{"evals/evals-freenode-#perlcafe.lst":[{"err":"","code":"/(?[()-!])/\n","out":"ERROR: Incomplete expression within '(?[ ])' in regex; marked by <-- HERE in m/(?[()-! <-- HERE ])/ at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"[0b1010 & 0b1000]\n","err":"","out":"[8]"},{"out":"[2016]","err":"","code":"[0b11111100000]\n"},{"out":"42.5833333333333","code":"1022/24\n","err":""},{"code":"(188982-183984)/1024\n","err":"","out":"4.880859375"},{"out":"[24]","code":"[20+4]\n","err":""},{"out":"[11]","err":"","code":"[5+6]\n"},{"out":"","code":"BEGIN(){i or$[}\n","err":""},{"code":"eval 'BEGIN(){i or$[}'\n","err":"","out":""},{"out":"[11]","code":"eval 'BEGIN(){i or$[}'; [5+6]\n","err":""},{"out":"NaN","code":"($inf, $neginf, $nan) = (9**9**9, -9**9**9, -sin(9**9**9)); use List::Util qw/max/; max(1.0, $nan)\n","err":""},{"err":"","code":"($inf, $neginf, $nan) = (9**9**9, -9**9**9, -sin(9**9**9)); use List::Util qw/max/; max($nan, 1.0)\n","out":"1"},{"out":"[2097152,4096,4096,65024,122624]","err":"","code":"[map {$_->[1] * 2 ** (32-$_->[0])} ([11, 1], [21, 2], [22, 4], [23, 127], [24, 479])]\n"},{"code":"my $line = \"This is my line.\"; $line;\n","err":"","out":"This is my line."},{"err":"","code":"my $string = 'I<Literature|^hardcover^>'; if ($string ~= /I\\<(.+)\\|(.+)\\>/) { \"<i $2>$1</i>\"} else { \"fail\" }\n","out":"ERROR: syntax error at (eval 1) line 1, near \"$string ~\"\n"},{"err":"","code":"my $string = 'I<Literature|^hardcover^>'; if ($string =~ /I\\<(.+)\\|(.+)\\>/) { \"<i $2>$1</i>\"} else { \"fail\" }\n","out":"<i ^hardcover^>Literature</i>"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"$2>\"\n","err":"","code":"my $string = 'I<Literature|^hardcover^> Other text'; $string =~ /I\\<(.+)\\|(.+)\\>/<i $2>$1<\\/i>/; $string;\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"\\>\"\n","err":"","code":"my $string = 'I<Literature|^hardcover^> Other text'; $string =~ /I\\<(.+)\\|(.+)\\>/<i $2\\>$1<\\/i>/; $string;\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"}]\"\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n","err":"","code":"my $x = [{z => \\{foo=>1}]; $x;\n"},{"out":"[{z => \\{foo => 1}}]","code":"my $x = [{z => \\{foo=>1}}]; $x;\n","err":""},{"code":"my $x = [{z => \\{foo=>1}}]; $x->[0]{z}->$*;\n","err":"","out":"{foo => 1}"},{"out":"","code":"pack('V' . 99999990);\n","err":"Out of memory!\npanic: fold_constants JMPENV_PUSH returned 2, <STDIN> line 1.\n"},{"err":"","code":"say \"Hello libreman.\"\n","out":"Hello libreman.\n"},{"out":"0","code":"tan(0)\n","err":""},{"err":"","code":"use experimental 'signatures'; sub rindolf($message) {print \"There's a message for you sire: \", $message}; rindolf(\"HI!\");\n","out":"There's a message for you sire: HI!"},{"err":"","code":"use List::Util qw/reduce/; reduce {$a + $b} map {$_->[1] * 2 ** (32-$_->[0])} ([11, 1], [21, 2], [22, 4], [23, 127], [24, 479])\n","out":"2292992"},{"err":"","code":"use List::Utils qw/reduce/; reduce {$a + $b} map {$_->[1] * 2 ** (32-$_->[0])} ([11, 1], [21, 2], [22, 4], [23, 127], [24, 479])\n","out":"ERROR: Can't locate List/Utils.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use POSIX; [POSIX::cot(0)]\n","out":"ERROR: cot is not a valid POSIX macro at (eval 1) line 1\n"},{"err":"","code":"use POSIX; [POSIX::tan(0)]\n","out":"[0]"},{"code":"use strict; use warnings; my $sub = sub { print \"Hello world\\n\" }; &$sub;\n","err":"","out":"Hello world\n"},{"code":"use strict; use warnings; my $sub = sub { print 'Hello world'; }; $sub;\n","err":"","out":"sub { \"DUMMY\" }"},{"err":"","code":"$x[()[()]]\n","out":""}],"evals/evals-freenode-#perl-cats.lst":[{"out":"0","err":"","code":"\"0.0\"+0 ? 1 : 0\n"},{"code":"\"0.0\" ? 1 : 0\n","err":"","out":"1"},{"code":"0.0 ? 1 : 0\n","err":"","out":"0"},{"code":"\"0e0\"+\"0e0\" ? 1 : 0\n","err":"","out":"0"},{"out":"1","code":"\"0e0\" ? 1 : 0\n","err":""},{"out":"0","err":"","code":"0e0 ? 1 : 0\n"},{"code":"0xffff == 0b1111111111111111\n","err":"","out":"1"},{"code":"1\n","err":"","out":"1"},{"out":"1","code":"\"1\"\n","err":""},{"code":"1/0\n","err":"","out":"ERROR: Illegal division by zero at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"1","code":"1.0 == 3.0/2.999999999999999999999999999999999999999999999\n","err":""},{"code":"1.0 == 3.0/3.0\n","err":"","out":"1"},{"err":"","code":"[20+4]\n","out":"[24]"},{"code":"BEGIN { package v5::Please; $INC{'v5/Please.pm'} = 1; sub import { print q[OK] } }; use v5::Please;\n","err":"","out":"OK"},{"out":"","code":"BEGIN { package v5::Please; $INC{'v5/Please.pm'} = 1; sub import { q[OK] } }; use v5::Please;\n","err":""},{"err":"","code":"{foo => 1, foo => 2}\n","out":"{foo => 2}"},{"out":"3","err":"","code":"($inf, $neginf, $nan) = (9**9**9, -9**9**9, -sin(9**9**9))\n"},{"err":"","code":"($inf, $neginf, $nan) = (9**9**9, -9**9**9, -sin(9**9**9)); $nan\n","out":"NaN"},{"out":"NaN","code":"($inf, $neginf, $nan) = (9**9**9, -9**9**9, -sin(9**9**9)); use List::Util qw/max/; max(1.0, $nan)\n","err":""},{"out":"1","err":"","code":"($inf, $neginf, $nan) = (9**9**9, -9**9**9, -sin(9**9**9)); use List::Util qw/max/; max($nan, 1.0)\n"},{"out":"30","err":"","code":"length \"America/Argentina/Buenos_Aires\"\n"},{"out":"47","err":"","code":"length qq{{\"customer_id\":114631,\"survey_id\":485,\"ttl\":10}};\n"},{"code":"length \"\\t->alloc called: 12345678 12345678 12345 12345\"\n","err":"","out":"46"},{"err":"","code":"my $a = [0]; sub foo {my $b = shift; return \\$b->[0]}; foo $a\n","out":"\\0"},{"code":"my $a = [0]; sub foo {my $b = shift; return \\$b->[0]}; ${foo $a} = 1; $a\n","err":"","out":"[1]"},{"err":"","code":"my @a = qw/a 1 b 2 c 3/; ${@a}->{a};\n","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"my @a = qw/a 1 b 2 c 3/; {@A}->{a}\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"}->\"\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"}->\"\n","code":"my @a = qw/a 1 b 2 c 3/; {+@A}->{a}\n","err":""},{"out":"","code":"my @a = qw/a 1 b 2 c 3/; ${+@A}{a}\n","err":""},{"err":"","code":"my @a = qw/a 1 b 2 c 3/; my $h = {@a}; $h\n","out":"{b => 2,c => 3,a => 1}"},{"code":"my @a = qw/a 1 b 2 c 3/; my $h = {@A}; $h\n","err":"","out":"{}"},{"err":"","code":"my $b = []; $a = \\$b;  $$a = []; $a = $$a; $a = []; $b\n","out":"[]"},{"err":"","code":"my($this)=qw(viogel$pviT$vilxsre$xwyN); my(@arr)=split(//,$this);  foreach(reverse(@arr)){ print(chr(ord($_)-(1<<2))); } print \"\\n\";\n","out":"Just another Perl hacker\n"},{"out":"ÃÂ","err":"","code":"\"\\N{NEL}\"\n"},{"err":"","code":"\"\\N{PILE OF POO}\"\n","out":"ÃÂ°ÃÂÃÂÃÂ©"},{"out":"ÃÂ¢ÃÂÃÂ","code":"\"\\N{SNOWMAN}\"\n","err":""},{"out":"pi","err":"","code":"pi\n"},{"err":"","code":"print \"foo\" if (+{});\n","out":"foo"},{"code":"print \"foo\" if (keys %{+{}});\n","err":"","out":"0"},{"code":"print qÍ¾This is a test;;\n","err":"","out":"ERROR: Can't find string terminator \"ÃÂ\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"[quotemeta \"\\n\"]\n","out":"[\"\\\\\\n\"]"},{"out":"\\\n","err":"","code":"quotemeta \"\\n\"\n"},{"out":"[\"\\\\\\n\"]","code":"[quotemeta \"\\n\" =~ s/\\\\\\n/\\n/gr]\n","err":""},{"out":"00001101","code":"sprintf \"%08b\", 015  # dick\n","err":""},{"err":"","code":"sprintf('0x%x', 0b1111111111111111)\n","out":"0xffff"},{"out":"    1101","err":"","code":"sprintf \"%8b\", 015\n"},{"out":"$VAR1 = [\n          'main'\n        ];\n$VAR2 = 'main::boo';\n","code":"sub AUTOLOAD {Dumper(\\@_, $AUTOLOAD)}; my $foo = \"boo\"; __PACKAGE__->$foo\n","err":""},{"err":"","code":"sub AUTOLOAD {Dumper(\\@_, $AUTOLOAD}; my $foo = \"boo\"; __PACKAGE__->$foo\n","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"->\"\"\"\n","err":"","code":"sub AUTOLOAD {Dumper(\\@_, $AUTOLOAD)}; my $foo = \"\"; __PACKAGE__->\"\"\n"},{"code":"sub AUTOLOAD {Dumper(\\@_, $AUTOLOAD)}; my $foo = \"\"; __PACKAGE__->(\"foo\")\n","err":"","out":"$VAR1 = [\n          'foo'\n        ];\n$VAR2 = 'main::main';\n"},{"out":"$VAR1 = [\n          'main'\n        ];\n$VAR2 = 'main::';\n","err":"","code":"sub AUTOLOAD {Dumper(\\@_, $AUTOLOAD)}; my $foo = \"\"; __PACKAGE__->$foo\n"},{"out":"$VAR1 = 'main';\n","err":"","code":"sub AUTOLOAD {Dumper@_}; my $foo = \"boo\"; __PACKAGE__->$foo\n"},{"out":"$VAR1 = 'main';\n","err":"","code":"sub AUTOLOAD {Dumper@_}; my $foo = \"\"; __PACKAGE__->$foo\n"},{"out":"ERROR: Can't locate CGI.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use CGI;\n"},{"out":"ERROR: Can't enable unknown feature signature at (eval 1) line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use experimental 'signature';\n"},{"err":"","code":"use experimental 'signatures';\n","out":""},{"out":"hola hoops hola hoops ","code":"use experimental 'signatures'; sub foo($bar) {print $bar, $bar}; foo(\"hola hoops \");\n","err":""},{"err":"","code":"use JSON::MaybeXS; JSON->decode(q/{\"foo\": undefined, \"bar\": null}/)\n","out":"ERROR: object is not of type Cpanel::JSON::XS at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: malformed JSON string, neither tag, array, object, number, string or atom, at character offset 8 (before \"undefined, \"bar\": nu...\") at (eval 1) line 1, <STDIN> line 1.\n","code":"use JSON::MaybeXS; JSON->new()->decode(q/{\"foo\": undefined, \"bar\": null}/)\n","err":""},{"code":"use strict; my @foo; my $x = $foo[1];\n","err":"","out":""},{"out":"[1]","err":"Argument \"bar\" isn't numeric in array element at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my @x; $x['bar'] = 1; [@x]\n"},{"out":"ERROR: Unrecognized character \\x{37e}; marked by <-- HERE after e utf8; *\"<-- HERE near column 103 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use utf8; *\"Í¾\" = {\"Hello World\"};\n"},{"code":"use utf8; my $ð«=\"hi\";\n","err":"","out":"ERROR: Unrecognized character \\x{1f62b}; marked by <-- HERE after utf8; my $<-- HERE near column 105 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't find string terminator \"ÃÂ\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use utf8; print qÍ¾This is a test;;\n"},{"out":"ERROR: Unrecognized character \\x{37e}; marked by <-- HERE after se utf8; *<-- HERE near column 102 at (eval 1) line 1, <STDIN> line 1.\n","code":"use utf8; *Í¾ = sub {\"Hello World\"};\n","err":""},{"code":"use utf8; sub Í¾ {\"Hello World\"};\n","err":"","out":"ERROR: Illegal declaration of anonymous subroutine at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"\"â-\\x{0305}1 2Â³ âÏ and it was really strange\"\n","err":"","out":"ÃÂÃÂ¢ÃÂÃÂÃÂÃÂ-ÃÂÃÂ1 2ÃÂÃÂÃÂÃÂ³ ÃÂÃÂ¢ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ and it was really strange"},{"code":"\"â-\\x{0305}1\\x{0305} 2Â³ âÏ and it was really strange\"\n","err":"","out":"ÃÂÃÂ¢ÃÂÃÂÃÂÃÂ-ÃÂÃÂ1ÃÂÃÂ 2ÃÂÃÂÃÂÃÂ³ ÃÂÃÂ¢ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ and it was really strange"},{"err":"","code":"\"â-\\x{035E}1 2Â³ âÏ and it was really strange\"\n","out":"ÃÂÃÂ¢ÃÂÃÂÃÂÃÂ-ÃÂÃÂ1 2ÃÂÃÂÃÂÃÂ³ ÃÂÃÂ¢ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ and it was really strange"},{"out":"ÃÂ¢ÃÂÃÂ-\u00035E1 2ÃÂÃÂ³ ÃÂ¢ÃÂÃÂÃÂÃÂ and it was really strange","err":"","code":"\"â-\\x035E1 2Â³ âÏ and it was really strange\"\n"},{"out":"ÃÂÃÂ¢ÃÂÃÂÃÂÃÂ-ÃÂ¢ÃÂÃÂ¾1 2ÃÂÃÂÃÂÃÂ³ ÃÂÃÂ¢ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ and it was really strange","code":"\"â-\\x{203E}1 2Â³ âÏ and it was really strange\"\n","err":""},{"out":"ÃÂÃÂ¢ÃÂÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂÃÂ1ÃÂÃÂ 2ÃÂÃÂÃÂÃÂ³ ÃÂÃÂ¢ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ and it was really strange","code":"\"â\\x{2212}\\x{0305}1\\x{0305} 2Â³ âÏ and it was really strange\"\n","err":""},{"out":"ÃÂ","err":"","code":"\"\\x85\"\n"}],"evals/evals-freenode-#perl.lst":[{"out":"18446744073709551615","err":"","code":"~-~()\n"},{"code":" [ \"(\" =~ /[(]/ ]\n","err":"","out":"[1]"},{"err":"","code":" [ \"]\" =~ /[\\]]/ ]\n","out":"[1]"},{"err":"","code":"- - _\n","out":"+_"},{"out":"+","code":"- '-'\n","err":""},{"err":"","code":"-{}\n","out":"-72577072"},{"out":"","err":"","code":";;\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"; :\"\n","err":"","code":":)\n"},{"err":"","code":"?\n","out":"ERROR: syntax error at (eval 1) line 1, near \"; ?\"\n"},{"code":"?^?\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"; ?\"\n"},{"out":"1","code":"/^+/\n","err":""},{"out":"","err":"","code":"/[^]]/\n"},{"out":"ERROR: Unmatched [ in regex; marked by <-- HERE in m/[ <-- HERE / at (eval 1) line 1, <STDIN> line 1.\n","code":"/[/\n","err":""},{"err":"","code":"/${#}/\n","out":"1"},{"code":"/$#/\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"; /$#/\"\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"; /$#/\"\n","err":"","code":"/$#//\n"},{"err":"","code":"/**/\n","out":"ERROR: Quantifier follows nothing in regex; marked by <-- HERE in m/* <-- HERE */ at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Unimplemented at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"...\n"},{"code":"'^\\/\\/'\n","err":"","out":"^\\/\\/"},{"out":"1","err":"","code":"'=' =~ /=/\n"},{"out":"","code":"''\n","err":""},{"out":"d","code":"'@' ^ '$'\n","err":""},{"err":"","code":"\"\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"\"'\" =~ /'/\n","out":"1"},{"code":"\"\"->()\n","err":"","out":"ERROR: Undefined subroutine &main:: called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"1","err":"","code":"\"[\" =~ /[[]/\n"},{"code":"\"$_\"\n","err":"","out":""},{"out":"65534 65534 65534 65534","code":"\"$( $)\"\n","err":""},{"code":"\"${}\"\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"${}\"\n"},{"err":"","code":"\"\\\"\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"\"\\[\"\n","err":"","out":"["},{"out":"ÃÂ¢ÃÂÃÂ","err":"","code":"\"â\"\n"},{"code":"\"ã»ã\"\n","err":"","out":"ÃÂ£ÃÂÃÂ»ÃÂ£ÃÂÃÂ"},{"code":"();\n","err":"","out":""},{"err":"","code":"[~~( )]\n","out":"[\"\"]"},{"out":"[1]","code":"[ !() ]\n","err":""},{"out":"[\"[ \\@_ ]\"]","err":"","code":"[ @_ ]\n"},{"out":"[1]","code":"[ $| ]\n","err":""},{"code":"[ â´ ]\n","err":"","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after tures/; [ <-- HERE near column 93 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"['\n","err":""},{"out":"[\"\"]","err":"","code":"['']\n"},{"out":"[\"\"]","err":"","code":"[\"\"]\n"},{"out":"[]","code":"[]\n","err":""},{"out":"","code":"[] == []\n","err":""},{"err":"","code":"[@_]\n","out":"[\"[\\@_]\"]"},{"out":"[1,0,1,0]","err":"","code":"[$|--, $|--, $|--, $|--]\n"},{"err":"","code":"[$_]\n","out":"[undef]"},{"out":"[undef,\"\\34\"]","err":"","code":"[$,, $;]\n"},{"out":"[\"\\34\"]","code":"[$;]\n","err":""},{"code":"[$\"]\n","err":"","out":"[\" \"]"},{"err":"","code":"[$[]\n","out":"[0]"},{"err":"","code":"[$@]\n","out":"[\"\"]"},{"code":"[++$|, ++$|, --$|, --$|]\n","err":"","out":"[1,1,1,1]"},{"out":"[1,1]","code":"[++$|, ++$|]\n","err":""},{"code":"[++$|; ++$|]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, near \"$|]\"\n"},{"code":"{;} + {}\n","err":"","out":"{}"},{"code":"{} {}\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"} {\"\n"},{"err":"","code":"@_\n","out":"1"},{"out":"0","err":"","code":"@{ [] } // []\n"},{"code":"@{[]}=()\n","err":"","out":"0"},{"code":"@#\n","err":"","out":"0"},{"out":"","err":"","code":"@#{ [] }\n"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","err":"","code":"$\n"},{"err":"","code":"$^_^$;;\n","out":"\u001c"},{"code":"$_ = '\n","err":"","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"$;\n","err":"","out":"\u001c"},{"err":"","code":"$!\n","out":"Too many open files"},{"err":"","code":"$!->()\n","out":"ERROR: Undefined subroutine &main::Too many open files called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"0","err":"","code":"$?\n"},{"code":"$\"\n","err":"","out":" "},{"out":" ","code":"$\";\n","err":""},{"out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"$[++\n"},{"out":"","err":"","code":"$@\n"},{"out":"","err":"","code":"$#\n"},{"err":"","code":"$%\n","out":"0"},{"err":"","code":"*_\n","out":"*main::_"},{"err":"","code":"*{\"\"}\n","out":"*main::"},{"err":"","code":"*{}\n","out":"ERROR: syntax error at (eval 1) line 1, near \"*{\"\n"},{"out":"\\{}","err":"","code":"\\{}\n"},{"out":"[\"\\\\\\@_\"]","err":"","code":"\\@_\n"},{"out":"[]","err":"","code":"\\@.\n"},{"err":"","code":"\\$_\n","out":"\\undef"},{"out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after natures/; <-- HERE near column 91 at (eval 1) line 1, <STDIN> line 1.\n","code":"â\n","err":""},{"err":"","code":"~0\n","out":"18446744073709551615"},{"code":"!0\n","err":"","out":"1"},{"code":"!!0\n","err":"","out":""},{"code":"\"\\0\"\n","err":"","out":"\u0000"},{"err":"","code":"[~~\"0\"]\n","out":"[0]"},{"out":"['18446744073709551615']","err":"","code":"[~0]\n"},{"out":"[\"\"]","code":"[ !!0 ]\n","err":""},{"code":"[ \"\"{}, 0+{} ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"\"\"{\"\n"},{"err":"","code":"[ 0 + 'â´' ]\n","out":"[0]"},{"out":"[24,\"Too many open files\"]","err":"","code":"[ 0 + $!, \"$!\" ]\n"},{"err":"","code":"[!!\"0\"]\n","out":"[\"\"]"},{"out":"[0,1,2,3,4,5,6,7,8,9]","code":"['0' .. ':']\n","err":""},{"err":"","code":"[\"\\0\"]\n","out":"[\"\\0\"]"},{"out":"/home/ryan/bots/perlbuut/lib/eval.pl","err":"","code":"$0\n"},{"out":"1","err":"","code":"$_ = '0'; $_++; $_\n"},{"out":"$_[0]","err":"","code":"$_[0]\n"},{"code":"\\0\n","err":"","out":"\\0"},{"code":"0!\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"0!\"\n"},{"code":"0+[]\n","err":"","out":"64491568"},{"out":"56315952","err":"","code":"0+{}\n"},{"out":"1","code":"!!'0.0'\n","err":""},{"out":"[0]","code":"[ (!!0) + 0 ]\n","err":""},{"out":"[1]","err":"","code":"[(0 ** 0)]\n"},{"err":"","code":"$0->[0]\n","out":""},{"code":"0 ^ 0\n","err":"","out":"0"},{"out":"1","code":"0 == 0\n","err":""},{"code":"0->[0]\n","err":"","out":""},{"out":"ERROR: Illegal division by zero at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"0/0\n"},{"out":"1","code":"0**0\n","err":""},{"out":"ERROR: Unrecognized character \\xC2; marked by <-- HERE after ures/; 0+ <-- HERE near column 94 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"0+ Â½\n"},{"out":"0","err":"","code":"0+'Â½'\n"},{"err":"","code":"$_ = '000'; $_++; $_\n","out":"001"},{"code":"&{0 == &{0 == 0}} * 0\n","err":"","out":"0"},{"out":"foo","err":"","code":"\"000000\" && \"foo\";\n"},{"out":"[\"0.0002\"]","err":"","code":"[ 0.00_02 ]\n"},{"code":"[\"0.00_02\" + 0]\n","err":"","out":"[0]"},{"out":"00:02:02:05:6D:4C","code":"'000202056D4C' =~ s/..\\K\\B/:/gr\n","err":""},{"out":"","code":"0+!! 0==1\n","err":""},{"out":"0","code":"(001234 ^ 01234) =~ /(^\\0*)/; length $1\n","err":""},{"err":"","code":"0+!!(0==1) # what I probably meant\n","out":"0"},{"out":"1","err":"","code":"'008' == 8\n"},{"out":"['18446744073709551615',\"18,446,744,073,709,551,615\"]","code":"[ ~0, ~0 =~ s/(?=(\\d{3})+$)/,/gr ]\n","err":""},{"err":"","code":"\"00\" ? \"true\" : \"false\";\n","out":"true"},{"out":"[-32768]","code":"$_ = \"\\0\\0\"; vec($_, 7, 1)=1; [unpack \"s>\", $_]\n","err":""},{"out":"[0,0]","code":"[ 0 & 0xFF, 0 >> 8 & 0xFF ]\n","err":""},{"code":"~0 + 1\n","err":"","out":"1.84467440737096e+19"},{"out":"1","err":"","code":"\"0\" | \"1\"\n"},{"code":"[0,1]\n","err":"","out":"[0,1]"},{"code":"$_ = '0.1'; $_++; $_\n","err":"","out":"1.1"},{"err":"","code":"0/1\n","out":"0"},{"code":"~0 + 1 > ~0\n","err":"","out":""},{"code":"[0?1:0,0e0?1:0]\n","err":"","out":"[0,0]"},{"out":"[0,0]","err":"","code":"[0?1:0,0E0?1:0]\n"},{"out":"1","err":"","code":"[0, '1'] ~~ [0, 1]\n"},{"err":"","code":"\"010\" ~~ [ 10 ]\n","out":"1"},{"out":"[\"0.3\",\"n\"]","code":"[ 0.1 + 0.2, ((0.1 + 0.2) == 0.3) ? 'y' : 'n' ] #weird\n","err":""},{"out":"6","err":"","code":"((\"010\"+2)/(010+2))*5\n"},{"out":"5.55111512312578e-17","err":"","code":"0.1 + 0.2 - 0.3\n"},{"out":"64","code":"~0 + 1 == ~0 ? 64 : 32\n","err":""},{"out":"1","code":"0 + \"1+1\"\n","err":""},{"err":"","code":"[ \"01101000 01100101 01101100 01110000\" =~ /\\d+/g ]; ### ZoffixWeb, why does it return an array when \\d+ isn't in a capture group?\n","out":"[\"01101000\",\"01100101\",\"01101100\",\"01110000\"]"},{"out":"1","err":"","code":"\"011112233\" =~ /^0[0-9]*\\s*\\z/\n"},{"code":"01.23\n","err":"","out":"123"},{"err":"","code":"01.23 >= 2.34 ? \"greater or equal\" : \"nope\"\n","out":"greater or equal"},{"out":"1","code":"\"0123456\" ~~ 123_456\n","err":""},{"out":"01:23:45:67:89:1b","err":"","code":"'01234567891b' =~ s/(..)(?!$)/$1:/gr\n"},{"err":"","code":"'01234567891b' =~ s/..\\K\\B/:/gr\n","out":"01:23:45:67:89:1b"},{"err":"","code":"[ \"-0123456789abcdefghi\" =~ /[[:xdigit:]]/g ]\n","out":"[0,1,2,3,4,5,6,7,8,9,\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]"},{"err":"","code":"$_ = \"\\0\\1\\2\"; s/([\\x00-\\x1f])/\"\\x{2400}\" | $1/eg; $_\n","out":"ÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂ"},{"out":"\\\"\\x{2400}\\x{2401}\\x{2402}\"","code":"$_ = \"\\0\\1\\2\"; s/([\\x00-\\x1f])/\"\\x{2400}\" | $1/eg; \\$_\n","err":""},{"err":"","code":"\"0\" | \"1.5\"\n","out":"1.5"},{"err":"","code":"[ 0 .. 15 ]\n","out":"[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]"},{"err":"","code":"[\"0\" | \"1.5\"]\n","out":"[\"1.5\"]"},{"out":"0","err":"","code":"(0)*150\n"},{"out":"1023","err":"","code":"01777\n"},{"out":"ERROR: Unrecognized character \\xC2; marked by <-- HERE after tures/; [ <-- HERE near column 93 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"[ Â¡!0, Â¡!1 ] # this might not \"work\", for example\n"},{"code":"~0 + 2\n","err":"","out":"1.84467440737096e+19"},{"err":"","code":"$#{[0..2]}\n","out":"2"},{"out":"1","code":"~0 * 2 > ~0\n","err":""},{"err":"","code":"02/03/04\n","out":"0.166666666666667"},{"out":"[5,10,3]","err":"","code":"[@{[0 .. 20]}[5,10,3]]\n"},{"out":"[17,15,13,11,9,\"Illegal octal digit '9' at (eval 1) line 1, at end of line\\n\"]","code":"[ 021, 017, 015, 013, 011, eval \"09\" || $@ ]\n","err":""},{"code":"025\n","err":"","out":"21"},{"code":"0 % -3\n","err":"","out":"0"},{"out":"[194,173]","err":"","code":"[ 0302, 0255 ]\n"},{"err":"","code":"031\n","out":"25"},{"code":"[0320, 0230]\n","err":"","out":"[208,152]"},{"err":"","code":"\"\\034\"\n","out":"\u001c"},{"out":"255","code":"0377\n","err":""},{"out":"1","err":"","code":"'03' lt '7'\n"},{"code":"[0 .. 4]\n","err":"","out":"[0,1,2,3,4]"},{"out":"[42]","err":"","code":"[ 0 || 42 ]\n"},{"code":"0 // 42\n","err":"","out":"0"},{"out":"292","err":"","code":"0444\n"},{"out":"0.45","code":"0.45\n","err":""},{"code":"[ 0.5, 0 .5, 0 . 5 ]\n","err":"","out":"[\"0.5\",\"05\",\"05\"]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"0. 5\"\n","err":"","code":"[ 0.5, 0. 5, 0 .5, 0 . 5 ]\n"},{"out":"[\"0.64\",\"0.68\",\"0.72\"]","err":"","code":"[0.6 + 0.04, 0.64 + 0.04, 0.68 + 0.04]\n"},{"code":"0734\n","err":"","out":"476"},{"out":"1","err":"","code":"!! \"0/8\"\n"},{"err":"","code":"0+'    9'\n","out":"9"},{"code":"0.99999999999929\n","err":"","out":"0.99999999999929"},{"err":"","code":"0.9999999999999\n","out":"0.9999999999999"},{"err":"","code":"0.99999999999999\n","out":"0.99999999999999"},{"code":"0.9999999999999901\n","err":"","out":"0.99999999999999"},{"out":"","code":"0.9999999999999901 > 0.99999999999999\n","err":""},{"out":"1","err":"","code":"0.9999999999999902 > 0.99999999999999\n"},{"err":"","code":"0.9999999999999919 > 0.9999999999999918\n","out":"1"},{"err":"","code":"$_ = \"0.9999999999999926\"; sprintf '%.*f', length, $_\n","out":"0.999999999999992562"},{"out":"0.999999999999992784","err":"","code":"$_ = \"0.9999999999999927\"; sprintf '%.*f', length, $_\n"},{"out":"[\"\",1]","err":"","code":"[ 0.999999999999999 == 1, 0.9999999999999999 == 1]\n"},{"code":"0b1_10010010\n","err":"","out":"402"},{"out":"3","code":"0b111 >> 1\n","err":""},{"err":"","code":"0b11111\n","out":"31"},{"code":"[ 0b11111, oct(\"31\") ]\n","err":"","out":"[31,25]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"0bPortalMeme\n\"\n","code":"0bPortalMeme\n","err":""},{"out":"1","err":"","code":"\"0 but true\" + 1\n"},{"out":"true","code":"'0 but true' ? 'true' : 'false'\n","err":""},{"out":"Only perl can parse Perl!","code":"'0BZMNDSFZNQOBNDOFGSN1SFZ!' =~ tr/\\\"-;N-ZA-M/A-Z a-z/r\n","err":""},{"err":"","code":"'0BZMNDSFZNQOBNDOFGSN1SFZ!' =~ tr/\\\"-;N-ZA-M/A-Z a-z/r;\n","out":"Only perl can parse Perl!"},{"out":"1","code":"0E0 eq 0\n","err":""},{"out":"true","err":"","code":"'0e0' ? 'true' : 'false'\n"},{"code":"\"0e0\" ? \"true\" : \"false\"\n","err":"","out":"true"},{"out":"false","err":"","code":"0e0 ? 'true' :'false'\n"},{"code":"0e0 ? \"true\" : \"false\"\n","err":"","out":"false"},{"out":"0","err":"","code":"'0' && 'foo'\n"},{"out":"0","err":"","code":"0 if 1\n"},{"out":"0","code":"0=~m{}=~y///d\n","err":""},{"code":"0o734\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"0o734\n\"\n"},{"code":"0;qq{@{sub{]]}}}}}\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"{]\"\nUnmatched right curly bracket at (eval 1) line 1, at end of line\nUnmatched right curly bracket at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, at EOF\n"},{"err":"","code":"[\"\\0\" ? \"T\" : \"F\"]\n","out":"[\"T\"]"},{"out":"[\"f\",\"f\"]","code":"[ 0?'t':'f', 00?'t':'f' ]\n","err":""},{"out":"[1]","code":"[ 0 == true ]\n","err":""},{"out":"false","err":"","code":"0 ? 'true' : 'false'\n"},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"[ (0 == true) ? \"true\" : \"false ];\n"},{"code":"[ (0 == true) ? \"true\" : \"false\" ];\n","err":"","out":"[\"true\"]"},{"code":"\"0\" == undef\n","err":"","out":"1"},{"code":"[ !!0, !!\"\", !!undef ]\n","err":"","out":"[\"\",\"\",\"\"]"},{"out":"","err":"","code":"$_[ ~0 ] = undef\n"},{"err":"","code":"0 == undef\n","out":"1"},{"err":"","code":"[ !0, !'', !undef, !'0' ]\n","out":"[1,1,1,1]"},{"err":"","code":"'<0x000D>' =~ s/<0x(....)>/\"\\N{U+$1}\"/er\n","out":"ERROR: Invalid hexadecimal number in \\N{U+...} at (eval 1) line 1, within string\n"},{"code":"\"<0x000D>\" =~ s/<(0x[[:xdigit:]]{4})>/chr hex $1/ger\n","err":"","out":"\r"},{"out":"4","err":"","code":"\"<0x0034>\" =~ s/<(0x[[:xdigit:]]{4})>/chr hex $1/ger\n"},{"err":"","code":"0x00FF\n","out":"255"},{"err":"","code":"0x011b;\n","out":"283"},{"out":"3","err":"","code":"0x03 & 0x07f\n"},{"out":"","code":"0x0x0x0\n","err":""},{"out":"0","err":"","code":"\"0x10\" + 0\n"},{"err":"","code":"[0x110000, 2**20 + 2**16]\n","out":"[1114112,1114112]"},{"out":"123","code":"0x1.23\n","err":""},{"out":"1194684","code":"0x123abc\n","err":""},{"out":"1.13671875","code":"0x1.23p0\n","err":""},{"out":"4690","err":"","code":"0x1252\n"},{"code":"0x173\n","err":"","out":"371"},{"code":"[0x173, unpack(\"n\", \"\\x01\\x73\"), unpack(\"v\", \"\\x73\\x01\")]\n","err":"","out":"[371,371,371]"},{"code":"[0x18, 0x12]\n","err":"","out":"[24,18]"},{"code":"0x1a\n","err":"","out":"26"},{"err":"","code":"0x1p-10\n","out":"0.0009765625"},{"out":"ERROR: Invalid hexadecimal number in \\N{U+...} at (eval 1) line 1, within string\n","err":"","code":"'<0x2004>' =~ s/<0x(....)>/\"\\N{U+$1}\"/er\n"},{"out":"51","err":"","code":"0x33 & 0x7f\n"},{"out":"945","err":"","code":"0x3b1\n"},{"out":"4","err":"","code":"0x4\n"},{"out":"16384","code":"0x4000\n","err":""},{"out":"0x4000","err":"","code":"\"0x4000\"\n"},{"err":"","code":"0x41\n","out":"65"},{"out":"","err":"","code":"0x4x0\n"},{"out":"33","code":"0x61 & 0x31\n","err":""},{"out":"[29184,7471104]","err":"","code":"[0x7200, 0x720000]\n"},{"code":"0xC0 & 0x7f\n","err":"","out":"64"},{"out":"[195,168]","err":"","code":"[0xc3, 0xa8]\n"},{"out":"13626846","err":"","code":"0xcfedde\n"},{"out":"13626846","err":"","code":"0xCFEDDE\n"},{"err":"","code":"0xDFEDDE\n","out":"14675422"},{"out":"255","err":"","code":"0xFF\n"},{"err":"","code":"0xFF & 0x07F\n","out":"127"},{"out":"281462092005375","code":"0xffff**3\n","err":""},{"err":"","code":"0 xor 0\n","out":""},{"code":"[ [0 xor 0], [1 xor 0], [0 xor 1], [1 xor 1] ]\n","err":"","out":"[[\"\"],[1],[1],[\"\"]]"},{"out":"[1]","err":"","code":"[ 0 xor 0, 1 xor 0, 0 xor 1, 1 xor 1 ]\n"},{"out":"1","err":"","code":"0 xor 1\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"0xpink_mist\n\"\n","code":"0xpink_mist\n","err":""},{"code":"!0=~y///d\n","err":"","out":"0"},{"out":"1","err":"","code":"1\n"},{"code":"~1\n","err":"","out":"18446744073709551614"},{"out":"ERROR: Switch (?(condition)... not terminated in regex; marked by <-- HERE in m/(?(1) <-- HERE / at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"/(?(1)/\n"},{"code":"\"1\"\n","err":"","out":"1"},{"err":"","code":"[] != -1\n","out":"1"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"$ = 1\"\nsyntax error at (eval 1) line 1, at EOF\n","code":"$ = 1; ++$\n","err":""},{"out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 1) line 1, <STDIN> line 1.\n","code":"$[ = 1\n","err":""},{"code":"1;\n","err":"","out":"1"},{"code":"1++\n","err":"","out":"ERROR: Can't modify constant item in postincrement (++) at (eval 1) line 1, near \"1++\"\n"},{"out":"10","err":"","code":"10\n"},{"code":"-1%~0\n","err":"","out":"18446744073709551614"},{"out":"\u0001","err":"","code":"'1' ^ '0'\n"},{"err":"","code":"1/0\n","out":"ERROR: Illegal division by zero at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"[ '1' + 0 ^ '0' ]\n","out":"[1]"},{"code":"100.\n","err":"","out":"100"},{"code":"100/0.0000003\n","err":"","out":"333333333.333333"},{"code":"100 * 10000000\n","err":"","out":"1000000000"},{"out":"0.2","err":"","code":"100./ 100./5\n"},{"code":"100. / 4\n","err":"","out":"25"},{"out":"3.16227766016838","code":"10 ** 0.5\n","err":""},{"out":"[]","err":"","code":"[ \"100.5\" =~ /([-+]?\\d+)(\\.\\d+)?\\s*(g|mg)/ ]\n"},{"err":"","code":"[ \"100.5 g\" =~ /([-+]?\\d+)(\\.\\d+)?\\s*(g|mg)/ ]\n","out":"[100,\".5\",\"g\"]"},{"err":"","code":"\"100.5 g\" =~ /([-+]?\\d+)(\\.\\d+)?\\s*(g|mg)/; [$1, $2, $3]\n","out":"[100,\".5\",\"g\"]"},{"code":"[ !1, !0, !1+0]\n","err":"","out":"[\"\",1,0]"},{"out":"[\"\",1]","code":"[ \"1.0\" != 1.0, \"1.0\" ne 1.0 ]\n","err":""},{"out":"10.123","code":"10.123\n","err":""},{"code":"101.97.114\n","err":"","out":"ear"},{"out":"f\u0000r\u0000o\u0000m","err":"","code":"102.0.114.0.111.0.109\n"},{"code":"1.0/2 + 1/4 + 1/8 + 2/16\n","err":"","out":"1"},{"err":"","code":"1024 >> 6\n","out":"16"},{"out":"1","code":"1.0 == 3.0/2.9999999999999999999999999999999999\n","err":""},{"out":"5","err":"","code":"(1 == 0) + 5\n"},{"err":"","code":"10/7\n","out":"1.42857142857143"},{"out":"9.70001856614999e-13","code":"1 - 0.99999999999903\n","err":""},{"err":"","code":"10e30\n","out":"1e+31"},{"out":"13","code":"10^length q|*******|\n","err":""},{"out":"[10,11]","code":"$. = 10; my ($what_you_think, $what_it_is) = ($.++,$.); [ $what_you_think, $what_it_is ]\n","err":""},{"err":"","code":"1/(0*nan/nan)\n","out":"NaN"},{"code":"'10%s' % 2\n","err":"","out":"0"},{"err":"","code":"'10%s' % 3\n","out":"1"},{"out":"11","err":"","code":"$. = 10; scalar($.++,$.)\n"},{"out":"[[10,\"\"],[11,\"\"],[12,\"\"],[13,\"\"],[14,\"\"],[15,\"\"]]","err":"","code":"$. = 10; [ [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ] ];\n"},{"out":"[[1,10],[\"\",11],[\"\",12],[\"\",13],[\"\",14],[\"\",15]]","err":"","code":"$. = 10; [ [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ] ]\n"},{"out":"10 11 12 13 14 15 ","code":"$. = 10; while (10..15) { print \"$. \"; $.++ }\n","err":""},{"out":"10 11 12 13 14 15 16 17 18 19 20 ","code":"$. = 10; while (10..20) { print \"$. \"; $.++ }\n","err":""},{"out":"9223372036854775807","code":"-1 >> 1\n","err":""},{"code":"[ 1 == \"1\" ]\n","err":"","out":"[1]"},{"out":"[\"1.1\"]","err":"","code":"[1.1]\n"},{"code":"$1$1\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"$1$1\n\"\n"},{"err":"","code":"1 ~~ '1'\n","out":"1"},{"out":"2","err":"","code":"1+1\n"},{"out":"2","code":"1+'1'\n","err":""},{"code":"[ (!!1) . '', (!!1) + 0 ]\n","err":"","out":"[1,1]"},{"code":"[() = (1..10)]\n","err":"","out":"[]"},{"err":"","code":"[1 .. 10]\n","out":"[1,2,3,4,5,6,7,8,9,10]"},{"out":"0.0909090909090909","err":"","code":"1/11\n"},{"out":"[1,1,1,0]","err":"","code":"[ 1 | 1, 1 | 0, 0 | 1, 0 | 0 ]\n"},{"out":"55","code":"\"111\" >> 1\n","err":""},{"code":"1111111 =~ /^(1{1,10})(1{1,10})(1{1,10})$(?{ push @comb, [$1, $2, $3] })(?!)/; [map [map length, @$_], @comb]\n","err":"","out":"[[5,1,1],[4,2,1],[4,1,2],[3,3,1],[3,2,2],[3,1,3],[2,4,1],[2,3,2],[2,2,3],[2,1,4],[1,5,1],[1,4,2],[1,3,3],[1,2,4],[1,1,5]]"},{"out":"27","code":"\"111\" >> 2\n","err":""},{"out":"[1,1,1,2,3]","code":"[ (1,1,(),((1,2),,,,,,,3)) ]\n","err":""},{"out":"0.846153846153846","code":"11/13\n","err":""},{"out":"0.733333333333333","code":"11/15;\n","err":""},{"out":"28416","code":"\"111\" << 8\n","err":""},{"out":"0","code":"\"111\" >> 8\n","err":""},{"code":"[ 1 << 1, 2 << 1, 3 << 1 ]\n","err":"","out":"[2,4,6]"},{"out":"22","err":"","code":"\"1122\" =~ s/\\d\\d(\\d\\d)??//r #let's try\n"},{"code":"\"1122\" =~ s/\\d\\d(\\d\\d)?//r #no, it's greedy, Iota\n","err":"","out":""},{"err":"","code":"$[ = -1; (1, 2, 3)[-2]\n","out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"-1 & 127 # piko` - at a guess you're just getting this, and perldoc -f system covers it\n","err":"","out":"127"},{"code":"{ 1+1 => 2, cats => 'dogs' }\n","err":"","out":"dogs"},{"out":"{cats => \"dogs\",2 => 2}","code":"+{ 1+1 => 2, cats => 'dogs' }\n","err":""},{"out":"0.769230769230769","code":"1/1.3\n","err":""},{"err":"","code":"1.139999999999999\n","out":"1.14"},{"code":"1 << 14\n","err":"","out":"16384"},{"out":"1","code":"'11' lt '7'\n","err":""},{"code":"[-1 .. -2]\n","err":"","out":"[]"},{"err":"","code":"[1,,,,,,2,,,,,,,]\n","out":"[1,2]"},{"out":"3","err":"","code":"1 + 2\n"},{"out":"3","err":"","code":"1+2\n"},{"out":"{1 => [21]}","err":"","code":"{ 1 => [21] }\n"},{"out":"1","code":"1/2 + 1/4 + 1/8 + 2/16\n","err":""},{"out":"1","code":"1./2 + 1/4 + 1/8 + 2/16\n","err":""},{"out":"match","err":"","code":"'12' =~ /1\\B2/ ? 'match' : 'nope'\n"},{"code":"[1<=>2, 2<=>2, 3<=>2]\n","err":"","out":"[-1,0,1]"},{"code":"[ \"1.22.333.4\" =~ /\\d+/g ]\n","err":"","out":"[1,22,333,4]"},{"code":"~~1.23\n","err":"","out":"1"},{"err":"","code":".1 + .2 - .3\n","out":"5.55111512312578e-17"},{"code":".1+.2-.3\n","err":"","out":"5.55111512312578e-17"},{"out":"","code":"(.1 + .2 == .3)\n","err":""},{"out":"3","code":"(1, 2, 3)\n","err":""},{"err":"","code":"(1+2==3)\n","out":"1"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"[ ,\"\n","err":"","code":"[ , 1 , 2 , 3 ]\n"},{"code":"[ \\(1, 2, 3) ]\n","err":"","out":"[\\1,\\2,\\3]"},{"out":"[\"\\1\\2\\3\"]","err":"","code":"[ 1.2.3 . \"\" ]\n"},{"out":"123","err":"","code":"\"123\" & 0x00FF;\n"},{"out":"[1,2,2,3]","code":"[ %{[ 1, 2, 3 ]}[ 1,2 ] ]\n","err":""},{"out":"1","code":"123 == '123abc  '\n","err":""},{"code":"(1,2,3)[1.5]\n","err":"","out":"2"},{"out":"[\"1.2.3.19\"]","err":"","code":"[ \"1.2.3.192/26\" =~ /((?:\\d{1,3}\\.){3}\\d{1,3})(?!\\/)/ ]\n"},{"code":"[ \"1.2.3.192/26\" =~ /((?:\\d{1,3}\\.){3}\\d{1,3})(?!\\/))/ ]\n","err":"","out":"ERROR: Unmatched ) in regex; marked by <-- HERE in m/((?:\\d{1,3}\\.){3}\\d{1,3})(?!/)) <-- HERE / at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"[ \"1.2.3.192/26\" =~ ((?:\\d{1,3}\\.){3}\\d{1,3})(?!\\/) ]\n","out":"ERROR: Search pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"\"@{[1 2 3 4]}\"\n","out":"ERROR: syntax error at (eval 1) line 1, near \"1 2\"\n"},{"err":"","code":"\"@{[1, 2, 3, 4]}\"\n","out":"1 2 3 4"},{"out":"34","err":"","code":"'12341234' =~ /.*(3.*)/; $1\n"},{"err":"","code":"\"123.45670000000\" + 0\n","out":"123.4567"},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"\"123.45670000000\"\" + 0\n","err":""},{"out":"1","code":"\" 1234567 \" =~ / [0-9]{7} /;\n","err":""},{"err":"","code":"$_ = \"1234567\"; /.{5,}/; [$1]\n","out":"[undef]"},{"err":"","code":"$_ = \"1234567\"; /(.){5,}/; [$1]\n","out":"[7]"},{"code":"$_ = \"1234567\"; /(.{5,})/; [$1]\n","err":"","out":"[1234567]"},{"out":"","err":"","code":"\" 12345678 \" =~ / [0-9]{7} /;\n"},{"err":"","code":"123456789012 =~ s/(\\d\\d\\d)/$1,/gr\n","out":"123,456,789,012,"},{"out":"[123,456,789,0]","err":"","code":"[ '1234567890' =~ /.{1,3}/g ]\n"},{"code":"1234567890 =~ s/(\\d\\d\\d)/$1,/gr\n","err":"","out":"123,456,789,0"},{"out":"ERROR: Nested quantifiers in regex; marked by <-- HERE in m/(\\d+{ <-- HERE 4})/ at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"[ \"12345678\" =~ m/(\\d+{4})/g ]\n"},{"out":"[1234,5678]","err":"","code":"[ \"1234 5678\" =~ m/(\\d+)/g ]\n"},{"out":"[12345678]","err":"","code":"[ \"12345678\" =~ m/(\\d+)/g ]\n"},{"code":"$_=\"1234567\"; s/(\\d\\d\\d)/$1,/g; $_\n","err":"","out":"123,456,7"},{"code":"[(1,2), (3,4), (5,6)] # Not what you think it will be, petrutrimbitas\n","err":"","out":"[1,2,3,4,5,6]"},{"out":"214365","err":"","code":"\"123456\" =~ s/../reverse $&/ger\n"},{"err":"","code":"$_ = \"123.456str789; $_++; $_\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"$_ = \"123.456str789\"; $_++; $_\n","err":"","out":"124.456"},{"out":"ERROR: Can't modify constant item in substitution (s///) at (eval 1) line 1, at EOF\n","code":"\"1/2/3/4/5\" =~ s{^.*/(?=[^/])}{}\n","err":""},{"err":"","code":"1.2345 =~ /^([^.])(\\..*)?/ && sprintf( q{%03d}, $1 ). ( $2 // q{} ); ### leobut\n","out":"001.2345"},{"code":"\"1/2/3/4/5/\" =~ s{^.*/(?=[^/]$)}{}r\n","err":"","out":"1/2/3/4/5/"},{"out":"5","code":"\"1/2/3/4/5\" =~ s{^.*/(?=[^/])}{}r\n","err":""},{"code":"\"1/2/3/4/5\" =~ s{^.*/(?=[^/]$)}{}r\n","err":"","out":"5"},{"out":"1234","err":"","code":"\"1234abc\"+0\n"},{"out":"1","err":"","code":"'+1234' =~ m/^+/\n"},{"out":"ERROR: Can't modify constant item in substitution (s///) at (eval 1) line 1, at EOF\n","code":"'+1234' =~ s/^+//\n","err":""},{"err":"","code":"'+1234' =~ s/^+//r\n","out":"+1234"},{"out":"[\"1234x\",123]","err":"","code":"[\"1234x 123y\" =~ /\\d*(?:[02468]\\D|[13579])/g ]\n"},{"err":"","code":"[\"1234x 123y\" =~ m{((?>\\d+)(?(?{$1 % 2 == 0}).))}g]\n","out":"[\"1234x\",\"123y\"]"},{"out":"[\"1234x\",1234,123,123]","err":"","code":"[\"1234x 123y\" =~ m{((?>(\\d+))(?(?{$2 % 2 == 0}).))}g]\n"},{"out":"12351","code":"12351\n","err":""},{"out":"[123,5,12,7]","code":"[ \"123 5 12 7 \" =~ /(\\d+)\\s*/g ] # or just numbers?\n","err":""},{"out":"{}","err":"","code":"[ \"123 5 12 7 \" =~ m/(?<num>\\d+)(?<space>\\s*)/g ]; \\%+\n"},{"out":"{space => \" \",num => 7}","err":"","code":"[ \"123 5 12 7 \" =~ m/(?<num>\\d+)(?<space>\\s*)/g ]; +{ %+ } # scope, I think?\n"},{"code":"\"123abc\" + 1\n","err":"","out":"124"},{"err":"","code":"$_ = \"123AG3GCAT422TG3\"; [/([:alpha:]+)/]\n","out":"[]"},{"code":"$_ = \"123AG3GCAT422TG3\"; [/([[:alpha:]]+)/]\n","err":"","out":"[\"AG\"]"},{"out":"[\"AG\",\"GCAT\",\"TG\"]","err":"","code":"$_ = \"123AG3GCAT422TG3\"; [/([[:alpha:]]+)/g]\n"},{"out":"[123,\"AG\",3,\"GCAT\",422,\"TG\",3]","err":"","code":"$_ = \"123AG3GCAT422TG3\"; [split /([[:alpha:]]+)/]\n"},{"err":"","code":"[ \"[123]a test\\n[345] second\\nthird\\n[456]more\\n\" =~ /(^\\[.*?(?=^\\[|$))/gsm ]\n","out":"[\"[123]a test\",\"[345] second\",\"[456]more\"]"},{"out":"[\"[123]a test\\n\",\"[345] second\\nthird\\n\",\"[456]more\\n\"]","err":"","code":"[ \"[123]a test\\n[345] second\\nthird\\n[456]more\\n\" =~ /(^\\[.*?(?=^\\[|\\z))/gsm ]\n"},{"out":"","err":"","code":"1.2.3 eq \"1.2.3\"\n"},{"out":"1","err":"","code":"'123' eq lc('123')\n"},{"code":"\"123\" eq uc \"123\";\n","err":"","out":"1"},{"out":"128","code":"\"123 HAI STRINGS ARE COOL\" + 5\n","err":""},{"out":"","code":"\"1.2.3\" lt \"1.10.0\"\n","err":""},{"err":"","code":"1.2.3 lt 1.10.0\n","out":"1"},{"err":"","code":"$_ = '1_2_3'; m/(\\w*_)/; push @arr, $1; m/(\\w*?_)/; push @arr, $1; \\@arr\n","out":"[\"1_2_\",\"1_\"]"},{"code":"$_=123;print eval'$_++.$/,'x10\n","err":"","out":"123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n"},{"out":"13","err":"","code":"\"123\" =~ s/2//gr\n"},{"code":"$_ = '1 2 3'; [ split ];\n","err":"","out":"[1,2,3]"},{"code":"$_ = \"123str456\"; $_++; $_\n","err":"","out":"124"},{"code":"*{123} = sub { \"D:\" }; &123\n","err":"","out":"D:"},{"out":"D:","code":"*{123} = sub { \"D:\" }; 123->()\n","err":""},{"out":"ERROR: Undefined subroutine &main::D: called at (eval 1) line 1, <STDIN> line 1.\n","code":"*{123} = sub { \"D:\" }; \\&123->()  # guessing this is also wrong\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"->123\"\n","code":"*{123} = sub { \"D:\" }; (bless {})->123\n","err":""},{"out":"5676","code":"12*473\n","err":""},{"out":"some text","code":"\"125 some text\" =~ s/^[1-9][0-9]* //r\n","err":""},{"out":"[\"\\177\\0\\0\\1\"]","err":"","code":"[ 127.0.0.1 . \"\"]\n"},{"code":"[ 127.0.0.1 ]\n","err":"","out":"[127.0.0.1]"},{"err":"","code":"128.129.130\n","out":"ÃÂÃÂÃÂ"},{"out":"0","err":"","code":"(\"12 bananas buys you 0.1 ruby\" =~ /\\d+/g)[1]\n"},{"out":"1","err":"","code":"(\"12 bananas buys you 1 ruby\" =~ /\\d+/g)[1]\n"},{"out":"1","err":"","code":"'?=12' =~ /^\\?(?:=(\\d+))?/\n"},{"code":"$. = 12; my $x = 10..20; [ $x ]; ### I've read the link but think I'm misunderstanding something. $. appears to be within that range but it still returns false.\n","err":"","out":"[\"\"]"},{"out":"[12,13,14]","code":"[ \"12\\n13\\n14\" =~ /(\\d+)/g ]\n","err":""},{"out":"12","code":"@; = (1, 2); print @;;\n","err":""},{"code":"[ 1, 2 ] # these brackets?\n","err":"","out":"[1,2]"},{"code":"\"@{[ 1+3 ]}\"\n","err":"","out":"4"},{"out":"4","err":"","code":"\"${\\( 1+3 )}\"\n"},{"code":"\"1\" & \"3\"\n","err":"","out":"1"},{"code":"1 % -3\n","err":"","out":"-2"},{"code":"1.3 * 0.7\n","err":"","out":"0.91"},{"out":"[1,30]","code":"[ \"1:30\" =~ /(?:(\\d*):)?(\\d+)/ ]\n","err":""},{"code":"[((1 << 3) - 1), 1+2+4]\n","err":"","out":"[7,7]"},{"code":"1<<32\n","err":"","out":"4294967296"},{"code":"134.95 * 100\n","err":"","out":"13495"},{"code":"[  '1-3,5,6-9' =~ s/(\\d+)-(\\d+)/join ',', $1..$2/ger ]\n","err":"","out":"[\"1,2,3,5,6,7,8,9\"]"},{"code":"\".1.3.6.1.2.1.43.11.1.1.6.1.1\" =~ m/\\.(?!5|4|12)$/\n","err":"","out":""},{"out":"4333.33333333333","err":"","code":"1.3e12 / 300e6\n"},{"code":"[ \"13month\" =~ /(\\d+)(\\w+)/ ]\n","err":"","out":"[13,\"month\"]"},{"code":"[1..4]\n","err":"","out":"[1,2,3,4]"},{"err":"","code":"@_ = (1..4); $#_\n","out":"3"},{"out":"[15,15]","code":"[((1 << 4) - 1), 1+2+4+8]\n","err":""},{"code":"1414364400 - 1414274400\n","err":"","out":"90000"},{"out":"1.43531264539073e-10","err":"","code":"'1.43531264539073e-11' * 10\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"4 <\"\n","code":"1 < 4 < 6\n","err":""},{"out":"0.159090909090909","err":"","code":"14/88\n"},{"err":"","code":"1.4e8\n","out":"140000000"},{"code":"(14 gt 7) ? 'yes' : 'no' # maxstr just uses gt instead of >, this seems completely wrong for what you're asking\n","err":"","out":"no"},{"out":"0.2","code":"1/5\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"|.\"\n","code":"\"150\" |. \"105\"\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"|.\"\n","code":"[150 | 105, 150 |. 105]\n","err":""},{"out":"1","err":"","code":"\"- 15:03:48,619  -\" =~ /- (\\d{2}:\\d{2}:\\d{2},\\d{3}).{3,}/\n"},{"code":"\"- 15:03:48,619  \" =~ /- (\\d{2}:\\d{2}:\\d{2},\\d{3}).{3,}/\n","err":"","out":""},{"out":"","err":"","code":"\"- 15:03:48,619  -\" =~ /- (\\d{2}:\\d{2}:\\d{2},\\d{3}).{4,}/\n"},{"out":"","code":"\"- 15:03:48,619  -\\n\\r\" =~ /- (\\d{2}:\\d{2}:\\d{2},\\d{3}).{4,}/\n","err":""},{"code":"155.0 / 3.0\n","err":"","out":"51.6666666666667"},{"err":"","code":"'15.8' == '15.80'\n","out":"1"},{"out":"","err":"","code":"'15.8' == undef\n"},{"err":"","code":"1.5e308\n","out":"1.5e+308"},{"out":"5","err":"","code":"@_ = (1 .. 5); $single = @_; $single\n"},{"err":"","code":"16 | 0\n","out":"16"},{"out":"0","err":"","code":"16 & 0\n"},{"out":"16","code":"16 | 16\n","err":""},{"out":"16","code":"16 & 16\n","err":""},{"out":"18446744073709551615","code":"(1 << 63) - 1 + (1 << 63)\n","err":""},{"out":"ÃÂ£ÃÂ£ÃÂ£","err":"","code":"163.163.163\n"},{"err":"","code":"((16385 >> 12) <<12)\n","out":"16384"},{"out":"1.79e+308","code":"1.79e308\n","err":""},{"err":"","code":"1 << 8\n","out":"256"},{"code":"[ 180000000 / 57100  ]\n","err":"","out":"[\"3152.3642732049\"]"},{"out":"1.84467440737096e+19","code":"18446744073709551615 + 1\n","err":""},{"out":"0","code":"18446744073709551616  - 18446744073709551000\n","err":""},{"out":"[0,32]","code":"[ 1890 & 8,  1890 & 32 ]\n","err":""},{"out":"Inf","code":"1.8e308\n","err":""},{"code":"1.8e308-1\n","err":"","out":"Inf"},{"out":"[0,\"1.23794003928538e+27\"]","err":"","code":"[1 << 90, 2**90]\n"},{"out":"[\"\\x{c0}\\x{a8}\\0\\0\",\"192.168.0.0\"]","err":"","code":"[ 192.168.0.0 . '', '192.168.0.0' ]\n"},{"err":"","code":"[ 192.168.0.0, '192.168.0.0' ]\n","out":"[192.168.0.0,\"192.168.0.0\"]"},{"code":"[ '1990-1992-1993-2010' =~ tr/-/ /r ]\n","err":"","out":"[\"1990 1992 1993 2010\"]"},{"out":"1999","err":"","code":"19.99*100\n"},{"err":"","code":"1^9999\n","out":"9998"},{"out":"0.9999929999755","code":"1999979/1999993\n","err":""},{"out":"1","code":"1**9999 # perl's spelling of \"^\"\n","err":""},{"code":"-+- \"1abc\"\n","err":"","out":"1"},{"out":"1","code":"-+-+-+-+-+- \"1abc\"\n","err":""},{"out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"$[ = 1; (\"A\", \"B\", \"C\")[0]\n"},{"err":"","code":"'1e0' == 1\n","out":"1"},{"out":"10034","code":"1e02.34\n","err":""},{"err":"","code":"$_ = '1e1'; $_++; $_\n","out":"11"},{"code":"1e10\n","err":"","out":"10000000000"},{"code":"1e1000\n","err":"","out":"Inf"},{"code":"1e999\n","err":"","out":"Inf"},{"out":"Inf","code":"1e9999\n","err":""},{"out":"[\"\",1]","err":"","code":"[ 1 eq '1.0', 1 == '1.0' ]\n"},{"out":"[1,1]","err":"","code":"[ 1 eq 1.0, 1 == 1.0 ]\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"2 !=\"\n","code":"1 eq 2 != 3\n","err":""},{"code":"$1 = eval {a:}\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"(\"1foo\"=~/(\\d+)/)[0]\n","err":"","out":"1"},{"out":"","code":"1 for @array;\n","err":""},{"out":"1","err":"","code":"1 if scalar \\%hash\n"},{"err":"","code":"$1\\l$2\n","out":"ERROR: syntax error at (eval 1) line 1, near \"$1\\\"\n"},{"out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"$[ = -1; my @foo = qw/x y z/; [ $foo[-1] ]\n"},{"out":"[1,\"one\"]","code":"[ 1=>'one' ];\n","err":""},{"out":"[1,\"foo\"]","err":"","code":"[(1 or 0 and \"foo\"), ((1 or 0) and \"foo\")]\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"1p\"\n","code":"1p-10\n","err":""},{"err":"","code":"$ = 1; print $++;\n","out":"ERROR: syntax error at (eval 1) line 1, near \"$ = 1\"\nsyntax error at (eval 1) line 1, at EOF\n"},{"out":"4","code":"1+print 4\n","err":""},{"err":"","code":"$! = 1; printf \"SvPV is %s but SvIV is %d\\n\", $!, $!\n","out":"SvPV is Operation not permitted but SvIV is 1\n"},{"err":"","code":"1 =~ /^([^.])(\\..*)?/ && sprintf( q{%03d}, $1 ). ( $2 // q{} ); ### leobut\n","out":"001"},{"err":"","code":"1=>undef\n","out":""},{"err":"","code":"1,undef\n","out":""},{"code":"[ -1 - ~unpack 'N', join '', map chr, '192.168.254.43' =~ /\\d+/g ]\n","err":"","out":"[\"-1.84467440704773e+19\"]"},{"err":"","code":"1x4\n","out":"1111"},{"code":"2014-1989\n","err":"","out":"25"},{"out":"17","err":"","code":"2014-1997\n"},{"code":"$_ = \"2015021900:00:00\"; /^(....)(..)(..)/; \"$1-$2-$3\"\n","err":"","out":"2015-02-19"},{"code":"$_ = 2015021900:00:00; /^(....)(..)(..)/; \"$1-$2-$3\"\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"2015021900:\"\n"},{"err":"","code":"['2.0' == 2 ? \"Y\" : \"N\"]\n","out":"[\"Y\"]"},{"err":"","code":"[20 + 4]\n","out":"[24]"},{"out":"[24]","err":"","code":"[20+4]\n"},{"out":"0","err":"","code":"2048 & 0x00FF\n"},{"out":"1","code":"\"Â²\" =~ /[â°-â¹]/\n","err":""},{"err":"","code":"\"  20:       ee110f10      mrc     15, 0, r0, cr1, cr0, {0}\" =~ s/^\\s+[0-9a-f]+:\\s+([0-9a-f]+)\\K/sprintf \"     %b   \", hex $1/er #netz something like this then?\n","out":"  20:       ee110f10     11101110000100010000111100010000         mrc     15, 0, r0, cr1, cr0, {0}"},{"err":"","code":"2**100\n","out":"1.26765060022823e+30"},{"out":"1.70141183460469e+38","err":"","code":"2**127;\n"},{"code":"2**1270;\n","err":"","out":"Inf"},{"err":"","code":"\"Ù¢\" =~ /[Ù¡-Ù£]/a\n","out":"1"},{"code":"[ 2 << 1, 4 >> 1 ]\n","err":"","out":"[4,2]"},{"out":"17179869184","code":"2**17 * 2**17\n","err":""},{"out":"999998","err":"","code":"-2 % 1e6\n"},{"code":"2 + 2\n","err":"","out":"4"},{"out":"4","code":"2+2\n","err":""},{"code":"[2**2*3]\n","err":"","out":"[12]"},{"out":"4","code":"*2 = 2.5; 2 + 2\n","err":""},{"code":"*2 = 2.5; 2 + &2\n","err":"","out":"ERROR: Undefined subroutine &main::2.5 called at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"\"\\22\\a\\6\\21A\\5SK\" ^ 'foobar22'\n","err":"","out":"this way"},{"out":"[2,23]","err":"","code":"[2.3 ^ 0, 2 . 3 ^ 0]\n"},{"err":"","code":"2 * 3 + 1\n","out":"7"},{"out":"2147483648","code":"2**31\n","err":""},{"code":"[ 23 ** 11, 2 ** 32 ]\n","err":"","out":"['952809757913927',\"4294967296\"]"},{"out":"34","err":"","code":"2^32\n"},{"code":"2**32\n","err":"","out":"4294967296"},{"code":"(2**32)/1000/60/60/24/365\n","err":"","out":"0.136192519533232"},{"out":"136.192519533232","code":"2**32 / 3600 / 24 / 365\n","err":""},{"out":"[\"2.3\",23]","err":"","code":"[ 2.3, 2 . 3 ]  # different\n"},{"out":"23","code":"23 % 24\n","err":""},{"err":"","code":"(2**32)/60/60/24\n","out":"49710.2696296296"},{"out":"4,294,967,296","code":"2**32 =~ s/\\B(?=(\\d\\d\\d)+$)/,/gr\n","err":""},{"out":"8589934592","err":"","code":"2**33\n"},{"code":"235 ^ 255\n","err":"","out":"20"},{"err":"","code":"235 xor 255\n","out":""},{"out":"223.517417907715","err":"","code":"240*(10**9)/(2**30)\n"},{"code":"240*10^9/2^30\n","err":"","out":"2426"},{"out":"0","code":"24 % 24\n","err":""},{"out":"32","err":"","code":"2**5\n"},{"out":"1.12589990684262e+15","code":"2**50  # really ?\n","err":""},{"err":"","code":"25 % 24\n","out":"1"},{"code":"255 & 0x7f\n","err":"","out":"127"},{"err":"","code":"25 | 6 ** 4\n","out":"1305"},{"code":"[ 256 >> 8 ]\n","err":"","out":"[1]"},{"out":"6103515625","err":"","code":"25**7\n"},{"code":"25 or 6 ** 4\n","err":"","out":"25"},{"out":"0.0722222222222222","code":"260 / 3600\n","err":""},{"out":"4.61168601842739e+18","err":"","code":"2**62\n"},{"err":"","code":"(2**63 - 1) + 2**63\n","out":"1.84467440737096e+19"},{"code":"2**64\n","err":"","out":"1.84467440737096e+19"},{"err":"","code":"2**64 - 1\n","out":"1.84467440737096e+19"},{"code":"265 % 2\n","err":"","out":"1"},{"out":"1420 litres of beer tonight","err":"","code":"2*710 . ' litres of beer tonight'\n"},{"out":"33","err":"","code":"2733.754 % 60.0; ### Why exactly is it that this yields 33 instead of 33.754 ?\n"},{"code":"2**(7*8)\n","err":"","out":"7.20575940379279e+16"},{"out":"NaN","code":"2790**2753 % 3233\n","err":""},{"out":"256","code":"2**8\n","err":""},{"out":"3.09485009821345e+26","code":"2**88\n","err":""},{"out":"0.192446666666667","code":"28867 / 150000\n","err":""},{"out":"100","err":"","code":"(2903000/2903000)*100\n"},{"out":"1819142","err":"","code":"29822 * length q|/gnu/store/d8fwypp5cnzjpc7kycmj4nj0gwn7k6lq-perl-xml-sax-0.99|\n"},{"out":"1","err":"","code":"2 =~ /\\A(?:(?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9])\\z/\n"},{"out":"ERROR: No such file or directory at (eval 1) line 1, <STDIN> line 1.\n","code":"$! = 2; die \"$!\"\n","err":""},{"out":"[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541]","err":"","code":"[2,grep{(1x$_)!~/^(..+)\\1+$/}3..541]\n"},{"err":"","code":"$_ = 2; grep { $_ } qw(1 3 5); $_\n","out":"2"},{"code":"(2 or 3)\n","err":"","out":"2"},{"out":"4.5","err":"","code":"*2 = sub {2.5}; 2 + &2\n"},{"out":"[\"ok\"]","code":"*{\"2\"} = sub { 'ok' }; [ main->${\\2} ]\n","err":""},{"code":"*{\"2\"} = sub { 'ok' }; [ main->2 ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"->2\"\n"},{"code":"*{\"2\"} = sub { 'ok' }; [ my $two = 2; main->$two ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, near \"$two ]\"\n"},{"err":"","code":"*{\"2\"} = sub { 'ok' }; my $two = 2; [ main->$two ]\n","out":"[\"ok\"]"},{"err":"","code":"2 =~ /\\w/\n","out":"1"},{"err":"","code":"2x4\n","out":"2222"},{"code":"3\n","err":"","out":"3"},{"out":"30000","code":"3_000_000 / 100  # this many seconds\n","err":""},{"code":"30_000 * 30_000 / 2\n","err":"","out":"450000000"},{"err":"","code":"300 x $60\n","out":""},{"out":"ÃÂÃÂÃÂÃÂ¡r jÃÂÃÂÃÂÃÂº sÃÂÃÂÃÂÃÂºr?\n","code":"\"\\303\\203\\302\\241r j\\303\\203\\302\\272 s\\303\\203\\302\\272r?\\n\"\n","err":""},{"err":"","code":"-30 % 60\n","out":"30"},{"err":"","code":"307 * 500\n","out":"153500"},{"out":"[\"\",30]","err":"","code":"[ \":30\" =~ /(?:(\\d*):)?(\\d+)/ ]\n"},{"err":"","code":"[ 30 =~ /(?:(\\d*):)?(\\d+)/ ]\n","out":"[undef,30]"},{"err":"","code":"3 ** 12   # Actually :)\n","out":"531441"},{"err":"","code":"3 ** 13\n","out":"1594323"},{"err":"","code":"\"31323334\" =~ s/.(.)/$1/gr\n","out":"1234"},{"out":"ERROR: Can't modify constant item in substitution (s///) at (eval 1) line 1, at EOF\n","err":"","code":"\"31323334\" =~ s/(..)/chr hex $1/g\n"},{"err":"","code":"\"31323334\" =~ s/(..)/chr hex $1/gr\n","out":"chr hex 31chr hex 32chr hex 33chr hex 34"},{"out":"1234","err":"","code":"\"31323334\" =~ s/(..)/chr hex $1/gre\n"},{"code":"3.141592653589793238462643383279502884\n","err":"","out":"3.14159265358979"},{"err":"","code":"3 / 2\n","out":"1.5"},{"err":"","code":"3 // 2\n","out":"3"},{"out":"1","err":"","code":"\"321\" =~ /\\d+/\n"},{"err":"","code":"3/2 > 7/5\n","out":"1"},{"code":"[ 3 ^ 3 ]\n","err":"","out":"[0]"},{"out":"\"Blythe\" \"33.62\" \"114.72\"","code":"$_ = '\"33.62\" \"114.72\" \"Blythe\"'; s/(\\S+)\\s(\\S+)\\s(.+$)/$3 $1 $2/; $_ # seems happy enough, did you try it?\n","err":""},{"code":"337 * 1051\n","err":"","out":"354187"},{"out":"yes","code":"(3 == 3) ? \"yes\" : \"no\";\n","err":""},{"err":"","code":"\"@{[ 3 + 4 ]}\"\n","out":"7"},{"code":"3.4/2.31012414912481924812904128490128412\n","err":"","out":"1.47178237208077"},{"out":"[\"\\x{51fa}\\x{8ca8}\\x{660e}\\x{7d30}\"]","err":"","code":"$_ = \"\\345\\207\\272\\350\\262\\250\\346\\230\\216\\347\\264\\260\"; utf8::decode $_; [$_]\n"},{"out":"[4,5,6,7,8,9]","err":"","code":"@3 = 4..9; \\@3  # other global stuff :)\n"},{"out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after tures/; 3 <-- HERE near column 93 at (eval 1) line 1, <STDIN> line 1.\n","code":" 3 â 5;\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"3:\"\n","err":"","code":"3:5\n"},{"err":"","code":"3+5\n","out":"8"},{"out":"292.596817016602","err":"","code":"350*24*365.25*100/(1024*1024) # about 300TB, why do you ask?\n"},{"out":"35.68","err":"","code":"3568 / 100\n"},{"out":"15","err":"","code":"360/24\n"},{"out":"1","code":"'Ù£' =~ /./a\n","err":""},{"code":"'Ù£' =~ /\\d/a\n","err":"","out":""},{"out":"1","err":"","code":"'Ù£' =~ /\\D/a\n"},{"out":"[1,1,1]","code":"[ 'Ù£' =~ /\\d/a, 'Ù£' =~ /./a, \"Ù¢\" =~ /[Ù¡-Ù£]/a, 'Ù£' =~ /\\D/a ]\n","err":""},{"err":"","code":"\"(3/(x+2)+(-1/2)/(x-3))dx \" =~ s/^\\(((?:[^()]|\\((?1)\\))*)\\)dx\\s*$/$1/r\n","out":"3/(x+2)+(-1/2)/(x-3)"},{"err":"","code":"\"(3/(x+2)+(-1/2)/(x-3))dx \" =~ s/^\\(((?:[^()]|\\((?1)\\))*\\)dx\\s*$/$1/r\n","out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/^\\(( <-- HERE (?:[^()]|\\((?1)\\))*\\)dx\\s*$/ at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"404->()\n","out":"ERROR: Undefined subroutine &main::404 called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"jolly","code":"$_ = '4 1 4 2 3'; @a=(); $a[abs $1-$']+=1 while / (\\d+)(?= )/g; (!defined shift @a) && @a == $_ - 1 && $_ - 1 == grep($_ == 1, @a) ? 'jolly' : 'Not jolly'\n","err":""},{"out":"jolly","err":"","code":" $_ = '4 1 4 2 3'; @deltas = 1; $deltas[abs $1 - $2] += 1 while / (\\d+)(?= (\\d+))/g;  grep($_ != 1, @deltas) ? 'Not jolly' : 'jolly'\n"},{"err":"","code":"42\n","out":"42"},{"out":"['18446744073709551573']","code":"[ ~42 ]\n","err":""},{"out":"[42]","code":"[ \"\" || 42 ]\n","err":""},{"out":"[\"\"]","code":"[ \"\" // 42 ]\n","err":""},{"code":"('42 bottles of beer' =~ /(\\d+)/)[0]\n","err":"","out":"42"},{"out":"[1,1,1]","code":"[ !!42, !!\"foo\", !!{baz=>quux} ]\n","err":""},{"code":"$_ = 42; [ \\$_, \\$main::_, \\$main::main::_ ]\n","err":"","out":"[\\42,$VAR1->[0],$VAR1->[0]]"},{"out":"[42,42,42]","code":"$_ = 42; [ map ${$_}, \\$_, \\$main::_, \\$main::main::_ ]\n","err":""},{"err":"","code":"$_ = 42; print map { $_ } qw(a b c); print \"; $_\"\n","out":"abc; 42"},{"out":"[\"446,744,073,709,551,615\"]","err":"","code":"[ '446744073709551615' =~ s/\\B(?=(\\d{3})+$)/,/gr ]  # fix\n"},{"out":"[\",446,744,073,709,551,615\"]","err":"","code":"[ '446744073709551615' =~ s/(?=(\\d{3})+$)/,/gr ]\n"},{"code":"45_000_000 * 24\n","err":"","out":"1080000000"},{"err":"","code":"(45/50-1)*100\n","out":"-10"},{"code":"(4,5,6)[-2..-1]\n","err":"","out":"6"},{"out":"[5,6]","code":"[(4,5,6)[-2..-1]]\n","err":""},{"code":"47 % 24\n","err":"","out":"23"},{"code":"[ 4 .. 9 ]\n","err":"","out":"[4,5,6,7,8,9]"},{"code":"4 .. 9\n","err":"","out":""},{"code":"49 & 97\n","err":"","out":"33"},{"out":"[4,5,6,7,8,9]","code":"\"4-9\" =~ /-/ and [eval '$`..$\\'']\n","err":""},{"out":"[]","code":"\"4-9\" =~ /-/ and [ split /,/, `perl -e'print join \",\", $\\` .. $'\\'` ]\n","err":""},{"code":"$_ = \"4-9\"; s/(\\d+)-/$1,@{[$1+1]}-/ until /(?<=,)(\\d+)-\\1/; s//$1/; $_\n","err":"","out":"4,5,6,7,8,9"},{"code":"$_ = \"4-9\"; s/(\\d+)-/$1,@{[$1+1]}-/ until /(?<=,)(\\d+)-\\1/; s//$1/; [ /(\\d+)/g ]  # better\n","err":"","out":"[4,5,6,7,8,9]"},{"code":"$_ = \"4-9\"; s/-/../; [ eval ]\n","err":"","out":"[4,5,6,7,8,9]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"4[\"\n","code":"4[$array]\n","err":""},{"out":"3.14159265358979","code":"4*atan2(1,1)\n","err":""},{"code":"$! = 4; die \"$!\"\n","err":"","out":"ERROR: Interrupted system call at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"$_[4] = ['foo']; $_->[4] = 'bar'; [ @{$_[4]} ];\n","err":"","out":"[\"foo\"]"},{"out":"[\"bar\"]","err":"","code":"$_[4] = ['foo']; $_->[4] = 'bar'; [ @$_[4] ];\n"},{"out":"5x5x5","err":"","code":"$_ = '4x4x4'; y(4)(5); $_ # still potential for confusion though\n"},{"out":"[\"0.5\"]","code":"[ .5]\n","err":""},{"out":"[5]","err":"","code":"[ 5. ]\n"},{"out":"[]","err":"","code":"[5 .. 0]\n"},{"out":"[0]","err":"","code":"[ \"5\" & \"000000\" ]\n"},{"out":"*main::5000","err":"","code":"*5000 = \\5;\n"},{"err":"","code":"\\*5000 = \\5;\n","out":"ERROR: Can't modify reference to ref-to-glob cast in scalar assignment at (eval 1) line 1, at EOF\n"},{"out":"ERROR: Can't modify reference to ref-to-glob cast in scalar assignment at (eval 1) line 1, at EOF\n","code":"\\*5000 = 5;\n","err":""},{"code":"*5000 = \\5; $5000\n","err":"","out":"5"},{"code":"*5000 = \\5; *5000\n","err":"","out":"*main::5000"},{"code":"*5000 = sub {5}; 5 & & 5000\n","err":"","out":"5"},{"code":"*5000 = sub {\"Hello World\"}; 10 &5000\n","err":"","out":"8"},{"code":"*5000 = sub {\"Hello World\"}; \\*5000->()\n","err":"","out":"\\\"Hello World\""},{"out":"Hello World","err":"","code":"*5000 = sub {\"Hello World\"}; &5000\n"},{"out":"Hello World","code":"*5000 = sub {\"Hello World\"}; 5000->()\n","err":""},{"err":"","code":"*5000 = sub {\"Hello World\"}; 5000()\n","out":"ERROR: syntax error at (eval 1) line 1, near \"5000(\"\n"},{"code":"*5000 = sub {\"Hello World\"}; \"Hello\" + &5000\n","err":"","out":"0"},{"err":"","code":"[ 5/0.06 ]\n","out":"[\"83.3333333333333\"]"},{"err":"","code":"5.013_006 # mauke typo I think\n","out":"5.013006"},{"out":"[105]","code":"[5 + 100]\n","err":""},{"out":"[5,6,7,8,9,10,11,12]","err":"","code":"[ 5 .. 12 ]\n"},{"out":"[5.14.0]","code":"[5.14.0]\n","err":""},{"out":"\u0005\u000e\u0000","err":"","code":"5.14.0\n"},{"code":"$â = 5; $â = 2; $â + $â\n","err":"","out":"ERROR: Unrecognized character \\x9C; marked by <-- HERE after tures/; $ÃÂ¢<-- HERE near column 93 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[1]","err":"","code":"[ \"5\" & \"3\" ]\n"},{"code":"5<=>3\n","err":"","out":"1"},{"out":"1.66666666666667","err":"","code":"5/3\n"},{"code":"[ 5 5 ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"5 5\"\n"},{"out":"25","code":"5*5\n","err":""},{"err":"","code":"5+5\n","out":"10"},{"code":"5 == 5.0\n","err":"","out":"1"},{"err":"","code":"[ 5 . 5, 5. 5, 5 .5, 5.5 ]\n","out":"ERROR: syntax error at (eval 1) line 1, near \"5. 5\"\n"},{"out":"10","err":"","code":"\"5 + 5\" =~ s/(.+)/ $1 /eer;\n"},{"out":"10","err":"","code":"\"5 + 5\" =~ s/.*/$&/eer;\n"},{"err":"","code":"\"5 5\" =~ s/(.)\\s(.)/$1 + $2/er;\n","out":"10"},{"out":"10","err":"","code":"\"5 5\" =~ s/(.)\\s(.)/print $1 + $2/er;\n"},{"code":"[5+6]\n","err":"","out":"[11]"},{"out":"11","code":"5+6\n","err":""},{"err":"","code":"5/7\n","out":"0.714285714285714"},{"code":"[ 57100 / 180000000 ]\n","err":"","out":"[\"0.000317222222222222\"]"},{"out":"99","code":"57+42  # perlbot is the most accessible calculator\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"5.'a'\"\n","code":"[ 5.'a' ]\n","err":""},{"out":"Input/output error\n","code":"$! = 5; say $!\n","err":""},{"err":"","code":"62 ** 4\n","out":"14776336"},{"out":"@@@ÃÂ¾ÃÂÃÂªÃÂÃÂÃÂÃÂ@@@","code":"64.64.64.5000000000.64.64.64\n","err":""},{"out":"@ADF","code":"64.65.68.70\n","err":""},{"code":"65280 & 127\n","err":"","out":"0"},{"out":"255","code":"65280 >> 8\n","err":""},{"code":"65536 >> 16\n","err":"","out":"1"},{"out":"256","err":"","code":"65536 >> 8\n"},{"out":"[65.66.67]","code":"[ 65.66.67 ]\n","err":""},{"out":"[65.66.67]","code":"[65.66.67]\n","err":""},{"out":"67","code":"6_5,6_6,6_7\n","err":""},{"err":"","code":"6_5.6_6.6_7\n","out":"ABC"},{"code":"65.66.67\n","err":"","out":"ABC"},{"out":"667","code":"~~667\n","err":""},{"err":"","code":"6.6e-16 == 6.6 * 10 ** -16\n","out":"1"},{"code":"6*710 . ' militres of beer tonight'\n","err":"","out":"4260 militres of beer tonight"},{"code":"6 * 99.90\n","err":"","out":"599.4"},{"code":"6 * 99.90 > 599.40\n","err":"","out":"1"},{"err":"","code":"\"6C5775272327642A382A453C327D3A31\" =~ s/(..)/chr hex $1/gre\n","out":"lWu'#'d*8*E<2}:1"},{"code":"\"6d73616e64626f78\" =~ s/([0-9a-f]{2})/chr hex $1/eg\n","err":"","out":"ERROR: Can't modify constant item in substitution (s///) at (eval 1) line 1, at EOF\n"},{"out":"15.9090909090909","code":"70 / 4.4\n","err":""},{"out":"86400","err":"","code":"7200 * 12\n"},{"out":"103","err":"","code":"7 + 32 + 64\n"},{"code":" 7 + 7 / 7 + 7 * 7 - 7\n","err":"","out":"50"},{"out":"7777778","code":" 7 + 7 / 7 + 7 x 7 - 7\n","err":""},{"err":"","code":"$78_char_wide_text\n","out":"ERROR: syntax error at (eval 1) line 1, near \"$78_char_wide_text\n\"\n"},{"out":"[1]","err":"","code":"[ 7 <=> \"cats\" ]\n"},{"out":"","code":"7 < 'D'\n","err":""},{"err":"","code":".7E9 / 604\n","out":"1158940.39735099"},{"code":"[ 7 <=> 'nan' ]\n","err":"","out":"[undef]"},{"code":"8181 / 101\n","err":"","out":"81"},{"out":"0.818181818181818","code":"8181/9999\n","err":""},{"out":"8","code":"8192 / 1024\n","err":""},{"out":"2","err":"","code":"8 >> 2\n"},{"out":"1234321","code":"(86274 ^ 87381) ** 2\n","err":""},{"code":"\"\\8\" eq \"\\9\" ? \"yes\" : \"no\"\n","err":"","out":"no"},{"code":"*9001 = \\5;\n","err":"","out":"*main::9001"},{"out":"0.818181818181818","code":"9/11\n","err":""},{"out":"777","err":"","code":"953-176\n"},{"err":"","code":"97 =~ s/(\\d+)/chr $1/er\n","out":"a"},{"code":"97 =~ s/(\\d+)/${\\chr $1}/r\n","err":"","out":"a"},{"out":"cafÃÂ©","code":"99.97.102.233\n","err":""},{"out":"99","code":"9999 / 101\n","err":""},{"code":"$. = 9; [ [ $.++, scalar(10..15) ], ]\n","err":"","out":"[[9,1]]"},{"code":"{a=>1}\n","err":"","out":"{a => 1}"},{"err":"","code":"@a=(1,2,3,4,5); [@a[-20..-1]]\n","out":"[undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,1,2,3,4,5]"},{"code":"@a=[1,2,3,4,5]; [@a[-20..-1]]\n","err":"","out":"[undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,[1,2,3,4,5]]"},{"err":"","code":"[ { a => 123 }, { b => 456 } ];\n","out":"[{a => 123},{b => 456}]"},{"err":"","code":"\"a123b\" =~ s/(\\d+)/$1*100/er\n","out":"a12300b"},{"code":"@a = (1, 2, 3); print $#a;\n","err":"","out":"2"},{"out":"[1,2,3,44]","err":"","code":"$_ = \"a1 2b 3 c 44\"; [/(\\d+)/g]\n"},{"out":"1","code":"@a = (1, 2, 'foo'); grep { $_ eq 'foo' } @a[1..$#a]\n","err":""},{"code":"$a = {1..4}; [keys $a]\n","err":"","out":"ERROR: Experimental keys on scalar is now forbidden at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[{1 => 2,2 => 3},{4 => 5,3 => 4}]","code":"@a=1..4; [{map{$_=>$_+1}@a[0..@a/2-1]},{map{$_=>$_+1}@a[@a/2..$#a]}]\n","err":""},{"code":"@a = (1,5,2,4,3); @b = (5,3,1,4,2); (() = delete @{ { map {$_,1} @a } }{ @b }) == @b\n","err":"","out":"1"},{"out":"1","code":"@a = (1,5,2,4,6); @b = (5,3,1,4,2); (() = delete @{ { map {$_,1} @a } }{ @b }) == @a\n","err":""},{"out":"different","err":"","code":"@a = (1,5,2,4,6); @b = (5,3,1,4,2); \"@{[sort @a]}\" eq \"@{[sort @b]}\" ? same : different\n"},{"out":"same","err":"","code":"@a = (1,5,2,4,6); @b = (5,6,1,4,2); \"@{[sort @a]}\" eq \"@{[sort @b]}\" ? same : different\n"},{"code":"@a = (1,5,2,4); @b = (5,3,1,4,2); (() = delete @{ { map {$_,1} @a } }{ @b }) == @b\n","err":"","out":"1"},{"out":"{a => 2}","err":"","code":"{ a => 1, a => 2 }\n"},{"out":"ERROR: Died at (eval 1) line 1, <STDIN> line 1.\n","code":"$a=1; $b=1; LABL: while($a--) {try {die if $b--} catch {redo LABL;}; print \"hello world\"};\n","err":""},{"out":"1","code":"$a = 1; $b = 3; ($a/$b)*$b\n","err":""},{"code":"@a = (1) x 1024*1024*30; $#a\n","err":"","out":"0"},{"err":"","code":"@a = (1) x 1024*1024*5\n","out":"1"},{"out":"[\"\"]","err":"","code":"@a = 2; [ @a == 2 ]\n"},{"out":"[undef,undef,{}]","err":"","code":"$a->[2]->{bar} eq 'baz'; $a\n"},{"err":"","code":"[ 'a 42 b' =~ s/\\D+//, 'a 42 b' =~ s/\\D+//g ]\n","out":"ERROR: Can't modify constant item in substitution (s///) at (eval 1) line 1, near \"s/\\D+//,\"\n"},{"out":"[\"42 b\",42]","err":"","code":"[ 'a 42 b' =~ s/\\D+//r, 'a 42 b' =~ s/\\D+//gr ]\n"},{"code":"@a=(4,5,6); [ map [@a[0..@a-$_]], 1..@a+1 ]\n","err":"","out":"[[4,5,6],[4,5],[4],[]]"},{"code":"%a=(a=>1); $s=\"a\"; $s=~s/.+/$a{\\1}/eg; print $s;\n","err":"","out":"1"},{"code":"\"<a<a></a>></a>\" =~ /<a(.*)>(.*)<\\/a>/\n","err":"","out":"1"},{"out":"","code":"\"<a<a></a>></a>\" !~ /<a(.*)>(.*)<\\/a>/\n","err":""},{"out":"8","code":"\"aaaaaaaanother thing\" =~ m/^(a+)/ and $+[1]\n","err":""},{"out":"[\"AAAAA\",\"BBBB\"]","err":"","code":"'AAAAABBBB' =~ /((.)\\2*)(.*)/ ; [ $1, $3 ]\n"},{"err":"","code":"'aaaabbbbbccccddddd' =~ tr/abc//sr\n","out":"abcddddd"},{"out":"a b c abcadaba","code":"\"aaa b ccccc abcadaba\" =~ tr/abc/abc/sr\n","err":""},{"out":"[\"aaa\",6]","code":"$_ = 'aaa'; my $a = 5; ++$_ for $a; [ $_, $a ];\n","err":""},{"out":"[\"aaa\",6]","code":"$_ = 'aaa'; my $a = 5; {local *_ = \\$a; ++$_}; [ $_, $a ];\n","err":""},{"out":"[\"aaa\",5]","err":"","code":"$_ = 'aaa'; my $a = 5; {local $_ = $a; ++$_}; [ $_, $a ]; # note that this, which uses 'local $_', acts differently\n"},{"out":"[\"aa\",\"bbaa\"]","code":"[ \"aabbaa\" =~ /(aab??)(b+aa)/ ]\n","err":""},{"out":"[\"aab\",\"baa\"]","err":"","code":"[ \"aabbaa\" =~ /(aab?)(b+aa)/ ]\n"},{"code":"\"aabbcc\" =~ s/(\\w)\\1/ $& /g;\n","err":"","out":"ERROR: Can't modify constant item in substitution (s///) at (eval 1) line 1, at EOF\n"},{"code":"@a = (); 'abcccccdefghi' =~ / (c) (?:(\\1)(?{push @a, $1})){4} /x; \\@a # backrefs :)\n","err":"","out":"[\"c\",\"c\",\"c\",\"c\"]"},{"out":"[\"d\",\"e\",\"f\",\"g\"]","err":"","code":"@a = (); 'abcdefghi' =~ / c (?:(.)(?{push @a, $1})){4} /x; \\@a\n"},{"err":"","code":"@a = (); 'abcdefghi' =~ / c (?:(.)(?{push @a, $1})){4} (?!) /x; \\@a\n","out":"[\"d\",\"e\",\"f\",\"g\"]"},{"out":"[\"a\",\"b\",\"c\",\"d\",\"b\",\"c\",\"d\",\"e\",\"c\",\"d\",\"e\",\"f\",\"d\",\"e\",\"f\",\"g\",\"e\",\"f\",\"g\",\"h\",\"f\",\"g\",\"h\",\"i\"]","code":"@a = (); 'abcdefghi' =~ / (?:(.)(?{push @a, $1})){4} (?= $ ) /x; \\@a\n","err":""},{"out":"[\"f\",\"g\",\"h\",\"i\"]","code":"@a = (); 'abcdefghi' =~ / (?:(.)(?{push @a, $1})){4} $ /x; \\@a\n","err":""},{"out":"aabcdef","err":"","code":"$_=\"aabcdef\"; print if /^a([abcd]+)ef$/ and $1 !~ /([abcd]).*\\1/\n"},{"code":"$a=\"a.b.com\";print \"yes\" if $a=~/^a.com$/\n","err":"","out":""},{"out":"ERROR: Not a GLOB reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"$a = 'a'; my $b = \\$a; for $$b (0..5) { print $a }\n"},{"out":"012345","err":"","code":"$a = 'a'; my $b = \\*a; for $$b (0..5) { print $a }\n"},{"out":"asd1312321\nasd1212\nasd121212\n","code":"$a=\"asd1312321asd1212asd121212\"; print $_,\"\\n\" for $a=~/(asd\\d+)/g;\n","err":""},{"err":"","code":"[ @a=['asd qwe', 'qqq '];   /(\\w+)\\s+(\\w+?)/ , print \"$1 - $2\" for ( @a )   ]\n","out":"ERROR: syntax error at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, near \")   ]\"\n"},{"code":"[ 'a' ^ 'A' ] # secret - the difference between upper and lower case is a space\n","err":"","out":"[\" \"]"},{"code":"\"AA\" =~ s/(.)(.)/\\l$1$2/r\n","err":"","out":"aA"},{"code":"[ 'a' ^ 'b' ]\n","err":"","out":"[\"\\3\"]"},{"err":"","code":"+{ a; b}\n","out":"ERROR: syntax error at (eval 1) line 1, near \"; b\"\n"},{"err":"","code":"\"ab12312532\" =~ /.*3.*/\n","out":"1"},{"err":"","code":"-+- \"ab1c\"\n","out":"+ab1c"},{"out":"[1]","code":"[ \"a{b\" =~ /a{/ ]\n","err":""},{"out":"01","code":"(\"AB\" ^ \"A4\") =~ tr/\\0\\1-\\377/01/r\n","err":""},{"err":"","code":"[ \"a\" . \"b\", \"a\" . 5, 5 . \"b\", 5 . 5 ]\n","out":"[\"ab\",\"a5\",\"5b\",55]"},{"out":"[\"ab\"]","code":"[ 'ababab' =~ /(ab)*/ ]\n","err":""},{"err":"","code":"[ 'ababab' =~ /(ab)/g ]\n","out":"[\"ab\",\"ab\",\"ab\"]"},{"out":"[undef]","err":"","code":"[ \"ab\" =~ /(a)x|b/ ]\n"},{"code":"'ab' & 'b'\n","err":"","out":"`"},{"code":"'ab' & 'ba'\n","err":"","out":"``"},{"err":"","code":"[\"abba\" =~ /(ab(ba))/]\n","out":"[\"abba\",\"ba\"]"},{"out":"[\"abba\",\"ba\"]","err":"","code":"\"abba\" =~ /(ab(ba))/; [$1, $2]\n"},{"code":"\"ABBBBBBBABBA\" =~ s/(B+)/length $1 < 3 ? 'C' x length $1 : $1/ger\n","err":"","out":"ABBBBBBBACCA"},{"err":"","code":"'aBBBc' =~ s/[^a-z]//gr\n","out":"ac"},{"err":"","code":"$_ = 'Abbott &&& Costello'; s/\\s\\K\\W+(?=\\s)/and/; $_ # should work here though\n","out":"Abbott and Costello"},{"code":"[ 'Abbott &&& Costello' =~ s/(\\s*)&&&(\\s*)/$1and$2/gr ]\n","err":"","out":"[\"Abbott and Costello\"]"},{"err":"","code":"[~~\"abc\"]\n","out":"[\"abc\"]"},{"code":"['ABC']\n","err":"","out":"[\"ABC\"]"},{"err":"","code":"A: B: C: ;\n","out":""},{"out":"0","err":"","code":"\"ABC\" & 0x00FF;\n"},{"out":"ab","code":"\"abc\" =~ \"(..)\"; $1\n","err":""},{"out":"ERROR: Can't call method \"encode_json\" on unblessed reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"{ abc => 123 }->JSON::encode_json\n"},{"out":"[\"abc123___\"]","code":"[ \"abc123___\" =~ /\\w+/g ]\n","err":""},{"out":"[30]","err":"","code":"[ \"abc 30 def\" =~ /abc (\\d+) def/  ]\n"},{"err":"","code":"[ \"abc 30 def\" =~ /abc (\\d) def/ || \"No match\" ]\n","out":"[\"No match\"]"},{"out":"[1]","err":"","code":"[ \"abc 30 def\" =~ /abc (\\d+) def/ || \"No match\" ]\n"},{"err":"","code":"[ 'abc446744073709551615' =~ s/\\B(?=(\\d{3})+$)/,/gr ]\n","out":"[\"abc,446,744,073,709,551,615\"]"},{"out":"[\"abc446,744,073,709,551,615\"]","err":"","code":"[ 'abc446744073709551615' =~ s/(?<=\\d)(?=(\\d{3})+$)/,/gr ]\n"},{"out":"7","code":"@abc = (5,6,7,8); $c = @abc[1,2]\n","err":""},{"out":"1","err":"","code":"\"abc\" =~ /a/\n"},{"out":"1","code":"\"abca9\" =~ /(.)(.)(.)${3}9/\n","err":""},{"code":"'abc' =~ /(a+)/; 'abc' =~ /(d+)/; [ 'bbaaccddee' =~ // ]\n","err":"","out":"[\"aa\"]"},{"out":"abcaccabc","code":"$_ = 'abcabcabc'; s/b(??{ ++$idx == 2 ? '' : 'no match' })/c/; $_ # except you'd never actually write code like this of course\n","err":""},{"err":"","code":"[ \"abcabca\" =~ s/a.*a/CAT/r, \"abcabca\" =~ s/a.*?a/CAT/r ] # greedy vs not greedy\n","out":"[\"CAT\",\"CATbca\"]"},{"out":"[\"A\",\"B\",\"C\",\"D\"]","code":"[ (\"A\",\"B\"),(\"C\",\"D\") ]\n","err":""},{"err":"","code":"[ 'abcd' & '1111' ]\n","out":"[\"! ! \"]"},{"code":"[ \"abcd123efg567h8i\" =~ /([a-z]+|[0-9]+)/g ];\n","err":"","out":"[\"abcd\",123,\"efg\",567,\"h\",8,\"i\"]"},{"err":"","code":"$_ = \"abcd12ABCD\"; print \"[[$_]]\" for  /(abcd|ABCD)/g\n","out":"[[abcd]][[ABCD]]"},{"code":"[ \"abcd\" =~ /^ab/ ]\n","err":"","out":"[1]"},{"err":"","code":"$_=\"abcdaef\"; print /^(a[abcd]+ef)$/ and $1 !~ /([abcd]).*\\1/ ? \"Yes\" : \"no\";\n","out":"abcdaef"},{"code":"$_=\"abcdaef\"; print if /^(a[abcd]+)ef)$/ and $1 !~ /([abcd]).*\\1/\n","err":"","out":"ERROR: Unmatched ) in regex; marked by <-- HERE in m/^(a[abcd]+)ef) <-- HERE $/ at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"$_=\"abcdaef\"; print if /^a([abcd]+)ef$/ and $1 !~ /([abcd]).*\\1/\n","err":"","out":"abcdaef"},{"out":"abcdaef","err":"","code":"$_=\"abcdaef\"; print if /^a([abcd]+)ef$/ and $1 !~ /([abcd]).*\\1(??{print $1})/\n"},{"code":"$_=\"abcdaef\"; print if /^(a[abcd]+ef)$/ and $1 !~ /([abcd]).*\\1/; print \"done\"\n","err":"","out":"done"},{"out":"abcda","code":"$_=abcda; print if /^([abcd]{1})+$/ or print \"hmm\"\n","err":""},{"code":"[ 'abcdcdcd' =~ /(ab)(cd)*/ ]\n","err":"","out":"[\"ab\",\"cd\"]"},{"out":"[\"a\"]","code":"[ \"abcdef\" =~ /^(?!.*([abcd]).*\\1)a.*ef\\z/s ]\n","err":""},{"err":"","code":"$_ = \"abcdef\"; [ /abc(?=def)/ ? $& : 'fail' ]\n","out":"[\"abc\"]"},{"out":"[\"abc\"]","err":"","code":"\"abc def\" =~ /(?<first> \\w+ )/x; [ $+{first} ]\n"},{"code":"'abcdefgh' & '11111111'\n","err":"","out":"! ! ! ! "},{"out":"[\"ab\",\"gh\"]","err":"","code":"[ 'abcdefgh' =~ /(ab)(..)*/ ]\n"},{"err":"","code":"[ \"ABCDEFGHABCD\" =~ /(?=(....))/g ]\n","out":"[\"ABCD\",\"BCDE\",\"CDEF\",\"DEFG\",\"EFGH\",\"FGHA\",\"GHAB\",\"HABC\",\"ABCD\"]"},{"code":"abcdefghi\n","err":"","out":"abcdefghi"},{"err":"","code":"'abcdefghi' =~ / (?{@a=()}) (?:(.)(?{push @a, $1})){4} (?= $ ) /x; \\@a\n","out":"[\"f\",\"g\",\"h\",\"i\"]"},{"code":" \"abc,,def,ghi,,jkl\" =~ s/(?<=,)(?=,)/\\\\N/gr\n","err":"","out":"abc,\\N,def,ghi,\\N,jkl"},{"out":"ERROR: Can't modify constant item in substitution (s///) at (eval 1) line 1, at EOF\n","code":"\"abcdefg\" =~ s/ef//; [ $-[0], length $` ]\n","err":""},{"err":"","code":"$_ = \"[a=b][c=d][e=f]\"; my @matches = /(\\[[^=]*=[^]]\\])/g; [ @matches ]\n","out":"[\"[a=b]\",\"[c=d]\",\"[e=f]\"]"},{"err":"","code":"$_ = \"[a=b][c=d][e=f]\"; my @matches = split /(\\[[^\\]]*\\])/; [ @matches ]\n","out":"[\"\",\"[a=b]\",\"\",\"[c=d]\",\"\",\"[e=f]\"]"},{"out":"[]","err":"","code":"$_ = \"[a=b][c=d][e=f]\"; my @matches = split /\\[[^\\]]*\\]/; [ @matches ]\n"},{"code":"[ 'abcdef' =~ s/cd/XY/r ];\n","err":"","out":"[\"abXYef\"]"},{"err":"","code":"['abcde' =~ /(?=(...))/g]\n","out":"[\"abc\",\"bcd\",\"cde\"]"},{"code":"$_= /a b c d/; @vars = (split)[2,3]; \\@vars\n","err":"","out":"[]"},{"err":"","code":"\"abc\" =~ /(?<gold>bc)/; $1\n","out":"bc"},{"out":"[\"B\"]","err":"","code":"'aBc' =~ m{([^a-z])}; [ $1 ]\n"},{"code":"[\"a b c\\n\", split]\n","err":"","out":"[\"a b c\\n\"]"},{"out":"[\"a\",\"b\",\"c\",\"a\",\"b\",\"c\"]","code":"@abc = qw(a b c); [ @abc => @abc ]\n","err":""},{"out":"[[\"a\",\"b\",\"c\"],$VAR1->[0]]","code":"@abc = qw(a b c); [ \\@abc => \\@abc ]\n","err":""},{"out":"ERROR: Can't modify constant item in substitution (s///) at (eval 1) line 1, at EOF\n","code":"'abc' =~ s/a//;\n","err":""},{"out":" a bc","err":"","code":"$_=\"abc\"; s/a/ a /; $_\n"},{"err":"","code":"'abc' =~ s/a//r;\n","out":"bc"},{"err":"","code":"[ \" a b c \" =~ /\\s+\\S+/g ]\n","out":"[\" a\",\" b\",\" c\"]"},{"err":"","code":"[ \" a b c \" =~ /\\s*\\S+/g ]  # to keep first non-space\n","out":"[\" a\",\" b\",\" c\"]"},{"out":"abc,\\N,\"this is ,\\N, a ,\\N, string column\",ghi,\\N,jkl","code":" 'abc,,\"this is ,, a ,, string column\",ghi,,jkl' =~ s/(?<=,)(?=,)/\\\\N/gr\n","err":""},{"code":"($a, $b) = [ print(\"Miesco\"), print(\"Miesco\") ]\n","err":"","out":"MiescoMiesco"},{"err":"","code":"'Abra Kadabra'->import; say 'Magic'\n","out":"Magic\n"},{"out":"b","code":"'a-b' =~ s/[a\\- ]//gr\n","err":""},{"err":"","code":"' a b ' =~ /\\s\\B\\s/\n","out":""},{"err":"","code":"'[a][b]' =~ s/[][]//gr\n","out":"ab"},{"out":"ab","err":"","code":"\"a()[]{}<>b\" =~ s/[][(){}<>]//gr\n"},{"err":"","code":"'a-b' =~ s/[- ]//r\n","out":"ab"},{"out":"ab","err":"","code":"'a-b' =~ s/[\\- ]//r\n"},{"code":"['A' cmp 'a']\n","err":"","out":"[-1]"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","err":"","code":"'a.com' =~ #(\\w+\\.)com$#\n"},{"out":"1","err":"","code":"\"a.com\" =~ /(?:\\w+\\.)+com$/\n"},{"code":"'a' .. 'd'\n","err":"","out":""},{"out":"[\"a\",\"b\",\"c\",\"d\"]","err":"","code":"['a' .. 'd']\n"},{"err":"","code":"add 5; sub add { $_[0]+1 }\n","out":"ERROR: syntax error at (eval 1) line 1, near \"add 5\"\n"},{"err":"","code":"$_ = '$addmodnav'; if(/^\\$addmod/i) { if(/^\\$addmod(?: )/i) { print \"some other stuff\" } else { print \"args would be printed here\" } }\n","out":"args would be printed here"},{"out":"\u0000\u0000eth0\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000","code":"$addr = PF_PACKET; $iface = \"eth0\"; $socket = pack(\"Sa14\", $addr, $iface);\n","err":""},{"out":"","err":"","code":"`adduser modulus`\n"},{"out":"[\"\\303\"]","code":"['Ã¦' =~ /([[:alpha:]])/]\n","err":""},{"out":"[]","code":"['Ã¦' =~ /([[:alpha:]])/a]\n","err":""},{"out":"\\u00c3\\u00a6\\u00c3\\u00b8\\u00c3\\u00a5","err":"","code":"$_ = \"Ã¦Ã¸Ã¥\"; s/(.)/sprintf('\\\\u%04x', ord $1)/ger\n"},{"out":"ERROR: Substitution replacement not terminated at (eval 1) line 1, <STDIN> line 1.\n","code":"$_ = \"Ã¦Ã¸Ã¥\"; s/(.)sprintf('\\\\u%04x', ord $1)/ger\n","err":""},{"code":"\"a\" eq \"b\"\n","err":"","out":""},{"out":"[\"\"]","err":"","code":"[ \"a\" eq \"b\" ]\n"},{"code":"@_ = ('a' .. 'e'); $single = @_; $single\n","err":"","out":"5"},{"out":"1","code":"@a = (foo => 1, bar => 2); print %{a}\n","err":""},{"code":"@a = (foo => 1, bar => 2); print ${{@a}}{\"a\"}\n","err":"","out":"1"},{"err":"","code":"@a = {foo => 1, bar => 2}; print ${$a}{\"foo\"}\n","out":"1"},{"out":"baz","code":"$a=\"foo bar\"; *$a = sub {\"baz\"}; \"foo bar\"->()\n","err":""},{"err":"","code":"[ \"a hash\" cmp \"an array\" ]\n","out":"[-1]"},{"out":"[\"o\",\"l\",\"lo\",\"l\",\"ll\",\"llo\",\"e\",\"el\",\"ell\",\"ello\",\"H\",\"He\",\"Hel\",\"Hell\",\"Hello\"]","err":"","code":"@a = (); \"Hello\" =~ /.+(??{unshift@a,$&})/; \\@a\n"},{"out":"[\"o\",\"lo\",\"llo\",\"ello\",\"Hello\"]","code":"@a = (); \"Hello\" =~ /.+$(??{unshift@a,$&})/; \\@a\n","err":""},{"out":"ERROR: Can't modify glob in substitution (s///) at (eval 1) line 1, at EOF\n","code":" <a href=\"http://www.yahoo.com/something.php?else=AoilkOoiud.FUoiu239834&ipadd=4.2.2.2&uri=a8s98loielulius_souej.\" min=\"s987ojeouyslkje\"> =~ s/(<.*(src|href)=\"[_%&:\\/\\?=,\\.a-z0-9-]+)[\\?|#|&]ip(ad(d(r(ess?)?)?)?)?=([1-2]?[0-9]{1,2}\\.[1-2]?[0-9]{1,2}\\.[1-2]?[0-9]{1,2}\\.[1-2]?[0-9]{1,2})([_%#&=\\/\\.a-z0-9-]*\".*>)/$1$8/isg\n","err":""},{"code":"$a = \"it works\"; print \"${chr 97}\"\n","err":"","out":"it works"},{"err":"","code":"$all = [[1,2],[4,5,6],[7,8]]; push @one, @$_ for @$all; \\@one\n","out":"[1,2,4,5,6,7,8]"},{"out":"a","code":"@_ = \"a\"; { local @_ = \"b\"; } \"@_\"\n","err":""},{"err":"","code":"'_' =~ /[:alpha:]/\n","out":""},{"err":"","code":"$alpha{1}='1'; $alpha{'01'}='01'; $alpha{2}='2'; map { print \"$alpha{$_},\"; } sort { $a <=> $b || $alpha{$b} cmp $alpha{$a} } keys %alpha\n","out":"1,01,2,"},{"out":"01,2,","err":"","code":"$alpha{1}='1'; $alpha{01}='01'; $alpha{2}='2'; map { print \"$alpha{$_},\"; } sort { $a <=> $b || $alpha{$b} cmp $alpha{$a} } keys %alpha\n"},{"code":"$alpha{a}='1'; $alpha{b}='01'; $alpha{c}='2'; map { print \"$alpha{$_},\"; } sort { $a <=> $b || $alpha{$a} cmp $alpha{$b} } keys %alpha\n","err":"","out":"01,1,2,"},{"code":"$alpha{a}='1'; $alpha{b}='01'; $alpha{c}='2'; map { print \"$alpha{$_},\"; } sort { $a <=> $b || $alpha{$b} cmp $alpha{$a} } keys %alpha\n","err":"","out":"2,1,01,"},{"err":"","code":"$alpha{a}='1'; $alpha{b}='01'; $alpha{c}='2'; map { print \"$alpha{$_},\"; } sort { $b <=> $a || $alpha{$b} cmp $alpha{$a} } keys %alpha\n","out":"2,1,01,"},{"out":"2,01,1,","code":"$alpha{a}='1'; $alpha{b}='01'; $alpha{c}='2'; map { print \"$alpha{$_},\"; } sort { $b cmp $a || $alpha{$b} <=> $alpha{$a} } keys %alpha\n","err":""},{"out":"Also this: ÃÂ°ÃÂÃÂÃÂ©","err":"","code":"\"Also this: \\N{PILE OF POO}\"\n"},{"out":"ERROR: Can't use an undefined value as a symbol reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"*{$::{Altreus}}{SCALAR}\n"},{"out":"Altrsus","err":"","code":"\"Altreus\" =~ s/^.*\\Ke/s/sr\n"},{"out":"","err":"","code":"a..'m'\n"},{"code":"'a' =~ m\\a\\\n","err":"","out":"1"},{"err":"","code":"a..'m',N..Z\n","out":""},{"code":"a..m=>N..Z\n","err":"","out":""},{"code":"[ a..'m',N..Z ] # list context\n","err":"","out":"[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"]"},{"code":"and evaldev: or so.\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"; and\"\n"},{"err":"","code":"[ ............. and in regex i have ranges []...do i parse out the [] in the regex?\n","out":"ERROR: syntax error at (eval 1) line 1, near \"[ ...\"\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n"},{"out":"[\"a\",\"a\"]","err":"","code":"[ 'a' =~ /((.))/ ] # ningu how about this?\n"},{"err":"","code":"'### An introduction to Firmware Analysis' =~ s/### (.*)/1. [$1](#\\L$1)/gr\n","out":"1. [An introduction to Firmware Analysis](#an introduction to firmware analysis)"},{"err":"","code":"[ \"Another happy day\" =~ m/(.\\K..?)/gc ]\n","out":"[\"Ano\",\"the\",\"r h\",\"app\",\"y d\",\"ay\"]"},{"code":"@answer = (); ' foo= bar1,bar2,bar3  ' =~ / +foo= +.*?(\\b\\w+\\d+)(?{push @answer, $1})(*FAIL)/; \\@answer\n","err":"","out":"[\"bar1\",\"bar2\",\"bar3\"]"},{"out":"AÃÂÃÂ§","err":"","code":"\"A\\N{U+0327}\"\n"},{"out":"ERROR: Can't locate object method \"any\" via package \"1\" (perhaps you forgot to load \"1\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"any {1} 1\n"},{"out":"ERROR: Can't call method \"any\" without a package or object reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"any {$_ eq 'a'}, 'b', 'c'\n"},{"code":"\"any string\" =~ /alias:any string/\n","err":"","out":""},{"err":"","code":"$a=\"one\"; $a = $b || undef; print $a;\n","out":"1"},{"out":"[\"\\303x\\303x\"]","err":"","code":"$_=\"ÃÃ¶\"; [ s/[^Ã¤]/x/gir ]\n"},{"out":"1","code":"'a' =~ /\\P{In_Latin1}/\n","err":""},{"out":"1","err":"","code":"$a=[]; print !!@$a;\n"},{"err":"","code":"$a=[]; print !!$a\n","out":"1"},{"out":"1","code":"$a=[]; print !!${@a}\n","err":""},{"err":"","code":"$a=[]; print !!${$a}\n","out":"ERROR: Not a SCALAR reference at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"$a=[]; print !!$@a\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"$@a\n\"\n"},{"out":"ERROR: Experimental push on scalar is now forbidden at (eval 1) line 1, at EOF\n","code":"$a = []; push $a, 1; $a  # right?\n","err":""},{"err":"","code":"\"a quine!: @_\"\n","out":"a quine!: \"a quine!: @_\""},{"code":"@a = qw(1 2 3); [ map { $_ == shift @a } @a ]\n","err":"","out":"[1,1,1]"},{"code":"@a = qw( 1 one 2 two ); print \"$_: $a[ $_ ] \" for keys @a;\n","err":"","out":"0: 1 1: one 2: 2 3: two "},{"code":"%a = qw ( 1 one 2 two ); print \"$_: $a{$_}, \" for keys %a\n","err":"","out":"1: one, 2: two, "},{"err":"","code":"%a = qw ( 1 one 2 two ); print \"$_: $a{$_}, \" for keys %s\n","out":""},{"out":"12","err":"","code":"%a = qw ( 1 one 2 two ); print keys %a\n"},{"out":"2/8","code":"%a = qw ( 1 one 2 two ); print scalar %a\n","err":""},{"out":"2","code":"%a = qw ( 1 one 2 two ); print scalar keys %a\n","err":""},{"out":"3 elems: <a><b><c>","err":"","code":"@A = qw<a b c>; sprintf \"%d elems: \" . (\"<%s>\") x @A, scalar(@A), @A;\n"},{"out":"0","code":"@a = (qw/foo bar baz/); @b = map {/bar/} @a; grep !defined, @b;\n","err":""},{"code":"@a = (qw/foo bar baz/); @b = map {/bar/} @a; print Dumper(\\@b);\n","err":"","out":"$VAR1 = [\n          1\n        ];\n"},{"err":"","code":"@a = (qw/foo bar baz/); [map {/bar/} @a]\n","out":"[1]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"qw/foo bar baz); [map {/bar\"\nUnmatched right curly bracket at (eval 1) line 1, at end of line\nUnmatched right square bracket at (eval 1) line 1, at end of line\n","code":"@a = (qw/foo bar baz); [map {/bar/} @a]\n","err":""},{"out":"[\"\",1,\"\"]","code":"@a = (qw/foo bar baz/); [map {scalar /bar/} @a]\n","err":""},{"out":"3","code":"@a = qw(f o o); undef @a; push @a, qw( b a r );\n","err":""},{"err":"","code":"$a=[qw/john paul george ringo/]; $str=join(', ', '?' x scalar @$a);\n","out":"????"},{"out":"????","err":"","code":"$a=[qw/john paul george ringo/]; $str=join(', ', ('?' x scalar @$a));\n"},{"out":"\u0000\u0000\u0000{","code":"@a = qw(N 123); sub f { &CORE::pack }; f(@a)\n","err":""},{"out":"\u0000\u0000\u0000{","code":"@a = qw(N 123); sub f { &CORE::pack(@_) }; f(@a)\n","err":""},{"out":"[]","code":"<>; \\@ARGV\n","err":""},{"err":"","code":"@ARGV\n","out":"0"},{"out":"-1","err":"","code":"$#ARGV\n"},{"err":"","code":"*ARGV = [1]; print for <>;\n","out":""},{"out":"[]","err":"","code":"@ar = (); [ map { $_->{a} } @ar ]\n"},{"out":"[]","err":"","code":"$ar = []; [ map { $_->{a} } @$ar ]\n"},{"out":"arn","code":"arn\n","err":""},{"code":"@arr = ( 1, 2, 3, 4, 5 ); if ( $#arr == 4 ){ print \"Total: $# arr\" };\n","err":"","out":"Total:  arr"},{"out":"","err":"","code":"@arr = ( 1, 2, 3, 4, 5 ); if (!@arr) { print \"array was empty\"; }\n"},{"err":"","code":"@arr = ( '1','2','3','4' ); print @arr >>;\n","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"out":"[1,\"\"]","code":"@arr = 1; [exists $arr[-1], exists $arr[-2]]\n","err":""},{"err":"","code":"@arr1 = qw/ a b c /; @arr2 = @arr1;      ++$#arr1;     [ 'Arr1:', @arr1, 'Arr2:', @arr2 ] # modulus^ it seems you don't really understand that @arr1 *actually gets changed* when you do that ...\n","out":"[\"Arr1:\",\"a\",\"b\",\"c\",undef,\"Arr2:\",\"a\",\"b\",\"c\"]"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"@arr1 = qw/ a b c /; @arr2 = @arr1;      ++$#arr1;       print '@arr1: ' . join(\n","err":""},{"out":"bob","err":"","code":"@arr1 = qw/bob alan/; @arr2 = (50, 100); @foo{@arr2} = @arr1; $foo{50}\n"},{"code":"@array/1\n","err":"","out":"0"},{"code":"@array = 1..10; [ join ',', map '?', @array ]  # so would this\n","err":"","out":"[\"?,?,?,?,?,?,?,?,?,?\"]"},{"err":"","code":"@array = 1..10; [ join ',', ('?') x @array ]\n","out":"[\"?,?,?,?,?,?,?,?,?,?\"]"},{"out":"[\\1,\\2,\\3]","err":"","code":"@array = (1,2,3); [ \\(@array) ]\n"},{"out":"","code":"@array = (1,2,3); return join(',', @accounts);\n","err":""},{"code":"@array=(1..5); $array[10]\n","err":"","out":""},{"out":"[1,2,4,8,16,32,64,128]","err":"","code":"@array = 1; for (@array) {$_ <= 100 and push @array, $_ * 2} \\@array  # hehehe  (never do this :)\n"},{"out":"k:1 v:one, k:one v:, k:2 v:two, k:two v:, ","code":"@array = ( 1=>\"one\", 2=>\"two\"); %hash = @array; map { print \"k:$_ v:$hash{$_}, \" } @array;\n","err":""},{"err":"","code":"@array = ( 1=>\"one\", 2=>\"two\"); %hash = @array; map { print \"k:$_ v:$hash{$_}\" } @array;\n","out":"k:1 v:onek:one v:k:2 v:twok:two v:"},{"code":"@array = ( 1=>\"one\", 2=>\"two\"); %hash = @array; map { print \"k:$_ v:$hash{$_}, \" } keys @array;\n","err":"","out":"k:0 v:, k:1 v:one, k:2 v:two, k:3 v:, "},{"code":"@array = ( 1=>\"one\", 2=>\"two\"); %hash = @array; map { print \"k:$_ v:$hash{$_}, \" } keys @hash;\n","err":"","out":"0"},{"out":"k:1 v:one, k:2 v:two, ","err":"","code":"@array = ( 1=>\"one\", 2=>\"two\"); %hash = @array; map { print \"k:$_ v:$hash{$_}, \" } keys %hash;\n"},{"out":"-1","err":"","code":"$#array = -2\n"},{"out":"[45,67,98]","err":"","code":"@array = (45,34,67,98); @array = grep $_ != 34, @array; \\@array\n"},{"code":"@array = (45,34,67,98); @index{@array} = 0 .. $#array; splice @array, $index{34}, 1; \\ @array\n","err":"","out":"[45,67,98]"},{"out":"[45,67,98]","code":"@array = (45,34,67,98); splice @array, $_, 1 for grep $array[$_] == 34, reverse 0 .. $#array; \\@array\n","err":""},{"code":"@array = ( 'a' .. 'c' ); printf \"Array:\" . ('%1$d - %s' x @array), 1, @array\n","err":"","out":"Array:1 - 11 - a1 - b"},{"out":"[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\"]","code":"@array = a..j;  [ @array[-@array .. -2] ]  # entire array except for last element (without modifying array)\n","err":""},{"err":"","code":"@array = (('a')x55555); scalar @array\n","out":"55555"},{"err":"","code":"@array = (('a')x55); scalar @array\n","out":"55"},{"out":"[\"a\",\"a\",\"a\",\"a\",\"a\"]","code":"@array = (('a')x5); \\@array\n","err":""},{"out":"","code":"@array = (('a')x(5x10)); scalar @array\n","err":"Out of memory!\n"},{"out":"[0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,0,2,4,6,8,10,12,14,16,18,20,0,3,6,9,12,15,18,21,24,27,30,0,4,8,12,16,20,24,28,32,36,40,0,5,10,15,20,25,30,35,40,45,50,0,6,12,18,24,30,36,42,48,54,60,0,7,14,21,28,35,42,49,56,63,70,0,8,16,24,32,40,48,56,64,72,80,0,9,18,27,36,45,54,63,72,81,90,0,10,20,30,40,50,60,70,80,90,100]","err":"","code":"@array = map { $_ % 11 * int $_ / 11 } 0..120; \\@array\n"},{"out":"ERROR: Can't call method \"any\" without a package or object reference at (eval 1) line 1, <STDIN> line 1.\n","code":"@array = qw(1 2 3); print \"match\" if(any{ $_ eq '4'} @array);\n","err":""},{"code":"@array = qw(1 2 3); say \"match\" if(any{ $_ eq '4'} @array);\n","err":"","out":"ERROR: Can't call method \"any\" without a package or object reference at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"@array = qw(1,2,3); say \"match\" if(any{ $_ eq '4'} @array);\n","err":"","out":"ERROR: Can't call method \"any\" without a package or object reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"a\",\"b\",\"c\",\"d\",\"e\",\"x\",\"f\"]","err":"","code":"@array = qw/a b c d e f/; splice @array, -1, 0, 'x'; \\@array  # voila\n"},{"code":"@array = qw/a b c d e f/; splice @array, -2, 0, 'x'; \\@array\n","err":"","out":"[\"a\",\"b\",\"c\",\"d\",\"x\",\"e\",\"f\"]"},{"out":"[\"a\",\"b\",\"c\",\"d\",\"x\",\"e\",\"f\"]","err":"","code":"@array = qw/a b c d e f/; splice @array, -2, 0, 'x'; \\@array  # voila\n"},{"out":"[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"x\"]","code":"@array = qw/a b c d e f/; splice @array, scalar(@array), 0, 'x'; \\@array  # voila\n","err":""},{"err":"","code":"@array = qw(SHOUTY SHOUT SHOUT); $_ = lc for @array; \\@array\n","out":"[\"shouty\",\"shout\",\"shout\"]"},{"err":"","code":"@array = qw//; splice @array, -2, 0, 'x'; \\@array\n","out":"ERROR: Modification of non-creatable array value attempted, subscript -2 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"b","code":"$arrayref = [\"a\",\"b\"];  \"$arrayref->[1]\"\n","err":""},{"code":"$arrayref = [ { foo => bar, baz => m00 }, { lol => lulz, schweinerei => smut } ]; $arrayref->[1]{schweinerei}\n","err":"","out":"smut"},{"out":"","err":"","code":"$arrayref=[qw/a b c/]; scalar @{$arrayref}[1,2,3]\n"},{"out":"ERROR: Can't find string terminator \"/\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"$arrayref=[qw/a b c]; scalar @{$arrayref}[1,2,3]\n"},{"err":"","code":"@arr='a'--'z';\n","out":"ERROR: Can't modify constant item in postdecrement (--) at (eval 1) line 1, near \"'a'--\"\nsyntax error at (eval 1) line 1, near \"--'z'\"\n"},{"code":"@arr = (foo => 1, bar => 2); { %{a} }\n","err":"","out":"0"},{"out":"array was empty","code":"@arr = (); if (!@arr) { print \"array was empty\"; }\n","err":""},{"err":"","code":"$arr = []; push $arr, 1; $arr\n","out":"ERROR: Experimental push on scalar is now forbidden at (eval 1) line 1, at EOF\n"},{"out":"this :3 a |0 c |0  |","err":"","code":"@arr=qw/a b c/; $b = 3; printf \"this :\".(\"%d %s |\" x @arr), $b, @arr;\n"},{"code":"@arr=qw/a b c/; @bong = (1..@arr); printf \"this :\".(\"%d %s |\" x @arr), @bong, @arr;\n","err":"","out":"this :1 2 |3 a |0 c |"},{"out":"this :3 a |0 c |0  |","err":"","code":"@arr=qw/a b c/; $bong = 3; printf \"this :\".(\"%d %s |\" x @arr), $bong, @arr;\n"},{"out":"0: 'a', 1: 'b', 2: 'c', ","code":"@arr=qw/a b c/; sprintf \"%d: '%s', \" x @arr, %arr[0 .. $#arr]\n","err":""},{"code":"@arr=qw/a b c/; $x = 3; printf '%.0s' . ('%1$d %s |' x @arr), $x, @arr;\n","err":"","out":"3 a |3 b |3 c |"},{"code":"@arr=qw/a b c/; $x = 3; printf '%1$d %s' x @arr, $x, @arr;\n","err":"","out":"3 33 a3 b"},{"err":"","code":"@arr = qw(one two three); sub f{print@{$_[0]}}f*{arr}{ref[]};\n","out":"onetwothree"},{"out":"ERROR: Unterminated <> operator at (eval 1) line 1, <STDIN> line 1.\n","code":"@arr = qw(one two three); sub f{print@{$_[0]}}f*{arr}{ref[]}; <-- *{arr}{ref[]}? o_O\n","err":""},{"code":"@arr = undef; if (!@arr) { print \"array was empty\"; }\n","err":"","out":""},{"out":"[undef]","code":"@ar = (undef); [ map { $_->{a} } @ar ]\n","err":""},{"err":"","code":"$ar = [undef]; [ map { $_->{a} } @$ar ]\n","out":"[undef]"},{"code":"[ 'a' =~ s/(.)/('$1','$1')/re ]\n","err":"","out":"[\"\\$1\"]"},{"out":"[\"a\"]","err":"","code":"[ 'a' =~ s/(.)/($1,$1)/re ]\n"},{"code":"[ 'a' =~ s/(.)/($1) x 2/re ]\n","err":"","out":"[\"aa\"]"},{"out":"a","err":"","code":"'A' =~ s/(A)/lcfirst $1/re\n"},{"code":"$_=\"Ã\"; [ s/Ã¤/x/ir ]\n","err":"","out":"[\"\\303\\204\"]"},{"out":"[\"asd1312321\",\"asd1212\",\"asd121212\"]","code":"[ \"asd1312321asd1212asd121212\" =~/(asd\\d+)/g ]\n","err":""},{"code":"~\"asdf\"\n","err":"","out":"ÃÂÃÂÃÂÃÂ"},{"code":"$asdf = []; 0 + !!@$blah\n","err":"","out":"0"},{"out":"[\"f\"]","err":"","code":"\"asdf\" =~ /(.)+/; [ $1 ]\n"},{"out":"1","err":"","code":"$asdf=[1,2]; !!@$asdf;\n"},{"err":"","code":"$asdf=[]; !!@$asdf;\n","out":""},{"out":"1","code":"\"asd.fg.foo.asd.fg\" =~ /(.*)\\.([^.]*)\\.\\1/\n","err":""},{"out":"1","code":"$asdf=[]; print !!@$asdf;\n","err":""},{"code":"\"        asdf    \" =~ /^([\\t ]+)/; my $indents = () = $1 =~ /(\\t| {4})/g\n","err":"","out":"2"},{"err":"","code":"\"        asdf    \" =~ /^([\\t ]+)/; my $indents = () = $1 =~ /(\\t| {8})/g\n","out":"1"},{"out":"2","err":"","code":"\"        asdf    \" =~ /^([\\t\\s]+)/; my $indents = () = $1 =~ /(\\t|\\s{4})/g\n"},{"code":"\"        asdf    \" =~ /^[\\t\\s]+/; my $indents = () = $1 =~ /(\\t|\\s{4})/g\n","err":"","out":"0"},{"out":"yes","code":"(\"asdfX\" ^ \"asdfY\") =~ /^\\0*[^\\0]\\z/ ? 'yes' : 'no'\n","err":""},{"out":"yes","err":"","code":"(\"asdfYt\" ^ \"asdfY\") =~ /^\\0*[^\\0]\\z/ ? 'yes' : 'no'\n"},{"code":"[ \"asd   qwe\" =~ /(\\w+)\\s(\\w+?)/ ]\n","err":"","out":"[]"},{"out":"[\"asd\",\"q\"]","code":"[ \"asd   qwe\" =~ /(\\w+)\\s+(\\w+?)/ ]\n","err":""},{"out":"a","err":"","code":"\"a\" =~ s/(.)/\\l$1/r\n"},{"err":"","code":"\"A\" =~ s/(.)/\\l$1/r\n","out":"a"},{"out":"214365","code":"@a = split //, 123456; join '', @a[map $_^1, 0..$#a]\n","err":""},{"out":"1","code":"\"a string literal\" ~~ [\"a string literal\"]\n","err":""},{"err":"","code":"[ \"a string literal\" ] ~~ \"a string literal\"\n","out":""},{"out":"","code":"[\"a string literal\"] ~~ [\"a string literal\", \"another string literal\"]\n","err":""},{"code":"{ a => sub { print 'foo' } }->{a}()\n","err":"","out":"foo"},{"out":"ERROR: Usage: POSIX::atan(x) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"atan(0, -1)\n"},{"code":"atan2(0, -1)\n","err":"","out":"3.14159265358979"},{"code":"'atcg' ^ 'agcg'\n","err":"","out":"\u0000\u0013\u0000\u0000"},{"out":"ÃÂÃÂ{0086}ther","err":"","code":"\"Ã\\u{0086}ther\"\n"},{"out":"ÃÂÃÂ0086ther","err":"","code":"\"Ã\\u0086ther\"\n"},{"out":"ERROR: Can't locate print.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"$a=[]; use print !!$a\n","err":""},{"out":"","err":"","code":"(\"a\" x 20) =~ /a*b/;\n"},{"err":"","code":"[ (\"a\" x 20) =~ /(a*b)/ ];\n","out":"[]"},{"code":"[ (\"a\" x 20 . \"b\") =~ /((a*?)*b)/ ];\n","err":"","out":"[\"aaaaaaaaaaaaaaaaaaaab\",\"\"]"},{"out":"[\"aaaaaaaaaaaaaaaaaaaab\",\"\"]","code":"[ (\"a\" x 20 . \"b\") =~ /((a*)*b)/ ];\n","err":""},{"out":"[\"aaaaaaaaaaaaaaaaaaaab\",\"a\"]","code":"[ (\"a\" x 20 . \"b\") =~ /((a+?)*b)/ ];\n","err":""},{"err":"","code":"[ (\"a\" x 20 . \"b\") =~ /((a+)*b)/ ];\n","out":"[\"aaaaaaaaaaaaaaaaaaaab\",\"aaaaaaaaaaaaaaaaaaaa\"]"},{"out":"[\"aaaaaaaaaaaaaaaaaaaab\"]","code":"[ (\"a\" x 20 . \"b\") =~ /(a*?b)/ ];\n","err":""},{"out":"aaa","code":"'a' x 3\n","err":""},{"err":"","code":"[('a'++)x3]\n","out":"ERROR: Can't modify constant item in postincrement (++) at (eval 1) line 1, near \"'a'++\"\n"},{"out":"[\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"\"]","err":"","code":"[ (\"a\" x 30) =~ /((a|a?)+)/ ];\n"},{"out":"[\"aaaa\"]","code":"['a' x 4]\n","err":""},{"err":"","code":"[('a') x 4]\n","out":"[\"a\",\"a\",\"a\",\"a\"]"},{"out":"a,a,a,a,a,a,a,a,a,a,\na,a,a,a,a,a,a,a,a,a,\na,a,a,a,a,a,a,a,a,a,\na,a,a,a,a,a,a,a,a,a,\na,a,a,a,a,","err":"","code":"('a,'x45) =~ s/(.*?,){10}\\K/\\n/gr\n"},{"err":"","code":"[ 'a' x 'b' ]\n","out":"[\"\"]"},{"code":"[ 'axcom' =~ /a.com/ ? 'yes' : 'no' ]\n","err":"","out":"[\"yes\"]"},{"out":"[\"\"]","code":"[\"a\" xor \"a\"]\n","err":""},{"code":"\"A-Z\" =~ /A-Z/ ? 'true' : 'false'\n","err":"","out":"true"},{"out":"_[a-z]+_(bd\\d+_[a-z0-9]{7}_\\d{6}_\\d{4}(AM|PM)_PST).tar.gz","code":"'_[a-z]+_(bd\\d+_[a-z0-9]{7}_\\d{6}_\\d{4}(AM|PM)_PST).tar.gz'\n","err":""},{"out":"\\\\\\\\\\\\","code":"\"\\\\\\\\\\\\\\\\$backup_server\\\\\\\\$host\"\n","err":""},{"err":"","code":"\"\\\\\\\\\\\\\\\\backup_server\\\\\\\\host\"\n","out":"\\\\\\\\backup_server\\\\host"},{"out":"[1,1]","err":"","code":"\"banana\" =~ /(a)/; [ @- ]\n"},{"out":"[22]","code":"\"banana\" =~ /(a)/; \\@-\n","err":""},{"out":"[20]","code":"\"banana\" =~ /a/; \\@-\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"=~ ?\"\n","err":"","code":"[ \"banana\" =~ ?a? ]\n"},{"out":"[\"ba\",\"na\",\"na\"]","err":"","code":"[ \"banana\" =~ /.a/g ]\n"},{"err":"","code":"() = 'banana' =~ /(?=ana)/g\n","out":"2"},{"err":"","code":"\"banana\" =~ /apple/; join //, qw(foo bar baz)\n","out":"foo1bar1baz"},{"err":"","code":"\"banana\" =~ /b(a)/; [ @- ]\n","out":"[0,1]"},{"out":"[0,0]","code":"\"banana\" =~ /(b|a|n)/g; [@-]\n","err":""},{"err":"","code":"('banana' ^ 'batman') =~ s/(.)/chr(ord \"0\" + !ord $1)/ger\n","out":"110000"},{"out":"002111","code":"('banana' ^ 'batman') =~ s/(.)/chr(ord \"0\" + ord $1)/ger\n","err":""},{"err":"","code":"('banana' ^ 'batma') =~ s/(.)/chr(ord \"0\" + !ord $1)/ger\n","out":"110000"},{"out":"[undef,\"banana\"]","code":"$_ = \"banana\"; $from =~ /$_/i; [$from, $_]\n","err":""},{"code":"$_ = \"banana\"; $from =~ /$_/i; [$from, $_, scalar /$_/i]\n","err":"","out":"[undef,\"banana\",1]"},{"code":"bananas\n","err":"","out":"bananas"},{"code":"\"banana\" =~ s/a/o/gr\n","err":"","out":"bonono"},{"out":"[1]","err":"","code":"$_ = \"banana\"; [ s/(ba)/bo/ ]\n"},{"code":"$_ = \"banana\"; s/./sprintf '%2x', ord $&/ge; $_\n","err":"","out":"62616e616e61"},{"code":"\"banana\" =~ s/(.)/sprintf \"\\\\x%x\", $1/gers\n","err":"","out":"\\x0\\x0\\x0\\x0\\x0\\x0"},{"out":"\\x62\\x61\\x6e\\x61\\x6e\\x61","err":"","code":"\"banana\" =~ s/(.)/sprintf \"\\\\x%x\", ord $1/gers\n"},{"out":"110000","code":"('banan' ^ 'batman') =~ s/(.)/chr(ord \"0\" + !ord $1)/ger\n","err":""},{"code":"\"banannas\" =~ /anna/\n","err":"","out":"1"},{"out":"+bar","code":"-(-bar)\n","err":""},{"out":"bar","code":"'bar'\n","err":""},{"code":"'bar'+0\n","err":"","out":"0"},{"err":"","code":"$_ = \"barbb\"; my $count = 0 + s/b//g; [ $count, length($_), $_ ]\n","out":"[3,2,\"ar\"]"},{"err":"","code":"[ $_ = \"barbb\") =~ s/b//g ]\n","out":"ERROR: syntax error at (eval 1) line 1, near \"\"barbb\") \"\n"},{"out":"ERROR: Search pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"$_ = \" bar\"; /(foo)? (bar); [$1, $2]\n"},{"err":"","code":"$_ = \" bar\"; /(foo)? (bar)/; [$1, $2]\n","out":"[undef,\"bar\"]"},{"err":"","code":"-(-'bar') # lul wat?\n","out":"+bar"},{"err":"","code":"\"B\" =~ /A-Z/ ? 'true' : 'false'\n","out":"false"},{"code":"\"bead^corn\" =~ /d^/\n","err":"","out":""},{"out":"beans [and rice--> ] <--","code":"'beans [and rice]' =~ s/[]]/--> ] <--/r\n","err":""},{"code":"\"beans\" . ' ' . \"cornbread\"\n","err":"","out":"beans cornbread"},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(<>\"\n","err":"","code":"BEGIN(<>)\n"},{"out":"","err":"","code":"BEGIN { *CORE::GLOBAL::defined = sub { 42 }; } defined\n"},{"out":"42","code":"BEGIN { *CORE::GLOBAL::ref = sub { 42 }; }  ref 42\n","err":""},{"out":"er, wait","code":"BEGIN { *CORE::GLOBAL::ref = sub { \"er, wait\" }; }  ref 42\n","err":""},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(&)\"\nBEGIN not safe after errors--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":" BEGIN { *foo = sub (&) { shift->(\"wibble\") } } foo { [ @_ ] }\n"},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(&)\"\nBEGIN not safe after errors--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":" BEGIN { *foo = sub (&) { shift->(\"wibble\") } foo { [ @_ ] }\n","err":""},{"out":"[\"asdf\\n\"]","code":"BEGIN { $^H = 0 }; open $fh, \">\", \\$str; $fh->say('asdf'); [ $str ]\n","err":""},{"code":"BEGIN { $^H = 0 }; open $fh, \">\", \\$str; say {$fh} 'asdf'; [ $str ]\n","err":"","out":"[\"asdf\\n\"]"},{"out":"[\"asdf\\n\"]","err":"","code":"BEGIN { $^H = 0 }; open $fh, \">\", \\$str; say $fh 'asdf'; [ $str ]\n"},{"err":"","code":"BEGIN { $^H = 0 }; open $fh, \">\", \\$str; say {$fh} 'main'; [ $str ]\n","out":"[\"main\\n\"]"},{"err":"","code":"BEGIN { $^H = 0 }; say 42;\n","out":"ERROR: syntax error at (eval 1) line 1, near \"say 42\"\n"},{"code":"BEGIN { $^H = 0 }; say {$fh} 'main';\n","err":"","out":"ERROR: Can't call method \"say\" on an undefined value at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"BEGIN { $^H{q} = sub {}; $^H |= 0x8000; } defined 'foo'\n","out":"ERROR: Constant(q): Call to &{$^H{q}} did not return a defined value at (eval 1) line 1, near \"defined 'foo'\"\n"},{"code":"BEGIN { *keyys = \\&CORE::keys; } my %foo = 1 .. 10; [ keyys %foo ]\n","err":"","out":"[7,9,5,1,3]"},{"code":"BEGIN { *main::defined = sub { !1 } } defined(\"womble\") ? \"yes\" : \"no\"\n","err":"","out":"yes"},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"BEGIN{ my $p = \\__PACKAGE__; &Internals::SvREADONLY($p, 0); $$p = 'foo'; } [ caller(0) ]\n","err":""},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"BEGIN{ my $p = \\__PACKAGE__; &Internals::SvREADONLY($p, 0); $$p = 'foo'; } [ __PACKAGE__ ]\n","err":""},{"out":"ERROR: Missing $ on loop variable at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"BEGIN { no strict 'refs'; *$_ = sub () :lvalue { state $x; $x } for qw/foo bar baz/; } foo = 1; bar = 2; baz = 3; [ foo, bar, baz ] # works for whatever\n"},{"code":"BEGIN { overload::constant integer => sub { state $x = 5; $x++ }; } my $foo = \"5\"; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say \"surprise!\" }\n","err":"","out":"surprise!\n"},{"err":"","code":"BEGIN { package X; *::defined = \\&::defined; } sub defined { 42 } defined\n","out":""},{"out":"","code":"BEGIN { $SIG{__DIE__} = sub { say 42; exit  };  }  a bc\n","err":""},{"out":"42\nERROR: Can't locate object method \"a\" via package \"bc\" (perhaps you forgot to load \"bc\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"BEGIN { $SIG{__DIE__} = sub { say 42; return  };  }  a bc\n"},{"out":"[1,1,\\1,0,\"\",\\\"\",0,\"\",$VAR1->[5],1,1,$VAR1->[2]]","err":"","code":"BEGIN { $::{true} = \\!!1; $::{false} = \\!!0 }; [ map { 0+$_, ''.$_, \\$_ } true, false, !!0, !!1 ];\n"},{"out":"","err":"","code":"BEGIN{$^W=1}join+($x)x101\n"},{"code":"BEGIN { $::{wtf} = \\\"hi\"; } \"wtf\"->();\n","err":"","out":"hi"},{"code":"BEGIN { $::{wtf} = \\\"hi\"; } wtf()\n","err":"","out":"hi"},{"code":"BEGIN { $::{wtf} = \\\"hi\"; } wtf( \"bleh\" )\n","err":"","out":"ERROR: Too many arguments for main::wtf at (eval 1) line 1, near \"\"bleh\" )\n\"\n"},{"out":"[\"big endian: 114\",\"little endian: 1912602624\"]","code":"[\"big endian: \" . 0x0000_0072, \"little endian: \" . 0x7200_0000 ]\n","err":""},{"code":"\"big fan of Fred, Frederick, and Wilma.\" =~ s/\\b(Fred|Wilma)\\b/Barney/gr\n","err":"","out":"big fan of Barney, Frederick, and Barney."},{"code":"() = bike .. care\n","err":"","out":"12351"},{"err":"","code":"`/bin/ls`\n","out":""},{"err":"","code":"`/bin/ls`; $!\n","out":"Too many open files"},{"code":"binmode select; print chr 8305\n","err":"","out":"ÃÂ¢ÃÂÃÂ±"},{"code":"binmode STDOUT; a^\"â¹\"^b\n","err":"","out":"Ã¡ÂÂ¹"},{"code":"binmode STDOUT; \"â¡\"^b^u^u\n","err":"","out":"ÂÂÂ¡"},{"out":"Ã¢ÂÂ­CÃ¢ÂÂ® Ã¢ÂÂ­aÃ¢ÂÂ® Ã¢ÂÂ­MÃ¢ÂÂ®!Ã¢ÂÂ­eÃ¢ÂÂ®yÃ¢ÂÂ­LÃ¢ÂÂ®LÃ¢ÂÂ­ Ã¢ÂÂ®lÃ¢ÂÂ­cÃ¢ÂÂ®IÃ¢ÂÂ­AÃ¢ÂÂ®sÃ¢ÂÂ­sÃ¢ÂÂ® Ã¢ÂÂ­EÃ¢ÂÂ®SÃ¢ÂÂ­ Ã¢ÂÂ®iÃ¢ÂÂ­ Ã¢ÂÂ® ","code":"binmode STDOUT; $_ = \"CaMeL cAsE   iS sIlLy!  \"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n","err":""},{"code":"binmode STDOUT; $_ = \"CaMeL cAsE   iS sIlLy! ?\"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n","err":"","out":"Ã¢ÂÂ­CÃ¢ÂÂ®?Ã¢ÂÂ­aÃ¢ÂÂ® Ã¢ÂÂ­MÃ¢ÂÂ®!Ã¢ÂÂ­eÃ¢ÂÂ®yÃ¢ÂÂ­LÃ¢ÂÂ®LÃ¢ÂÂ­ Ã¢ÂÂ®lÃ¢ÂÂ­cÃ¢ÂÂ®IÃ¢ÂÂ­AÃ¢ÂÂ®sÃ¢ÂÂ­sÃ¢ÂÂ® Ã¢ÂÂ­EÃ¢ÂÂ®SÃ¢ÂÂ­ Ã¢ÂÂ®iÃ¢ÂÂ­ Ã¢ÂÂ® "},{"err":"","code":"binmode STDOUT; $_ = \"CaMeL cAsE   iS sIlLy! \"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n","out":"Ã¢ÂÂ­CÃ¢ÂÂ® Ã¢ÂÂ­aÃ¢ÂÂ®!Ã¢ÂÂ­MÃ¢ÂÂ®yÃ¢ÂÂ­eÃ¢ÂÂ®LÃ¢ÂÂ­LÃ¢ÂÂ®lÃ¢ÂÂ­ Ã¢ÂÂ®IÃ¢ÂÂ­cÃ¢ÂÂ®sÃ¢ÂÂ­AÃ¢ÂÂ® Ã¢ÂÂ­sÃ¢ÂÂ®SÃ¢ÂÂ­EÃ¢ÂÂ®iÃ¢ÂÂ­ Ã¢ÂÂ® "},{"code":"binmode STDOUT; $_ = \"CaMeL cAsE  iS sIlLy! \"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n","err":"","out":"Ã¢ÂÂ­CÃ¢ÂÂ® Ã¢ÂÂ­aÃ¢ÂÂ®!Ã¢ÂÂ­MÃ¢ÂÂ®yÃ¢ÂÂ­eÃ¢ÂÂ®LÃ¢ÂÂ­LÃ¢ÂÂ®lÃ¢ÂÂ­ Ã¢ÂÂ®IÃ¢ÂÂ­cÃ¢ÂÂ®sÃ¢ÂÂ­AÃ¢ÂÂ® Ã¢ÂÂ­sÃ¢ÂÂ®SÃ¢ÂÂ­EÃ¢ÂÂ®iÃ¢ÂÂ­ Ã¢ÂÂ® "},{"out":"Ã¢ÂÂ­CÃ¢ÂÂ® Ã¢ÂÂ­aÃ¢ÂÂ®!Ã¢ÂÂ­MÃ¢ÂÂ®yÃ¢ÂÂ­eÃ¢ÂÂ®LÃ¢ÂÂ­LÃ¢ÂÂ®lÃ¢ÂÂ­ Ã¢ÂÂ®IÃ¢ÂÂ­cÃ¢ÂÂ®sÃ¢ÂÂ­AÃ¢ÂÂ® Ã¢ÂÂ­sÃ¢ÂÂ®SÃ¢ÂÂ­EÃ¢ÂÂ®i","err":"","code":"binmode STDOUT; $_ = \"CaMeL cAsE iS sIlLy! \"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n"},{"out":"Ã¢ÂÂ­CÃ¢ÂÂ®!Ã¢ÂÂ­aÃ¢ÂÂ®yÃ¢ÂÂ­MÃ¢ÂÂ®LÃ¢ÂÂ­eÃ¢ÂÂ®lÃ¢ÂÂ­LÃ¢ÂÂ®IÃ¢ÂÂ­ Ã¢ÂÂ®sÃ¢ÂÂ­cÃ¢ÂÂ® Ã¢ÂÂ­AÃ¢ÂÂ®SÃ¢ÂÂ­sÃ¢ÂÂ®iÃ¢ÂÂ­EÃ¢ÂÂ® ","code":"binmode STDOUT; $_ = \"CaMeL cAsE iS sIlLy!\"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n","err":""},{"out":"Ã¯Â¿Â½Ã¯Â¿Â½Ã¯Â¿Â½Ã¯Â¿Â½Ã¯Â¿Â½Ã¯Â¿Â½","err":"","code":"binmode STDOUT; Encode::decode(\"utf-8\", \"\\x99\\x99\\x99\\x99\\x99\\x99\")\n"},{"code":"binmode STDOUT; $_ = \"Just another Perl/BIDI Hacker,\"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n","err":"","out":"Ã¢ÂÂ­JÃ¢ÂÂ®,Ã¢ÂÂ­uÃ¢ÂÂ®rÃ¢ÂÂ­sÃ¢ÂÂ®eÃ¢ÂÂ­tÃ¢ÂÂ®kÃ¢ÂÂ­ Ã¢ÂÂ®cÃ¢ÂÂ­aÃ¢ÂÂ®aÃ¢ÂÂ­nÃ¢ÂÂ®HÃ¢ÂÂ­oÃ¢ÂÂ® Ã¢ÂÂ­tÃ¢ÂÂ®IÃ¢ÂÂ­hÃ¢ÂÂ®DÃ¢ÂÂ­eÃ¢ÂÂ®IÃ¢ÂÂ­rÃ¢ÂÂ®BÃ¢ÂÂ­ Ã¢ÂÂ®/Ã¢ÂÂ­PÃ¢ÂÂ®lÃ¢ÂÂ­eÃ¢ÂÂ®r"},{"code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\xff00-\\xff5f]r;\n","err":"","out":"XÂÂÂÃ¿o|}ÂvsÂÃ¿c|wq}rsÃ¿voqysÂ:"},{"code":"binmode STDOUT; \"\\N{SPARKLE}\";\n","err":"","out":"Ã¢ÂÂ"},{"out":"Ã°ÂÂÂ©","code":"binmode STDOUT; print \"\\x{1f4a9}\"\n","err":""},{"out":"0123456789ÃÂ ÃÂ¡ÃÂ¢ÃÂ£ÃÂ¤ÃÂ¥ÃÂ¦ÃÂ§ÃÂ¨ÃÂ©ÃÂ°ÃÂ±ÃÂ²ÃÂ³ÃÂ´ÃÂµÃÂ¶ÃÂ·ÃÂ¸ÃÂ¹ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃ Â¥Â¦Ã Â¥Â§Ã Â¥Â¨Ã Â¥Â©Ã Â¥ÂªÃ Â¥Â«Ã Â¥Â¬Ã Â¥Â­Ã Â¥Â®Ã Â¥Â¯Ã Â§Â¦Ã Â§Â§Ã Â§Â¨Ã Â§Â©Ã Â§ÂªÃ Â§Â«Ã Â§Â¬Ã Â§Â­Ã Â§Â®Ã Â§Â¯Ã Â©Â¦Ã Â©Â§Ã Â©Â¨Ã Â©Â©Ã Â©ÂªÃ Â©Â«Ã Â©Â¬Ã Â©Â­Ã Â©Â®Ã Â©Â¯Ã Â«Â¦Ã Â«Â§Ã Â«Â¨Ã Â«Â©Ã Â«ÂªÃ Â«Â«Ã Â«Â¬Ã Â«Â­Ã Â«Â®Ã Â«Â¯Ã Â­Â¦Ã Â­Â§Ã Â­Â¨Ã Â­Â©Ã Â­ÂªÃ Â­Â«Ã Â­Â¬Ã Â­Â­Ã Â­Â®Ã Â­Â¯Ã Â¯Â¦Ã Â¯Â§Ã Â¯Â¨Ã Â¯Â©Ã Â¯ÂªÃ Â¯Â«Ã Â¯Â¬Ã Â¯Â­Ã Â¯Â®Ã Â¯Â¯Ã Â±Â¦Ã Â±Â§Ã Â±Â¨Ã Â±Â©Ã Â±ÂªÃ Â±Â«Ã Â±Â¬Ã Â±Â­Ã Â±Â®Ã Â±Â¯Ã Â³Â¦Ã Â³Â§Ã Â³Â¨Ã Â³Â©Ã Â³ÂªÃ Â³Â«Ã Â³Â¬Ã Â³Â­Ã Â³Â®Ã Â³Â¯Ã ÂµÂ¦Ã ÂµÂ§Ã ÂµÂ¨Ã ÂµÂ©Ã ÂµÂªÃ ÂµÂ«Ã ÂµÂ¬Ã ÂµÂ­Ã ÂµÂ®Ã ÂµÂ¯Ã Â·Â¦Ã Â·Â§Ã Â·Â¨Ã Â·Â©Ã Â·ÂªÃ Â·Â«Ã Â·Â¬Ã Â·Â­Ã Â·Â®Ã Â·Â¯Ã Â¹Â","err":"","code":"binmode STDOUT, ':raw'; print grep { /\\d/ } map { chr } 0x1..0xe50 # for pink_mist's irssi\n"},{"out":"Ã°ÂÂÂ§Ã°ÂÂÂ¨Ã°ÂÂÂ©Ã°ÂÂÂªÃ°ÂÂÂ«Ã°ÂÂÂ¬Ã°ÂÂÂ­Ã°ÂÂÂ®Ã°ÂÂÂ¯Ã°ÂÂÂ°Ã°ÂÂÂ±Ã°ÂÂÂ²Ã°ÂÂÂ³Ã°ÂÂÂ´Ã°ÂÂÂµÃ°ÂÂÂ¶Ã°ÂÂÂ·Ã°ÂÂÂ¸Ã°ÂÂÂ¹Ã°ÂÂÂ¶Ã°ÂÂÂ·Ã°ÂÂÂ¸Ã°ÂÂÂ¹Ã°ÂÂÂºÃ°ÂÂÂ»Ã°ÂÂÂ¼Ã°ÂÂÂ½Ã°ÂÂÂ¾Ã°ÂÂÂ¿Ã°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂ°Ã°ÂÂÂ±Ã°ÂÂÂ²Ã°ÂÂÂ³Ã°ÂÂÂ´Ã°ÂÂÂµÃ°ÂÂÂ¶Ã°ÂÂÂ·Ã°ÂÂÂ¸Ã°ÂÂÂ¹Ã°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂ°Ã°ÂÂÂ±Ã°ÂÂÂ²Ã°ÂÂÂ³Ã°ÂÂÂ´Ã°ÂÂÂµÃ°ÂÂÂ¶Ã°ÂÂÂ·Ã°ÂÂÂ¸Ã°ÂÂÂ¹Ã°ÂÂ£Â Ã°ÂÂ£Â¡Ã°ÂÂ£Â¢Ã°ÂÂ£Â£Ã°ÂÂ£Â¤Ã°ÂÂ£Â¥Ã°ÂÂ£Â¦Ã°ÂÂ£Â§Ã°ÂÂ£Â¨Ã°ÂÂ£Â©Ã°ÂÂ©Â Ã°ÂÂ©Â¡Ã°ÂÂ©Â¢Ã°ÂÂ©Â£Ã°ÂÂ©Â¤Ã°ÂÂ©Â¥Ã°ÂÂ©Â¦Ã°ÂÂ©Â§Ã°ÂÂ©Â¨Ã°ÂÂ©Â©Ã°ÂÂ­ÂÃ°ÂÂ­ÂÃ°ÂÂ­ÂÃ°ÂÂ­ÂÃ°ÂÂ­ÂÃ°ÂÂ­ÂÃ°ÂÂ­ÂÃ°ÂÂ­ÂÃ°ÂÂ­ÂÃ°ÂÂ­ÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂ Ã°ÂÂÂ¡Ã°ÂÂÂ¢Ã°ÂÂÂ£Ã°ÂÂÂ¤Ã°ÂÂÂ¥Ã°ÂÂÂ¦Ã°ÂÂÂ§Ã°ÂÂÂ¨Ã°ÂÂÂ©Ã°ÂÂÂªÃ°ÂÂÂ«Ã°ÂÂÂ¬Ã°ÂÂÂ­Ã°ÂÂÂ®Ã°ÂÂÂ¯Ã°ÂÂÂ°Ã°ÂÂÂ±Ã°ÂÂÂ²Ã°ÂÂÂ³Ã°ÂÂÂ´Ã°ÂÂÂµÃ°ÂÂÂ¶Ã°ÂÂÂ·Ã°ÂÂÂ¸Ã°ÂÂÂ¹Ã°ÂÂÂºÃ°ÂÂÂ»Ã°ÂÂÂ¼Ã°ÂÂÂ½Ã°ÂÂÂ¾Ã°ÂÂÂ¿","err":"","code":"binmode STDOUT, ':raw'; print grep { /\\d/ } map { chr } 0x11067..0x10ffff # how about these fonts ;)\n"},{"out":"13","err":"","code":"$bla = (12, 13); $bla\n"},{"out":"[12,undef,undef]","err":"","code":"($bla = ($bli, $blu)) = (12, 13, 14); [$bla, $bli, $blu]\n"},{"out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"'blah blah '\\'' blah blah '\\'' blah blah'\n","err":""},{"code":"'blah' . print \"a\" . 'blah' . print \"b\"\n","err":"","out":"bablah1"},{"out":"[\"hah\"]","code":"[ \"blah\" =~ s/bl/h/r ]\n","err":""},{"out":"","code":"$blah = { x=>1 }; $z => { y=>$blah->{x} }; $blah->{x} = \"hello\"; $z->{y}\n","err":""},{"out":"no match","code":"\"blalapi0\" =~ /^lapi0$/ ? \"match\" : \"no match\"\n","err":""},{"code":"\"bleep\"->bloop\n","err":"","out":"ERROR: Can't locate object method \"bloop\" via package \"bleep\" (perhaps you forgot to load \"bleep\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"[ \"blehAAtingtongtangTTthe cat\" =~ m/(AA.{1,23}TT)/ ]\n","out":"[\"AAtingtongtangTT\"]"},{"err":"","code":"$bleh = sub { print $_[0]; }; $bleh->(\"two\");\n","out":"two"},{"out":"1","err":"","code":"$bleh = sub { print \"$_\" }; $bleh->(\"one\");\n"},{"code":"$bleh = sub { print \"$_\" }; $bleh->(\"two\");\n","err":"","out":"1"},{"out":"two","err":"","code":"$bleh = sub { print shift }; $bleh->(\"two\");\n"},{"err":"","code":"bless {}, \"\"\n","out":"bless( {}, 'main' )"},{"code":"bless [], \"\\0\" # or something\n","err":"","out":"bless( [], '' )"},{"out":"bless( do{\\(my $o = undef)}, 'trolol' )","code":"bless \\do { my $nou = undef }, \"trolol\"\n","err":""},{"err":"","code":"bless {}, pack(\"ll\",0xFEEDFACE,0xDEADBEEF)\n","out":"bless( {}, 'ÃÂÃÂºÃÂ­ÃÂ¾ÃÂ¯ÃÂ¾ÃÂ­ÃÂ' )"},{"code":"bless \\undef, \"trolol\"\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"bless you\n","out":"ERROR: Can't bless non-reference value at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"bless \\'you', 'Altreus'\n"},{"err":"","code":"bless([], \"your::face\")->import(42);\n","out":""},{"out":"ERROR: Can't locate object method \"new\" via package \"Blubb\" (perhaps you forgot to load \"Blubb\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"Blubb->new\n","err":""},{"err":"","code":"\"bold test end bold\"\n","out":"bold test end bold"},{"err":"","code":"\" \u0002*bold*\u0002 \u001f_underline_\u001f /italics/ normal \"\n","out":" \u0002*bold*\u0002 \u001f_underline_\u001f /italics/ normal "},{"code":"'bool' gt '_Bool'\n","err":"","out":"1"},{"err":"","code":"[ 'boooo' =~ /\\w*(.)\\1\\w*/g ]\n","out":"[\"o\"]"},{"out":"btw, you can do the same kind of thing with trigger.pl","code":"\"btw, you can do the same kind of thing with trigger.pl\"\n","err":""},{"err":"","code":"\"but not this\" =~ m/^(a+)/ and $+[1]\n","out":""},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","err":"","code":"but where do i put the test?\n"},{"err":"","code":"buu\n","out":"buu"},{"err":"Out of memory!\npanic: fold_constants JMPENV_PUSH returned 2, <STDIN> line 1.\n","code":"\"b\"x10e10\n","out":""},{"code":"\"\\^C\"\n","err":"","out":"^C"},{"out":"0","err":"","code":"$^C\n"},{"code":"$c = 0; [ ' foo (bar (baz) quux (blop)) ' =~ s/[()]/$& eq '(' ? $c++ ? '[' : $& : --$c ? ']' : $&/ger ]\n","err":"","out":"[\" foo (bar [baz] quux [blop]) \"]"},{"err":"","code":"$c = 1; while(my $e = glob \"{foo,bar}\") {print $c++, \") \", $e, \"    \"}\n","out":"1) foo    2) bar    "},{"err":"","code":"(caller(1))[3]\n","out":"main::perl_code"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"$(caller\"\n","code":"$(caller(1))[3]\n","err":""},{"code":"${(caller(1))}[3]\n","err":"","out":""},{"out":"ERROR: Can't call method \"can\" without a package or object reference at (eval 1) line 1, <STDIN> line 1.\n","code":"\"\"->can(\"foo\");\n","err":""},{"out":"","code":"'.canvas_container' =~ /\\b\\.canvas/\n","err":""},{"out":"1","err":"","code":"($capt) = 'hello world' =~ /(hello)/\n"},{"err":"","code":"($capt) = 'hello world' =~ /(hello)/; $cap\n","out":""},{"out":"hello","err":"","code":"($capt) = 'hello world' =~ /(hello)/; $capt\n"},{"code":"[ \"cat 10\" =~ /(?:cat|dog)\\s(\\d+)/ ]\n","err":"","out":"[10]"},{"out":"[undef]","err":"","code":"[ \"cat 10\" =~ /(?:cat)|(?:dog)\\s(\\d+)/ ]\n"},{"out":"[\"ca\",\"at\",\"td\",\"do\",\"og\"]","code":"[ 'catdog' =~ /(?=(\\w{2}))./sg ]\n","err":""},{"err":"","code":"[ 'catdog' =~ /(\\w\\K\\w)/g ]\n","out":"[\"ca\",\"td\",\"og\"]"},{"err":"","code":"cats\n","out":"cats"},{"code":"~'cats'\n","err":"","out":"ÃÂÃÂÃÂÃÂ"},{"out":"","code":"\"@cats\"\n","err":""},{"out":"[\"cats\"]","err":"","code":"[ \"\" || \"cats\" ]\n"},{"out":"cats","code":"+\"cats\"\n","err":""},{"code":"\"cats and dogs say hello world\" =~ /hello world/\n","err":"","out":"1"},{"err":"","code":"$cats = \"cats\"; $cats =~ s{$cats}'$dogs'r\n","out":"$dogs"},{"code":"$cats = \"meow\"; printf '\"many cats %s\"', $cats\n","err":"","out":"\"many cats meow\""},{"err":"","code":"$cats = \"meow\"; [qq(\"many cats $cats\")]\n","out":"[\"\\\"many cats meow\\\"\"]"},{"err":"","code":"$cats = \"meow\"; [ sprintf '\"many cats %s\"', $cats ]\n","out":"[\"\\\"many cats meow\\\"\"]"},{"code":"\"cats\" =~ m pcatsp\n","err":"","out":"1"},{"out":"$dogs","err":"","code":"\"cats\" =~ s'cats'$dogs'r\n"},{"out":"CATS","code":"'cats' =~ s/(.)/\\U$1/gr\n","err":""},{"err":"","code":"\"cats\"->${ \\sub {$_[0]} }\n","out":"cats"},{"code":"() = \"C++\" =~ /\\b/g\n","err":"","out":"2"},{"out":"[\"\\3\"]","code":"[ \"\\cC\" ]\n","err":""},{"err":"","code":"\"c\" == \"d\"\n","out":"1"},{"err":"","code":"\"\\cD\" eq \"\\x04\"\n","out":"1"},{"err":"","code":"ceil(log(~0)/log(2))\n","out":"64"},{"err":"","code":"char 0x3b\n","out":"ERROR: syntax error at (eval 1) line 1, near \"char 0x3b\"\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"char 0x7b\"\n","err":"","code":"char 0x7b\n"},{"err":"","code":"char(2**16)\n","out":"ERROR: Undefined subroutine &main::char called at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"char(2*16)\t\t\t\t\t        [13:56]\n","out":"ERROR: syntax error at (eval 1) line 1, near \")\t\t\t\t\t        [\"\n"},{"code":"char('a')^char('A')\n","err":"","out":"ERROR: Undefined subroutine &main::char called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't use an array as a reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"@charmap = qw/Botje!!!/; @charmap->[qw/Botje/]\n"},{"err":"","code":"@charmap = undef; \\@charmap\n","out":"[undef]"},{"out":"ARABIC-INDIC DIGIT SIX","code":"charnames::viacode(0x666)\n","err":""},{"code":"charnames::viacode(0xdf)\n","err":"","out":"LATIN SMALL LETTER SHARP S"},{"err":"","code":"[chomp($_=\"\")]\n","out":"[0]"},{"err":"","code":"chr 0b01000001\n","out":"A"},{"out":"[\"\\377\"]","code":"[ chr 0b1111_1111 ]\n","err":""},{"code":"chr 0x064b\n","err":"","out":"ÃÂÃÂ"},{"out":"ÃÂÃÂ","code":"chr 0x064e\n","err":""},{"code":"[chr 0x11b, \\x{11b}]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"11b\"\n"},{"out":"ÃÂ°ÃÂÃÂÃÂ¾","err":"","code":"chr 0x1F5FE\n"},{"err":"","code":"chr(0x30)\n","out":"0"},{"out":";","err":"","code":"chr 0x3b\n"},{"out":"q","code":"chr 0x71\n","err":""},{"code":"chr 0x7b\n","err":"","out":"{"},{"out":"ÃÂ¢","err":"","code":"chr 0xe2\n"},{"out":"ÃÂ©","err":"","code":"chr 0xe9\n"},{"out":"ÃÂ¯ÃÂ¬ÃÂ","code":"chr 0xfb06\n","err":""},{"err":"","code":"chr(171)\n","out":"ÃÂ«"},{"code":"chr(173) =~ /\\N{SOFT HYPHEN}/;\n","err":"","out":"1"},{"err":"","code":"chr(173) =~ /\\N{U+AD}/;\n","out":"1"},{"out":"1","code":"chr(173) =~ /\\xad/;\n","err":""},{"err":"","code":"chr(173) =~ /\\xAD/;\n","out":"1"},{"out":"ÃÂ°ÃÂÃÂÃÂ","err":"","code":"chr(2 << 15)\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \")\t\t\t\t\t        [\"\n","err":"","code":"chr(2**16)\t\t\t\t\t        [13:56]\n"},{"code":"chr 232\n","err":"","out":"ÃÂ¨"},{"code":"${\\chr 24}\n","err":"","out":"\u0018"},{"out":"\u0018","code":"chr 24\n","err":""},{"err":"","code":"chr 33\n","out":"!"},{"code":"chr 34\n","err":"","out":"\""},{"code":"chr 39\n","err":"","out":"'"},{"err":"","code":"[chr(48) .. chr(48)]\n","out":"[0]"},{"code":"[chr(48) .. chr(58)]\n","err":"","out":"[0,1,2,3,4,5,6,7,8,9]"},{"out":"[1,\"\\n\"]","err":"","code":"[chr 49, chr 10]\n"},{"err":"","code":"chr 5000000000\n","out":"ÃÂ¾ÃÂÃÂªÃÂÃÂÃÂÃÂ"},{"err":"","code":"chr(51) . chr(76)\n","out":"3L"},{"code":"[chr(60) .. chr(88)]\n","err":"","out":"[\"<\"]"},{"out":"A","code":"chr 65\n","err":""},{"out":"[\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"]","code":"[chr(65) .. chr(100)]\n","err":""},{"err":"","code":"[chr(65), chr(100)]\n","out":"[\"A\",\"d\"]"},{"err":"","code":"[chr(65] .. chr(100)]\n","out":"ERROR: syntax error at (eval 1) line 1, near \"65]\"\nUnmatched right square bracket at (eval 1) line 1, at end of line\n"},{"err":"","code":"chr 8304\n","out":"ÃÂ¢ÃÂÃÂ°"},{"out":"\\\"\\x{2071}\"","code":"\\chr 8305\n","err":""},{"out":"ÃÂ¢ÃÂÃÂ±","err":"","code":"chr 8305\n"},{"out":"V","err":"","code":"chr 86;\n"},{"out":"ÃÂ¢ÃÂÃÂ±","code":"chr 9585.5\n","err":""},{"err":"","code":"chr('a')^chr('A')\n","out":"\u0000"},{"err":"","code":"[chr(hex \"3c\"), \"\\x3c\"]\n","out":"[\"<\",\"<\"]"},{"err":"","code":"chr(ord('a') + 2)\n","out":"c"},{"out":"","code":"close(STDIN); close(STDOUT); close(STDERR); print \"I have no mouth and I must scream\"\n","err":""},{"out":"foo.com","err":"","code":"{ Clubs => [ { Url => 'foo.com' } ] }->{Clubs}[0]{Url}\n"},{"err":"","code":"<code>\n","out":""},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"code; also pleval deparse rbeval jseval pyeval phpeval k20eval luaeval jeval.\n","err":""},{"out":"code","err":"","code":"<code here>\n"},{"code":"$color = 'green'; $ref = \\$color; $$ref = 'blue'; $color\n","err":"","out":"blue"},{"code":"@color = qw(blue white red); print $color[$#color];\n","err":"","out":"red"},{"out":"red","code":"@color = qw(blue white red); print $color[eval($#color)];\n","err":""},{"err":"","code":"command of perlbot, that's useful to perlbot to display things properly\n","out":"ERROR: Can't locate object method \"things\" via package \"properly\" (perhaps you forgot to load \"properly\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"COMMAND --password\n","out":"ERROR: Can't modify constant item in postdecrement (--) at (eval 1) line 1, near \"COMMAND --\"\nsyntax error at (eval 1) line 1, near \"--password\n\"\n"},{"out":"","code":"\"COMPRESSION_GZIP\" eq \"COMPRESS_GZIP\" # let's ask perl\n","err":""},{"code":"$_ = \"  Computer  \"; [ s/^ +| +$| Computer //gr, s/ Computer |^ +| +$//gr ]\n","err":"","out":"[\"Computer\",\"Computer\"]"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, near \"s/Computer//gr ]\"\n","code":"$_ = \"C omputer\"; [ s/ |Computer//gr; s/ //gr =~ s/Computer//gr ]\n","err":""},{"err":"","code":"$Config{osname}\n","out":""},{"out":"CONST","err":"","code":"*CONST = sub { 'haha' }; CONST\n"},{"err":"","code":"*CONST = sub { 'haha' }; CONST()\n","out":"haha"},{"code":"copy(\"$alt\", \"$neu\");\n","err":"","out":"ERROR: Undefined subroutine &main::copy called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","code":"CORE::dump()\n","err":"/home/ryan/workspace/perlblead-ci/runeval.sh: line 5: 11135 Aborted                 /home/ryan/perl5/perlbrew/perls/perlbot-blead-intest/bin/perl /home/ryan/bots/perlbuut/lib/eval.pl\n"},{"out":"[\"\\342\\202\\254\"]","code":"[CORE::fc 'â¬']\n","err":""},{"code":"&CORE::for () CORE::for ();\n","err":"","out":""},{"err":"","code":"\\&CORE::hex->(\"0x24\")\n","out":"ERROR: Undefined subroutine &main::0 called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"sub { \"DUMMY\" }","err":"","code":"\\&CORE::lc\n"},{"code":"(\\&CORE::lc)->('lol')\n","err":"","out":"lol"},{"code":"(\\&CORE::lc)->(undef)\n","err":"","out":""},{"err":"","code":"&CORE::open()\n","out":"ERROR: Not enough arguments for open at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"(\\&CORE::print)->('a')\n","out":"ERROR: Undefined subroutine &CORE::print called at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"\\&CORE::print->(\"foo\")\n","out":"ERROR: Undefined subroutine &CORE::print called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Undefined subroutine &CORE::print called at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"(\\&CORE::print)->('lol')\n"},{"out":"ERROR: CORE::prototoype is not a keyword at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"CORE::prototoype(\\&CORE::die)\n"},{"out":"@","err":"","code":"CORE::prototype(\\&CORE::die)\n"},{"out":"_","err":"","code":"CORE::prototype(\\&CORE::prototype)\n"},{"err":"","code":"\\(&CORE::ref)->([])\n","out":"ERROR: Undefined subroutine &main:: called at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"\\&CORE::ref->([])\n","err":"","out":"ERROR: Undefined subroutine &main:: called at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"CORE::say \"hi\"\n","err":"","out":"hi\n"},{"code":"(\\&CORE::say)->(\"/layout save\")\n","err":"","out":"ERROR: Undefined subroutine &CORE::say called at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"CORE::stat('file')\n","err":"","out":""},{"out":"ERROR: &CORE::system cannot be called directly at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"&CORE::system(\"ls &\") # aw, no symmetry for me :(\n"},{"out":"ERROR: Can't locate object method \"echo\" via package \"0\" (perhaps you forgot to load \"0\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"$count = 0; do { echo $count; $count++ } while ($count le 3);\n","err":""},{"code":"$count = 0; do { print $count; $count++ } while ($count le 3);\n","err":"","out":"0123"},{"out":"12351","err":"","code":"$count = () = bike..care\n"},{"out":"{b => 2,c => 1,a => 3}","code":"++$count{$_} for split //, 'abcaba'; \\ %count\n","err":""},{"err":"","code":"[ counts=>{},_keys=>() ]\n","out":"[\"counts\",{},\"_keys\"]"},{"out":"","code":"'CryptoX' != 'CryptX' # orly\n","err":""},{"code":"${ \"\\cV\" }\n","err":"","out":"bless( {qv => 1,original => \"v5.24.0\",version => [5,24,0]}, 'version' )"},{"err":"","code":"${ \"\\cV\" } . ''\n","out":"v5.24.0"},{"out":"TeSt! teSt","err":"","code":"$c=v0;'test! Test'=~s/[a-z]/$&^($c^=$\")/gire\n"},{"err":"","code":"$c=v0;'test! Test'=~s/[a-z]/($c^=$\")^lc$&/gire\n","out":"TeSt! TeSt"},{"err":"","code":"$c=v0;'x!xx!x!x!'=~s/[a-z]/$&^($c^=$\")/gire\n","out":"X!xX!x!X!"},{"code":"['*.c' =~ /\\*\\.\\w/]\n","err":"","out":"[1]"},{"out":"[\"d8:50:e6:84:e6:de\"]","err":"","code":"$_ = 'd850e684e6de'; [join ':', unpack('(A2)*')]\n"},{"out":"d8:50:e6:84:e6:de","code":"'d850e684e6de' =~ s/..\\K\\B/:/gr\n","err":""},{"err":"","code":"\"daleks\" lt \"perl\" # but of course perl would say that\n","out":"1"},{"out":"[234]","err":"","code":"[ 'data 234 foo 456 bar' =~ /(\\d+).*bar$/ ]\n"},{"err":"","code":"[ 'data 234 foo 456 bar' =~ /(\\d+)(?=.*bar$)/ ]\n","out":"[234]"},{"out":"[234]","err":"","code":"[ 'data 234 foo 456 bar' =~ /(\\d+)(?:.*bar$)/ ]\n"},{"err":"","code":"@data = '25 25.175 jitter'; [split(/\\s+/, $data];\n","out":"ERROR: syntax error at (eval 1) line 1, near \"$data]\"\n"},{"out":"ERROR: Can't locate object method \"quick_select\" via package \"database\" (perhaps you forgot to load \"database\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"database->quick_select($Table, \\%Params, \\%Options)\n","err":""},{"out":"[\"02/14/2014\"]","err":"","code":"'data-date=\"02/14/2014\"' =~ m!data-date=\"(\\d\\d/\\d\\d/\\d\\d\\d\\d)\"!; [ $1 ]\n"},{"out":"$VAR1 = {'b' => 2,'a' => {'two' => 2}};","err":"","code":"$Data::Dumper::Indent = 0; $h = {'a' => {'one' => 1}, \"b\" => 2}; $i = {'a' => {'two' => 2}}; $j = {%$h, %$i}; print Dumper($j);\n"},{"out":"","code":"$Data::Dumper::Useperl = 1; open my $fh , '>', \\my $str; [ *$fh{IO} ]\n","err":"Can't handle 'IO' type at /home/ryan/bots/perlbuut/lib/eval.pl line 309.\n"},{"out":"[\"foo\"]","code":"@data = (\"foo\"); $data[0]{label} = $data[0]; [@data]\n","err":""},{"out":"/data/install/smt/repo/$RCE/SLES11-SP3-Updates/sle-11-x86_64","err":"","code":"\"/data/install/smt/repo/\\$RCE/SLES11-SP3-Updates/sle-11-x86_64\"\n"},{"out":"qr/(?#)/","err":"","code":"Data::Munge::list2re \"\"\n"},{"err":"","code":"Data::Munge::list2re ();\n","out":"qr/(?!)/"},{"err":"","code":"Data::Munge::list2re qw(= == : --)\n","out":"qr/\\-\\-|\\=\\=|\\:|\\=/"},{"code":"Data::Munge->VERSION\n","err":"","out":"0.096"},{"err":"","code":"[`date`]\n","out":"[]"},{"out":"0","err":"","code":"$_=\"date\"; exec $_;\n"},{"err":"","code":"DateTime::Duration->new( minutes => 3, seconds => 15 )->in_units('seconds')\n","out":"15"},{"code":"DateTime->noew\n","err":"","out":"ERROR: Can't locate object method \"noew\" via package \"DateTime\" at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"0","code":"DateTime::TimeZone->is_valid_name(\"America/New_York\");\n","err":""},{"out":"D:/AU Files","err":"","code":"\"D:/AU\\ Files\"\n"},{"out":"Value missing at 1:5\n","code":"debugmsg(\"Value missing at %d:%d\\n\", 1, 5);   sub debugmsg { my $msg = sprintf(shift, @_); warn $msg; print $msg; }\n","err":"Value missing at 1:5\n"},{"code":"debugmsg(\"Value missing at %d:%d\\n\", 1, 5);   sub debugmsg { my $msg = sprintf(@_); warn $msg; print $msg; } #since perlbot doesn't have $dbug opened, I removed it ... let's see what happens!\n","err":"3 at (eval 1) line 1, <STDIN> line 1.\n","out":"3"},{"err":"","code":"dec('008') == 8\n","out":"ERROR: Undefined subroutine &main::dec called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"sub { \"DUMMY\" }","err":"","code":"\\&decode_json\n"},{"out":"decode_json","code":"decode_json\n","err":""},{"err":"","code":"decode_utf8(\"s\\x{c3}\\x{bc}\\x{c3}\\x{9f}e\")\n","out":"sÃÂ¼ÃÂe"},{"out":"[\"\"]","code":"[ defined ${bless \\do { my $nou = undef }, \"trolol\"} ];\n","err":""},{"out":"[1]","err":"","code":"[defined chomp($_=\"\")]\n"},{"code":"defined fork\n","err":"","out":""},{"code":"defined($INC[-1]) ? \"yay\" : \"nay\"\n","err":"","out":"nay"},{"err":"","code":"[ defined ${\\undef} ]\n","out":"[\"\"]"},{"out":"ERROR: delete argument is not a HASH or ARRAY element or slice at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"delete *C::foo{CODE}\n"},{"out":"","code":"delete $undef->{foo}; print defined, ref for $foo\n","err":""},{"err":"","code":"delete $undef->{foo}; print defined, ref for $undef\n","out":"1HASH"},{"err":"","code":"delete $undef->{key}; $undef\n","out":"{}"},{"err":"","code":"deparse: $::{true}\n","out":""},{"code":"$deploys = [1..3]; [ @{$deploys}[-5 .. -1] ];\n","err":"","out":"[undef,undef,1,2,3]"},{"err":"","code":"$deploys = [1..3]; [ grep $_, @{$deploys}[-3 .. -1] ];\n","out":"[1,2,3]"},{"code":"$deploys = [1..3]; [ grep $_, @{$deploys}[-5 .. -1] ];\n","err":"","out":"ERROR: Modification of non-creatable array value attempted, subscript -5 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Modification of non-creatable array value attempted, subscript -5 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"$deploys = [1..3]; push @foo, $_ for @{$deploys}[-5 .. -1]; [ @foo ]\n"},{"err":"","code":"DESTROY <>\n","out":"ERROR: Illegal declaration of subroutine DESTROY at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Died at (eval 1) line 1, <STDIN> line 1.\n","code":"die();\n","err":""},{"err":"","code":"?: die 'Denied.';\n","out":"ERROR: syntax error at (eval 1) line 1, near \"; ?\"\n"},{"out":"ERROR: Denied. at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"()?(): die 'Denied.';\n"},{"out":"[\"died with signal 0\",\"\"]","code":"[ \"died with signal \" . (256 & 127), 256 & 128 ? 'core dumped' : '' ]\n","err":""},{"err":"","code":"die \"failed\"\n","out":"ERROR: failed at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"die \"foo\" . \"\\n\"\n","out":"ERROR: foo\n"},{"code":"die or do\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"code":"Digest::MD5::md5_hex \"\"\n","err":"","out":"d41d8cd98f00b204e9800998ecf8427e"},{"err":"","code":"$dirname = \"/usr/share/local/\"; $arg = '$dirname/'\n","out":"$dirname/"},{"out":"<div id=\"search-results\" ... >","err":"","code":"\"<div id=\\\"search-results\\\" ... >\"\n"},{"err":"","code":"$_ = 'DoÃ'; s[(doÃ)][ $1 ^ lc $1 ^ 'cat' ]ier;\n","out":"CaT\u0000"},{"err":"","code":"$_ = '\"Doe\",\"John \"Johnny\"\",\"T\",...'; s/(?<=[^,])\"(?!,)/'/gr\n","out":"\"Doe\",\"John 'Johnny'\",\"T\",..."},{"err":"","code":"$_ = 'Dog'; s[(dog)][ $1 ^ lc $1 ^ 'cat' ]er;\n","out":"Dog"},{"code":"$_ = 'Dog'; s[(dog)][ $1 ^ lc $1 ^ 'cat' ]ier;\n","err":"","out":"Cat"},{"out":"[3]","err":"","code":"[ do { if(0) { 2 } else { 3 } } ]\n"},{"out":"[]","err":"","code":"[do { if (1) {} }]\n"},{"out":"[2]","code":"[ do { if(1) { 2 } else { 3 } } ]\n","err":""},{"out":"doing it for cpan","code":"\"doing it for fun\" =~ s/fu/cpa/r\n","err":""},{"err":"","code":"{ do { last } while 1 }\n","out":""},{"err":"","code":"do { last } while 1\n","out":""},{"code":"[do { my $asdf = 9; if ($asdf==9) {} }]\n","err":"","out":"[]"},{"err":"","code":"do { my $line = $_; chomp $line; say $line } for \"asdf\",\"asdf\\n\"\n","out":"asdf\nasdf\n"},{"err":"","code":"do { next }\n","out":""},{"code":"do {} or die\n","err":"","out":"ERROR: Died at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"do or\"\n","code":"do or die\n","err":""},{"out":"foo","err":"","code":"do { print q{foo}; } while 0;\n"},{"code":"++do{ state $N }\n","err":"","out":"ERROR: Can't modify do block in preincrement (++) at (eval 1) line 1, at EOF\n"},{"err":"","code":"do { ++state $N }\n","out":"1"},{"code":"do { state $N++ }\n","err":"","out":"0"},{"out":"3","code":"do { $x = 1; $x +=2; } if 1; $x\n","err":""},{"out":"Dr","code":"\"Dr doctor\" =~ s/(Dr).+/$1/r;\n","err":""},{"code":"drink_coffee() if $!{ ENOCAFFIENE };\n","err":"","out":""},{"code":"Dumper(undef); use Data::Dumper\n","err":"","out":"$VAR1 = undef;\n"},{"err":"","code":"Dumper; use Data::Dumper\n","out":""},{"out":"","code":"Dumper(); use Data::Dumper\n","err":""},{"out":"$VAR1 = [];\n","err":"","code":"Dumper([]); use Data::Dumper\n"},{"code":"-e\n","err":"","out":""},{"out":"-e","err":"","code":"-'e'\n"},{"out":"-e","code":"-\"e\"\n","err":""},{"err":"","code":"$_ = \"Ã©\"; $_++; $_\n","out":"1"},{"err":"","code":"$_ = 'e8b748680748'; [ s/..\\K\\B/:/gr ]\n","out":"[\"e8:b7:48:68:07:48\"]"},{"err":"","code":"[ each @{[ qw( a b c d e ) ]} ]\n","out":"[0,\"a\"]"},{"out":"[0]","code":"[ $!{EAGAIN} ]\n","err":""},{"out":"[0]","err":"","code":"[$!{EAGAIN}]\n"},{"out":"ERROR: Unrecognized character \\xC3; marked by <-- HERE after pha:]]/, '<-- HERE near column 116 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"['Ã¨\" =~ /[[:alpha:]]/, 'Ã¨' =~ /[[:alpha:&&\n"},{"err":"","code":"earlier\n","out":"earlier"},{"code":"$e = \"...brow,n\"; $e =~ s/^\\W*(\\w+).*/$1/; [ $e ]\n","err":"","out":"[\"brow\"]"},{"out":"[\"brow\"]","code":"$e = \"...brow,n\"; $e =~ s/^\\W*(\\w+).*/\\1/; [ $e ]\n","err":""},{"err":"","code":"$e = \"...brow,n\"; $e =~ s/^\\W*(\\w+)\\W*$/\\1/; [ $e ]\n","out":"[\"...brow,n\"]"},{"err":"","code":"echo true\n","out":"ERROR: Can't locate object method \"echo\" via package \"true\" (perhaps you forgot to load \"true\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"`echo uuoo`\n","out":""},{"out":"[\"a\",\"b\",\"c\",\"d\",\" e\"]","err":"","code":"$e = ' e'; @x = (qw(a b c d), $e); \\@x;   # quitte\n"},{"out":"[\"a\",\"b\",\"c\",\"d\",\"e\"]","err":"","code":"$e = 'e'; @x = (qw(a b c d), $e); \\@x;   # quitte\n"},{"out":"[\"a\",\"b\",\"c\",\"d\"]","code":"$e = 'e'; @x = qw(a b c d), $e; \\@x;   # quitte\n","err":""},{"code":"-e \"foo\"; $!\n","err":"","out":"No such file or directory"},{"out":"[0,1,2,3,4,5]","code":"@elems = (0..5);  my $ref =  \\@elems; $ref;\n","err":""},{"out":"sub { \"DUMMY\" }","code":"EmptyPkg->can(\"can\")\n","err":""},{"out":"sub { \"DUMMY\" }","err":"","code":"EmptyPkg->can(\"DOES\")\n"},{"out":"","code":"EmptyPkg->can(\"import\")\n","err":""},{"out":"sub { \"DUMMY\" }","code":"EmptyPkg->can(\"isa\")\n","err":""},{"code":"Encode::decode_utf8(join \"\", map chr, qw(195 188 195 159))\n","err":"","out":"ÃÂ¼ÃÂ"},{"out":"ÃÂ¯ÃÂ¿ÃÂ½ÃÂ¯ÃÂ¿ÃÂ½ÃÂ¯ÃÂ¿ÃÂ½ÃÂ¯ÃÂ¿ÃÂ½ÃÂ¯ÃÂ¿ÃÂ½ÃÂ¯ÃÂ¿ÃÂ½","code":"Encode::decode(\"utf-8\", \"\\x99\\x99\\x99\\x99\\x99\\x99\")\n","err":""},{"err":"","code":"encode 'UTF-8', 'ÃÂ¡r jÃÂº sÃÂºr?'\n","out":"ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ¡r jÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂº sÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂºr?"},{"code":"[encode_utf8(\"\\x{2665}\")] # works too, depening inthe output you want\n","err":"","out":"[\"\\342\\231\\245\"]"},{"code":"END { ... }\n","err":"Unimplemented at (eval 1) line 1, <STDIN> line 1.\nEND failed--call queue aborted, <STDIN> line 1.\n","out":""},{"err":"2- at (eval 1) line 1, <STDIN> line 1.\nEND failed--call queue aborted, <STDIN> line 1.\n","code":"END { print \"1-\" } END { die \"2-\" } END { print \"3-\" } # b100s\n","out":"3-1-"},{"err":"","code":"END {print \"yes\" } cvx{{Wr\n","out":"ERROR: Missing right curly or square bracket at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, at EOF\nyes"},{"code":"EOF # are you a thing?\n","err":"","out":"-1"},{"out":"[]","err":"","code":"[ \"EOL\\r\\n\" =~ m/L$/,  \"EOL\\r\\n\" =~ m/L$/m ]\n"},{"code":"[ \"EOL\\r\\n\" =~ m/L$/,  \"EOL\\r\\n\", =~ m/L$/m ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \", =~\"\n"},{"out":"[1]","code":"[ \"EOL\\r\\n\" =~ m/L\\R\\z/ ]\n","err":""},{"out":"Episode s0105.mkv","err":"","code":"\"Episode 1x4.mkv\" =~ s{(\\d+)x(\\d+)}{ sprintf \"s%02d%02d\", $1, $2 + 1 }ger\n"},{"out":"Episode s0104.mkv","code":"\"Episode 1x4.mkv\" =~ s{(\\d+)x(\\d+)}{ sprintf \"s%02d%02d\", $1, $2 }ger\n","err":""},{"code":"$_ = 'episode9'; s/episode(\\d)/sprintf \"e(%d)\", $1 - 1/e\n","err":"","out":"1"},{"err":"","code":"$_ = 'episode9'; s/episode(\\d)/sprintf \"e(%d)\", $1 - 1/e; $_\n","out":"e(8)"},{"out":"equal","err":"","code":"\"equal\" if \"aaaa\" == \"bbbb\"\n"},{"out":"","err":"","code":"\"equal\" if \"aaaa\" eq \"bbbb\"\n"},{"code":"'' eq undef\n","err":"","out":"1"},{"code":"Errno::ENOENT\n","err":"","out":"2"},{"code":"[ eval \"0.00_02\" ]\n","err":"","out":"[\"0.0002\"]"},{"err":"","code":"eval '0;qq{@{sub{]]}}}}}'\n","out":""},{"out":"[16,10]","err":"","code":"[ eval '0x10', eval '10' ]\n"},{"code":"[eval \"0x\" . ('f' x 16), unpack(\"q\", '\\xff' x 8)] # hmm\n","err":"","out":"['18446744073709551615','7378717377743452252']"},{"err":"","code":"eval {1}; [ $@ ]\n","out":"[\"\"]"},{"out":"7838398","err":"","code":"eval \"12w6d17h19m58s\" =~ s/(\\d+)(\\w)/'+' . $1 * {qw(w 604800 d 86400 h 3600 m 60 s 1)}->{$2}/ger\n"},{"err":"","code":"[ eval '1-3,5,6-9' =~ s/-/../gr ]\n","out":"[1,2,3,5,6,7,8,9]"},{"out":"1","code":"eval{5 / 0} // 1\n","err":""},{"err":"","code":"eval \"\\\\\\\\\\\\\\\\backup_server\\\\\\\\host\"\n","out":""},{"out":"","code":"eval \"\\$       \\b     leonerd = 42\";\n","err":""},{"code":"eval \"\\$       \\b     leonerd = 42\"; $@\n","err":"","out":"Unrecognized character \\x08; marked by <-- HERE after $       <-- HERE near column 9 at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"eval { die 0; } say \"Died\" if $@;\n","out":"ERROR: syntax error at (eval 1) line 1, near \"} say\"\n"},{"err":"","code":"eval { die 0; }; say \"Died $@\" if $@;\n","out":"Died 0 at (eval 1) line 1, <STDIN> line 1.\n\n"},{"err":"","code":"eval { die 0; }; say \"Died\" if $@;\n","out":"Died\n"},{"out":"bless( do{\\(my $o = 0)}, 'JSON::PP::Boolean' )","err":"","code":"eval { die JSON::false; }; say \"Died $@\" if $@;\n"},{"err":"","code":"eval { die 'there you are' }; $@ # easily tested\n","out":"there you are at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"eval { die undef } [ $@ ]\n","out":"ERROR: syntax error at (eval 1) line 1, near \"} [\"\n"},{"code":"eval { die undef }; [ $@ ]\n","err":"","out":"[\"Died at (eval 1) line 1, <STDIN> line 1.\\n\"]"},{"code":"eval join '*', 1..10\n","err":"","out":"3628800"},{"err":"","code":"eval(join '*', 1..30) / 1000 / 3600 / 24 / 365  # after heat death of universe ?\n","out":"8.41111300774325e+21"},{"code":"eval: $l = \"abc\"; $r = \"ABC\"; $l =~ s/./$&.substr($r,$-[0],1)/rge\n","err":"","out":"aAbBcC"},{"out":"Unmatched right curly bracket at /dev/null line 0, at end of line\nsyntax error at /dev/null line 0, near \"#line 0 /dev/null\n}\"\n","err":"","code":"eval \"#line 0 /dev/null\\n}\"; $@\n"},{"code":"eval \"#line 1 /dev/null\\n}\"; $@\n","err":"","out":"Unmatched right curly bracket at /dev/null line 1, at end of line\nsyntax error at /dev/null line 1, near \"#line 1 /dev/null\n}\"\n"},{"out":"Unmatched right curly bracket at (eval 1) line 2, at end of line\nsyntax error at (eval 1) line 2, near \"#line -42 /dev/null\n}\"\n","code":"eval \"#line -42 /dev/null\\n}\"; $@\n","err":""},{"code":"eval \"\\$       \\n     leonerd = 42\"; $@\n","err":"","out":""},{"code":"eval \"\\$       \\n     leonerd = 42\"; $leonerd\n","err":"","out":"42"},{"out":"1","code":"eval {print 1; next; print 2}\n","err":""},{"out":"2","code":"eval { print \"2\" }\n","err":""},{"err":"","code":"eval \\{ print \"2\" }\n","out":"2"},{"out":"2","err":"","code":"eval &{ print \"2\" }\n"},{"out":"2","err":"","code":"eval print \"2\"\n"},{"code":"eval { print \"2\" }; print $?\n","err":"","out":"20"},{"err":"","code":"eval { print \"2\" }; print $@\n","out":"2"},{"err":"","code":"eval \"print 'nested\\nlike\\nthis'\"\n","out":"nested\nlike\nthis"},{"err":"","code":"[ eval \"qw(yes yes),\\n#no\\nqw(yes yes)\" ]\n","out":"[\"yes\",\"yes\",\"yes\",\"yes\"]"},{"err":"","code":"eval { return 1; }; print \"HELLO\"\n","out":"HELLO"},{"out":"1\n","err":"","code":"eval \"say 1; next; say 2\"\n"},{"err":"","code":"eval {say 1; next; say 2}\n","out":"1\n"},{"err":"","code":"eval: $str=\"network=192.168.1.1; Dummy-SIGB=10.0.2.79; testbed-oam-net=135.111.74.116; Dummy-SIGA=10.0.1.111\"; for ( split /\\;/, $str ){ if ( /(.*)\\=(.*)/ ){ print \"$1,$2\" } }\n","out":"network,192.168.1.1 Dummy-SIGB,10.0.2.79 testbed-oam-net,135.111.74.116 Dummy-SIGA,10.0.1.111"},{"out":"Undefined subroutine &C::foo called at (eval 1) line 1, <STDIN> line 1.\n","code":"eval {sub C::foo {}; my $o = \\&C::foo; undef &C::foo; $o->(); 1} or $@\n","err":""},{"out":"","err":"","code":"eval \"\\$       \\t     leonerd = 42\"; $@\n"},{"code":"eval { undef->() }; \"-> $@ <-\"\n","err":"","out":"-> Can't use an undefined value as a subroutine reference at (eval 1) line 1, <STDIN> line 1.\n <-"},{"out":"Can't use an undefined value as a subroutine reference at (eval 1) line 1, <STDIN> line 1.\n","code":"eval { undef->() }; $@\n","err":""},{"err":"","code":"eval \"unpack 'S', \\\"\\xff\\xff\\\"\"\n","out":"65535"},{"err":"","code":"eval \"\\$       \\v     leonerd = 42\"; $@\n","out":"syntax error at (eval 1) line 1, near \"$       v     leonerd \"\n"},{"out":"","code":"eval \"`who\".\"ami`\"\n","err":""},{"out":"AA","err":"","code":"eval '\"'.'\\x41\\x41'.'\"'\n"},{"err":"","code":"exec '/bin/ls'\n","out":"0"},{"out":"0","code":"exec 'ping', 'google.com'\n","err":""},{"out":"0","code":"exec '/usr/bin/ping', 'google.com'\n","err":""},{"out":"ERROR: exists argument is not a HASH or ARRAY element or a subroutine at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"exists \"\"\n"},{"out":"7","code":"~~exp 2\n","err":""},{"out":"7.38905609893065","err":"","code":"exp(2)\n"},{"out":"[[\"hello world\"],$VAR1->[0]]","code":"*EXPORT = \\@Foo::Bar::EXPORT; push @EXPORT, \"hello world\"; [ \\@EXPORT, \\@Foo::Bar::EXPORT ]\n","err":""},{"out":"wtf","err":"","code":"\"#\\\\E \\\\z\" =~ m{ \\Q#\\E \\z}xms ? \"wtf\" : \"k\"\n"},{"out":"ERROR: Bizarre copy of ARRAY in map iterator at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"@F=(0..9,0);sub r{my($y,@x)=@_;map{ref$_ ? (&$_) :$_}@d=(@F,($y && sub{@F[$y-1,-1-$y]=($\")x2;r(@x)}),@F%2|$y?@F:())}print r 1,1,3..@F/2-1\n"},{"code":"\"f0b0\" =~ /f(.)b\\1/\n","err":"","out":"1"},{"code":"fail?succeed:fail\n","err":"","out":"succeed"},{"out":"FAILFAIL","err":"","code":"FAIL x 2\n"},{"out":"true","code":"false ? true : file_not_found\n","err":""},{"err":"","code":"'false' ? \"yes it is\" : \"no, it isn't\" # place your bets!\n","out":"yes it is"},{"code":"%fancylist = ( 1,\"one\",2,\"two\",3,\"three\" ); print scalar %fancylist;\n","err":"","out":"2/8"},{"out":"3","code":"%fancylist = ( 1,\"one\",2,\"two\",3,\"three\" ); print scalar keys %fancylist;\n","err":""},{"err":"","code":"fc('er') eq fc('Er')\n","out":"1"},{"out":"ÃÂ£ÃÂ","err":"","code":"fc \"Ã\"\n"},{"code":"FF & 07F\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"07F\n\"\n"},{"err":"","code":"[ -f \"/\", -f \"/does-not-exist\", -f undef ]\n","out":"[\"\",undef,undef]"},{"code":"$_ = '@f@f@f'; s'@f'$b'gr;\n","err":"","out":"$b$b$b"},{"code":"$_ = 'file-bkp-2014-06-08'; [ map { s/bkp\\K(\\d*)/$1+1/e; $_ } ($_) x 12 ]\n","err":"","out":"[\"file-bkp1-2014-06-08\",\"file-bkp2-2014-06-08\",\"file-bkp3-2014-06-08\",\"file-bkp4-2014-06-08\",\"file-bkp5-2014-06-08\",\"file-bkp6-2014-06-08\",\"file-bkp7-2014-06-08\",\"file-bkp8-2014-06-08\",\"file-bkp9-2014-06-08\",\"file-bkp10-2014-06-08\",\"file-bkp11-2014-06-08\",\"file-bkp12-2014-06-08\"]"},{"out":"[0,1,2]","code":"[ fileno STDIN, fileno STDOUT, fileno STDERR ]\n","err":""},{"out":"there are 3 files","err":"","code":"@files = qw(one two three); 'there are ' . @files . ' files'\n"},{"out":"there are 3 files","err":"","code":"@files = qw(one two three); \"there are @{[ scalar @files ]} files\"\n"},{"out":"[]","err":"","code":"[ %{File::Stat::} ]\n"},{"code":"File::Stat->import; [ %{File::Stat::} ]\n","err":"","out":"[\"import\",*File::Stat::import]"},{"out":"F., Name, 745 45363\nS., One, 343 5454","code":" $_ = \"First Name Position first.name@somewhere.com 745 45363\\nSome One Worker some.one@somewhere.com 343 5454\\n\" =~ s/^\\s*(\\S)\\S*\\s+(\\S+).+?(\\d\\d\\d \\d\\d\\d\\d)\\s*/$1., $2, $3/gmr\n","err":""},{"out":"[\"Bla, bla, bla. \",\"Hi.\\t\"]","err":"","code":"$_ = \"First.\\nSecond.\\nBla, bla, bla. \\nHi.\\t\\nLast line.\\n\"; [ /^.*\\h+$/gm ] # try \\h if you only want horizontal whitespace\n"},{"code":"@_=('first','second'); print $_[0];\n","err":"","out":"first"},{"code":"floor()\n","err":"","out":"ERROR: Usage: POSIX::floor(x) at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"[ floor(-5/3), int(-5/3) ]\n","err":"","out":"[-2,-1]"},{"code":"floor(85.3)\n","err":"","out":"85"},{"err":"","code":"-F\\\"m S\\\"\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"foo","code":"foo\n","err":""},{"err":"","code":"~~\"foo\"\n","out":"foo"},{"err":"","code":"-foo\n","out":"-foo"},{"out":"'foo'","err":"","code":"'\\'foo\\''\n"},{"out":"foo","err":"","code":"'foo'\n"},{"err":"","code":"\"\" . \\@{\\*foo}\n","out":"ERROR: Not an ARRAY reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","code":"\"foo\" =~ /[.]/\n","err":""},{"err":"","code":"(\\*foo)->()\n","out":"ERROR: Not a CODE reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Undefined subroutine &main::foo called at (eval 1) line 1, <STDIN> line 1.\n","code":"(\\&{ \\*foo })->()\n","err":""},{"code":"[ \"foo\" =~ /()(.)/ ]\n","err":"","out":"[\"\",\"f\"]"},{"code":"[${\\ 'foo' }]\n","err":"","out":"[\"foo\"]"},{"err":"","code":"$_=\"foo\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"foo","err":"","code":"$_ = 'foo'; $::_\n"},{"err":"","code":"${\\*foo}\n","out":"*main::foo"},{"out":"","err":"","code":"$foo->@*\n"},{"code":"*foo\n","err":"","out":"*main::foo"},{"err":"","code":"\\\\*foo\n","out":"\\\\*::foo"},{"err":"","code":"\\&::foo\n","out":"sub { \"DUMMY\" }"},{"code":"\\&{ \\*foo }->()\n","err":"","out":"ERROR: Not a CODE reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"$foo++\"\n","err":"","code":"++$foo++\n"},{"out":"0","code":"'foo'+0\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"foo \\\"\n","code":"foo { $$_[0] = 1 } foo \\(my $x); $x\n","err":""},{"out":"ERROR: Not an ARRAY reference at (eval 1) line 1, <STDIN> line 1.\n","code":"(\\@{ \\*foo })->[0]++; \\@foo;\n","err":""},{"err":"","code":"(\\@{ \\*foo })->[0]++; say @foo;\n","out":"ERROR: Not an ARRAY reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"foo\"]","code":"$_ = [['foo']]; @$_[0] # Which is entirely different from @{$_[0]}\n","err":""},{"out":"[1,1,2,3,4]","code":"$foo = 1; [ 0+$foo, map $foo++, 1..4 ] # if you wanted the other behaviour\n","err":""},{"out":"ERROR: Modification of non-creatable array value attempted, subscript -1 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"$foo[-1] = 2\n"},{"out":"[\"foo\",1,2,3]","err":"","code":"[ foo => (1, 2, 3) ]\n"},{"code":"[ foo => [1, 2, 3] ]\n","err":"","out":"[\"foo\",[1,2,3]]"},{"out":"[\"foo\",1,2,3]","err":"","code":"[ foo => 1, 2, 3 ]\n"},{"code":"{ +FOO => 123 }\n","err":"","out":"123"},{"out":"[\"1, 2, 3\"]","code":"@foo = ( 1, 2, 3 ); $\" = ', '; [ \"@foo\" ]\n","err":""},{"out":"{2 => 3,foo => 1}","code":"{ foo => (1, 2, 3) } # perhaps more useful\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"foo 1\"\n","err":"","code":"[foo 1, 2, 3] sub foo { { thingy => $_[0] } }\n"},{"out":"bar 13 foo 12","err":"","code":"\"@{ [ %{ {foo => 12, bar => 13} }] }\" # no hash slice involved\n"},{"out":"foo=(1,2)   bar=(3,4)","err":"","code":"\"foo=(1, 2)   bar=(3, 4)\" =~ s/(?<=\\()([^)]+)/$1=~s{\\s+}{}gr/gre\n"},{"out":"124","code":"@foo = (1, 2, undef, 4); for my $foo (@foo) { print $foo }\n","err":""},{"out":"ERROR: Modification of non-creatable array value attempted, subscript -1 at (eval 1) line 1, <STDIN> line 1.\n","code":"$foo[-1] = 42\n","err":""},{"err":"","code":"$foo1 = 4/5; $foo2 = int(4/5); $foo3 = $foo2 ? $foo2 : 1; [ foo1 => $foo1, foo2 => $foo2, foo3 => $foo3 ]\n","out":"[\"foo1\",\"0.8\",\"foo2\",0,\"foo3\",1]"},{"out":"[1,*::foo]","code":"$foo = 1; $bar = *foo; $qux = \\*foo; [ $$bar, $$qux ]\n","err":""},{"out":"ERROR: Global symbol \"$bar\" requires explicit package name (did you forget to declare \"my $bar\"?) at (eval 1) line 1, <STDIN> line 1.\nGlobal symbol \"$qux\" requires explicit package name (did you forget to declare \"my $qux\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"$foo = 1; $bar = *foo; $qux = \\*foo; use strict; [ $$bar, $$qux ]\n","err":""},{"err":"","code":"$foo1 = $foo2 = '4 a 2'; ( $foo1 ) = $foo1 =~ /(\\d+)/; $foo2 =~ s/\\D+//g; [ $foo1, $foo2 ]\n","out":"[4,42]"},{"err":"","code":"$foo = 1; $foo++; $foo\n","out":"2"},{"out":"[5,1,2,3,4]","err":"","code":"$foo = 1; [$foo, map { $foo++ } 1 .. 4]; # isn't the order of evaluation from left to right?\n"},{"out":"[]","code":"$foo = 1; our $bar = *foo; our $qux = \\*foo; use strict; [ %$bar ]\n","err":""},{"err":"","code":"$foo = 1; our $bar = *foo; our $qux = \\*foo; use strict; [ $$bar, $$qux ]\n","out":"[1,*::foo]"},{"code":"$foo = 1; our $bar = *foo; our $qux = \\*foo; use strict; [ %$bar, %$qux ]\n","err":"","out":"ERROR: Not a HASH reference at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"$foo = 1; our $bar = *foo; our $qux = \\*foo; use strict; [ %{*$qux} ]\n","out":"[]"},{"err":"","code":"$foo ||= 2;\n","out":"2"},{"code":"${{[foo=>2, bar=>3]}}{\"foo\"}\n","err":"","out":""},{"out":"3","code":"$foo=3; $foo ||= 2;\n","err":""},{"out":"3","code":"$foo = 3; oct \"0x$foo\"\n","err":""},{"err":"","code":"{ -foo, 42 }\n","out":"42"},{"err":"","code":"{ +foo => 42 }\n","out":"42"},{"code":"+{ +foo => 42 }\n","err":"","out":"{foo => 42}"},{"code":"($foo = 42)++; $foo  # same kind of thing\n","err":"","out":"43"},{"code":"$foo = 42; our $bar = *foo; our $qux = \\*foo; use strict; [ *$bar, *$qux ]\n","err":"","out":"[*::foo,*::foo]"},{"code":"$foo = 42; our $bar = *foo; our $qux = \\*foo; use strict; [ *{$bar}{SCALAR}, *{$qux}{SCALAR} ]\n","err":"","out":"[\\42,$VAR1->[0]]"},{"out":"[\" \\\"42\\\" \"]","err":"","code":"$foo = 42; [ qq' \"$foo\" ' ]\n"},{"code":"$foo = [42]; shift $foo\n","err":"","out":"ERROR: Experimental shift on scalar is now forbidden at (eval 1) line 1, at EOF\n"},{"code":"$foo = 5607181; substr($foo, -6, 0) = '.'; $foo # without all that FANCY COMPLICATED DIVISION\n","err":"","out":"5.607181"},{"code":"$foo=5; ${*$foo}{\"bar\"}=2; $5{bar}\n","err":"","out":"2"},{"out":"abcd","code":"$foo = 'a2b11c3d5'; $foo =~ s/[^a-z]//g; print $foo;\n","err":""},{"out":"[\"a2b11c3d5\"]","code":"@foo = \"a2b11c3d5\" =~ /(\\w+)/g; \\@foo\n","err":""},{"out":"1","code":"\"f o o\" =~ /[ab ]/\n","err":""},{"err":"","code":"$foo = \"abcdefg\"; $foo =~ s/ef//; [ $-[0], length $` ]\n","out":"[4,4]"},{"err":"","code":"$foo = \"abc:def\"; {split /:/, $foo};\n","out":"2"},{"code":"$foo = \"abc:def\"; sprintf(\"0x%x\", ~~{split \":\", $foo});\n","err":"","out":"0x4cf3a70"},{"err":"","code":"$foo = '...'; \"abc\" =~ /\\Q$foo/\n","out":""},{"out":"1","code":"\"f o o\" =~ /[ab ]/x\n","err":""},{"code":"[ \"foo a b = z\" =~ /foo((?: \\w)+)/ ]\n","err":"","out":"[\" a b\"]"},{"err":"","code":"\"foo a b = z\" =~ /foo( \\w)+/; [ $1, $& ]\n","out":"[\" b\",\"foo a b\"]"},{"out":"[\"\\257\"]","code":"$foo = \"AF\"; [chr oct \"0x$foo\"]\n","err":""},{"out":"{b => [5],c => [],a => [1,2]}","err":"","code":"$_ = \"foo: a\\n bar: 1\\n bar: 2\\nfoo: b\\n bar: 5\\nfoo: c\\n\"; my(%h,$last); $1 ? push @{ $h{$last} }, $2 : ($h{$last = $2} = [])   while/^( ?)\\w+: (\\w+)/gm; \\%h\n"},{"out":"\\(A\\)","code":"$foo = \"(A)\"; \"\\Q$foo\"\n","err":""},{"code":"$foo = [ a..z ]; *array = $foo;  $array[5] # glob trick for programmers that don't like ->  hehehe\n","err":"","out":"f"},{"out":"match","err":"","code":"'foo  bang' =~ /foo (?:bar)? bang/ ? match : nomatch\n"},{"out":"nomatch","code":"'foo bang' =~ /foo (?:bar)? bang/ ? match : nomatch\n","err":""},{"out":"[\"match\"]","err":"","code":"[ 'foo bang' =~ /foo\\s+(?:bar\\s+)?bang/ ? 'match' : 'nomatch' ]\n"},{"err":"","code":"<{foo,bar}>\n","out":"foo"},{"err":"","code":"'foo   ' ^. '   bar'\n","out":"ERROR: syntax error at (eval 1) line 1, near \"^.\"\n"},{"out":"1","code":"'foo' == 'bar'\n","err":""},{"out":"","code":"\"foo\" =~ /bar/\n","err":""},{"code":"\"foo\" != \"bar\"\n","err":"","out":""},{"code":"\"foo\" . \"bar\"\n","err":"","out":"foobar"},{"out":"FOObar","err":"","code":"\"foobar\" ^ \"   \"\n"},{"out":"[\"foo\",\"bar\"]","code":"[ <{foo,bar}> ]\n","err":""},{"code":"[ \"foo ); bar );\" =~ /(.* \\)\\;)/ ]\n","err":"","out":"[\"foo ); bar );\"]"},{"out":"[\"foo );\"]","err":"","code":"[ \"foo ); bar );\" =~ /(.*? \\)\\;)/ ]\n"},{"out":"[\"+foo\",\"bar\"]","err":"","code":"[- -foo => 'bar']\n"},{"out":"ERROR: Can't modify constant item in predecrement (--) at (eval 1) line 1, near \"foo =>\"\n","err":"","code":"[--foo => 'bar']\n"},{"out":"[\"+foo\",\"bar\"]","code":"[-+-+-+-+-+-+-+-+foo => 'bar']\n","err":""},{"code":"[-+-foo => 'bar']\n","err":"","out":"[\"+foo\",\"bar\"]"},{"code":"[(-+foo => 'bar')]\n","err":"","out":"[\"-foo\",\"bar\"]"},{"code":"[{ +foo => 'bar' }]\n","err":"","out":"[{foo => \"bar\"}]"},{"code":"[{-+foo => 'bar'}]\n","err":"","out":"[{\"-foo\" => \"bar\"}]"},{"out":"bar","code":"{ +foo => 'bar' }\n","err":""},{"err":"","code":"{ +foo => \"bar\" }\n","out":"bar"},{"code":"{-+foo => 'bar'}\n","err":"","out":"bar"},{"err":"","code":"+{ foo => \"bar\" }\n","out":"{foo => \"bar\"}"},{"code":"Foo'bar\n","err":"","out":"Foo::bar"},{"out":"55","code":"$foo = $bar = 0; $foo += $bar += 1 for 1..10; $foo  # even more fun :)\n","err":""},{"out":"[\"bar1\",\"bar2\",\"bar3\"]","err":"","code":"[ ' foo= bar1,bar2,bar3  ' =~ /bar\\d+/g ]\n"},{"err":"","code":"$foo{'bar'} = 1; $foo{'baz'} = 1; scalar(%foo);\n","out":"2/8"},{"err":"","code":"$foo{'bar'} = 1; $foo{'baz'} = 1; scalar(keys(%foo));\n","out":"2"},{"out":"34","code":"@foo = ( bar => 34, baz => 42 ); print +{@foo}->{bar};\n","err":""},{"code":"'foo bar bang' =~ /foo (?:bar)? bang/ ? match : nomatch\n","err":"","out":"match"},{"err":"","code":"[ 'foo bar bang' =~ /foo\\s+(?:bar\\s+)?bang/ ? 'match' : 'nomatch' ]\n","out":"[\"match\"]"},{"err":"","code":"[ foo => bar => baz => ]\n","out":"[\"foo\",\"bar\",\"baz\"]"},{"err":"","code":"foo bar baz\n","out":"ERROR: Can't locate object method \"foo\" via package \"bar\" (perhaps you forgot to load \"bar\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"$_ = 'foo bar baz'; my %foo; @foo{qw(one two three)} = m/(\\w+)/g; \\%foo;\n","out":"{one => \"foo\",three => \"baz\",two => \"bar\"}"},{"err":"","code":"$foo->{bar} = 'baz'; \"quux $foo->{bar}\"\n","out":"quux baz"},{"err":"","code":"\"foo bar baz\" =~ s/\\b(\\w)/\\U$1/gr\n","out":"Foo Bar Baz"},{"err":"","code":"[ 'foo bar baz' =~ /\\S+/g ]\n","out":"[\"foo\",\"bar\",\"baz\"]"},{"err":"","code":"\"    foo bar baz\" =~ s/(?<=\\s)foo//r\n","out":"     bar baz"},{"out":"foo bar baz","err":"","code":"\"foo bar baz\" =~ s/(?<=\\s)foo//r\n"},{"err":"","code":"\"    foo bar baz\" =~ s/\\s\\Kfoo//r\n","out":"     bar baz"},{"out":"foo bar baz","code":"\"foo bar baz\" =~ s/\\s\\Kfoo//r\n","err":""},{"out":"ERROR: Unknown regexp modifier \"/r\" at (eval 1) line 1, at end of line\n","err":"","code":"\"foo/bar-baz&stuff/51\" =~ /(\\d+)$/r # if >5.10, I think\n"},{"out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"$foo = { bar => 'baz }; sub foo { $foo->{bar}{baz}{quux} }; exists foo()\n","err":""},{"out":"1","code":"$foo = { bar => 'baz' }; sub foo { $foo->{bar}{baz}{quux} }; exists &foo;\n","err":""},{"out":"ERROR: exists argument is not a subroutine name at (eval 1) line 1, <STDIN> line 1.\n","code":"$foo = { bar => 'baz' }; sub foo { $foo->{bar}{baz}{quux} }; exists foo()\n","err":""},{"out":"[\"foo.getBar().getBaz()\"]","err":"","code":"[ \"foo.bar.baz\" =~ s{\\.(\\w+)}{.get\\u$1()}gr ]\n"},{"out":"Foo Bar Baz","code":"\"foo bar baz\" =~ s/(\\w+)/\\u$1/gr #ah, this is what I was looking for\n","err":""},{"code":"\"foo bar baz\" =~ s/(\\w+)/\\U$1/gr #will this work I wonder?\n","err":"","out":"FOO BAR BAZ"},{"out":"[\"blah\",\"blah\"]","err":"","code":"$foo = $bar = './blah'; substr($foo, 0, 2) = ''; $bar = substr($bar, 2); [ $foo, $bar ]\n"},{"out":"0","err":"","code":"%foo; @bar = ('cat', 'dog', 'bird', 'bird'); @foo{@animals} = (); %foo;\n"},{"err":"","code":"%foo; @bar = ('cat', 'dog', 'bird', 'bird'); @foo{@bar} = (); \\%foo;\n","out":"{cat => undef,bird => undef,dog => undef}"},{"out":"2/8","code":"%foo; @bar = ('cat', 'dog', 'bird', 'bird'); @foo{@bar} = (); %foo;\n","err":""},{"err":"","code":"$foo{bar} = (); \\%foo\n","out":"{bar => undef}"},{"out":"1","err":"","code":"$foo = 'bar'; ++$$foo; $bar\n"},{"out":"[undef,\"bar\"]","code":"[\"foobar\" =~ /f(ooo)|(bar)/]\n","err":""},{"code":"\"foo(bar\" =~ /oo\\(ba/ ? \"match\" : \"no match\"\n","err":"","out":"match"},{"out":"","err":"","code":"$_='FOO bar'; print if $_ !~ /FOO\\s*?(BAR|xx)/i;\n"},{"code":"$_='FOObar'; print if $_ !~ /FOO\\s*?(BAR|xx)/i;\n","err":"","out":""},{"err":"","code":"$_='FOO bar'; print \"Invalid str.  Foo is missing BAR or xx\"  if $_ =~ /FOO(?!\\s*(BAR|xx))/i;\n","out":""},{"out":"Invalid str.  Foo is missing BAR or xx","err":"","code":"$_='FOO bar'; print \"Invalid str.  Foo is missing BAR or xx\"  if $_ =~ /FOO\\s*?(?!(BAR|xx))/i;\n"},{"out":"","code":"$_='FOObar'; print \"Invalid str.  Foo is missing BAR or xx\"  if $_ =~ /FOO(?!\\s*(BAR|xx))/i;\n","err":""},{"err":"","code":"%foo = (bar => 'quux'); sub foo { +{%foo} } [ foo->{bar}, $foo{bar} ] #huf, you're wrong, foo->{bar} is $foo{bar} :P\n","out":"[\"quux\",\"quux\"]"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n","err":"","code":"['foobarrrrsplot' =~ /foo(bar+)splot/\n"},{"err":"","code":"['foobarrrrsplot' =~ /foo(bar+)splot/]\n","out":"[\"barrrr\"]"},{"out":"[\"barrrr\",\"bar\"]","code":"['foobarrrrsplot foobarsplot' =~ /foo(bar+)splot/g]\n","err":""},{"out":"[\"barrrr\"]","code":"['foobarrrrsplot' =~ /foo(bar+)splot/g]\n","err":""},{"code":"$foo = { bar => \"stuff\" };  $foo->{bar}->{gravy}\n","err":"","out":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"foo 'bar'\"\n","err":"","code":"foo 'bar'; sub foo { 1; } # you mean you want to catch things like this?\n"},{"err":"","code":"\"foo\" . \"bar\" . \"yin\" . \"yang\"\n","out":"foobaryinyang"},{"out":"FOObat","err":"","code":"$_='FOObat'; print if $_ !~ /FOO\\s*?(BAR|xx)/i;\n"},{"err":"","code":"$foo = \"blah\"; ($bar = $foo) =~ s/bl/h/; [$bar]\n","out":"[\"hah\"]"},{"code":"$foo = \"blah\"; ($bar = $foo) =~ s/bl/h/r; [$bar]\n","err":"","out":"[\"blah\"]"},{"code":"[ 'fooblahblahbarfoobazbar' =~ /foo((?:(?!bar).)*)bar/ ]\n","err":"","out":"[\"blahblah\"]"},{"err":"","code":"$foo = \"blah episode9 blah\"; $foo =~ s/episode([0-9])/e($1-1)/e; $foo\n","out":"ERROR: Undefined subroutine &main::e called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"'e'(\"\n","err":"","code":"$foo = \"blah episode9 blah\"; $foo =~ s/episode([0-9])/'e'($-1)/e; $foo\n"},{"err":"","code":"$foo = \"blah episode9 blah\"; $foo =~ s/episode([0-9])/e($-1)/e; $foo\n","out":"ERROR: syntax error at (eval 1) line 1, near \"$-1\"\n"},{"err":"","code":"$foo = \"blah episode9 blah\"; $foo =~ s/episode([0-9])/e$1/; $foo\n","out":"blah e9 blah"},{"err":"","code":"$foo = 'b(o+g[o|n(s';  [ $foo =~ /\\Q$foo\\E/, \"\\Q$foo\" ]\n","out":"[1,\"b\\\\(o\\\\+g\\\\[o\\\\|n\\\\(s\"]"},{"code":"'foo' eq 'bar'\n","err":"","out":""},{"err":"","code":"\"{{foo\" =~ /{{f/\n","out":"1"},{"err":"","code":"\"foo\" =~ /foo/\n","out":"1"},{"code":"[ \"foo\" =~ /foo(.*)(.*?)/ ]\n","err":"","out":"[\"\",\"\"]"},{"out":"","code":"%foo{'foo'};\n","err":""},{"out":"[\"\",\"\"]","err":"","code":"[ \"foo\" =~ /foo(.*)(bar|)/ ]\n"},{"code":"[ \"foo\" =~ /foo(.*)(bar)/ ]\n","err":"","out":"[]"},{"err":"","code":"[ \"foo\" =~ /foo(bar)(baz)/ ]\n","out":"[]"},{"out":"51","code":"($foo) = \"foo/bar-baz&stuff/51\" =~ /(\\d+)$/;  $foo\n","err":""},{"out":"[\"foo\",\"rarafoo\"]","code":"[ \"foo foobar foobaz rarafoo gerzson\" =~ /\\w*o\\b/g ]\n","err":""},{"out":"[\"foo \",\"rarafoo \"]","err":"","code":"[ \"foo foobar foobaz rarafoo gerzson\" =~ /\\w*o\\W/g ]\n"},{"code":"[ \"foo foobar foobaz rarafoo\" =~ /\\w*foo\\b/g ]\n","err":"","out":"[\"foo\",\"rarafoo\"]"},{"out":"[\"foo\",\"foo\",\"foo\",\"rarafoo\"]","err":"","code":"[ \"foo foobar foobaz rarafoo\" =~ /\\w*foo/g ]\n"},{"err":"","code":"[ \"foo foobar foobaz rarafoo\" =~ /\\w*foo$/g ]\n","out":"[\"rarafoo\"]"},{"code":"$foo[\"foo\"] = \"hallo\"; \\@foo\n","err":"","out":"[\"hallo\"]"},{"code":"$foo = {};  \"foo!\" if $foo;\n","err":"","out":"foo!"},{"code":"'foo' =~ /.+/; 'foo' =~ s//bar/r; # yup\n","err":"","out":"bar"},{"code":"'foo' ^ 'fop'\n","err":"","out":"\u0000\u0000\u001f"},{"err":"","code":"[ 'foo' ^ 'fop' ]\n","out":"[\"\\0\\0\\37\"]"},{"out":"k","err":"","code":"FOO: for (0 .. 9) { last FOO; } FOO: while () { last FOO; } \"k\"\n"},{"out":"[\"o\",\"lo\",\"llo\",\"ello\",\"hello\"]","err":"","code":"$foo = 'hello'; push @bar, substr($foo, -$_) for 1 .. length $foo; \\@bar\n"},{"err":"","code":"foo \"HERE\"\n","out":"ERROR: syntax error at (eval 1) line 1, near \"foo \"HERE\"\"\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"foo \"hi\\n\"\"\n","err":"","code":"foo \"hi\\n\"; sub foo { print \"moo\\n\"; }\n"},{"out":"[]","err":"","code":"\\ @Foo::ISA\n"},{"err":"","code":"@$foo{key} # except it isn't\n","out":""},{"code":"\"foo\" =~ m/\\1/\n","err":"","out":"ERROR: Reference to nonexistent group in regex; marked by <-- HERE in m/\\1 <-- HERE / at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"\"foo\" =~ m/f/ and print \"yay\"\n","out":"yay"},{"out":"foo","code":"$_ = 'foo'; my $a = 5; 1 for $a; $_\n","err":""},{"out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n","err":"","code":"$_ = 'foo'; { my $_ = 'bar'; print $_; }\n"},{"err":"","code":"$_ = 'foo'; { my $_; print $main::_; }\n","out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_\"\n"},{"out":"1","err":"","code":"$foo = 'name'; \"define('DB_NAME', 'l33t7ex7');\" =~ /^define\\('DB_\\U$foo\\E', '(.*)'\\);$/\n"},{"err":"","code":"\"foo\\nbar\" =~ m/[\\n]/ and \"yes\"\n","out":"yes"},{"out":"[\"oo\\nar\\naz\"]","code":"[ \"foo\\nbar\\nbaz\" =~ s/^.//mgr ]\n","err":""},{"out":"matches","err":"","code":"\"foo\\nbar\" =~ /o\\nb/ ? \"matches\" : \"doesn't match\"\n"},{"out":"\nbar","code":"$_=\"foo\\nbar\"; s/.+//; $_\n","err":""},{"code":"\"foo\\nbar\" ~~ s/\\n/<br>/gr\n","err":"","out":""},{"code":"\"foo\\nbar\" =~ s/\\n/<br>/gr\n","err":"","out":"foo<br>bar"},{"err":"","code":"\"foo\\nbar\" =~ s/\\n/<br\\>/gr\n","out":"foo<br>bar"},{"out":"1","code":"\"foo\" ne \"bar\"\n","err":""},{"code":"[ 'foo nobang' =~ /foo\\s+(?:bar\\s+)?bang/ ? 'match' : 'nomatch' ]\n","err":"","out":"[\"nomatch\"]"},{"out":"[\"foo\\n\",\"#one\\n #two \\n#three\\n\",\"ERROR\",\"four\\n\"]","err":"","code":"$_ = \"foo\\n#one\\n #two \\n#three\\n##bar\\nfour\\n\"; @parse = (); push @parse, $1 =~ /##/ ? \"ERROR\" : $1 while s/^((?:\\s*#(?!#).*\\n)+|.*\\n)//; \\@parse\n"},{"err":"","code":"[ \"foo\" =~ /o{2}/, \"foo\" =~ /\\Qo{2}/ ]\n","out":"[1]"},{"out":"beans-and-cornbread","code":"$foo = 'origin/beans-and-cornbread'; substr($foo, 7)\n","err":""},{"code":"$_='FOO'; print if !~ /(BAR|xx)/;\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"if !~\"\n"},{"code":"$_='FOO'; print if $_ !~ /(BAR|xx)/;\n","err":"","out":"FOO"},{"err":"","code":"$foo = ''; print \"nothing found\" unless length $foo;\n","out":"nothing found"},{"out":"[\"a\",\"b\",\"i\",\"d\",\"e\"]","err":"","code":"@foo = qw/a b c d e/; $x = \\$foo[2];  $$x = 'i';  [ @foo ]\n"},{"err":"","code":"@foo = qw/a b c d/; [ $#foo ]\n","out":"[3]"},{"err":"","code":"@foo = qw( a b c ); [$#foo]\n","out":"[2]"},{"out":"foo\r\n\tbar\n","err":"","code":"\"foo\\r\\n\\tbar\\n\"\n"},{"code":"*foo{SCALAR}->$* = 2; my $bar; $$bar = 3; say $bar->$****foo{SCALAR}->$*;\n","err":"","out":"9\n"},{"out":"[\"foo\",\"flarb\"]","err":"","code":"[ (foo => scalar('bar', baz => scalar('quux', flurb => scalar('flarb')))) ]\n"},{"err":"","code":"[ (foo =>scalar 'bar', baz =>scalar 'quux', flurb =>scalar 'flarb') ]\n","out":"[\"foo\",\"bar\",\"baz\",\"quux\",\"flurb\",\"flarb\"]"},{"code":"[ 'foo' =~ s/foo/bar/r, 'foo' =~ tr/o/x/r ]\n","err":"","out":"[\"bar\",\"fxx\"]"},{"err":"","code":"\"foo\" =~ s/foo/^{MATCH}bar/pr;\n","out":"^{MATCH}bar"},{"out":"bar","code":"\"foo\" =~ s/foo/$^{MATCH}bar/pr;\n","err":""},{"err":"","code":"\"foo\" =~ s/foo/${^MATCH}bar/pr;\n","out":"foobar"},{"out":"fee","err":"","code":"\"foo\" =~ s/o/e/gr\n"},{"out":"foo bar","code":"@foo = (\"%s %s\", 'foo', 'bar'); printf @foo;\n","err":""},{"code":"@foo = (\"%s %s\", 'foo', 'bar'); sprintf @foo;\n","err":"","out":"3"},{"out":"[{foo => sub { \"DUMMY\" }}]","code":"[ {foo => sub {1}} ]\n","err":""},{"out":"hello","code":"\"Foo\"->${\\sub { \"hello\" } };\n","err":""},{"out":"foo.{0}.*","code":"'foo*' =~ s{([*?]+)|(\\W)}{ $2 ? \"\\\\$2\" : '.{' . $1 =~ tr/?// . '}' . '.*' x (index($1, '*') >= 0) }egr\n","err":""},{"out":"foo.*","err":"","code":"'foo*' =~ s{([*?]+)|(\\W)}{ $2 ? \"\\\\$2\" : '.' x $1 =~ tr/?// . '.*' x (index($1, '*') >= 0) }egr\n"},{"err":"","code":"[ \" foo\\tbar  baz \" =~ /\\S+/g ]\n","out":"[\"foo\",\"bar\",\"baz\"]"},{"out":"is/that","code":"$foo = 'this/that' =~ s/th//r; $foo\n","err":""},{"out":"foo","err":"","code":"$_=\"foo\"; tr alaLa; print $_\n"},{"err":"","code":"%foo = (undef, undef); say \"defined\" if (grep { defined } keys %foo);\n","out":"defined\n"},{"code":"$_='FOO v'; print if $_ !~ /FOO\\s*?(BAR|xx)/i;\n","err":"","out":"FOO v"},{"err":"","code":"$_='FOO v'; print \"Invalid str.  Foo is missing BAR or xx\"  if $_ =~ /FOO(?!\\s*(BAR|xx)/i;\n","out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/FOO( <-- HERE ?!\\s*(BAR|xx)/ at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"Invalid str.  Foo is missing BAR or xx","code":"$_='FOO v'; print \"Invalid str.  Foo is missing BAR or xx\"  if $_ =~ /FOO(?!\\s*(BAR|xx))/i;\n","err":""},{"out":"ERROR: Group name must start with a non-digit word character in regex; marked by <-- HERE in m/(?<< <-- HERE <<!>&)#(\\w+)/ at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"\"foo\" =~ /(?<<<<!>&)#(\\w+)/\n"},{"out":"[\"foo\"]","err":"","code":"[ \"(foo)\" =~ /\\w+/g ]\n"},{"out":"ERROR: Undefined subroutine &main::foo called at (eval 1) line 1, <STDIN> line 1.\n","code":"${\\*foo}->(\"why hello\")\n","err":""},{"err":"","code":"$foo=\"wibble\"; q\"$foo\"\n","out":"$foo"},{"code":"'foo' xor 'fop'\n","err":"","out":""},{"err":"","code":"$_='FOO x'; print \"Invalid str.  Foo is missing BAR or xx\"  if $_ =~ /FOO(?!\\s*(BAR|xx))/i;\n","out":"Invalid str.  Foo is missing BAR or xx"},{"out":"ERROR: Can't modify reference to array dereference in loop entry at (eval 1) line 1, at EOF\n","code":"for \\@{[]} (()) {}\n","err":""},{"err":"","code":"for ( 0 .. 10 ) { print; } print $_;\n","out":"012345678910"},{"code":"for (\"1\"..\"128\"){ print chr \"$_\" };\n","err":"","out":"\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ÃÂ"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"[ for \"\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n","err":"","code":"[ for (1..20){if (/^5$/ .. /^18$/){print $_;} ]\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"[ for \"\n","code":"[ for (1..20){if (/^5$/ .. /^18$/){print $_;}} ]\n","err":""},{"err":"","code":"for (1..20){if (/^5$/ .. /^18$/){print $_;}\n","out":"ERROR: Missing right curly or square bracket at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, at EOF\n"},{"err":"","code":"for (1..20){if (/^5$/ .. /^18$/){print $_;}}\n","out":"56789101112131415161718"},{"code":"for (\"123 5 12 7 \") { my $re = qr/(\\d+)(\\s+)/; if(/^(?:$re)+$/) { my @result = /$re/g; print \"[\" . join(\",\", @result) . \"]\" } else { print \"no match\" } } # maybe not necessarily like this, but something along these lines\n","err":"","out":"[123, ,5, ,12, ,7, ]"},{"err":"","code":"for(1..3) { print $_+1 }\n","out":"234"},{"code":"for (1..5) { print; print and last if 0 }\n","err":"","out":"12345"},{"out":"ERROR: Unimplemented at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"... for \"A\" ... \"Z\"\n"},{"code":"foreach (1..4) { do { next }; print \"$_\\n\"}\n","err":"","out":""},{"out":"[0,2,4]","err":"","code":"foreach ($i = 0; $i < 3; $i++) { push @foo, $i*2 }  \\@foo\n"},{"code":"foreach my $val (qw/entity baz /) {print +(grep /$val/,( \"foo\", \"bar\", \"foo entity bar quux\", \"foo bar\")) ? \"$val found\" : \"$val not found\" };\n","err":"","out":"entity foundbaz not found"},{"err":"","code":"foreach my $var ( 1..5 ){ print \"$var,\" }\n","out":"1,2,3,4,5,"},{"code":"for ('foo', 'bar') { s/oo/ar/g } # sirkha, like this\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"1234512345","code":"for ( grep { print $_; 1 } 1 .. 5 ) { print $_ }\n","err":""},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n","code":"for (\"hello\") { $_ = 42 }\n","err":""},{"out":"","code":"fork\n","err":""},{"err":"","code":"\"fork-fork\" =~ /-/ and [eval '$`..$\\'']\n","out":"[\"fork\"]"},{"code":"fork; print $!;\n","err":"","out":"Resource temporarily unavailable"},{"out":"","code":"fork while fork\n","err":""},{"out":"","err":"","code":"fork while fork;\n"},{"err":"","code":"fork while fork'\n","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"for (map $_, 'hello') { $_ = 42 }\n","out":""},{"err":"","code":"formatbw\\.css   # not valid\n","out":"ERROR: syntax error at (eval 1) line 1, near \"formatbw\\\"\n"},{"code":"for my $a(1 .. 100) { if ($a == 4) last; }\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \") last\"\n"},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"for my $cat (1,2,3,4) { $cat++ }\n"},{"out":"1\n2\n","err":"","code":"for \\my %hash ({foo => 1}, {foo => 2}) { say $hash{foo}; }\n"},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"for(my $i=0;$i<10;$i++) {print \"Don't spam, please!\"\\n\";}\n"},{"err":"","code":"for(my $i=0;$i<10;$i++) {print \"Don't spam, please!\\n\";}\n","out":"Don't spam, please!\nDon't spam, please!\nDon't spam, please!\nDon't spam, please!\nDon't spam, please!\nDon't spam, please!\nDon't spam, please!\nDon't spam, please!\nDon't spam, please!\nDon't spam, please!\n"},{"err":"","code":"for(my $i = 0; $i < 10; $i++) { print \"Hello #$i \"; }\n","out":"Hello #0 Hello #1 Hello #2 Hello #3 Hello #4 Hello #5 Hello #6 Hello #7 Hello #8 Hello #9 "},{"out":"Hello #0\nHello #1\nHello #2\nHello #3\nHello #4\nHello #5\nHello #6\nHello #7\nHello #8\nHello #9\n","err":"","code":"for(my $i = 0; $i < 10; $i++) { print \"Hello #$i\\n\"; }\n"},{"out":"","code":"for(my $i =0; $i <= $#$ref;$i++){ print @$ref[$i] , \"\\n\";}\n","err":""},{"err":"","code":"for my $i (1..100) {push @a, [(1) x 1024*1024]}; scalar @a\n","out":"100"},{"out":"Hello #1 Hello #2 Hello #3 Hello #4 Hello #5 Hello #6 Hello #7 Hello #8 Hello #9 Hello #10 ","err":"","code":"for my $i (1 .. 10) { print \"Hello #$i \"; }\n"},{"out":"30","err":"","code":"for my $i (1..30) {push @a, [(1) x 1024*1024]}; scalar @a\n"},{"out":"bca","code":"for my $k (keys %{{a=>1, b=>2, c=>3}}) { print $k } # works fine with hashes only known by reference too\n","err":""},{"err":"","code":"for my $x ( 1..10 ) { print $x }\n","out":"12345678910"},{"code":"for my $x ( 1..10 ) { say $x }\n","err":"","out":"1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n"},{"out":"1\n2\n4\n8\n","err":"","code":"for (my $x = 1; $x < 10; $x += my $y) { $y=$x; say $x}\n"},{"code":"for (my ($x, $y) = (\"A\", \"B\")) { print \"$x $y. \"; }\n","err":"","out":"A B. A B. "},{"code":"for (my ($x, $y) = (\"A\", \"B\")) { print \"$x $y (current value: $_). \"; }\n","err":"","out":"A B (current value: A). A B (current value: B). "},{"err":"","code":"for (()) { next }\n","out":""},{"code":"for $_ qw(foo bar baz) { print }\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"$_ qw(foo bar baz)\"\n"},{"out":"ERROR: &CORE::values cannot be called directly at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"for ([qw/foo bar/]->${\\\\&CORE::values}) { print }\n"},{"code":"for ([qw/foo bar/]->${\\\\&values}) { print }\n","err":"","out":"ERROR: Undefined subroutine &main::values called at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"for (while 1) {}\n","out":"ERROR: syntax error at (eval 1) line 1, near \"(while\"\n"},{"out":"1","code":"'á¸' =~ /\\P{UpperCase}/\n","err":""},{"err":"","code":"@f{qw/sign exponent fraction/} = (unpack \"b*\",(pack \"d\", 0.9999999999999926)) =~ /^(\\d)(\\d{11,11})(\\d+)$/; \\%f\n","out":"{sign => 1,fraction => \"1111111111111111111111111111111111111111011111111100\",exponent => \"01111011111\"}"},{"out":"23","err":"","code":"*f = sub { 23 }; no strict; &{'f'}()\n"},{"out":"t","err":"","code":"\"ft\\n\" =~ m/ft$/ ? 't' : 'f'\n"},{"out":"123","code":"*fuck = sub { 123 }; fuck()\n","err":""},{"out":"1","err":"","code":"\"FÂ­uÂ­dge\" =~ /\\N{SOFT HYPHEN}/;\n"},{"out":"1.0704","err":"","code":"Function::Parameters->VERSION\n"},{"err":"","code":"\"gammadelta\" =~ /alfa(bravo)|(gamma)delta/\n","out":"1"},{"out":"","code":"getlogin()\n","err":""},{"out":"[]","code":"[glob(\"../*\")]\n","err":""},{"out":"","err":"","code":"(glob '*')[0]\n"},{"out":"[[]]","err":"","code":"[[ ((glob(\"*.*\"))[0]) ]]\n"},{"out":"[1234,1235,1236,1237]","err":"","code":"[ glob \"123{4,5,6,7}\" ]\n"},{"code":"[ glob(\"{1,2,3,4,5,6,7,8,9,10}{11,12,13,14,15,16,17,17,18,19,20}\") ]\n","err":"","out":"[111,112,113,114,115,116,117,117,118,119,120,211,212,213,214,215,216,217,217,218,219,220,311,312,313,314,315,316,317,317,318,319,320,411,412,413,414,415,416,417,417,418,419,420,511,512,513,514,515,516,517,517,518,519,520,611,612,613,614,615,616,617,617,618,619,620,711,712,713,714,715,716,717,717,718,719,720,811,812,813,814,815,816,817,817,818,819,820,911,912,913,914,915,916,917,917,918,919,920,1011,1012,1013,1014,1015,1016,1017,1017,1018,1019,1020]"},{"err":"","code":"[ glob \"123[4 .. 7]\" ]\n","out":"[\"123[4\",\"..\",\"7]\"]"},{"err":"","code":"[ glob \"123[4-7]\" ]\n","out":"[]"},{"out":"[\"1 no split on space\",\"1d\",\"2 no split on space\",\"2d\"]","code":"[ glob '\"{1,2}{ no split on space,d}\"' ]\n","err":""},{"out":"[]","code":"[glob \"[abc]\"]\n","err":""},{"err":"","code":"[glob \"{a,b,c}\"]\n","out":"[\"a\",\"b\",\"c\"]"},{"out":"[\"abc\"]","code":"[glob \"abc\"]\n","err":""},{"out":"[\"aa\",\"ab\",\"ba\",\"bb\"]","code":"[ glob '{a,b}' x 2 ]\n","err":""},{"out":"[\"fooa\",\"foob\"]","code":"[glob \"foo{a,b}\"]\n","err":""},{"err":"","code":"glob \"foo{a,b}\"\n","out":"fooa"},{"out":"[\"fooac\",\"fooad\",\"foobc\",\"foobd\"]","err":"","code":"[glob \"foo{a,b}{c,d}\"]\n"},{"out":"[\"aa\",\"ab\",\"ac\",\"ad\",\"ae\",\"ba\",\"bb\",\"bc\",\"bd\",\"be\",\"ca\",\"cb\",\"cc\",\"cd\",\"ce\",\"da\",\"db\",\"dc\",\"dd\",\"de\",\"ea\",\"eb\",\"ec\",\"ed\",\"ee\"]","code":"[ glob \"{${\\join ',', 'a' .. 'e'}}\" x 2 ]\n","err":""},{"out":"[]","code":"[ glob \"kjdasfkjdasfdas/*\" ]\n","err":""},{"code":"*globlal = sub {\"Hello World\"}; globlal()\n","err":"","out":"Hello World"},{"out":"ERROR: Can't modify reference to ref-to-glob cast in scalar assignment at (eval 1) line 1, at EOF\n","code":"\\*globlal = sub {\"Hello World\"}; globlal()\n","err":""},{"code":"[glob(\"/*\")] # nothing even in /?\n","err":"","out":"[]"},{"out":"[\"samuel road\",\"samuel street\",\"samuel alley\",\"sam road\",\"sam street\",\"sam alley\",\"s road\",\"s street\",\"s alley\"]","err":"","code":"[ glob '\"samuel road\"' =~ s/\\bsamuel\\b/{samuel,sam,s}/gr =~ s/\\broad\\b/{road,street,alley}/gr ]\n"},{"err":"","code":"[[ ((glob(\"*.txt\"))[0]) ]]\n","out":"[[]]"},{"err":"","code":"[[ ((glob(\"*.txt\"))[0..3]) ]]\n","out":"[[]]"},{"code":"[glob \".[Zz][Ii][Pp]\"]\n","err":"","out":"[]"},{"out":"[\"nomatch\"]","err":"","code":"[ \"GMT\" =~ /(?:[PMCE][SD]T|UTC)/ ? 'match' : 'nomatch' ]\n"},{"err":"","code":"~(\"Goat\" & \" \") ^ \"oatgma\"\n","out":"ÃÂatgma"},{"out":"oatgma","err":"","code":"\"Goat\" & \" \" | \"oatgma\"\n"},{"out":"1","err":"","code":"\"Good morning! Sabah el kheer   ØµØ¨Ø§Ø­ Ø§ÙØ®ÙØ±\" =~  m{[^\\x00-\\x7f]}\n"},{"code":"goto LABEL; [do { ; LABEL: 42 }];\n","err":"","out":"[42]"},{"out":"wut","code":"goto LABEL; [do { ; LABEL: print 'wut' }];\n","err":""},{"err":"","code":"goto LABEL; [do { ; LABEL: print 'wut' } 1];\n","out":"ERROR: syntax error at (eval 1) line 1, near \"} 1\"\n"},{"out":"","code":"goto LABEL; [grep { ; LABEL: print 'wut' } 1];\n","err":"/home/ryan/workspace/perlblead-ci/runeval.sh: line 5: 13142 Segmentation fault      /home/ryan/perl5/perlbrew/perls/perlbot-blead-intest/bin/perl /home/ryan/bots/perlbuut/lib/eval.pl\n"},{"out":"","code":"goto LABEL; [map { ; LABEL: print 'wut' } 1];\n","err":"/home/ryan/workspace/perlblead-ci/runeval.sh: line 5: 13145 Segmentation fault      /home/ryan/perl5/perlbrew/perls/perlbot-blead-intest/bin/perl /home/ryan/bots/perlbuut/lib/eval.pl\n"},{"out":"[]","code":"[ grep /.../ ]\n","err":""},{"err":"","code":"[ grep $_, \"0 and false\" , 1 , \"false\", 0 ]\n","out":"[\"0 and false\",1,\"false\"]"},{"err":"","code":"[ grep 1 ]\n","out":"[]"},{"out":"[0,1,2,4,8,16,32,64,128,256,512,1024]","code":"[grep { !($_ & ($_-1)) } 0 .. 1024]\n","err":""},{"out":"[\"abcd\",\"abdc\",\"acbd\",\"acdb\",\"adbc\",\"adcb\",\"bacd\",\"badc\",\"bcad\",\"bcda\",\"bdac\",\"bdca\",\"cabd\",\"cadb\",\"cbad\",\"cbda\",\"cdab\",\"cdba\",\"dabc\",\"dacb\",\"dbac\",\"dbca\",\"dcab\",\"dcba\"]","err":"","code":"[ grep !/(.).*\\1/, glob '{a,b,c,d}' x 4 ]\n"},{"code":"[ grep $_ % 2, 1 .. 20 ]\n","err":"","out":"[1,3,5,7,9,11,13,15,17,19]"},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"[ grep { $_-=2 } 1,2,3,4,5 ]\n"},{"out":"[-1,1,2,3]","err":"","code":"[ grep { $_-=2 } 1..5 ]\n"},{"out":"[3,4,5,6,7]","code":"[ grep { $_+=2 } 1..5 ]\n","err":""},{"out":"[-1,1,2,3]","code":"[ grep { $_-=2 } 1..5 ]  # where's my error\n","err":""},{"out":"[5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]","code":"[ grep { ($_ >= 5) .. ($_ <= 18) } (1..20) ]\n","err":""},{"out":"[5,6,7,8,9,10,11,12,13,14,15,16,17,18]","code":"[grep $_ == 5 .. $_ == 18, 1 ..20]\n","err":""},{"out":"[5,4,3,2,1]","code":"[grep $_ == 5 .. $_ == 18, reverse 1 ..20]\n","err":""},{"out":"[\"abc\",\"bat\"]","err":"","code":"[ grep { /a/ and /b/ } qw/abc cat bat/ ]\n"},{"err":"","code":"[ grep /(a.a)/, qw(apple pear banana) ]\n","out":"[\"banana\"]"},{"err":"","code":"[ grep { /a/ && /b/ } qw/abc cat bat/ ]\n","out":"[\"abc\",\"bat\"]"},{"out":"[\"foobar=true\",\"foobar.yes\",\"foobar|no\"]","err":"","code":"[grep { $_ =~ /\\Afoobar.(?:true|false|yes|no)\\z/ms } (\"foobar=true\", \"foobar.yes\", \"foobar|no\", \"foobar.lambda\",)];\n"},{"out":"3","code":"grep { $_ =~ /\\Afoobar.(?:true|false|yes|no)\\z/ms } (\"foobar=true\", \"foobar.yes\", \"foobar|no\", \"foobar.lambda\",);\n","err":""},{"out":"[\"axxxyyyb\"]","code":"[ grep /a(x{0,3})(??{'y' x length $1})b/, qw( axxxyyb axxxyyyb axxxyyyyb ) ]  # Su-Shee\n","err":""},{"out":"[\"foo.bar\",\"foo\"]","err":"","code":"[ grep /^[a-z0-9]*[a-z](\\.[a-z0-9]*[a-z])*\\z/, qw( foo.bar foo foo..bar foo0.bar foo.bar. ) ]\n"},{"out":"[\"dogs\",\"badgers\",\"monkeys\"]","err":"","code":"[grep \"cats\", qw(dogs badgers monkeys)]\n"},{"code":"grep chr() =~ /[[:space:]]/, 0 .. 0x10_ffff\n","err":"","out":"25"},{"code":"[grep defined, \"this is (a test,a problem)\" =~ /.*\\(|\\).*|([^,()]+)/g ]\n","err":"","out":"[\"a test\",\"a problem\"]"},{"out":"present","err":"","code":"!grep($_ eq 'bbb', qw(aaa bbb ccc)) ? 'not present' : 'present'\n"},{"out":"not present","err":"","code":"!grep($_ eq 'xxx', qw(aaa bbb ccc)) ? 'not present' : 'present'\n"},{"err":"","code":"[ grep /foo(?!.*bar)/, qw( foo bar foobar fooooooobar  foosomebar foosomeba ) ]\n","out":"[\"foo\",\"foosomeba\"]"},{"out":"[\"foo\",\"foo (bar)\",\"(bar) foo\",\"foo (bar) baz\"]","code":"[ grep /^([^()]+|\\([^()]*\\))*$/g, \"foo\", \"foo (bar)\", \"(bar) foo\", \"foo (bar) baz\", \"foo (bar\" ]\n","err":""},{"code":"grep $_ .= '-haha', map $_, qw(a b c d e)\n","err":"","out":"5"},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n","code":"grep $_ .= '-haha', qw(a b c d e)\n","err":""},{"out":"[\"h\"]","code":"[ grep /h/, map chr, (0..0x3000) ]\n","err":""},{"err":"","code":"[grep -iP { $_ =~ /(?:foobar)(?:\\s.\\s|.)(?:true|false|yes|no) } (\"foobar=true\", \"foobar = true\", \"FOOBAR:no\", \"barfoo=yes\",)];\n","out":"ERROR: Search pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"[ grep { length * 2 < 4 } qw/a bcd efgh i j k/ ]\n","out":"[]"},{"out":"ERROR: Unterminated <> operator at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"[ grep { length <= 3 } qw/a bcd efgh i j k/ ]\n"},{"code":"[ grep { length >= 3 } qw/a bcd efgh i j k/ ]\n","err":"","out":"[\"bcd\",\"efgh\"]"},{"out":"[\"[\",\"]\"]","code":"[ grep /[\\[\\]]/, map chr, 0..255 ]\n","err":""},{"out":"[\"http://40.media.tumblr.com/b3e62ef833996a4ffb544ed37300807d/tumblr_nlf8czGMpJ1s61cido1_500.jpg\",\"http://40.media.tumblr.com/c0e108161497f351e40db139289b3818/tumblr_nldblnzio71s61cido1_500.jpg\"]","err":"","code":"[ grep m|^http://(?!.*avatar)|, qw( http://assets.tumblr.com/images/default_avatar/octahedron_open_48.png http://assets.tumblr.com/images/default_avatar/cube_closed_48.png http://40.media.tumblr.com/b3e62ef833996a4ffb544ed37300807d/tumblr_nlf8czGMpJ1s61cido1_500.jpg http://40.media.tumblr.com/c0e108161497f351e40db139289b3818/tumblr_nldblnzio71s61cido1_500.jpg ) ]\n"},{"code":"grep { $_->{name}[0] eq $w } @list,\n","err":"","out":"0"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"},\"\n","code":"grep { $_->{name}[0] eq $w }, @list\n","err":""},{"out":"[]","err":"","code":"[ grep { not (1../3/) } (1..10) ]\n"},{"out":"[\"help-comment\\@example.net\",\"help\\@example.net\"]","err":"","code":"[ grep { not (1 + index $_, 'approver') and m/help.*?\\@example.net/ } qw(help-approver@example.net help-comment@example.net help@example.net) ];\n"},{"out":"[]","code":"[ grep { not (do{1}../3/) } (1..10) ]\n","err":""},{"out":"[\"m\",\"q\",\"s\",\"y\"]","err":"","code":"[ grep { not eval } a..z ]\n"},{"code":"grep $_, @order[-1]\n","err":"","out":"ERROR: Modification of non-creatable array value attempted, subscript -1 at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"[ grep { scalar(/\\Aw\\z/../\\Af\\z/) } qw/m tu w th f sa su/ ]\n","err":"","out":"[\"w\",\"th\",\"f\"]"},{"code":"[ grep Scalar::Util::looks_like_number $_, split ' ', \"foo 12 bar lol super-yay 13_000 20.12 baz\" ]\n","err":"","out":"[12,\"20.12\"]"},{"out":"[12,13]","code":"[ grep Scalar::Util::looks_like_number $_, split ' ', \"foo 12 bar lol super-yay 13 baz\" ]\n","err":""},{"out":"[\"ScaleAddr5=abc\"]","err":"","code":"[ grep /^scaleaddr(\\d)=([^\\d]*)/i, qw(blahj blah blah ScaleAddr5=abc) ];\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"/^scaleaddr(\\d)/i qw/scaleaddr123/\"\n","err":"","code":"[ grep /^scaleaddr(\\d)/i qw/scaleaddr123/ ];\n"},{"out":"[\"\\t\",\"\\n\",\"\\13\",\"\\f\",\"\\r\",\" \",\"\\205\",\"\\240\"]","err":"","code":"[ grep /\\s/,map chr,  0..255 ]\n"},{"out":"[\"frog\",\"\\\"jumping\",\"jack\\\"\",\"book\",\"bob\\\"\",\"elephant\"]","code":"[  grep { $_ !~ /:/ } split('\\s+', 'frog abd:def \"jumping jack\" 123:456 book jimbo:\"billy bob\" elephant') ]\n","err":""},{"code":"grep { $_ !~ /:/ } split('\\s+', 'frog abd:def \"jumping jack\" 123:456 book jimbo:\"billy bob\" elephant');\n","err":"","out":"6"},{"err":"","code":"[ grep tr/()//cdr!~/^\\)|\\($|\\(\\(|\\)\\)/, \"foo\", \"foo (bar)\", \"(bar) foo\", \"foo (bar) baz\", \"foo (bar\" ]\n","out":"[\"foo\",\"foo (bar)\",\"(bar) foo\",\"foo (bar) baz\"]"},{"code":"[ grep tr/()//cdr=~/^(\\(\\))*$/g, \"foo\", \"foo (bar)\", \"(bar) foo\", \"foo (bar) baz\", \"foo (bar\" ]\n","err":"","out":"[\"foo\",\"foo (bar)\",\"(bar) foo\",\"foo (bar) baz\"]"},{"out":"[\"one\",\"abcdefghij\"]","code":"[ grep /^\\w{3,10}\\z/, qw( one jdhfkjhfkjhdlkfjgh qwe.ert abcdefghij  no abcdefghijk ) ]\n","err":""},{"code":"Grinnz->can('import') ? \"has import kthx\" : \"no such thing\"\n","err":"","out":"no such thing"},{"out":"","err":"","code":"Grinnz->import()\n"},{"code":"\"guess\\nwhat\" =~ /\\Aguess$/m ? \"k\" : \"wtf\"\n","err":"","out":"k"},{"out":"[\"T\",\"F\"]","err":"","code":"%h = ( 1=>1, 1=>0, 0=>1, 0=>0 ); [ map { !$_ || $h{$_} ? 'T' : 'F' } keys %h ]\n"},{"err":"","code":"%h = ( 1=>1, 1=>0, 0=>1, 0=>0 ); map { !$_ || $h{$_} ? 'T' : 'F' } keys %h\n","out":"2"},{"out":"[\"T\"]","code":"@h = ( 1=>1, 1=>0, 0=>1, 0=>0 ); [ map { ! $_ || shift @h ? 'T' : 'F' } shift @h ]\n","err":""},{"code":"@h = ( 1, 1, 1, 0, 0, 1, 0, 0 ); [ map { ! $_ || shift @h ? 'T' : 'F' } shift @h ]\n","err":"","out":"[\"T\"]"},{"code":"%h = (12 => 'hip', 0x12 => 'hop'); \\%h\n","err":"","out":"{12 => \"hip\",18 => \"hop\"}"},{"code":"%h = 1..6; {%h{1,3}}\n","err":"","out":"4"},{"out":"{1 => 2,3 => 4}","err":"","code":"%h = 1..6; +{%h{1,3}}\n"},{"code":"%h = 1..6; +{%h{1,3,5}} # boo\n","err":"","out":"{5 => 6,1 => 2,3 => 4}"},{"out":"{7 => undef,1 => 2,3 => 4}","err":"","code":"%h = 1..6; +{%h{1,3,7}} # boo\n"},{"err":"","code":"[\\(%h1, %h2, %h3)]\n","out":"[{},{},{}]"},{"code":"%h = ( 1=>\"one\", 2=>\"two\" ); map { print \"key: $_ val: $h{$_}\" } keys %h\n","err":"","out":"key: 1 val: onekey: 2 val: two"},{"err":"","code":"$h = { 25 => 1 }; my $idx = \"25 \"; [ $h->{$idx}, $h->{0+$idx} ]\n","out":"[undef,1]"},{"out":"[1,1]","err":"","code":"$h = { 25 => 1 }; my $idx = \"25\"; [ $h->{$idx}, $h->{0+$idx} ]\n"},{"err":"","code":"$^H=256;join(($x)x101)\n","out":""},{"err":"","code":"$^H=256;join($x)x101\n","out":""},{"out":"ERROR: Missing right curly or square bracket at (eval 1) line 1, within string\nsyntax error at (eval 1) line 1, at EOF\n","code":"%h=( 'a'=>'1', 'b'=>'2' ); %h=( 'c'=>'3', 'd'=>'4' ); for ( sort keys %h ){ print \"$_ $h{$_\" };\n","err":""},{"code":"%h=( 'a'=>'1', 'b'=>'2' ); %h=( 'c'=>'3', 'd'=>'4' ); for ( sort keys %h ){ print \"$_ $h{$_}\" };\n","err":"","out":"c 3d 4"},{"out":"1/8","code":"%h = (a => 1); scalar %h\n","err":""},{"out":"{b => 3,c => 4,a => 2}","err":"","code":"@h{'a' .. 'c'} = 1 .. 3; ++$_ for values %h; \\ %h;\n"},{"code":"halal\n","err":"","out":"halal"},{"err":"","code":"`halt`;\n","out":""},{"err":"","code":"$h = {'a' => {'one' => 1}, \"b\" => 2}; $i = {'a' => {'two' => 2}; $j = {%$h, %$i}; print Dumper($j);\n","out":"ERROR: syntax error at (eval 1) line 1, near \"; $j \"\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n"},{"err":"","code":"$h = {'a' => {'one' => 1}, \"b\" => 2}; $i = {'a' => {'two' => 2}}; $j = {%$h, %$i}; print Dumper($j);\n","out":"$VAR1 = {\n          'b' => 2,\n          'a' => {\n                   'two' => 2\n                 }\n        };\n"},{"err":"","code":"$h = {'a' => {'one' => 1}, \"b\" => 2}}; $i = {'a' => {'two' => 2}}; $j = {%$h, %$i}; print Dumper($j);\n","out":"ERROR: Unmatched right curly bracket at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, near \"}}\"\n"},{"out":"0","code":"%hash = 1..4; delete @hash{1,3}; scalar %hash\n","err":""},{"out":"2/8","err":"","code":"%hash = 1..4; scalar %hash\n"},{"code":"%hash = (1..8); $_++ for %hash; \\%hash\n","err":"","out":"{7 => 9,5 => 7,1 => 3,3 => 5}"},{"err":"","code":"%hash = (1..8); %hashtwo = (a..j); $_++ for %hash, %hashtwo; [ \\%hash, \\%hashtwo ]\n","out":"[{7 => 9,5 => 7,1 => 3,3 => 5},{i => \"k\",c => \"e\",g => \"i\",e => \"g\",a => \"c\"}]"},{"out":"{quux => {bar => 2,foo => 1},baz => undef}","err":"","code":"%hash1 = ( foo => 1, bar => 2 ); %hash2 = ( baz => undef, quux => \\%hash1 );  \\%hash2\n"},{"out":"{bar => 2,foo => 1}","err":"","code":"%hash1 = ( foo => 1, bar => 2 ); %hash2 = ( baz => undef, quux => \\%hash1 );  $hash2{quux}\n"},{"out":"2","code":"%hash1 = ( foo => 1, bar => 2 ); %hash2 = ( baz => undef, quux => \\%hash1 );  $hash2{quux}{bar}\n","err":""},{"err":"","code":"%hash=(2=>\"two\", 1=>\"one\"); print sort { $a cmp $b } keys %hash\n","out":"12"},{"out":"ERROR: Experimental keys on scalar is now forbidden at (eval 1) line 1, <STDIN> line 1.\n","code":"%hash=(2=>\"two\", 1=>\"one\"); print sort keys { $a cmp $b } keys %hash\n","err":""},{"code":"%hash = @array = qw/a list of stuff/; [ \\%hash, \\@array ]   # you have arrayrefs though. see perldoc perlreftut\n","err":"","out":"[{of => \"stuff\",a => \"list\"},[\"a\",\"list\",\"of\",\"stuff\"]]"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","err":"","code":"$hash = { a => 'z', b => { c => 'y' } }; if(ref $hash->{a} ne ;\n"},{"out":"scalar","err":"","code":"$hash = { a => 'z', b => { c => 'y' } }; if(ref $hash->{a} ne 'ARRAY' && ref $hash->{a} ne 'HASH') { print 'scalar' };\n"},{"out":"HASH","err":"","code":"$hash = { a => 'z', b => { c => 'y' } }; ref $hash->{b};\n"},{"out":"{b => 1,c => 2,f => 2,d => 1,e => 1,a => 2}","code":"%hash = (); @hash{a..f} = (1)x7; $_++ for @hash{a,c,f}; \\%hash  # hehehe\n","err":""},{"code":"$hash{'key1'} = \"val1\"; print ref %hash\n","err":"","out":"1"},{"out":"1","code":"$hash{'key1'} = \"val1\"; print ref $hash{'key1'}\n","err":""},{"code":"$hash{\"key1\"}=\"val2\"; $hash{\"key2\"}=\"val1\"; for ( sort { $hash{$a} cmp $hash{$b} } keys %hash ) { print \"key: $_: val: $hash{$_}, \"; };\n","err":"","out":"key: key2: val: val1, key: key1: val: val2, "},{"out":"key: key2: val: val1, key: key1: val: val2, ","err":"","code":"$hash{\"key1\"}=\"val2\"; $hash{\"key2\"}=\"val1\"; for ( sort { $hash{$a} <=> $hash{$b} } keys %hash ) { print \"key: $_: val: $hash{$_}, \"; };\n"},{"out":"key: key1: val: val2, key: key2: val: val1, ","code":"$hash{\"key1\"}=\"val2\"; $hash{\"key2\"}=\"val1\"; for ( sort { $hash{$b} cmp $hash{$a} } keys %hash ) { print \"key: $_: val: $hash{$_}, \"; };\n","err":""},{"out":"key:key2: val:val1, key:key1: val:val2, ","code":"$hash{\"key1\"}=\"val2\"; $hash{\"key2\"}=\"val1\"; for ( sort { $hash{$b} <=> $hash{$a} } keys %hash ) { print \"key:$_: val:$hash{$_}, \"; };\n","err":""},{"err":"","code":"$h->{bar} eq 'lol'; $h->{baz}->{whiz} eq 'lol'; $h\n","out":"{baz => {}}"},{"out":"{baz => {whiz => \"lol\"}}","code":"$h->{bar} eq 'lol'; $h->{baz}->{whiz} = 'lol'; $h\n","err":""},{"code":"[ \"hello\" =~ /^([a-z]+)(?:\\s+(.+))?$/ ]\n","err":"","out":"[\"hello\",undef]"},{"err":"","code":"$_ = \"hello\"; /e/c or die; [pos]\n","out":"[undef]"},{"out":"1","code":"\"hello it is now on 8:08\" =~ m{\\A .* on (.*) }xms;\n","err":""},{"out":"1","code":"(\"hello it is now on 8:08\" =~ m{\\A .* on (.*) }xms);\n","err":""},{"code":"[\"hello it is now on 8:08\" =~ m{\\A .* on (.*) }xms];\n","err":"","out":"[\" 8:08\"]"},{"out":"[\"hello\\n\",\"world\",\"\"]","err":"","code":"[ \"hello\\nworld\" =~ m/(.*(?:\\n|$))/g ]\n"},{"out":"[\"hello\\n\",\"world\"]","err":"","code":"[ \"hello\\nworld\" =~ /^.*\\n?/mg ]\n"},{"err":"","code":"\"Hello\" =~ /^.*(.+)$(??{print\"$1\\n\"})/\n","out":"o\nlo\nllo\nello\nHello\n"},{"out":"o\nlo\nllo\nello\no\nlo\nllo\no\nlo\no\n","code":"\"Hello\" =~ /(?!^).*(.+)$(??{print\"$1\\n\"})/    # test\n","err":""},{"out":"[\"o\",\"lo\",\"llo\",\"ello\"]","code":"\"Hello\" =~ /(?!^).+(*PRUNE)(?{push @bar, $&})(*FAIL)/; [ reverse @bar ]\n","err":""},{"out":"hello","code":"\"   hello\" =~ s/^\\s*//sr\n","err":""},{"err":"","code":"[ \"hello there\" =~ /^([a-z]+)(?:\\s+(.+))?$/\n","out":"ERROR: syntax error at (eval 1) line 1, at EOF\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n"},{"out":"[\"hello\",\"there\"]","err":"","code":"[ \"hello there\" =~ /^([a-z]+)(?:\\s+(.+))?$/ ]\n"},{"out":"[\"hello\",\"there\"]","err":"","code":"[ \"hello there\" =~ /^([a-z]+)\\s*(|(?<=\\s).+)$/ ]\n"},{"code":"[ \"hello-there\" =~ /^([a-z]+)\\s*(|(?<=\\s).+)$/ ]\n","err":"","out":"[]"},{"out":"[\"hellothere\",\"\"]","err":"","code":"[ \"hellothere\" =~ /^([a-z]+)\\s*(|(?<=\\s).+)$/ ]\n"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n","err":"","code":"[\"Hello\" =~ tr/l/g/r\n"},{"code":"[\"Hello\" =~ tr/l/g/r]\n","err":"","out":"[\"Heggo\"]"},{"err":"","code":"{%{hello=>\"world\"}}\n","out":"0"},{"out":"0","err":"","code":"%{%{{hello=>\"world\"}}}\n"},{"code":"%{%{hello=>\"world\"}}\n","err":"","out":"0"},{"out":"[\"hello\",\"world\",\"foo-bar-baz\"]","code":"$_ = 'hello, world, foo bar baz';  [ map tr/ /-/r, split /,\\s*/ ]\n","err":""},{"code":"$_ = 'hello, world, foo bar baz';  [ map tr/ /-/r, split /,\\s*/ ] # try three :)\n","err":"","out":"[\"hello\",\"world\",\"foo-bar-baz\"]"},{"out":"[\"Hell\",\"o, w\",\"orld\"]","err":"","code":"[ \"Hello, world!\" =~ m/(....)/g ]\n"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"[ \"Hello, world!\" =~ m/(....)/g; ]\n","err":""},{"out":"[[\"h\",\"e\"],[\"l\",\"l\"],[\"o\",\" \"],[\"w\",\"o\"],[\"r\",\"l\"]]","err":"","code":"$_ = 'hello world'; push @ar, [$1,$2] while /(.)(.)/g; \\@ar\n"},{"code":"\"Hello, world\" =~ tr/A-Za-z/N-ZA-Mn-za-m/\n","err":"","out":"ERROR: Can't modify constant item in transliteration (tr///) at (eval 1) line 1, at EOF\n"},{"out":"","err":"","code":"'help-approver@example.net' =~ /^(?!help-approver).+\\@example\\.net$/\n"},{"code":"'help-approver@example.net' =~ /(?<!^help-approver)\\@example\\.net$/\n","err":"","out":""},{"code":"'help-approver@example.net' =~ /(?<!help-approver)\\@example\\.net$/\n","err":"","out":""},{"err":"","code":"'help-approver@example.net' =~ /(?!<^help-approver)\\@example\\.net$/\n","out":"1"},{"err":"","code":"'help-approver@example.net' =~ /(?!<help-approver)\\@example\\.net$/\n","out":"1"},{"out":"1","err":"","code":"'help-approver@example.net' =~ /(?!help-approver).+\\@example\\.net/\n"},{"code":"'help-comment@example.net' =~ /^(?!help-approver).+\\@example\\.net$/\n","err":"","out":"1"},{"out":"1","err":"","code":"'help@example.net' =~ /(?<!help-approver)\\@example\\.net$/\n"},{"out":"here","err":"","code":"here\n"},{"err":"","code":"HERE: { print 1; HERE: { print 2; HERE: { print 3; goto HERE unless $i++ > 2 } } }\n","out":"123333"},{"out":"there","code":" ${{here,there}}{here};\n","err":""},{"out":"sub { \"DUMMY\" }","code":"\\&hex\n","err":""},{"out":"1393955010.823","err":"Hexadecimal number > 0xffffffff non-portable at (eval 1) line 4, <STDIN> line 1.\n","code":"hex(\"000001448e317907\") / 1000\n"},{"code":"hex '0a'\n","err":"","out":"10"},{"out":"10","code":"hex '0x0a'\n","err":""},{"out":"20","code":"hex \"0x14\"\n","err":""},{"out":"ERROR: Undefined subroutine &main::hex called at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"\\&hex->(\"0x24\")\n"},{"out":"43981","code":"hex \"0xabcd\"\n","err":""},{"err":"Use of uninitialized value $_[0] in hex at (eval 1) line 4, <STDIN> line 1.\n","code":"hex $1\n","out":"0"},{"err":"","code":"hex \"1e0\"\n","out":"480"},{"code":"hex 41\n","err":"","out":"65"},{"code":"hex \"4155\"\n","err":"","out":"16725"},{"out":"[6316287]","code":"$hex = '6060FF'; [ unpack q{L>*}, pack q{H*}, '0' x (-length($hex) % 8) . $hex ]\n","err":""},{"err":"","code":"hex \"dead\"\n","out":"57005"},{"code":"hex 'f' x 16\n","err":"Hexadecimal number > 0xffffffff non-portable at (eval 1) line 4, <STDIN> line 1.\n","out":"18446744073709551615"},{"out":"3.16059037807746e+20","code":"hex q{112233445566778899}\n","err":"Integer overflow in hexadecimal number at (eval 1) line 4, <STDIN> line 1.\nHexadecimal number > 0xffffffff non-portable at (eval 1) line 4, <STDIN> line 1.\n"},{"out":"true","err":"","code":"\"hey, this contains A-Z somewhere\" =~ /A-Z/ ? 'true' : 'false'\n"},{"out":"1","err":"","code":"$^H{feature_state} = 1; sub foo { state $x; }\n"},{"err":"","code":"$h = { \"foo\" => 42 } ;  push @{$h->{foo}}, 17;  say $h->{foo};  # Really?\n","out":"42\n"},{"out":"[5,6,2]","code":"$h = {foo => 5, bar => 6, baz => 2}; [@{$h}{qw(foo bar baz)}] # is that what you mean?\n","err":""},{"out":"[5]","code":"$h = {foo => 5, bar => 6}; [$h->{foo}]\n","err":""},{"out":"[5]","err":"","code":"$h = {foo => 5, bar => 6}; [@{$h}{qw/foo/}]\n"},{"out":"0","err":"","code":"$H{'foobar'}++\n"},{"err":"","code":"@h{grep !/[a-zA-Z{}]/, split //, \"MPOPCNTSF: INTEGER[9]\"} = (); join '', keys %h\n","out":"[: 9]"},{"err":"","code":"$h=\"hello world!\"; $h=~ s/(.){1}(.){1}/$2,$1/eg; print $h\n","out":"hlowrd"},{"out":"hlowrd","err":"","code":"$h=\"hello world!\"; $h=~ s/(.)(.)/$2,$1/eg; print $h\n"},{"out":"ifmmp!xpsme\"","code":"$h=\"hello world!\"; $h=~ s/(.)(.)/$cipher.=chr(ord($1)+1).chr(ord($2)+1);/eg; print $cipher\n","err":""},{"out":"ififmmifmmp!ifmmp!xpifmmp!xpsmifmmp!xpsme\" == ifmmp!xpsme\"","code":"$h=\"hello world!\"; $h=~ s/(.)(.)/$cipher.=chr(ord($1)+1).chr(ord($2)+1);/eg; print \"$h == $cipher\"\n","err":""},{"out":"ehll oowlr!d","err":"","code":"$h=\"hello world!\"; $h=~ s/(.)(.)/$h=\"$2$1\";/eg; print $h\n"},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n","code":"$h=\"hello world!\"; $h=~ s/(.)(.)/$h=$2++.$1++;/eg; print $h\n","err":""},{"code":"$h=\"hello world!\"; $h=~ s/(.)(.)/$h=chr(ord($1)+1.$1++;/eg; print $h\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"1.$1\"\n"},{"err":"","code":"$h=\"hello world!\"; $h=~ s/(.)(.)/$h=chr(ord($1)+1).chr(ord($2)+1);/eg; print $h\n","out":"ifmmp!xpsme\""},{"err":"","code":"$h=\"hello world!\"; $h=~ s/(.)(.)/$h=uc($2).\"$1\";/eg; print $h\n","out":"EhLl oOwLr!d"},{"err":"","code":"$h=\"hello world!\"; $h=~ s/(.)(.)/$h=uc($2).$1\";/eg; print $h\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"hi","err":"","code":"hi\n"},{"err":"","code":"\"hi\"\n","out":"hi"},{"out":"ni","err":"","code":"%h = (ichi, ni, san, shi); $h{ichi}\n"},{"code":"[\"Hi mace\"]\n","err":"","out":"[\"Hi mace\"]"},{"out":"hi","code":"$_=\"hi\"; print();\n","err":""},{"err":"","code":"$_=\"hi\"; print(undef);\n","out":"1"},{"out":"Hi these_eyesHi these_eyesHi these_eyes","err":"","code":"'Hi these_eyes' x 3\n"},{"out":"hihihihi","err":"","code":"\"hi\" x 4\n"},{"out":"[\"hi\",\"hi\",\"hi\",\"hi\"]","code":"[(\"hi\") x 4]\n","err":""},{"out":"hiya","err":"","code":"'{# hiya #} {# world #}' =~ m/{#\\s?(.+?)\\s?#}/g; $1;\n"},{"err":"","code":"\"hlagh\"**0\n","out":"1"},{"out":"foo","code":"$h{'login'} = 'foo'; $h{login}\n","err":""},{"out":"{aaa => \"one\",\"asd.fg\" => \"foo\",ccc => \"test\",bbb => \"two\"}","err":"","code":"%h = map { /^(.+)\\.(.*?)\\.\\1$/ } \"aaa.one.aaa\", \"bbb.two.bbb\", \"ccc.test.ccc\", \"asd.fg.foo.asd.fg\"; \\%h\n"},{"out":"{b => 456,a => 123}","code":"%h = map { split /:/ } qw( a:123 b:456 ); \\%h\n","err":""},{"err":"","code":"$_ = 'hood'; s/h(.*)d/n$1k/r\n","out":"nook"},{"out":"[\"foo\",\"bar\"]","code":"$href = { \"foo\"=>\"bar\" }; [ %$href ]\n","err":""},{"err":"","code":"$href = { \"foo\"=>\"bar\" }; lock_ref_keys($href); map { print \"\\\"$_\\\":$href->{$_}\\n\" } %{$href}\n","out":"ERROR: Undefined subroutine &main::lock_ref_keys called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"\"foo\":bar\n\"bar\":\n","code":"$href = { \"foo\"=>\"bar\" }; map { print \"\\\"$_\\\":$href->{$_}\\n\" } %{$href}\n","err":""},{"out":"foobar","err":"","code":"$href = { \"foo\"=>\"bar\" }; print (%{$href})\n"},{"out":"bar","code":"$href = { \"foo\"=>\"bar\" }; print $href->{\"foo\"}\n","err":""},{"out":"foobar","code":"$href = { \"foo\"=>\"bar\" }; sub pr { print @_ }; pr( %$href );\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"$hs1 = { _ -> {} }\n","err":""},{"out":"qr/XabcY/u","code":"$h->{someKey}->{whatever} = 'abc'; qr/X$h->{someKey}->{whatever}Y/\n","err":""},{"out":"[\"/html\"]","code":"[\"<html>foo</html>\" =~ /<([^>]+)>\\s*$/m]\n","err":""},{"out":"[\"k1\",\"v1\",\"k2\",\"v2\"]","err":"","code":"$_=\"http://a?k1=v1&k2=v2\"; $_=(split /\\?/)[-1]; [ map { split /=/ } (split /&/) ]\n"},{"out":"[\"1J2KAFHQk_.jpg\"]","err":"","code":" [ 'http://go2web4free.com:7004/img/users/1/1J2KAFHQk_.jpg' =~ m{[^/]+$}g ]\n"},{"out":"ERROR: Unknown regexp modifier \"/e\" at (eval 1) line 1, at end of line\n","err":"","code":"http://google.com $html->at('title')->text\n"},{"out":"ERROR: Unknown regexp modifier \"/t\" at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, near \"599c9b609f78f9b0abf4\n\"\n","code":"https://gist.github.com/anonymous/599c9b609f78f9b0abf4\n","err":""},{"err":"","code":"https://gist.github.com/zoffixznet/2ad28e7398c95bb4c92d#file-test-pl-L9\n","out":"ERROR: Unknown regexp modifier \"/t\" at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, near \"2ad28e7398c95bb4c92d#file-test-pl-L9\n\"\n"},{"out":"ERROR: Unknown regexp modifier \"/w\" at (eval 1) line 1, at end of line\nUnknown regexp modifier \"/w\" at (eval 1) line 1, at end of line\nUnknown regexp modifier \"/w\" at (eval 1) line 1, at end of line\n","code":"http://www.google.com/ $html = lc $html; $html =~ tr/a-z/n-za-m/;\n","err":""},{"code":"http://www.google.com/ $html = lc $html; $html =~ tr/a-z/n-za-m/; $html\n","err":"","out":"ERROR: Unknown regexp modifier \"/w\" at (eval 1) line 1, at end of line\nUnknown regexp modifier \"/w\" at (eval 1) line 1, at end of line\nUnknown regexp modifier \"/w\" at (eval 1) line 1, at end of line\n"},{"code":"http://www.google.com/ ref $html\n","err":"","out":"ERROR: Unknown regexp modifier \"/w\" at (eval 1) line 1, at end of line\nUnknown regexp modifier \"/w\" at (eval 1) line 1, at end of line\nUnknown regexp modifier \"/w\" at (eval 1) line 1, at end of line\n"},{"code":"\"http://www.google.com\" =~ s/http:\\/\\//http:\\/\\/CLOUD_NETWORK.1.1:2144\\//r # I get www.google.com at the end\n","err":"","out":"http://CLOUD_NETWORK.1.1:2144/www.google.com"},{"out":"[\"australia\"]","err":"","code":"[ 'http://www.site.com/letters0241/something-in-australia-a' =~ m[/(?:[^-/]*-){2}([^-/]*)[^/]*\\z] ]\n"},{"out":"[\"australia\"]","code":"[ 'http://www.site.com/letters0241/something-in-australia-a' =~ m[something-in-([^-]*)] ]\n","err":""},{"err":"","code":"$_ = \"huf\"; ++$_\n","out":"hug"},{"code":"huf->can(\"be::sure\")\n","err":"","out":""},{"out":"sub { \"DUMMY\" }","code":"huf->can(\"can\")\n","err":""},{"out":"sub { \"DUMMY\" }","code":"huf->can(\"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")\n","err":""},{"out":"3\n","err":"","code":"@hyperv = qw(foo bar baz); print @hyperv . \"\\n\"\n"},{"out":"abaa","err":"","code":"$i = 0; \"aaaa\" =~ s/a/(++$i == 2) ? 'b' : $&/ger #hey, you can do it in perl too! :P\n"},{"out":"1 2 3 5 8 13 21 34 55 89 144 233 ","code":"$i = 1; for (1 .. 12) { print $i, \" \"; $i = int $i * (.5 + sqrt 1.25) + .5; }\n","err":""},{"out":"14","code":"$i=5; $i = ++$i + ++$i\n","err":""},{"out":"I am ","err":"","code":"\"I am \"\n"},{"out":"I am a bot","code":"\"I am a bot\"\n","err":""},{"out":"I am a fish \"I am a fish \".$_[0]","err":"","code":"\"I am a fish \".$_[0]\n"},{"out":"[\"i am\",\" am \",\"am h\",\"m ha\",\" hap\",\"happ\",\"appy\"]","err":"","code":"$_ = 'i am happy'; [ /(?=(....))/g ]\n"},{"err":"","code":"`id`\n","out":""},{"err":"","code":"'i' ^ 'd'\n","out":"\r"},{"out":"[\"\\r\"]","err":"","code":"[ 'i' ^ 'd' ]\n"},{"code":"[ \"<id>textA<email1><id>textB<email2>\" =~ m!<id>([^<>]*)<email2>! ]\n","err":"","out":"[\"textB\"]"},{"code":"[ \"<id>textA<email1><id>textB<email2>\" =~ m!<id>([^<>]*)<email\\d>!g ]\n","err":"","out":"[\"textA\",\"textB\"]"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","err":"","code":"if(0)\n"},{"out":"0","code":"if (0) { 'a block' }\n","err":""},{"code":"if (0) { } esle { } exit\n","err":"","out":""},{"err":"","code":"if (1 == 1) { print 'foo'; } else;\n","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"code":"if ( 1 ){ do_something(); } sub  do_something { print \"heyy\"; }\n","err":"","out":"heyy"},{"out":"ERROR: syntax error at (eval 1) line 1, near \") {\"\n","code":"if (1) {} elseif (2) {}\n","err":""},{"out":"","code":"if (1) {} elsif (2) {}\n","err":""},{"out":"lelz","err":"","code":"{ if (1 ) { last; print \"lols\"; } print \"lulz\"; } print \"lelz\";  # linagee\n"},{"out":"here done","err":"","code":"if(1) {{ print \"here\"; last; print \"not here\" }} print \" done\"\n"},{"err":"","code":"if ('abc' =~ /^a/) { 1 } else { 0 }\n","out":"1"},{"err":"","code":"if(\"a\" == \"b\"){print \"true\";}else{print \"false\";}\n","out":"true"},{"err":"","code":"if(\"a\" eq \"b\"){print \"true\";}else{print \"false\";}\n","out":"false"},{"code":"\"if answer > 0: answer = answer + 2\" =~ /^\\s*if (.*): (.*)/\n","err":"","out":"1"},{"err":"","code":"if (@a = sub { return }->()) { 1 }\n","out":"0"},{"code":"if (@a = sub { return undef }->()) { 1 }\n","err":"","out":"1"},{"code":"if('besaid' =~ m/(\\w*said)/) {print qq{matched \"$1\"\\n};}\n","err":"","out":"matched \"besaid\"\n"},{"code":"`ifconfig -a | grep -i inet`\n","err":"","out":""},{"out":"[{foo => {bar => {}}}]","code":"if (exists $x->{foo}{bar}{baz}) { } [$x]\n","err":""},{"code":"if (false) { print \"false is true!\"; }\n","err":"","out":"false is true!"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"if...\"\n","err":"","code":"if...if ($x.endswith(\"ft\"))...\n"},{"code":"if (my ($var1, $var2) = \"foo bar\" =~ /(foo|bar)/g) { print \"Matches! var1: $var1, var2: $var2\"; }\n","err":"","out":"Matches! var1: foo, var2: bar"},{"err":"","code":"if (my ($var1, $var2) = \"foo bar\" =~ /(foo)|(bar)/g) { print \"Matches! var1: $var1, var2: $var2\"; }\n","out":"Matches! var1: foo, var2: "},{"out":"Matches! var1: foo, var2: ","code":"if (my ($var1, $var2) = \"foo bar\" =~ /(foo|bar)/) { print \"Matches! var1: $var1, var2: $var2\"; } #I'm not quite sure it's entirely correct though\n","err":""},{"out":"Matches! var1: foo, var2: ","err":"","code":"if (my ($var1, $var2) = \"foo bar\" =~ /(foo)|(bar)/) { print \"Matches! var1: $var1, var2: $var2\"; } #meant like this rather, but meh\n"},{"out":"TRUE","code":"if ((my $var) = (\"z\" =~ //)) { print \"TRUE\" ;}\n","err":""},{"err":"","code":"if (my ($x, $y) = (1, 0) { ['true']; } else { ['false'] }\n","out":"ERROR: syntax error at (eval 1) line 1, near \") {\"\n"},{"err":"","code":"if (my ($x, $y) = (1, 0)) { ['true']; } else { ['false'] }\n","out":"[\"true\"]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"if  !\"\n","code":"if  !($sender =~ qr/@ArrayNickHighLight/i) {}\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","err":"","code":"if (!($sender =~ qr/@ArrayNickHighLight/i))\n"},{"out":"","err":"","code":"if (!($sender =~ qr/@ArrayNickHighLight/i)) {}\n"},{"out":"","err":"","code":"if ($sender !~ qr/@ArrayNightHighLight/i) { ... }\n"},{"err":"","code":"if( \"        \" =~ /^((\\t|\\s{4})+)/ ) { print length $1 }\n","out":"8"},{"out":"4","err":"","code":"if( \"        \" =~ /^(\\t|\\s{4})+/ ) { print length $1 }\n"},{"out":"1","code":"\"        if (x = 2): print y;        yo\" =~ /^([\\t ]+)/; my $indents = () = $1 =~ /(\\t| {8})/g\n","err":""},{"code":"if (! $x = foo() )\n","err":"","out":"ERROR: Can't modify not in scalar assignment at (eval 1) line 1, near \") )\n\"\nsyntax error at (eval 1) line 1, at EOF\n"},{"err":"","code":"if ($x->{foo}{bar}{baz}) { } [$x]\n","out":"[{foo => {bar => {}}}]"},{"out":"","err":"","code":"if ($x){next}\n"},{"code":"$_ = \"If you can read this, you could be a programmer\"; tr/aeiou//d; $_\n","err":"","out":"If y cn rd ths, y cld b  prgrmmr"},{"out":"[{i => 2,h => 1},undef]","code":"$i = {\"h\" => 1, \"i\" => 2}; $j = \"i\"; [ ${$j}, $i->{${$j}} ]\n","err":""},{"err":"","code":"\"I hate people\" =~ s/e//gr\n","out":"I hat popl"},{"code":"\"I\" + \"I\";\n","err":"","out":"0"},{"code":"$i=$i++;  ++$i + $i++\n","err":"","out":"3"},{"out":"3","code":"$i=$i++;  ++$i + $i++  ;\n","err":""},{"err":"","code":"\"i like my keys with rings, not within my hammy interior\" =~ s/\\b(my|with)\\b/[$1]/rg\n","out":"i like [my] keys [with] rings, not within [my] hammy interior"},{"code":"\"i like my keys with rings, not within my hammy interior\" =~ s/\\b(my|with)\\b/[$1]/rg -- this one?\n","err":"","out":"ERROR: Can't modify substitution (s///) in postdecrement (--) at (eval 1) line 1, near \"s/\\b(my|with)\\b/[$1]/rg --\"\nsyntax error at (eval 1) line 1, near \"-- this one\"\n"},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"\"img 34 32 4 3453  m agi  img 34 ag sgd dfg dfs img 54323 423 img 3sadf  asd\n","err":""},{"code":"\"img 34 32 4 3453  m agi  img 34 ag sgd dfg dfs img 54323 423 img 3sadf  asd\" =~ s/img/img\\n/gr\n","err":"","out":"img\n 34 32 4 3453  m agi  img\n 34 ag sgd dfg dfs img\n 54323 423 img\n 3sadf  asd"},{"code":"$in = \"abc123def456xyz\"; (@out) = $in =~ /\\d+/g; \\@out;\n","err":"","out":"[123,456]"},{"out":"[123]","err":"","code":"$in = \"abc123def\"; ($out) = $in =~ /\\d+/g; [$out]; # for added confusion\n"},{"err":"","code":"$in = \"abc123def\"; ($out) = $in =~ /(\\d+)/; [$out]\n","out":"[123]"},{"out":"[1]","code":"$in = \"abc123def\"; ($out) = $in =~ /\\d+/; [$out]\n","err":""},{"code":"index('abcde', 'd')\n","err":"","out":"3"},{"out":"[0,0]","err":"","code":"[index(\"foo bar\",\"foo\"),index(\"food\",\"foo\")]\n"},{"err":"","code":"[index(\"foo\", \"foo bar\"),index(\"foo\",\"food\")]\n","out":"[-1,-1]"},{"out":"1","err":"","code":"index('test123', 'test') == 0  # I assume?\n"},{"err":"","code":"@indices; for (1 .. 10) { push @indices, 11 - $_ }; [@indices];\n","out":"[10,9,8,7,6,5,4,3,2,1]"},{"out":"inf","err":"","code":"'inf'\n"},{"out":"1","code":"'inf' > ~0\n","err":""},{"out":"ERROR: Illegal division by zero at (eval 1) line 1, <STDIN> line 1.\n","code":"'inf'/0\n","err":""},{"code":"'inf' - 'inf'\n","err":"","out":"NaN"},{"out":"1","code":"inf == inf\n","err":""},{"out":"1","err":"","code":"\"inf\" == \"Inf\"\n"},{"out":"NaN","err":"","code":"'inf'/'nan'\n"},{"out":"[\"foo\",\"foo.bak\"]","code":"$in=\"foo\"; ($out = $in) .= \".bak\"; [ $in, $out ]\n","err":""},{"out":"[\"foo.bak\",\"foo.bak\"]","err":"","code":"$in=\"foo\"; $out = $in .= \".bak\"; [ $in, $out ]\n"},{"code":"\"INGY\" ^ \"perl\"\n","err":"","out":"9+55"},{"out":"[\"no\",\"yes\"]","err":"","code":"$input = \"123\\n456\"; [ $input =~ /123.*456/ ? \"yes\" : \"no\", $input =~ /123.*456/s ? \"yes\" : \"no\" ]\n"},{"code":"$input = '       A         B        C'; [ split \" \", $input ]\n","err":"","out":"[\"A\",\"B\",\"C\"]"},{"err":"","code":"$input = ideally I'd\n","out":"ERROR: Can't locate object method \"ideally\" via package \"I::d\" (perhaps you forgot to load \"I::d\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"73","err":"","code":"int(11/15 * 100);\n"},{"out":"113","err":"","code":"int(1.139999999999999 * 100)\n"},{"out":"114","code":"int(1.14 * 100)\n","err":""},{"code":"int(134.95 * 100)\n","err":"","out":"13494"},{"out":"25","code":"int( (1414364400 - 1414274400) / 3600 )\n","err":""},{"err":"","code":"int(19.99*100)\n","out":"1998"},{"err":"","code":"int(2.4213534531451E+30)\n","out":"2.4213534531451e+30"},{"err":"","code":"int((45/50-1)*100)\n","out":"-9"},{"err":"","code":"int(5/3)\n","out":"1"},{"err":"","code":"&Internals::SvREADONLY \\!0, 0; ${\\!0} = 0; defined 'foo'\n","out":"ERROR: syntax error at (eval 1) line 1, near \"&Internals::SvREADONLY \\\"\n"},{"code":"&Internals::SvREADONLY(\\!0, 0); ${\\!0} = 0; defined 'foo'\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"&Internals::SvREADONLY(\\undef, 0); undef = []; undef\n","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"int((foo); bar()\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"out":"64","code":"$intsize = length(~1) > 10 ? 64 : 32\n","err":""},{"code":"int sprintf '%.f', 134.95 * 100\n","err":"","out":"13495"},{"out":"true","err":"","code":"\" \" == int(\" \") ? \"true\" : \"false\"\n"},{"out":"true","err":"","code":"\"\" == int(\"\") ? \"true\" : \"false\"\n"},{"code":"int((x)\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"err":"","code":"int((x); y()\n","out":"ERROR: Transliteration replacement not terminated at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"IO::Socket::INET->new()\n","err":"","out":"ERROR: Can't locate object method \"new\" via package \"IO::Socket::INET\" (perhaps you forgot to load \"IO::Socket::INET\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"[ \"<ip:11111432941656@192.168.0.230>\" =~ /:([0-9]+)/ ]\n","out":"[\"11111432941656\"]"},{"code":"$i = [qw/5 7 8 2/]; [sum map { scalar @$_ } @i]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"sum map\"\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"sum map\"\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n","code":"$i = [qw/5 7 8 2/]; [sum map { scalar @$_ } @list\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"sum map\"\n","err":"","code":"$i = [qw/5 7 8 2/]; [sum map { scalar @$_ } @list]\n"},{"err":"","code":"'irc.freenode.net' =~ /irc\\.([^.]+)/ and print $1;\n","out":"freenode"},{"out":"1","code":"isa {STDOUT} 'GLOB';\n","err":""},{"out":"","err":"","code":"isa {STDOUT} 'IO::Handle';\n"},{"out":"ERROR: Can't call method \"isa\" without a package or object reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"\"\"->isa(\"UNIVERSAL\")\n"},{"out":"[\"s\",\"Wilma\",\" yest\"]","err":"","code":"$_ = \"I saw Wilma yesterday\"; [ /(\\w*)a/, /(\\w*a)(\\s+[a-zA-Z]{4})/ ]\n"},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"\" is just our way of talking to the evalbot. Nothing to do wih code.\n","err":""},{"out":"imaa peaksmaaa Oatgmaaaa Atinlmaaaaa","err":"","code":"$_ = 'I speak Goat Latin'; my $n = 1; s/\\b([^aeiou\\W])?(\\w+)/\"$2\\L$1ma\".'a'x$n++ ^ (($&&$\")^$\")/geir\n"},{"code":"$_ = 'I speAk Goat Latin'; my $n = 1; s/\\b([^aeiou\\W])?(\\w+)/\"$2\\L$1ma\".'a'x$n++ ^ (($&&$\")^$\")/geir\n","err":"","out":"imaa peAksmaaa Oatgmaaaa Atinlmaaaaa"},{"err":"","code":"$_ = 'I speAk Goat Latin'; my $n = 1; s/\\b([^aeiou\\W])?(\\w+)/\"\\L$2$1ma\".'a'x$n++ ^ (($&&$\")^$\")/geir\n","out":"Imaa peaksmaaa Oatgmaaaa Atinlmaaaaa"},{"out":"Imaa peaksmaaa oatgmaaaa atinlmaaaaa","err":"","code":"$_ = 'I speak Goat Latin'; my $n = 1; s/\\b([^\\Waeiouy]?)(\\w+)/$2\\l$1ma/gr =~ s/\\w+\\K/'a'x$n++/ger\n"},{"code":"$_ = \"I speAk Goat Latin\"; my $n = 1; s/\\b([^\\Waeiouy]?)(\\w+)/my $z = \"$2\\l$1ma\" ; ($1=~m\"\\p{Lu}\"?\"\\u$z\":$z)/ger =~ s/\\w+\\K/\"a\"x$n++/ger\n","err":"","out":"Imaa peAksmaaa oatgmaaaa atinlmaaaaa"},{"code":"$_ = 'I speAk Goat Latin'; my $n = 1; s/\\b([^\\Waeiouy]?)(\\w+)/$\"x length$&&\"$1$2\"^\"\\U$2$1\\Ema\"/ger =~ s/\\w+\\K/'a'x$n++/ger\n","err":"","out":"Imaa peaKsmaaa Oatgmaaaa Atinlmaaaaa"},{"out":"Imaa peaKsmaaa Oatgmaaaa Atinlmaaaaa","err":"","code":"$_ = 'I speAk Goat Latin'; my $n = 1; s/\\b([^\\Waeiouy]?)(\\w+)/$\"x length$&&$&^\"\\U$2$1\\Ema\"/ger =~ s/\\w+\\K/'a'x$n++/ger\n"},{"code":"$_ = 'I speak Goat Latin'; s/\\b[aeiouy]\\w+\\K/ma/gi || s/\\b(\\w)(\\w*)/$2$1ma/g; my $n = 1; s/\\w+\\K/'a'x$n++/ger # like this riceandbeans\n","err":"","out":"Imaa peaksmaaa oatGmaaaa atinLmaaaaa"},{"code":"is to test things.\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"err":"","code":"\"italic test after italic\"\n","out":"italic test after italic"},{"out":"{itemFilter => \"second value\"}","code":"{ itemFilter => 'first value', itemFilter => 'second value' };\n","err":""},{"out":"second value","code":"( item => \"first value\", item => \"second value\" ); # That's how you fix \u0002*that*\u0002\n","err":""},{"code":"[ item => \"first value\", item => \"second value\" ]; # Why did you evaluate the last one the way you did, anyway?\n","err":"","out":"[\"item\",\"first value\",\"item\",\"second value\"]"},{"err":"","code":"\"It puts the lotion in the basket!\"\n","out":"It puts the lotion in the basket!"},{"err":"","code":"'i' xor 'd'\n","out":""},{"out":"j","code":"\"\\j\"\n","err":""},{"out":"+jesus","code":"- -'jesus'\n","err":""},{"code":"-'jesus'\n","err":"","out":"-jesus"},{"out":"john.com","err":"","code":"\"john@example.com\"\n"},{"out":"ERROR: Can't locate object method \"j\" via package \"oin\" (perhaps you forgot to load \"oin\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"j oin\n","err":""},{"code":"join \"\\0\", qw<a b c>\n","err":"","out":"a\u0000b\u0000c"},{"err":"","code":"join(':', (1..10))\n","out":"1:2:3:4:5:6:7:8:9:10"},{"err":"","code":"join \", \", 1, 2, \"\\n\";\n","out":"1, 2, \n"},{"err":"","code":"join'','a'..'m','N'..'Z'\n","out":"abcdefghijklmNOPQRSTUVWXYZ"},{"out":"abcdefghijklmNOPQRSTUVWXYZ","err":"","code":"join'',a..'m',N..Z\n"},{"out":"ERROR: Search pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n","code":"join'',a..m ,N..Z\n","err":""},{"out":"ERROR: Search pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"join'',a..m,N..Z\n"},{"err":"","code":"join('', 'a'..'z') =~ s/(.{13})$/uc$1/er\n","out":"abcdefghijklmNOPQRSTUVWXYZ"},{"out":"abcdefghijklmNOPQRSTUVWXYZ","code":"join('', 'a'..'z') =~ s/^(.*)\\K(??{ '.' x length $1 })$/\\U$&/r;\n","err":""},{"out":"Buffalo","err":"","code":"join ' ', (\"Buffalo\")\n"},{"out":"Buffalo Buffalo Buffalo Buffalo Buffalo Buffalo Buffalo Buffalo","code":"join ' ', (\"Buffalo\") x8\n","err":""},{"out":"d8:50:e6:84:e6:de","code":"join ':', 'd850e684e6de' =~ /../g\n","err":""},{"err":"","code":"join'e', qw(y s)\n","out":"yes"},{"code":"join \"\", grep /\\w/a, map chr, 0..999999\n","err":"","out":"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"},{"err":"","code":"join \"hello\", \"a single argument\"\n","out":"a single argument"},{"err":"","code":"join 'irre', qw(sq l)\n","out":"sqirrel"},{"err":"","code":"[ join('', map { +{} } 0..10 ]\n","out":"ERROR: syntax error at (eval 1) line 1, near \"10 ]\"\n"},{"err":"","code":"[join \"\", map \"$_\\0\", qw(foo bar baz)]\n","out":"[\"foo\\0bar\\0baz\\0\"]"},{"out":"[\"?,?,?,?,?,?,?,?,?,?\"]","code":"[ join ',', map '?', 1..10 ]\n","err":""},{"out":"1:4:9:16:25:36:49:64:81:100","err":"","code":"join(':', map { $_ *= $_ } (1..10))\n"},{"out":"0 20 40 60 80","err":"","code":"join ' ', map { 20 * ($_ - 1) } 1 .. 5;\n"},{"code":"join '', map chr, 0x2603 # works fine with >256, but they're unicode not utf-8\n","err":"","out":"ÃÂ¢ÃÂÃÂ"},{"out":"admin","err":"","code":"join '', map { chr(255 - hex) } \"9E9B929691\" =~ /([[:xdigit:]]{2})/g # Nei++\n"},{"err":"","code":"join ' ', map chr, 97 .. 100\n","out":"a b c d"},{"out":"abc","err":"","code":"join('',map chr,(97, 98, 99))\n"},{"out":"gRINNZ","err":"","code":"join '', map chr(ord ^ 32), split '', 'Grinnz'\n"},{"code":"join '', map { chr } unpack 'H*', \"31323234\"\n","err":"","out":"ÃÂ¿ÃÂÃÂÃÂÃÂÃÂµÃÂÃÂÃÂ¶ÃÂÃÂÃÂµÃÂ"},{"out":"abc,\\N,def,ghi,\\N,jkl","code":"join \",\", map { $_ || \"\\\\N\" } split \",\", \"abc,,def,ghi,,jkl\"\n","err":""},{"code":"join ' ', map $_ . \"\\N{U+0300}\", qw(a e i o u)\n","err":"","out":"aÃÂÃÂ eÃÂÃÂ iÃÂÃÂ oÃÂÃÂ uÃÂÃÂ"},{"code":"join ' ', map $_ . \"\\N{U+0300}\", qw(a e i o u)  <perlbot> anno: Ã Ã¨Ã¬Ã²\n","err":"","out":"ERROR: Unrecognized character \\xC3; marked by <-- HERE after ot> anno: <-- HERE near column 155 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"226, 194, 194, 194, 226, 226, 226, 226, 226, 226","code":"join ', ', map ord, qw(â° Â¹ Â² Â³ â´ âµ â¶ â· â¸ â¹)\n","err":""},{"code":"join ' ', map pack('B8', $_), \"01101000 01100101 01101100 01110000\" =~ /\\d+/g;\n","err":"","out":"h e l p"},{"err":"","code":"[ join \" -- \",map { s!^/|/$!!g;$_ } @{[ qw{ /foo/bar/baz/ foo/bar/baz /foo/bar/baz foo/bar/baz/ } ]} ]\n","out":"[\"foo/bar/baz -- foo/bar/baz -- foo/bar/baz -- foo/bar/baz\"]"},{"code":"join(' ', map { sprintf(\"%02X\", ord($_)) } split('', \"bar\"))\n","err":"","out":"62 61 72"},{"err":"","code":"join \" \", map sprintf(\"%02x\", $_), qw|137 80 78 71 13 10 26 10|\n","out":"89 50 4e 47 0d 0a 1a 0a"},{"err":"","code":"join \" \", map {ucfirst} split(\" \", \"My fancy filename.txt\")\n","out":"My Fancy Filename.txt"},{"out":"V:b1.03.00.00. N:00.00.03.b1.","err":"","code":"join ' ', map { \"$_:\".(unpack( \"H*\", pack $_, 945 ) =~ s/../$&./gr) } 'V', 'N'\n"},{"code":"join '-', map { \"x$_y\" } 1..3;\n","err":"","out":"x-x-x"},{"out":"x1y-x2y-x3y","code":"join '-', map { \"x${_}y\" } 1..3;\n","err":""},{"out":"[\"This\\n is\\na st\\nring\"]","code":"[ join (\"\\n\", unpack '(A4)*', 'This is a string') ]\n","err":""},{"err":"","code":"join ('\\n', unpack '(A4)*', 'This is a string')\n","out":"This\\n is\\na st\\nring"},{"out":"[\"(?^u:^[a-zA-Z]+\\$)|(?^u:^[0-9]+\\$)\"]","err":"","code":"[ join '|', qr/^[a-zA-Z]+$/, qr/^[0-9]+$/ ]\n"},{"out":"fname <<<<<<< lname <<<<<<< age","code":"join ' <<<<<<< ', qw(fname lname age)\n","err":""},{"out":"foo1bar1baz","code":"join //, qw(foo bar baz)\n","err":""},{"code":"join ',', qw(?) x 10\n","err":"","out":"?,?,?,?,?,?,?,?,?,?"},{"out":"7b46867c","code":"join '', reverse \"7c86467b\" =~ m/../g\n","err":""},{"out":"Just another Perl hacker,","code":"join '', sort { --$| * 2 - 1 } split //, 'Jurlt ,cneh eeotakrrsa Ph';\n","err":""},{"err":"","code":"join '', sort { --$| * 2 - 1 } split //, 'LaeulsraWt y yarmsoir r l';\n","out":"Larry Wall is your master"},{"err":"","code":"join '', sort split '', 'msixpodualngc'\n","out":"acdgilmnopsux"},{"code":"[join '', sort {$|--} split //, \"tuJsa nohterP er lhakcer,\"]\n","err":"","out":"[\"Just another Perl hacker,\"]"},{"out":"abc","err":"","code":"(join '', (split //, 'abc'))\n"},{"err":"","code":"+join +'_', +(+split /_/, +\"the_cool_string\")[+1,+2]\n","out":"cool_string"},{"out":"cool_string","err":"","code":"join '_', (split /_/, \"the_cool_string\")[1,2]\n"},{"out":"cool_string","err":"","code":"join '_', +(split /_/, \"the_cool_string\")[1,2]\n"},{"err":"","code":"join \" \", @{ unbuu || [] }\n","out":""},{"out":"","code":"join \" \", @{ undef || [] }\n","err":""},{"err":"","code":"join \" \", @{ undef() || [] }\n","out":""},{"out":"","err":"","code":"join \" \", @{ undef() }\n"},{"err":"","code":"[ join ',', (undef // ()), 'x', (undef // ()) ]\n","out":"[\"x\"]"},{"out":"00:02:02:05:6D:4C","err":"","code":"join \":\", unpack \"(a2)*\", \"000202056D4C\"\n"},{"out":"3.177","err":"","code":"join \".\", unpack \"C*\", pack \"n\", 945\n"},{"out":"12:34:56","err":"","code":"join ':', unpack('(H2)3', \"\\x12\\x34\\x56\")\n"},{"out":"e8:b7:48:68:07:48","code":"join \":\", unpack \"(H2)*\", pack \"H*\", \"e8b748680748\"\n","err":""},{"out":"[\"?,?,?,?\"]","code":"[ join ',', ('?')x4 ]\n","err":""},{"out":"[\"????\"]","code":"[ join ',', ('?'x4) ]\n","err":""},{"out":"JSON","err":"","code":"JSON\n"},{"out":"ERROR: Undefined subroutine &main::JSON called at (eval 1) line 1, <STDIN> line 1.\n","code":"JSON()\n","err":""},{"code":"JSON::encode_json [sprintf(\"%.2f\", 1.234), sprintf(\"%.2f\", 1.234) + 0]\n","err":"","out":"[\"1.23\",1.23]"},{"err":"","code":"\\@JSON::EXPORT\n","out":"[\"from_json\",\"to_json\",\"jsonToObj\",\"objToJson\",\"encode_json\",\"decode_json\"]"},{"code":"\\@JSON::EXPORT_OK\n","err":"","out":"[]"},{"err":"","code":"JSON->new->encode({ value => 0+sprintf(\"%.3f\", 34.33/400) })\n","out":"{\"value\":0.086}"},{"out":"[bless( do{\\(my $o = 1)}, 'JSON::PP::Boolean' )]","err":"","code":"[JSON::true]\n"},{"out":"JUNK","code":"\"JUNK\" =~ m/(.*)/; do { local $1; \"wibble\" =~ m/(\\d+)/; $1; }\n","err":""},{"err":"","code":"\"JUNK\" =~ m/(.*)/; \"wibble\" =~ m/(\\d+)/; $1;\n","out":"JUNK"},{"out":"Just another Perl hacker","err":"","code":"Just'another'Perl'hacker =~ s/::/ /gr\n"},{"out":"Just another silly! Perl hacker","code":"\"Just anotherÂ Perl hacker\" =~ s\u000fo?Â \u000f silly! \u000fr\n","err":""},{"code":"$_ = \"key foo\"; push @arr, /key(.*)/; [@arr]\n","err":"","out":"[\" foo\"]"},{"code":"[ keys { 1 .. 10 } ]\n","err":"","out":"ERROR: Experimental keys on scalar is now forbidden at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Experimental keys on scalar is now forbidden at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"[keys {1..4}]\n"},{"out":"5","err":"","code":"keys @{ [1..5] }\n"},{"out":"ERROR: Experimental keys on scalar is now forbidden at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"keys( {} ) = 42\n"},{"err":"","code":"[ keys (%{{ 'dave' => 1, 'bob' => 2 }}) ]\n","out":"[\"dave\",\"bob\"]"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","err":"","code":"[ keys (%{{ 'dave' => 1, 'bob' => 2 }}); ]\n"},{"err":"","code":"keys (%{ 'dave' => 1, 'bob' => 2 });\n","out":"0"},{"err":"","code":"keys (%{{ 'dave' => 1, 'bob' => 2 }});\n","out":"2"},{"out":"0","code":"keys %hash = 200; scalar %hash\n","err":""},{"out":"ERROR: Type of arg 1 to keys must be hash (not constant item) at (eval 1) line 1, at EOF\n","code":"keys INC\n","err":""},{"err":"","code":"keys %{main::};\n","out":"1495"},{"err":"","code":"keys(%order) = 2; keys(%order)\n","out":"0"},{"out":"0","err":"","code":"keys(%order) = 2; scalar %order\n"},{"err":"","code":"[keys { qw(a b c d) }]\n","out":"ERROR: Experimental keys on scalar is now forbidden at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"keys { qw(a b c d) }\n","err":"","out":"ERROR: Experimental keys on scalar is now forbidden at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"4","code":"@keys = qw(a b c d); @hash{@keys} = @hash{@keys}\n","err":""},{"code":"@keys = qw(a b c d); @hash{@keys} = @hash{@keys}; \\%hash\n","err":"","out":"{b => undef,c => undef,d => undef,a => undef}"},{"out":"{b => 2,c => [3,4],a => 1}","err":"","code":"@keys = qw(a b c); @values = qw(1 2 3 4); my %result; if (@keys < @values) { push @values, [ splice @values, $#keys ]} @results{@keys} = @values; \\%results\n"},{"err":"","code":"@keys = qw(a b c); @values = qw(1 2 3 4); my %result; if (@keys < @values) { push @values, [ splice @values, $#keys ]} $results{@keys} = @values; \\%results\n","out":"{3 => 3}"},{"out":"[]","code":"[ keys(%^V), values(%^V) ]\n","err":""},{"out":"","code":"kill -TERM, 0\n","err":"/home/ryan/workspace/perlblead-ci/runeval.sh: line 5: 14692 Terminated              /home/ryan/perl5/perlbrew/perls/perlbot-blead-intest/bin/perl /home/ryan/bots/perlbuut/lib/eval.pl\n"},{"code":"@{[\"Knark\",\". \",\"knark\",\",\"]}\n","err":"","out":"4"},{"err":"","code":"\"\\\\l\\$1\"\n","out":"\\l$1"},{"code":"\"\\l\\$1\"\n","err":"","out":"$1"},{"err":"","code":"LABEL: { goto redo next last LABEL; }\n","out":""},{"err":"","code":"LABEL: { last LABEL if 1; }\n","out":""},{"code":"LABEL: sub { }\n","err":"","out":"sub { \"DUMMY\" }"},{"out":"","code":"LABEL: { sub { last LABEL }->() }\n","err":""},{"err":"","code":"LABEL: { sub { last LABEL }->(); print \"fail\" }; print \"ok\";\n","out":"ok"},{"out":"ERROR: Label not found for \"last LABEL\" at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"LABEL: sub { { last LABEL } print \"hax\" }->()\n"},{"out":"lag","err":"","code":"\"lag\"\n"},{"err":"","code":"'lala'->${ \\sub { 'here ' . shift } }\n","out":"here lala"},{"out":"la la","err":"","code":"*{ 'la la'} = sub { 'la la' }; my $name = 'la la'; my $ref = \\&$name; $ref->()\n"},{"code":"lc 'áº'\n","err":"","out":"ÃÂ¡ÃÂºÃÂ"},{"err":"","code":"lc chr 0xfb06\n","out":"ERROR: panic: Infinite recursion in SWASHNEW for 'ToLc'\n"},{"err":"","code":"lc chr 0xfb08\n","out":"ERROR: panic: Infinite recursion in SWASHNEW for 'ToLc'\n"},{"code":"lc \"Foo\" eq lc \"foo\"\n","err":"","out":"1"},{"out":"","code":"length\n","err":""},{"out":"[undef]","code":"[length]\n","err":""},{"code":"length \"[^ /\"\n","err":"","out":"4"},{"err":"","code":"length 0x00FF\n","out":"3"},{"code":"length 0xFF\n","err":"","out":"3"},{"out":"3","code":"length 100\n","err":""},{"code":"length \"1436365603657\"\n","err":"","out":"13"},{"code":"length 1e10\n","err":"","out":"11"},{"err":"","code":"length 1e1000\n","out":"3"},{"out":"10","err":"","code":"length 2**32\n"},{"out":"31","err":"","code":"length \"2421392269093537440547188383164\"\n"},{"err":"","code":"length 2**64\n","out":"20"},{"code":"length 64.64.64.5000000000.64.64.6\n","err":"","out":"7"},{"out":"3","code":"length \"Ìa\"\n","err":""},{"code":"length \"aÌ\"\n","err":"","out":"3"},{"out":"2","code":"length \"Ã \"\n","err":""},{"out":"104857600","err":"","code":"length (\"a\"x(100*1024*1024))\n"},{"out":"31457280","err":"","code":"length (\"a\"x(30*1024*1024))\n"},{"code":"length \"Ã©\"\n","err":"","out":"2"},{"out":"9","code":"length 'á¹ÍÍÍ'\n","err":""},{"err":"","code":"length pack \"c\", 9999;\n","out":"1"},{"code":"length pack \"cc\", 9888, 9999;\n","err":"","out":"2"},{"out":"2","code":"length pack \"cc\", 9999;\n","err":""},{"err":"","code":"length pack \"h\", \"41\"\n","out":"1"},{"out":"1","err":"","code":"length q(\\\\)\n"},{"out":"16","code":"length q|0.99999999999996|\n","err":""},{"code":"length q|0.9999999999999919|\n","err":"","out":"18"},{"err":"","code":"length q caller vec and print chr ord uc q chr lc and print chr ord q ge log and print chr ord qw q lc q and print chr ord qw q lc q and print chr ord q xor x and print chr ord qq q q and print chr ord uc qw q wait q and print chr ord q xor x and print chr ord q qr q and print chr ord qw q le q and print chr ord qw q do q and print chr hex length q q semctl setpgrp chop q and print chr length q q conti\n","out":"ERROR: Can't find string terminator \"q\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"length q[{CRYPT}$2a$04$MjkMhQxasFQod1qq56DXCOvWu6YTWk9X.EZGnmSSIbbtyEBIAixbS]\n","err":"","out":"67"},{"out":"8","err":"","code":"length 'sàº²à» '\n"},{"out":"7","err":"","code":"length 'sàº²à»'\n"},{"out":"8","code":"length sprintf \"%8.2f\", 12\n","err":""},{"code":"length sprintf \"%8f\", 12\n","err":"","out":"9"},{"err":"","code":"length sprintf '%b', 2 ** 100\n","out":"64"},{"err":"","code":"length sprintf '%b', 2**64\n","out":"64"},{"out":"42","code":"$            leonerd = 42;\n","err":""},{"out":"42","err":"","code":"$ leonerd = 42;\n"},{"out":"yummy","err":"","code":"@lettuce = ( kale => \"chrunchy\"); map { print \"yummy\" if  /kale/ } @lettuce;\n"},{"out":"2","err":"","code":"@lettuce = ( kale => \"chrunchy\"); map { print \"yummy\" if $lettuce{$_} eq \"kale\" } @lettuce;\n"},{"out":"1","code":"'<li><a href=\"' =~ /<li><a href=/\n","err":""},{"err":"","code":"'<li><a href=\"' =~ /<li><a href=/; [$1, $2, $3]\n","out":"[undef,undef,undef]"},{"err":"","code":"$likeb = qr/(?:(?<!\\S)(?!\\s)|(?<!\\s)(?!\\S))/; [ 'this, is..a test.' =~ s/$likeb/*/gr ] # should have been qr// (was typo)\n","out":"[\"*this,* *is..a* *test.*\"]"},{"code":"$likeb = qw/(?:(?<!\\S)(?=\\S)|(?<=\\S)(?!\\S))/; [ 'this, is..a test.' =~ s/$likeb/*/gr ]  # codydn\n","err":"","out":"[\"*this,* *is..a* *test.*\"]"},{"out":"like this","err":"","code":"'like this'\n"},{"out":"line","err":"","code":"line\n"},{"out":"1","err":"","code":"__LINE__\n"},{"out":"[\"line 2\\n\"]","code":"[ \"line 1\\nline 2\\n\\nline 4\" =~ /^.*\\s$/gm ]\n","err":""},{"err":"","code":"@lines = <{a,b,c}>; \\@lines\n","out":"[\"a\",\"b\",\"c\"]"},{"out":"[]","code":"@lines = <.*>; \\@lines\n","err":""},{"out":"[1]","code":"$line = \"\\thello\"; [ 0+ $line =~ /^\\t(.+)/ ]\n","err":""},{"out":"[\"hello\"]","code":"$line = \"\\thello\"; [ $line =~ /^\\t(.+)/ ]\n","err":""},{"code":"$list{0}=\"zero\"; $list{1}=\"one\"; $list{2}=\"two\"; $list{3}=\"three\"; print scalar %list\n","err":"","out":"2/8"},{"err":"","code":"$list[0]=\"zero\"; $list[1]=\"one\"; $list[2]=\"two\"; print scalar @list\n","out":"3"},{"out":"2/8","code":"$list{0}=\"zero\"; $list{1}=\"one\"; $list{2}=\"two\"; print scalar %list\n","err":""},{"out":"3","err":"","code":"$list[1]=\"one\"; $list[2]=\"two\"; print scalar @list\n"},{"out":"3","code":"@list=('d', 'e', 'f', 'a', 'b', 'c'); $startindex=3; @list=@list[$startindex..$#list], @list[0..$startindex-1]; @list\n","err":""},{"out":"a b c d e f","err":"","code":"@list=('d', 'e', 'f', 'a', 'b', 'c'); $startindex=3; @list=(@list[$startindex..$#list], @list[0..$startindex-1]); $text = join ' ', @list; $text;\n"},{"code":"@list=('d', 'e', 'f', 'a', 'b', 'c'); $startindex=3; @list=@list[$startindex..$#list], @list[0..$startindex-1]; $text = join ' ', @list; $text;\n","err":"","out":"a b c"},{"out":"[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]","code":"@list = ('d' .. 'f', 'a' .. 'c'); splice @list, 0, 0, splice @list, 3; \\@list\n","err":""},{"out":"1","code":"List::MoreUtils::any { $_ eq 'a' } ('b', 'a')\n","err":""},{"code":"List::MoreUtils::any { $_ eq 'a' } ('b', 'c')\n","err":"","out":""},{"code":"List::MoreUtils::any {$_ eq 'a'}, 'b', 'c'\n","err":"","out":"c"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"} 'b'\"\n","err":"","code":"List::MoreUtils::any( {$_ eq 'a'} 'b', 'c' )\n"},{"out":"ERROR: Type of arg 1 to List::MoreUtils::any must be block or sub {} (not anonymous hash ({})) at (eval 1) line 1, near \"'c' )\n\"\n","err":"","code":"List::MoreUtils::any( {$_ eq 'a'}, 'b', 'c' )\n"},{"out":"[\"three\",\"four\"]","code":" @list = ({name => 1, x => one}, {name => 2, x => two}, {name => 3, x => three}, {name => 4, x => four}); [map {$_->{x}} grep { $_->{name} > 2 } @list]\n","err":""},{"out":"94","err":"","code":"@listof105 = (1..105); @listof11 = (1..11); @listof105 - @listof11\n"},{"err":"","code":"@list_of_indices = ('1','3'); @array[ @list_of_indices ] = (\"Z\") x @list_of_indices;  \\@array\n","out":"[undef,\"Z\",undef,\"Z\"]"},{"out":"[\"\"]","err":"","code":"@list = qw(a b c); $search=\"x\"; [ !! grep($_ eq $search,@list) ]\n"},{"code":"@list = qw(a b c); $search=\"x\"; [ !! grep($search,@list) ]\n","err":"","out":"[1]"},{"out":"{orange => {banana => undef},beef => {fish => undef},apple => {orange => undef,banana => undef}}","err":"","code":"@list = ([qw(apple banana)], [qw(apple orange)], [qw(orange banana)], [qw(beef fish)]); my %sets = (); for my $pair (@list) { my ($x, $y) = @$pair; $sets{$x}{$y} = undef; for my $el (keys %{delete($sets{$y}) // {}}) { $sets{$el} = $sets{$x}; $sets{$x}{$el} = undef } } \\%sets\n"},{"out":"{orange => {banana => undef},beef => {fish => undef},apple => {orange => undef,banana => undef}}","code":"@list = ([qw(apple banana)], [qw(apple orange)], [qw(orange banana)], [qw(beef fish)]); my %sets = (); for my $pair (@list) { my ($x, $y) = @$pair; $sets{$x}{$y} = undef; for my $el (keys %{$sets{$y} // {}}) { $sets{$el} = $sets{$x}; $sets{$x}{$el} = undef } } \\%sets\n","err":""},{"out":"[\"dog\",\"cat\",\"rabbit\",\"turtle\",\"mouse\",\"wolf\"]","err":"","code":"@list = qw(dog cat turtle mouse wolf); splice @list, 2, 0, \"rabbit\"; \\@list\n"},{"err":"","code":"[List::UtilsBy::sort_by( sub { $_ }, 31, 30, 30.1, 31.1)]\n","out":"[30,\"30.1\",31,\"31.1\"]"},{"code":"[List::UtilsBy::sort_by( sub { $_ }, 31, 30, 301, 311)]\n","err":"","out":"[30,301,31,311]"},{"code":"List::UtilsBy::sort_by( sub { $_ }, 31, 30, 301, 311)\n","err":"","out":"311"},{"err":"","code":"local $[ = 1;\n","out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 1) line 1, <STDIN> line 1.\n","code":"local $[ = -1; my @a = (1); $#a\n","err":""},{"out":"ERROR: Can't locate Getopt/Long.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"local @ARGV = qw(--linkadd y file_name_here.tgz); use Getopt::Long; GetOptions(\"linkadd=s\" => \\$linkadd); { linkadd => $linkadd, ARGV => \\@ARGV }\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n","err":"","code":"[ \"\\local_dir\\selected\"\n"},{"code":"[ \"\\local_dir\\selected\" ]\n","err":"","out":"[\"ocal_dirselected\"]"},{"out":"[\"\"]","err":"","code":"{ local $@; eval { die \"foo\" } } [$@]\n"},{"err":"","code":"{ local $@; eval { die \"foo\" } } $@\n","out":""},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n","code":"local *_ = \\\"hello\"; $_ = 42\n","err":""},{"err":"","code":"local $_ = \"my fancy filename.txt\";$count=0;s/(\\s*)(.)/upper($1,$2,$count++)/ge;print;sub upper { my ($s, $c, $n) = @_;return $s ? \"$s\\u$c\" : !$n ? \"\\u$c\" : $c; }\n","out":"My Fancy Filename.txt"},{"out":"My Fancy Filename.txt","code":"local $_ = \"my fancy filename.txt\";$count=0;s/(\\s*)(\\w+)/upper($1,$2,$count++)/ge;print;sub upper { my ($s, $c, $n) = @_;return $s ? \"$s\\u$c\" : !$n ? \"\\u$c\" : $c; }\n","err":""},{"out":"ERROR: Can't localize lexical variable $foo at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"local my $foo\n"},{"out":"1,2,3,4,5,6,7,8,9,10","err":"","code":"local $, = ','; print 1..10\n"},{"code":"$^LOCALTIME\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"$^LOCALTIME\n\"\n"},{"out":"UTF-32","err":"","code":"local $_ = \"UCS-4\"; eval q@qr/^UCS-?4-?(BE|LE)?$/i; uc(\"UTF-32$1\")@\n"},{"out":" local notlocal","err":"","code":"local $var = 'local'; print \" $var \"; { $var = 'notlocal'; print $var };\n"},{"code":"local $var = 'local'; { $var = 'notlocal'; print $var }; print \" $var \"\n","err":"","out":"notlocal notlocal "},{"out":"64","err":"","code":"log(~0 +1)/log(2)\n"},{"err":"","code":"log(~0+1)/log(2)\n","out":"64"},{"code":"log(~0)/log(2)\n","err":"","out":"64"},{"code":"log(13500) / log(2)\n","err":"","out":"13.7206717868256"},{"code":"$= = log(16777213) / log(2); $= # yep perfectly safe\n","err":"","out":"23"},{"err":"","code":"log(2421392269093537440547188383164)/log(2)\n","out":"100.9336796636"},{"code":"[ log(2), log(10), log(exp(1)) ]\n","err":"","out":"[\"0.693147180559945\",\"2.30258509299405\",1]"},{"out":"1.58496250072116","code":"log(3) / log 2\n","err":""},{"out":"First is bigger","err":"","code":"((log(632382) * 518061 > log(519432) * 525806) ? \"First\" : \"Second\") . \" is bigger\"\n"},{"out":"5.97727992349992","code":"log(63) / log(2) # you might want to round to nearest integer if you do\n","err":""},{"out":"ERROR: Can't find string terminator \"LOG\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"$log_content .= <<LOG;\n","err":""},{"code":"[ log_file => 42, die => 9 ]\n","err":"","out":"[\"log_file\",42,\"die\",9]"},{"out":"LogÃÂ¯ÃÂ¿ÃÂ½ProcessingÃÂ¯ÃÂ¿ÃÂ½ServiceÃÂ¯ÃÂ¿ÃÂ½canÃÂ¯ÃÂ¿ÃÂ½receiveÃÂ¯ÃÂ¿ÃÂ½logÃÂ¯ÃÂ¿ÃÂ½messagesÃÂ¯ÃÂ¿ÃÂ½","code":"'Logï¿½Processingï¿½Serviceï¿½canï¿½receiveï¿½logï¿½messagesï¿½' =~ y/\\xA0/ /dr\n","err":""},{"code":"$_ = 'LOL' (\\&CORE::lc)->()\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"'LOL' (\"\n"},{"code":"$_ = 'LOL'; (\\&CORE::lc)->()\n","err":"","out":"lol"},{"out":"LoL","err":"","code":"$_=\"lol\"; tr alaLa; print;\n"},{"out":"I'm fucking rich, I got 0!","err":"","code":"$long_var_blah = 42;  $my_pay = $long_var_b1ah * 1000; print \"I'm fucking rich, I got $my_pay!\";\n"},{"code":"`ls`;\n","err":"","out":""},{"err":"","code":"[`ls`]\n","out":"[]"},{"code":"`ls -a`\n","err":"","out":""},{"code":"lvfjf is a fool!\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"err":"","code":"LWP::Simple::get www.google.com\n","out":"ERROR: Can't locate object method \"get\" via package \"LWP::Simple\" (perhaps you forgot to load \"LWP::Simple\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"[m#\n","err":"","out":"ERROR: Search pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"m?^?\n","err":"","out":"1"},{"code":"m/^+/\n","err":"","out":"1"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"; m/$#/\"\n","code":"m/$#/\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"0\\\"\nMissing right curly or square bracket at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, at EOF\n","err":"","code":"m0{0\\my}sub H;0;sub{sub{H\n"},{"err":"","code":"//magic\n","out":"1"},{"out":"1","err":"","code":"$main::_ == $_\n"},{"code":"main->can(\"can\")\n","err":"","out":"sub { \"DUMMY\" }"},{"code":"[ main->can( sub { 'dummy' } ) ]\n","err":"","out":"[undef]"},{"code":"main->can( sub { 'dummy' } )\n","err":"","out":""},{"out":"","code":"main::for () for ();\n","err":""},{"err":"","code":"*main::main::main::main::X{PACKAGE}\n","out":"main"},{"out":"bar\n","err":"","code":"@many = ( \"foo\", \"bar\" ); %{$href} = @many; print $href->{'foo'}.\"\\n\"\n"},{"out":"[1,0]","code":"[ map { 0+!$_} 0, 1 ]\n","err":""},{"out":"[-1,0,1]","code":"[ map { ($_ > 0) - ($_ < 0) } qw(-5 0 10) ]\n","err":""},{"out":"[[312,56],[326,-186]]","err":"","code":"[ map [$_->[0] + $_->[3] * 256, $_->[0] - ($_->[1] ^ $_->[2]) * 256], [0b0011_1000, 0, 0, 1], [0b0100_0110, 0, 1, 1] ]\n"},{"out":"3","code":"map { $_ =~ /(?:^|[^0-9])[0-9]{7}(?:$|[^0-9])/ ? \"+ \" : \"- \"} (\"1234567 \",\" 1234567\",\" 12345678 \")\n","err":""},{"err":"","code":"[ map { $_->[0] eq $_->[1] } [ split //, \"AB\" ], [ split //, \"A4\" ]]\n","out":"[\"\",\"\"]"},{"err":"","code":"[ map { 0+!$_ } qw(0 1) ]\n","out":"[1,0]"},{"err":"","code":"[ map 0+sprintf('%.3f', $_), 0.7, 0.33333 ]\n","out":"[\"0.7\",\"0.333\"]"},{"err":"","code":"[ map 0+sprintf('%.3f', $_), 7, 0.33333 ]\n","out":"[7,\"0.333\"]"},{"code":"[ map { $_->[0] xor $_->[1] } [ split //, \"AB\" ], [ split //, \"A4 ]\n","err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"[ map { $_->[0] xor $_->[1] } [ split //, \"AB\" ], [ split //, \"A4 ]]\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"\",\"\"]","err":"","code":"[ map { $_->[0] xor $_->[1] } [ split //, \"AB\" ], [ split //, \"A4\" ]]\n"},{"err":"","code":"[ map 1 ]\n","out":"[]"},{"err":"","code":"[ map $_/10, 0..10 ]\n","out":"[0,\"0.1\",\"0.2\",\"0.3\",\"0.4\",\"0.5\",\"0.6\",\"0.7\",\"0.8\",\"0.9\",1]"},{"out":"10","err":"","code":"map { $_*10 } 1..10\n"},{"out":"[\"0 j\",\"1 a\",\"2 p\",\"3 h\"]","code":"[ map{($.||1..$.&&0)-1 .\" $_\"}split(//,japh) ]\n","err":""},{"out":"[0,0,0,2,0,4,4,6,0,8,8,10,8,12,12,14,0,16,16,18,16,20,20,22,16,24,24,26,24,28,28,30,0]","err":"","code":"[map { $_ & ($_-1) } 0 .. 32]\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"1 1\"\n","err":"","code":"[map 1 1]\n"},{"code":"[map 1, 1]\n","err":"","out":"[1]"},{"out":"[0,1,0,1,0,1,0,1,0,1]","code":"[ map --$|, 1..10 ] # ++ and -- in perl don't have to make sense, they just do useful stuff\n","err":""},{"code":"[map { 1 << $_ } (1 .. 10)]\n","err":"","out":"[2,4,8,16,32,64,128,256,512,1024]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"} 1\"\n","code":"map { \"$_\" => 1 } 1,2,3\n","err":""},{"code":"map { $_ => 1 } 1,2,3\n","err":"","out":"6"},{"out":"6","err":"","code":"map {; \"$_\" => 1 } 1,2,3\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"; $_ \"\n","code":"[map +{; $_ => $_ }, 1 .. 3]\n","err":""},{"err":"","code":"[map +{ $_ => $_ }, 1 .. 3] # need + and , for that\n","out":"[{1 => 1},{2 => 2},{3 => 3}]"},{"code":"[ map --$|, 1..5 ]\n","err":"","out":"[0,1,0,1,0]"},{"out":"[1,0,1,0,1]","code":"[ map $|--, 1 .. 5 ]\n","err":""},{"err":"","code":"[map {/.*\\.(.*)$/;$1} \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n","out":"[\"jpg\",\"pdf\",\"\",\"vimrc\",\"pl\",undef]"},{"out":"[\"\",\"\",\"\",\"\",\"\",\"\"]","code":"[map {/.*\\.*(.*)$/;$1} \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n","err":""},{"out":"4","err":"","code":"map \"$_\" => 1, qw(a b c);\n"},{"out":"c","err":"","code":"map (\"$_\" => 1), qw(a b c);\n"},{"out":"6","err":"","code":"map +(\"$_\" => 1), qw/a b c/\n"},{"err":"","code":"map { \"$_\" => 1 } qw/foo bar baz/\n","out":"ERROR: syntax error at (eval 1) line 1, near \"} qw/foo bar baz/\"\n"},{"code":"map { $_ => 1 } qw/foo bar baz/\n","err":"","out":"6"},{"err":"","code":"[ map (1x$_) =~ /^1?$|^(11+?)\\1+$/, '1000000000000066600000000000001' ]\n","out":"[\"1000000000000066600000000000001\"]"},{"out":"10","err":"","code":"map { $_* 2 } 1..10\n"},{"code":"[ map { $_ % 2 ? \"<$_>\" : () } 2, 3, 4, 5, 6, 7 ]\n","err":"","out":"[\"<3>\",\"<5>\",\"<7>\"]"},{"err":"","code":"[ map { $_ ** 2 } grep { $_ % 2 } (2, 4, 6, 8) ]\n","out":"[]"},{"err":"","code":"[ map { 2 ** $i++ if $_ } reverse split //, sprintf \"%b\", 20]\n","out":"[0,0,1,0,2]"},{"out":"[1,2]","code":"[ map { $_ ? 2 ** $i++ : ()  } reverse split //, sprintf \"%b\", 20]\n","err":""},{"out":"[1,2,4,8,16]","err":"","code":"[ map { 2 ** $i++ } reverse split //, sprintf \"%b\", 20]\n"},{"err":"","code":"[ map { 2 ** $i++ * $_ } reverse split //, sprintf \"%b\", 20]\n","out":"[0,0,4,0,16]"},{"out":"3","code":"map{@$_ == 3} \\@arr1, \\@arr2, \\@arr3\n","err":""},{"out":"[40,41,42,43,44,45,46,47,32,33,34,35,36,37,38,39,24,25,26,27,28,29,30,31,16,17,18,19,20,21,22,23,8,9,10,11,12,13,14,15,0]","err":"","code":"[ map { 47 - ($_ ^ 7) } 0..40 ]\n"},{"out":"[-1,-1,-1,-1,0,1,1,1,1,1]","err":"","code":"[ map { $_ <=> 5 } 1 .. 10 ]\n"},{"code":"[ map { $_ / 5 } (1..10) ]\n","err":"","out":"[\"0.2\",\"0.4\",\"0.6\",\"0.8\",1,\"1.2\",\"1.4\",\"1.6\",\"1.8\",2]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"},\"\n","err":"","code":"[ map { $_ / 5 }, (1..10) ]\n"},{"out":"[40,41,42,43,44,45,46,47,32,33,34,35,36,37,38,39,24,25,26,27,28,29,30,31,16,17,18,19,20,21,22,23,8,9,10,11,12,13,14,15,0]","err":"","code":"[ map { $_ % 8 + 40 - ($_ & ~7) } 0..40 ]  # shorter :)\n"},{"out":"[40,41,42,43,44,45,46,47,32,33,34,35,36,37,38,39,24,25,26,27,28,29,30,31,16,17,18,19,20,21,22,23,8,9,10,11,12,13,14,15,0]","err":"","code":"[ map { $_ % 8 + 40 - (int($_ / 8) * 8) } 0..40 ]\n"},{"out":"[undef]","err":"","code":"[ map { $_->{a} } @{[ undef ]} ]\n"},{"out":"[[],[\"\"],[\"a\",\"b\"],[\"a\",\"b\"],[\"\",\"\"],[\"\",\"b\"]]","err":"","code":"[ map [/(?!\\A\\z)^.*/mg], \"\", \"\\n\", \"a\\nb\\n\", \"a\\nb\", \"\\n\\n\", \"\\nb\\n\" ]\n"},{"code":"[ map { ~~/\\b([A-Z]\\.){2,}\\b/ } qw(A.A. B.B.B.B.B.B.B.B. C.C.C.C A.M) ]\n","err":"","out":"[0,1,1,0]"},{"out":"[\"LATIN SMALL LETTER A WITH CIRCUMFLEX\",\"LATIN SMALL LETTER A WITH CIRCUMFLEX\",\"LATIN SMALL LETTER A WITH CIRCUMFLEX\"]","err":"","code":"[ map charnames::viacode(ord($_)), qw(â â â) ]\n"},{"out":"[\"LATIN SMALL LETTER A WITH CIRCUMFLEX\",\"LATIN SMALL LETTER A WITH CIRCUMFLEX\",\"LATIN SMALL LETTER A WITH CIRCUMFLEX\"]","err":"","code":"[ map charnames::viacode(ord), qw(â â â) ]\n"},{"err":"","code":"[ map{chomp} (\"foo\\n\",\"bar\\n\") ]\n","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"I H A T E P E O P L E","err":"","code":"\"@{[ map chr $_ + 64, qw/9 8 1 20 5 16 5 15 16 12 5/]}\"\n"},{"code":"\"@{[ map chr $_ + 65, qw/9 8 1 20 5 16 5 15 16 12 5/]}\"\n","err":"","out":"J I B U F Q F P Q M F"},{"code":"[ map chr hex, \"302e3f313133\" =~ /../g ] # if you don't want the extra validation\n","err":"","out":"[0,\".\",\"?\",1,1,3]"},{"code":"[ map chr(hex($_)), sprintf('%08x', 1383403352) =~ /../g ]\n","err":"","out":"[\"R\",\"u\",\"\\17\",\"X\"]"},{"code":"\"@{[ map chr, qw/9 8 1 20 5 16 5 15 16 12 5/]}\"\n","err":"","out":"\t \b \u0001 \u0014 \u0005 \u0010 \u0005 \u000f \u0010 \f \u0005"},{"out":"[1,1,\"\"]","err":"","code":"[ map { $_ || defined $_ } (0, 1, undef) ]\n"},{"out":"[1,1,\"\",1]","err":"","code":"[ map defined, 1, '', undef, 42 ]\n"},{"code":"[ map { \"descri$_\" } \"bing\", map { \"pti$_\" } \"on\", \"ve\" ]\n","err":"","out":"[\"describing\",\"description\",\"descriptive\"]"},{"code":"[ map { /[^\\d-]/ ? $_ : tr/-/ /r } '1990-1992-1993-2010', \"this-is-a-string-with-9-something-3ls3\" ]\n","err":"","out":"[\"1990 1992 1993 2010\",\"this-is-a-string-with-9-something-3ls3\"]"},{"code":"[ map { \"duck\" =~ m/$_/ ? $_ : \"no\" } qw/du uc ck/ ]\n","err":"","out":"[\"du\",\"uc\",\"ck\"]"},{"out":"[\"foo\",\"a\",\"foo\",\"b\",\"foo\",\"c\"]","err":"","code":"[ map { ; foo => $_ } 'a'..'c' ]\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"} 'a'\"\n","err":"","code":"[ map +{ foo => $_ } 'a'..'c' ]\n"},{"err":"","code":"[ map +{ foo => $_ }, 'a'..'c' ]\n","out":"[{foo => \"a\"},{foo => \"b\"},{foo => \"c\"}]"},{"code":"[ map { foo => $_ } 'a'..'c' ]; # which of the above two should this be?\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"} 'a'\"\n"},{"err":"","code":"[ map {; /^(?!(foobar){2}$)(?:\\1)*/ ? 1 : 0 } \"\", \"foobar\", \"foobarfoobar\", \"foobarfoobarfoobar\" ]\n","out":"[1,1,0,1]"},{"out":"[[\"bar\",123],[undef,123],[]]","code":"[ map [ /foo (bar)? (\\d+)/ ], 'foo bar 123', 'foo  123', 'no match' ]\n","err":""},{"out":"[\"\",1]","code":"[ map !!/(?<!^)foo/, \"foo\", \"barfoo\" ]\n","err":""},{"out":"[\"\",1]","err":"","code":"[ map !!/(?!^)foo/, \"foo\", \"barfoo\" ]\n"},{"out":"[1]","err":"","code":"[ map /(?!^)foo/, \"foo\", \"barfoo\" ]\n"},{"out":"[\"\",\"\",\"\",\"\"]","err":"","code":"[ map {; for (()){} } qw(A B C D) ]\n"},{"err":"","code":"[ map { $i++; $_ ? 2 ** ($i - 1) : ()  } reverse split //, sprintf \"%b\", 20]\n","out":"[4,16]"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","err":"","code":"[ map { if ($_ % 2) { \"<$_>\" } else { say \"hey!\"; () }; } (1..10); ]\n"},{"code":"[ map {; if ($_ ne 'A') { 0 } } qw(A B C D) ]\n","err":"","out":"[\"\",0,0,0]"},{"out":"[0,0,0,0,1,1,1,1,1,2]","code":"[ map { int($_ / 5) } (1..10) ]\n","err":""},{"err":"","code":"[ map { $i++ } qw/foo bar baz/ ]\n","out":"[0,1,2]"},{"code":"[  map { +{ ITEM => $_ } } qw( bla hi hue )  ]\n","err":"","out":"[{ITEM => \"bla\"},{ITEM => \"hi\"},{ITEM => \"hue\"}]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"} qw( bla hi hue )\"\n","err":"","code":"[  map { ITEM => $_ } qw( bla hi hue )  ]\n"},{"out":"[{ITEM => \"bla\"},{ITEM => \"hi\"},{ITEM => \"hue\"}]","code":"[  map { ITEM => $_ }, qw( bla hi hue )  ]\n","err":""},{"out":"[{ITEM => \"bla\"},{ITEM => \"hi\"},{ITEM => \"hue\"}]","err":"","code":"[  map { +{ ITEM => $_ } } qw( bla hi hue )  ]  # see\n"},{"code":"%map{key}\n","err":"","out":""},{"out":"[\"\",1]","err":"","code":"[ map !!/.\\Kfoo/, \"foo\", \"barfoo\" ]\n"},{"code":"[map { $_; last } (1,2,3)]\n","err":"","out":""},{"code":"[map length, q{$\"=\"\";@x=([],{},\" \",sub{},\\\"\");map{s/..(..).*/$1/}@x;\"@x\"}, q{print/..(..?)/ for[],{},$\"x3,\\&f,\\0}]\n","err":"","out":"[57,35]"},{"err":"","code":"[ map m?^?, 1 .. 4 ]\n","out":"[1]"},{"code":"[ map [ m{\\A (.*?) - ( \\d+ (?: \\. \\d+ )* (?: -r \\d+ )? ) \\z}xa ], qw(cryptsetup-1.1.3-r3 cronbase-0.3.3 automake-wrapper-3-r1 gcc-4.5.3-r1) ]\n","err":"","out":"[[\"cryptsetup\",\"1.1.3-r3\"],[\"cronbase\",\"0.3.3\"],[\"automake-wrapper\",\"3-r1\"],[\"gcc\",\"4.5.3-r1\"]]"},{"out":"[[\"cryptsetup\",\"1.1.3-r3\"],[],[\"automake-wrapper\",\"3-r1\"],[\"gcc\",\"4.5.3-r1\"]]","code":"[ map [ m{\\A (.*?) - ( \\d+ (?: \\. \\d+ )* (?: -r \\d+ )? ) \\z}xa ], qw(cryptsetup-1.1.3-r3 cronbase-0.3.3. automake-wrapper-3-r1 gcc-4.5.3-r1) ]\n","err":""},{"err":"","code":"[ map { m/^(\\d+)-(\\d+)$/ ? ( $1 .. $2 ) : ( $_ ) } split m/,/, \"1-3,5,6-9\" ]\n","out":"[1,2,3,5,6,7,8,9]"},{"out":"[[\"\"],[\"\"],[\"a\",\"b\"],[\"a\",\"b\"],[\"\",\"\"],[\"\",\"b\"]]","err":"","code":"[ map [/^.*/mg], \"\", \"\\n\", \"a\\nb\\n\", \"a\\nb\", \"\\n\\n\", \"\\nb\\n\" ]\n"},{"err":"","code":"[ map { my ( $a, $b ) = split /:/; { $a => $b } } qw( a:123 b:456 ) ];\n","out":"[\"a\",123,\"b\",456]"},{"out":"[{a => 123},{b => 456}]","err":"","code":"[ map { my ( $a, $b ) = split /:/; +{ $a => $b } } qw( a:123 b:456 ) ];\n"},{"out":"[1,2,3,4,5,6,7,8,9,10]","code":"[ map { my $foo if 0; ++$foo } 1 .. 10 ]\n","err":""},{"code":"[ map { my $foo if 0; ++$foo } 5 .. 10 ]\n","err":"","out":"[1,2,3,4,5,6]"},{"code":"[ map { my $line = $_; $line =~ s/\\n+$//; $line } (\"asdf\",\"asdf\\n\") ]\n","err":"","out":"[\"asdf\",\"asdf\"]"},{"out":"[\"asdf\\n\",\"asdf\\n\"]","err":"","code":"[ map { my $line = $_; $line =~ s/\\n*$/\\n/; $line } (\"asdf\",\"asdf\\n\") ]\n"},{"err":"","code":"[map { $_; next } (1,2,3)]\n","out":""},{"out":"[[\"\"],[\"\\n\"],[\"a\\n\",\"b\\n\"],[\"a\\n\",\"b\"],[\"\\n\",\"\\n\"],[\"\\n\",\"b\\n\"]]","code":"[ map [/^.*\\n?/mg], \"\", \"\\n\", \"a\\nb\\n\", \"a\\nb\", \"\\n\\n\", \"\\nb\\n\" ]\n","err":""},{"err":"","code":"map {; no strict qw(refs); $_; } 1..3\n","out":"3"},{"out":"[1,5,21,85,341,1365,5461,21845,87381,349525]","code":"[ map oct '0b1' . '01' x $_, 0 .. 9 ]\n","err":""},{"code":"[ map oct '0b1' . '01' x $_, 1 .. 10 ]\n","err":"","out":"[5,21,85,341,1365,5461,21845,87381,349525,1398101]"},{"out":"[9,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8239,8287,12288]","err":"","code":"[ map ord, grep /\\h/, map chr, (0..0x3000) ]\n"},{"out":"[226,226,226]","err":"","code":"[ map ord, qw(â â â) ]\n"},{"err":"","code":"[map ord, qw(L E O V)]\n","out":"[76,69,79,86]"},{"code":"[ map { ord } split //, 0.18446744073709551615.0 ]\n","err":"","out":"[0,'18446744073709551615',0]"},{"out":"[0,0,0]","code":"[ map { ord } split //, 0.18446744073709551616.0 ]\n","err":""},{"code":"[ map ord, split //, 64.64.64.5000000000.64.64.64 ]\n","err":"","out":"[64,64,64,5000000000,64,64,64]"},{"out":"[97,115,99,105,105]","code":"[ map ord, split //, \"ascii\" ]\n","err":""},{"err":"","code":"[map { ord } split //, fuckit\n","out":"ERROR: syntax error at (eval 1) line 1, at EOF\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n"},{"out":"[\"0.8\",\"0.85\",\"0.85\",\"0.85\",\"0.85\",\"0.85\"]","code":"[ map {POSIX::ceil($_*20)/20} (0.80, 0.81, 0.82, 0.83, 0.84, 0.85) ]\n","err":""},{"code":"map print, [1,2,3]->@*  # or maybe a -, a >, an @ and an *\n","err":"","out":"123"},{"err":"","code":"[ map { !$_ } qw(0 1) ]\n","out":"[1,\"\"]"},{"code":"[ map ref, \\1, [], {}, sub{}, qr//, \\(substr($_,1)),  ]\n","err":"","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"LVALUE\"]"},{"code":"[ map {  $_  || ref && ( eval q{@$_} || eval q{%$_} ) ? 1 : 0  } [], [5], {}, {A=>6}, 0, 123, q{}, q{abc} ]; # I added the input to the map, but everything else is verbatium.\n","err":"","out":"[1,1,1,1,0,1,0,1]"},{"err":"","code":"[ map s/[0-9]\\K-(?=[A-Z])//r, qw(4-A 4-a 4-4 9-X)]\n","out":"[\"4A\",\"4-a\",\"4-4\",\"9X\"]"},{"out":"[\"fff\",\"doesn't match\",\"kasdfk\"]","err":"","code":"[ map { /!(.+?)\\s/ ? $1 : \"doesn't match\" } \"!fff askd\", \"!dja\", \"!kasdfk \" ]\n"},{"code":"[ map scalar m?^?, 1 .. 4 ]\n","err":"","out":"[1,\"\",\"\",\"\"]"},{"out":"[5,\"abc\"]","code":"[ map /^scaleaddr(\\d)=([^\\d]*)/gi, qw(blahj blah blah ScaleAddr5=abc) ];\n","err":""},{"out":"[5,\"abc\"]","code":"[ map /^scaleaddr(\\d)=([^\\d]*)/gi, qw(blahj blah blah ScaleAddr5=abc foo bar) ];\n","err":""},{"out":"[\"0.7\",\"0.333\",\"-0.800\"]","err":"","code":"[ map s!\\.\\d{3}\\K(\\d+)!!r, 0.7, 0.33333, -0.800000000000001 ]\n"},{"err":"","code":"[ map s!\\.\\d{3}\\K(\\d+)!!r, 0.7, 0.33333, -0.800900000000001 ] #he probably wants the last one to be -0.801 in this case?\n","out":"[\"0.7\",\"0.333\",\"-0.800\"]"},{"out":"[[\"a\",\"b\"],[\"c\",\"d\",\"e\",\"f\"],[\"g\",\"h\"]]","code":"[ map [ split /,/ ], split /,,/, 'a,b,,c,d,e,f,,g,h' ]\n","err":""},{"out":"[[\"foo\",\"bar\",\"baz\"],[\"foo\"]]","err":"","code":"[ map [split /,/], split ' ', \"foo,bar,baz foo\" ]\n"},{"code":"[map {[sprintf \"%010B %010B\", $_, $_-1]} grep {$_ && !($_ & ($_-1)) } 0 .. 1024]\n","err":"","out":"[[\"0000000001 0000000000\"],[\"0000000010 0000000001\"],[\"0000000100 0000000011\"],[\"0000001000 0000000111\"],[\"0000010000 0000001111\"],[\"0000100000 0000011111\"],[\"0001000000 0000111111\"],[\"0010000000 0001111111\"],[\"0100000000 0011111111\"],[\"1000000000 0111111111\"],[\"10000000000 1111111111\"]]"},{"err":"","code":"[ map {sprintf \"%03b\"} 7, 6, 7&6 ]\n","out":"[\"000\",\"000\",\"000\"]"},{"code":"[ map {sprintf \"%04b\", $_} 10, 9, 10&9 ]\n","err":"","out":"[1010,1001,1000]"},{"out":"[\"0111\",\"0110\",\"0110\"]","code":"[ map {sprintf \"%04b\", $_} 7, 6, 7&6 ]\n","err":""},{"err":"","code":"[ map {sprintf \"%04b\"} 7, 6, 7&6 ]\n","out":"[\"0000\",\"0000\",\"0000\"]"},{"err":"","code":"[ map { sprintf \"%04x\", $_ } unpack \"n*\", \"\\x41\\x42\\x43\\x44\" ]\n","out":"[4142,4344]"},{"code":"[map { sprintf '%.0f', $_ } -2.5, -1.5, -0.5, 0.5, 1.5, 2.5]\n","err":"","out":"[-2,-2,\"-0\",0,2,2]"},{"out":"[\"0.299999999999999988897770\",\"0.300000000000000044408921\"]","err":"","code":"[ map { sprintf \"%.24f\", $_ }   0.3,   0.1*3   ]\n"},{"code":"[ map { sprintf(\"%.2f\", $_) + 0 } 3.14159, 8.675309, 1.20, 3 ]\n","err":"","out":"[\"3.14\",\"8.68\",\"1.2\",3]"},{"out":"[0,1,1,2,1,2,2,0]","code":"[ map { (sprintf(\"%b\", $_) =~ tr/1/1/) % 3 } qw(0 1 2 3 4 5 6 7) ]\n","err":""},{"err":"","code":"[map { sprintf '%d', $_ } -2.5, -1.5, -0.5, 0.5, 1.5, 2.5]\n","out":"[-2,-1,0,0,1,2]"},{"code":"[ map sprintf('%.f', $_), 6.5, 7.5, 8.5, 9.5 ]\n","err":"","out":"[6,8,8,10]"},{"err":"","code":"[ map { sprintf '%.*f', length('9999999999999911'), \"0.99999999999999$_\" } '00' .. '10' ]\n","out":"[\"0.9999999999999900\",\"0.9999999999999900\",\"0.9999999999999902\",\"0.9999999999999905\",\"0.9999999999999905\",\"0.9999999999999905\",\"0.9999999999999906\",\"0.9999999999999908\",\"0.9999999999999908\",\"0.9999999999999908\",\"0.9999999999999910\"]"},{"out":"[-2,-1,0,0,1,2]","err":"","code":"[map { sprintf '%i', $_ } -2.5, -1.5, -0.5, 0.5, 1.5, 2.5]\n"},{"err":"","code":"[ map { sprintf q{%03.2f}, $_; } 2, 64, 100 ];\n","out":"[\"2.00\",\"64.00\",\"100.00\"]"},{"err":"","code":"[ map { sprintf q{%3.2f}, $_; } 2, 64, 100 ];\n","out":"[\"2.00\",\"64.00\",\"100.00\"]"},{"err":"","code":"[ map { sprintf q{%3i}, $_; } 2, 64, 100 ];\n","out":"[\"  2\",\" 64\",100]"},{"err":"","code":"[ map { sprintf \"%vd\", $_ }  'abcd' & '11111111' ]\n","out":"[\"33.32.33.32\"]"},{"code":"[ map { sprintf \"%vd\", $_ }  'abcdefgh', '11111111', 'abcdefgh' & '1111' ]\n","err":"","out":"[\"97.98.99.100.101.102.103.104\",\"49.49.49.49.49.49.49.49\",\"33.32.33.32\"]"},{"out":"[\"97.98.99.100.101.102.103.104\",\"49.49.49.49.49.49.49.49\",\"33.32.33.32.33.32.33.32\"]","code":"[ map { sprintf \"%vd\", $_ }  'abcdefgh', '11111111', 'abcdefgh' & '11111111' ]\n","err":""},{"out":"[198,\"195.134\"]","err":"","code":"[ map sprintf(\"%vd\", $_), \"\\xc6\", Encode::encode_utf8(\"\\xc6\") ]\n"},{"err":"","code":"[ map sprintf(\"%vx\", $_), \"\\xc6\", Encode::encode_utf8(\"\\xc6\") ]\n","out":"[\"c6\",\"c3.86\"]"},{"out":"[\"two\",\"four\"]","err":"","code":"[ map /@(\\S+)/, qw( one@two three@four ) ]\n"},{"out":"[\"two\",\"four\"]","err":"","code":"[ map /\\@(\\S+)/, qw( one@two three@four ) ]\n"},{"out":"[\"bar.org\",\"bar.org\"]","code":"[ map s/.*\\@//r, qw( foo@bar.org bar.org ) ] # not sure what exactly is wanted...\n","err":""},{"out":"[\"Just another Perl hacker,\"]","err":"","code":"[map tr/a-z/oh, turtleneck Phrase Jar! What the f**k?/r, wftedskaebjgdpjgidbsmnjgc => ]\n"},{"err":"","code":"[map { ucfirst $_ } split(/a/, \"abacus\")]\n","out":"[\"\",\"B\",\"Cus\"]"},{"code":"[ map $_ // 'undef', 1, '', undef, 42 ]\n","err":"","out":"[1,\"\",\"undef\",42]"},{"err":"","code":"[ map unpack(\"H*\", $_), \"like this\" =~ /\\A(.)(.*)(.)\\z/s ]\n","out":"[\"6c\",\"696b6520746869\",73]"},{"code":"[ map \"\\u${ \\ qw(no one two three)[$_] } blind ${ \\ qw(mouse mice)[$_ > 1] }\", 0 .. 3]\n","err":"","out":"[\"No blind mouse\",\"One blind mouse\",\"Two blind mice\",\"Three blind mice\"]"},{"err":"","code":"map { $_->{val} } undef\n","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[1,2,2,3,3,3,4,4,4,4]","err":"","code":"[ map { ($_) x $_ } 0 .. 4 ]\n"},{"out":"[1,2,3,4,5,6,7,8,9,10]","err":"","code":"[ map { ++$x } 1..10 ]\n"},{"out":"[1,2,3,4,5,6,7,8,9,10]","err":"","code":"[ map ++$x, 1..10 ]\n"},{"out":"10","err":"","code":"map { ++$x } 1..10\n"},{"out":"[\"ZZ\",\"oo\",\"ff\",\"ff\",\"ii\",\"xx\",\"  \",\"dd\",\"oo\",\"uu\",\"bb\",\"tt\",\"ss\",\"  \",\"tt\",\"hh\",\"aa\",\"tt\",\"  \",\"mm\",\"aa\",\"pp\",\"  \",\"ee\",\"xx\",\"aa\",\"mm\",\"pp\",\"ll\",\"ee\",\"  \",\"ww\",\"oo\",\"rr\",\"kk\",\"ss\"]","err":"","code":"[ map $_ x 2, split //, \"Zoffix doubts that map example works\" ]\n"},{"out":"[{x => 3}]","code":"[ map {; +{ x => 3 } } 0 ] # with luck, those people will soon be promoted to the point where they no longer commit code\n","err":""},{"code":"[map { ($_) x 3 } (1 .. 3)]\n","err":"","out":"[1,1,1,2,2,2,3,3,3]"},{"code":"map({(((~($_ & (' ' x length($_)))) ^ (' ' x length($_))) & 'butt');} 'cloud', 'CLoud', 'CLOUD', 'ClOuD');\n","err":"","out":"4"},{"code":"[ map { (~($_ & ' ' x length) ^ ' ' x length) & lc 'butt'  } qw(cloud CLoud CLOUD ClOuD) ]\n","err":"","out":"[\"butt\",\"BUtt\",\"BUTT\",\"BuTt\"]"},{"code":"map { (~($_ & ' ' x length) ^ ' ' x length) & lc 'butt'  } qw(cloud CLoud CLOUD ClOuD)\n","err":"","out":"4"},{"code":"[ map { $_ x= !m!\\d+!; } @dummy = qw/ABC 123 DEF/ ]\n","err":"","out":"[\"ABC\",\"\",\"DEF\"]"},{"err":"","code":"[ map { $_ x= !m!\\d+!; } map $_, qw/ABC 123 DEF/ ];\n","out":"[\"ABC\",\"\",\"DEF\"]"},{"code":"[ map { $_ x= !m!\\d+!; } qw/ABC 123 DEF/ ];\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"ABC\",\"\",\"DEF\"]","err":"","code":"[ map { $_ x !m!\\d+!; } qw/ABC 123 DEF/ ]\n"},{"code":"[ map { \"xxx.$_\" } qw/1 2 3/ ]\n","err":"","out":"[\"xxx.1\",\"xxx.2\",\"xxx.3\"]"},{"err":"","code":"$mask='11000000'; print $mask >> 1;\n","out":"5500000"},{"out":"96","err":"","code":"$mask=192, print ( $mask >> 1 );\n"},{"out":"224","err":"","code":"$mask=192, print ( ($mask >> 1) + 128 );\n"},{"out":"224","code":"$mask=192; print ( ($mask >> 1) + 128 );\n","err":""},{"out":"240","code":"$mask=192, print ( ($mask >> 2) + 192 );\n","err":""},{"out":"248","err":"","code":"$mask=192, print ( ($mask >> 3) + 224 );\n"},{"err":"","code":"$mate=4; \"hello$mate\"\n","out":"hello4"},{"err":"","code":"\"maybe this is an eval bot, but perhaps it's a cake\"\n","out":"maybe this is an eval bot, but perhaps it's a cake"},{"code":"''.methods.length\n","err":"","out":"methods"},{"err":"","code":"'@microsoft.com' =~ /microsoft.com$/ ? \"matches\" : \"does not\"\n","out":"matches"},{"code":"\"@microsoft.com\" =~ /microsoft.com$/ ? \"matches\" : \"does not\"\n","err":"","out":"does not"},{"out":"Might Even Work With Hyphen-Separated Words","err":"","code":"\"Might even work with hyphen-separated words\" =~ s/\\b(\\w)/\\U$1/gr\n"},{"err":"","code":"might work better?\n","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"err":"","code":"MIME::Entity->build\n","out":"ERROR: Can't locate object method \"build\" via package \"MIME::Entity\" (perhaps you forgot to load \"MIME::Entity\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"7","err":"","code":"$min = 5; $max = 7; @x = (($min - 2) .. ($max + 2));\n"},{"code":"$min = 5; $max = 7; @x = (($min - 2)..($max + 2));\n","err":"","out":"7"},{"code":"$min = 5; $max = 7; @x = (($min - 2)..($max + 2)); \\@x\n","err":"","out":"[3,4,5,6,7,8,9]"},{"code":"$min = 5; $max = 7; @x = (($min - 2)..($max + 2)); x[0] x[2];\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"x[\"\n"},{"code":"$min = 5; $max = 7; @x = range((($min - 2) .. ($max + 2)));\n","err":"","out":"ERROR: Undefined subroutine &main::range called at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"$min = 5; $max = 7; @x = range(($min - 2)..($max + 2));\n","out":"ERROR: Undefined subroutine &main::range called at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"missingsub(); # yes it does\n","out":"ERROR: Undefined subroutine &main::missingsub called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Permission denied at (eval 1) line 1, <STDIN> line 1.\n","code":"mkdir (\"womble\") or die $!\n","err":""},{"out":"[\"internet\",\"1nt3rn3t\",\"intern3t\"]","err":"","code":"%m=(); $m{$1}=\"[$1$2]\" while 'e3o0i1s5'=~/([a-z])([^a-z]+)/g; $pat = 'internet' =~ s/(.)/$m{$1}||$1/ger; [ grep /$pat/, qw( internet 1t3rn3t 1nt3rn3t intern3t ) ] # trist4n\n"},{"out":"1","code":"m//magic\n","err":""},{"out":"1","err":"","code":"'module blah blah foo bar biz baz ( ... );' =~ /^module.*\\);$/\n"},{"out":"ERROR: Can't locate object method \"get\" via package \"Mojo::UserAgent\" (perhaps you forgot to load \"Mojo::UserAgent\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"Mojo::UserAgent->get(\"https://de.wikipedia.org/wiki/F%C3%BCrst\")->res->dom->at('title')->text\n"},{"err":"","code":"Mojo::UserAgent->new->get(\"https://de.wikipedia.org/wiki/F%C3%BCrst\")->res->dom->at('title')->text\n","out":"ERROR: Can't locate object method \"new\" via package \"Mojo::UserAgent\" (perhaps you forgot to load \"Mojo::UserAgent\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"[\"Moo\"..2, \"Moo\". .2]\n","out":"[0,1,2,\"Moo0.2\"]"},{"out":"[\"moo\",\"mo\",\"oo \",\"oo\",\"o c\",\"o \",\" cl\",\" c\",\"clu\",\"cl\",\"luc\",\"lu\",\"uck\",\"uc\",\"ck\"]","err":"","code":"$_=\"moo cluck\"; m/(.{2,3})(?{ push @r, $1 })^/; \\@r\n"},{"out":"I'm not blind","err":"","code":"'morissett' eq 'morissette' ? \"I'm blind\" : \"I'm not blind\"\n"},{"out":"I'm not blind","code":"'morissett' =~ /morissette/ ? \"I'm blind\" : \"I'm not blind\"\n","err":""},{"err":"","code":"$ms=\".085\"; sprintf(\"%.03u\", $ms);\n","out":"000"},{"out":"000","err":"","code":"$ms=\".085\"; sprintf(\"%.3u\", $ms);\n"},{"out":".085","err":"","code":"$ms=85; sprintf(\".%.03u\", $ms);\n"},{"out":"085","err":"","code":"$ms=85; sprintf(\"%.03u\", $ms);\n"},{"out":"","err":"","code":"my (((())))\n"},{"code":"my ([])\n","err":"","out":"ERROR: Can't declare anonymous array ([]) in \"my\" at (eval 1) line 1, at EOF\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"my [\"\n","err":"","code":"my []\n"},{"err":"","code":"my $_\n","out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_\n\"\n"},{"out":"ERROR: Can't use global $0 in \"my\" at (eval 1) line 1, near \"my $0 \"\n","err":"","code":"my $0 = 1; print $0;\n"},{"out":"","err":"","code":"my (0 ? $x : $y);\n"},{"out":"ERROR: Can't use global $1 in \"my\" at (eval 1) line 1, near \"my $1\"\n","code":"{ my $1; }\n","err":""},{"err":"","code":"my $1;\n","out":"ERROR: Can't use global $1 in \"my\" at (eval 1) line 1, near \"my $1\"\n"},{"out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n","err":"","code":"my $_ = \"4-9\"; s/(\\d+)-(\\d+)/join \",\", $1..$2/e; $_\n"},{"code":"my $_ = \"4-9\"; s/(\\d+)-(\\d+)/join \",\", $1..$2/e; eval\n","err":"","out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n"},{"code":"my $_ = \"4-9\"; s/(\\d+)-(\\d+)/join \",\", $1..$2/e; [ eval ]\n","err":"","out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n"},{"err":"","code":"my @a = 0..9; my $p = \\@a; my @b = splice($p, -3); { a => \\@a, b => \\@b }  # u-ou\n","out":"ERROR: Experimental splice on scalar is now forbidden at (eval 1) line 1, near \"3)\"\n"},{"err":"","code":"my @a = 0..9; my $p = \\@a; my @b = splice($p, -3); print \"@a @b\\n\";\n","out":"ERROR: Experimental splice on scalar is now forbidden at (eval 1) line 1, near \"3)\"\n"},{"out":"ERROR: Experimental splice on scalar is now forbidden at (eval 1) line 1, near \"3)\"\n","code":"my @a = 0..9; my $p = \\@a; my @b = splice($p, -3); print \"@b @a\\n\";\n","err":""},{"out":"1","code":"my $a = 0; print unless defined($a);\n","err":""},{"err":"","code":"my @a = <{1..10}{11..20}>; \\@a\n","out":"[\"1..1011..20\"]"},{"err":"","code":"my @a = <{1..10}{11..20}>; [ scalar @a ]\n","out":"[1]"},{"out":"1.234.567.890\n","err":"","code":"my $a = 1234567890; my $b = reverse(join('.', (reverse $a) =~ /([0-9]{1,3})/g)); say $b\n"},{"err":"","code":"my @a = (1,2); [(a => @a)];\n","out":"[\"a\",1,2]"},{"err":"","code":"my @a=(1,2);(@a) x 2\n","out":"22"},{"out":"[{1 => 2,2 => 3},{4 => 5,3 => 4}]","code":"my @a = 1..4; my %h1 = map +( $_ => $_+1 ), splice @a, 0, @a/2; my %h2 = map +( $_ => $_+1 ), @a; [ \\%h1, \\%h2 ] # splice should already be removing the first set of elements, I think?\n","err":""},{"code":"my @a = 1..4; my %h1 = map +( $_ => $_+1 ), splice @a, 0, @a/2; my %h2 = map +( $_ => $_+1 ), splice @a, @a/2-1; [ \\%h1, \\%h2 ]\n","err":"","out":"[{1 => 2,2 => 3},{4 => 5,3 => 4}]"},{"out":"[\\1,\\2,bless( do{\\(my $o = 3)}, 'main' ),\\4,\\5]","code":"my @a = 1..5; bless \\$a[2], 'main'; [\\(@a)];\n","err":""},{"code":"my @a = 1..5; bless \\$a[2], 'main'; \\(@a);\n","err":"","out":"\\5"},{"code":"my @a = 1..5; bless \\$a[2], 'main'; \\@a;\n","err":"","out":"[1,2,3,4,5]"},{"err":"","code":"my @a = 1..5; bless \\$a[2], 'main'; [\\(@a[0..$#a])];\n","out":"[\\1,\\2,bless( do{\\(my $o = 3)}, 'main' ),\\4,\\5]"},{"out":"\\5","code":"my @a = 1..5; bless \\$a[2], 'main'; \\(@a[0..$#a]);\n","err":""},{"err":"","code":"my @a = 1..5; bless \\$a[2], 'main'; \\$a[2];\n","out":"bless( do{\\(my $o = 3)}, 'main' )"},{"out":"12345","err":"","code":"my @a = (1..5); for( ; $_ = shift @a; $x++ ) { print }\n"},{"out":"[[-1,1,2,3],[-1,0,1,2,3]]","err":"","code":"my @a = 1..5; [  [grep { $_-=2 } @a], \\@a ]\n"},{"out":"[1,2,42,4,5]","code":"my @a = 1..5; sub TIESCALAR { bless [] }; sub FETCH { 42 }; tie $a[2], 'main'; \\@a;\n","err":""},{"out":"[undef,undef,bless( [], 'main' ),undef,undef]","err":"","code":"my @a = 1..5; sub TIESCALAR { bless [] }; sub FETCH { 42 }; tie $a[2], 'main'; sub foo { map tied $_, @_ }; [foo @a];\n"},{"err":"","code":"my @a = (1..5); while( $_ = shift @a; $x++ ) { print }\n","out":"ERROR: syntax error at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, near \"++ ) \"\n"},{"out":"4","err":"","code":"my $a = 1; $a += 1, $a += 2; $a\n"},{"out":"<22>","code":"my $a = \"    22\";$a =~ s/^\\s+//; \"<$a>\"\n","err":""},{"err":"","code":"my $a = \"    22\";$a = s/^\\s+//; \"<$a>\"\n","out":"<>"},{"out":"ERROR: Substitution replacement not terminated at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my $a = \"    22\";$a = s/\\s+/g;print $a;\n"},{"code":"my $a = \"    22\";$a = s/\\s+\\/g;print $a;\n","err":"","out":"ERROR: Substitution pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"my $a = \"    22\";$a =~ s/^\\s+//;print $a;\n","out":"22"},{"out":"    22","code":"my $a = \"    22\";$a =~ s/\\s+$//;print $a;\n","err":""},{"code":"my $a = \"    22\";$a = s/^\\s+//;print $a;\n","err":"","out":"1"},{"code":"my @a = 2; OUTER: for( my $n = $a[-1] + 1; @a < 100; $n += 2 ) { $n % $_ or next OUTER for @a; push @a, $n; }; \\@a;\n","err":"","out":"[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541]"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, near \"2 ) \"\nsyntax error at (eval 1) line 1, near \"$n }\"\n","err":"","code":"my @a = 2; OUTER for( my $n = $a[-1] + 1; @a < 100; $n += 2 ) { $n % $_ or next OUTER for @p; push @a, $n } \\@a;\n"},{"code":"my @a = 2; OUTER for( my $n = $a[-1] + 1; @a < 100; $n += 2 ) { $n % $_ or next OUTER for @p; push @a, $n; }; \\@a;\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, near \"2 ) \"\nsyntax error at (eval 1) line 1, near \"; }\"\n"},{"code":"my @a = 2; OUTER: for( my $n = $a[-1] + 1; @a < 100; $n += 2 ) { $n % $_ or next OUTER for @p; push @a, $n; }; \\@a;\n","err":"","out":"[2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,95,97,99,101,103,105,107,109,111,113,115,117,119,121,123,125,127,129,131,133,135,137,139,141,143,145,147,149,151,153,155,157,159,161,163,165,167,169,171,173,175,177,179,181,183,185,187,189,191,193,195,197,199]"},{"out":"undef","code":"my $a = 5; 1 for $a; $_ // 'undef';\n","err":""},{"out":"5","code":"my $a = 5; print $        a;   # this one bothers me because \"$a\" feels like one token to me.\n","err":""},{"code":"my $a = \"95.50.218.84\\r80\"; $a =~ s/\\r/:/g; print $a;\n","err":"","out":"95.50.218.84:80"},{"code":"my @a; [+@a]\n","err":"","out":"[]"},{"out":"1","err":"","code":"my %a; $a {a} = 1; $a{a}\n"},{"code":"my $a = {a=>\"BLA\", b=>\"BLO\"}; print \"$k2:$v2\\n\" while((my($k2,$v2) = each %$a);\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"out":":\n:\n","err":"","code":"my $a = {a=>\"BLA\", b=>\"BLO\"}; print \"$k2:$v2\\n\" while(my($k2,$v2) = each %$a);\n"},{"err":"","code":"my @a = ( 'A'..'E' ); delete $a[0]; \\@a; # Delete doesn't remove the element.\n","out":"[undef,\"B\",\"C\",\"D\",\"E\"]"},{"err":"","code":"my $a=\"a\"; my $b=\"b\";my $ab=\"${a}_${b}\";print $ab;\n","out":"a_b"},{"out":"b","code":"my $a=\"a\"; my $b=\"b\";my $ab=\"$a_$b\";print $ab;\n","err":""},{"code":"my $a=\"asd1312321asd1212asd121212\"; print $1,\"\\n\" for $a=~/(asd\\d+)/g;\n","err":"","out":"asd121212\nasd121212\nasd121212\n"},{"out":"asd - qwe\nqwe - \n","code":"my @a=(\"asd qwe\", \"qwe \"); for (@a) {print \"$1 - $2\\n\" if /(\\w+)\\s+(\\w+)?/}\n","err":""},{"out":"[]","err":"","code":"my @a = 'a'..'z'; [ @a[ 2..1 ] ]; # This array slice is an empty list; that's a good thing.\n"},{"out":"[\"a\"]","code":"my @a = 'a'..'z'; [ $a[ 2..1 ] ]; # This is the scalar .. operator used as an array index, and is hardly every what one wants.\n","err":""},{"code":"my ($a, $b) = (5); $b = $_ for $a; $b++; $a;\n","err":"","out":"5"},{"code":"my @accounts = (1,2,3); return join(',', @accounts);\n","err":"","out":"1,2,3"},{"code":"my @a = (\"foo\\n\", \"bar\", \"baz\\n\"); [ chomp @a ]\n","err":"","out":"[2]"},{"out":"110","code":"my @a = glob(\"{1,2,3,4,5,6,7,8,9,10}{11,12,13,14,15,16,17,17,18,19,20}\")\n","err":""},{"out":" dldldl","err":"","code":"my $a = \"ldldldl\"; $a =~ s/l/ /;print $a\n"},{"code":"my $a = \"ldldldl\"; $a =~ s/l+/ /;print $a\n","err":"","out":" dldldl"},{"code":"my $a = \"ldldldl\"; $a =~ tr/l//d;print $a\n","err":"","out":"ddd"},{"out":"[1,2,4,5,6,7,8]","code":"my $all_list = [[1,2],[4,5,6],[7,8]]; [ map @$_, @$all_list ] # depends on whether there are nested arrayrefs\n","err":""},{"err":"","code":"my $allPlans = [ 4..7 ]; for my $paymentPlan (@$allPlans) { print \" plan: $paymentPlan  \" }\n","out":" plan: 4   plan: 5   plan: 6   plan: 7  "},{"err":"","code":"my ($animal) = \"banana\" =~ /(na)/; $animal\n","out":"na"},{"out":"\\n\n","code":"my$a=\"\\\\n\";printf $a.\"\\n\";\n","err":""},{"out":"1","code":"my $a = NULL; print unless defined($a);\n","err":""},{"out":"ERROR: Illegal division by zero at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my @a; print 5/@a\n"},{"code":"my $a = \" \"; print unless defined($a);\n","err":"","out":"1"},{"out":"1","err":"","code":"my $a = (); print unless defined($a);\n"},{"err":"","code":"my @a = qw(1 2 3); print @{*_{ARRAY}} for (\\$a);\n","out":"my @a = qw(1 2 3); print @{*_{ARRAY}} for (\\$a);"},{"err":"","code":"my @a = qw(fo,o ba,r b,az); @a = map [split /,/], @a; @a;\n","out":"3"},{"code":"my @a = qw(fo,o ba,r b,az); @a = map [split /,/], @a; \\@a;\n","err":"","out":"[[\"fo\",\"o\"],[\"ba\",\"r\"],[\"b\",\"az\"]]"},{"code":"my @ar1 = qw(1 2 3); my $x = \\@ar1; my @ar2 = @$x; pop @ar2; [ @ar1 ]\n","err":"","out":"[1,2,3]"},{"out":"[1,2]","err":"","code":"my @ar1 = qw(1 2 3); my $x = \\@ar1; pop @$x; [ @ar1 ]\n"},{"err":"","code":"my $ar = [aw{foo bar baz}]; push @$ar, 'biz', 'goo'; $ar\n","out":"ERROR: Can't locate object method \"foo\" via package \"bar\" (perhaps you forgot to load \"bar\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[5,6,7]","code":"my $aref = [1..10]; [@{ $aref } [4..6]]\n","err":""},{"code":"my %args = {domain => \"example.net\", number => 0 };\n","err":"","out":"1"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"my %args = {domain => \"example.net\", number => 0; };\n","err":""},{"code":"my %args = { number => 100 }; print $args{number};\n","err":"","out":"1"},{"err":"","code":"my %args{ number => 100 }; print $args{number};\n","out":"ERROR: syntax error at (eval 1) line 1, near \"%args{ \"\n"},{"code":"my @args = ('%s %s', 'asdf', 'fdsa'); sprintf @args\n","err":"","out":"3"},{"code":"my @ar;  push @ar, { key => \"value\" }, { key2 => \"value2\" };  \\@ar\n","err":"","out":"[{key => \"value\"},{key2 => \"value2\"}]"},{"out":"[\"foo\",\"bar\",\"baz\",\"biz\",\"goo\"]","code":"my $ar = [qw{foo bar baz}]; push @$ar, 'biz', 'goo'; $ar\n","err":""},{"code":"my $ar = [qw{foo bar baz}]; push $ar, 'biz', 'goo'; $ar\n","err":"","out":"ERROR: Experimental push on scalar is now forbidden at (eval 1) line 1, at EOF\n"},{"out":"[\"foo\",\"bar\",\"baz\",\"biz\",\"grub\",\"goo\"]","err":"","code":"my @ar = qw{foo bar baz}; push @ar, 'biz', 'grub', 'goo'; \\@ar;\n"},{"code":"my @ar = qw{foo bar baz}; push @ar, qw{biz grub goo}; \\@ar;\n","err":"","out":"[\"foo\",\"bar\",\"baz\",\"biz\",\"grub\",\"goo\"]"},{"out":"[[],[]]","code":"[ [], \\my @arr ]\n","err":""},{"code":"my @arr=(1,0,1,1); my  $n=0; printf \"%b\\n\", $n; $n<<=1, $n|=$_ for @arr; printf \"%b\\n\", $n;\n","err":"","out":"0\n1011\n"},{"err":"","code":"my @arr=(1,0,1,1); my  $n=0; printf \"%b\\n\", $n; $n<<=1, $n|=$_ for @arr; printf \" -> %b\\n\", $n; print \" -> $n \";\n","out":"0\n -> 1011\n -> 11 "},{"out":"[]","code":"my @arr = 1 .. 20; undef(@arr); \\@arr\n","err":""},{"code":"my @arr = (1,2,3); \\@arr;\n","err":"","out":"[1,2,3]"},{"out":"[2,3,4]","code":"my @arr = (1,2,3); foreach my $num (@arr) { $num =~ s/(\\d)/$1+1/eg } \\@arr\n","err":""},{"out":"[[1,2,3],[]]","err":"","code":"my @arr = (1, 2, 3); my @fetch = splice @arr;  [ \\@fetch, \\@arr ]\n"},{"code":"my $arr = [1,2,3]; print $arr->[2]\n","err":"","out":"3"},{"code":"$,=$\\=' '; my @arr = (1, 2, 3); print $#arr, scalar @arr; $[ = 0; print $#arr, scalar @arr;\n","err":"","out":"2 3 2 3  "},{"out":"3      123","code":"my @arr = (1,2,3); print @arr x 1 ,\"      \", (@arr) x 1;\n","err":""},{"err":"","code":"my @arr = (1,2,3); print qq[\\@arr , \\(@arr)];\n","out":"@arr , (1 2 3)"},{"out":"[2,3,4]","code":"my @arr = (1,2,3); s/(\\d)/$1+1/eg for @arr; \\@arr\n","err":""},{"out":"[1,2,1,2]","err":"","code":"my @arr=(1,2); [(@arr)x2]\n"},{"code":"my @arr=(1,2); [(@a)x2]\n","err":"","out":"[]"},{"out":"[1,2,3]","code":"my @arr = (1..3); my $ref; @$ref = @arr; pop @arr; $ref\n","err":""},{"out":"[1,2,\"a\",4,5]","code":"my @arr = (1..5); @arr[2] = qw/a b c/; \\@arr\n","err":""},{"err":"","code":"my @arr = ('a', 'b', 'c'); my ($foo) = @arr; say $foo\n","out":"a\n"},{"err":"","code":"my @arr = ('a', 'b', 'c'); my $foo = @arr; say $foo\n","out":"3\n"},{"err":"","code":"my $arr = []; [!!@$arr]\n","out":"[\"\"]"},{"err":"","code":"my @arr; @arr[0..3]; scalar @arr\n","out":"0"},{"err":"","code":"my @arr;  $arr[0] = \"41\"; $arr[1] = \"42\"; [ $arr[\"foo\"] ]\n","out":"[41]"},{"out":"[42]","err":"","code":"my @arr; $arr[1] = \"42\"; [ $arr[\"1foo\"] ]\n"},{"code":"my @arr; $arr[1] = \"42\"; [ $arr[\"1foo\"]; ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"out":"[undef]","code":"my @arr;  $arr[1] = \"42\"; [ $arr[\"foo\"] ]\n","err":""},{"err":"","code":"my $array = [0, 1, 2]; my $one_one = [1, 1]; splice @$array, @$one_one; $array\n","out":"[0,1]"},{"out":"[0,2]","code":"my $array = [0, 1, 2]; splice @$array, 1, 1; $array\n","err":""},{"out":"[1,2,3,4,5]","err":"","code":"my @array = (1, 2, 3, 4, 5); [ @array ]\n"},{"out":"[1]","code":"my @array = 1, 2, 3, 4, 5; [ @array ]\n","err":""},{"out":"[1,2,3]","code":"my @array = (1,2,3); [@array]\n","err":""},{"out":"[1,2,3]","code":"my @array = (1,2,3); \\@array\n","err":""},{"out":"[[1,2,3]]","code":"my @array = [1,2,3]; [@array]\n","err":""},{"out":"[1]","code":"my @array = 1,2,3; \\@array\n","err":""},{"out":"123","err":"","code":"my @array = (1,2,3); foreach (@array) { print }\n"},{"code":"my @array = (1,2,3); return join(',', @accounts);\n","err":"","out":""},{"out":"[1,2,undef,undef,5]","code":"@myarray = (1, 2); $myarray[4] = 5; [ @myarray ]\n","err":""},{"code":"@myarray = (1, 2); $myarray[4] = 5; print \"<<$myarray[3]>>\";\n","err":"","out":"<<>>"},{"err":"","code":"@myarray = (1, 2); $myarray[4] = 5; print $myarray[3];\n","out":"1"},{"code":"my @array = (1..3); $#array = -2; \\@array;\n","err":"","out":"[]"},{"err":"","code":"my @array = { 1 .. 6 }; for my $h (@array) { $_ *= 10 for values %$h; } \\@array\n","out":"[{5 => 60,1 => 20,3 => 40}]"},{"code":"my @array = { 1 .. 6 }; for my $v (map values %$_, @array) { $v *= 10; } \\@array\n","err":"","out":"[{5 => 6,1 => 2,3 => 4}]"},{"out":"123456","err":"","code":"my @array = (1); for my $elem (@array) { last if $elem > 5; push @array, $elem+1 } print @array\n"},{"out":"[[],[4],[4,5],[4,5,6]]","code":"my @array = (4,5,6); [ [], map [ @array[0..$_] ], 0..$#array ] # since order doesn't matter, I find this slightly neater\n","err":""},{"code":"my @array = (4,5,6); [ (map [ $_ ], @array), (map [ @array[0..$_] ], 1..$#array) ] # but as preaction says, look for a module first\n","err":"","out":"[[4],[5],[6],[4,5],[4,5,6]]"},{"err":"","code":"my @array = (4,5,6); [ (map [ $_ ], @sets_list1), (map [ @sets_list1[0..$_] ], -1..$#sets_list1) ];\n","out":"[[]]"},{"err":"","code":"my @array = (\"a\",1,\"b\",\"x\",\"v\"); my @idxs = (0,2);  [@array[grep { !exists {map {$_=>undef} @idxs}->{$_}} keys @array]]\n","out":"[1,\"x\",\"v\"]"},{"err":"","code":"my @array = (\"a\", \"b\"); [\\(@array)]\n","out":"[\\\"a\",\\\"b\"]"},{"code":"my @array = (\"a\", \"b\"); [\\@array, \\(@array)]\n","err":"","out":"[[\"a\",\"b\"],\\$VAR1->[0][0],\\$VAR1->[0][1]]"},{"out":"[222,\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]","err":"","code":"my @array = (\"a\", \"b\"); [@array x 3, (@array) x 3]\n"},{"err":"","code":"my @array = (\"a\", \"b\"); [q(@array) .@x1, q@array .@x1]\n","out":"[\"\\@array0\",\"array .\"]"},{"out":" a b .... (a b) ","code":"my @array = (a..b); qq[ @array .... (@array) ]\n","err":""},{"out":"0: A\n1: B\n2: C\n","code":"my @array = ( 'A'..'C' ); while ( ( my $i, $_ ) = each @array ) { say qq{$i: $_}; } # Chib\n","err":""},{"code":"my @array = 'a'..'e'; my %hash = %array[0 .. 4]; [ %hash ] #do you mean like this, treker?\n","err":"","out":"[1,\"b\",0,\"a\",4,\"e\",3,\"d\",2,\"c\"]"},{"out":"{1 => \"b\",0 => \"a\",4 => \"e\",3 => \"d\",2 => \"c\"}","err":"","code":"my @array = 'a'..'e'; my %hash = %array[0 .. 4]; \\%hash # meant like this I guess\n"},{"code":"my @array = ( 'A'..'E' ); sub { shift @{$_[0]} while @{$_[0]} }->( \\@array ); \\@array;\n","err":"","out":"[]"},{"out":"[-1]","code":"my @array = (); [ $#array ];\n","err":""},{"err":"","code":"my @array; $#array\n","out":"-1"},{"code":"my @array; $array[0] = \\@array; [@array]\n","err":"","out":"[[$VAR1->[0]]]"},{"out":"[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]","err":"","code":"my @array = \"A\" .. \"Z\"; [ keys @array ]\n"},{"out":"[\"a\",1,\"b\",1,\"c\",1,\"d\",1,\"e\",1,\"f\",1,\"g\",1,\"h\",1,\"i\",1,\"j\",1,\"k\",1,\"l\",1,\"m\",1,\"n\",1,\"o\",1,\"p\",1,\"q\",1,\"r\",1,\"s\",1,\"t\",1,\"u\",1,\"v\",1,\"w\",1,\"x\",1,\"y\",1,\"z\",1]","err":"","code":"my @array = 'a'..'z'; [ map { $_, 1 } @array ];\n"},{"out":"[\"a\",42,\"b\",42,\"c\",42,\"d\",42,\"e\",42,\"f\",42,\"g\",42,\"h\",42,\"i\",42,\"j\",42,\"k\",42,\"l\",42,\"m\",42,\"n\",42,\"o\",42,\"p\",42,\"q\",42,\"r\",42,\"s\",42,\"t\",42,\"u\",42,\"v\",42,\"w\",42,\"x\",42,\"y\",42,\"z\",42]","err":"","code":"my @array = 'a'..'z'; [ map { $_, 42 } @array ];\n"},{"code":"my @array; [ defined @array ]\n","err":"","out":"ERROR: Can't use 'defined(@array)' (Maybe you should just omit the defined()?) at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"my @array = ( \"hip\", \"hip\" ); print \"@array\\n\", ref(@array);\n","err":"","out":"hip hip\n"},{"out":"ERROR: Type of arg 1 to push must be array (not constant item) at (eval 1) line 1, at EOF\n","code":"my @array; push array, 1, 2\n","err":""},{"out":"in scope","err":"","code":"my @array = qw(1..3); for (@array) { 0+@array and print \"in scope\" }\n"},{"out":"[\"a\",\"s\",\"d\",\"f\"]","code":"my @array = qw(a a a s d f a); [ @array[sort { $a <=> $b } values %{ +{ reverse map {; $_ => $array[$_] } 0..$#array } } ] ] # might be useful as an interview answer if you didn't want the job\n","err":""},{"out":"s f d a","code":"my @array = qw(a a a s d f); @array = keys %{ {map { $_ => 1 } @array} }; \"@array\"\n","err":""},{"out":"ERROR: Experimental keys on scalar is now forbidden at (eval 1) line 1, <STDIN> line 1.\n","code":"my @array = qw(a a a s d f); @array = keys %{map { $_ => 1 } @array}; Dumper(@array)\n","err":""},{"out":"$VAR1 = 's';\n$VAR2 = 'f';\n$VAR3 = 'd';\n$VAR4 = 'a';\n","err":"","code":"my @array = qw(a a a s d f); my %conv = map { $_ => 1 } @array; @array = keys %conv; Dumper(@array)\n"},{"code":"my @array = qw(a a a s d f); my %items = map {; $array[$_] => $_ } 0..$#array; [ @array[sort { $a <=> $b } values %items] ] # if you dislike uniq() for some reason\n","err":"","out":"[\"a\",\"s\",\"d\",\"f\"]"},{"out":"[\"s\",\"f\",\"d\",\"a\"]","err":"","code":"my @array = qw(a a a s d f); my @unique = keys %{ {@array, reverse @array} }; \\@unique\n"},{"err":"","code":"my $array_ref = [3,4,5]; [ $#$array_ref ]\n","out":"[2]"},{"err":"","code":"my $array_ref = [3,4,5]; local $[ = 1; [ $#$array_ref ]\n","out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"my $array_ref = [3,4,5]; [ scala @$array_ref ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"scala @\"\n"},{"code":"my $array_ref = [3,4,5]; [ scalar @$array_ref ]\n","err":"","out":"[3]"},{"code":"my $array_ref = eval \"[1,2,3]\"; print $array_ref->[2]; #works for me\n","err":"","out":"3"},{"out":"[[\"bar\",3],[\"onur\",5],[\"foo\",7]]","code":"my $array_ref = [ [ 'onur', 5 ], [ 'bar', 3], [ 'foo', 7 ] ]; [ sort { $a->[1] <=> $b->[1] } @$array_ref]\n","err":""},{"out":"ERROR: Can't call method \"bundle_by\" on unblessed reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my @array = split '', 'abcdefghijklmnopqrstuvwxyz'; [bundle_by { [@_] } 9, @array]\n"},{"code":"my @arr = (\"b\", \"c\"); push @arr, \"d\";\n","err":"","out":"3"},{"code":"my $arr = []; @$blah ? 1 : 0\n","err":"","out":"0"},{"err":"","code":" my @arr = (\"foo\", \"bar\");  print \"@arr \".@arr.\"\\n\";\n","out":"foo bar 2\n"},{"out":"[[3],[]]","err":"","code":"my @arr = ([], []); my $copyref = [@arr]; $copyref->[0][0] = 3; \\@arr\n"},{"out":"[]","err":"","code":"my @arr; my $copyref = [@arr]; $copyref->[0][0] = 3; \\@arr\n"},{"out":"[[[3]],[]]","err":"","code":"my @arr; my $copyref = [@arr]; $copyref->[0][0] = 3; [ $copyref, \\@arr ]\n"},{"err":"","code":"my @arr; my %sections = { name => \"testname\" }; push(@arr, \"test\"); print $arr[0];\n","out":"test"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"%sections { \"\n","code":"my @arr; my %sections { name => \"testname\" }; push(@arr, \"test\"); print $arr[0];\n","err":""},{"code":"my @arr; my @stuff = @arr[0..3]; scalar @arr\n","err":"","out":"0"},{"code":"my @arr; my @stuff = grep defined, @arr[0..3]; scalar @arr\n","err":"","out":"4"},{"code":"my @arr; push(@arr, \"123\"); @arr =~ s/2//g; @arr[0];\n","err":"","out":"ERROR: Can't modify private array in substitution (s///) at (eval 1) line 1, at EOF\n"},{"out":"ERROR: Can't modify private array in substitution (s///) at (eval 1) line 1, at EOF\n","err":"","code":"my @arr; push(@arr, \"123\"); @arr =~ s/2//g; $arr[0];\n"},{"err":"","code":"my @arr; push(@arr, \"123\"); @arr = s/2//g; @arr[0];\n","out":""},{"out":"1","code":"my @arr; push(@arr, \"123\"); @arr = s/2//g; print @arr[0];\n","err":""},{"code":"my @arr; push(@arr, \"test\"); push(@arr, \"i refuse to do what master tells me to\"); @arr2 = grep(/test/, @arr); print @arr2[1];\n","err":"","out":"1"},{"code":"my @arr; push(@arr, \"test\"); push(@arr, \"i refuse to do what master tells me to\"); @arr2 = grep(\"test\", @arr); print @arr2[1];\n","err":"","out":"i refuse to do what master tells me to"},{"err":"","code":"my @arr; push(@arr, \"test\"); push(@arr, \"i refuse to do what master tells me to\"); my @arr2 = grep { /test/ } @arr; $arr2[0];\n","out":"test"},{"code":"my @arr; push(@arr, \"test\"); push(@arr, \"i refuse to do what master tells me to\"); my @arr2 = grep { /test/ } @arr; $arr2[1];\n","err":"","out":""},{"out":"1","err":"","code":"my @arr; push(@arr, \"test\"); push(@arr, \"i refuse to do what master tells me to\"); my @arr2 = grep { /test/ } @arr; print @arr2[1];\n"},{"code":"my @arr; push(@arr, \"test\"); push(@arr, \"i refuse to do what master tells me to\"); my @arr2 = grep { /test/ } @arr; print $arr2[1];\n","err":"","out":"1"},{"err":"","code":"my @arr; push(@arr, \"test\"); push(@arr, \"i refuse to do what master tells me to\"); my @arr2 = grep {$_ == \"test\"} @arr; print @arr2[1];\n","out":"i refuse to do what master tells me to"},{"out":"1","code":"my @arr; push(@arr, \"test\"); push(@arr, \"i refuse to do what master tells me to\"); my @arr2 = grep(/test/, @arr); print @arr2[1];\n","err":""},{"code":"my @arr; push(@arr, \"test\"); push(@arr, \"not\"); @arr2 = grep(\"test\", @arr); print @arr[1];\n","err":"","out":"not"},{"err":"","code":"my @arr; push(@arr, \"test\"); push(@arr, \"not\"); @arr2 = grep(\"test\", @arr); print @arr2[1];\n","out":"not"},{"out":"123","err":"","code":"my @arr = qw(1 2 3); print @arr;\n"},{"code":"my @arr = qw/a b c d e f/; my ($item) = @arr; $item;\n","err":"","out":"a"},{"out":"6","code":"my @arr = qw/a b c d e f/; my $name = @arr; $name;\n","err":""},{"out":"[0,\"A\"]","code":"my @arr = qw( A B C ); my @result = each @arr; \\@result\n","err":""},{"err":"","code":"my @arr = qw/foo bar baz/; delete $arr[0]; [ @arr ]\n","out":"[undef,\"bar\",\"baz\"]"},{"err":"","code":"my $arrref = [ key => \"value\" ];  { @$arrayref }->{key}\n","out":"ERROR: syntax error at (eval 1) line 1, near \"}->\"\n"},{"out":"value","err":"","code":"my $arrref = [ key => \"value\" ];  +{ @$arrref }->{key}\n"},{"out":"0","err":"","code":"my @arr; say @arr if @arr;\n"},{"err":"","code":"my @arr; say 'defined' if @arr;\n","out":"0"},{"code":"my @arr = (undef, undef, 'foo'); shift @arr; say 'defined' if @arr;\n","err":"","out":"defined\n"},{"err":"","code":"my @arr = (undef, undef, 'foo'); shift @arr; say '-->', $_, '<--' for @arr;\n","out":"--><--\n-->foo<--\n"},{"err":"","code":"my @arr = (undef, undef, undef, {foo=>3}); grep {$_->{foo}} @arr; \\@arr\n","out":"[{},{},{},{foo => 3}]"},{"code":"my @ary = ('one','two','three'); [ (check => @ary) ] # G66K: not what you wanted, eh?\n","err":"","out":"[\"check\",\"one\",\"two\",\"three\"]"},{"err":"","code":"my @ary = ('one','two','three'); my %h = (check => @ary); print $h{check}\n","out":"one"},{"code":"my @ary = qw( foo 1 bar 2 ); my %hash = @ary; [ \\%hash ]\n","err":"","out":"[{bar => 2,foo => 1}]"},{"out":"[[2,2,1],[\"f00\",\"b00\",\"b0z\"]]","code":"my @ary = qw( foo boo boz ); my @edited = map { s/o/0/g } @ary; [ \\@edited, \\@ary ]\n","err":""},{"code":"my @ary = qw (one two three); my $sc = splice (@ary , 0 ,1); print $sc\n","err":"","out":"one"},{"out":"three","code":"my @ary = qw (one two three); my $sc = splice (@ary , 0); print $sc\n","err":""},{"err":"","code":"my @ary = qw (one two three); my $sc = splice (@ary , -1); print $sc\n","out":"three"},{"out":"three","err":"","code":"my @ary = qw (one two three); my $sc = splice (@ary , 2); print $sc\n"},{"out":"[\"z\",\"x\",\"y\"]","code":"my $a; [sort { $a cmp $b } qw( z y x)]\n","err":""},{"err":"","code":"my @a = \"${\\( wantarray() ? 'list' : 'scalar' )}\"\n","out":"1"},{"out":"scalar","code":"my @a = \"${\\( wantarray() ? 'list' : 'scalar' )}\"; @a[0]\n","err":""},{"code":"my @a = \"${wantarray() ? \\'list' : \\'scalar'}\"; @a[0]\n","err":"","out":"scalar"},{"out":"1","err":"","code":"my $a = \"woop\"; $a =~ m/woop/;\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"$a m/woop/\"\n","code":"my $a = \"woop\"; $a m/woop/;\n","err":""},{"err":"","code":"my $a = \"woop\"; $a =~ m/w(..)p/; $1\n","out":"oo"},{"out":"y2kupdate","err":"","code":"my $badcrons = ('/var/tmp', 'psybnc', 'y2kupdate'); $badcrons\n"},{"out":"","code":"my $bar; if (my $foo = $bar) { 1 }\n","err":""},{"err":"","code":"my $base = \"foo.bar.baz\"; my ($junk, $wanted) = split '\\.', $base; $wanted;\n","out":"bar"},{"code":"my $b = 'b'; --$b\n","err":"","out":"-1"},{"err":"","code":"my $b = 'b'; $b--\n","out":"b"},{"out":"[\"FOO\\\\tBAR\\\\r\\\\n\",\"FOO\\\\tBAR\\\\r\\\\n\"]","code":"my $before = q{FOO\\tBAR\\r\\n}; ( my $after = $before ) =~ s/\\\\([trn])/qq{\\\\$1}/ge; [ $before, $after ]; # Wondering if there is a way to do this withough having seaprate substitutions?\n","err":""},{"out":"0.40625","err":"","code":"my $binary = '01101'; my $rslt = 0; my $factor = 2; for(split //, $binary) { $rslt += 1/$factor if $_; $factor <<= 1 } $rslt\n"},{"out":"1999","err":"","code":"my $birthday = '1999/10/07'; ($birthday) = $birthday =~ /(\\d{4})/; $birthday\n"},{"out":"[0,1,2,3,4,5]","err":"","code":"my @blah; $blah[5] = \"something\"; [ keys @blah ]\n"},{"err":"","code":"my $blah = { x=>1 }; my $d = 0; $d ||= $blah->{x}; $d\n","out":"1"},{"out":"","err":"","code":"my $blah = { x=>1 }; my $z => { y=>$blah->{x} }; $blah->{x}++; $z->{y}\n"},{"err":"","code":"my $blah = { x=>1 }; my $z = { y=>$blah->{x} }; $blah->{x}++; $z->{y}\n","out":"1"},{"out":"2","code":"my $blah = { x=>1 }; my $z = { y=>\\$blah->{x} }; $blah->{x}++; ${ $z->{y} }\n","err":""},{"code":"my $buf = \"\\x{666}\"; open my $fh, '<', \\$buf or die \"open: $!\"\n","err":"","out":"ERROR: open: Invalid argument at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"my @bytes = 1..10; my @words = unpack '(s1)*', pack '(c1c1)*', @bytes; \\@words # may need both pack+unpack\n","out":"[513,1027,1541,2055,2569]"},{"code":"my $bytes = pack(\"Q>\", 123456789); $bytes =~ s/^\\0+//; $bytes\n","err":"","out":"\u0007[ÃÂ\u0015"},{"err":"","code":"my @captures = \"peas and carrots\" =~ /([aeiou])/g; \\@captures\n","out":"[\"e\",\"a\",\"a\",\"a\",\"o\"]"},{"out":"[\"e\",\"a\",\"a\",\"n\",\"a\",\"r\",\"o\",\"t\"]","code":"my @captures = \"peas and carrots\" =~ /([aeiou])(.)/g; \\@captures\n","err":""},{"out":"ERROR: Undefined subroutine &CORE::GLOBAL::pop called at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my $c = \\&CORE::GLOBAL::pop; my @abc = qw,a b c,; [$c->(\\@abc)]\n"},{"code":"my $c = \\&CORE::pop; my @abc = qw,a b c,; [$c->(\\@abc)]\n","err":"","out":"ERROR: &CORE::pop cannot be called directly at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"samsung\",\"crap\",\"shit\"]","code":"my %c; @c{qw(apple samsung shit crap)} = (); my $b = 'apple'; delete $c{$b}; [keys %c]\n","err":""},{"out":"ab!\"","err":"","code":"my $ch = 'ab'; $ch .= join '', map chr(ord($_) & ~0x40), split //, $ch; $ch # just use $! and $\", I'm sure no one would mind\n"},{"out":"1oo4ar7az10uux14leem","code":"my @chars = split '', 'FooBarBazQuuxFleem'; join '', map $chars[$_] =~ /[A-Z]/ ? $_+1 : $chars[$_], 0..$#chars;\n","err":""},{"code":"my $checkOS = \"if [ -e /etc/redhat-release ] ; then cat /etc/redhat-release ; else lsb_release -a |grep Desc ; fi\";\n","err":"","out":"if [ -e /etc/redhat-release ] ; then cat /etc/redhat-release ; else lsb_release -a |grep Desc ; fi"},{"out":"oneERROR: Label not found for \"last LABEL\" at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my $c; LABEL: { $c = sub { last LABEL } }; print \"one\"; $c->(); print \"two\";\n"},{"code":"my $c; LABEL: { $c = sub { last LABEL } }; print \"one\"; LABEL: { $c->(); print \"two\"; }\n","err":"","out":"one"},{"err":"","code":"my %class_from_domain = ('a,b,c' => 1, 'a,c' => 2); [ map $class_from_domain{join ',', sort @$_}, ([qw(a b c)], [qw(a c)]) ] # if there's no overlap, should be simple to handle with a hash\n","out":"[1,2]"},{"out":"sed -e 's#\\\\\\n#\\n#g'","code":"my $cmd = q(sed -e 's#\\\\\\\\\\n#\\n#g'); print $cmd; ();\n","err":""},{"out":"sed -e 's#\\\\n#\\n#g'","code":"my $cmd = q(sed -e 's#\\\\\\n#\\n#g'); print $cmd; ();\n","err":""},{"out":"5","err":"","code":"my $c = (my @tmp) = (split ' ', \"pink_mist says split is special\", 0); $c\n"},{"out":"ERROR: Experimental keys on scalar is now forbidden at (eval 1) line 1, <STDIN> line 1.\n","code":"my %commands = ( help => sub { my $commands = say for keys in %commands; }); say $commands{help};\n","err":""},{"err":"","code":"my $cond = sub { my $s = shift ; return $s =~ /start/ && ($s =~ /tomorrow/ || $s =~ /class/); }; [$cond->(\"start tomorrow\")]\n","out":"[1]"},{"out":"1","code":"my $c = () = (split ' ', \"pink_mist says split is special\", 0); $c\n","err":""},{"err":"","code":"my $c = () = (split ' ', \"pink_mist says split is special\"); $c\n","out":"1"},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"my $c = () = (split ' ', \"pink_mist says split is special); $c\n","err":""},{"err":"","code":"my $d3; [ map { 42 } @{$d3->{null_edges}} ]\n","out":"[]"},{"code":"my $d3 = { null_edges => [undef] }; [ map { map { 42 } @$_ } @{$d3->{null_edges}} ]\n","err":"","out":"[]"},{"code":"my $data = \"\\0\\1\\2\\3\\4\\5\\6\\7\\x08\\x09\\x0a\\x0b\"; [ unpack \"a8 L>\", $data ]\n","err":"","out":"[\"\\0\\1\\2\\3\\4\\5\\6\\a\",134810123]"},{"out":"ERROR: Invalid type '\u0000' in unpack at (eval 1) line 1, <STDIN> line 1.\n","code":"my $data = \"\\0\\1\\2\\3\\4\\5\\6\\7\\x08\\x09\\x0a\\x0b\"; [ unpack $data, \"a8 L>\" ]\n","err":""},{"out":"[\"1 2 3\"]","err":"","code":"my $data = '1 2 3'; [ split /\\+/, $data ]\n"},{"err":"","code":"my $data = \"ABCDE\\x02\";  substr $data, 0, -ord substr $data, -1\n","out":"ABCD"},{"out":"hellofreenodeperl","err":"","code":"my $data = {foo => [qw/hello freenode perl/]}; print for ($data->{foo}->@*); \n"},{"out":"2 - two","code":"my @data = ({number => 1, name => 'one'},{number => 2, name => 'two'}); for(@data) { print $_->{number} . ' - ' . $_->{name} if $_->{number} == 2 } # something like this\n","err":""},{"err":"","code":"my %defaults = ( foo => 111, boo => 222, coo => 333, doo => 444 ); @_ = ( boo => 555, moo => 999, coo => 777 ); my %user = @_; +{ map { $_ => $user{$_} // $defaults{$_} } keys %defaults }; ### Is there a nicer way to do this?\n","out":"{coo => 777,doo => 444,foo => 111,boo => 555}"},{"out":"[0,2]","code":"my $delay = 0;  my $after = ( $delay+0, $delay+=2 )[0];  [ $after, $delay ]\n","err":""},{"out":"[2,2]","code":"my $delay = 0;  my $after = ( $delay, $delay+=2 )[0];  [ $after, $delay ]\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"+=,\"\n","code":"my $delay = 0;  my $after = ( $delay+=, $delay+=2 )[0];  [ $after, $delay ]\n","err":""},{"err":"","code":"my $delim = q{ | }; my @list = qw( AAA BBB CCC ); [ map { $_, $delim } @list ] ### Is there a way to do this so $delim is only between each array element, like how join() works?\n","out":"[\"AAA\",\" | \",\"BBB\",\" | \",\"CCC\",\" | \"]"},{"code":"my $delim = q{ | }; my @list = qw( AAA BBB CCC ); [ map { @list, $delim } @list ] ### Is there a way to do this so $delim is only between each array element, like how join() works?\n","err":"","out":"[\"AAA\",\"BBB\",\"CCC\",\" | \",\"AAA\",\"BBB\",\"CCC\",\" | \",\"AAA\",\"BBB\",\"CCC\",\" | \"]"},{"code":"my $delim = q{ | }; my @list = qw( AAA BBB CCC ); [ shift( @list ), map { $delim, $_ } @list ] ### How about this?\n","err":"","out":"[\"AAA\",\" | \",\"BBB\",\" | \",\"CCC\"]"},{"out":"1:4:9:16:25:36:49:64:81:100","code":"my @digit = (1..10); map { $_ *= $_ } (@digit); print join \":\", @digit;\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"join(|\"\n","code":"my @digit = (1..10); map { $_ *= $_ ,join(|:|,$_)} (@digit); print @digit;\n","err":""},{"out":"149162536496481100","err":"","code":"my @digit = (1..10); map { $_ *= $_ ,join(\":\",$_)} (@digit); print @digit;\n"},{"code":"my $dispatch; $dispatch = { one => sub { return $dispatch }, two => sub { return $dispatch }, };       $dispatch->{'one'}->('one')->{'two'}->('two')\n","err":"","out":"{one => sub { \"DUMMY\" },two => sub { \"DUMMY\" }}"},{"code":"my $dt = DateTime->new; ~~$dt\n","err":"","out":"ERROR: Mandatory parameter 'year' missing in call to DateTime::new\n at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/site_perl/5.24.0/x86_64-linux/DateTime.pm line 197, <STDIN> line 1.\n\tDateTime::new(undef) called at (eval 1) line 1\n\teval 'use 5.024000; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; my $dt = DateTime->new; ~~$dt' called at /home/ryan/bots/perlbuut/lib/eval.pl line 301\n\tmain::perl_code(\"my \\$dt = DateTime->new; ~~\\$dt\") called at /home/ryan/bots/perlbuut/lib/eval.pl line 248\n"},{"err":"","code":"my $e; { local $@; eval { die \"foo\" }; $e = $@; }\n","out":"foo at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"Unimplemented at (eval 1) line 1, <STDIN> line 1.\n","code":"my $e; { local $@; eval { ... }; $e = $@; }\n","err":""},{"out":"[{}]","code":"my %empty; my $defined = \\%empty; [ $defined ] # mad_hatter\n","err":""},{"code":"my $enumeratedValues = \"1|2|3|4\"; [ split('\\|', $enumeratedValues) ]\n","err":"","out":"[1,2,3,4]"},{"code":"m/yes/no\n","err":"","out":""},{"out":"[\"\"]","code":"my $eval = '$2 $1'; my $out = \"foo bar\" =~ s/(\\w+) (\\w+)/$eval/eer; [ $out ]\n","err":""},{"out":"[\"\\$2 \\$1\"]","code":"my $eval = '$2 $1'; my $out = \"foo bar\" =~ s/(\\w+) (\\w+)/$eval/er; [ $out ]\n","err":""},{"err":"","code":"my $eval_block_result = eval { die 'blahblah'; 3 }; [ $eval_block_result, $@ ];\n","out":"[undef,\"blahblah at (eval 1) line 1, <STDIN> line 1.\\n\"]"},{"out":"[3,\"\"]","code":"my $eval_block_result = eval { die 'blahblah' if 0; 3 }; [ $eval_block_result, $@ ];\n","err":""},{"code":"my $eval_block_result = eval { die syntax error here if 0; 3 }; [ $eval_block_result, $@ ];\n","err":"","out":"[3,\"\"]"},{"out":"something","err":"","code":"my @example = qw<fail>; $_ = 'test@example.com'; s/\\Q$_\\E/something/; print;\n"},{"out":"something","err":"","code":"my @example = qw<fail>; $_ = 'testfail.com'; s/\\Qtest@example.com\\E/something/; print;\n"},{"err":"","code":"'my@example' =~ /^(\\w+)\\@/\n","out":"1"},{"err":"","code":"'my@example' =~ /^(\\w+)\\@/; $1\n","out":"my"},{"out":"1234","code":"my $f = 1; my @x = qw( 1 2 3 ); for ( @x ) { if ( $f ) { $f--; push @x, 4; } print; }\n","err":""},{"out":"1","err":"","code":"my $f = \"1welp\"; $f ~~ 1;\n"},{"out":"[\"\",1]","code":"my $f = \"1welp\"; my $d = \"1\"; my $before = $f ~~ $d; my $c = $d + 0; my $after = $f ~~ $d; [$before, $after];\n","err":""},{"out":"3628800","err":"","code":"my $fac = 1; $fac *= $_ for (2 .. 10); $fac;\n"},{"out":"my fancy filename.txt","code":"$_ = \"my fancy filename.txt\"; s/(?<!\\.)\\b/\\U/gr\n","err":""},{"err":"","code":"$_ = \"my fancy filename.txt\"; s/(?<!\\.)\\b(\\w)/\\U$1/gr\n","out":"My Fancy Filename.txt"},{"out":">implying","code":"my $fh = *STDOUT; print $fh \">implying\"; ()\n","err":""},{"code":"my $field = 'foo'; sub bar { (my $param, $field) = @_; [ $param, $field ] } bar('baz');\n","err":"","out":"[\"baz\",undef]"},{"out":"1","err":"","code":"my $field = 'foo'; sub bar { (my $param, $field) = @_; print $field } bar('baz');\n"},{"err":"","code":"my @fields = (1..10); my @bits = reverse split //, sprintf '%b', 1890; join ',', map $bits[$_] ? $fields[$_] : (), 0..$#fields\n","out":"2,6,7,9,10"},{"code":"my $file = \"blah.pl\"; return \"Yep\" if ($file =~ m#\\.pl$#);\n","err":"","out":"Yep"},{"code":"my $filename = \"foo.jpg.\"; my @chunks = split /\\./, $filename; (@chunks > 1 ? $chunks[-1] : die 'funny shit')\n","err":"","out":"jpg"},{"out":"jpg","code":"my $filename = \"foo\\nbar.jpg\"; my @chunks = split /\\./, $filename; (@chunks > 1 ? $chunks[-1] : die 'funny shit')\n","err":""},{"out":"vimrc","err":"","code":"my $filename = \".vimrc\"; my @chunks = split /\\./, $filename; (@chunks > 1 ? $chunks[-1] : die 'funny shit')\n"},{"out":"_ _ _ _ _","code":"my @fill = (\"_\") x 5; \"@fill\"\n","err":""},{"out":"h _ _ _ _","code":"my @fill = (\"_\") x 5; $fill[0] = 'h'; \"@fill\"\n","err":""},{"err":"","code":"my @fill = (\"_\") x 5; $fill[0] = 'h'; $fill[2] = 'l'; $fill[3] = 'l'; \"@fill\"\n","out":"h _ l l _"},{"out":"_ h _ _ _","code":"my @fill = (\"_\") x 5; $fill[1] = 'h'; \"@fill\"\n","err":""},{"code":"my $final = qw( these comma operators are in scalar context ); $final\n","err":"","out":"context"},{"out":"","code":"my $ foo;\n","err":""},{"out":"['18446744073709551615',\"-1.84467440737096e+19\"]","code":"my $foo = 0; [~-$foo, -~$foo]\n","err":""},{"out":"1","err":"","code":"my $foo = 0; sub test { $_[0]++ } test $foo; $foo\n"},{"out":"1","err":"","code":"my $foo = 0; sub test { my $bar = $_[0]; $$bar = $$bar + 1 } test \\$foo; $foo\n"},{"out":"[]","code":"my $foo = '[1.1.1.1]'; [$foo =~ /\\[(\\d{1-3}\\.\\d{1-3}\\.\\d{1-3}\\.\\d{1-3})\\]/]\n","err":""},{"err":"","code":"my $foo = '[1.1.1.1]'; [$foo =~ /\\[(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\\]/]\n","out":"[\"1.1.1.1\"]"},{"code":"my $foo = '1.1.1.1'; [$foo =~ /\\[(\\d{1-3}\\.\\d{1-3}\\.\\d{1-3}\\.\\d{1-3})\\]/]\n","err":"","out":"[]"},{"out":"[]","err":"","code":"my $foo = '1.1.1.1'; [$foo =~ /\\[(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\\]/]\n"},{"out":"[1,2,3,4,5,6,7,8,9,10,\"a\",11,12,13,14,15,16,17,18,19,20]","err":"","code":"my @foo = 1 .. 20; my @bar = (@foo[0..$#foo/2], \"a\", @foo[10..$#foo]); [@bar]\n"},{"err":"","code":"my @foo = (1,2,3); \\@foo\n","out":"[1,2,3]"},{"err":"","code":"my @foo = (1,2,3); $_++ for @foo; \\@foo\n","out":"[2,3,4]"},{"code":"my $foo = 123; package Y { print \">$foo<\" }\n","err":"","out":">123<"},{"out":"1","code":"my $foo = \\1; my $bar = $$foo; $foo++; $bar;\n","err":""},{"code":"my $foo = 1; my $foo_bar = 2; \"$foo\\_bar\"\n","err":"","out":"1_bar"},{"code":"my $foo = 1; sub change_foo { $foo = 2 }; change_foo(); [ $foo ]\n","err":"","out":"[2]"},{"out":"[[1,sub { \"DUMMY\" }]]","err":"","code":"my @foo = [1, sub { code; }]; \\@foo\n"},{"out":"[[1,sub { \"DUMMY\" }]]","err":"","code":"my @foo = [1, sub { ... }]; \\@foo\n"},{"out":"[1]","err":"","code":"my $foo = 1; sub get_foo { return $foo }; [ get_foo() ]\n"},{"err":"","code":"my $foo = 2 ** 20; $foo;\n","out":"1048576"},{"out":"[4294967295,\"-1.84467440694146e+19\"]","err":"","code":"my $foo = 2**32; [~-$foo, -~$foo]\n"},{"err":"","code":"my $foo = 42; my $bar = \\$foo; $foo = \"hi\"; $bar\n","out":"\\\"hi\""},{"code":"my $foo = 42; my $bar = \\$foo; $foo = \"hi\"; $$bar\n","err":"","out":"hi"},{"err":"","code":"my $foo = + + + + + + + 5;\n","out":"5"},{"out":"[4,\"-1.84467440737096e+19\"]","code":"my $foo = 5.0; [~-$foo, -~$foo]\n","err":""},{"code":"my $foo = 5 + do { 5 }; [$foo]\n","err":"","out":"[10]"},{"code":"my $foo = 5; $ foo;\n","err":"","out":"5"},{"out":"[4,\"-1.84467440737096e+19\"]","err":"","code":"my $foo = 5; [~-$foo, -~$foo]\n"},{"out":"5","err":"","code":"my $foo = 5; my $bar = sub { $foo }; $bar->()\n"},{"err":"","code":"my $foo = 5; sub bar { $foo } bar\n","out":"5"},{"err":"","code":"my $foo = 5; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say 3 }\n","out":"2\n"},{"code":"my $foo = 5; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say 3 } else { say 4 }\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"} else\"\n"},{"out":"","err":"","code":"my $foo = 7; my $bar = 1; say \"blah\" if (($foo or $bar) == 1);\n"},{"code":"my $foo = 7; my $bar = 1; say \"blah\" if ($foo or $bar) == 1;\n","err":"","out":""},{"err":"","code":"my %foo = (a,1,b,2,c,3); join(', ', keys %foo); #for PSGroup53\n","out":"b, c, a"},{"err":"","code":"my %foo = (a,1,b,2,c,3); join(', ', values %foo); #for PSGroup53\n","out":"2, 3, 1"},{"out":"3","err":"","code":"my %foo = (a,1,b,2,c,3); keys %foo; #for PSGroup53\n"},{"out":"{lucky => \"luke\"}","code":"my $foo = {a => bar, b => baz}; $moo = \"lucky:luke\"; $foo = {split \":\", $moo}; $foo;\n","err":""},{"code":"my $foo = 'a b c d'; $foo =~ s/ /\\\\s+/g; 'a    b    c     d' =~ s/$foo/bar/r\n","err":"","out":"bar"},{"code":"my $foo = 'a b c d'; $foo =~ s/ /\\\\s+/g; 'a    b    c     d' =~ s/$foo//r\n","err":"","out":""},{"err":"","code":"my @foo = ([\"A\",\"B\",\"C\"],[\"E\",\"F\"],[\"G\",\"H\",\"I\",\"J\",\"K\"],[\"L\"]); $#{$foo[0]}\n","out":"2"},{"out":"c\n","code":"my $foo = ('a', 'b', 'c'); say $foo #this though...\n","err":""},{"out":"[\"asdf\"]","code":"my $foo = \"asdf\"; open my $fh, '<', \\$foo; [<$fh>]\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"$foo{bar\"\n","err":"","code":"my $foo{bar} = 1\n"},{"out":"[2]","err":"","code":"[ my ($foo, $bar) //= (1,2) ]\n"},{"out":"","code":"my $foo = 'bar' and $foo\n","err":""},{"out":"barbarbarbarbarbra ann","err":"","code":"my($foo,$bar)=('bar','bra ann');$foo x= 5;print $foo.$bar;\n"},{"out":"[\"bar\",\"baz\"]","err":"","code":"my %foo = (bar => 'baz'); my @refs = \\(%foo); ${$refs[0]} = 'quux'; [%foo]\n"},{"out":"[\"bar\",\"quux\"]","code":"my %foo = (bar => 'baz'); my @refs = \\(%foo); ${$refs[1]} = 'quux'; [%foo]\n","err":""},{"err":"","code":"[ my ($foo, $bar, $baz) = ('quux') x 3 ]\n","out":"[\"quux\",\"quux\",\"quux\"]"},{"code":"my $foo = 'ba\\'r'; [ \"foo '$foo'\" ]\n","err":"","out":"[\"foo 'ba'r'\"]"},{"out":"bar","err":"","code":"my $foo=\"bar\"; for $foo (1..4) {}; $foo\n"},{"out":"bar","err":"","code":"my $foo=\"bar\"; for $foo (1..4) {last}; $foo\n"},{"out":"","code":"my $foo = \"bar\"; my $baz = sub {$foo; ${\"foo\"}}; $baz->();\n","err":""},{"out":"1","err":"","code":"my $foo = \"bar\"; my $baz = sub {${\"foo\"}}; print $baz->();\n"},{"code":"my $foo = \"bar\"; print $                 foo;\n","err":"","out":"bar"},{"err":"","code":"my @foo; defined @foo\n","out":"ERROR: Can't use 'defined(@array)' (Maybe you should just omit the defined()?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[[undef,undef,undef,undef,undef,[undef,undef,undef,[]]]]","err":"","code":"my @foo; exists $foo[5][3][7]; [ \\@foo ]; ### It also works with arrays.\n"},{"out":"[[undef,undef,undef,undef,undef,{bar => []}]]","err":"","code":"my @foo; exists $foo[5]{bar}[7]; [ \\@foo ]; ### Or a mix of the two.\n"},{"out":"[{bar => {baz => {quux => {}}}}]","code":"my %foo; exists $foo{bar}{baz}{quux}{floop}; [ \\%foo ]\n","err":""},{"err":"","code":"my @foo; [ $foo[1] != 1 ]\n","out":"[1]"},{"out":"foo foo ","err":"","code":"my %foo = foo => 1, bar => 1; sub foo { print join \" \", %foo }; foo; { delete local $foo{foo}; foo }; foo;\n"},{"out":"foo ","err":"","code":"my %foo = foo => 1; sub foo { print join \" \", %foo }; foo; delete local $foo{foo}; foo;\n"},{"out":"bar 2 foo 2bar 2foo 2 bar 2","err":"","code":"my %foo = (foo => 2, bar => 2); sub foo { print join \" \", %foo }; foo; { delete local $foo{foo}; foo }; foo;\n"},{"out":"[\"foo bar=baz big=\\\"some \\\\\\\"other\\\\\\\" thing\\\"\",\"dumb=today\"]","err":"","code":"my $foo = 'foo bar=baz big=\"some \\\"other\\\" thing\" dumb=today'; [split / (?![^\"]*?\")/, $foo]\n"},{"code":"my $foo = 'foo bar=baz big=\"some thing\" dumb=today'; [split / (?![^\"]*?\")/, $foo]\n","err":"","out":"[\"foo bar=baz big=\\\"some thing\\\"\",\"dumb=today\"]"},{"out":"[\"foo bar=baz big=\\\"some thing\\\"\",\"dumb=today\"]","err":"","code":"my $foo = 'foo bar=baz big=\"some thing\" dumb=today'; [split / (?![^\"]*\")/, $foo]\n"},{"out":"[2]","code":"my $foo =()= 'foo bar who owl scoop' =~ /oo/g; [ $foo ];\n","err":""},{"out":"0 1 2\n3\n","code":"my @foo; @foo = @foo || (0..2); say \"@foo\"; @foo = @foo || (5..7); say \"@foo\"\n","err":""},{"out":"quux","err":"","code":"my $foo = 'foo'; package Bar { my $foo = 'quux'; print $foo; }\n"},{"out":"{zot => \"asdf\"}","code":"my %foo; $foo{zot}=\"asdf\\n\"; chomp $foo{zot}; \\%foo;\n","err":""},{"out":"haha hello hihi","err":"","code":"my $foo = \"hello\"; print \"haha \" . $foo . \" hihi\";\n"},{"err":"","code":"my $foo = int 5; [~-$foo, -~$foo]\n","out":"[4,\"-1.84467440737096e+19\"]"},{"err":"","code":"my $foo = { key => [ 2, 3, 4] }; print @$foo{key}[1]\n","out":"ERROR: syntax error at (eval 1) line 1, near \"}[\"\n"},{"err":"","code":"my $foo = { key => [ 2, 3, 4] }; say @$foo{key}[1]\n","out":"ERROR: syntax error at (eval 1) line 1, near \"}[\"\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"} \"A\"\"\n","err":"","code":"my $foo = map { 0, 0, 0 } \"A\", \"B\", \"C\", \"D\"\n"},{"out":"12","code":"my $foo = map {; 0, 0, 0 } \"A\", \"B\", \"C\", \"D\"\n","err":""},{"code":"my $foo = map { 42 } \"A\", \"B\", \"C\", \"D\"\n","err":"","out":"4"},{"code":"my $foo = map { for (()) { } } qw(A B C) if 0;\n","err":"","out":"0"},{"code":"my $foo = map { if ($_ ne \"A\") return 0 } \"A\", \"B\", \"C\", \"D\"\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \") return\"\n"},{"err":"","code":"my $foo = map { if ($_ neq \"A\") 0 } \"A\", \"B\", \"C\", \"D\"\n","out":"ERROR: syntax error at (eval 1) line 1, near \"$_ neq \"\n"},{"code":"my $foo = map { $_ ne \"A\" ? 0 : () } \"A\", \"B\", \"C\", \"D\"\n","err":"","out":"3"},{"out":"[\"let's see\",undef]","code":"my $foo; my $bar;  (1 ? $foo : $bar) = \"let's see\"; [ $foo, $bar ]\n","err":""},{"err":"","code":"my $foo; my $bar = []; [$foo, $bar]\n","out":"[undef,[]]"},{"code":"my $foo = {}; my $k = \"dev/database/url\"; my $p = \\$foo; for my $n (split m{/}, $k) { $p = \\$$p->{$n}; } $$p = 42; $foo\n","err":"","out":"{dev => {database => {url => 42}}}"},{"out":"[\"bar\"]","code":"my $foo; my $ref = \\$foo; $$ref = 'bar'; [ $foo ]\n","err":""},{"out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"my $foo; my $ref = \\$foo; $ref++; $$ref = '\n","err":""},{"err":"","code":"my $foo; my $ref = \\$foo; $ref++; $$ref = 'bar'; [ $foo ]\n","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't modify constant item in substitution (s///) at (eval 1) line 1, at EOF\n","code":"my ($foo) = \"onetwothree\" =~ s/(tw.)//g; $foo\n","err":""},{"out":"2","err":"","code":"my %foo = ('â¥' => 'perllove');\n"},{"err":"","code":"my %foo = ('â¥' => 'perllove'); say $foo{'â¥'};\n","out":"perllove\n"},{"err":"","code":"my $foo; push @{$foo->{bar}{baz}}, 123; $foo\n","out":"{bar => {baz => [123]}}"},{"err":"","code":"my $foo; push @{$foo{bar}{baz}}, 123; $foo\n","out":""},{"out":"qr/^(?^u:bananas!)/u","code":"my $foo = qr/bananas!/; qr/^$foo/\n","err":""},{"out":"[3,4,1,2]","err":"","code":"my @foo = qw(1 2 3 4); push(@foo, splice(@foo, 0, 2)); [@foo]\n"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","err":"","code":"my @foo = qw(1 2 3 4); [ unshift(@foo, splice(@foo, 2, 2)); ]\n"},{"code":"my @foo = qw(1 2 3 4); unshift(@foo, splice(@foo, 2, 2)); [ @foo ]\n","err":"","out":"[3,4,1,2]"},{"out":"[3,4,1,2]","code":"my @foo = qw(1 2 3 4); unshift(@foo, splice(@foo, -2)); [ @foo ]\n","err":""},{"code":"my @foo = qw(a 1 b 2 c 3); open my $printer, '>', \\my $buffer; print $printer @foo; [$buffer, \"@foo\"]\n","err":"","out":"[\"a1b2c3\",\"a 1 b 2 c 3\"]"},{"out":"[5]","code":"my $foo = [qw/a b c d e/]; [ scalar @$foo ]\n","err":""},{"err":"","code":"my $foo = qw/azertyuiopqsdfghjklmwxcvbn/; $foo =~ s/(.{8})\\s.+?/$1/; $foo;\n","out":"azertyuiopqsdfghjklmwxcvbn"},{"code":"my %foo = qw(foo 1 bar 2 baz 3); @foo{keys %foo} = (); \\%foo;\n","err":"","out":"{baz => undef,bar => undef,foo => undef}"},{"out":"[\\\"foo\",\\\"bar\",\\\"baz\"]","code":"my @foo = qw(foo bar baz); [ \\(@foo) ]\n","err":""},{"out":"[[\"foo\",\"bar\",\"baz\"]]","err":"","code":"my @foo = qw(foo bar baz); [ \\@foo ]\n"},{"out":"\\\"baz\"","code":"my @foo = qw(foo bar baz); \\(@foo)\n","err":""},{"err":"","code":"my @foo = qw(foo bar baz); [ \\(@foo, 42) ]\n","out":"[[\"foo\",\"bar\",\"baz\"],\\42]"},{"out":"15","err":"","code":"my @foo = qw(foo bar baz); (@foo) = (@foo) x 5;\n"},{"out":"ERROR: Can't modify private array in repeat (x) at (eval 1) line 1, at EOF\n","err":"","code":"my @foo = qw(foo bar baz); (@foo) x= 5;\n"},{"out":"ERROR: Can't modify private array in repeat (x) at (eval 1) line 1, near \"5]\"\n","err":"","code":"my @foo = qw(foo bar baz); [(@foo) x= 5];\n"},{"out":"[\"foo\",\"bar\",\"baz\",\"foo\",\"bar\",\"baz\",\"foo\",\"bar\",\"baz\",\"foo\",\"bar\",\"baz\",\"foo\",\"bar\",\"baz\"]","code":"my @foo = qw(foo bar baz); [(@foo) x 5];\n","err":""},{"code":"my %foo = qw(foo bar baz qux kitties nip); my $ref = \\%foo; undef %foo; $ref\n","err":"","out":"{}"},{"err":"","code":"my @foo = qw(milk nip kitties meow); my @slice = @foo[2,3,2,1]; \\@slice\n","out":"[\"kitties\",\"meow\",\"kitties\",\"nip\"]"},{"out":"[[\"foo\",\"foo\"],[\"foo\",\"bar\"],[\"bar\",\"bar\"]]","code":"my @foo = split /\\s+/, \"foo bar\"; [ [ @foo[0,0] ], [ @foo[0,1] ], [ @foo[1,1] ] ]\n","err":""},{"code":"my $foo; sub bar { print \"[$foo]\"; } for $foo (\"hello\") { bar; }\n","err":"","out":"[]"},{"err":"","code":"my %foo; sub foo { print join \" \", %foo }; foo; local $foo{foo} = foo; foo;\n","out":"foo 1"},{"err":"","code":"my %foo; sub foo { print join(\" \", %foo }; foo; local $foo{foo} = foo; foo;\n","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"out":"1","err":"","code":"{ my $foo; sub plusfoo { $foo++ } sub getfoo { $foo } } plusfoo(); getfoo()\n"},{"out":"sub { \"DUMMY\" }","code":"my $foo = sub { return $foo };\n","err":""},{"out":"[1,2,3]","err":"","code":"my $foo = sub { shift }; [ map $foo->($_), 1, 2, 3 ]\n"},{"out":"[sub { \"DUMMY\" },$VAR1->[0],$VAR1->[0]]","err":"","code":"my $foo = sub { shift }; [ map $foo, 1, 2, 3 ]\n"},{"err":"","code":"my $foo = sub { shift }; [ map &$foo, 1, 2, 3 ]\n","out":"[\"my \\$foo = sub { shift }; [ map &\\$foo, 1, 2, 3 ]\",undef,undef]"},{"err":"","code":"my $foo = \"test\\x{327}\"; $foo =~ tr/\\x{327}/\\x{326}/; [$foo]\n","out":"[\"test\\x{326}\"]"},{"err":"","code":"(my $foo:)//= undef\n","out":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"$foo :\"\n","code":"my $foo ://= undef;\n","err":""},{"code":"my $foo //= undef;\n","err":"","out":""},{"out":"[]","err":"","code":"my $foo = undef; [ @$foo ]\n"},{"err":"","code":"my $foo = undef // say \"it broke!\"; [ $foo ]\n","out":"it broke!\n"},{"code":"my $found = 0; 0+($found == 7) # you pass a zero to exit, it will happily use that value\n","err":"","out":"0"},{"out":"yx\n","code":"my $f = \"s/l/y/g;s/k/x/g\"; my $s = \"lk\\n\"; $s = do { local $_ = $s; eval($f); $_ }; printf(\"%s\", $s)\n","err":""},{"code":"my $f = sub { [] }; @a = map { 0+ $f->($_) } 1..10;\n","err":"","out":"10"},{"err":"","code":"my $f = sub { [] }; @a = map { 0+ $f->($_) } 1..10; \\@a\n","out":"[59793136,56453672,59793136,56453672,59793136,56453672,59793136,56453672,59793136,56453672]"},{"out":"ERROR: Can't call method \"refaddr\" on unblessed reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my $f = sub { [] }; @a = map { refaddr $f->($_) } 1..10;\n"},{"out":"5 4 3 2 1 0 ","code":"my $f = sub { SUB: my ($n) = @_; print \"$n \"; $n or return; @_ = $n - 1; goto SUB; }; $f->(5);\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n","code":"$_ = \"my.funny-str is a string\"; [ [split /(?=[. -])/], [split /[. -]/]\n","err":""},{"code":"$_ = \"my.funny-str is a string\"; [ [split /(?=[. -])/], [split /[. -]/]]\n","err":"","out":"[[\"my\",\".funny\",\"-str\",\" is\",\" a\",\" string\"],[\"my\",\"funny\",\"str\",\"is\",\"a\",\"string\"]]"},{"out":"2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50","err":"","code":"my $gf = sub { (1..50) }; my $ev = sub { $_ % 2 == 0 }; print join \",\", grep { $ev->($_) }  $gf->()\n"},{"out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after ) = split(<-- HERE near column 132 at (eval 1) line 1, <STDIN> line 1.\n","code":"(my $good_stuff, my $throw_away) = split(â=â, $stuff);  # for comparison\n","err":""},{"out":"[[\"foo\",\"bar\",\"baz\\n\"]]","err":"","code":"my @groups; my $chunk = []; for my $x (\"foo\", \"bar\", \"baz\\n\", \"x\", \"y\", \"z\") { push @$chunk, $x; if ($x =~ /\\R\\z/) { push @groups, $chunk; $chunk = []; } } push @$groups, $chunk if @$chunk; [ @groups ]\n"},{"out":"ERROR: Search pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n","code":"my @groups; my $chunk = []; for my $x (\"foo\", \"bar\", \"baz\\n\", \"x\", \"y\", \"z\") { push @$chunk, $x; if ($x =~ /\\R\\z) { push @groups, $chunk; $chunk = []; } } push @$groups, $chunk if @$chunk; [ @groups ]\n","err":""},{"out":"[{},{}]","err":"","code":"my $h = {}; [ {}, {} ]\n"},{"code":"my $h = '09:12:34'; $h =~ s/0(\\d)(?=(?::\\d\\d){2})/$1/r;\n","err":"","out":"9:12:34"},{"code":"my $h = '09'; [ $h, 0+$h ];\n","err":"","out":"[\"09\",9]"},{"out":"","code":"my %h = (a => 1); ++$_ for keys %h;\n","err":""},{"err":"","code":"my %h = (a = 1); ++$_ for keys %h;\n","out":"ERROR: Can't modify constant item in scalar assignment at (eval 1) line 1, near \"1)\"\n"},{"code":"my %h = (a => 1); ++$_ for keys %h; \\%h;\n","err":"","out":"{a => 1}"},{"code":"my %h = (a => 1); ++$_ for values %h; \\%h;\n","err":"","out":"{a => 2}"},{"code":"my %hash = ( 1 => '', 2 => '', 1 => '');  \\%hash\n","err":"","out":"{1 => \"\",2 => \"\"}"},{"err":"","code":"my $hash = { a=>1, b=>2 }; delete $hash->{(keys %{$hash})[0]}\n","out":"2"},{"out":"","code":"my $hash = { a=>1, b=>2 }; delete $hash{(keys %{$hash})[0]}\n","err":""},{"err":"b, 2, a, 1 at (eval 1) line 1, <STDIN> line 1.\n","code":"my %hash = (a => 1, b => 2); mySub(%hash); sub mySub { my (%hash) = @_; warn join ', ', %hash }\n","out":"1"},{"out":"1","err":"1 at (eval 1) line 1, <STDIN> line 1.\n","code":"my %hash = (a => 1, b => 2); mySub(%hash); sub mySub { my (%h) = @_; warn $h{a} }\n"},{"out":"def jkl;","err":"","code":"my %hash = ( abc => 'def', asdf => 'jkl;' ); print join ' ', @hash{abc,asdf}\n"},{"err":"","code":"my %hash = ( abc => 'def', asdf => 'jkl;' ); print join ' ', @hash{abc,def}\n","out":"def "},{"out":"SomeClass","code":"my %hash; bless \\%hash, \"SomeClass\";  ref \\%hash;   # <== tm604: \u0002*technically*\u0002 it's the referrant itself, and not the reference\n","err":""},{"out":"HASH","code":"my %hash; bless \\%hash, \"SomeClass\";  ref \\%somehash;   # <== tm604: \u0002*technically*\u0002 it's the referrant itself, and not the reference\n","err":""},{"err":"","code":"my %hash = (foo => !!1); $hash{foo} = 1\n","out":"1"},{"err":"","code":"my %hash = (foo => [ 4 ]); $ hash { 'foo' } [ 0 ]\n","out":"4"},{"out":"{\"baz\":\"bra\",\"foo\":\"bar\"}","code":"my %hash = (foo => \"bar\", baz => \"bra\"); use JSON::XS; encode_json \\%hash\n","err":""},{"out":"bar","code":"my %hash = (foo => 'bar'); (%hash)[1]\n","err":""},{"err":"","code":"my %hash = (foo => 'bar'); (values %hash)[0];\n","out":"bar"},{"code":"my @hash = %hash; print @hash\n","err":"","out":"1"},{"err":"","code":"my %hash; if ($hash{foo} eq $hash{bar}) { print \"OMG\" }\n","out":"OMG"},{"out":"[\"1/256\"]","code":"my %hash; keys %hash = 200; $hash{abc} = 1; [scalar %hash]\n","err":""},{"out":"[1,2,3,4,5]","code":"my %hash; my @array1 = qw/ 1 2 3 4 /; my @array2 = qw/ 3 4 5 /;    @hash{@array1,@array2} = ();   my @combined = sort keys %hash;    [ @combined ]\n","err":""},{"code":"my %hash; my %dash = (qw/a 1 b 2/); [ scalar %hash, scalar %dash ]\n","err":"","out":"[0,\"2/8\"]"},{"out":"8\n16\n32\n64\n128\n256\n512\n","err":"","code":"my %hash; my $prior = \"\"; for my $new (1..1000) { ++$hash{$new}; print \"$new\\n\" if $prior ne join \" \", grep $_ != $new, keys %hash; $prior = join \" \", keys %hash }\n"},{"code":"my %hash; my $str = \"foo:12 bar:34 baz:45\"; @hash{'foo', 'bar', 'baz'} = $str =~ /foo:(\\d+) bar:(\\d+) baz:(\\d+)/; \\%hash\n","err":"","out":"{baz => 45,bar => 34,foo => 12}"},{"err":"","code":"my %hash; my $val1 = $hash{a}; my $val2 = $hash{b} if exists $hash{b}; [keys %hash]\n","out":"[]"},{"err":"","code":"my %hash = (one => [1, 2, 4]);\n","out":"2"},{"err":"","code":"my %hash = (one => [1, 2, 4]); sub bar { \tmy $href = shift @_; \tpush @{$href->{one}}, 5; } bar(\\%hash); @{$hash{one}};\n","out":"4"},{"err":"","code":"my %hash = (one => [1, 2, 4]); sub bar { \tmy $href = shift @_; \tpush @{$href->{one}}, 5; } bar(\\%hash); print @{$hash{one}};\n","out":"1245"},{"out":"[2,2]","err":"","code":"my $hash = {one=>1,two=>2,three=>2}; [ grep $_ == 2, values %$hash ]\n"},{"code":"my $hash = {one=>1,two=>2,three=>2};[  @{$hash}{ grep $hash->{$_} == 2, keys %$hash } ] # then as huf said, use something like this. seems a bit pointless though\n","err":"","out":"[2,2]"},{"out":"[\"one\",1,\"two\",2]","code":"my %hash = ( one => 1, two => 2, three => 3 );  [ %hash{qw(one two)} ]\n","err":""},{"out":"[\"one,\",undef,\"two\",2]","code":"my %hash = ( one => 1, two => 2, three => 3 );  [ %hash{qw(one, two)} ]\n","err":""},{"out":"[\"one\",\"baz\"]","err":"","code":"my %hash = (one => 'foo'); sub bar { my ($href) = @_; $href->{one} = 'baz'; } bar(\\%hash);  [ %hash ]\n"},{"out":"[\"one\",\"foo\"]","code":"my %hash = (one => 'foo'); sub bar { my $href = @_; $href->{one} = 'baz'; } bar(\\%hash);  [ %hash ]\n","err":""},{"out":"one\nthree\n","err":"","code":"my %hash = (one => two, three => four); say for keys %hash;\n"},{"out":"one\n","err":"","code":"my %hash = one => two, three => four; say for keys %hash;\n"},{"err":"","code":"my %hash; push @{$hash{foo}}, 3; \\%hash\n","out":"{foo => [3]}"},{"out":"{}","code":"@{\\my %hash}{qw(a b)} = (1, 2); \\%hash\n","err":""},{"code":"my $hash = {ref => [1, 2, 3]}; while(my $num = $hash->{ref}->CORE::each) {print $num, \" => \";}\n","err":"","out":"ERROR: Can't call method \"each\" on unblessed reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"20001","err":"","code":"my $hashref = { 20001 => {} }; my ($key) = %$hashref; $key\n"},{"err":"","code":"my $hashref = { 20001 => {} }; my ($key) = %$hr; $key\n","out":""},{"out":"","err":"","code":"my $hash_ref = { 'foo' => 'bar' }; $hash_ref{'foo'};\n"},{"out":"ERROR: Not an ARRAY reference at (eval 1) line 1, <STDIN> line 1.\n","code":"my $hashref = { foo => 'bar' }; my $doesntwork = $#$hashref;\n","err":""},{"out":"[{one => \"falcom\",three => \"Isaac Newton\",two => \"rindolf\"}]","err":"","code":"my $hash_ref = {'one' => 'falcom', 'two' => 'rindolf'}; my $d = { %$hash_ref, 'three' => \"Isaac Newton\"}; [$d]\n"},{"code":"my %hash; scalar %hash\n","err":"","out":"0"},{"code":"my %hash = (thing => SOME_CONSTANT() ); sub SOME_CONSTANT { 5 }; $hash{thing}\n","err":"","out":"5"},{"err":"","code":"my %hash = (thing => SOME_CONSTANT); sub SOME_CONSTANT { 5 }; $hash{thing}\n","out":"SOME_CONSTANT"},{"code":"my %hash = (x=>123); %hash = (); \\%hash\n","err":"","out":"{}"},{"err":"","code":"my %h = (a..z); ${%h}{\"how strange\"} = \"is this, anyway?\"; \\%{%h};\n","out":"{\"how strange\" => \"is this, anyway?\"}"},{"out":"6/1626/64","err":"","code":"my %h = (a..z); ${%h}{\"ignore the man\"} = \"behind the curtain\"; print scalar %h; undef $h{$_} for 1..20; print scalar %h;\n"},{"err":"","code":"my %h = (a..z); ${%h}{\"ignore the man\"} = \"behind the curtain\"; undef $h{$_} for 1..20; \\%{%h};\n","out":"{}"},{"out":"{b => \"bluh\",x => \"y\",a => \"bleh\"}","code":"my %hb = (a => 'bleh', b => 'bluh'); my %ha = (a => 'woo', x => 'y', %hb); \\%ha;\n","err":""},{"err":"","code":"my @headers = qw(foo bar ibytes pickles);\n","out":"4"},{"out":"5","code":"my @headers = qw(hits bytes ihits ibytes ips);\n","err":""},{"code":"my %h = (); exists $h{foo}->{bar}; print exists $h{foo}\n","err":"","out":"1"},{"err":"","code":"my $hex = q{6060FF}; [ hex($hex), [ unpack q{L>*}, pack q{H*}, map { sprintf q{%08s}, $_; } ( $hex =~ s!^0x!!r) =~ m!(^.{2,6}|.{2,8})!g ] ]; ### How to do what hex() does with pack/unpack. Is there a cleaner / less-hackier way?\n","out":"[6316287,[6316287]]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"what hex\"\n","err":"","code":"my $hex = q{6060FF}; [ hex($hex), [ unpack q{L>*}, pack q{H*}, map { sprintf q{%08s}, $_; } ( $hex =~ s!^0x!!r) =~ m!(^.{2,6}|.{2,8})!g ] ]; How to do what hex() does with pack/unpack. Is there a cleaner / less-hackier way?\n"},{"out":"[6316287,[101121792]]","err":"","code":"my $hex = q{6060FF}; [ hex($hex), [ unpack q{N*}, pack q{(h8)*}, $hex ] ];\n"},{"code":"my $hex = q{6060FF}; [ hex($hex), [ unpack q{N*}, pack q{(H8)*}, $hex ] ];\n","err":"","out":"[6316287,[1616969472]]"},{"out":"[6316287,[1616969472]]","code":"my $hex = q{6060FF}; [ hex($hex), [ unpack q{N}, pack q{H8}, q{6060FF} ] ] # How to do the equivilent of hex() with pack/unpack functions?\n","err":""},{"code":"my $hex = q{6060FF}; [ hex($hex), [ unpack q{N}, pack q{H*}, q{6060FF} ] ] # with H* it is only three bytes and apparently rejected by V/N/I/L\n","err":"","out":"[6316287,[]]"},{"err":"","code":"my $hex = q{6060FF}; [ hex($hex), [ unpack q{V*}, pack q{(h8)*}, $hex ] ];\n","out":"[6316287,[16713222]]"},{"err":"","code":"my $hex = q{6060FF}; [ hex($hex), [ unpack q{V*}, pack q{(H8)*}, $hex ] ];\n","out":"[6316287,[16736352]]"},{"out":"6ÃÂÃÂ4F\u0013xaC0","code":"my $hex = unpack(\"H*\", pack(\"Q<\", 1397463445)); my $td = pack(\"H*\", unpack(\"Q<\",$hex)); $td;\n","err":""},{"out":"1","err":"","code":"my $h = { foo => 42 }; $h == \\%{$h}\n"},{"err":"","code":"my %h = ( foo => { bar => {ber => [boor] } } ); my $ar = $h{foo}{bar}{ber}; push @$ar, 'foor';  \\%h\n","out":"{foo => {bar => {ber => [\"boor\",\"foor\"]}}}"},{"out":"[20,21,22,23,24,25,26,27,28,29,30]","err":"","code":" my %h; @h{(20..34)} = (); [(sort keys %h)[0..10]];\n"},{"out":"c 3d 4","code":"my %h=(); %h=( 'a'=>'1', 'b'=>'2' ); %h=( 'c'=>'3', 'd'=>'4' ); for ( sort keys %h ){ print \"$_ $h{$_}\" };\n","err":""},{"err":"","code":"my %h; @{ $h{a}{b} } = qw/c d e/; \\%h\n","out":"{a => {b => [\"c\",\"d\",\"e\"]}}"},{"err":"","code":"my $h = \"Hello world!\"; $h =~ s/(.)(.)/$2$1/g; $h\n","out":"eHll oowlr!d"},{"code":"my $h = \"Hello world!\"; $h =~ s/(.)(.)/\\U$2\\E$1/g; $h\n","err":"","out":"EHLl oOwLr!d"},{"code":"my %h=(); %h=getone(); sub getone {return ('a'=>'1','b'=>'2')}; %h=gettwo(); sub gettwo { return('c'=>'3','d'=>'4')}; for ( sort keys %h ){ print \"$_ $h{$_}\" };\n","err":"","out":"c 3d 4"},{"code":"my %h=(); %h=getone(); sub getone {return ('a'=>'1','b'=>'2')}; %h=gettwo(); sub gettwo { return undef}; for ( sort keys %h ){ print \"[$_] $h{$_}\" }\n","err":"","out":"[] "},{"err":"","code":"my %h=(); %h=getone(); sub getone {return ('a'=>'1','b'=>'2')}; %h=gettwo(); sub gettwo { return undef}; for ( sort keys %h ){ print \"$_ $h{$_}\" }\n","out":" "},{"code":"my %h=(); %h=getone(); sub getone {return ('a'=>'1','b'=>'2')}; %h=gettwo(); sub gettwo { return undef}; for ( sort keys %h ){ print \"$_ $h{$_}\" };\n","err":"","out":" "},{"code":"my $h = {}; [ $h, $h ]\n","err":"","out":"[{},$VAR1->[0]]"},{"out":"a 1b 2c 3d 4","err":"","code":"my %h=(); %h=(%h, 'a'=>'1', 'b'=>'2' ); %h=(%h, 'c'=>'3', 'd'=>'4' ); for ( sort keys %h ){ print \"$_ $h{$_}\" };\n"},{"out":"{key => [undef,undef,{anotherkey => \"hello\"}]}","code":"my $h; $h->{key}[2]{anotherkey} = \"hello\"; $h\n","err":""},{"out":"2","err":"","code":"my %h=(); %h={return ('a'=>'1','b'=>'2')}; %h={ return('c'=>'3','d'=>'4')}; for ( sort keys %h ){ print \"$_ $h{$_}\" };\n"},{"out":"{two => sub { \"DUMMY\" }}","code":"my %h; $h{two} = sub { \\%h }; $h{two}->()->{two}->()\n","err":""},{"code":"my %h; $h{x}{y}{z} = 123; \\%h # sure\n","err":"","out":"{x => {y => {z => 123}}}"},{"code":"my %h = (map { $_ => 2*$_ } 1 .. 10); [ %h{3,5,8} ]\n","err":"","out":"[3,6,5,10,8,16]"},{"out":"18","err":"","code":"my %h = (map { $_ => 3*$_  } 1.. 10); { %h{(1,4,6)} }\n"},{"out":"{6 => 18,1 => 3,4 => 12}","code":"my %h = (map { $_ => 3*$_  } 1.. 10); +{ %h{(1,4,6)} }\n","err":""},{"out":"[{foo => {bar => {bizbaz => {cats => 1}}}}]","err":"","code":"my %h; my $p = \\%h; $p = $p->{$_} //= {} for qw/foo bar bizbaz/; $p->{cats} = 1; [ \\%h ]\n"},{"out":"ERROR: Experimental push on scalar is now forbidden at (eval 1) line 1, at EOF\n","code":"my %h = (one => [1,2,4]); sub bar { my ($href) = @_; push ${$href->{one}}, 5; } bar(\\%h); @{$h{one}}\n","err":""},{"code":"my %h = ( one => 1, two => 2 ); [ %h{qw( one three )} ]\n","err":"","out":"[\"one\",1,\"three\",undef]"},{"out":"bar\nber\n","code":"my %h = qw/foo bar baz ber/; say $h{foo}; my $x = 'baz'; say $h{$x}\n","err":""},{"err":"","code":"my %h = qw(must 1 should 2 could 3); [ sort {$h{$a} <=> $h{$b}} qw(must should could could must could should must) ]\n","out":"[\"must\",\"must\",\"must\",\"should\",\"should\",\"could\",\"could\",\"could\"]"},{"out":"{a => 5}","code":"my $hr = {a => 5}; my @arr; push @arr, %$hr; my %hash = @arr; \\%hash\n","err":""},{"err":"","code":"my $hr = {a => 5}; my %hash; $hash{hashref}=$hr; $hash{hashref}{a}\n","out":"5"},{"code":"my $hr = { asdf => 5 }; (%$hr)[1]\n","err":"","out":"5"},{"out":"5","code":"my $hr = { asdf => 5 }; (values %$hr)[0]\n","err":""},{"code":"my $href = { foo => 42, bar => 37 }; keys %$href - 3\n","err":"","out":"ERROR: Experimental keys on scalar is now forbidden at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"my $href = { foo => 42, bar => 37 }; keys(%$href) - 3\n","err":"","out":"-1"},{"out":"","code":"my $href; %$href\n","err":""},{"code":"my $href; $href->{key} = {}; my $other = $href->{key}; $other->{bar} = 1; $href\n","err":"","out":"{key => {bar => 1}}"},{"out":"{key => {bar => 1}}","code":"my $href; my $other = $href->{key} ||= {}; $other->{bar} = 1; $href\n","err":""},{"out":"not empty","err":"","code":"my $hr = {searchable => {phones => \"bullshit\"}}; unless ($hr->{searchable}->%*) { \"Empty\" } else { \"not empty\" };\n"},{"code":"my $hr = {searchable => {}}; unless ($hr->{searchable}->%*) { \"Empty\" } else { \"not empty\" };\n","err":"","out":"Empty"},{"code":"my $html = \"<html><body><div>and stuff</div></body></html>\"; $html->find\n","err":"","out":"ERROR: Can't locate object method \"find\" via package \"<html><body><div>and stuff</div></body></html>\" (perhaps you forgot to load \"<html><body><div>and stuff</div></body></html>\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"my $hw = \"Hello World!\\n\"; print $hw;\n","out":"Hello World!\n"},{"out":"{x => \"abc\",y => \"def\"}","err":"","code":"my %h = (x => \"abc123\", y => \"def456\"); map { tr/a-z//dc } values %h; \\%h\n"},{"out":"{x => \"abc\",y => \"def\"}","code":"my %h = (x => \"abc123\", y => \"def456\"); tr/a-z//dc for values %h; \\%h # are you trying to do something like this\n","err":""},{"out":"5","code":"my $i = 0; HERE: { HERE: { HERE: { HERE: goto HERE unless $i++ > 3 } } }  print $i\n","err":""},{"out":"1","err":"","code":"my $i = 0; while ( $i <= 10) { print; $i++; } print $_;\n"},{"code":"my $i = 5; ++$i++\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"$i++\"\n"},{"out":"0","code":"my @ids = $page_content =~ m!http://www\\.liveleak\\.com/view\\?i=(\\w{14})!g;\n","err":""},{"code":"my $idx = 0; my @group; push @{$group[/\\R$/ ? $idx++ : $idx]}, $_ for  \"foo\", \"bar\", \"baz\\n\", \"x\", \"y\", \"z\"; \\@group # something like that?\n","err":"","out":"[[\"foo\",\"bar\",\"baz\\n\"],[\"x\",\"y\",\"z\"]]"},{"out":"%01","code":"my $imagecount = \"\"; my $foo = \"%0\" . length $imagecount . \"d\";\n","err":""},{"out":"[0,0,0]","err":"","code":"my $i; { my $foo; sub get_foo { $foo //= $i++ } } [get_foo, get_foo, get_foo]\n"},{"err":"","code":"my @in = 1..3; my @out = grep { $_++ } @in; [ \\@in, \\@out ] # far as I recall, List::UtilsBy has an explicit local $_ = $_; to avoid this sort of behaviour, so presumably ::XS doesn't have an equivalent\n","out":"[[2,3,4],[2,3,4]]"},{"code":"my $indents = () = \"        \" =~ /(\\t|\\s{4})/g\n","err":"","out":"2"},{"err":"","code":"my @index; $_ = \"  * *    * ** \"; while(/\\G[^*]*\\*/gc) { push @index, pos } \\@index\n","out":"[3,5,10,12,13]"},{"out":"5","err":"","code":"my $ind = index(fc 'test string', fc 'STRING'); $ind;\n"},{"out":"-1","err":"","code":"my $ind = index('test string', 'STRING'); $ind;\n"},{"err":"","code":"my $input = 'Ù£'; say $input + 42;\n","out":"42\n"},{"out":"[\"02020111 48850386 11fbff42 01000008 00000000 00000086\"]","err":"","code":"my @input = map pack('H2', $_), qw(02 02 01 11 48 85 03 86 11 FB FF 42 01 00 00 08 00 00 00 00 00 00 00 86); [ join ' ', map sprintf(\"%08x\", unpack('N1', $_)), join('', @input) =~ /..../g ] # you're asking for this?\n"},{"err":"","code":"my $input = \"Number 123 here won't be matched, but <number 666, the number of the beast> will.\"; my $match_mode = 0; while ($input =~ /(\\d+)|(<)|(>)/g) { if ($1 and $match_mode) { print $1; } if ($2) { $match_mode = 1; } if ($3) { $match_mode = 0; }}\n","out":"666"},{"out":"666","err":"","code":"my $input = \"Number 666 will match, but not <number 123 here>, ok?\"; my $match_mode = 1; while ($input =~ /(\\d+)|(<)|(>)/g) { if ($1 and $match_mode) { print $1; } if ($2) { $match_mode = 0; } if ($3) { $match_mode = 1; }}\n"},{"out":"7f000000.00000000.00000000.01000000","err":"","code":"my $ip = '127.0.0.1'; $ip =~ s#(\\d+)#unpack( \"H*\", pack( \"V1\",$1))#ge; $ip\n"},{"out":"","code":"my $ip = '127.0.0.1'; $ip =~ s#(\\d+)#unpack( \"H*\", pack( \"V1\",$1))#ge; $ip =~ s#.##g; $ip\n","err":""},{"err":"","code":"my $ip = '127.0.0.1'; $ip =~ s#(\\d+)#unpack( \"H*\", pack( \"V1\",$1))#ge; $ip =~ s#.#g; $ip\n","out":"ERROR: Substitution replacement not terminated at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"my $ip = '127.0.0.1'; $ip =~ s#(\\d+).?#unpack( \"H*\", pack( \"v\",$1))#ge; $ip\n","err":"","out":"7f00000000000100"},{"out":"[0,0,0]","err":"","code":"my $i; sub get_foo { state $foo = $i++ } [get_foo, get_foo, get_foo]\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \":(\"\n","code":"my $karma = 27; sub mst :() :lvalue { $karma } mst++; $karma\n","err":""},{"code":"my $karma = 27; sub mst :lvalue { $karma } mst++; $karma\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","err":"","code":"my $karma = 27; sub mst() :lvalue { $karma } mst++; $karma\n"},{"out":"28","code":"my $karma = 27; sub mst :lvalue { $karma } mst()++; $karma # actually, might just be this?\n","err":""},{"out":"foo","err":"","code":"my $key = 'a'; $hash{$key} = 'foo'; print $hash{$key};\n"},{"code":"my @keys = (1..10); ++$_ for @keys; \\@keys\n","err":"","out":"[2,3,4,5,6,7,8,9,10,11]"},{"out":"4,294,967,296","code":"my $L = 2**32; join \"\", reverse split //, ((reverse $L) =~ s/(\\d{3})/$1,/rg);\n","err":""},{"out":"4,492,769,692,","err":"","code":"my $L = 2**32; local $\\ = ','; print for reverse unpack '(A3)*', scalar reverse $L\n"},{"code":"my $L = 2**32; local $\\ = ','; print reverse unpack '(A3)*', scalar reverse $L\n","err":"","out":"4492769692,"},{"code":"my $L = 2**32; $L =~ s/(?<=\\d)(?=(?:\\d{3})+(?!\\d))/,/rg\n","err":"","out":"4,294,967,296"},{"out":"4,294,967,296","err":"","code":"my $L = 2**32; $L =~ s/\\d\\K(?=(?:\\d{3})+(?!\\d))/,/rg\n"},{"code":"my $l = 2**32; my $s = join \"\", reverse split //, $l; $s =~ s/(\\d{3})/$1,/g; join \"\", reverse split //, $s\n","err":"","out":"4,294,967,296"},{"err":"","code":"my $L = 2**32; reverse reverse($L) =~ s/(\\d{3})/$1,/rg\n","out":"4,294,967,296"},{"code":"my $L = 2**32; scalar reverse join ',', unpack '(A3)*', scalar reverse $L\n","err":"","out":"4,294,967,296"},{"out":"stuff5","code":"my $l = 4; \"stuff\" . ( $l + 1 );\n","err":""},{"code":"my $l = 4; \"stuff\" . $l + 1;\n","err":"","out":"1"},{"err":"","code":"my $lambda = sub { shift()+1 }; @a=1..4; [{map{$_=>$lambda->($_)}@a[0..@a/2-1]},{map{$_=>$lambda->($_)}@a[@a/2..$#a]}]\n","out":"[{1 => 2,2 => 3},{4 => 5,3 => 4}]"},{"out":"[123,456,456,456,456]","err":"","code":"my $last; [ map { $last = $_ // $last } ( 123, 456, undef, undef, undef ) ]\n"},{"code":"my $last; [ map { $last = $_ // $last } qw[ 123, 456, undef, undef, undef ] ]\n","err":"","out":"[\"123,\",\"456,\",\"undef,\",\"undef,\",\"undef\"]"},{"out":"%-5s","err":"","code":"my $lengths = { mach => 5 }; \"%-$lengths->{mach}s\" # you want this, right?\n"},{"code":"my $line = \"COMP2711|3713452|Warren, Ahmad|3645/2|M\"; $line =~ s/\\|(.+), (.+)\\|/$2$1/; print $line;\n","err":"","out":"COMP2711Ahmad|3645/23713452|WarrenM"},{"out":"COMP2711|3713452|Warren, Ahmad|3645/2|M","err":"","code":"my $line = \"COMP2711|3713452|Warren, Ahmad|3645/2|M\"; print $line;\n"},{"out":"1 => answer > 0, 2 => answer = answer + 2","code":"my $line = \"if answer > 0: answer = answer + 2\"; if(0) { } elsif($line =~ /^\\s*if (.*): (.*)/) { print \"1 => $1, 2 => $2\" }\n","err":""},{"out":"The verb is <take> and the other arguments are <cat>","err":"","code":"my $line = \"take cat\";  my ( $verb, @others ) = split m/\\s+/, $line;  \"The verb is <$verb> and the other arguments are <@others>\"\n"},{"code":"my @list = qw(foo bar foo baz kitties meow); 3 + @list\n","err":"","out":"9"},{"out":"{kitties => \"meow\",foo => \"baz\"}","err":"","code":"my @list = qw(foo bar foo baz kitties meow); my %hash = @list; \\%hash\n"},{"code":"my @l = qw/2 4 6/; my @f; for ( my $i=0; $i<@l; $i++ ) { my $x = $l[$i]; push @f, sub { 3 * $x; }; } [ map { $_->(); } @f ];\n","err":"","out":"[6,12,18]"},{"out":"[0,0,0]","err":"","code":"my @l = qw/2 4 6/; my @f; for ( my $i=0; $i<@l; $i++ ) { push @f, sub { 3 * $l[$i]; }; } [ map { $_->(); } @f ];\n"},{"out":"[\"some foo1 string\",\"foo2\",\"foo3\"]","code":"my @l = qw(foo1 foo2 foo3); my $foo1 = \\ $l[0]; $$foo1 = 'some foo1 string'; \\@l\n","err":""},{"out":"foocats                             bar","err":"","code":"my %map = (param1 => 'cats', param2 => 'botje'); my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \\{ ([^{]+) \\}/push @params, $2; $1 . 's'/gex; printf $str, map {$map{$_}} @params\n"},{"out":"[\"\",\"\"]","err":"","code":"my ($mapped, $grepped); map { $mapped = wantarray } 1; grep { $grepped = wantarray } 1; [$mapped, $grepped]\n"},{"code":"my %map = ('\\t' => \"\\t\", '\\r' => \"\\r\", '\\n' => \"\\n\"); my $x = q{FOO\\tBAR\\r\\n}; my $y = s/(\\\\[trn])/$map{$1}/ge; [$x, $y]\n","err":"","out":"[\"FOO\\\\tBAR\\\\r\\\\n\",\"\"]"},{"code":"my %map = ('\\t' => \"\\t\", '\\r' => \"\\r\", '\\n' => \"\\n\"); my $x = q{FOO\\tBAR\\r\\n}; my $y = s/(\\\\[trn])/$map{$1}/gre; [$x, $y]\n","err":"","out":"[\"FOO\\\\tBAR\\\\r\\\\n\",undef]"},{"out":"[\"FOO\\\\tBAR\\\\r\\\\n\",\"FOO\\tBAR\\r\\n\"]","err":"","code":"my %map = ('\\t' => \"\\t\", '\\r' => \"\\r\", '\\n' => \"\\n\"); my $x = q{FOO\\tBAR\\r\\n}; my $y = $x =~ s/(\\\\[trn])/$map{$1}/gre; [$x, $y]\n"},{"out":"[\"bar\",\"baz\"]","err":"","code":"my @matches = \"foobarbaz\" =~ /(ba.)/g; \\@matches\n"},{"out":"here","code":"my $meth = sub { 'here' }; main->$meth\n","err":""},{"out":"here","code":"my $meth = sub { 'here' }; notmain->$meth\n","err":""},{"out":"here","err":"","code":"my $meth = sub { 'here' }; undef->$meth\n"},{"code":"my @m; push @m, $1 ? [ digit => $1 ] : [ space => $2 ] while \"foo 3 5 1 7 bar\" =~ m/(\\d+)|(\\s+)/g; \\@m\n","err":"","out":"[[\"space\",\" \"],[\"digit\",3],[\"space\",\" \"],[\"digit\",5],[\"space\",\" \"],[\"digit\",1],[\"space\",\" \"],[\"digit\",7],[\"space\",\" \"]]"},{"out":"","code":"my $my->{my}\n","err":""},{"out":"ERROR: Can't redeclare \"my\" in \"my\" at (eval 1) line 1, at end of line\nCan't redeclare \"my\" in \"my\" at (eval 1) line 1, at end of line\n","code":"my (my (my $delilah))\n","err":""},{"out":"ERROR: No such class My at (eval 1) line 1, near \"; my My\"\nsyntax error at (eval 1) line 1, near \"$my :\"\n","code":"my My $my :Delilah;\n","err":""},{"out":"ERROR: Can't redeclare \"my\" in \"my\" at (eval 1) line 1, at end of line\n","code":"my (my $x)\n","err":""},{"code":"my $n = 0; while(1){print $n.\" \"; $n = $n+1;}\n","err":"Out of memory!\n","out":""},{"err":"","code":"my $n = 20; my $t = 0; my @c; while ($n) { push @c, 1 << $t if $n & 1; $n >>= 1; $t++; } \\@c\n","out":"[4,16]"},{"err":"","code":"my $n = 3; my $str = q(|1|2a|3abc|4abcd|5abcde); [join q(|), (split /\\|/, $str)[0..$n]];\n","out":"[\"|1|2a|3abc\"]"},{"code":"my $name = \"nonconvergent\"; my $s = \"Hello $name - what's up?\"; [$s]\n","err":"","out":"[\"Hello nonconvergent - what's up?\"]"},{"err":"","code":"my @names = qw(one two three); my @numbers = qw(1 2 3); for(0..$#numbers) { print $numbers[$_] . ' - ' . $names[$_] if $numbers[$_] == 2} # one option is to iterate by index rather than element\n","out":"2 - two"},{"out":"xx_xx_xx_xx","code":"my $name = 'xx.xx.xx.xx'; $name =~ s/\\./_/g; $name\n","err":""},{"err":"","code":"my %notes = qw/0 C 2 D/; [ @notes{0,2} ]\n","out":"[\"C\",\"D\"]"},{"out":"b","code":"my $not_really_an_array = (\"a\", \"b\"); $not_really_an_array # no arrays here\n","err":""},{"code":"my $n=split(/\\|/,\"one|two|three|four\");\n","err":"","out":"4"},{"code":"'my $num = 10; my  $res = ($num > 15 and $num < 30) ? \"Num is out of range\" : \"Num is in range\"; print $res .\"\\n\";'\n","err":"","out":"my $num = 10; my  $res = ($num > 15 and $num < 30) ? \"Num is out of range\" : \"Num is in range\"; print $res .\"\\n\";"},{"out":"Num is in range\n","code":"my $num = 10; my  $res = ($num > 15 and $num < 30) ? \"Num is out of range\" : \"Num is in range\"; print $res .\"\\n\";\n","err":""},{"err":"","code":"my $num = 42; my @array = (1, 2, qr/2$/); $num ~~ @array\n","out":"1"},{"out":"ERROR: wat at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my $num = 42; my @array = (1, 2, sub { die \"wat\" }); $num ~~ @array\n"},{"code":"my $num = 50; my $bitstring = unpack 'b*', $num;\n","err":"","out":"1010110000001100"},{"err":"","code":"my $num = 50; my $bitstring = unpack 'B*', $num;\n","out":"0011010100110000"},{"out":"163026885721590438","err":"Octal number > 037777777777 non-portable at (eval 1) line 11, <STDIN> line 1.\n","code":"my $num = \"99839489327429485246\"; $num =~ tr/89/01/; oct $num\n"},{"err":"","code":"my $number = grep { $_ == 2 } (1, 2, 2, 2, 3); $number\n","out":"3"},{"out":"azertyu iopqsdfghjklmwxcvbn","code":"my $obj = \"azertyu iopqsdfghjklmwxcvbn\"; $obj =~ s/(.{8})\\s.+?/$1/; $obj;\n","err":""},{"code":"my $obj = \"azertyui opqsdfghjklmwxcvbn\"; $obj =~ s/(.{8})\\s.+?/$1/; $obj;\n","err":"","out":"azertyuipqsdfghjklmwxcvbn"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"my $obj = \"azertyui opqsdfghjklmwxcvbn\"; $obj =~ s/(.{8})\\s[^\\n]+/$1/; [$obj;]\n","err":""},{"out":"[\"azertyui\"]","code":"my $obj = \"azertyui opqsdfghjklmwxcvbn\"; $obj =~ s/(.{8})\\s[^\\n]+/$1/; [$obj]\n","err":""},{"out":"[bless( {}, 'main' ),$VAR1->[0],$VAR1->[0]]","err":"","code":"my $obj = bless {};  ($a, $b, $c) = ($obj) x 3; [$a, $b, $c]\n"},{"code":"my %old = (1..10); +{ %old{1,5,7} }\n","err":"","out":"{7 => 8,5 => 6,1 => 2}"},{"code":"my %old_hash = (1 => 2, 3 => undef); my %new_hash = reverse %old_hash; \\%new_hash\n","err":"","out":"{2 => 1,\"\" => 3}"},{"code":"my %old_hash = (1 => 2, 3 => undef); my %new_hash = reverse %old_hash; %new_hash\n","err":"","out":"1/8"},{"code":"my $one = \"1\"; my $two = $one + \"0 but true\"; [ $one ^ $one ];\n","err":"","out":"[0]"},{"out":"[0]","code":"my $one = 1; my $two = $one . \" used as a string?\"; [ $one ^ $one ];\n","err":""},{"out":"[\"\\0\"]","code":"my $one = \"1\"; [ $one ^ $one ];\n","err":""},{"code":"my $one = 1; [ $one ^ $one ];\n","err":"","out":"[0]"},{"out":"ERROR: Can't use 'defined(@array)' (Maybe you should just omit the defined()?) at (eval 1) line 1, <STDIN> line 1.\n","code":"my @one = qw(1 2 3); @one = (); my @two; @two = (); [ (defined(@one) ? 'defined' : 'undef'), (defined(@two) ? 'defined' : 'undef') ]\n","err":""},{"err":"","code":"my $optional = 1; my $alternative = 1; print ([\"\", \"Optional.\", \"Alternative.\", \"Optional and alternative.\"]->[($alternative ? 2 : 0) + ($optional ? 1 : 0)])\n","out":"Optional and alternative."},{"err":"","code":"my $orig = 'abcdef'; my $str = $orig =~ s/(cde)//r; my $removed = $1; [$orig, $str, $removed]\n","out":"[\"abcdef\",\"abf\",\"cde\"]"},{"err":"lemmings!!!(eval 1) line 1, <STDIN> line 1.\n","code":"my $orig = $SIG{__WARN__}; local $SIG{__WARN__} = sub { my $warn = shift; $warn =~ s/ at /!!!/g; local $SIG{__WARN__} = $orig; warn $warn }; warn 'lemmings' # could just double-local it\n","out":"1"},{"err":"","code":"my (our $x);\n","out":"ERROR: Can't redeclare \"our\" in \"my\" at (eval 1) line 1, at end of line\n"},{"out":"[\"d\",\"e\",\"f\",\"g\"]","code":"my @out; { local our @tmp; 'abcdefghi' =~ /c(?:(.)(?{ local @tmp = (@tmp, $^N) })){4}(?{ @out = @tmp })/ or die } \\@out\n","err":""},{"code":"my @out; { local our @tmp; 'abcdefghi' =~ / (?:(.)(?{ local @tmp = (@tmp, $^N) })){4}(?{ @out = @tmp }) (?= $ ) /x or die } \\@out\n","err":"","out":"[\"f\",\"g\",\"h\",\"i\"]"},{"err":"","code":"my @out; { my $tmp = []; 'abcdefghi' =~ /c(?:(.)(?{ local @$tmp = (@$tmp, $^N) })){4}(?{ @out = @$tmp })/ or die } \\@out\n","out":"ERROR: Can't localize through a reference at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"my @out; { our @tmp; 'abcdefghi' =~ /c(?:(.)(?{ local @tmp = (@tmp, $^N) })){4}(?{ @out = @tmp })/ or die } \\@out\n","err":"","out":"[\"d\",\"e\",\"f\",\"g\"]"},{"out":"[\"foo\",\"bar\",\"baz\",\"quux\",\"teeen\"]","err":"","code":"my @packets = qw(foo=ba r=baz= quux =teeen); my @chunks; my $prev = ''; for my $part (@packets) { my @pieces = split /=/, $part, -1; $pieces[0] = $prev . $pieces[0]; $prev = pop @pieces; push @chunks, @pieces; } push @chunks, $prev; \\@chunks\n"},{"out":"ERROR: Undefined subroutine &CORE::print called at (eval 1) line 1, <STDIN> line 1.\n","code":"my $p = \\&CORE::print; $p->(\"foo\")\n","err":""},{"code":"my $pi = atan2(0, -1); my $x = $pi; [ $pi, map { $x *= 1e10; ($x - int $x)*1e10;  } 1..10 ]\n","err":"","out":"[\"3.14159265358979\",\"8979301452.63672\",0,0,0,0,0,0,0,0,0]"},{"err":"","code":"my $pi = atan2(0, -1); $pi *= 1e10; [ int $pi, $pi - int $pi ]\n","out":"['31415926535',\"0.897930145263672\"]"},{"code":"my $pi = atan2(0, -1); $pi *= 1e20; [ int $pi, $pi - int $pi ]\n","err":"","out":"[\"3.14159265358979e+20\",0]"},{"out":"[\"b\",\"a\"]","code":"my %pool = (param0 => 'a', param1 => 'b'); [ map { $pool{$_} } 'param1', 'param0' ]\n","err":""},{"code":"my %pool = (param0 => 'a', param1 => 'b'); [ @pool{'param1', 'param0'} ]\n","err":"","out":"[\"b\",\"a\"]"},{"out":"foocats                             baraltreus","code":"my %pool = qw(param0 altreus param1 cats); my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \\{ ([^{]+) \\}/push @params, $pool{$2}; $1 . 's'/gex; printf $str, @params\n","err":""},{"out":"foo                                 bar","err":"","code":"my %pool = qw(param0 altreus param1 cats); my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \\{ ([^{]+) \\}/push @params, $pool{\"param$2\"}; $1 . 's'/gex; printf $str, @params\n"},{"err":"","code":"my $pos = 3; my $ref = '1'; my $seq = [qw(a b c d e f g h i j)]; join '', @{$seq}[($pos - 1)..(($pos-2) + length($ref))] # off by 2, I think?\n","out":"c"},{"code":"my $p = \"(part1).*(part2)\"; \"foopart1barpart2\" =~ /$p/; print \"$1 $2\";\n","err":"","out":"part1 part2"},{"out":"( A) (A B) (B C) (C D) ","err":"","code":"my $prev; for my $cur (\"A\" .. \"D\") { print \"($prev $cur) \"; } continue { $prev = $cur; }\n"},{"out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n","code":"my $_ = q,asdf \"foo\"='bar baz',; my $h = 0x20000; my %h; s/(([\"'])(?:[^\"']+|\\\\.|(?!\\2).)*\\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split ' '; $h = chr($h-1); s/([\\x{20000}-$h])/$h{$1}/g for @words; \\@words;\n","err":""},{"err":"","code":"my $_ = q, echo foo bar=baz hmm=\"1 2 3\" nn='aa bb',; my $h = 0x20000; my %h; s/(([\"'])(?:[^\"']+|\\\\.|(?!\\2).)*\\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split /\\s+/; $h = chr($h-1); s/([\\x{20000}-$h])/$h{$1}/g for @words; \\@words;\n","out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n"},{"out":"ERROR: No such class qw at (eval 1) line 1, near \"; my qw\"\n","err":"","code":"my qw( $foo ); $foo = 123; $foo; ### Why does this not work?\n"},{"err":"","code":"my $r = bless [], \"HASH\";  ref $r\n","out":"HASH"},{"err":"","code":"my @rc; my @vals = ('a','b','c'); (0 ? @rc : $rc[0]) = @vals; \\@rc\n","out":"[\"a\"]"},{"out":"[3]","code":"my @rc; my @vals = ('a','b','c'); 0 ? @rc : $rc[0] = @vals; \\@rc\n","err":""},{"code":"my @rc; my @vals = ('a','b','c'); (1 ? @rc : $rc[0]) = @vals; \\@rc\n","err":"","out":"[\"a\",\"b\",\"c\"]"},{"code":"my @rcolors = (\"red\", \"orange\", \"color green\"); my $count = 0; for (@rcolors) { last if /color green/; } continue { $count++; } $count; # seems unlikely\n","err":"","out":"2"},{"err":"","code":"my $r = \\&CORE::ref; $r->([])\n","out":"ARRAY"},{"out":"ERROR: failed at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my $readfromfile = '[x'; my $re = eval { qr/$readfromfile/; 1 } or die 'failed'; [ $re ]\n"},{"out":"[1]","code":"my $re = 'asdf'; ['asdfasdf' =~ /^\\Q$re\\E.*$/]\n","err":""},{"err":"","code":"my $re = 'asdf\\E.*'; ['asdfasdf' =~ /^\\Q$re$/]\n","out":"[]"},{"out":"{baz => \"moomoomoomoo\",foo => \"moomoomoo\"}","code":"my $records = { foo => \"bar\", baz => \"quux\" }; s/./moo/g for values %$records; $records\n","err":""},{"err":"","code":"my $recurse = sub { ref ? __SUB__->($_) : say for values $_[0] }; $recurse->({x => 123, y => [qw(a b c)]}) # this\n","out":"ERROR: Experimental values on scalar is now forbidden at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"#646464","code":"my ($red, $green, $blue) = (100, 100, 100); sprintf '#%02x%02x%02x', $red, $green, $blue;\n","err":""},{"out":"1\n2\n3\n4\n","err":"","code":"my $ref = [1,2,3,4]; for my $item (@$ref) { print $item, \"\\n\" }\n"},{"err":"","code":"my $ref = [1,2,3]; push @{$ref}, \"hi\"; $ref\n","out":"[1,2,3,\"hi\"]"},{"out":"{5 => \"floop\",3 => \"baz\",4 => \"quux\"}","err":"","code":"my $ref = { 1 => foo => 2 => bar => 3 => baz => 4 => quux => 5 => 'floop' }; %{ $ref } = %{ $ref }{ (reverse sort keys %$ref)[0 .. 2] }; $ref # joobie\n"},{"err":"","code":"my $ref = \\42; ${$ref} = \"hi\";\n","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"10","code":"my $ref = [[8],[9],[10]]; @{$ref}[0,1,2]->[0]\n","err":""},{"code":"my $ref = [[8],[9],[10]]; @{$ref}[0,1,2][0]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"][\"\n"},{"err":"","code":"my $ref = do { \\ my $foo; }; ref $ref\n","out":"SCALAR"},{"err":"","code":"my $ref = \\&foo; $ref->(21);  sub foo { $_[0] * 2 }\n","out":"42"},{"code":"my $refName = [ 'one', 'two', 'three', 'four', 'five' ];  my @slice = (1,3);  my @values = @{$refName}[@slice];  \\@values\n","err":"","out":"[\"two\",\"four\"]"},{"code":"my $refName = [ 'one', 'two', 'three', 'four', 'five' ];  my @values = @{$refName}[1,3];  \\@values\n","err":"","out":"[\"two\",\"four\"]"},{"err":"","code":"my $ref = [ qw/ a b c / ]; [ @{ $ref }[1,2] ]\n","out":"[\"b\",\"c\"]"},{"err":"","code":"my $ref = [qw/foo bar baz/]; for $i (keys $ref) { print \"$i \"; }\n","out":"ERROR: Experimental keys on scalar is now forbidden at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"something\"]","err":"","code":"my $re = \"motd \\\\^(.*)\"; [ map /$re/, 'motd ^something' ] # vs. /motd \\^/\n"},{"out":"foo","code":"my @replacements = (['foo', 'bar', 'baz'], ['quux']); $replacements[0][0]\n","err":""},{"out":"[\"vkAuth?code=edb31139a2f04d22a8\"]","code":"my $re = '/projects/test/(.*)'; [ \"/projects/test/vkAuth?code=edb31139a2f04d22a8\" =~ $re ]\n","err":""},{"err":"","code":"my $re = '/projects/(\\w+)/(.*)'; [ \"/projects/test/vkAuth?code=edb31139a2f04d22a8\" =~ $re ]\n","out":"[\"test\",\"vkAuth?code=edb31139a2f04d22a8\"]"},{"err":"","code":"my $re = '/projects/(\\w+)/test/(.*)'; [ \"projects/test/vkAuth?code=edb31139a2f04d22a8\" =~ $re ]\n","out":"[]"},{"out":"qr/[[]/u","err":"","code":"my $re = qr/[[]/\n"},{"out":"","code":"my $re = qr/ blah \\n | \\n blah1 \\n | \\n yada/x; print \"Failed\\n\" if 'testing' =~ $re\n","err":""},{"out":"Match","err":"","code":"my $re = qr/^To: .*helpme\\@mydomain.com/; 'To: Some person<helpme@mydomain.com> lalala' =~ $re ? \"Match\" : \"No match\"\n"},{"code":"my $re = qr/(?<!x)(x+)(??{ my $len = length $1; \"y{$len}\" })(?!y)/; [ map { scalar $_ =~ $re } qw(xxyy xxy xyy) ]\n","err":"","out":"[1,\"\",\"\"]"},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n","code":"my @res = map { chomp; $_ if (-f $_) } qw(dupes.txt allfiles.bak.txt hahaha.setnhue); print join(' ', @res) . \"\\n\";\n","err":""},{"code":"my ($result) = \"a numeric example: 42\" =~ /(\\d+)/; $result # note the lack of \\\n","err":"","out":"42"},{"out":"[\"\"]","code":"my $result = do { \"my string\" for 1 .. 8 };  [$result]\n","err":""},{"code":"my $result = do { \"my string\" for 1 .. 8 };  $result\n","err":"","out":""},{"out":"[\"elsif\"]","err":"","code":"my $result; if (0) { $result = \"if\"; } elsif (1) { $result = \"elsif\"; } else { $result = \"else\"; } [$result]\n"},{"err":"","code":"my $result = sprintf '%.28f', '1.43531262539073e-11'; { local $/ = '0'; 1 while chomp($result) } $result # let perl work it out\n","out":"0.0000000000143531262539072984"},{"err":"","code":" my $result = sub { my $str = \"foo:12 bar:34 baz:45\"; $str =~ /foo:(?<foo>\\d+) bar:(?<bar>\\d+) baz:(?<baz>\\d+)/; return \\%+ }->(); 'x: 78' =~ /\\w+: (?<whatevs>\\d+)/; +{ %$result } # yeah, you'll just get the results from whichever regex is in the current scope\n","out":"{whatevs => 78}"},{"out":"[10,1,2]","code":"my $ret = my ($x, $y) = 1..10; [ $ret, $x, $y ];\n","err":""},{"code":"my $ret = my ($x, $y) = 9..19; [ $ret, $x, $y ];\n","err":"","out":"[11,9,10]"},{"code":"my $ret = my ($x, $y, @z) = 9..19; [ $ret, $x, $y, \\@z ]; # For those wondering, the right way to grab the rest of the elements.\n","err":"","out":"[11,9,10,[11,12,13,14,15,16,17,18,19]]"},{"out":"[2,9,10,[9,10]]","code":"my $ret = my @z = my ($x, $y) = 9..19; [ $ret, $x, $y, \\@z ];\n","err":""},{"out":"hello, here is my message","err":"","code":"my $return = print \"hello, here is my message\";   $return\n"},{"err":"","code":"my @rocks = qw (granite rubble lava slate); [ grep { $rocks[$_] =~ /a/ } 0..$#rocks ]\n","out":"[0,2,3]"},{"out":"{IV => 4,II => 2,V => 5,I => 1,III => 3}","err":"","code":"my %roman; sub r :lvalue { $roman{$_[0]} }  ( r(\"I\"), r(\"II\"), r(\"III\"), r(\"IV\"), r(\"V\") ) = 1..5;  \\%roman\n"},{"err":"","code":"my %s = (1,2,3,4,5,6); my $pre = %s; delete @s{keys %s}; [$pre, scalar %s]\n","out":"[\"2/8\",0]"},{"code":"my %s = (1,2,3,4,5,6); %s+1\n","err":"","out":"3"},{"code":"my %s = (1,2,3,4,5,6); scalar keys %s\n","err":"","out":"3"},{"out":"[\"2/8\",2,3]","code":"my %s = (1,2,3,4,5,6); [ scalar %s, 0+%s, 0+keys %s ]\n","err":""},{"err":"","code":"my %s = (1,2,3,4,5,6); [ scalar %s, 1+%s, 0+keys %s ]\n","out":"[\"2/8\",3,3]"},{"out":"1-2-3,4,5","code":"my $s = \"1,2,3,4,5\"; join \"-\", split \",\", $s, 3;\n","err":""},{"code":"my $s1 = q#([A-Z]+)# ; my $s2 = q#([a-z]+)#; my @foo = (\"HELLO-hi\" =~ /$s1-$s2/); [@foo]\n","err":"","out":"[\"HELLO\",\"hi\"]"},{"out":"ab","err":"","code":"my ($s1, $s2) = qw/abc abx/; my $prefix = ($s1 ^ $s2) =~ /\\A(\\0*)/ ? substr($s1, 0, length $1) : ''; $prefix\n"},{"err":"","code":"my $s = \"3 5 1 7 \";  my @m = $s =~ /^(?:(\\d)(\\s))+$/g; \\@m;\n","out":"[7,\" \"]"},{"err":"","code":"my $s = \"3 5 1 7 \";  my @m = $s =~ /^(?:(\\d)(\\s))+$/; \\@m;\n","out":"[7,\" \"]"},{"out":"[]","code":"my $s = \"aabaaaaaaaaaaaab\"; @x = /(a++b)/; [@x]\n","err":""},{"out":"[\"ABCDEfghijklmnopqrstuvwxyz\"]","code":"my $s = \"abcdefghijklmnopqrstuvwxyz\"; $s =~ tr/a-e/A-E/; [$s]\n","err":""},{"code":"my $s = 'ABC'; $s =~ s/([A-Za-z])/join '', map chr(ord ^ 32), split '', $1/ge; $s   # pretty, portable, uses s//, what's not to like?\n","err":"","out":"abc"},{"out":"[\"AB\"]","err":"","code":"my $s = \"A#B\"; $s =~ s/[#]//; [ $s ]\n"},{"out":"[1,2,3]","err":"","code":"my $scalar = [1,2,3]; $scalar\n"},{"out":"hot%chicks","code":"my $search = \"hot chicks\"; $search =~ tr/ /%20/; print $search\n","err":""},{"err":"","code":"my $search = \"hot chicks\"; $search =~ tr/hot/123/; print $search\n","out":"123 c1icks"},{"out":"hot+chicks","err":"","code":"my $search = \"hot chicks\"; $search =~ tr/ /+/; print $search\n"},{"err":"","code":"my $search_path = \"ILMT::HIN::PAN\"; [ grep /^${search_path}::[^:]+$/, \"ILMT::HIN::PAN::UTF2WX\" ]\n","out":"[\"ILMT::HIN::PAN::UTF2WX\"]"},{"out":"[]","code":"my $search_path = \"ILMT::HIN::PAN\"; [ grep /^${search_path}::[^:]+$/, \"ILMT::HIN::PAN::UTF2WX::UTF2WX\" ]\n","err":""},{"err":"","code":"my %seen; my $i = 0; $seen{$_} = ++$i for 'one','two','three'; \\%seen\n","out":"{one => 1,three => 3,two => 2}"},{"err":"","code":"my %seen; my $i = 0; $seen{''} = ++$i; \\%seen\n","out":"{\"\" => 1}"},{"code":"my %seen; $seen{''} = 123; print $seen{''};\n","err":"","out":"123"},{"code":"my %seen; $seen{foo} // 1; \\%seen\n","err":"","out":"{}"},{"code":"my %seen; $seen{foo}; $seen{bar}; \\%seen\n","err":"","out":"{}"},{"err":"","code":"my %seen; $seen{''} //= keys(%seen)+1; print $seen{''}.\"\\n\";\n","out":"2\n"},{"out":"2","code":"my %seen; $test=\"one\"; $seen{$test} //= keys(%seen)+1; print $seen{$test};\n","err":""},{"code":"my %seen; $test=\"one\"; $seen{$test} //= keys(%seen); print $seen{$test};\n","err":"","out":"1"},{"err":"","code":"my %seen; $test=\"one\"; $seen{$test} = [keys(%seen)]; \\%seen\n","out":"{one => []}"},{"out":"{one => [\"one\"]}","err":"","code":"my %seen; $test=\"one\"; $seen{$test} //= [keys(%seen)]; \\%seen\n"},{"err":"","code":"my ( $self ) = @_;\n","out":"1"},{"out":"1","err":"","code":"my ( $self ) = $_;\n"},{"out":"ERROR: Can't locate object method \"goats\" via package \"main\" at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my $self = bless {}; $self->goats();\n"},{"err":"","code":"my $self = +{}; $self->{messages} = [1,2,3]; $self->{messages}->[0] = \"a\"; $self->{messages}\n","out":"[\"a\",2,3]"},{"err":"","code":"my $sentence = \" I saw the the router.\"; [$sentence =~ /([a-zA-Z]+)\\s+\\1/]\n","out":"[\"the\"]"},{"code":"my @sets_list1 = (4,5,6); [ (map [ $_ ], @sets_list1), (map [ @sets_list1[0..$_] ], -1..$#sets_list1) ];\n","err":"","out":"[[4],[5],[6],[],[4],[4,5],[4,5,6]]"},{"out":"[3,\" \",5,\" \",1,\" \",7,\" \"]","code":"my $s = \"foo 3 5 1 7 bar\";  my @m = $s =~ /(?:(\\d)(\\s))/g; \\@m;\n","err":""},{"out":"[3,\" \",5,\" \",1,\" \",7,\" \"]","code":"my $s = \"foo 3 5 1 7 bar\";  my @m = $s =~ /(\\d)(\\s)/g; \\@m;\n","err":""},{"code":"my $s = \"foo 3 5 1 7 bar\";  my @m = $s =~ /(?:(\\d)(\\s))/g; \\@m;  # JQKP\n","err":"","out":"[3,\" \",5,\" \",1,\" \",7,\" \"]"},{"out":"[3,\" \",5,\" \",1,\" \",7,\" \"]","err":"","code":"my $s = \"foo 3 5 1 7 bar\";  my @m = $s =~ /(?:(\\d)(\\s))/g; \\@m; # wasn't your earlier example already capturing what you wanted?\n"},{"out":"3| |5| |1| |7| \n","err":"","code":"my $s = \"foo 3 5 1 7 bar\";  my @m = $s =~ /(?:(\\d)(\\s))/g; say join \"|\", @m;  # JQKP\n"},{"out":"[\"foobarbaz\\r\\n\"]","code":"my $s = \"foo\\r\\nbar\\r\\nbaz\\r\\n\"; $s =~ s/\\R(?=.)//g; [ $s ];\n","err":""},{"code":" my ($sha) = split(' ', readpipe(\"sha1sum\", $filename));\n","err":"","out":"0"},{"out":"[\"Hello  My name is .\"]","err":"","code":"my $s = \"Hello (hey) My name is (rindolf).\"; $s =~ s/\\([^)]*\\)//g; [$s]\n"},{"out":"Matched <Hello>\n","err":"","code":"my $s = \"Hello.label\"; if (my ($m) = $s =~ /^(.*)\\.label$/) { print \"Matched <$m>\\n\"; }\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"\"Hello\" [\"\n","err":"","code":"my $s = \"Hello\" [ref($s)]\n"},{"out":"[\"\"]","err":"","code":"my $s = \"Hello\"; [ref($s)]\n"},{"out":"[\"Way\"]","err":"","code":"my $s = \"Hello\"; [($s eq \"Good\" or \"Way\")]\n"},{"out":"[\"Hello rrman!\"]","err":"","code":"my $s = \"Hello\"; $s .= \" rrman!\"; [$s]\n"},{"out":"[\"     Hello\"]","code":"my $s = \"      Hello\"; $s =~ s/^\\s//; [$s]\n","err":""},{"out":"[\"Hello\"]","err":"","code":"my $s = \"      Hello\"; $s =~ s/^\\s+//; [$s]\n"},{"out":"[\"hello world 120423424 one two three\"]","err":"","code":"my $s = \"hello world <120423424> one two three\"; $s =~ s/\\A((?:\\S+\\s+){2})<([0-9]+)>/$1$2/; [$s]\n"},{"out":"[\"hello world 120423424 one two three\"]","code":"my $s = \"hello world <120423424> one two three\"; $s =~ s/\\A(?:\\S+\\s+){2}\\K<([0-9]+)>/$1/; [$s]\n","err":""},{"out":"[\"Hello \"]","code":"my $s = \"Hello World\"; $s=~ /Wor/; [$`]\n","err":""},{"out":"{7939 => [34],7967 => [62],7925 => [10],8051 => [166],7973 => [134],8023 => [142],7965 => [118],7991 => [122],7923 => [38,6],7931 => [22,14],8003 => [106],7955 => [86,74],7943 => [94,26],7979 => [158],7957 => [146],7975 => [58],7935 => [46],7995 => [82]}","err":"","code":"my %sieve; my @primes = (2,3); my ($p_i, $p, $q, $n)=(1,3,9,3); push @primes, do { { $n += 2; if ( my $s = delete $sieve{$n} ) { push @{$sieve{$n + $_}}, $_ for @$s; redo } elsif ( $n < $q ) { $n } else { push @{$sieve{$q + $p*2}}, $p * 2; $p = $primes[++$p_i]; $q = $p*$p; redo } } } until @primes >= 1000; \\%sieve;\n"},{"out":"[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541]","code":"my %sieve; my @primes = (2,3); my ($p_i, $p, $q, $n)=(1,3,9,3); push @primes, do { { $n += 2; if ( my $s = delete $sieve{$n} ) { push @{$sieve{$n + $_}}, $_ for @$s; redo } elsif ( $n < $q ) { $n } else { push @{$sieve{$q + $p*2}}, $p * 2; $p = $primes[++$p_i]; $q = $p*$p; redo } } } until @primes >= 100; \\@primes;\n","err":""},{"code":"my %sieve; my @primes = (2,3); my ($p_i, $p, $q, $n)=(1,3,9,3); push @primes, do { { $n += 2; if ( my $s = delete $sieve{$n} ) { push @{$sieve{$n + $_}}, $_ for @$s; redo } elsif ( $n < $q ) { $n } else { push @{$sieve{$q + $p*2}}, $p * 2; $p = $primes[++$p_i]; $q = $p*$p; redo } } } until @primes >= 100; \\%sieve;\n","err":"","out":"{551 => [38],543 => [6],559 => [26],553 => [14],545 => [10],575 => [46],561 => [34,22]}"},{"out":"[\"llama\",\"lamal\",\"amall\",\"malla\",\"allam\"]","code":"my $s = \"llama\"; [ map { substr($s, $_).substr($s, 0, $_) } 0..4 ]\n","err":""},{"code":"my $s; my $c = sub { warn $s }; for $s (1,2,3) { $c->(); }\n","err":"Warning: something's wrong at (eval 1) line 1, <STDIN> line 1.\nWarning: something's wrong at (eval 1) line 1, <STDIN> line 1.\nWarning: something's wrong at (eval 1) line 1, <STDIN> line 1.\n","out":""},{"err":"","code":"my @some_array = qw/0 1 2 3 4 5 6 7 8 9 10/; my (@primes, $zero) = @some_array[2,3,5,7,0]; print \"@primes%\"; print !defined $zero;\n","out":"2 3 5 7 0%1"},{"code":"my $s = \"<One> Two <Three> Four <Five>\"; [$s =~ /<([^>]+)>/g]\n","err":"","out":"[\"One\",\"Three\",\"Five\"]"},{"code":"my $s = \"one.two.three\"; my $count = $s =~ tr/././; [$count]\n","err":"","out":"[2]"},{"code":"my $space = 15; printf(\"... %-${space}s => %s\", \"foo\", \"bar\");\n","err":"","out":"... foo             => bar"},{"out":"...             foo => bar","code":"my $space = 15; printf(\"... %${space}s => %s\", \"foo\", \"bar\");\n","err":""},{"code":"my $space = 15; printf(\"... %s%${space}s => %s\", \"foo\", \"\", \"bar\");\n","err":"","out":"... foo                => bar"},{"err":"","code":"my $s = q{abc}; [ $s =~ /(?:abc(foo|bar|baz)|)/ ]; # anno, seems it does returns undef.\n","out":"[undef]"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n","err":"","code":"my $s = q{abc}; [ $s =~ /(?:abc(foo|bar|baz)|)/ # anno, seems it does returns undef.\n"},{"code":"my $s = q{foo=bar=baz}; my $p = qr/=(.*?)=/; my $r = q{,$1,}; $s =~ s/$p/$r/re;\n","err":"","out":"foo,$1,baz"},{"err":"","code":"my $s = q{foo=bar=baz}; my $p = qr/=(.*?)=/; my $r = q{,$1,}; $s =~ s/$p/$r/ree;\n","out":"foobaz"},{"out":"foo,bar,baz","code":"my $s = q{foo=bar=baz}; my $p = qr/=(.*?)=/; my $r = q{\",$1,\"}; $s =~ s/$p/$r/ree\n","err":""},{"out":"","code":"my $s = q{foo=bar=baz}; my $p = qr/=/; my $r = ','; $s = s/$p/$r/;\n","err":""},{"err":"","code":"my $s = q{foo=bar=baz}; my $p = qr/=/; my $r = ','; $s = s/$p/$r/r;\n","out":""},{"out":"foo,bar,baz","err":"","code":"my $s = q{foo=bar=baz}; my $p = qr/=/; my $r = ','; $s =~ s/$p/$r/rg;\n"},{"err":"","code":"my sql $db: cool cool\n","out":"ERROR: No such class sql at (eval 1) line 1, near \"; my sql\"\nsyntax error at (eval 1) line 1, near \"$db:\"\n"},{"out":"[0]","err":"","code":"my $s = qq{ 0xFF }; [ 0+$s ];\n"},{"code":"my $s = qq{ 1234.5 }; [ 0+$s ];\n","err":"","out":"[\"1234.5\"]"},{"out":"[\"Hello \\\"World\\\"!\"]","code":"my $s = qq{Hello \"World\"!}; [$s]\n","err":""},{"err":"","code":"my $s = 'some text'; my $f = 's/x/s/g; s/o/a/g;'; eval $f for $s; $s # if you want to limit the scope... why is there a string eval involved anyway\n","out":"same test"},{"out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n","code":"my $_ = \"â\"; s/(.)/sprintf('\\\\u%04x', ord \"$1\")/ger\n","err":""},{"out":"x1y-x2y-x3y","err":"","code":"my $s = sub { \"x${_}y\" }; join '-', map $s->(), 1..3;\n"},{"code":"my (state $foo)\n","err":"","out":"ERROR: Can't redeclare \"state\" in \"my\" at (eval 1) line 1, at end of line\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"$state_var sub function_that_uses_state_var \"\nsyntax error at (eval 1) line 1, near \"} }\"\n","err":"","code":"{ my $state_var sub function_that_uses_state_var { ... } }\n"},{"code":"{ my $state_var; sub function_that_uses_state_var { ...; } }\n","err":"","out":""},{"out":"1","code":"my $str = \"001.html\"; my @pats = (qr/^\\d\\d\\d\\.html/); print \"fail\" unless $str ~~ @pats;\n","err":""},{"out":"1","code":"my $str = \"001.html\"; my @pats = (qr/\\d\\d\\d\\.html/); print \"fail\" unless $str ~~ @pats;\n","err":""},{"code":"my $str = \"001.html\"; my @pats = (qr/\\d\\d\\d\\.html); print \"fail\" unless $str ~~ @pats;\n","err":"","out":"ERROR: Search pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ok","code":"my $str = \"001.html\"; my $re = qr/^\\d\\d\\d\\.html/;  $str =~ /$re/ ? \"ok\" : \"fail\"\n","err":""},{"out":"[\"\\0\"]","code":"my $str = \"\\0\"; [ $str ]\n","err":""},{"err":"","code":"my $str = '123456'; substr $str, -2, 0, ','; $str\n","out":"1234,56"},{"code":"my $str = \"123AG3GCAT422TG3\"; my @groups = $str =~ m/(\\d+|[[:alpha:]]{2})/g; \\@groups\n","err":"","out":"[123,\"AG\",3,\"GC\",\"AT\",422,\"TG\",3]"},{"out":"13; month","code":"my $str = \"13month\"; my ($N, $dep) = $str =~ m/(\\d+)(\\w+)/; print \"$N; $dep\"\n","err":""},{"out":"[\"#\",18,0,18,0,\"Chunk\",\"17:25:25\",\"17:25:25\",2,\"arabidopsis_thaliana_core_28_81_10.analysis_description\"]","err":"","code":"my $str = \"#     18       0     18      0 Chunk     17:25:25 17:25:25 2    arabidopsis_thaliana_core_28_81_10.analysis_description\"; [split /\\s+/, $str]\n"},{"err":"","code":"my $str = \"\\23\\53\\52\"; $str # Grinnz_\n","out":"\u0013+*"},{"out":"\u001754","err":"","code":"my $str = \"\\\\23\\\\53\\\\52\"; $str =~ s/\\\\(\\d\\d)/chr $1/eg; $str\n"},{"out":"\u0013+*","code":"my $str = \"\\23\\53\\52\"; $str =~ s/\\\\(\\d\\d)/chr $1/eg; $str\n","err":""},{"err":"","code":"my $str = \"\\\\23\\\\53\\\\52\"; $str =~ s/\\\\(\\d\\d)/chr oct $1/eg; $str\n","out":"\u0013+*"},{"err":"","code":"my $str = '2 4 8 16'; my $match = '(\\d+)'; my $subst = '$1 / 2'; $str =~ s/$match/$subst/ge; $str\n","out":"$1 / 2 $1 / 2 $1 / 2 $1 / 2"},{"code":"my $str = \"4 8 16 7\"; $str =~ s{(\\d+)}{$1 / 2}ge; print $str\n","err":"","out":"2 4 8 3.5"},{"code":"my $str = \"aabbcc\"; $str =~ s/((\\w)\\1)/ $1 /g; $str\n","err":"","out":"aabbcc"},{"code":"my $str = \"aabbcc\"; $str =~ s/(\\w)\\1/ $& /g;\n","err":"","out":"3"},{"out":" aa  bb  cc ","err":"","code":"my $str = \"aabbcc\"; $str =~ s/(\\w)\\1/ $& /g; $str\n"},{"code":"my $str = \"aabbcc\"; $str =~ s/((\\w)\\2)/ $1 /g; $str\n","err":"","out":" aa  bb  cc "},{"out":"[\"c\",\"h\",\"h\"]","code":"my $str = \"a b c d e f g h i j h k l\"; [ (split \" \", $str)[2,5-8,10] ]\n","err":""},{"out":"[\"c\",\"f\",\"g\",\"h\",\"i\",\"h\"]","err":"","code":"my $str = \"a b c d e f g h i j h k l\"; [ (split \" \", $str)[2,5..8,10] ]\n"},{"out":"[\"adgjmpsvyz\"]","err":"","code":"my $str = 'abcdefghijklmnopqrstuvwxyz'; [ join '', split /(.)../, $str ] # depends on how you define 'easiest'\n"},{"code":"my $str = 'abcdefghijklmnopqrstuvwxyz'; join '', $str =~ /..(.)/g\n","err":"","out":"cfilorux"},{"out":"cfiloruxyz","err":"","code":"my $str = 'abcdefghijklmnopqrstuvwxyz'; $str =~ s/..(.)/$1/gr\n"},{"out":"[\"abc\"]","code":"my $str = 'abc def'; [ $str =~ m/^(\\w*)/ ]\n","err":""},{"code":"my $str = 'abc def'; [ $str =~ m/^(\\w*)/; ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"out":"cde","code":"my $str = 'abcdef'; $str =~ s/(cde)//; my $removed = $1; $removed\n","err":""},{"code":"my $str = 'abcdef'; $str =~ s/(cde)//; my $removed = $1; [$str, $removed]\n","err":"","out":"[\"abf\",\"cde\"]"},{"code":"my $str = 'abc def'; [ $str =~ /^(\\w*)/; ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"err":"","code":"my $str = 'abc def'; [ $_ =~ /^(\\w*)/; ]\n","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"out":"a_b_c_da_b_c","code":"my $str = \"a_b_c_d\"; my $newstr = $str =~ s/_[^_]*$//r; print $str, $newstr\n","err":""},{"err":"","code":"my $str = 'abcd'; substr($str, 2, 2).substr($str, 0, 2)\n","out":"cdab"},{"out":"[\"Abc\",\"aBc\",\"ABc\",\"abC\",\"AbC\",\"aBC\",\"ABC\"]","err":"","code":"my $str = \"abc\"; my $len = length $str; my $copy = $str; my @rslt; for(1..2**$len-1) { my $idx = 0; do { substr($copy, $idx, 1) ^= \" \" } until substr($copy, $idx, 1) eq uc substr($str, $idx++, 1); push @rslt, $copy } \\@rslt\n"},{"code":"my $str = \"Anna: barbara (>= 0.6.16), cindy (>= 0.6.16), deborah (>= 2.7), ellen (= 1.5.3-5+deb7u1), fiona (>= 1.4.2), greta (>= 1.4.0)\"; my @girls = $str =~ /\\b([a-z]+)\\b/ig; [@girls]\n","err":"","out":"[\"Anna\",\"barbara\",\"cindy\",\"deborah\",\"ellen\",\"fiona\",\"greta\"]"},{"err":"","code":"my $str = \"ÃÃ¶\"; [ $str =~ /([[:upper:]])/ ]\n","out":"[\"\\303\"]"},{"out":"woot","err":"","code":"my $str = '{ awf wv qwea vwev eaga }END'; return \"woot\" if ($str =~ m#^{.*}END$#);\n"},{"code":"my $str = \"Buyer information:vivek jena\"; my ($first, $second) = $str =~ /:(\\w+)\\s+(\\w+)/; [$first, $second]\n","err":"","out":"[\"vivek\",\"jena\"]"},{"err":"","code":"my $str = '{f.43.fq34.gf.34gfeg.ea.greags sdfasfd sd {} s{S}D F{SA}D{ FSA}D{ }},'; my ($return) = $str =~ m#^({.*?}).*#; $return\n","out":"{f.43.fq34.gf.34gfeg.ea.greags sdfasfd sd {}"},{"err":"","code":"my $str = \"foo:12 bar:34 baz:45\"; $str =~ /foo:(?<foo>\\d+) bar:(?<bar>\\d+) baz:(?<baz>\\d+)/; \\%+\n","out":"{}"},{"out":"{baz => 45,foo => 12,bar => 34}","err":"","code":"my $str = \"foo:12 bar:34 baz:45\"; $str =~ /foo:(?<foo>\\d+) bar:(?<bar>\\d+) baz:(?<baz>\\d+)/; +{ %+ }\n"},{"out":"12","err":"","code":"my $str = \"foo:12 bar:34 baz:45\"; $str =~ /foo:(?<foo>\\d+) bar:(?<bar>\\d+) baz:(?<baz>\\d+)/; $+{foo}\n"},{"code":"my $str = \"foo:12 bar:34 baz:45\"; $str =~ /foo:(?<foo>\\d+) bar:(?<bar>\\d+) baz:(?<baz>\\d+)/; [ keys %+ ]\n","err":"","out":"[\"baz\",\"bar\",\"foo\"]"},{"err":"","code":"my $str = \"foo:12 bar:34 baz:45\"; $str =~ /foo:(?<foo>\\d+) bar:(?<bar>\\d+) baz:(?<baz>\\d+)/; { %+{keys %+} }\n","out":"12"},{"out":"{baz => 45,foo => 12,bar => 34}","err":"","code":"my $str = \"foo:12 bar:34 baz:45\"; $str =~ /foo:(?<foo>\\d+) bar:(?<bar>\\d+) baz:(?<baz>\\d+)/; +{ %+{keys %+} }\n"},{"out":"{params => [\"param1\",\"param0\"],str => \"foo%-331bar%2\"}","code":"my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \\{ ([^{]+) \\}/push @params, $2; $1 . @params/gex; { str => $str, params => \\@params }\n","err":""},{"code":"my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \\{ ([^{]+) \\}/push @params, $2; $1 . 's'/gex; printf $str, @params\n","err":"","out":"fooparam1                           barparam0"},{"out":"{params => [\"param1\",\"param0\"],str => \"foo%-33sbar%s\"}","err":"","code":"my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \\{ ([^{]+) \\}/push @params, $2; $1 . 's'/gex; { str => $str, params => \\@params }\n"},{"out":"[[\"foo\",\"bar\",\"baz\",\"foo\"]]","code":"my $str = \"foo,bar,baz foo\"; my $arr = [map {split(\",\", $_)} split(\" \", $str)]; [$arr]\n","err":""},{"err":"","code":"my $str = \"foo,bar,baz foo\"; my $arr = [map {split(\",\", $_)} split($str)]; [$arr]\n","out":"[[]]"},{"out":"foo bar baz","err":"","code":"my $str = \"foo bar baz\"; open(my $fh, '<', \\$str); print <$fh>;\n"},{"err":"","code":"my $str = \"foobar\"; my $new = $str ^ \"   \"; $new\n","out":"FOObar"},{"code":"my $str='   foo bar   '; $str =~ s/^\\s+|\\s+$//gie; print \"STR is now '$str'\";\n","err":"","out":"STR is now 'foo bar'"},{"out":"STR is now 'foo bar'","code":"my $str='   foo bar   '; $str =~ s/^\\s+|\\s+$//gi; print \"STR is now '$str'\";\n","err":""},{"code":"my $str='   foo bar   '; $str =~ s/^\\s+|\\s+$//grie; print \"STR is now '$str'\";\n","err":"","out":"STR is now '   foo bar   '"},{"err":"","code":"my $str = \"foo\\nbar\\nbaz\\n\"; my @lines; while ($str =~ m/([^\\n]+\\n)/gc) { my $line = $1; push @lines, $line } \\@lines\n","out":"[\"foo\\n\",\"bar\\n\",\"baz\\n\"]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"/(?<=\\n)/ $str \"\n","err":"","code":"my $str = \"foo\\nbar\\nbaz\\n\"; [ split /(?<=\\n)/ $str ]\n"},{"err":"","code":"my $str = \"foo\\nbar\\nbaz\\n\"; [ split /(?<=\\n)/, $str ]\n","out":"[\"foo\\n\",\"bar\\n\",\"baz\\n\"]"},{"out":"ERROR: Group name must start with a non-digit word character in regex; marked by <-- HERE in m/(?<\\ <-- HERE n)/ at (eval 1) line 1, <STDIN> line 1.\n","code":"my $str = \"foo\\nbar\\nbaz\\n\"; [ split /(?<\\n)/ $str ]\n","err":""},{"out":"ERROR: Group name must start with a non-digit word character in regex; marked by <-- HERE in m/(?<\n <-- HERE )/ at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my $str = \"foo\\nbar\\nbaz\\n\"; [ split \"(?<\\n)\" $str ]\n"},{"out":"1","code":"my $str = \"fooo.bar/blah,+bar\"; $str =~ s/,[+]/%2C+/g\n","err":""},{"out":"fooo.bar/blah%2C+bar","code":"my $str = \"fooo.bar/blah,+bar\"; $str =~ s/,[+]/%2C+/g; $str\n","err":""},{"code":"my $str = \"fooo.bar/blah,+bar\"; $str =~ s/,\\+/%2C+/g; $str\n","err":"","out":"fooo.bar/blah%2C+bar"},{"code":"my $str = \"foo\"; open( my ($fh), \">\", \\$str ); print $fh \"bar\"; [ $str ];\n","err":"","out":"[\"bar\"]"},{"err":"","code":"my $str = \"foo\"; open( my ($fh), \">+\", \\$str ); print $fh \"bar\"; [ $str ];\n","out":"ERROR: Unknown open() mode '>+' at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"my $str = \"foo\"; open( my ($fh), \"+>\", \\$str ); print $fh \"bar\"; [ $str ];\n","out":"[\"bar\"]"},{"out":"GLOB(0x3885030)","err":"","code":"my $str = \"foo\"; open( my ($fh), \">\", \\$str ); print $fh; [ $str ];\n"},{"code":"my $str = \"foo\"; substr $str, 0, 1, ''; $str\n","err":"","out":"oo"},{"code":"my $str = '( G1 Z0.252 F7200.000 )'; my ($int) = $str =~ m#^.*?Z([0-9.]+)#; $int\n","err":"","out":"0.252"},{"code":"my $str = '( G1 Z0.252 F7200.000 )'; my ($value) = $str =~ m#Z([0-9.]+)#; printf(\"%f\",$value);\n","err":"","out":"0.252000"},{"out":"0.252","err":"","code":"my $str = '( G1 Z0.252 F7200.000 )'; my ($value) = $str =~ m#Z([0-9.]+)#; printf(\"%s\",$value);\n"},{"out":"Hello","err":"","code":"my $str = \"Hello\"; $str = $str =~ tr/l/m/r =~ tr/m/l/r; # b100s is this what you mean?\n"},{"err":"","code":"my $string = 'danny larry monica'; my @names = split /\\s/, $string; print $names[0];\n","out":"danny"},{"out":"it's great funt's grit's great funit's great funt fit's great funn","err":"","code":"my $string = \"it's great fun\"; $string =~ s/[aeiou]/$string/g; $string\n"},{"err":"","code":"my $string = \"Number of Users: 3 Active: 3 Neighbor: 0 Parent: \"; my ($number_of_users) = $string =~ /Number of Users: (\\d+)/; $number_of_users\n","out":"3"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"my $string = \"parachutes are good\"; $string =~ /chute/; pos($string) = $-[0]; $string =~ /\\G.*//;\n","err":""},{"err":"","code":"my $str = join '', a..z; [map substr($str, 2 + $_ * 3, 1), 0 .. length($str)/3 ]\n","out":"[\"c\",\"f\",\"i\",\"l\",\"o\",\"r\",\"u\",\"x\",\"\"]"},{"err":"","code":"my $str = join '', a..z; [map substr($str, $_ * 5, 1), 0 .. length($str)/5 ]\n","out":"[\"a\",\"f\",\"k\",\"p\",\"u\",\"z\"]"},{"code":"my $str = $LastZvalue; my ($int) = $str =~ m#^.*?Z([0-9.]+)#; $int; > and when I use the variable in < printf $fhS \"; Last Z value = %d\\n\", $int; > it is showing me '; Last Z value = 0'\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"; >\"\n\"use\" not allowed in expression at (eval 1) line 1, at end of line\n"},{"out":"lello","code":"my $str = \"mello\"; $str = $str =~ tr/l/m/r =~ tr/m/l/r; # this might illustrate it better?\n","err":""},{"out":"","err":"","code":"my $str = \"nickserv!nickserv@blah\"; return 1 if ($str =~ m#^nickserv!nickserv\\@#);\n"},{"code":"my $str = \"nickserv!nickserv\\@blah\"; return 1 if ($str =~ m#^nickserv!nickserv\\@#);\n","err":"","out":"1"},{"code":"my $str = q{blah blah\n","err":"","out":"ERROR: Can't find string terminator \"}\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"my @str = ('Site oficial', 'Site nÃ£o oficial'); my @results = grep { /(?<!nÃ£o )oficial/i } @str; [@results]\n","out":"[\"Site oficial\"]"},{"err":"","code":"my $str = \"some text here\"; $str =~ / (\\S+) (\\S+)/  or die; my $tmpl = \"we had '[1]' and '[2]'\"; my @matches = map substr($str, $-[$_], $+[$_] - $-[$_]), 0..$#+; [ $tmpl =~ s/\\[(\\d+)\\]/$matches[$1]/ger ] # and it tends to obscure the important parts of the code\n","out":"[\"we had 'text' and 'here'\"]"},{"err":"","code":"my $str = \"--\"; $str =~ tr/-/-1/; $str\n","out":"--"},{"code":"my $str = \"take cat\"; open my $fh, '<', \\$str; $/ = \\4; [ readline($fh) ]\n","err":"","out":"[\"take\",\" cat\"]"},{"out":"te","code":"my $str = 'te'; return substr($str,0,3);\n","err":""},{"out":"[\"Test\",\"tEst\",\"TEst\",\"teSt\",\"TeSt\",\"tESt\",\"TESt\",\"tesT\",\"TesT\",\"tEsT\",\"TEsT\",\"teST\",\"TeST\",\"tEST\",\"TEST\"]","code":"my $str = \"test\"; my $len = length $str; my $mask = \"\\0\" x $len; my @rslt; for(1..2**$len-1) { my $idx = 0; do { substr($mask, $idx, 1) ^= \" \" } until substr($mask, $idx++, 1) eq \" \"; push @rslt, $str ^ $mask } \\@rslt\n","err":""},{"err":"","code":"my $str = \"test test, test\"; substr($str, (rindex $str, ','), 1, ''); $str;\n","out":"test test test"},{"out":"[1,2,3,\"more\",\"things\"]","code":"my $struct = { things => [1, 2, 3] };  push @{ $struct->{things} }, \"more\", \"things\";  $struct->{things}\n","err":""},{"out":"{test => [\"hello\"]}","err":"","code":"my $structure = {}; push @{$structure->{test}}, \"hello\";  $structure\n"},{"code":"my $structure; push @{$structure->{test}}, \"hello\";  $structure\n","err":"","out":"{test => [\"hello\"]}"},{"out":"[\"word2\",\"word4\"]","err":"","code":"my $str = '[word1] word2 [word3] word4'; 1 while $str =~ s/(\\[.*?\\])/\\N{U+FFFC}/; [ $str =~ /(\\w+)/g ];\n"},{"code":"my $str = \"words, only like this phrase!\"; $str =~ tr/ a-z//cd; $str; # doesn't need regex, if you mean remove non-alpha characters\n","err":"","out":"words only like this phrase"},{"out":"402","code":"my $str = \"\\x01\\x92\"; my $v = 0; $v = ($v << 8) | $_ for map ord, split //, $str; $v\n","err":""},{"code":"my $str = \"\\x01\\x92\"; my $v = 0; $v = $v << 8 | $_ for unpack 'C*', $str; $v\n","err":"","out":"402"},{"out":"402","code":"my $str = \"\\x01\\x92\"; unpack 'N', substr(\"\\0\" x 4 . $str, -4)\n","err":""},{"err":"","code":"my $str = \"\\xff\\xff\\xff\\xff; my $v = 0; $v = $v << 8 | $_ for unpack 'C*', $str; $v\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"4294967295","err":"","code":"my $str = \"\\xff\\xff\\xff\\xff\"; my $v = 0; $v = $v << 8 | $_ for unpack 'C*', $str; $v\n"},{"out":"4294967295","err":"","code":"my $str = \"\\xff\\xff\\xff\\xff\"; unpack 'N', substr(\"\\0\" x 4 . $str, -4)\n"},{"code":"my @stuff = ( 1..4 ); my ( $x, $y, @output ) = @stuff; [ @output, $x, $y ];\n","err":"","out":"[3,4,1,2]"},{"code":"my $stuff = {a => 1, b => 2}; [@$stuff{'a','b'}]\n","err":"","out":"[1,2]"},{"err":"","code":"my $stuff = {a => 1, b => 2}; [$stuff->@{'a','b'}] # might work on new perls?\n","out":"[1,2]"},{"code":"my %stuff = (abc => 1); { local $stuff{abc} = 2; delete $stuff{abc} } \\%stuff\n","err":"","out":"{abc => 1}"},{"err":"","code":"my ($stuff) = grep { /foo/ } qw/acme beta foorlp/; [ $stuff ]\n","out":"[\"foorlp\"]"},{"err":"","code":"{ my sub foo { 42 } print foo(); } foo()\n","out":"42ERROR: Undefined subroutine &main::foo called at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"{ my $_; sub foo { say } } foo for 123\n","err":"","out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_\"\n"},{"code":"my @subs; for (1 .. 5) { { push @subs, sub { $_ + 1 } } }; [ map { $_->\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n"},{"code":"my @subs; for (1 .. 5) { { push @subs, sub { $_ + 1 } } }; [ map { $_->>() } @subs ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"->>\"\n"},{"err":"","code":"my @subs; for (1 .. 5) { push @subs, sub { $_ + 1 } }; [ map { $_->() } @subs ]\n","out":"[57325801,57325801,57325801,57325801,57325801]"},{"err":"","code":"my @subs; for (1 .. 5) { { push @subs, sub { $_ + 1 } } }; [ map { $_->() } @subs ]; # stupid fingers.\n","out":"[75249721,75249721,75249721,75249721,75249721]"},{"code":"my @subs; for my $_ (1 .. 5) { { push @subs, sub { $_ + 1 } } }; [ map { $_->() } @subs ]; # stupid fingers.\n","err":"","out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n"},{"code":"my @subs; for my $n (1 .. 5) { push @subs, sub { $n + 1 } }; [ map { $_->() } @subs ]\n","err":"","out":"[2,3,4,5,6]"},{"out":"foo","code":"my $subs = [ sub { print 'foo'; }, sub { print 'bar'; } ]; &{$subs->[0]};\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"} sub foo \"\n","err":"","code":"my $sub = sub { say shift // 'no args' } sub foo { &$sub } foo('one arg')\n"},{"out":"one arg\n","err":"","code":"my $sub = sub { say shift // 'no args' }; sub foo { &$sub } foo('one arg')\n"},{"out":"ERROR: Can't declare single ref constructor in \"my\" at (eval 1) line 1, at EOF\n","code":"my (sub { $x })\n","err":""},{"code":"my @super = qw/foo bar baz aaa bbb/; my @unordered = qw/aaa foo baz/; my %order; $order{$super[$_]} = $_ for 0 .. $#super; [ sort { $order{$a} <=> $order{$b} } @unordered ]\n","err":"","out":"[\"foo\",\"baz\",\"aaa\"]"},{"out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n","err":"","code":"my $_ = \"system qw(rm -rf /*)\"; s/(\\d+)-(\\d+)/join \",\", $1..$2/e; [ eval ]\n"},{"code":"my @t=(3,5,7); print shift(@t)*100\n","err":"","out":"300"},{"err":"","code":"my $tdata = { }; push @{ $data }, $tdata;\n","out":"1"},{"out":"ERROR: delete argument is not a HASH or ARRAY element or slice at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my $test = 1; my $something = delete $test;\n"},{"code":"my $test = `echo \"here\" >> /tmp/tactical`; print $test;\n","err":"","out":"1"},{"out":"SCALAR","code":"my $test = ('hello'); ref(\\$test)\n","err":""},{"out":"[\"dword\",\"imixed42\"]","code":"my @test = qw(dword 42 imixed42); my $pat = join '|', qr/(.).{3,}\\1/, qr/(.).{0,1}\\1/; [ grep { m/(?|$pat)/ } @test ]\n","err":""},{"err":"","code":"my @test = qw(dword 42 imixed42); my $pat = join '|', qr/(.).{3,}\\1/, qr/(.).{0,1}\\1/; [ grep { m/$pat/ } @test ]\n","out":"[\"dword\",42,\"imixed42\"]"},{"out":"[\"test\",\"foobar\",\"thab\"]","err":"","code":"my @test = qw(test ing foobar thab); my $pat = join '|', map { quotemeta } qw(e a t); [ grep { m/$pat/ } @test ]\n"},{"out":"[\"word\",42]","code":"my @test = qw(word 42 mixed42); my $pat = join '|', qr/^[a-zA-Z]+$/, qr/^[0-9]+$/; [ grep { m/$pat/ } @test ]\n","err":""},{"out":"[undef]","code":"my $test = sub { \"don't do this\" }; [ $test { 'main' } ]\n","err":""},{"code":"my $test = sub { '$test is not a string' }; my $class = 'main'; [ $class->$test() ]\n","err":"","out":"[\"\\$test is not a string\"]"},{"out":"M\\xf6glich","err":"","code":" my $text = 'M\\xf6glich'\n"},{"code":" my $text = \"M\\xf6glich\"\n","err":"","out":"MÃÂ¶glich"},{"out":"1","code":"my $text = \"onetwothree\"; my ($foo) = $text =~ s/(tw.)//g; $foo\n","err":""},{"out":"text","err":"","code":"my $text = 'some text to match'; my ($captured) = $text =~ /\\b(t[^ ]+)/; $captured\n"},{"code":"my $thing = {};  $thing->{cycle} = $thing;  q( <== Here I have created a cycle. IT IS NOT YET A LEAK BECAUSE $thing STILL HOLDS IT );   undef $thing->{cycle};   q( <== There. I broke the cycle so now all is fine )\n","err":"","out":" <== There. I broke the cycle so now all is fine "},{"err":"","code":"my $title = (sub (_) { defined ? $_ : '' })->($big_long_var_name)\n","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(_\"\n"},{"code":"my $title = (sub :prototype(_) { defined ? $_ : '' })->($big_long_var_name)\n","err":"","out":""},{"out":"ERROR: Can't declare array dereference in \"my\" at (eval 1) line 1, at EOF\n","code":"my @$tmp;\n","err":""},{"code":"my @tmp = (1..3); my @tmp; \\@tmp\n","err":"","out":"[]"},{"out":"10","code":"( my $tmp = \"Hello, world\" ) =~ tr/A-Za-z/N-ZA-Mn-za-m/\n","err":""},{"err":"","code":"( my $tmp = \"Hello, world\" ) =~ tr/A-Za-z/N-ZA-Mn-za-m/; $tmp\n","out":"Uryyb, jbeyq"},{"code":"my @tmp; $tmp[3] = \"gi|300707803|ref|XP_002996096.1|hypothetical protein NCER_100860 [Nosema ceranae BRL01] >gi|239605364|gb|EEQ82425.1| hypothetical protein NCER_100860 [Nosema ceranae BRL01]\"; my($ia,$ib) = split(/\\[/,$tmp[3]); [ $ia, $ib]\n","err":"","out":"[\"gi|300707803|ref|XP_002996096.1|hypothetical protein NCER_100860 \",\"Nosema ceranae BRL01] >gi|239605364|gb|EEQ82425.1| hypothetical protein NCER_100860 \"]"},{"err":"","code":"my $two = \"two\"; [ \"two\\n\" =~ /^\\Q$two\\E$/, \"two\\n\" =~ /\\A\\Q$two\\E\\z/, \"two\\n\" eq $two ]\n","out":"[1,\"\"]"},{"out":"[1,\"\"]","err":"","code":"my $two = \"two\"; [ \"two\\n\" =~ /^\\Q$two\\E$/, \"two\\n\" eq $two ]\n"},{"err":"","code":"my $txt = \"T\\x0A\\x0B\"; s{([^[:print:]])}{sprintf '\\\\%02x', ord $1}ge for $txt; [ $txt ] # or this. or Data::Dumper\n","out":"[\"T\\\\0a\\\\0b\"]"},{"code":"[ my $tz ]\n","err":"","out":"[undef]"},{"code":"my (undef, $b) = (1,2)\n","err":"","out":"2"},{"err":"","code":"my $undef = \" \"; print $undef\n","out":" "},{"code":"my $undef = \"\"; print $undef\n","err":"","out":"1"},{"err":"","code":"my (undef, undef);\n","out":""},{"err":"","code":"my $undef = undef; print $undef\n","out":"1"},{"out":"2","code":"my (undef, $y) = (\"a\", \"b\");\n","err":""},{"code":"my @under = ( \"_\" );   [ ( @under )x 5 ]\n","err":"","out":"[\"_\",\"_\",\"_\",\"_\",\"_\"]"},{"err":"","code":"my @under = ( \"_\" );   [ @under x 5 ]\n","out":"[11111]"},{"out":"[\"youtube-dl\",\"-f\",17,\"...\",\"http://something\"]","code":"my $url = 'http://something'; my @cmd = (qw(youtube-dl -f 17 ...), $url); \\@cmd # I'd write it more like this\n","err":""},{"err":"","code":"my $USA; my $x = 'USA'; ${$x} = 42; [ $USA ]\n","out":"[undef]"},{"out":"xyz%","code":"my $username_ = 'xyz'; \"$username_%\" # ${...} might look better\n","err":""},{"err":"","code":"my ( $user, $nick ) = ( 'root', 'ro.+' ); if($user =~ /^$nick$/){ say 'pwned' } else { say 'you are not root' }\n","out":"pwned\n"},{"out":"damn them\n","err":"","code":"my $users = 1;say \"damn them\" if $users;\n"},{"code":"my $v = 0.223; die \"out of range\" if $v > 1; my $w = 0.05; my $start = $w * int($v / 0.05); [ $start, $start + $w ]\n","err":"","out":"[\"0.2\",\"0.25\"]"},{"out":"18","err":"","code":"my $v = '0.9'; $v .= '9' until $v . '9' == $v; length $v\n"},{"out":"18","code":"my $v = 0.9; $v .= '9' until $v == $v.'9'; length $v;\n","err":""},{"code":"my $v = 0; $v ||= 5; [$v]\n","err":"","out":"[5]"},{"out":"[[255,11111111]]","code":"my $v = -1; my @x; for( my $i = 0, my $r = 0; $r = ($v/256**$i)%256; $i++ ) { push @x, pack q{C}, $r; } [ map { [ unpack( q{C} ), unpack( q{B8} ) ]; } @x ]\n","err":""},{"err":"","code":"my $v = 1; $v ||= 5; [$v]\n","out":"[1]"},{"out":"[\"00100011\",11000010,\"00000011\"]","code":"my $v = 246307; my @x; for( my $i = 0, my $r = 0; $r = ($v/256**$i)%256; $i++ ) { push @x, pack q{C}, $r; } [ map { unpack q{B8}; } @x ]\n","err":""},{"out":"[\"00000101\",\"00000001\"]","code":"my $v = 261; my @x; for( my $i = 0, my $r = 0; $r = ($v/256**$i)%256; $i++ ) { push @x, pack q{C}, $r; } [ map { unpack q{B8}; } @x ] ## Use 'reverse @x' for opposite endian, big endian in this case.\n","err":""},{"out":"[\"a\",\"a\",\"a\"]","code":"my $val = 'a'; [($val++)x3]\n","err":""},{"out":"[undef,undef,undef]","err":"","code":"my @vals = (1,2,3); sub do_stuff { undef $_ } [ map { do_stuff(); $_ } (@vals) ]\n"},{"out":"[1,1]","err":"","code":"my @values = (1, 0, 1, 1);  my $n = 0; ($n >>= 2) |= $_ for reverse @values; [ $n, sprintf '%b', $n ];\n"},{"code":"my @values = (1, 0, 1, 1);  my $n = 0; ($n <<= 2) |= $_ for reverse @values; [ $n, sprintf '%b', $n ]; # d'oh\n","err":"","out":"[81,1010001]"},{"out":"127","code":"my @values = ((1)x 7, 0);  my $n = 0; ($n *= 2) += $_ for reverse @values; $n;\n","err":""},{"out":"","code":"my @values = ((1)x 7, 0);  my $n = 0; ($n *= 2) += $_ for @values;\n","err":""},{"out":"254","err":"","code":"my @values = ((1)x 7, 0);  my $n = 0; ($n *= 2) += $_ for @values; $n;\n"},{"code":"my @values = ((1)x 7, 0); unpack 'I<', pack(('b' x @values), @values);\n","err":"","out":"16843009"},{"out":"16843009","err":"","code":"my @values = ((1)x 7, 0); unpack 'I>', pack(('b' x @values), @values);\n"},{"out":"2155905152","code":"my @values = ((1)x 7, 0); unpack 'I<', pack(('B' x @values), @values);\n","err":""},{"out":"2155905152","err":"","code":"my @values = ((1)x 7, 0); unpack 'I>', pack(('B' x @values), @values);\n"},{"out":"257","err":"","code":"my @values = ((1)x 7, 0); unpack 'n', pack(('b' x @values), @values);\n"},{"out":"32896","code":"my @values = ((1)x 7, 0); unpack 'n', pack(('B' x @values), @values);\n","err":""},{"out":"ERROR: '<' allowed only after types sSiIlLqQjJfFdDpP( in unpack at (eval 1) line 1, <STDIN> line 1.\n","code":"my @values = ((1)x 7, 0); unpack 'N<', pack(('b' x @values), @values);\n","err":""},{"err":"","code":"my @values = ((1)x 7, 0); unpack 'N', pack(('b' x @values), @values);\n","out":"16843009"},{"out":"2155905152","code":"my @values = ((1)x 7, 0); unpack 'N', pack(('B' x @values), @values);\n","err":""},{"code":"my $value = undef;  undef == 2\n","err":"","out":""},{"out":"1","err":"","code":"my $var = 0 || 1;\n"},{"out":"[1]","code":"my $var = 0; [ defined $var ]\n","err":""},{"out":"0","code":"my $var = (1-1) || (2-2);\n","err":""},{"out":"var1: 7888. var2: 3","err":"","code":"my $var1 = 3; my $var2 = 7888; ($var1, $var2) = ($var2, $var1); print \"var1: $var1. var2: $var2\"; #hudo\n"},{"code":"my $var = \"1k10k1l11dld1\";  $var =~ /(\\d+)/; print $var;\n","err":"","out":"1k10k1l11dld1"},{"out":"01","code":"my $var = \"1k10k1l11dld1\";  $var = tr/(d+)//d; print $var;\n","err":""},{"out":"you = me","code":"my ($var1, $var2) = split(/\\=/, \"you=me\"); print $var1 . \" = \" . $var2\n","err":""},{"code":"my $var = 2 || 3;\n","err":"","out":"2"},{"out":"2","code":"my $var = 42; my $ref = \\$var; Internals::SvREFCNT $var\n","err":""},{"out":"47","err":"","code":"my $var = 42; sub xxx { my ($stuff) = @_; return $stuff + $var } xxx(5)\n"},{"out":"[5]","err":"","code":"my(@var) = 5; [ @var ]\n"},{"err":"","code":"my@var = 5; [ @var ]\n","out":"[5]"},{"out":"8","err":"","code":"my $var = \"6d73616e64626f78\"; $var =~ s/([0-9a-f]{2})/chr hex $1/eg\n"},{"out":"msandbox","err":"","code":"my $var = \"6d73616e64626f78\"; $var =~ s/([0-9a-f]{2})/chr hex $1/eg; $var\n"},{"out":"(9)","code":"my $var = (7,8,9); print \"($var)\";\n","err":""},{"err":"","code":"my $var='/.a./.a./.a./.a./'; $var =~ /(\\.\\.)/ ? print \"match two dots in a row\" : \"no match\";\n","out":"no match"},{"err":"","code":"my $var = \"cat\"; \"${var}iable\"\n","out":"catiable"},{"out":"Three","err":"","code":"my $var = ( 'One', 'Two', 'Three');\n"},{"err":"","code":"my $var = ( 'One', 'Two', 'Three'); $var\n","out":"Three"},{"err":"","code":"my $var='\\/print \"OK\" if\n","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"my $var = qw/ One Two Three /; $var\n","out":"Three"},{"err":"","code":"my $var = \"something\"; \"$var\" # this?\n","out":"something"},{"out":"this","code":"my $var = \"this\"; my $ref = \\$var; my $copy = $$ref; $var = \"that\"; $copy\n","err":""},{"err":"","code":"my $var = \"this\"; my $ref = \\$var; my $copy = $ref; $var = \"that\"; print($$copy);\n","out":"that"},{"code":"my $var='/../../../../'; $var =~ /(\\.\\.)/ ? print \"match two dots in a row\" : \"no match\";\n","err":"","out":"match two dots in a row"},{"code":"my $v = q{1.41_02}; [ $v, eval $v ];\n","err":"","out":"[\"1.41_02\",\"1.4102\"]"},{"out":"","err":"Out of memory!\nAttempt to free unreferenced scalar: SV 0x97ff258, <STDIN> line 1.\n","code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { 1 } @$v[ $i, $i + 1 ]; print qq{($a,$n)}; } ### This results in an infinate loop some how...\n"},{"out":"(1,1)(1,1)(1,1)","code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { 1 } @$v; print qq{($a,$n)}; } ### Oddly though, changing @$v[ $i, $i + 1 ]; to just @$v makes the loop finite again...\n","err":""},{"code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } do { @$v[ $i, $i + 1 ] }; print qq{($a,$n)}; } ### Another way, a little cleaner and without an explicit array being declared.\n","err":"","out":"(A,B)(B,C)(C,)"},{"code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } (my @x) = @$v[ $i, $i + 1 ]; print qq{($a,$n)}; } ### Slightly hackish but works.\n","err":"","out":"(A,B)(B,C)(C,)"},{"code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } splice @$v, $i, -2, 2; print qq{($a,$n)}; }\n","err":"Out of memory!\n","out":""},{"out":"(,)(,)(,)","err":"","code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } () = @$v[ $i, $i + 1 ]; print qq{($a,$n)}; }\n"},{"code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } @$v[ $i, $i + 1 ]; print qq{($a,$n)}; } ### This results in an infinate loop some how...\n","err":"Out of memory!\nAttempt to free unreferenced scalar: SV 0xa093f68, <STDIN> line 1.\n","out":""},{"err":"","code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } @$v[ $i, $i < $#$v ? $i + 1 : () ]; print qq{($a,$n)}; } ### This solution is rather ugly as sin, but it works. Is there another way?\n","out":"(A,B)(B,C)(C,)"},{"out":"","err":"Out of memory!\nAttempt to free unreferenced scalar: SV 0xac58f68, <STDIN> line 1.\n","code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } $v->[$i], $v->[$i+1]; print qq{($a,$n)}; }\n"},{"out":"(,)(,)(,)","code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } $v[$i], $v[$i+1]; print qq{($a,$n)}; }\n","err":""},{"out":"","err":"Out of memory!\nAttempt to free unreferenced scalar: SV 0x9a94f68, <STDIN> line 1.\n","code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } $v->[ $i ], $v->[ $i + 1 ]; print qq{($a,$n)}; } ### Why does this still loop infinately when $v->[ $i ], $v->[ $i + 1 ]; on two seaprate lines does not?\n"},{"err":"Out of memory!\nAttempt to free unreferenced scalar: SV 0xb5c1458, <STDIN> line 1.\n","code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ } @$v[ $i, $i + 1 ]; print qq{($a,$n)}; } ### This results in an infinate loop some how...\n","out":""},{"code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = @$v[ $i, $i + 1 ]; print qq{($a,$n)}; }\n","err":"","out":"(A,B)(B,C)(C,)"},{"err":"","code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = ($v->[$i], $v->[$i+1]); print qq{($a,$n)}; }\n","out":"(A,B)(B,C)(C,)"},{"err":"","code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my $a = $v->[ $i ] // q{}; my $n = $v->[ $i + 1 ] // q{}; print qq{($a,$n)}; } ### This works as expected.\n","out":"(A,B)(B,C)(C,)"},{"code":"my $warning; $SIG{__WARN__} = sub { $warning = shift }; warn 'asdf'; [$warning]\n","err":"","out":"[\"asdf at (eval 1) line 1, <STDIN> line 1.\\n\"]"},{"out":"[]","code":"my @warnings; sub foo { local $SIG{__WARN__} = sub { push @warnings, @_ }; goto &bar } sub bar { warn \"blah\" } foo(); \\@warnings\n","err":"blah at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"my $wat = \"\\\\Q\"; \"Q\" =~ /$wat/ ? \"yes\" : \"no\"\n","err":"","out":"yes"},{"err":"","code":"my $what = \"cats\"; [ delete $cats ]\n","out":"ERROR: delete argument is not a HASH or ARRAY element or slice at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"my $what = \"cats\"; [ delete $what ]\n","err":"","out":"ERROR: delete argument is not a HASH or ARRAY element or slice at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"my @whatever = ( my %being = qw(state alive) ); \\@whatever\n","err":"","out":"[\"state\",\"alive\"]"},{"out":"[\"the\",\"b\",\"brown\",\"dog\",\"the\",\"b\",\"brown\"]","err":"","code":"my @whitelist = qw(the b brown dog); [ map { my $word = $_; grep { index($word, $_) >= 0 } @whitelist } \"the brown dog jumps over the brown fox\" =~ /\\w+/g ] # apart from the illegibility, of course\n"},{"err":"","code":"my $_ = \"wibble\"; s/(.)/sprintf('\\\\u%04x', \"$1\")/ger\n","out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n"},{"code":"my $_ = \"wibble\"; s/(.)/sprintf('\\\\u%04x', $1)/ger\n","err":"","out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n"},{"out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n","err":"","code":"my $_ = \"wibble\"; s/(.)/sprintf('\\\\u%04x', ord \"$1\")/ger\n"},{"code":"my @w = map { $_ =~ /\\s+/ ? $_ =~ s/\\s|\\s+/-/g : trim($_) } split ',', ('hello, world, foo bar baz');\n","err":"","out":"3"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n","err":"","code":"my @words = split /\\W/, \"a.b!c?d e\"; for my $i (0..$#words - 1) { push @word_pairs [ $words[$i], $words[$i+1 ]; }; \\@word_pairs\n"},{"err":"","code":"my @words = split /\\W/, \"a.b!c?d e\"; for my $i (0..$#words - 1) { push @word_pairs, [ $words[$i], $words[$i+1] ]; }; \\@word_pairs\n","out":"[[\"a\",\"b\"],[\"b\",\"c\"],[\"c\",\"d\"],[\"d\",\"e\"]]"},{"out":"{right => [],wrong => [[]]}","err":"","code":"my @wrong = [] ; my @right = (); { wrong => \\@wrong, right => \\@right }\n"},{"out":"[\\undef]","code":"[\\my $x]\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"my @x = ;\n","err":""},{"out":"2","err":"","code":"my @x = ( [ 0, 1, 2 ] ); $#{$x[0]}\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"$x[\"\n","err":"","code":"my @x = ( [ 0, 1, 2 ] ); $#$x[0]\n"},{"out":"-1","err":"","code":"my $x = [ [ 0, 1, 2 ] ]; $#{$x[0]}\n"},{"err":"","code":"my $x = 0.21875; my $out = ''; while(int($x) != $x) { $x *= 2; $out .= ($x & 1) ? 1 : 0; }; $out\n","out":"00111"},{"out":"010011001100110011001100110011001100110011001100110011","err":"","code":"my $x = 0.3; my $out = ''; while(int($x) != $x) { $x *= 2; $out .= ($x & 1) ? 1 : 0; }; $out\n"},{"err":"","code":"my $x = 0.40625; my $out = ''; while(int($x) != $x) { $x *= 2; $out .= ($x & 1) ? 1 : 0; }; $out\n","out":"01101"},{"out":"1","code":"my $x = 0.5; my $out = ''; while(int($x) != $x) { $x *= 2; $out .= ($x & 1) ? 1 : 0; }; $out\n","err":""},{"code":"my $x = [0..9];  $#$x # is this the right way to get the last index of @$x?\n","err":"","out":"9"},{"out":"12345678910","err":"","code":"my $x = 0; eval 'print ++$x;'x10  # \"power of looping\"\n"},{"out":"[1,0,1,0,1]","err":"","code":"my $x = 0; [ map { $x = int !!--$x } 1..5 ]\n"},{"code":"my $x = 0; [ map { $x = int !!++$x } 1..5 ]\n","err":"","out":"[1,1,1,1,1]"},{"out":"01","code":"my $x = 0; print \"$x\" if $x == 0;\n","err":""},{"code":"my $x = 0; print $x if $x == 0;\n","err":"","out":"01"},{"code":"my $x = 0; print \"$x,  return value:\" if $x == 0;\n","err":"","out":"0,  return value:"},{"code":"my $x = 0; $x += $_ + ($_*$_ < 2119) * $_ * $_ for 1 .. 2118; $x\n","err":"","out":"2277532"},{"out":"ERROR: Use of := for an empty attribute list is not allowed at (eval 1) line 1, <STDIN> line 1.\n","code":"my $x := 1;\n","err":""},{"out":"0.00999999999999979","err":"","code":"my $x = 10.01; $x -= 10; print $x\n"},{"code":"my $x = 10,25;\n","err":"","out":"25"},{"err":"","code":"my $x = 10,25; [$x]\n","out":"[10]"},{"out":"10 is less-than 20","code":"my $x = 10; my $y = 20; sprintf \"%d is %s %d\", $x, [qw( equal-to greater-than less-than )]->[ $x <=> $y ], $y\n","err":""},{"out":"0.546875","code":"my %x = 1 .. 100; eval scalar %x\n","err":""},{"code":"my %x = 1..100; int %x\n","err":"","out":"35"},{"code":"my %x = 1..100; scalar keys %x\n","err":"","out":"50"},{"out":"35/64","err":"","code":"my %x = 1..100; scalar %x\n"},{"err":"","code":"my %x = 1..10; $_ += 100 for keys %x; \\%x\n","out":"{7 => 8,9 => 10,5 => 6,1 => 2,3 => 4}"},{"code":"my %x = 1..10; $_ += 100 for values %x; \\%x\n","err":"","out":"{7 => 108,9 => 110,5 => 106,1 => 102,3 => 104}"},{"err":"","code":"my @x = 1..10; [ @x[0 .. -1] ]\n","out":"[]"},{"out":"[1]","err":"","code":"my @x = 1..10; [ $x[0 .. -1] ]\n"},{"err":"","code":"my $x = \"123\"; 0+$x; \"123 \" ~~ $x ? 'yes' : 'no'\n","out":"yes"},{"code":"my $x = \"123\"; 0+$x; print \"123 \" ~~ $x ? \"yes\" : \"no\"\n","err":"","out":"yes"},{"err":"","code":"my $x = \"123\"; \"123 \" ~~ $x ? 'yes' : 'no'\n","out":"no"},{"code":"my $x = '1.2345' + '10000000000'; $x =~ /([0-9]{3}\\.[0-9]+)$/; print $1;\n","err":"","out":"001.2345"},{"err":"","code":"my $x = \"123\"; print \"123 \" ~~ $x ? \"yes\" : \"no\"\n","out":"no"},{"out":"closure","code":"{ my $x =123; sub cloure { $x } } closure\n","err":""},{"out":"closure","err":"","code":"{ my $x =123; sub clousre { $x } } closure\n"},{"out":"[[1],[3]]","err":"","code":"my $x = [[1],[2],[3]]; [ @$x[0, 2] ]\n"},{"code":"my $x = [[1],[2],[3]]; @x->[0,2]\n","err":"","out":"ERROR: Can't use an array as a reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[[1,2,3],\\$VAR1->[0][0],\\$VAR1->[0][1],\\$VAR1->[0][2]]","err":"","code":"my @x = (1,2,3); [\\@x, \\(@x)]\n"},{"out":"","err":"","code":"my $x = [[1],[2]]; my $y = $x->[1]; 42 if \\$x->[1] == $y\n"},{"out":"","err":"","code":"my $x = [[1],[2]]; my $y = $x->[1]; 42 if \\$x->[1] == \\$y\n"},{"out":"[[2]]","err":"","code":"my $x = [[1],[2]]; my $y = \\$x->[1]; [grep { $y == \\$_ } @$x];\n"},{"out":"1","code":"my $x = [ 1, 2 ]; $x->[0] # or these?\n","err":""},{"out":"5","code":"my @x = (1..5); @x[0..2] = (1..3); scalar @x;\n","err":""},{"out":"3","err":"","code":"my @x = (1..5); @x = (1..3); scalar @x;\n"},{"out":"[1,\"a\"]","code":"my %x = (1, 'a'); my @x = ('c', 'd'); [ %x{1} ]\n","err":""},{"out":"1e-100","err":"","code":"my $x = 1e-100; print $x\n"},{"out":"[\"\\@array1\",\"array .\"]","err":"","code":"my @x1 = 'FOO'; my @array = (\"a\", \"b\"); [q(@array) .@x1, q@array .@x1]\n"},{"out":"1255","code":"my $x = 1; print $x++, $x++, ++$x, ++$x;\n","err":""},{"out":"124557","err":"","code":"my $x = 1; print $x++, $x++, \"\" . ++$x, \"\" . ++$x, $x++, \"\" . ++$x;\n"},{"code":"my $x = 1; print $x++, $x++, ++$x, ++$x, $x++, ++$x;\n","err":"","out":"127757"},{"out":"[undef]","code":"my $x = 1; sub foo :lvalue { $x }  undef foo; [$x]\n","err":""},{"err":"","code":"my $x = 1; sub foo :lvalue { $x }  undef foo; $x\n","out":""},{"out":"3","code":"my $x = 1; $x+2\n","err":""},{"out":"ERROR: Can't modify preincrement (++) in substitution (s///) at (eval 1) line 1, at EOF\n","err":"","code":"my $x = 1; ( ++$x ) =~ s/2/TWO/;  $x\n"},{"code":"my $x = 1; ${\\$x++} =~ s/2/TWO/; $x\n","err":"","out":"2"},{"out":"TWO","err":"","code":"my $x = 1; ${\\++$x} =~ s/2/TWO/; $x\n"},{"out":"2277532","err":"","code":"my $x = 2118 * 2119 / 2; $x += $_ * $_ for 1 .. sqrt 2118; $x\n"},{"code":"my $x = (3,2,1); $x\n","err":"","out":"1"},{"out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"my $x = '3 + 4 eq \"7\"; my @n = $x =~ /(\\d+)g/; [ @n ]\n","err":""},{"err":"","code":"my $x = '3 + 4 eq \"7\"'; my @n = $x =~ /(\\d+)/g; [ @n ]\n","out":"[3,4,7]"},{"code":"my $x = '3 + 4 eq \"7\"'; my @n = $x =~ /(\\d+)g/; [ @n ]\n","err":"","out":"[]"},{"err":"","code":"my $x = '3 + 4 eq \"7\"'; my @n = $x =~ /\\d+/g; [ @n ]\n","out":"[3,4,7]"},{"err":"","code":"my $x = 3; $x /= 3; $x\n","out":"1"},{"err":"","code":"my $x = 42; [  map { state $y = $x++; $y } 0..3 ];\n","out":"[42,42,42,42]"},{"code":"my $x = 42; sub { $x++ }->(); $x\n","err":"","out":"43"},{"out":"42","err":"","code":"my $x = \\42; $x->$*\n"},{"err":"","code":"my $x = ~42; [ $x =~ 42 ]\n","out":"[]"},{"code":"my $x = ~42; [ $x = ~42 ]\n","err":"","out":"['18446744073709551573']"},{"out":"x = ","err":"","code":"{ my $x = 42; } \"x = $x\"\n"},{"code":"my $x = 43; Internals::SvREADONLY $x, 1; $x = 23; $x\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"6","code":"my $x = ( 4, 5, 6 ); $x; ### Gives last value from comma list (comma operator.)\n","err":""},{"out":"4-9","err":"","code":"my $x = \"4-9\"; s/(\\d+)-(\\d+)/join \",\", $1..$2/e; $x\n"},{"code":"my $x = 55; sub foo { unless ($x) { return 'foo' } } [foo()]\n","err":"","out":"[55]"},{"code":"my @x = (5,6,7); print \"Hello\", scalar(@x), \"\\n\";\n","err":"","out":"Hello3\n"},{"out":"Hello567\n","err":"","code":"my @x = (5,6,7); print \"Hello\", @x, \"\\n\";\n"},{"code":"my @x = (5,6,7); \\@x\n","err":"","out":"[5,6,7]"},{"out":"[[5,6,7]]","err":"","code":"my @x = [5,6,7]; \\@x\n"},{"out":"789","err":"","code":"my @x = 7 .. 9; please, print @x;\n"},{"out":"789","err":"","code":"my @x = 7..9; print @x;\n"},{"out":"[\"true\",\"false\"]","err":"","code":"my %x = (a => 0); [ (exists $x{a} ? 'true' : 'false'), ($x{a} ? 'true' : 'false') ]\n"},{"out":"[\"REF\",123]","code":"my $x = \\{ a => 123 }; [ ref $x, $$x->{a} ]\n","err":""},{"out":"{a => 1}","code":"my %x = (a => 1); my $y = { %x }; delete $y->{a}; \\%x\n","err":""},{"out":"{}","code":"my %x = (a => 1); my $y = \\%x; delete $y->{a}; \\%x\n","err":""},{"out":"[\"bbb\"]","err":"","code":"my $x = 'aaa'; sub f { $_[0] = 'bbb';}; f($x); [$x]\n"},{"err":"","code":"my $x = 'aaa'; sub f { \\@_ }; my $y = f($x); $y->[0] = 'bbb'; $x\n","out":"bbb"},{"code":"my $x=\"ababababa\"; $x=~s/a/x/ for 1..3; $x\n","err":"","out":"xbxbxbaba"},{"out":"[4]","code":"my $x = \"a b a c a d a e\"; [$x =~ s/a/t/g]\n","err":""},{"out":"[\"\"]","code":"my $x = \"a b a c a d a e\"; [$x !~ s/a/t/g]\n","err":""},{"out":"cd","err":"","code":"my $x = 'abcd'; substr $x, 2 # but more importantly it'd make the code almost readable\n"},{"out":"a","err":"","code":"my $x = \"a\"; ${\\my $x} = \"b\"; $x\n"},{"out":"2;","err":"","code":"my $x = \"asdf\"; pos($x) = 1; { local pos($x) = 2; print pos $x, \";\";} pos $x\n"},{"out":"4;4","code":"my $x = \"asdf\"; pos($x) = 2; { local pos($x) = 4; print pos $x, \";\";} print pos $x\n","err":""},{"code":"my $x = \"asdf\"; pos($x) = 666; pos $x\n","err":"","out":"4"},{"err":"","code":"my $x = \"asdfX\"; my $y = \"asdfY\"; $x =~ /\\A\\Q$y\\E{0}.\\z/s ? \"yes\" : \"no\"\n","out":"yes"},{"err":"","code":"my $x = \"asdfX\"; my $y = \"asdfY\"; $x =~ /\\A(?>\\Q$y\\E??).\\z/s ? \"yes\" : \"no\"\n","out":"yes"},{"out":"no","err":"","code":"my $x = \"asdfY\"; my $y = \"asdfYt\"; $x =~ /\\A(?>\\Q$y\\E??).\\z/s ? \"yes\" : \"no\"\n"},{"err":"","code":"my $x = \"asdfYt\"; my $y = \"asdfY\"; $x =~ /\\A(?>\\Q$y\\E??).\\z/s ? \"yes\" : \"no\"\n","out":"no"},{"out":"ERROR: Can't declare scalar dereference in \"our\" at (eval 1) line 1, near \"$x =\"\n","err":"","code":"my $x; BEGIN { $x = 'x' } our $$x = 123; # basically this - the 'our' isn't doing anything useful so it can be left out entirely\n"},{"out":"(0, 7)(1, 8)(2, 9)","err":"","code":"my $x = bless [7,8,9], q{FOO}; print qq{($a, $b)} while ($a, $b) = each @$x; ### What I don't quite understand is that @$x to such a function works, so it wouldn't make sense for keys or so to do something similar, if UNIVERSAL::isa( $arg, q{ARRAY} ) @$arg or something like that? Or would overloading still muck with that?\n"},{"err":"","code":"my $x = bless [7,8,9], q{FOO}; UNIVERSAL::isa( $x, q{ARRAY} )\n","out":"1"},{"out":"[1,\"d\"]","err":"","code":"my @x = ('c', 'd'); [ %x[1] ]\n"},{"out":"[1,undef]","err":"","code":"my @x = ('c', 'd'); [ %x{1} ]\n"},{"err":"","code":"my $x = 'code'; print $$x;\n","out":"1"},{"out":"","err":"","code":"my $x = 'code'; $$x;\n"},{"code":"my $x = \"Data::Dumper\"; use $x;\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"use $x\"\n"},{"out":"[\\42]","code":"my $x = \\do {42}; [ $x ]\n","err":""},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my $x = \\do {42}; [ ++$$x ]\n"},{"out":"[43]","code":"my $x = \\do {my $o = 42}; [ ++$$x ]\n","err":""},{"err":"","code":"my $x = do { my $tmp; \\$tmp }; my $y = $x; $$y = 'foo'; print $$x; # porton is this what you want?\n","out":"foo"},{"out":"-1","err":"","code":"{ my $x = \"e\"; $x--; print $x }\n"},{"out":"{second => \"great success\"}","code":"my $x = { first => 'some error here', second => 'great success' }; my %h = map { ($x->{$_} !~ /error/) ? ($_ => $x->{$_}) : () } keys %$x; \\%h # like this, you mean?\n","err":""},{"code":"my $x = { foo => 1 }; my \\%y = $x; $y{bar} = 2; $x;\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"my \\\"\n"},{"out":"1oo4ar7az10uux14leem","code":"my $x = 'FooBarBazQuuxFleem'; my $off = 1; join '', map { (my $str = $_) =~ s/^./$off/; $off += length($_); $str } split /(?=[A-Z])/, $x;\n","err":""},{"code":"my $x = 'FooBarBazQuuxFleem'; my $off = 1; join '', map { (my $str = $_) =~ s/$/$off/; $off += length($_); $str } split /(?=[A-Z])/, $x;\n","err":"","out":"Foo1Bar4Baz7Quux10Fleem14"},{"out":"1oo4ar7az10uux14leem","err":"","code":"my $x = 'FooBarBazQuuxFleem'; $x =~ s/[A-Z]/$+[0]/g; $x\n"},{"out":"Foo4ar7azQuuxFleem","err":"","code":"my $x = 'FooBarBazQuuxFleem'; $x =~ s/B/$+[0]/g; $x\n"},{"err":"","code":"my $x = 'FooBarBazQuuxFleem'; $x =~ s/B/$+[0]/g; $x =~ s/Q/$+[0]/g; $x\n","out":"Foo4ar7az10uuxFleem"},{"out":"ERROR: Can't modify constant item in substitution (s///) at (eval 1) line 1, at EOF\n","code":"my $x = 'FooBarBazQuuxFleem'; $x =~ s/B/$+[0]/g; x =~ s/Q/$+[0]/g; $x\n","err":""},{"out":"[\"foo\",\"bar:baz\"]","code":"my $x = \"foo:bar:baz\"; [ $x =~ /\\A(.*?)(?:=|==|:|--)(.*)\\z/s ]\n","err":""},{"out":"[\"foo\",\"bar:baz\"]","code":"my $x = \"foo:bar:baz\"; $x =~ /=|==|:|--/ or die; [ substr($x, 0, $-[0]), substr($x, $+[0]) ]\n","err":""},{"err":"","code":"my $x = \"foo\"; my $f = sub { print $x }; $f->(); $x = \"bar\"; $f->();\n","out":"foobar"},{"code":"my @x = (\"foo\\n\", \"bar\", \"baz\\n\"); chomp @x; \\@x\n","err":"","out":"[\"foo\",\"bar\",\"baz\"]"},{"err":"","code":"my $x = 'foo'; $x ||= do { print 'bar'; 'baz' }; [ $x ];\n","out":"[\"foo\"]"},{"code":"my $x = 'foo'; $x &&= do { print 'bar'; 'baz' }; [ $x ];\n","err":"","out":"bar"},{"out":"","code":"my @x; for (@x) { print \"entered\" } # unless you mean something other than running code inside the foreach loop?\n","err":""},{"out":"3","code":"my $x; $_++ for ($x)x3; $x # two more examples\n","err":""},{"err":"","code":"my $x = 'Friseure'; [ map { $x =~ /e$/g; pos($x) } 1..10 ] # does this make it any clearer?\n","out":"[8,undef,8,undef,8,undef,8,undef,8,undef]"},{"out":"[\"nm37.bullet.mail.ir2.yahoo.com\",\"212.82.96.62\"]","code":"my $x=\"from nm37.bullet.mail.ir2.yahoo.com (nm37.bullet.mail.ir2.yahoo.com [212.82.96.62])\"; [ ($x =~ /[\\w.]+/g)[-2, -1] ] # tharkun\n","err":""},{"code":"my $x = \"Hello a and b\"; $x =~ s/\\b([ab])\\b/$1 eq 'a' ? \"l3u\" : \"rindolf\"/ge; [$x]\n","err":"","out":"[\"Hello l3u and rindolf\"]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"\"Hello anna!\" [\"\n","err":"","code":"my $x = \"Hello anna!\" [($x eq \"anna\" ? \"T\" : \"F\"), ($x =~ /anna/ ? \"T\" : \"F\")]\n"},{"out":"[\"F\",\"T\"]","err":"","code":"my $x = \"Hello anna!\"; [($x eq \"anna\" ? \"T\" : \"F\"), ($x =~ /anna/ ? \"T\" : \"F\")]\n"},{"err":"","code":"my $x = \"Hello \"; $x .= \"KNERD\"; [$x]\n","out":"[\"Hello KNERD\"]"},{"code":"my $x = \"hmm\"; [ (my $tmp = $x, undef $x)[0] ]\n","err":"","out":"[\"hmm\"]"},{"code":"my $x = \"hmm\"; [ (my $tmp = $x; undef $x)[0] ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, near \"$x)\"\n"},{"out":"[\"hmm\",undef]","code":"my $x = 'hmm'; [ ([$x]->[0], undef $x) ]\n","err":""},{"code":"my $x = 'hmm'; [ ([$x]->[0], undef $x)[0] ]\n","err":"","out":"[\"hmm\"]"},{"out":"[\"hmm\"]","code":"my $x = 'hmm'; [ (\"$x\", undef $x)[0] ]\n","err":""},{"err":"","code":"my $x = 'hmm'; [ ($x, undef $x)[0] ]\n","out":"[undef]"},{"out":"[undef]","code":"my $x = 'hmm'; [ [$x, undef $x]->[0] ]\n","err":""},{"out":"","code":"my $x = \"Host: myHost\\n\";  my ($targetHost) = $heap->{buffer} =~ m#Host: (.*?)#; return $targetHost;\n","err":""},{"code":"my $x = []; if ($x) { print \"a ref is true even when it refers to empty\" }\n","err":"","out":"a ref is true even when it refers to empty"},{"err":"","code":"my $x = 'interpolates?'; qq'$x';\n","out":"interpolates?"},{"err":"","code":"my $x = 'interpolates?'; q\"$x\";\n","out":"$x"},{"err":"","code":"my %x; local keys %x;\n","out":"ERROR: Can't modify keys in local at (eval 1) line 1, at EOF\n"},{"code":"my %x; local keys %x = \"hi\";\n","err":"","out":"ERROR: Can't modify keys in local at (eval 1) line 1, near \"%x =\"\n"},{"err":"","code":"my @x; local $x[0] = 42; \"@x\";\n","out":"42"},{"err":"","code":"my @x; local $x[0] = 42; @x;\n","out":"1"},{"err":"","code":"my @x; local $x[0] = 42; \\@x;\n","out":"[]"},{"out":"[3,30,6,60]","code":"my @x = (map { $_ * 10 } 0 .. 9); [%x[3,6]]\n","err":""},{"out":"3","err":"","code":"my @x = map { no strict qw(refs); $_; } 1..3; ### Why does this generate an error regarding the use of `no` ?\n"},{"err":"","code":"my @x = map { qq{$_\\n} } qw/ABC DEF 123 GHI/; join q{}, map { $_ x= !m!\\d+!; } @x ;\n","out":"ABC\nDEF\nGHI\n"},{"err":"","code":"my @x = map /^(\\w+)/g, \"some test line\"; \\@x; # This is what I meant.\n","out":"[\"some\"]"},{"code":"my @x = map /^(\\w+)/m, \"some test line\"; \\@x; # Passing flags can be useful.\n","err":"","out":"[\"some\"]"},{"out":"[\"some\"]","err":"","code":"my @x = map /^(\\w+)/, \"some test line\"; \\@x; # yet another way to do it.\n"},{"out":"some","code":"my @x; my $line = \"some test line\"; push @x, $line =~ /^(\\w+)/; print for @x; # another way to write the same thing\n","err":""},{"out":"[\\undef,\\undef]","code":"[\\(my $x, my $y)]\n","err":""},{"out":"[undef,\"1E0\"]","err":"","code":"my $x; my $y = 1..1; [ $x, $y ]; ### Why exactly does assigning a range in scalar context result in the lhs being an empty string (not undef) ?\n"},{"out":"[1]","err":"","code":"my $x = \"\" ; my $y; [ ($x // '') eq ($y // '') ]\n"},{"out":"[1]","err":"","code":"my $x = \"\\n\"; [ $_ = chomp $x ]\n"},{"code":"my $x = \"\\n\"; [chomp($x);]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"out":"[1]","code":"my $x = \"\\n\"; [chomp($x)]\n","err":""},{"err":"","code":"my $x = \"\\n\"; chomp($x); print $x;\n","out":"1"},{"out":"[1]","err":"","code":"my $x = \"\\n\"; [ $x = chomp $x ]\n"},{"err":"","code":"my $x = \"\\n\"; [$x = chomp $x, $x]\n","out":"[1,1]"},{"out":"1","err":"","code":"my $x = \"\\n\"; $x = chomp $x; $x\n"},{"out":"1","err":"","code":"my $x = \"\\n\"; $x = chomp($x); $x\n"},{"out":"[\"One Two Three\"]","code":"my @x = (\"One\", \"Two\", \"Three\"); [join(\" \", @x)]\n","err":""},{"out":"[0,1,0,1]","code":"my @x; push @x, foo(), foo(); { my $var = 0; sub foo { $var++ } } push @x, foo(), foo(); \\@x\n","err":""},{"out":"[\"X\",\"Y\",\"Z\",\"A\",\"B\",\"C\"]","err":"","code":"my @x; push @x, qw( A B C ); unshift @x, qw( X Y Z ); \\@x;\n"},{"out":"[\"test\"]","err":"","code":"my @x; push @x, /^(\\w+)/ for 'test something'; \\@x;\n"},{"out":"1","code":"my $x = q{abc}; !!$x;\n","err":""},{"code":"my $x = q{FOO\\tBAR\\r\\n}; ( my $y = $x ) =~ s/\\\\t/\\t/g; $y =~ s/\\\\r/\\r/g; $y =~ s/\\\\n/\\n/g; [ $x, $y ];\n","err":"","out":"[\"FOO\\\\tBAR\\\\r\\\\n\",\"FOO\\tBAR\\r\\n\"]"},{"err":"","code":"my $x = q{}; int !!$x;\n","out":"0"},{"out":"Regexp=REGEXP(0x3511a70)","err":"","code":"my $x = qr/bar/; no overloading; \"$x\";\n"},{"out":"(?^u:bar)","err":"","code":"my $x = qr/bar/; \"$x\"; # vs.\n"},{"out":"(?^ux:what does this do)","code":"my $x = qr/what does this do/x; \"$x\"\n","err":""},{"err":"","code":"my $x = qr/\\w+/; [ $x, qr/$x/ ]; # Why can't dclone just handle Regexp objects like this?\n","out":"[qr/\\w+/u,qr/\\w+/u]"},{"out":"[qr/x/u,$VAR1->[0]]","code":"my $x = qr/x/; my $y = $x; [ $x, $y ];\n","err":""},{"code":"my @x = qw/1 2 3/; $_+=3 for @x; \\@x\n","err":"","out":"[4,5,6]"},{"err":"","code":"my @x = qw/1 2 3 4/; delete $x[-1]; print $_ // '!' for @x;\n","out":"123"},{"out":"123!","err":"","code":"my @x = qw/1 2 3 4/; $x[-1] = undef; print $_ // '!' for @x;\n"},{"err":"","code":"my @x = qw( @ A 1 B 2 C 3 ); foreach my $i ( 1 .. $#x ) { my ( $k, $v ) = ( $x[ $i ], $x[ $i++ + 1 ] ); print qq{$k => $v | }; }\n","out":"A => 1 | 1 => B | B => 2 | 2 => C | C => 3 | 3 =>  | "},{"out":"A => 1 | B => 2 | C => 3 | ","err":"","code":"my @x = qw( @ A 1 B 2 C 3 ); for ( my $i = 1; $i < @x; $i++ ) { my ( $k, $v ) = ( $x[ $i ], $x[ $i++ + 1 ] ); print qq{$k => $v | }; }\n"},{"err":"","code":"my @x = qw(a b c d d a b a c a c c c d e f g h); for(@x) { if($seen{$_}) { $_ = $_ . \"_\" . $seen{$_}++ } else { $seen{$_} = \"aa\" } } \\@x # like this, or something else?\n","out":"[\"a\",\"b\",\"c\",\"d\",\"d_aa\",\"a_aa\",\"b_aa\",\"a_ab\",\"c_aa\",\"a_ac\",\"c_ab\",\"c_ac\",\"c_ad\",\"d_ab\",\"e\",\"f\",\"g\",\"h\"]"},{"out":"a!cd","code":"my @x = qw(a b c d); delete $x[1]; print $_ // '!' for @x;\n","err":""},{"code":"my %x = qw(a b c d e f g h); [ @x{a, g} ]\n","err":"","out":"[\"b\",\"h\"]"},{"out":"{g => \"h\",a => \"b\"}","code":"my %x = qw(a b c d e f g h); @y{a, g} = @x{a, g}; \\%y\n","err":""},{"err":"","code":"my @x = ( qw( A B C ) ); { exists => [ map { exists $x[ $_ ] } 0..5 ], x => \\@x };\n","out":"{exists => [1,1,1,\"\",\"\",\"\"],x => [\"A\",\"B\",\"C\"]}"},{"err":"","code":"my @x = qw(a b c); splice @x, 1, 1; \\@x # if you want to remove an element from the array, use splice, pop or shift\n","out":"[\"a\",\"c\"]"},{"out":"[\"a\",undef,\"c\"]","code":"my @x = qw(a b c); undef $x[1]; \\@x # if you want to set a specific element to undef, use undef\n","err":""},{"code":"my $x = qw(a b c); $x # it's the list/scalar context that determines what you get\n","err":"","out":"c"},{"out":"[\\\"foo\",\\\"bar\",\\\"baz\",\\1,\\2,\\3,\\42]","err":"","code":"my @x = qw(foo bar baz); my @y = 1..3; [ \\(map {$_} @x, @y, 42) ]\n"},{"out":"[[\"foo\",\"bar\",\"baz\"],[1,2,3],\\42]","code":"my @x = qw(foo bar baz); my @y = 1..3; [ \\((@x, @y, 42)) ]\n","err":""},{"code":"my @x = qw(foo bar baz); my @y = 1..3; [ \\(@x, @y, 42) ]\n","err":"","out":"[[\"foo\",\"bar\",\"baz\"],[1,2,3],\\42]"},{"out":"3","err":"","code":"my $x = () = qw(foo bar baz); $x\n"},{"out":"2","code":"my @x = qw/foo bar/; my $y = (123 => @x); $y # or the usual fun\n","err":""},{"code":"my @x = qw(x y z); my @y = do { push @x, my @x = q chic; @x }; [ \\@x, \\@y ]\n","err":"","out":"[[\"x\",\"y\",\"z\",\"hi\"],[\"hi\"]]"},{"out":"2","code":"my @x = qw(zero one two); my ($idx) = grep $x[$_] eq 'two', 0 .. $#x; $idx\n","err":""},{"code":"my $x = q{}; !!$x;\n","err":"","out":""},{"err":"","code":"my $x = []; ref \\$x\n","out":"REF"},{"out":"hello world","err":"","code":"my @xs; bless \\@xs, \"hello world\"; ref \\@xs\n"},{"out":"","err":"","code":"my $x :shared;\n"},{"err":"","code":"my $x = '/somepath/subdir'; $y = '/newpath/newdir'; my $data = '/somepath/subdir/whatever.txt'; $data =~ s/\\Q$x/$y/g; [ $data ]\n","out":"[\"/newpath/newdir/whatever.txt\"]"},{"code":"my $x = 'some test'; my $y = \\substr($x, 5, 4); $$y = 'data'; $x\n","err":"","out":"some data"},{"err":"","code":"my $x = \"something\"; qq/'\" foo bar baz '\" $x/\n","out":"'\" foo bar baz '\" something"},{"out":"[\"some var\",\"some thing\"]","err":"","code":"my $x = 'some var'; my $y = $x =~ s/var/thing/r; [ $x, $y ]\n"},{"out":"[\"l\",\"p\",\"b\",\"o\",\"d\",\"z\",\"a\"]","err":"","code":"my @xs = qw/a b d z o l p a l/; [ keys %{{ @xs, reverse @xs }} ]\n"},{"err":"","code":"my $x = sub (\\@) { \"$_[0]\" }; my @a = (3, 4); print &$x(@a); ()\n","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(\\\"\n"},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(\\\"\n","err":"","code":"my $x = sub (\\@) { \"$_[0]\" }; my @a = (3, 4); $x->(@a)\n"},{"err":"","code":"my $x; sub foo:lvalue { return $x } foo() = 123; $x;\n","out":"123"},{"out":"[\\undef,$VAR1->[0]]","code":"my $x; sub lala { \\$x } [\\$x, lala()] # identical\n","err":""},{"out":"ERROR: Too many arguments for subroutine at (eval 1) line 1.\n","code":"my $x = sub ($) { @_ }; *x = $x; [ join ' ', $x->('a'..'c'), '|', x('a'..'c') ]\n","err":""},{"out":"testblah","err":"","code":"my $x = 'test$blah'; $x =~ s#[^a-zA-Z0-9 ]##g; $x\n"},{"code":"my $x = \"test$blah\"; $x =~ s#[^a-zA-Z0-9 ]##g; $x\n","err":"","out":"test"},{"out":"...","err":"","code":"my $x = 'testing'; for ($x) { (sub { $_ = shift; return /firefox/ })->('...') } $x # no, probably not okay\n"},{"code":"my $x = \\undef; &Internals::SvREADONLY($x, 0); $$x = 3; [ undef ]\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"my $x = \\undef; &Internals::SvREADONLY($x, 0); $$x = Scalar::Util::dualvar 0, \"lemons\"; [ undef, defined undef ]\n","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"my $x = \\undef; &Internals::SvREADONLY($x, 0); $$x = Scalar::Util::dualvar 0, \"lemons\"; [ undef ] # maybe?\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","err":"","code":"my $x = unpack \"b*\", \"this is a test\"; $c\n"},{"out":"0010111000010110100101101100111000000100100101101100111000000100100001100000010000101110101001101100111000101110","err":"","code":"my $x = unpack \"b*\", \"this is a test\"; $x\n"},{"out":"[undef,undef,undef,undef]","err":"","code":"my @x; [ @x[0..3] ]\n"},{"err":"","code":"my %x; $x[1] = 1;\n","out":"1"},{"out":"ERROR: Can't modify index/value array slice in list assignment at (eval 1) line 1, at EOF\n","code":"my %x; %x[1] = 1; # gives a syntax error\n","err":""},{"err":"","code":"my ($x, $x) = (1, 2); $x\n","out":"2"},{"out":"5","code":"my %x; $x{a} = 4; @x{a} = (5); print $x{a}\n","err":""},{"out":"5","code":"my %x; $x{a} = 4; @x{'a','b'} = (5); print $x{a}\n","err":""},{"code":"my $x; $x{abc} = 123; $x\n","err":"","out":""},{"err":"","code":"my $x; $x ||= do { print 'bar'; 'baz' }; [ $x ];\n","out":"bar"},{"code":"my $x; $x &&= do { print 'bar'; 'baz' }; [ $x ];\n","err":"","out":"[undef]"},{"out":"ERROR: Can't call method \"what_did_you_expect\" on an undefined value at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my $x; $x->what_did_you_expect\n"},{"code":"my @x; { ++$#x } \\@x\n","err":"","out":"[undef]"},{"code":"my $x; $x++; $x\n","err":"","out":"1"},{"code":"my $x = []; $x == \\@$xs ? \"yes\" : \"no\"\n","err":"","out":"no"},{"out":"1","code":"my $x; $x ? $x++ : ( $x = 1 ); $x;\n","err":""},{"err":"","code":"my $x = {}; $x->{x} = $x; $x\n","out":"{x => $VAR1}"},{"err":"","code":"my $x = []; $x == \\@$x ? \"yes\" : \"no\"\n","out":"yes"},{"code":"my ($x, $y) = 1..10;\n","err":"","out":"10"},{"err":"","code":"my ( $x, $y ) = ( 2733.754, 60 ); sprintf q{%.3f}, $x - int( $x/$y ) * $y;\n","out":"33.754"},{"out":"33.754","code":"my ( $x, $y ) = ( 2733.754, 60 ); ( ( $x * 10000 ) - ( int($x/$y) * $y * 10000) ) / 10000; ### :)\n","err":""},{"err":"","code":"my ( $x, $y ) = ( 2733.754, 60 ); $x - int( $x/$y ) * $y; ### :)\n","out":"33.7539999999999"},{"out":"11","err":"","code":"my ($x, $y) = 9..19;\n"},{"err":"","code":"my $x->{y} = $x;\n","out":""},{"out":"[undef,undef]","err":"","code":"my ($x, $y); ${'x'} = 123; ${'y'} = 456;  [ $x, $y ] # even typo fixes I can't see how that would ever work\n"},{"out":"Zoooooofix","err":"","code":"my $x = 'Zoffix'; substr($x, 2, 1) = 'ooooo'; $x\n"},{"out":"45","code":"my @y = 1..9; my $x = (map { $y[$_-1] += $y[$_] } reverse 1..$#y)[-1]; $x # death.\n","err":""},{"err":"","code":"my $y=1; my $x=\\$y; ++$x; [$x, $y]\n","out":"[70885241,1]"},{"out":"6","code":"my @y = ( 4, 5, 6 ); my $x = ( 0, @y[0 .. $#y] ); $x\n","err":""},{"code":"my @y = ( 4, 5, 6 ); my $x = ( 0, @y ); ### I thought that would work, but I see it interprets @y in ( 0, @y ) in scalar context, effectively being ( 0, 3 ) rather than ( 0, 4, 5, 6 )\n","err":"","out":"3"},{"out":"3","code":"my @y = ( 4, 5, 6 ); my $x = @y; $x; ### Gives size of list instead, as expected here. Is there a way to get the last item in the list, similar to how the comma operator would, like above?\n","err":""},{"out":"[42,{x => 42}]","err":"","code":"my %y; my $x; \\$x = \\$y{x}; $x = 42; [ $x, \\%y ]\n"},{"out":"[42,{x => 42}]","code":"my %y; our $x; *x = \\$y{x}; $x = 42; [ $x, \\%y ]\n","err":""},{"out":"A\nB \"foo bar baz\" C\nD\n","code":"my $y = q{bar}; my @x = <A \"B \\\\\"foo $y baz\\\\\" C\" D>; print qq{$_\\n} for @x; # Seems to do everything I've seen people over and over ask if qw() could do.\n","err":""},{"code":"my $y = q|foo{x,y,z}|; my @x = < $y >; \\@x;\n","err":"","out":"[\"foox\",\"fooy\",\"fooz\"]"},{"err":"","code":"my $y = q{x y z}; my @x = <A \"B foo\" C $y D \"$y\" E>; \\@x; # Feels a little like bash.\n","out":"[\"A\",\"B foo\",\"C\",\"x\",\"y\",\"z\",\"D\",\"x y z\",\"E\"]"},{"code":"my @z = my $ret = my ($x, $y) = 9..19; [ $ret, $x, $y, \\@z ]; # Basically just assigning $ret to @z, a la @z = $ret;\n","err":"","out":"[11,9,10,[11]]"},{"err":"","code":"myÂ %argsÂ =Â {domainÂ =>Â \"example.net\", numberÂ =>Â 0;};\n","out":"ERROR: Unrecognized character \\xC2; marked by <-- HERE after tures/; my<-- HERE near column 93 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n","err":"","code":"my $_ = \"åå\"; s/(.)/sprintf('\\\\u%04x', $1)/ger\n"},{"code":"\"\\n\" =~ /^$/\n","err":"","out":"1"},{"code":"['\\n']\n","err":"","out":"[\"\\\\n\"]"},{"out":"[\"\\n\"]","err":"","code":"[\"\\n\"]\n"},{"err":"","code":"$n = 0; 5 / ($n || 1)\n","out":"5"},{"out":"1 1 2 3 5 8 13 21 34 55 ","err":"","code":"$n=10;$==0,(1x$_)=~/^(1|11(??{}))*$(?{$=++})^/,print\"$= \"for 0..$n-1\n"},{"code":"$n=10;$==0,(1x$_)=~/^(1|11(?{}))*$(?{$=++})^/,print\"$= \"for 0..$n-1\n","err":"","out":"1 1 2 2 2 2 2 2 2 2 "},{"out":"1 1 2 2 2 2 2 2 2 2 ","code":"$n=10;$==0,(1x$_)=~/^(1|11)*$(?{$=++})^/,print\"$= \"for 0..$n-1\n","err":""},{"code":"$n = 11111111113232323232 ; $d = $n << 32 >> 32 ; $d1 = ($n - $d) >> 32 ;  $r = pack(\"N\",$d1) . pack(\"N\",$d) ; print unpack(\"H*\",$r) .\"\\n\"\n","err":"","out":"9a3298b0341b92a0\n"},{"err":"","code":"$n = 232 ; $d = $n << 32 >> 32 ; $d1 = ($n - $d) >> 32 ;  $r = pack(\"N\",$d1) . pack(\"N\",$d) ; print unpack(\"H*\",$r) .\"\\n\"\n","out":"00000000000000e8\n"},{"out":"ffffffffffffffff\n","err":"","code":"$n = 23342342342342342342 ; $d = $n << 32 >> 32 ; $d1 = ($n - $d) >> 32 ;  $r = pack(\"N\",$d1) . pack(\"N\",$d) ; print unpack(\"H*\",$r) .\"\\n\"\n"},{"err":"","code":"$n = 42; $, = ' '; print ++$n, ++$n, ++$n, ++$n  # oh, really\n","out":"46 46 46 46"},{"code":"$n = 4; [ 'abcdefghi' =~ /c@{['(.)'x$n]}/ ]\n","err":"","out":"[\"d\",\"e\",\"f\",\"g\"]"},{"out":"5","err":"","code":"$n = 5; $n = $n++; $n\n"},{"out":"6","err":"","code":"$n = 5; $n = ++$n; $n\n"},{"code":"$\\=\"\\n\"; $_ = \"ab\"; print; $_++; print; $_+0; print; $_++; print\n","err":"","out":"ab\nac\nac\n1\n\n"},{"out":"ab\nac\nac\n1\n\n","code":"$\\=\"\\n\"; $_ = \"ab\"; print; $_++; print; $_+0; print; $_++; print; ()\n","err":""},{"out":"No such file or directory","err":"","code":"$! = 'NaN'; $!\n"},{"err":"","code":"'nan'/0\n","out":"ERROR: Illegal division by zero at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"NaN/0\n","err":"","out":"bless( {sign => \"NaN\",value => [0]}, 'Math::BigInt' )"},{"out":"","code":"!!( \"nan\" <= 1.0 )\n","err":""},{"out":"","code":"\"NaN\" <=> \"NaN\"\n","err":""},{"out":"0","err":"","code":"(\"NaN\" <=> \"NaN\") + 0\n"},{"out":"banana","code":"'na'x3^\"\\f\"\n","err":""},{"out":"","code":"\"\\n\" =~ /\\A\\z/\n","err":""},{"code":"\"\\N{BEER MUG}\"\n","err":"","out":"ÃÂ°ÃÂÃÂÃÂº"},{"out":"1","code":"\"\\nD\" =~ /^D/m\n","err":""},{"out":"needs more :","code":"'needs more :'\n","err":""},{"out":"[\"true\",\"true\"]","code":"$new = true; [$new, true]\n","err":""},{"out":"","code":"{ next }\n","err":""},{"out":"[{a => {}}]","err":"","code":"{ next if $x->{a}{b}; } [ $x ]\n"},{"code":"\"nickserv!nickserv@blah\"\n","err":"","out":"nickserv!nickserv"},{"code":"\"\\N{INTERROBANG}\" x 3 . \"HELLO\" . \"\\N{INTERROBANG}\" x 3\n","err":"","out":"ÃÂ¢ÃÂÃÂ½ÃÂ¢ÃÂÃÂ½ÃÂ¢ÃÂÃÂ½HELLOÃÂ¢ÃÂÃÂ½ÃÂ¢ÃÂÃÂ½ÃÂ¢ÃÂÃÂ½"},{"out":"1","code":"\"\\n\" =~ /\\n/\n","err":""},{"out":"[\"   hello\\n\"]","err":"","code":"[ \"  \\n   \\n  \\n   hello\\n\" =~ s/^\\s*\\n//r ]\n"},{"code":"\"  \\n   \\n  \\nhello\\n\" =~ s/^\\s*//sr\n","err":"","out":"hello\n"},{"out":"[\"TAG\\n\"]","err":"","code":"$_ = \"\\n\\nTAG\\n\\n\\n\"; s/\\A\\n+//; s/\\n+\\z/\\n/; [ $_ ]\n"},{"code":"no arybase;\n","err":"","out":""},{"code":"no autovivification 'delete'; delete $undef->{key}; $undef\n","err":"","out":"ERROR: Can't locate autovivification.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"$nodes[5] = 1; \\@nodes\n","err":"","out":"[undef,undef,undef,undef,undef,1]"},{"out":"[0]","err":"","code":"@nodeStatus = (0) * 150; \\@nodeStatus\n"},{"out":"[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]","err":"","code":"@nodeStatus = (0) x 150; \\@nodeStatus\n"},{"code":"no feature ':all'; sub foo (;$) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \\%h\n","err":"","out":"{meow => \"moo\",bar => [42]}"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"} 1\"\n","err":"","code":"no feature; no indirect 'fatal'; sub new { bless [] }; [ new {main} 1,2 ]\n"},{"code":"no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new { bless [] }; [ new {main} ]\n","err":"","out":"[bless( [], 'foo' )]"},{"err":"","code":"no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new { bless [] }; [ new main ]\n","out":"ERROR: Indirect call of method \"new\" on object \"main\" at (eval 1) line 1.\n"},{"out":"[bless( [], 'foo' )]","err":"","code":"no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new(*) { bless [] }; [ new main ]\n"},{"code":"no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new { die @_ }; [ new {main} 1,2 ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"} 1\"\n"},{"out":"[bless( [], 'foo' )]","err":"","code":"no feature; no indirect; sub new { bless [] }; package foo; sub new(*) { bless [] }; [ new main ]\n"},{"out":"[\"foo\\nbar\\nbaz\\n\"]","code":"no feature 'say'; open $fh, \">\", \\$str; say $fh $_ for qw,foo bar baz,; [ $str ]\n","err":""},{"code":"no feature 'say'; open $fh, \">\", \\$str; say($fh $_) for qw,foo bar baz,; [ $str ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"$fh $_\"\n"},{"code":"no feature 'signatures'; sub foo (\\@) { say @_ };  foo +(split //, \"foobar\")\n","err":"","out":"ERROR: Type of arg 1 to main::foo must be array (not split) at (eval 1) line 1, at EOF\n"},{"out":"ERROR: Type of arg 1 to main::bar must be array (not constant item) at (eval 1) line 1, near \"3)\"\nToo many arguments for main::bar at (eval 1) line 1, near \"3)\"\n","code":"no feature 'signatures'; sub foo { [@_] } sub bar (\\@) { [@_] } [foo(1,2,3), bar(1,2,3)]\n","err":""},{"out":"[{thingy => 1},2,3]","code":"no feature 'signatures'; sub foo ($) { {thingy => $_[0]} } [foo 1, 2, 3]\n","err":""},{"err":"","code":"no feature 'signatures'; sub sort_subset_by (\\@@) { my ($expected, @stuff) = @_; my %in = map { ($_ => 1) } @stuff; return grep { $in{$_} } @$expected; } my @exp = (5,4,3,2,1); my @arr = (2,3,4); [sort_subset_by @exp, @arr]\n","out":"[4,3,2]"},{"code":"no feature; sub new { bless [] }; package foo; sub new(*) { bless [] }; [ new main ]\n","err":"","out":"[bless( [], 'foo' )]"},{"out":"[]","err":"","code":"no feature 'unicode_strings'; my $d = my $u; utf8::upgrade($u); utf8::downgrade($d); [ map /\\w/, $u, $d ]\n"},{"out":"[1,0]","err":"","code":"no feature 'unicode_strings'; my $d = my $u = \"\\x{df}\"; utf8::upgrade($u); utf8::downgrade($d); [ map 0+/\\w/, $u, $d ]\n"},{"err":"","code":"no feature 'unicode_strings'; my $d = my $u = \"\\x{df}\"; utf8::upgrade($u); utf8::downgrade($d); [ map /\\w/, $u, $d ]\n","out":"[1]"},{"out":"1","code":"no feature 'unicode_strings'; \"\\N{U+666}\" =~ /\\d/\n","err":""},{"out":"ERROR: Can't locate object method \"parse\" via package \"backwards\" (perhaps you forgot to load \"backwards\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"no indirect; parse backwards;\n","err":"Indirect call of method \"parse\" on object \"backwards\" at (eval 1) line 1.\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"new main \"\n","code":"no indirect; sub main { bless [] }; [ new main ]\n","err":""},{"err":"","code":"\"No output.\"\n","out":"No output."},{"code":"no overloading; '' . *STDOUT{IO};\n","err":"","out":"IO::File=IO(0x17e0fb8)"},{"code":"no 'strict'\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"no 'strict'\"\n"},{"err":"","code":"no strict; [ Foo ]\n","out":"[\"Foo\"]"},{"err":"","code":"no strict 'refs';  my $lexicalvar = \"hello\";  ${\"lexicalvar\"}\n","out":""},{"code":"no strict 'refs';  our $packagevar = \"hello\";  ${\"packagevar\"}\n","err":"","out":"hello"},{"code":"no strict; sub Foo { \"Bar\" }; [ Foo ]\n","err":"","out":"[\"Bar\"]"},{"out":"{one => [[\"a\",0,\"F\"],[\"b\",1,\"N\"],[\"c\",2,\"N\"]],two => [[\"x\",0,\"F\"],[\"y\",1,\"N\"],[\"z\",2,\"N\"]]}","err":"","code":"no strict 'vars'; sub foo { local $n = $n//0; my @p = (shift, $n, $n ? 'N' : 'F'); ++$n; @_ ? (\\@p, &foo) : \\@p }; { 'one' => [foo('a'..'c')], 'two' => [foo('x'..'z')] };\n"},{"err":"","code":"no strict 'vars'; sub foo { local $n = $n//0; my @p = [ shift, $n, $n ? 'N' : 'F' ]; ++$n; @_ ? [ @p, foo( @_ ) ] : \\@p }; { 'one' => foo('a'..'c'), 'two' => foo('x'..'z') };\n","out":"{one => [[\"a\",0,\"F\"],[[\"b\",1,\"N\"],[[\"c\",2,\"N\"]]]],two => [[\"x\",0,\"F\"],[[\"y\",1,\"N\"],[[\"z\",2,\"N\"]]]]}"},{"out":"{one => [\"a\",0,\"F\",\"b\",0,\"F\",\"c\",0,\"F\"],two => [\"x\",0,\"F\",\"y\",0,\"F\",\"z\",0,\"F\"]}","err":"","code":"no strict 'vars'; sub foo { local $n = $n//0; my @p = (shift, $n, $n ? 'N' : 'F'); @_ ? (@p, &foo) : @p }; { 'one' => [foo('a'..'c')], 'two' => [foo('x'..'z')] };\n"},{"out":"{one => [[\"a\",0,\"F\"],[\"b\",0,\"F\"],[\"c\",0,\"F\"]],two => [[\"x\",0,\"F\"],[\"y\",0,\"F\"],[\"z\",0,\"F\"]]}","err":"","code":"no strict 'vars'; sub foo { local $n = $n//0; my @p = (shift, $n, $n ? 'N' : 'F'); @_ ? (\\@p, &foo) : \\@p }; { 'one' => [foo('a'..'c')], 'two' => [foo('x'..'z')] };\n"},{"code":"[ No::Such::Class->import() ]\n","err":"","out":"[]"},{"out":"{not => \"a block\"}","err":"","code":"{ not => 'a block' }\n"},{"out":"","err":"","code":"$nothing=\"a\"; print \"Nothing found\\n\" if $nothing !~ /^\\w+/;\n"},{"code":"$nothing=\"\"; if ($nothing !~ /./) { print \"Nothing found\\n\" }\n","err":"","out":"Nothing found\n"},{"code":"$nothing=\"\"; print \"Nothing found\\n\" if $nothing eq \"\";\n","err":"","out":"Nothing found\n"},{"out":"Nothing found\n","err":"","code":"$nothing=\"\"; print \"Nothing found\\n\" if $nothing !~ /^\\w+/;\n"},{"code":"no utf8; encode 'UTF-8', 'ÃÂ¡r jÃÂº sÃÂºr?'\n","err":"","out":"ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ¡r jÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂº sÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂºr?"},{"code":"no utf8; printf \"%vd\", \"Ã¼\"  # does this even work\n","err":"","out":"195.188"},{"code":"{no utf8; $x=\"âââ\" }; $x\n","err":"","out":"ÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂ"},{"code":"\"\\N{PILE OF POO}\"\n","err":"","out":"ÃÂ°ÃÂÃÂÃÂ©"},{"code":"[ $., $NR ]\n","err":"","out":"[1,undef]"},{"code":"\"\\N{REGIONAL INDICATOR SYMBOL LETTER Z}\\N{REGIONAL INDICATOR SYMBOL LETTER A}\"\n","err":"","out":"ÃÂ°ÃÂÃÂÃÂ¿ÃÂ°ÃÂÃÂÃÂ¦"},{"err":"","code":"\"\\n\\r\\n\"\n","out":"\n\r\n"},{"err":"","code":"\"\\n\" =~ /\\s/\n","out":"1"},{"out":"no match","err":"","code":"\"\\n\" =~ /(?[ \\s - [\\n] ])/ ? \"match\" : \"no match\"\n"},{"err":"","code":"\"\\n\" =~ (?[ \\s - [\\n] ]) ? \"match\" : \"no match\"\n","out":"ERROR: Substitution pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ÃÂ¢ÃÂÃÂ","code":"\"\\N{SNOWMAN}\"\n","err":""},{"err":"","code":"\"\\N{SPARKLE}\"\n","out":"ÃÂ¢ÃÂÃÂ"},{"err":"","code":"\"\\N{SPARKLE}\";\n","out":"ÃÂ¢ÃÂÃÂ"},{"out":"[\"\\x{2747}\"]","err":"","code":"[ \"\\N{SPARKLE}\" ]\n"},{"code":"[ \"\\N{test}\" ]\n","err":"","out":"ERROR: Unknown charname 'test' at (eval 1) line 1, within string\n"},{"code":"\"\\N{U+00A2}\"\n","err":"","out":"ÃÂ¢"},{"out":"match","code":"\"\\N{U+0B}\" =~ /(?[ \\s - [\\n] ])/ ? \"match\" : \"no match\"\n","err":""},{"out":"ÃÂ°ÃÂÃÂÃÂ«","code":"\"\\N{U+1f52b}\"\n","err":""},{"code":"\"\\N{U+666}\" =~ /\\d/\n","err":"","out":"1"},{"out":"ERROR: Illegal number of bits in vec at (eval 1) line 1, <STDIN> line 1.\n","code":"$num = 0b00000011111111111111111111111111; [vec($num, 0, 26), vec($num, 26, 6)]\n","err":""},{"err":"","code":"$num = -1.67; int($num + $num / abs($num * 2));\n","out":"-2"},{"out":"b1n2n3","code":"$num = 1; \"banana\" =~ s/a/$num++/ger\n","err":""},{"out":"btest: 1ntest: 2ntest: 3","err":"","code":"$num = 1; \"banana\" =~ s/a/\"test: ${\\$num++}\"/ger\n"},{"out":"btest: 1++ntest: 1++ntest: 1++","err":"","code":"$num = 1; \"banana\" =~ s/a/\"test: $num++\"/ger\n"},{"out":"b1n2n3","err":"","code":"$num = 1; \"banana\" =~ s/a/test: $num++/ger\n"},{"code":"$num=2**32; $digits=reverse $num; $digits =~ s/(\\d\\d\\d)(?=\\d)(?!\\d*\\.)/$1,/g; $num=reverse $digits; print $num\n","err":"","out":"4,294,967,296"},{"err":"","code":"$num=2**32; $digits=reverse $num; $digits =~ s/(\\d\\d\\d)(?=\\d)(?!\\d*\\.)/$1,/g; print $digits;\n","out":"692,769,492,4"},{"out":"1","err":"","code":"$num='2**32'; $digits=reverse $num; $digits =~ s/(\\d\\d\\d)(?=\\d)(?!\\d*\\.)/$1,/g; print reverse $digist;\n"},{"code":"$num='2**32'; $digits=reverse $num; $digits =~ s/(\\d\\d\\d)(?=\\d)(?!\\d*\\.)/$1,/g; print reverse $digits;\n","err":"","out":"23**2"},{"out":"692,769,492,4","err":"","code":"$num=2**32; $digits=reverse $num; $digits =~ s/(\\d\\d\\d)(?=\\d)(?!\\d*\\.)/$1,/g; print reverse $digits;\n"},{"err":"","code":"$num=\"2\"; $num = sprintf(\"%02d\", $num); print $num\n","out":"02"},{"out":" 2","err":"","code":"$num=\"2\"; $num = sprintf(\"%2d\", $num); print $num\n"},{"err":"","code":"@nums = (30, 7, 200, 40, 5, 1000); [ [ sort @nums ], [ sort { $a <=> $b } @nums ] ] # string-sort using default cmp vs numeric <=>\n","out":"[[1000,200,30,40,5,7],[5,7,30,40,200,1000]]"},{"out":"ERROR: Unknown charname 'VERTICAL TAB' at (eval 1) line 1, within string\n","code":"\"\\N{VERTICAL TAB}\" =~ /(?[ \\s - [\\n] ])/ ? \"match\" : \"no match\"\n","err":""},{"code":"\"\\N{VT}\" =~ /(?[ \\s - [\\n] ])/ ? \"match\" : \"no match\"\n","err":"","out":"match"},{"err":"","code":"\"\\n\" =~ /^/ ? 'y' : 'n'\n","out":"y"},{"err":"","code":"\"\\n\" =~ /^$/ ? 'y' : 'n'\n","out":"y"},{"out":"n","err":"","code":"\"\\n\" =~ /^\\z/ ? 'y' : 'n'\n"},{"out":"ERROR: Can't call method \"generic_method\" on an undefined value at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"$obj->generic_method();\n"},{"code":"@occ = 'xxx hihi.so yyy hoho.so' =~ /\\w+\\.so/g; \\@occ\n","err":"","out":"[\"hihi.so\",\"hoho.so\"]"},{"err":"","code":"[ oct \"0.00_02\" ]\n","out":"[0]"},{"out":"509","err":"","code":"oct '0775'\n"},{"code":"oct '0a'\n","err":"","out":"0"},{"code":"oct \"0b0100100\"\n","err":"","out":"36"},{"out":"[2,2,2]","code":"[ oct(0b10),oct(0x2),hex(0b10) ]\n","err":""},{"out":"25","code":"oct(0b11111);\n","err":""},{"out":"255","code":"oct '0b' . '11111111'\n","err":""},{"out":"18446744073709551615","code":"oct '0b' . ('1' x 64)\n","err":"Binary number > 0b11111111111111111111111111111111 non-portable at (eval 1) line 11, <STDIN> line 1.\n"},{"out":"16","code":"oct \"0x10\"\n","err":""},{"err":"","code":"[ oct \"0x10\", hex \"010\" ]\n","out":"[16,16]"},{"out":"[10]","err":"","code":"[ oct \"0xa\" ]\n"},{"err":"","code":"oct \"10\"\n","out":"8"},{"out":"[512]","code":"[ oct \"10_00\" ]\n","err":""},{"code":"oct \"1_2\"\n","err":"","out":"10"},{"out":"1","code":"oct \"1.2e3\"\n","err":""},{"code":"oct(\"420)\"\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"err":"","code":"oct \"4e3\"\n","out":"4"},{"out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"$_='oh turtleneck\n"},{"code":"$_='oh turtleneck phrase jar!'; s/.{13}\\K.*//s; print;\n","err":"","out":"oh turtleneck"},{"out":"oh turtleneck","err":"","code":"$_='oh turtleneck phrase jar!'; s/(?<=.{13}).*//; print\n"},{"err":"","code":"$_='oh turtleneck phrase jar!'; s/(?<=.{13}).*//s; print\n","out":"oh turtleneck"},{"err":"","code":"$_='oh turtleneck phrase jar!'; s/(?<=.{13}).*//s; print;\n","out":"oh turtleneck"},{"code":"$_='oh turtleneck phrase jar!'; s/(?<=\\w{13}).*//s; print;\n","err":"","out":"oh turtleneck phrase jar!"},{"out":"[\"\",\"\"]","code":"$old = 'abc'; $new = substr($old, 0) = ''; [$old, $new]\n","err":""},{"err":"","code":"$old = 'abc'; $new = substr($old) = ''; [$old, $new]\n","out":"ERROR: Not enough arguments for substr at (eval 1) line 1, near \"$old) \"\n"},{"err":"","code":"\\@ONC\n","out":"[]"},{"code":"$_ = \"one=1 two=2 three=3\"; [ m/(\\w+)=(\\d+)/gc ]\n","err":"","out":"[\"one\",1,\"two\",2,\"three\",3]"},{"err":"","code":"$_ = \"one=1 two=2 three=3\"; print $1 while m/(\\w+)=(\\d+)/gc\n","out":"onetwothree"},{"out":"1","err":"","code":"$one = 'foobar'; $two = \"foobazquux\"; $count = () = $one.$two =~ /[$one$two]/g\n"},{"out":"16","code":"$one = 'foobar'; $two = \"foobazquux\"; $count = () = ($one.$two) =~ /[\\Q$one$two\\E]/g\n","err":""},{"out":"1","code":"$one = 'foobar'; $two = \"foobazquux\"; $count = () = $one.$two =~ /[\\Q$one$two\\E]/g\n","err":""},{"code":"$one = 'foobar'; $two = \"foobazquux\"; $count = () = $two =~ /[$one]/g\n","err":"","out":"5"},{"err":"","code":"$one = \"foobar\"; $two = \"foobazquux\"; $i++ while substr($one, $i, 1) eq substr($two, $i, 1); $i\n","out":"5"},{"code":"$_ = \"one\\ntwo\\nthree some text four\\nfive\\n\"; [ /(.*some text.*)/ ]\n","err":"","out":"[\"three some text four\"]"},{"out":"[\"one two\",\"two\",undef]","err":"","code":"[\"one two \" =~ /(one (two)) (three)?/]\n"},{"out":"[\"one.two\"]","err":"","code":"$_ = 'one.two.three'; [ /(.*)\\./ ]\n"},{"code":"$_ = \"one two three\"; %h = ( one => 1, two => 2 ); s/$_/$h{$_}/ for keys %h; $_\n","err":"","out":"one two three"},{"code":"$_ = \"one two three\"; %h = ( one => 1, two => 2 ); s/$_/$h{$_}/ for keys %h; $_\"\n","err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"one two\",\"two\",\"three\"]","code":"[\"one two three\" =~ /(one (two)) (three)/]\n","err":""},{"err":"","code":"$_ = 'one two two three'; $_ =~ s/^.*?two//; $_\n","out":" two three"},{"err":"","code":"'one two two three' =~ 's/^.*?two//r\n","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"out":" two three","err":"","code":"'one two two three' =~ s/^.*?two//r\n"},{"err":"","code":"\"O.O\" =~ s/\\./_/r\n","out":"O_O"},{"out":"[undef]","err":"","code":"[ ${^OPEN} ]\n"},{"code":"open(2, \"|df -h\")\n","err":"","out":""},{"out":"[]","code":"[ 'openerp-server' =~ m{/([^/]+)$} ]\n","err":""},{"code":"open $fh, \">\", \\$str; say($fh 'asdf'); [ $str ]\n","err":"","out":"[\"asdf\\n\"]"},{"code":"open $fh, \">\", \\$str; say($fh $_) for qw,foo bar baz,; [ $str ]\n","err":"","out":"[\"foo\\nbar\\nbaz\\n\"]"},{"err":"","code":"open FILE, \"<\", \"/etc/passwdoeuoe\"; print <FILE>\n","out":"1"},{"code":"open FILE, \"<\", \"/etc/passwd\"; print <FILE>\n","err":"","out":"1"},{"code":"open $f, \"<\", \"/proc/self/mountinfo\"; fileno($f)\n","err":"","out":""},{"out":"","code":"open my $fh, \\$altreus; print $fh \"I hate you\";\n","err":""},{"out":"ERROR: Too many open files at (eval 1) line 1, <STDIN> line 1.\n","code":"open my @fh, '<', '/dev/zero' or die $!; \\@fh\n","err":""},{"out":"GLOB","err":"","code":"open my $fh, '>', \\my $buffer; ref $fh\n"},{"code":"open my $fh, '>', \\my $foo or die $!; [$fh, $fh->isa(\"GLOB\"), ref $fh]\n","err":"","out":"[\\*{'::$fh'},1,\"GLOB\"]"},{"out":"[\\*{'::$fh'},1,\"GLOB\",[]]","err":"","code":"open my $fh, '>', \\my $foo or die $!; [$fh, $fh->isa(\"GLOB\"), ref $fh, \\@GLOB::ISA]\n"},{"out":"GLOB","code":"open my $fh, '>', \\my $foo or die $!; print ref $fh;\n","err":""},{"out":"[\"IO::File=IO(0x340ca70)\"]","err":"","code":"open my $fh , '>', \\my $str; [ '' . *$fh{IO} ]\n"},{"out":"[bless( , 'IO::File' )]","code":"open my $fh , '>', \\my $str; [ *$fh{IO} ]\n","err":"cannot handle ref type 15 at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/x86_64-linux/Data/Dumper.pm line 233, <STDIN> line 1.\n"},{"code":"open my $fh , '>', \\my $str; [ ref *$fh{IO} ]\n","err":"","out":"[\"IO::File\"]"},{"err":"","code":"open my $fh , q{>}, \\(my $str); say $fh q{foo}; [ ref $fh ];\n","out":"[\"GLOB\"]"},{"out":"[24,\"Too many open files\"]","code":"open my($fh), \"<\", \"some file which doesn't exist\"; [ $! + 0, \"\" . $! ]\n","err":""},{"out":"[24,\"Too many open files\"]","code":"open my($fh), \"<\", \"some file which doesn't exist\"; [ 0 + $!, \"\" . $! ]\n","err":""},{"out":"abcxyzw","code":"open my $fh, '<', \\\"xyzwtu\"; my $s = \"abc\"; read $fh, $s, 4, 3; $s\n","err":""},{"code":"open my $lol, '<', 'lol'; <$lol>\n","err":"","out":""},{"code":"open my $lol, '>', 'lol'; $lol->print(\"lol\");\n","err":"","out":""},{"err":"","code":"open( my $ofh, q{>}, q{/tmp/abc.txt} ) or die qq{write: $!}; print $ofh q{abcdefghijklmnopqrstuvwxyz}; close $ofh; open( my $ifh, q{<}, q{/tmp/abc.txt} ) or die qq{read: $!}; my $count = read $ifh, my $chunk, 10, 5; close $ifh; [ $count, $chunk ];\n","out":"ERROR: write: Too many open files at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"GLOB(0x381b030)","err":"","code":"open $out2, '>&=', 2 or warn \">$!<\"; $out2->autoflush(1); \"\".$out2\n"},{"out":"ERROR: Can't use an undefined value as filehandle reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"open undef\n"},{"out":"194","code":"ord 'Â«'\n","err":""},{"out":"194","code":"ord 'Â£'\n","err":""},{"out":"42","code":"ord '*'\n","err":""},{"code":"ord 'â'\n","err":"","out":"226"},{"out":"39","err":"","code":"ord \"'\"\n"},{"code":"ord('/')\n","err":"","out":"47"},{"out":"46","err":"","code":"ord(\".\")\n"},{"code":"[ ord \"â°\", ord \"â¹\" ]\n","err":"","out":"[226,226]"},{"out":"[194]","err":"","code":"[ord \"Â²\"]\n"},{"out":"97","code":"ord 'a'\n","err":""},{"code":"ord 'A'\n","err":"","out":"65"},{"code":"ord('a')^ord('A')\n","err":"","out":"32"},{"out":"233","code":"ord chr 0xe9\n","err":""},{"err":"","code":"(ord chr 0xe9) == 0xe9\n","out":"1"},{"out":"1","err":"","code":"ord chr 0xe9 == 0xe9\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"; or\"\n","code":"or deparse:?\n","err":""},{"err":"","code":"$#order = 2; $#order\n","out":"2"},{"out":"ERROR: Modification of non-creatable array value attempted, subscript -2 at (eval 1) line 1, <STDIN> line 1.\n","code":"@order = 2; @order and @order = grep $_, @order[-2, -1]\n","err":""},{"err":"","code":"$#order = 2; @order and @order = grep $_, @order[-2,-1]\n","out":"0"},{"out":"ERROR: Can't modify constant item in scalar assignment at (eval 1) line 1, at EOF\n","err":"","code":"$#order = 2; @order and order = grep $_, @order[-2,-1];\n"},{"out":"0","code":"@order and @order = grep $_, @order[-2, -1]\n","err":""},{"code":"... or die\n","err":"","out":"ERROR: Unimplemented at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"ord \"\\n\"\n","out":"10"},{"err":"","code":"[ord '~', ord ' ']\n","out":"[126,32]"},{"code":"[ord '.', ord '[']\n","err":"","out":"[46,91]"},{"err":"","code":"ord('/') - ord('+')\n","out":"4"},{"err":"","code":"ord pack 'A', 32\n","out":"51"},{"code":"ord pack \"B8\", \"11111110\"\n","err":"","out":"254"},{"out":"41","err":"","code":"ord(split '',a..m=>N..Z)-7\n"},{"code":"[ord 'Ã']\n","err":"","out":"[195]"},{"code":"ord unpack 'A', 32\n","err":"","out":"51"},{"out":"254","err":"","code":"ord \"\\xFE\"\n"},{"out":"208","code":"ord 'Ð¹'\n","err":""},{"code":"or evaljs:\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"; or\"\n"},{"out":"bar","err":"","code":"$_=\"otmat\"; /(?{$name=\"foo\"})re[x]ma|(?{$name=\"bar\"})o[ther]matc/; $name\n"},{"out":"ERROR: Undefined subroutine &main::notlol called at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"our $AUTOLOAD = 'cats'; sub cats { \"lol\" } notlol()\n"},{"out":"[1,2,2,\"abc\"]","code":"our $baz = 'abc'; package foo; sub bar { our $baz; return ++$baz }; package main; [ foo::bar(), foo::bar(), $foo::baz, $baz ]\n","err":""},{"code":"{ our $baz = 'abc'; package foo; sub bar { our $baz; return ++$baz }; }; package thisfails; [ foo::bar(), foo::bar(), $foo::baz, $baz ]\n","err":"","out":"[1,2,2,undef]"},{"out":"[1,2,2,\"abc\"]","err":"","code":"our $baz = 'abc'; package foo; sub bar { our $baz; return ++$baz }; package thisfails; [ foo::bar(), foo::bar(), $foo::baz, $baz ]\n"},{"out":"0","code":"our $descriptivism++;\n","err":""},{"out":"BAR\n","err":"","code":"our $DIR; BEGIN { $DIR = 'BAR' } say $DIR;\n"},{"out":"2","err":"","code":"our %foo = 1 .. 2; *foo->{1}\n"},{"out":"ERROR: Not a HASH reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"our %foo = 1, 2; (\\*foo)->{HASH}\n"},{"code":"our %foo = 1, 2; *foo{HASH}\n","err":"","out":"{1 => undef}"},{"code":"{ our $foo = 5;} eval { $foo }; { our $foo . $@ }\n","err":"","out":"5"},{"err":"","code":"our $n = 0; sub foo { local $n = $n; my @p = [ shift, $n ? 'N' : 'F' ]; ++$n; @_ ? [ @p, foo( @_ ) ] : \\@p }; { 'one' => foo('a'..'c'), 'two' => foo('x'..'z') };\n","out":"{one => [[\"a\",\"F\"],[[\"b\",\"N\"],[[\"c\",\"N\"]]]],two => [[\"x\",\"F\"],[[\"y\",\"N\"],[[\"z\",\"N\"]]]]}"},{"code":"our $n = 0; sub foo { local $n = $n; my @p = [ shift, $n, $n ? 'N' : 'F' ]; ++$n; @_ ? [ @p, foo( @_ ) ] : \\@p }; { 'one' => foo('a'..'c'), 'two' => foo('x'..'z') };\n","err":"","out":"{one => [[\"a\",0,\"F\"],[[\"b\",1,\"N\"],[[\"c\",2,\"N\"]]]],two => [[\"x\",0,\"F\"],[[\"y\",1,\"N\"],[[\"z\",2,\"N\"]]]]}"},{"out":"Wimbledon(eval 1)1","code":"our sub Bulgaria { print caller; } package Wimbledon; Bulgaria()\n","err":""},{"err":"","code":"our $varname = \"womble\"; ${$varname} = \"Bulgaria\"; print \"Uncle $womble\"\n","out":"Uncle Bulgaria"},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"our $x = \"\\\n"},{"err":"","code":"{ our $x = \"dogs\" } { our $x; print $x }\n","out":"dogs"},{"out":"1","code":"our $x=\"\\n\"; $x = chomp $x; $x\n","err":""},{"code":"our $x = 'package'; my $x = 'lexical'; { our $x; print $x }\n","err":"","out":"package"},{"err":"","code":"our $x; sub lala { \\$x } [\\$x, lala()] # also identical\n","out":"[\\undef,$VAR1->[0]]"},{"code":"our %y; our $x = 5; *{y{x}} = *x; $y = 3; [ $x, \\%y ]; ### I saw this in some code I was reviewing, which I think was someone trying to alias a hash key to a variable, similar to *x = *y, but it doesn't seem t owork (maybe for an old Perl?)\n","err":"","out":"ERROR: Can't modify glob elem in scalar assignment at (eval 1) line 1, at EOF\n"},{"err":"","code":"@output=`df -h`; for my $line (@output){ print $line if $line =~ /procfs/ }\n","out":""},{"out":"[undef]","code":"[ overload::Overloaded( 'Regexp' ) ]\n","err":""},{"err":"","code":"[ overload::Overloaded( v1.2.3 ) ]\n","out":"[undef]"},{"out":"{1 => 2}","err":"","code":"%p = (1,2); @array = values %p; s/\\d// for @array; \\%p\n"},{"out":"","code":"%p = (1,2); s/\\d// for keys %p\n","err":""},{"code":"%p = (1,2); s/\\d// for keys %p; \\%p\n","err":"","out":"{1 => 2}"},{"err":"","code":"%p = (1,2); s/\\d// for values %p; \\%p\n","out":"{1 => \"\"}"},{"code":"$P2::x = \"P2\"; package P1; our $x = \"P1\"; package P2; $x\n","err":"","out":"P1"},{"err":"","code":"$P2::x = \"P2\"; package P1; $x = \"P1\"; package P2; $x\n","out":"P2"},{"err":"","code":"pack \"a\", 0x32;\n","out":"5"},{"out":"5","err":"","code":"pack \"a\", 0x33;\n"},{"out":"214365","code":"pack '(a)*', 123456 =~ /.(.)(?<=(.).)/g\n","err":""},{"code":"pack 'a', 32\n","err":"","out":"3"},{"out":"3","err":"","code":"pack 'A', 32\n"},{"out":"4","err":"","code":"pack 'a', 48\n"},{"out":"main","err":"","code":"__PACKAGE__\n"},{"out":"[\"main\"]","err":"","code":"[ __PACKAGE__ ]\n"},{"err":"","code":"package A; sub new { bless {}, ref $_[0] || $_[0]; } sub foo { [ $_[0], q{A:111} ]; } package B; our @ISA = qw(A); package C; our @ISA = qw(A); package D; our @ISA = qw(B C); package main; my $d = D->new; [ $d->foo, $d->B::foo, $d->C::foo, $d->A::foo ];\n","out":"[[bless( {}, 'D' ),\"A:111\"],[$VAR1->[0][0],\"A:111\"],[$VAR1->[0][0],\"A:111\"],[$VAR1->[0][0],\"A:111\"]]"},{"out":"[[bless( {}, 'D' ),\"B:222\"],[$VAR1->[0][0],\"B:222\"],[$VAR1->[0][0],\"C:333\"],[$VAR1->[0][0],\"A:111\"]]","code":"package A; sub new { bless {}, ref $_[0] || $_[0]; } sub foo { [ $_[0], q{A:111} ]; } package B; our @ISA = qw(A); sub foo { [ $_[0], q{B:222} ]; } package C; our @ISA = qw(A); sub foo { [ $_[0], q{C:333} ]; } package D; our @ISA = qw(B C); package main; my $d = D->new; [ $d->foo, $d->B::foo, $d->C::foo, $d->A::foo ];\n","err":""},{"err":"","code":"package A; sub x { q{A::x}; } package B; sub x { q{B::x}; } package C; sub x { q{C::x}; } package main; [ map { $_->can( q{x} )->() } qw(A B C) ]; ### litewait\n","out":"[\"A::x\",\"B::x\",\"C::x\"]"},{"err":"","code":"package Blah { sub foo { print \"eh\" } } Blah::foo()\n","out":"eh"},{"code":"package Blah { sub foo { print \"eh\" } } foo()\n","err":"","out":"ERROR: Undefined subroutine &main::foo called at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"package Cats; our $meow; our $mewl = '>:('; package main; \\%Cats::\n","out":"{mewl => *Cats::mewl,meow => *Cats::meow}"},{"code":"package Cats; our $meow; package main; \\%Cats::\n","err":"","out":"{meow => *Cats::meow}"},{"code":"package C; sub new { bless {}, ref $_[0] || $_[0] } package main; my $foo = sub { [ @_ ] }; my $c = C->new; $c->$foo( 1..3 );\n","err":"","out":"[bless( {}, 'C' ),1,2,3]"},{"out":"sub { \"DUMMY\" }","code":"package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; \\&foo;\n","err":""},{"err":"","code":"package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; $c->(\\&foo)->( 1..3 );\n","out":"ERROR: Not a CODE reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Not a CODE reference at (eval 1) line 1, <STDIN> line 1.\n","code":"package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; $c->(\\&foo)( 1..3 );\n","err":""},{"err":"","code":"package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; $c->${\\\\&foo}( 1..3 );\n","out":"[bless( {}, 'C' ),1,2,3]"},{"code":"package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; $c->\\&foo( 1..3 );\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"->\\\"\n"},{"code":"package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; my $name = \"foo\"; $c->$name( 1..3 );\n","err":"","out":"ERROR: Can't locate object method \"foo\" via package \"C\" at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; my $ref = \\&foo; $c->$ref( 1..3 );\n","err":"","out":"[bless( {}, 'C' ),1,2,3]"},{"out":"","code":"{ package damnit; sub a { \"\" } } tr/// for a damnit\n","err":""},{"out":"ERROR: Invalid version format (0 before decimal required) at (eval 1) line 1, near \"; package dedicated::dedicated\"\nsyntax error at (eval 1) line 1, near \"package dedicated::dedicated.\"\n","code":"package dedicated::dedicated.fr {}\n","err":""},{"out":"cats","code":"package Don; sub t { 'cats' } package main; Don't;\n","err":""},{"err":"","code":"package DudeUseMoo { sub moot { bless {} } } $m = DudeUseMoo->moot; $m->{asdf} = 'blah'; $m->{asdf}\n","out":"blah"},{"err":"","code":"package DudeUseMoo { sub moot { bless {} } sub whurble { my $self=shift; $self->{asdf} } } $m = DudeUseMoo->moot; $m->{asdf} = 'blah'; $m->whurble\n","out":"blah"},{"out":"[15,15]","err":"","code":"{ package FF; sub TIESCALAR { my ($c, $v) = @_; bless \\$v, $c } sub FETCH { my $v = ${$_[0]}; ${$_[0]} = -${$_[0]}; $v } } sub frob :lvalue { my ($v) = @_; tie $v, \"FF\", $v; $v } sub List::Util::0sum {my ($a, $b)=(0,0); $a+=$_, $b-=$_ for @_; ($a, $b)}; [List::Util::0sum(map frob($_), 1,2,3,4,5)]\n"},{"out":"1","code":"package foo; $bar = 1; package quux; print $main::foo::bar;\n","err":""},{"out":"The method called was: foo::gooblegobble","err":"","code":"package foo; our $AUTOLOAD; sub AUTOLOAD {print \"The method called was: $AUTOLOAD\"}; package main; foo->gooblegobble();\n"},{"out":"[\"blah baz\"]","err":"","code":"package foo { our $bar = 'baz' } [\"blah $foo::bar\"]\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"}::\n\"\n","err":"","code":"package Foo; our $foo = 42; package main; my $z = 'Foo';  \\%{$x}::\n"},{"code":"package Foo: our $var;  package Splot; $var = 3; print $Foo::var;\n","err":"","out":"ERROR: Invalid version format (non-numeric data) at (eval 1) line 1, near \"; package Foo\"\nsyntax error at (eval 1) line 1, near \"package Foo:\"\nNo package name allowed for variable $Foo::var in \"our\" at (eval 1) line 1, near \"print $Foo::var\"\n"},{"code":"{ package Foo; our $x = \"foo\"; package Bar; $x = \"bar\"; } [ $Foo::x, $Bar::x ]\n","err":"","out":"[\"bar\",undef]"},{"err":"","code":"package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );  $x->can($foo{bar})->()\n","out":"42"},{"err":"","code":"package foo; sub bar { 'ok' }; package main; use base 'foo'; [ main->SUPER::bar ];\n","out":"ERROR: Can't locate foo.pm:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/base.pm line 100, <STDIN> line 1.\n\t...propagated at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/base.pm line 109, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate foo.pm:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/base.pm line 100, <STDIN> line 1.\n\t...propagated at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/base.pm line 109, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"package foo; sub bar { 'ok' }; package main; use base 'foo'; package other; [ main->SUPER::bar ];\n","err":""},{"out":"[\"[1]\",\"[2]\",2]","err":"","code":"package foo; sub bar { our $baz; \"[\". ++$baz . \"]\" }; [ bar(), bar(), $baz ]\n"},{"out":"[\"[1]\",\"[2]\",2]","err":"","code":"package foo; sub bar { our $baz; \"[\". ++$baz . \"]\" }; [ bar(), bar(), $foo::baz ]\n"},{"out":"[\"[1]\",\"[2]\",2]","err":"","code":"package foo; sub bar { our $baz; package fizzbuz; \"[\". ++$baz . \"]\" }; [ bar(), bar(), $baz ]\n"},{"out":"12","err":"","code":"package foo; sub bar { our $baz; print ++$baz }; [ bar(), bar(), $foo::baz ]\n"},{"err":"","code":"package foo; sub bar { our $baz; print ++$baz }; print bar(); print bar(); print $foo::baz;\n","out":"11212"},{"out":"[1,2,2]","err":"","code":"package foo; sub bar { our $baz; return ++$baz }; [ bar(), bar(), $foo::baz ]\n"},{"code":"{ package Foo; sub DESTROY {} } sub bar; bar Foo;\n","err":"","out":"ERROR: Can't locate object method \"bar\" via package \"Foo\" at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate object method \"bar\" via package \"Foo\" at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"{ package Foo; sub DESTROY {} } sub bar; bar Foo 1;\n"},{"out":"lala","code":"package Foo; sub d { return \"lala\" } package main; my $c = bless {}, 'Foo'; $c->d()\n","err":""},{"err":"","code":"package foo; sub new {[1]} package bar; foo->new\n","out":"[1]"},{"out":"[[1,2,3],[\"Foo\",1,2,3],[bless( {}, 'Foo' ),1,2,3]]","err":"","code":"package Foo { sub new { bless {}, shift } sub bar { [@_] } } [Foo::bar(1,2,3), Foo->bar(1,2,3), Foo->new->bar(1,2,3)]\n"},{"out":"value","err":"","code":"package Foo { sub new { my $self = shift; bless {@_}, $self } } my $foo = Foo->new(key => 'value'); $foo->{key};\n"},{"out":"value","code":"package Foo { sub new { my $self = shift; bless {@_}, $self } sub get_key { my $self = shift; return $self->{+shift} } } my $foo = Foo->new(key => 'value'); $foo->get_key('key'); # with an accessor method\n","err":""},{"out":"[\"A\",\"B\",\"C\"]","code":"package Foo; sub x { \\@ARGV; } package main; @ARGV = qw( A B C ); Foo::x;\n","err":""},{"code":"package Foo; sub x { \\@main::ARGV; } package main; @ARGV = qw( A B C ); Foo::x;\n","err":"","out":"[\"A\",\"B\",\"C\"]"},{"out":"f","err":"","code":"package Foo; use overload 'bool' => sub { 0 }; sub new { bless {}, shift }; package main; Foo->new() ? 't' : 'f'\n"},{"out":"ERROR: Can't locate object method \"42\" via package \"foo\" (perhaps you forgot to load \"foo\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"package Foo; use overload q{\"\"} => sub {42 }; package main; my $x = bless {}, 'Foo'; 'foo'->$x\n","err":""},{"code":"package Foo; use overload q{\"\"} => sub {42 }; package main; my $x = bless sub{ 45 }, 'Foo'; [ 'foo'->$x // 'z', \"$x\" //'z' ]\n","err":"","out":"[45,42]"},{"out":"0","code":"package Foo; use warnings; sub foo { undef()+0 }; package main; ${Foo::^WARNING_BITS}=0; Foo::foo();\n","err":"Use of uninitialized value in addition (+) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"package Foo; use warnings; sub foo { undef()+0 }; package main; $Foo::{^WARNING_BITS}=0; Foo::foo();\n","out":"ERROR: syntax error at (eval 1) line 1, near \"{^\"\n"},{"out":"0","code":"package Foo; use warnings; sub foo { undef()+0 }; package main; no warnings; Foo::foo();\n","err":"Use of uninitialized value in addition (+) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"0","code":"package Foo; use warnings; sub foo { undef()+0 }; package main; { package Foo; no warnings; Foo::foo(); use warnings; }\n","err":"Use of uninitialized value in addition (+) at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"package Foo; use warnings; sub foo { undef()+0 }; package main; $SIG{__WARN__}=sub{}; Foo::foo();\n","err":"","out":"0"},{"out":"[\"foo\",\"bar\"]","code":"{ package Foo; $x = \"foo\"; package Bar; $x = \"bar\"; } [ $Foo::x, $Bar::x ]\n","err":""},{"code":"[ __PACKAGE__, __FUNCTION__ ]\n","err":"","out":"[\"main\",\"__FUNCTION__\"]"},{"code":"package ImARegex; sub match { $_[1] =~ $_[0] ? 1 : 0 } package main; my $re = qr/hai/; bless $re, 'ImARegex'; $re->match('chair')\n","err":"","out":"1"},{"code":"package ImARegex; sub match { $_[1] =~ $_[0] ? 1 : 0 } package main; my $re = qr/hai/; bless $re, 'ImARegex'; $re->match('char')\n","err":"","out":"0"},{"out":"123","err":"","code":"package lala; my $x = 123; package lulu; $x\n"},{"code":"package mac { sub ska { 'ca' } } \"ce${\\mac->ska}\"\n","err":"","out":"ceca"},{"out":"ERROR: Can't locate object method \"method\" via package \"Package\" at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"Package->method\n"},{"err":"","code":"package My; my My $my :Delilah;\n","out":"ERROR: Invalid SCALAR attribute: Delilah at (eval 1) line 1.\n"},{"code":"package mypackage.pm; # although I'd guess perl should already be complaining about it\n","err":"","out":"ERROR: Invalid version format (0 before decimal required) at (eval 1) line 1, near \"; package mypackage\"\nsyntax error at (eval 1) line 1, near \"package mypackage.\"\n"},{"code":"{ package MyProject::whatever; sub doSomething { print 'test' } } my $class = 'whatever'; *{\"MyProject::${class}::doSomething\"}{CODE}() # but really don't do this\n","err":"","out":"test"},{"err":"","code":"package My::Thing { sub validate_rules { { cat => qr/meow/, cow => qr/moo/ } } } my $klass = \"My::Thing\"; $klass->validate_rules\n","out":"{cow => qr/moo/u,cat => qr/meow/u}"},{"out":"plup plop","err":"","code":"{ package Plip; use overload '\"\"' => sub { 'plop' } } $x = bless [], 'Plip'; \"plup $x\"\n"},{"out":"bless( {bar => 456,foo => 123}, 'P' )","code":"package P; sub new { my $class = @_ && ( $_[0]->isa( __PACKAGE__ ) || $_[0] eq __PACKAGE__ ) ? shift : __PACKAGE__; bless +{ @_ }, ( ref $class or $class ); } package main; P->new( foo => 123, bar => 456 );\n","err":""},{"err":"","code":"package P; sub new { my $class = @_ && ( $_[0]->isa( __PACKAGE__ ) || $_[0] eq __PACKAGE__ ) ? shift : __PACKAGE__; bless +{ @_ }, ( ref $class or $class ); } package main; P::new( foo => 123, bar => 456 );\n","out":"bless( {bar => 456,foo => 123}, 'P' )"},{"out":"bless( {123 => \"bar\",456 => undef}, 'P' )","code":"package P; sub new { my $class = @_ && ( $_[0]->isa( __PACKAGE__ ) || $_[0] eq __PACKAGE__ ) ? shift : __PACKAGE__; bless +{ @_ }, ( ref $class or $class ); } package main; P::new( P => 123, bar => 456 );\n","err":""},{"out":"ERROR: Operation \"+\": no method found,\n\tleft argument in overloaded package P,\n\tright argument in overloaded package P at (eval 1) line 1, <STDIN> line 1.\n","code":"package P { use overload '\"\"' => sub { \"07\" }, '0+' => sub { \"01\" } } (bless {}, \"P\") + (bless {}, \"P\")\n","err":""},{"err":"","code":"package P { use overload '\"\"' => sub { \"07\" }, '0+' => sub { \"01\" } } oct(bless {}, 'P')\n","out":"7"},{"out":"7","code":"package P { use overload '\"\"' => sub { \"07\" } } oct(bless {}, 'P')\n","err":""},{"out":"[\"qqq\"]","err":"","code":"package q; sub qq {\"qqq\"};package main; *main::notq = \\&q::qq; [notq()]\n"},{"err":"","code":"{ package Regexp; use overload '\"\"' => sub { 'overload' }, fallback => 1 } my $x = bless qr/loves/, 'Regexp'; [ \"$x\", re::regexp_pattern($x) ] # then there are those who just like to watch the world burn\n","out":"[\"overload\",\"loves\",\"u\"]"},{"out":"in class method","code":"package Some::Class; sub class_method { my $class = shift; print \"in class method\" }  package main; Some::Class->class_method;\n","err":""},{"err":"","code":"package ã; sub foo {3} package main; ã::foo()\n","out":"ERROR: Unrecognized character \\xE3; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[bless( {}, 'TerribleThing' )]","err":"","code":"package TerribleThing { sub new { bless {}, shift } sub DESTROY { undef $@ } } eval { die TerribleThing->new }; [$@]\n"},{"code":"package TerribleThing { sub new { bless {}, shift } sub DESTROY { undef $@ } } eval { my $foo = TerribleThing->new; die 1 }; [$@]\n","err":"","out":"[\"1 at (eval 1) line 1, <STDIN> line 1.\\n\"]"},{"err":"","code":"package test; sub new { my $class = shift; my $props = { property => shift }; bless $props, $class; return $props; } 1; my $tester = new test(\"thisproperty\"); my $longstring = << 'EOF'; long long string\\n\\n$test->property\\n\\nEOF; print $tester;\n","out":"ERROR: Can't find string terminator \"EOF\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"TRUE","code":"package tm406; sub is_gandalf { 1 }; return \"TRUE\" if(tm406->is_gandalf());\n","err":""},{"out":"ERROR: Too few arguments for method stuff (expected 2, got 1) at (eval 1) line 1.\n","err":"","code":"{ package Try; use Function::Parameters qw(:strict); method stuff($class: $x) { $x + 1 } } Try->stuff\n"},{"out":"<>\nmain\nok","err":"","code":"{ package X; sub DESTROY { print \"<>\\n\"; } } my $sub = sub { my $x = bless [], \"X\"; sub { \"ok\" } }->(); print \"main\\n\"; print $sub->()\n"},{"err":"","code":"{ package X; sub TIEHASH { bless [], $_[0] } sub AUTOLOAD { my $r = shift; push @$r, [our $AUTOLOAD, @_] } } tie my %x, 'X'; %x = \"A\" .. \"D\"; tied %x\n","out":"bless( [[\"X::CLEAR\"],[\"X::STORE\",\"A\",\"B\"],[\"X::STORE\",\"C\",\"D\"]], 'X' )"},{"out":"bless( [\"X::CLEAR\",\"X::STORE\",\"X::STORE\"], 'X' )","err":"","code":"{ package X; sub TIEHASH { bless [], $_[0] } sub AUTOLOAD { push @{$_[0]}, our $AUTOLOAD } } tie my %x, 'X'; %x = \"A\" .. \"D\"; tied %x\n"},{"out":"ERROR: Can't locate object method \"STORE\" via package \"X\" at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"{ package X; sub TIEHASH { bless [], $_[0] } sub CLEAR {} } tie my %x, 'X'; %x = (1, 2);\n"},{"err":"","code":"{ package X; sub TIEHASH { bless [], $_[0] } } tie my %x, 'X'; %x = ();\n","out":"ERROR: Can't locate object method \"CLEAR\" via package \"X\" at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"{ package X; sub TIEHASH { bless [], $_[0] } } tie my %x, 'X'; %x = (1, 2);\n","err":"","out":"ERROR: Can't locate object method \"CLEAR\" via package \"X\" at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"{ package X; sub TIESCALAR { bless [] } sub FETCH { state $x = 5; $x++ } } tie my $foo, X::; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say \"surprise!\" }\n","out":"surprise!\n"},{"err":"","code":"{ package X; } tie my %x, 'X'; %x = ();\n","out":"ERROR: Can't locate object method \"TIEHASH\" via package \"X\" at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"surprise!\n","err":"","code":"{ package X; use overload fallback => 1, '0+' => sub { state $x = 5; $x++ }; } my $foo = bless [], X::; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say \"surprise!\" }\n"},{"out":"string","code":"package X; use overload '\"\"' => sub { print \"string\"; \"x\" }, '.' => sub { print \"concat\"; \"x\" }; sprintf '%s', (bless {}, 'X');\n","err":""},{"out":"X","code":"package X; use overload '+' => sub { print \"X\"; }; package Y; use overload '+' => sub { print \"Y\" }; [ (bless {}, 'X') + (bless {}, 'Y') ]\n","err":""},{"out":"Y","code":"package X; use overload '+' => sub { print \"X\"; }; package Y; use overload '+' => sub { print \"Y\" }; [ (bless {}, 'Y') + (bless {}, 'X') ]\n","err":""},{"code":"package XYZ; my @FIELDS = qw(one two); for my $field (@FIELDS) { *$field = sub { shift->{$field} }; } my $obj = bless {one => 1, two => 2, five => 5}, 'XYZ'; $FIELDS[1] = 'five'; [ map $obj->$_, qw(one two) ]\n","err":"","out":"[1,5]"},{"out":"[\"called with x y\",\"called with XYZ x y\"]","err":"","code":"package XYZ; sub somesub { \"called with @_\" } [ XYZ::somesub('x', 'y'), XYZ->somesub('x', 'y') ] # they don't have to be class methods, you can use the package namespace without importing it into the current scope\n"},{"code":"pack '(a)*', map +(/.(.)/g,/(.)./g), \"123456\"\n","err":"","out":"246135"},{"err":"","code":"pack '(a)*', sort {$|--} \"tuJsa nohterP er lhakcer,\" =~ /./g\n","out":"Just another Perl hacker,"},{"err":"","code":"pack 'B*', ~0\n","out":"ÃÂwÃÂ°"},{"out":"This","err":"","code":"pack \"b*\", \"00101010000101101001011011001110\"\n"},{"out":"Tith4cokei\n","code":"pack 'B*', '0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010'\n","err":""},{"code":"pack \"b*\", 0b010101010;\n","err":"","out":"\u0003"},{"err":"","code":"pack \"(b8)*\", \"00101010\",\"00010110\",10010110,11001110\n","out":"This"},{"err":"","code":"pack \"(b8)*\", \"00101010\",\"00010110\",10010110,11001110'\n","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"\u0003\u0002is","code":"pack \"(b8)*\", 00101010,00010110,10010110,11001110\n","err":""},{"out":"*","code":"pack('b8','01010100')\n","err":""},{"out":"T","err":"","code":"pack('B8','01010100')\n"},{"out":"*ÃÂ.\u0016,ÃÂÃÂ¶ÃÂÃÂ¦ÃÂP","err":"","code":"pack('(b8)*',\"0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010\" =~ /.{8}/g);\n"},{"err":"","code":"pack \"B8\", \"11111110\"\n","out":"ÃÂ¾"},{"err":"","code":"pack \"(b8)*\", split ' ', \"00101010 00010110 10010110 11001110\"\n","out":"This"},{"out":"\u0000T\u0000h\u0000i\u0000s","code":"pack \"(b8)*\", split/(.{8})/, \"00101010000101101001011011001110\"\n","err":""},{"out":"*\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000","err":"","code":"pack('b8'x11,\"0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010\");\n"},{"err":"","code":"[ pack \"B*\", pack \"C*\", (1) x 7, 0 ]\n","out":"[\"\\376\"]"},{"out":"","code":"pack \"c\", 127;\n","err":""},{"out":"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000ÃÂ¿ÃÂ¿ÃÂÃÂ¨\u0000\u0001","code":"pack \"C16\", (0)x10, (0xff)x2, split /[.]/, \"192.168.0.1\"\n","err":""},{"out":"[0]","err":"","code":"[ pack 'c', 48 ]\n"},{"out":"c","code":"pack \"c\", 99;\n","err":""},{"out":"\u000f","code":"pack \"c\", 9999;\n","err":""},{"err":"","code":"pack \"cc\", 9888, 9999;\n","out":"ÃÂ \u000f"},{"out":"bc","err":"","code":"pack \"cc\", 98, 99;\n"},{"out":"ERROR: '%' may not be used in pack at (eval 1) line 1, <STDIN> line 1.\n","code":"[ pack '%c', map { $_ & 1 } unpack '%c', 'asdf1111' ]\n","err":""},{"err":"","code":"pack \"c*\", map { hex } \"30313133\" =~ /([[:xdigit:]]{2})/g\n","out":"0113"},{"out":"ÃÂPNG\r\n\u001a\n","err":"","code":"pack \"C*\", qw|137 80 78 71 13 10 26 10|\n"},{"err":"","code":"[ pack \"C*\", qw|137 80 78 71 13 10 26 10| ] # throw Data::Dumper at it\n","out":"[\"\\211PNG\\r\\n\\32\\n\"]"},{"out":"ERROR: Can't locate object method \"packege\" via package \"Whatever\" (perhaps you forgot to load \"Whatever\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"packege Whatever; # looks like an error to me, man\n","err":""},{"err":"","code":"pack \"f*\", 1,2,3;\n","out":"\u0000\u0000ÃÂ?\u0000\u0000\u0000@\u0000\u0000@@"},{"out":"[\"\\377\\377\\377\\377\\377\\377#\\300\"]","err":"","code":"[ pack 'F', (9/10-1)*100 ]\n"},{"out":"\u0000\u0000\u001c\u0000","err":"","code":"pack 'H*', '00001c00';\n"},{"code":"pack(\"H*\", 0x80 + 1)\n","err":"","out":"\u0012ÃÂ"},{"code":"pack '(H2)*', split /\\./, sprintf '%vx', 'one way to do it'\n","err":"","out":"one way to do it"},{"err":"","code":"pack \"h\", \"41\"\n","out":"\u0004"},{"err":"","code":"pack 'H*', '41'\n","out":"A"},{"out":"A","code":"pack(\"H*\", 41)\n","err":""},{"out":"[\"A B C\",\"A B C\"]","code":"[ pack(\"H*\", 4120422043), pack(\"h*\", 1402240234) ]\n","err":""},{"out":"[\"A B C\",\"4120422043\"]","code":"[ pack(\"H*\", 4120422043), unpack(\"H*\", \"A B C\") ]\n","err":""},{"code":"pack \"H*\", \"42424242\"\n","err":"","out":"BBBB"},{"code":"[ pack \"H*\", \"49440953\" ]\n","err":"","out":"[\"ID\\tS\"]"},{"out":"667ÃÂµ'6","err":"","code":"pack 'h*', '6363735f7263'\n"},{"out":"ccs_rc","code":"pack 'H*', '6363735f7263'\n","err":""},{"code":"pack 'H*', \"6578616d706c65206865782064617461\"\n","err":"","out":"example hex data"},{"code":"[ pack \"H*\", \"6d73616e64626f78\" ]\n","err":"","out":"[\"msandbox\"]"},{"code":"pack \"H*\", '7061756c'\n","err":"","out":"paul"},{"out":"this is a test","err":"","code":"pack \"H*\", \"7468697320697320612074657374\"\n"},{"out":"admin","code":"~pack \"H*\", '9e9b929691'\n","err":""},{"out":"ÃÂÃÂÃÂÃÂÃÂ","code":"pack \"H*\", '9e9b929691'\n","err":""},{"err":"","code":"pack \"H*\", ${\\chr 24}\n","out":"ÃÂ"},{"out":"AA","err":"","code":"pack 'H*', '\\x41\\x41' =~ tr/\\\\x//dr\n"},{"err":"","code":"[ pack 'N', 42 ]\n","out":"[\"\\0\\0\\0*\"]"},{"out":"214365","code":"pack 'n*', unpack 'v*', \"123456\"\n","err":""},{"out":"\\xff\\xff","code":"pack 'q', 7378717377743452252\n","err":""},{"code":"pack \"s>\", 25\n","err":"","out":"\u0000\u0019"},{"err":"Out of memory!\npanic: fold_constants JMPENV_PUSH returned 2, <STDIN> line 1.\n","code":"pack('V' . 0xfffffff)\n","out":""},{"out":"","err":"Out of memory!\npanic: fold_constants JMPENV_PUSH returned 2, <STDIN> line 1.\n","code":"pack('V' . 0xfffffff);\n"},{"out":"","err":"Out of memory!\n","code":"pack('V31337000');\n"},{"code":"[pack 'V', 85]\n","err":"","out":"[\"U\\0\\0\\0\"]"},{"out":"","err":"Out of memory!\npanic: fold_constants JMPENV_PUSH returned 2, <STDIN> line 1.\n","code":"pack('V' . 99999990);\n"},{"code":"[pack \"(Z*)*\", qw(foo bar baz)]\n","err":"","out":"[\"foo\\0bar\\0baz\\0\"]"},{"err":"","code":"$page_content=\"http://www.liveleak.com/view?i=abcd\"; if ( $page_content =~ /http\\:\\/\\/www\\.liveleak\\.com\\/view\\?i\\=(\\w+)/ ){ $ids = $1 }; print $ids;\n","out":"abcd"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"$page_content='http://www.liveleak.com/view?i=abcd'; if ( $page_content =~ m!http://www\\.liveleak\\.com/view\\?i=(\\w{14})!g; ){ $ids = $1 }; print $ids;\n","err":""},{"err":"","code":"$page_content='http://www.liveleak.com/view?i=abcd'; my @ids = $page_content =~ m!http://www\\.liveleak\\.com/view\\?i=(\\w{14})!g; print @ids;\n","out":"1"},{"out":"abcd","code":"$page_content=\"http://www.liveleak.com/view?i=abcd\"; $page_content =~ s/http\\:\\/\\/www\\.liveleak\\.com\\/view\\?i\\=(\\w+)/$1/g; print $page_content;\n","err":""},{"out":"c77_1406577312","code":"$page_content=\"http://www.liveleak.com/view?i=c77_1406577312\"; $page_content =~ s/http\\:\\/\\/www\\.liveleak\\.com\\/view\\?i\\=(\\w+)/$1/g; print $page_content;\n","err":""},{"out":"qwerty","err":"","code":"$page_content=\"http://www.liveleak.com/view?i=qwerty\"; if ( $page_content =~ /http\\:\\/\\/www\\.liveleak\\.com\\/view\\?i\\=(\\w+)/ ){ push (@ids,$1); }; print @ids;\n"},{"out":"match","code":"\"/page/save/2202440;294ac50e,315fb991\" =~ m{page/} ? 'match' : 'nope'\n","err":""},{"out":"match","err":"","code":"\"/page/show/2202440\" =~ m{page/} ? 'match' : 'nope'\n"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","err":"","code":"\"/page/show/2202440\" =~ {page/} ? 'match' : 'nope'\n"},{"out":"[\"parachute\"]","code":"[ \"parachute! ahh I'm falling!\" =~ s/(?<=chute).*//r ]\n","err":""},{"out":"[\"parachute\"]","err":"","code":"[ \"parachute!\" =~ s/(?<=chute).*//r ]\n"},{"err":"","code":"[ \"parachute\" =~ s/(?<=chute).*//r ]\n","out":"[\"parachute\"]"},{"code":"parse backwards\n","err":"","out":"ERROR: Can't locate object method \"parse\" via package \"backwards\" (perhaps you forgot to load \"backwards\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"\" part isn't necessary in your actual code; it's just for interacting with the IRC bot\n","err":""},{"out":"[1]","err":"","code":"$pattern = \"oo\"; return [ \"foo\" =~ /$pattern/, \"bar\" =~ /$pattern/ ];\n"},{"out":"[1,1]","err":"","code":"$pattern = \"oo\"; return [ \"foo\" =~ /$re/, \"bar\" =~ /$re/ ]; # voila!\n"},{"code":"#!perl\n","err":"","out":""},{"code":"\"Perl\"^2\n","err":"","out":"2"},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"perl -e \"my @res = map { substr($_, 0, length($_)-1) if (-f substr($_, 0, length($_)-1) } qw(dupes.txt allfiles.bak.txt hahaha.setnhue); print join(' ', @res) . \"\\n\";\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"perlev ' [ unpack q{N}, pack q{H8}, q{6060FF} ] '\"\n","code":"perlev ' [ unpack q{N}, pack q{H8}, q{6060FF} ] ' # alanjf\n","err":""},{"err":"","code":"[ PerlIO::get_layers(*STDIN) ]\n","out":"[\"unix\",\"perlio\"]"},{"out":"ERROR: Can't find string terminator \"\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"perl -p -e \"s/\\/\\/a\\[contains\\(text\\(\\),'(\\w+)'\\)\\]/$1/g\" <<< //a[contains(text(),'Korel&nbsp;&nbsp;GÃ¶ymen')]\n","err":""},{"err":"","code":"`perl -v`\n","out":""},{"err":"","code":"perl -v\n","out":"0"},{"out":"PermitRootLogin no way man","code":"\"#########PermitRootLogin no way man\" =~ s/#*(PermitRootLogin\\sno)/$1/r\n","err":""},{"code":"'phd defense' gt 'php defense'\n","err":"","out":""},{"out":"1","code":"@phone =~ /^0$/\n","err":""},{"out":"1","code":"@phone = 0; @phone =~ /^1$/\n","err":""},{"err":"","code":"@phone = 1; @phone =~ /^1$/\n","out":"1"},{"out":"","err":"","code":"\"pobox\" eq \"pÐ¾box\"\n"},{"err":"","code":"pop @{politics}\n","out":""},{"err":"","code":"POSIX::fmod(-10, exp 1)\n","out":"-1.84515451462286"},{"out":"[2,6]","err":"","code":"@pos = (); push @pos, @- while 'hangman' =~ /n/g; \\@pos\n"},{"code":"@pos = (); $word = 'hangman'; $guess = 'n'; push @pos, @- while $word =~ /$guess/g; \\@pos  # vaskozl\n","err":"","out":"[2,6]"},{"out":"ERROR: exists argument is not a HASH or ARRAY element or a subroutine at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"$predicate = 1; $true = {foo => 2}; $false = {}; [exists($predicate ? $true->{foo} : $false->{foo}) ? \"Y\" : \"N\"]\n"},{"out":"ERROR: Search pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n","code":"$price = '16.60'; ($dollar,$cents)=$price=~/(\\d+)\\.(\\d+); $dollar++ if $cents > 0; print $dollar\n","err":""},{"code":"$price = '16.60'; ($dollar,$cents)=$price=~/(\\d+)\\.(\\d+)/; $dollar++ if $cents > 0; print $dollar\n","err":"","out":"17"},{"out":"1","err":"","code":"print\n"},{"out":"sub { \"DUMMY\" }","err":"","code":"\\&print\n"},{"code":"print ''\n","err":"","out":"1"},{"out":"\\","err":"","code":"print '\\\\'\n"},{"err":"","code":"print \"`*`\";\n","out":"`*`"},{"code":"print \"-\"\n","err":"","out":"-"},{"err":"","code":"print \"\"\n","out":"1"},{"err":"","code":"print \"[@_]\";\n","out":"[print \"[@_]\";]"},{"err":"","code":"print \"$,\"\n","out":"1"},{"out":"\u001c","err":"","code":"print \"$;\"\n"},{"out":"ÃÂ¢ÃÂÃÂ","err":"","code":"print \"â\"\n"},{"err":"","code":"print @_;\n","out":"print @_;"},{"err":"","code":"print $/\n","out":"\n"},{"code":"print $@\n","err":"","out":"1"},{"out":"1","err":"","code":"print;\n"},{"out":"01","code":"print \"0\"\n","err":""},{"code":"print \"01\"\n","err":"","out":"01"},{"out":"-1.11022302462516e-16","code":"print(0.3 + 0.3 + 0.3 - 0.9);\n","err":""},{"code":"print \"0\"; '' # and it's gone\n","err":"","out":"0"},{"out":"09","err":"","code":"print '0' x 1 . '9'\n"},{"out":"1","code":"print 1\n","err":""},{"code":"print 1;\n","err":"","out":"1"},{"out":"2","code":"print 1 + 1;\n","err":""},{"err":"","code":"print(1+2)/2\n","out":"3"},{"err":"","code":"print 123\n","out":"123"},{"out":"1","code":"print (.1 + .2 == .3)\n","err":""},{"code":"print \" 1234567 \" =~ /[0-9]{7} /;\n","err":"","out":"1"},{"out":"1","code":"print \" 12345678 \" =~ / [0-9]{7} /;\n","err":""},{"err":"","code":"print \" 12345678 \" =~ /[0-9]{7} /;\n","out":"1"},{"out":"51.6666666666667","code":"print 155.0 / 3.0\n","err":""},{"code":"print (1/999)*999\n","err":"","out":"0.001001001001001"},{"code":"[print 2]\n","err":"","out":"2"},{"out":"2","code":"print \"2\"\n","err":""},{"out":"221","err":"","code":"print \"2\" && print @+\n"},{"err":"","code":"print \"2\" && print $!\n","out":"Too many open files1"},{"out":"01","code":"print \"2\" && print $?\n","err":""},{"err":"","code":"print (3+undef)/2\n","out":"3"},{"out":"print4","err":"","code":"print4\n"},{"out":"12","code":"print (7 + 5) * 13, \"\\n\";\n","err":""},{"out":"ERROR: Undefined subroutine &main::print called at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"(\\&print)->('a')\n"},{"out":"\u0007","err":"","code":"print \"\\a\"\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"}->\"\n","code":"print {@a}->{a}\n","err":""},{"out":"1","code":"print +{@a}->{a}\n","err":""},{"out":"a!bc","code":"$, = '!'; print 'a', 'b'.'c';\n","err":""},{"out":"ab!c","code":"$, = '!'; print 'a'.'b','c';\n","err":""},{"code":"$, = '!'; print 'a'.('b','c');\n","err":"","out":"ac"},{"out":"abc","code":"print 'a', 'b'.'c';\n","err":""},{"err":"","code":"print \"abc$^Hdef\"\n","out":"abc256def"},{"out":"aERROR: an error at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"print \"a\"; die \"an error\"\n"},{"err":"Out of memory!\npanic: fold_constants JMPENV_PUSH returned 2, <STDIN> line 1.\n","code":"print 'alive'; eval q![ 'a' x 1e12 ]!\n","out":""},{"out":"[[ \"pos\" ], /\"(/d+)\"/]\nERROR: Unmatched ( in regex; marked by <-- HERE in m/\"( <-- HERE / at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"print $a=\"[[ \\\"pos\\\" ], /\\\"(/d+)\\\"/]\", \"\\n\"; my $result = eval($a) or die $@;\n"},{"code":"print $a=\"[[ \\\"pos\\\" ], /\\\"(/d+)\\\"/]\", \"\\n\"; print ref(eval($a)),\"\\n\";\n","err":"","out":"[[ \"pos\" ], /\"(/d+)\"/]\n\n"},{"out":"1","err":"","code":"print \"a\" x \"b\";\n"},{"code":"print \"bottle\\n\" x 2;\n","err":"","out":"bottle\nbottle\n"},{"err":"","code":"print \"bottle\" x 2;\n","out":"bottlebottle"},{"code":"print (caller(0))[8]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \")[\"\n"},{"err":"","code":"print 'cats'\n","out":"cats"},{"out":"cats","err":"","code":"print \"cats\"\n"},{"code":"print \"${chr(24)}\"\n","err":"","out":"/home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/bin/perl5.24.0"},{"out":"ÃÂ¢ÃÂÃÂ±","err":"","code":"print chr 8305\n"},{"out":"\n","code":"print chr length q q continue q\n","err":""},{"err":"","code":"print chr ord for qw q hasdfsadfsadf aasdfdsafasdf chasdfadsfadsf kasdfadfasdf easdfsfdsdf refwefsadfsadfa q\n","out":"hacker"},{"out":"Considered harmful by some, for this reason.","err":"","code":"{ print 'Considered'; last; print \"fun\"; } print ' harmful by some, for this reason.'\n"},{"out":"1","err":"","code":"print crypt('Gil*321T','$');\n"},{"err":"","code":"print cwd();\n","out":"ERROR: Undefined subroutine &main::cwd called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"Debug\n","code":"print(\"Debug\\n\"), return 1 if (1);\n","err":""},{"out":"2","code":"print do { if (0) { 1 } else { 2 } }\n","err":""},{"out":"1","err":"","code":"print do { if (1) { 1 } else { 2 } }\n"},{"out":"$VAR1 = 'print Dumper @_';\n","code":"print Dumper @_\n","err":""},{"out":"1","err":"","code":"print `echo 1`\n"},{"err":"","code":"print \"Enter number 1: \", $a1 = <STDIN>;\n","out":"Enter number 1: "},{"out":"2","code":"print eval +{print \"2\"}\n","err":""},{"out":"01","err":"","code":"print exec(\"dir\")\n"},{"out":"01","code":"print exec(\"ls\")\n","err":""},{"code":"printf \"%04o\\n\",0777;\n","err":"","out":"0777\n"},{"code":"printf \"%04o\\n\",07777;\n","err":"","out":"7777\n"},{"out":"ERROR: Can't call method \"mode\" on an undefined value at (eval 1) line 1, <STDIN> line 1.\n","code":"printf \"%04o\\n\",$mode->mode & 07777;\n","err":""},{"out":"11111111\n01111111\n01111111\n","err":"","code":"printf \"%08b\\n%08b\\n%08b\\n\", 0xff, 0x7f, 0xff & 0x7f\n"},{"err":"","code":"printf \" %08b \", ord \"a\"\n","out":" 01100001 "},{"code":"printf '%2$-2s%1$s', qw(a b) # you're trying to write a script to do this, or is there more to it?\n","err":"","out":"b a"},{"code":"printf '%-2$p', sub {}\n","err":"","out":"%-2$p"},{"out":"3.1415926535897931159979634685441851615906\n","err":"","code":"printf \"%.40f\\n\", 3.141592653589793238462643383279502884;\n"},{"code":"printf \"%.6f\", 6.437370834e-01\n","err":"","out":"0.643737"},{"out":"64.373708","code":"printf \"%.6f\", 6.437370834e+01\n","err":""},{"out":"0.000006","code":"printf \"%.6f\", 6.437370834e-06\n","err":""},{"out":"6437370.834000","err":"","code":"printf \"%.6f\", 6.437370834e+06\n"},{"err":"","code":"printf '%b', ord ' '\n","out":"100000"},{"code":"print fc(\"Å\") cmp fc(\"z\")\n","err":"","out":"1"},{"code":"printf(â%dâ, 1.9)\n","err":"","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after /; printf(<-- HERE near column 98 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"-9%","err":"","code":"printf('%d%%', (45/50-1)*100)\n"},{"out":"-9%","err":"","code":"printf('%d%%', (9/10-1)*100)\n"},{"out":"floo","err":"","code":"print \"floo\"\n"},{"err":"","code":"\\&print->(\"foo\")\n","out":"ERROR: Undefined subroutine &main::print called at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"print \"foo\"\n","out":"foo"},{"err":"","code":"print \"foo\" if (\"/page/show/1234\" =~ m{page/});\n","out":"foo"},{"code":"print foo(); my $x = 213; sub foo { $x }\n","err":"","out":"213"},{"code":"print for 1..4\n","err":"","out":"1234"},{"out":"aaaazzzz","err":"","code":"print for aaaa.zzzz\n"},{"out":"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ","code":"print for (a..z, 0..9, A..Z);\n","err":""},{"out":"12345","err":"","code":"print foreach 1..5\n"},{"out":"111,99,","err":"","code":"print \"$_,\" for sort ( 99, 111 )\n"},{"code":"print \"<<$_>>\" for 'this is a test' =~ /.../g;  # hehehe\n","err":"","out":"<<thi>><<s i>><<s a>><< te>>"},{"err":"","code":"print/..(..?)/ for[],{},$\"x3,\\&f,\\0\n","out":"RASH DEAL"},{"out":"51.66666667","code":"printf q{%.8f}, 155.0 / 3.0\n","err":""},{"err":"","code":"printf q{%f.8}, 155.0 / 3.0\n","out":"51.666667.8"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"printf ?say\\n?\n","err":""},{"out":"I'm so unruly bot ...\n","err":"","code":"printf(\"%s\\n\", \"I'm so unruly bot ...\");\n"},{"out":"01101000 01100101 01101100 01101100 01101111","code":"printf \"%*v08b\", \" \", \"hello\"\n","err":""},{"code":"printf \"%vd %s\", chr hex \"2665\", chr hex \"2665\"\n","err":"","out":"9829 ÃÂ¢ÃÂÃÂ¥"},{"out":"195.188","code":"printf \"%vd\", \"Ã¼\"\n","err":""},{"code":"printf '%x' ord ':'\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"'%x' ord\"\n"},{"out":"3a","code":"printf '%x', ord ':'\n","err":""},{"out":"Good night","err":"","code":"print 'Good night';\n"},{"out":"hello","err":"","code":"print \"hello\"\n"},{"code":"print \"Hello\";\n","err":"","out":"Hello"},{"out":"hello","code":"print \"hello\"; 2+2\n","err":""},{"out":"hello\n","err":"","code":"print \"hello\\n\";\n"},{"code":"print \"hello\\nworld\"\n","err":"","out":"hello\nworld"},{"err":"","code":"@{ print \"hello\"; print \" world\"; [] }\n","out":"hello world"},{"err":"","code":"print \"hello world\";\n","out":"hello world"},{"out":"Hello world!","code":"print \"Hello world!\";\n","err":""},{"code":"print \"Hello, world!\";\n","err":"","out":"Hello, world!"},{"out":"hello world\n","code":"print \"hello world\\n\"\n","err":""},{"out":"hi","code":"print \"hi\";\n","err":""},{"err":"","code":"print \"hi\\tsir\\n\"\n","out":"hi\tsir\n"},{"err":"","code":"print \"hi\".(\" \" x 4).\"there\\n\";\n","out":"hi    there\n"},{"out":"I'm a Perl 5 program.","err":"","code":"print \"I'm a Perl \", 5 + !!\"0\", \" program.\"\n"},{"code":"print \"is about to flood the channel\"\n","err":"","out":"is about to flood the channel"},{"err":"","code":"print join \",\",  grep { $_ % 2 == 0 } (1..50)\n","out":"2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50"},{"code":"print join('',map {chr $_} (97, 98, 99))\n","err":"","out":"abc"},{"out":"axbxcxd","code":"print join ('x', \"a\",\"b\",\"c\",\"d\");\n","err":""},{"err":"","code":"print join x => a => b => c => d =>\n","out":"axbxcxd"},{"code":"print \"Å\" cmp \"z\"\n","err":"","out":"1"},{"code":"print `ls`;\n","err":"","out":"1"},{"err":"","code":"print `ls /tmp`\n","out":"1"},{"code":"print map { \"(\".$_.\")\" } \"a:1 b:2 a:3 b:4 \" =~ m/^((a:\\d+ )(b:\\d+ ))*/\n","err":"","out":"(a:3 b:4 )(a:3 )(b:4 )"},{"out":"abcdefghi","code":" print map (lc,('ABC','DEF','GHI'));\n","err":""},{"out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after  map (lc,(<-- HERE near column 106 at (eval 1) line 1, <STDIN> line 1.\n","code":" print map (lc,(âABCâ,âDEFâ,âGHIâ));\n","err":""},{"out":"abcdefghi","code":" print map { lc } qw/ ABC DEF GHI /;\n","err":""},{"out":"0123456789","code":"print map { $x++ } 1..10\n","err":""},{"err":"","code":"[ print \"Miesco\", print \"Miesco\" ]\n","out":"MiescoMiesco1"},{"out":"MiescoMiesco1","err":"","code":"print \"Miesco\", print \"Miesco\"\n"},{"out":"MiescoMiesco","code":"print(\"Miesco\"), print(\"Miesco\")\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"@arr[\"\n","err":"","code":"print my @arr[2];\n"},{"code":"print my $arr[2];\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"$arr[\"\n"},{"out":"\n","code":"print \"\\n\"\n","err":""},{"code":"print \"$_\\n\" for 'this is a test' =~ /.../g;  # hehehe\n","err":"","out":"thi\ns i\ns a\n te\n"},{"out":"No output.","code":"print \"No output.\"\n","err":""},{"code":"print oct(\"420)\"\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"out":"oh yes, entire nothings","err":"","code":"print(\"oh yes, entire nothings\")\n"},{"err":"","code":"print \"ok\" if \"Ã¥\" =~ /[[:alpha:]_]/\n","out":"ok"},{"code":"print \"ok\" if \"Ã¥\" =~ /[[:alpha:]_]/a\n","err":"","out":""},{"code":"print \"ok\" if \"_\" =~ /[[:alpha:]_]/\n","err":"","out":"ok"},{"out":"","err":"","code":"print \"ok\" if \"_\" =~ /[[:alpha:]]/\n"},{"out":"194","err":"","code":"print ord \"Â¢\"\n"},{"code":"print ord('a'), \" \", ord('Ð°');\n","err":"","out":"97 208"},{"code":"print ord('a'), ord('Ð°');\n","err":"","out":"97208"},{"code":"print ord pack \"cc\", 9999\n","err":"","out":"15"},{"out":"194","code":"print ord \"Â \"\n","err":""},{"out":"Perl is easy","code":"print \"Perl is easy\";\n","err":""},{"err":"","code":"print ${ print 'foo'; \\'bar' };\n","out":"foobar"},{"code":"print print print print print\n","err":"","out":"1111"},{"out":"PRIVMSG ##microsoft hello","code":"print \"PRIVMSG ##microsoft hello\";\n","err":""},{"out":"$@","code":"print prototype('CORE::sprintf')\n","err":""},{"out":"foo","code":"print q/foo/\n","err":""},{"code":"print q{foo} while 0;\n","err":"","out":"0"},{"out":"[\\/:\\\\\\/][/:\\/]","err":"","code":"print '[', $_, ':', quotemeta($_), ']' for q{\\/}, qq{\\/};\n"},{"err":"","code":"print quotemeta 'test@example.com'\n","out":"test\\@example\\.com"},{"code":"print\"RASH DEAL\"\n","err":"","out":"RASH DEAL"},{"out":"7c86467b","code":"print reverse (\"7c86467b\");\n","err":""},{"out":"987654321","code":"print ( reverse sort ( 1..9 ));\n","err":""},{"err":"","code":"print round(0.5)\n","out":"ERROR: Undefined subroutine &main::round called at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"print s/..(..).*/$1/r for[],{},$\",\\&f,\\0\n","err":"","out":"RASH DEAL"},{"code":"print s/..(..).*/$1/r for(...there you go\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"(...\"\n"},{"out":"1","err":"","code":"print scalar \"321\" =~ /\\d+/;\n"},{"out":"1","code":"print scalar (a..b)\n","err":""},{"out":"ab","code":"print scalar a..b\n","err":""},{"out":"1","err":"","code":"print scalar \"abc\" =~ /\\d+/;\n"},{"out":"gnirts ym","err":"","code":"print scalar reverse \"my string\"\n"},{"code":"print $self\n","err":"","out":"1"},{"out":"123456789","err":"","code":"print ( sort ( 1..9 ));\n"},{"out":"100101102979899","err":"","code":"print sort 97..102\n"},{"err":"","code":"print \"$_,\" sort ( 99, 111 );\n","out":"ERROR: syntax error at (eval 1) line 1, near \"\"$_,\" sort \"\n"},{"code":"print sort ( 99, 111 );\n","err":"","out":"11199"},{"err":"","code":"print sort qw( 1 5 2 3 7 4 6 9 8 0);\n","out":"0123456789"},{"out":"Just another Perl hacker,","code":"print sort {$|--} \"tuJsa nohterP er lhakcer,\" =~ /./g\n","err":""},{"err":"","code":"print sprintf(\"Hello %s!\", uc \"Corin\");\n","out":"Hello CORIN!"},{"err":"","code":"print sqrt length \"zomg\"\n","out":"2"},{"code":"print {STDOUT} 1,2;\n","err":"","out":"121"},{"out":"Ã¢ÂÂ±1","err":"","code":"print STDOUT chr 8305\n"},{"out":"1","err":"","code":"print $t\n"},{"out":"","err":"","code":"print test\n"},{"out":"test","code":"print 'test'\n","err":""},{"err":"","code":"print \"test\"\n","out":"test"},{"out":"1","err":"","code":"print $this_variable_does_not_exist;\n"},{"out":"","code":"print \"Time for coffee\" if $!{ENOCAFFIENE}\n","err":""},{"err":"","code":"print true\n","out":""},{"err":"","code":"print uc sprintf(\"Hello %s!\", \"Corin\");\n","out":"HELLO CORIN!"},{"out":"[\"print\",undef]","code":"[ print => undef ]\n","err":""},{"out":"undef1","err":"","code":"print undef => 1\n"},{"err":"","code":"print ${^UNICODE}\n","out":"01"},{"out":"10000110","err":"","code":"print unpack(\"b8\", \"a\")\n"},{"out":"ÃÂ°ÃÂÃÂÃÂ©","code":"print v128169\n","err":""},{"err":"","code":"print v3232.95.3232\n","out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ "},{"out":"ÃÂ¢ÃÂÃÂ¡","err":"","code":"print v9825\n"},{"out":"$variable","code":"print '$variable'\n","err":""},{"code":"print \"very well\"\n","err":"","out":"very well"},{"code":"print \"$_ \" while $_ = glob 'test' =~ s/([a-z])/{\\l$1,\\u$1}/gir  # what was wrong with this ?\n","err":"","out":"test tesT teSt teST tEst tEsT tESt tEST Test TesT TeSt TeST TEst TEsT TESt TEST "},{"out":"ÃÂÃÂ¢","err":"","code":"print \"\\x{0622}\"\n"},{"code":"print $x=1, $x=2, $x=3, $x=4, $x=5;\n","err":"","out":"55555"},{"out":"-----------------------------------\n","err":"","code":"print '-' x 35 . \"\\n\";\n"},{"err":"","code":"print '-' x 35.\"\\n\";\n","out":"ERROR: syntax error at (eval 1) line 1, near \"35.\"\\n\"\"\n"},{"err":"","code":"print \"\\x{ffff}\"\n","out":"ÃÂ¯ÃÂ¿ÃÂ¿"},{"out":"ÃÂ¿ff","err":"","code":"print \"\\xffff\"\n"},{"err":"","code":"print \"x\" for qw(1 2 3);\n","out":"xxx"},{"err":"","code":"print \"Yes we do\";\n","out":"Yes we do"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"product 1\"\n","code":"product 1..10\n","err":""},{"code":"prototype \\&CORE::bless\n","err":"","out":"$;$"},{"err":"","code":"prototype 'CORE::bless' ? 'yes' : 'no'\n","out":"yes"},{"err":"","code":"prototype \"CORE::glob\"\n","out":"_;"},{"out":"$@","code":"prototype \\&CORE::join\n","err":""},{"err":"","code":"prototype \\&CORE::lc\n","out":"_"},{"err":"","code":"prototype 'CORE::open'\n","out":"*;$@"},{"code":"prototype \"CORE::open\"\n","err":"","out":"*;$@"},{"out":"$@","err":"","code":"prototype \"CORE::pack\"\n"},{"err":"","code":"prototype \\&CORE::print\n","out":""},{"code":"prototype \\&CORE::prototype\n","err":"","out":"_"},{"out":"\\@@","code":"prototype 'CORE::push'\n","err":""},{"code":"prototype \"CORE::push\"\n","err":"","out":"\\@@"},{"err":"","code":"prototype(\\&CORE::push)\n","out":"\\@@"},{"err":"","code":"prototype 'CORE::ref'\n","out":"_"},{"out":"_","code":"prototype \\&CORE::ref\n","err":""},{"out":";$","code":"prototype \\&CORE::sleep\n","err":""},{"out":"","code":"prototype 'CORE::sort'\n","err":""},{"out":"\\@;$$@","code":"prototype 'CORE::splice'\n","err":""},{"code":"prototype(\\&CORE::split)\n","err":"","out":""},{"err":"","code":"prototype \\&CORE::substr\n","out":"$$;$$"},{"out":";\\[$@%&*]","err":"","code":"prototype 'CORE::undef'\n"},{"out":"@","code":"prototype \"CORE::warn\"\n","err":""},{"code":"prototype \"CORE::write\"\n","err":"","out":";*"},{"code":"provides scalar context\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"provides scalar\"\n"},{"code":"prtin 1\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"prtin 1\"\n"},{"out":"1","code":"$_=\"psychology\"; print reverse;\n","err":""},{"out":"ERROR: Invalid range \"z-a\" in transliteration operator at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"$_=\"psychology\"; tr/a-z/z-a/g; print;\n"},{"code":"$_ = 'psychology'; $za = join('', reverse 'a' .. 'z'); eval \"tr/a-z/$za/\"; $_\n","err":"","out":"khbxsloltb"},{"code":"$_ = 'psychology'; $za = join('', reverse 'a' .. 'z'); eval \"tr/a-z/$za\"; $_\n","err":"","out":"psychology"},{"err":"","code":"$_ = 'psychology'; $za = join('', 'z' .. 'a'); eval \"tr/a-z/$za\"; $_\n","out":"psychology"},{"out":"othr bits","err":"","code":"'pthr bots' =~ tr/op/io/r\n"},{"out":"1","err":"","code":"'Â·' =~ /[[:punct:]]/\n"},{"out":"1","err":"","code":"'Â§' =~ /[[:punct:]]/\n"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","err":"","code":"push @_, !\n"},{"out":"ERROR: Experimental push on scalar is now forbidden at (eval 1) line 1, near \"1]\"\n","err":"","code":"[push [], 1]\n"},{"out":"Grinnz_ is the push (@_,\"alpha\"); push (@_,\"omega\"); print \"Grinnz_ is the $_[0] and the $_[$#_]\\n\" and the omega\n","code":"push (@_,\"alpha\"); push (@_,\"omega\"); print \"Grinnz_ is the $_[0] and the $_[$#_]\\n\"\n","err":""},{"err":"","code":"$|++; push @a, $|; $|--; push @a, $|; $|--; push @a,  $|; \\@a\n","out":"[1,0,1]"},{"err":"","code":"[ push [], 'a' ]  # thus\n","out":"ERROR: Experimental push on scalar is now forbidden at (eval 1) line 1, near \"'a' ]\"\n"},{"out":"ERROR: Type of arg 1 to push must be array (not constant item) at (eval 1) line 1, at EOF\n","err":"","code":"push foo, 1, 2\n"},{"out":"2,3,4,5,6,7,8,9,10,11","code":"(++$_ && push(@foo, $_)) for 1..10; join ',',@foo;\n","err":""},{"code":"push @foo, glob \"/\" for (1..10); \\@foo\n","err":"","out":"[\"/\",\"/\",\"/\",\"/\",\"/\",\"/\",\"/\",\"/\",\"/\",\"/\"]"},{"out":"ERROR: Experimental push on scalar is now forbidden at (eval 1) line 1, at EOF\n","code":"push $hash{foo}, 'something'; \\%hash\n","err":""},{"err":"","code":"push $hash->{foo}->@*, \"wibble\"; $hash\n","out":"{foo => [\"wibble\"]}"},{"err":"","code":"push @{ $href->{key} }, qw(a b c); $href\n","out":"{key => [\"a\",\"b\",\"c\"]}"},{"code":"push @l, $-[0] while \"banana\" =~ /b|a|n/g; [@l]\n","err":"","out":"[0,1,2,3,4,5]"},{"err":"","code":"push @players, [ \"Dealer\", \"\", \"\" ]; push @players, [ \"AcidRain\", \"50\", \"\" ];     [ @players ]\n","out":"[[\"Dealer\",\"\",\"\"],[\"AcidRain\",50,\"\"]]"},{"out":"1","code":"push @strings, $_ =~ m/^\\w*/\n","err":""},{"code":"push @strings, [$_ =~ /^\\w+/];\n","err":"","out":"1"},{"out":"{foo => [\"bar\",\"baz\"]}","err":"","code":"push @{$x->{foo}}, 'bar'; push @{$x->{foo}}, 'baz'; $x  # or with $x not even hodling anything to begin with\n"},{"out":"","code":"`pwd`;\n","err":""},{"err":"","code":"q ð :) ð\n","out":"ERROR: Unrecognized character \\x9F; marked by <-- HERE after  ÃÂ°ÃÂÃÂÃÂ :) ÃÂ°<-- HERE near column 102 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","code":"q{}\n","err":""},{"err":"","code":"q{\\}\n","out":"ERROR: Can't find string terminator \"}\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","err":"","code":"/\\Q[/\n"},{"code":"\"\\Q!\"\n","err":"","out":"\\!"},{"out":"[\"\\\"\"]","err":"","code":"$_ = q(\"...); /()(.)/; [$2]\n"},{"out":"q522","err":"","code":"q5.22.0\n"},{"code":"q{\"90020\",33.786594,\"-118.298662\",\"Los Angeles\",\"CA\",\"Los Angeles\"} =~ s/^(\".+\").+$/$1/r\n","err":"","out":"\"90020\",33.786594,\"-118.298662\",\"Los Angeles\",\"CA\",\""},{"err":"","code":"q \\ a\\ b\\ c ;\n","out":"ERROR: syntax error at (eval 1) line 1, near \"q \\ a\\ b\"\n"},{"err":"","code":"[ q{abc def 123 ghi} =~ m/\\b([A-Za-z]+)\\b/g ]; # Where as this matches all three.\n","out":"[\"abc\",\"def\",\"ghi\"]"},{"err":"","code":"[ q{abc def 123 ghi} =~ m/(?:^|\\s)([A-Za-z]+)(?=\\s|$)/g ]\n","out":"[\"abc\",\"def\",\"ghi\"]"},{"out":"[\"abc\",\"ghi\"]","err":"","code":"[ q{abc def 123 ghi} =~ m/(?:^|\\s)([A-Za-z]+)(?:\\s|$)/g ]; # Why doesn't 'def' get matched?\n"},{"out":"[\"c\"]","err":"","code":"$_= q/a b c d e f g/; @vars = (split)[2]; \\@vars\n"},{"out":"[\"c\",\"d\"]","err":"","code":"$_= q/a b c d/; @vars = (split)[2,3]; \\@vars\n"},{"code":"q aeven thisa\n","err":"","out":"even this"},{"err":"","code":"$_=q{an if1 \" some if2 \" then \"if3\" not if4!!};  [ /(if\\d)(?=(?:[^\"]|\"[^\"]*\")*$)/g ]\n","out":"[\"if1\",\"if4\"]"},{"err":"","code":"$_=q{an if1 \" some if2 \" then \"if3\" not if4!!};  [ /\"[^\"]*\"(*SKIP)(*F)|if\\d/g ]\n","out":"[\"if1\",\"if4\"]"},{"out":"aller ve","err":"","code":"q caller vec\n"},{"out":"[\"echo\",\"foo\",\"bar=baz\",\"hmm=\\\"1 2 3\\\"\",\"nn='aa bb'\"]","err":"","code":"$_ = q,echo foo bar=baz hmm=\"1 2 3\" nn='aa bb',; my @h; s/(([\"'])(?:[^\"']+|\\\\.|(?!\\2).)*\\2)/push @h, $1;\"\\xFFFD\"/ge; my @words = split ' '; s/\\xFFFD/shift @h/ge for @words; \\@words;\n"},{"out":"foo","err":"","code":"q\\foo\\\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"q\\foo\\\\\"\n","err":"","code":"q\\foo\\\\bar\\\n"},{"err":"","code":"\"\\Qf(o+o*)\\Ebar\"\n","out":"f\\(o\\+o\\*\\)bar"},{"code":"\"\\Qfoo\\Ebar\"\n","err":"","out":"foobar"},{"out":"1","code":"q\\foo\\ =~ m\\foo\\\n","err":""},{"err":"","code":"q\\foo\\ =~ s\\foo\\bar\\r\n","out":"bar"},{"code":"q{foo} x 2.5 # Would be interesting if this coudl actually produce a sub string.\n","err":"","out":"foofoo"},{"out":"ERROR: Unrecognized character \\x88; marked by <-- HERE after q ÃÂÃÂhelloÃÂ<-- HERE near column 101 at (eval 1) line 1, <STDIN> line 1.\n","code":"q ÌhelloÌ\n","err":""},{"out":"ERROR: Unrecognized character \\x88; marked by <-- HERE after  qÃÂÃÂhelloÃÂ<-- HERE near column 100 at (eval 1) line 1, <STDIN> line 1.\n","code":"qÌhelloÌ\n","err":""},{"err":"","code":"qÌhelloÌ . \"\"\n","out":"ERROR: Unrecognized character \\x88; marked by <-- HERE after  qÃÂÃÂhelloÃÂ<-- HERE near column 100 at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"q{I think perl bot is down?}\n","out":"I think perl bot is down?"},{"out":"\"\"","code":"qq(\"\")\n","err":""},{"code":"qq(\"\\\")\n","err":"","out":"\"\""},{"out":"ERROR: Can't find string terminator \")\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"qq(\\)\n"},{"out":"a b c ' d","err":"","code":"q qa b c ' dq # great idea\n"},{"out":"1","err":"","code":"q qaq =~ m\\a\\\n"},{"out":"","code":"qq'$bar'\n","err":""},{"err":"","code":"qq(foo\\tbar)\n","out":"foo\tbar"},{"out":"[undef,\"hello\",undef,\"there\",\"test test\",undef,undef,\"more\",undef,\"testing\"]","code":"[ qq(hello there \"test test\" more testing) =~ /\"([^\"]+)\"|(\\S+)/g ]\n","err":""},{"err":"","code":"[ qq(    \"  some extra spaces \" hello there \"test test\" more testing) =~ /\"([^\"]+)\"|(\\S+)/g ]\n","out":"[\"  some extra spaces \",undef,undef,\"hello\",undef,\"there\",\"test test\",undef,undef,\"more\",undef,\"testing\"]"},{"out":"[\"space1   \",undef,undef,\"space2\"]","code":"[ qq(  \"space1   \"   space2 ) =~ /\"([^\"]+)\"|(\\S+)/g ]\n","err":""},{"out":"[\"\\\"foo\\\\\\r\\\\\\n\\\\\\tbar\\\\\\n\\\"\"]","code":"[q{\"}.quotemeta(\"foo\\r\\n\\tbar\\n\").q{\"}]\n","err":""},{"err":"","code":"[ qr/[ @_ ]/ ]\n","out":"[qr/[ [ qr\\/[ @_ ]\\/ ] ]/u]"},{"out":"qr/ qr\\/ @_ \\/ /u","err":"","code":"qr/ @_ /\n"},{"code":"qr/(?[ () ])/\n","err":"","out":"ERROR: Incomplete expression within '(?[ ])' in regex; marked by <-- HERE in m/(?[ ()  <-- HERE ])/ at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"qr/[[]/u","code":"qr/[[]/\n","err":""},{"out":"(?^u:^cats$)","code":"qr/^cats$/ . \"\"\n","err":""},{"out":"ERROR: Switch (?(condition)... not terminated in regex; marked by <-- HERE in m/(?(DEFINE) <-- HERE / at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"qr{(?(DEFINE)};\n"},{"out":"qr/e/u","err":"","code":"qr/e$d/\n"},{"code":"q{regexp_substr(fn.stringvalue, '\\w+\\s\\w+') user_full_name}\n","err":"","out":"regexp_substr(fn.stringvalue, '\\w+\\s\\w+') user_full_name"},{"out":"ERROR: Quantifier follows nothing in regex; marked by <-- HERE in m/* <-- HERE .*/ at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"qr/*.*/ # not with that first * in there, no\n"},{"code":"qr/\\Q$foo/\n","err":"","out":"qr//u"},{"out":"[qr/foo/u,qr/\\Qfoo/u]","err":"","code":"[qr/\\Qfoo/, qr'\\Qfoo']\n"},{"out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/( <-- HERE ?^:\\(s\\)\\)/ at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"qr/(?^:\\Q(s))/\n"},{"code":"qr/\\Q(s)/\n","err":"","out":"qr/\\(s\\)/u"},{"err":"","code":"qr'\\Q/s.'\n","out":"qr/\\Q\\/s./u"},{"out":"qr/\\Q(s)/u","err":"","code":"qr'\\Q(s)'\n"},{"out":"qr/(?^:\\(s\\))/u","err":"","code":"qr/(?^:\\Q(s)\\E)/\n"},{"out":"qr//u","code":"qr/\\Q$x/\n","err":""},{"out":"qr/(s)/u","err":"","code":"qr'(s)'\n"},{"code":"'' . qr/something/msx\n","err":"","out":"(?^umsx:something)"},{"code":"[ qr/\\s+:SerialNumber\\s+/, \"\\s+:SerialNumber\\s+\" ]\n","err":"","out":"[qr/\\s+:SerialNumber\\s+/u,\"s+:SerialNumbers+\"]"},{"err":"","code":" qr/(?s)<tr/ . ''\n","out":"(?^u:(?s)<tr)"},{"err":"","code":"qr/<tr/s . ''\n","out":"(?^us:<tr)"},{"out":"qr/what does this do/ux","code":"qr/what does this do/x\n","err":""},{"err":"","code":"qr/(\\.xls$|\\.xlsx$)/\n","out":"qr/(\\.xls$|\\.xlsx$)/u"},{"err":"","code":"qr/(?=.|\\z)*.*/\n","out":"qr/(?=.|\\z)*.*/u"},{"code":"quotemeta <>\n","err":"","out":""},{"out":"\\<\\>","code":"quotemeta <\\<\\>>\n","err":""},{"out":"\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)_\\\\\\{\\}\\.\\,\\+\\?","code":"quotemeta '~!@#$%^&*()_\\\\{}.,+?'\n","err":""},{"out":"\\<\\>","code":"quotemeta '<>'\n","err":""},{"err":"","code":"quotemeta '!'\n","out":"\\!"},{"code":"quotemeta \"_\"\n","err":"","out":"_"},{"err":"","code":"quotemeta \":\"\n","out":"\\:"},{"code":"quotemeta 'abcdefg[\\]$%^&*()'\n","err":"","out":"abcdefg\\[\\\\\\]\\$\\%\\^\\&\\*\\(\\)"},{"code":"quotemeta 'hello world'\n","err":"","out":"hello\\ world"},{"err":"","code":"quotemeta 'hello:world'\n","out":"hello\\:world"},{"err":"","code":"quotemeta q<<>>\n","out":"\\<\\>"},{"out":"\\\\\\/","err":"","code":"quotemeta(q{\\/})\n"},{"out":"\\/","code":"quotemeta(qq{\\/})\n","err":""},{"code":"[ quotemeta(q{\\/}), quotemeta(qq{\\/}) ]\n","err":"","out":"[\"\\\\\\\\\\\\/\",\"\\\\/\"]"},{"code":"[ quotemeta 'test@example.com' ]\n","err":"","out":"[\"test\\\\\\@example\\\\.com\"]"},{"out":"ÃÂ­ÃÂÃÂ","err":"","code":"quotemeta \"\\x{D000}\"\n"},{"err":"","code":"quoutemeta <>\n","out":"ERROR: syntax error at (eval 1) line 1, near \"<>\"\n"},{"out":"ERROR: Undefined subroutine &main::quoutemeta called at (eval 1) line 1.\n","err":"","code":"quoutemeta( <> )\n"},{"err":"","code":"qv'5.22.0'\n","out":"ERROR: Bad name after qv' at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"qv5.22.0\n","err":"","out":"qv522"},{"err":"","code":"[qw()]\n","out":"[]"},{"err":"","code":"qw()\n","out":""},{"err":"","code":"[ qw( a b c ) x 3 ]\n","out":"[\"a\",\"b\",\"c\",\"a\",\"b\",\"c\",\"a\",\"b\",\"c\"]"},{"err":"","code":"qw( a b c ) x 3\n","out":"ccc"},{"err":"","code":"[qw(Attachment) x 3]\n","out":"[\"Attachment\",\"Attachment\",\"Attachment\"]"},{"err":"","code":"qw/Attachment/ x 3\n","out":"AttachmentAttachmentAttachment"},{"out":"[\"email\\@one.com\",\"email\\@two.com\"]","err":"","code":"[qw(email@one.com email@two.com)]\n"},{"err":"","code":"\"@{ [ %{ [qw/foo bar baz/] } ] }\"\n","out":"ERROR: Not a HASH reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"%{ [qw/foo bar baz/] }","err":"","code":"\"%{ [qw/foo bar baz/] }\"\n"},{"out":"[\"foo\",\"bar\",\"baz\"]","code":"[ qw(foo bar baz) ]\n","err":""},{"out":"baz","err":"","code":"qw/foo bar baz/\n"},{"out":"baz","code":"qw(foo bar baz)\n","err":""},{"err":"","code":"qw(foo bar baz)[2]\n","out":"baz"},{"err":"","code":"qw/foo bar baz quux/[1]\n","out":"bar"},{"err":"","code":"[ qw ( &my_function) ] # Prostetnic\n","out":"[\"&my_function\"]"},{"code":"[ qw(#no) ]\n","err":"","out":"[\"#no\"]"},{"out":"1","err":"","code":"$qwqwerqwe = 1;\n"},{"code":"+{ qw/you can dump a hashref directly/ }\n","err":"","out":"{hashref => \"directly\",you => \"can\",dump => \"a\"}"},{"code":"qx(id);\n","err":"","out":""},{"out":"","code":"qx(ls /);\n","err":""},{"out":"","code":"qx(whoami)\n","err":""},{"out":"ERROR: Unrecognized character \\xA0; marked by <-- HERE after llo worldÃÂ<-- HERE near column 107 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"q Â hello worldÂ ;\n"},{"err":"","code":"q Â hello\\ worldÂ ;\n","out":"ERROR: Unrecognized character \\xA0; marked by <-- HERE after lo\\ worldÃÂ<-- HERE near column 108 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"RASH DEAL","err":"","code":"\"RASH DEAL\"\n"},{"code":"RASHâDEAL\n","err":"","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after res/; RASH<-- HERE near column 95 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"x?y+\",qr/x?y+/u,qr/x?y+/u]","err":"","code":"$re0 = \"x?y+\"; $re1 = qr/$re0/; $re2 = qr/$re1/; [ $re0, $re1, $re2 ]\n"},{"out":"[qr/x?y+/u,qr/x?y+/u]","code":"$re1 = qr/x?y+/; $re2 = qr/$re1/; [ $re1, $re2 ]\n","err":""},{"out":"","err":"","code":"readline \"{a,b,c}\"\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"reduce 1\"\n","err":"","code":"reduce 1\n"},{"out":"ERROR: Can't locate object method \"reduce\" via package \"0\" (perhaps you forgot to load \"0\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"reduce {$a + $b} 1\n","err":""},{"out":"ARRAY","code":"ref [];\n","err":""},{"out":"REF","err":"","code":"ref \\[1]\n"},{"out":"REF","code":"ref \\\\1\n","err":""},{"out":"SCALAR","code":"ref \\$a\n","err":""},{"code":"ref \\\\\\\\\\\\$a\n","err":"","out":"REF"},{"out":"ARRAY","code":"ref bless {}, 'ARRAY'\n","err":""},{"out":"Here is a lovely long string that I invented one summer's day","code":"ref( bless {}, \"Here is a lovely long string that I invented one summer's day\" )\n","err":""},{"code":"ref [\"item1\",\"item2\"]\n","err":"","out":"ARRAY"},{"out":"","code":"ref main::\n","err":""},{"out":"Regexp","err":"","code":"ref qr//\n"},{"err":"","code":"ref qr//;\n","out":"Regexp"},{"out":"[\"IO::File\"]","code":"[ ref *STDOUT{IO} ]\n","err":""},{"err":"","code":"ref \\(substr \"aliens\", 0, 2)\n","out":"LVALUE"},{"out":"VSTRING","code":"ref \\v1.2.3\n","err":""},{"out":"","err":"","code":"ref v1.2.3\n"},{"code":"ref([v1.2.3]->[0])\n","err":"","out":""},{"out":"[\"\"]","err":"","code":"ref( $x = wantarray ); [$x]\n"},{"out":"ERROR: Quantifier follows nothing in regex; marked by <-- HERE in m/* <-- HERE meow*/ at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"$regex = \"*meow*\"; \"banana\" =~ /$regex/;\n"},{"err":"","code":"[ 'Regexp'->can('(\"\"') ]\n","out":"[undef]"},{"out":"[undef]","err":"","code":"[ 'Regexp'->can('(+0') ]\n"},{"code":"rename(\"/opt/google/chrome\", \"/opt/google/egacs\") or die \"$!\"\n","err":"","out":"ERROR: No such file or directory at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"$re=qr/(\\d{7})/; [ \"12345678\" =~ $re, \"1234567\" =~ $re ]\n","err":"","out":"[1234567,1234567]"},{"err":"","code":"$re=qr/(?<!\\D)(\\d{7})(?!\\D)/; [ \"12345678\" =~ $re, \"1234567\" =~ $re ]\n","out":"[1234567,1234567]"},{"code":"$re = '['; /\\Q$re/\n","err":"","out":""},{"err":"","code":"require(0 + \"inf\")\n","out":"ERROR: Invalid version format (non-numeric data) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"1","err":"","code":"require 5\n"},{"code":"require 5.0.6;\n","err":"","out":"1"},{"err":"","code":"require 5blah\n","out":"ERROR: syntax error at (eval 1) line 1, near \"require 5\"\n"},{"out":"ERROR: Can't locate App::Pluggable:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\n","code":"require 'App::Pluggable';\n","err":""},{"out":"0","err":"","code":"require bigint; bigint->import; 1<<70\n"},{"out":"{\"hi\":123}","err":"","code":"require JSON::XS; JSON::XS::encode_json {hi => 123};\n"},{"out":"ERROR: Can't locate Some::Module:__XYZ:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"require 'Some::Module:__XYZ'\n"},{"err":"","code":"require Some::Module:__XYZ\n","out":"ERROR: syntax error at (eval 1) line 1, near \"require Some::Module:\"\n"},{"code":"$re = '['; /$re/\n","err":"","out":"ERROR: Unmatched [ in regex; marked by <-- HERE in m/[ <-- HERE / at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"return join(',', @accounts);\n","out":""},{"out":"","err":"","code":"return or die;\n"},{"code":"\"Return value\"; \"Miesco\";\n","err":"","out":"Miesco"},{"out":"[\"3b00\",\"1a28\",1100,\"0012\",\"0000\",\"0000\",\"0000\",\"0046\"]","code":"[ reverse(\"6.4.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.1.0.0.0.0.1.1.8.2.a.1.0.0.b.3\" =~ tr/.//dr) =~ /.{4}/g ]\n","err":""},{"code":"reverse \"7c86467b\"\n","err":"","out":"b76468c7"},{"out":"reenigne","err":"","code":"reverse 'engineer'\n"},{"out":"yxorp","code":"reverse proxy\n","err":""},{"err":"","code":"[ reverse \"psychology\" ]\n","out":"[\"psychology\"]"},{"err":"","code":"reverse((reverse 0x7f9241004ee8) =~ s/(...)/$1,/gr)\n","out":",140,266,132,492,008"},{"out":"gnirts","code":"reverse \"string\"\n","err":""},{"code":"reverse (\"string\")\n","err":"","out":"gnirts"},{"out":"[\"string\",\"string\"]","err":"","code":"[ (reverse \"string\"), (reverse (\"string\")) ]\n"},{"code":"reverse (\"string\", \"string\")  # :s\n","err":"","out":"gnirtsgnirts"},{"err":"","code":"[reverse(\"string\",\"strong\"), scalar reverse(\"string\", \"strong\")]\n","out":"[\"strong\",\"string\",\"gnortsgnirts\"]"},{"err":"","code":"$_=\"rexma\"; /(?{$name=\"foo\"})re[x]ma|(?{$name=\"bar\"})o[ther]matc/; $name\n","out":"foo"},{"out":"","code":"@r = (foo => 1, bar => 2); ${{@r}}{\"a\"}\n","err":""},{"err":"","code":"rindex \"1234abc\", \"c\"\n","out":"6"},{"err":"","code":"rindex $_, \"c\" == length $_ - 1 for \"1234abc\"\n","out":""},{"out":"Device or resource busy","code":"rmdir '/' or $!\n","err":""},{"out":"1","err":"","code":"\"\\r\\n\" =~ /^\\R$/\n"},{"out":"[\"hi\",\"hi\",\"one\",\"two\"]","err":"","code":"$row = [qw(hi one two)]; unshift(@$row, substr($row->[0],-10)); $row\n"},{"out":"s","code":"\"\\s\"\n","err":""},{"out":"s+","err":"","code":"\"\\s+\"\n"},{"out":"","code":"s =~ =///=\n","err":""},{"code":"/@(\\S+)/\n","err":"","out":""},{"err":"","code":"/\\s{0,}(#{0,})SANITY01/\n","out":""},{"out":"","err":"","code":"/\\s{0,}(\\#{0,})SANITY01/x\n"},{"code":"/\\s{0,}(#{0,})SANITY01/x\n","err":"","out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/\\s{0,}(#{0,})SANITY01 <-- HERE / at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"\"S01E\" . $1 * 2\n","out":"S01E0"},{"code":"S01E($1*2)\n","err":"","out":"ERROR: Undefined subroutine &main::S01E called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"RASH DEAL","code":"s/..(..).*/$1/ for@x=([],{},$\",\\&f,\\0);print@x\n","err":""},{"code":"s/..(..).*/$1/ for@x=([],{},$\",\\&f,\\0);$\"=\"\";\"@x\"\n","err":"","out":"RASH DEAL"},{"out":"RASH DEAL","code":"s/..(..).*/$1/,print for@x=([],{},$\",\\&f,\\0)\n","err":""},{"out":"[\"foo\"]","code":"$s1 = ''; $s2 = 'foo'; $s3 = $s1 || $s2; [$s3]\n","err":""},{"out":"/","err":"","code":"\"////\" =~ s{/{2,}}{/}gr\n"},{"code":"$s=(3+undef)/2;print $s\n","err":"","out":"1.5"},{"code":"@s=[4,5,6];print join \" \",@s[-1..-2];\n","err":"","out":"1"},{"err":"","code":"@s=[4,5,6];print @s[-1..-2];#since no one's talking in here anyway, may as well use the bot\n","out":"1"},{"code":"$s = \"a,b also has, commas,c,d,e,has,commas,f,g\"; $s =~ s/(,[^,]+){2}$//;  \"e is '\" . (split \",\", $s, 5)[4] . \"'\"\n","err":"","out":"e is 'd,e,has,commas'"},{"err":"","code":"$s = \"a,b,c,d,e,has,commas,f,g\"; $s =~ s/(,[^,]+){2}$//;  \"e is '\" . (split \",\", $s, 5)[4] . \"'\"\n","out":"e is 'e,has,commas'"},{"code":"$s=\"a.b.c.d\"; $h{a}{b}{c}{d}=123;  $r=\\%h; $r=$r->{$_} for split/\\./,$s; $r\n","err":"","out":"123"},{"out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"$s=\"a.b.c.d\"; $h{a}{b}{c}{d}=123;  $r=\\%h; $r=$r->{$_} for split/\\./,$s; $r'\n","err":""},{"code":"$s=\"a.b.c.d\"; my %h; @h{ split(/\\./, $s) } = (1, 2, 3, 4); print keys %h, print values %h;\n","err":"","out":"2341bcda1"},{"code":"$s = '*';  \"a*b*c\" =~ /\\Q$s/ ? \"Match\" : \"No match\"\n","err":"","out":"Match"},{"err":"","code":"$s = '*';  \"a*b*c\" =~ /$s/ ? \"Match\" : \"No match\"\n","out":"ERROR: Quantifier follows nothing in regex; marked by <-- HERE in m/* <-- HERE / at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"\"s\" =~ /^((?:a|b|c)s?)?$/ # whatever dude\n","out":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"\"{a}b}\" $s \"\n","err":"","code":"$s = \"{a}b}\" $s =~ /\\{(.*?)\\}/; [$1]\n"},{"out":"[\"a\"]","code":"$s = \"{a}b}\"; $s =~ /\\{(.*?)\\}/; [$1]\n","err":""},{"code":"s/(A)/eval(lcfirst $1)/gee\n","err":"","out":""},{"err":"","code":"s/(A)/lcfirst $1/e\n","out":""},{"out":"","code":"s/(A)/lcfirst $1/re\n","err":""},{"code":"$_=\"&&&\"; s/&/&amp;/g; [$_]\n","err":"","out":"[\"&amp;&amp;&amp;\"]"},{"err":"","code":"s///apple\n","out":"ERROR: Regexp modifiers \"/a\" and \"/l\" are mutually exclusive at (eval 1) line 1, near \"; \"\n"},{"out":"ERROR: Regexp modifiers \"/a\" and \"/l\" are mutually exclusive at (eval 1) line 1, near \"; \"\nRegexp modifiers \"/a\" and \"/l\" are mutually exclusive at (eval 1) line 1, near \"; \"\n","err":"","code":"s///asmallregex\n"},{"out":"save","err":"","code":"${ \\ 'save' }\n"},{"out":"0\n","err":"","code":"say $[\n"},{"out":"18446744073709551615\n","err":"","code":"say ~0;\n"},{"err":"","code":"say$_*2for 1..10\n","out":"2\n4\n6\n8\n10\n12\n14\n16\n18\n20\n"},{"code":"say((\"a\" x 10000) =~ /^(ab?)*$/ ? \"Yes\" : \"No\");\n","err":"","out":"Yes\n"},{"err":"","code":"say blahblah q|0.000.000_YYMMDDhhmm|\n","out":""},{"out":"damn them all to hell\n","code":"say \"damn them all to hell\";\n","err":""},{"code":"say Encode::encode(\"ISO-8859-1\", Encode::decode(\"UTF-8\", \"ÃÂ¡r jÃÂº sÃÂºr?\"));\n","err":"","out":"ÃÂÃÂ¡r jÃÂÃÂº sÃÂÃÂºr?\n"},{"out":"foo\n","code":"say \"foo\" if (\"/page/show/1234\" =~ m{page/});\n","err":""},{"out":"","code":"say for keys %hash;\n","err":""},{"code":"say 'hello'\n","err":"","out":"hello\n"},{"code":"say hi\n","err":"","out":""},{"code":"say 'hi'\n","err":"","out":"hi\n"},{"out":"hi\n","code":"say \"hi\"\n","err":""},{"code":"say length \"0.99999999999991\"\n","err":"","out":"16\n"},{"code":"say length q|0.000.000_YYMMDDhhmm|\n","err":"","out":"20\n"},{"err":"","code":"say lenqth q|0.000.000_YYMMDDhhmm|\n","out":""},{"out":"ERROR: Can't find string terminator \"h\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"say q  hello\\ world ;\n"},{"out":"ERROR: Unrecognized character \\xA0; marked by <-- HERE after lo\\ worldÃÂ<-- HERE near column 112 at (eval 1) line 1, <STDIN> line 1.\n","code":"say q Â hello\\ worldÂ ;\n","err":""},{"out":"RASH DEAL\n","err":"","code":"say\"RASH DEAL\"\n"},{"code":"say something\n","err":"","out":""},{"err":"","code":"say \"var $rindolf is better than var $generic_var\"\n","out":"var  is better than var \n"},{"out":"ERROR: Can't locate object method \"what\" via package \"again\" (perhaps you forgot to load \"again\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"say what again\n","err":""},{"out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after res/; say <-- HERE near column 95 at (eval 1) line 1, <STDIN> line 1.\n","code":"say âwhateverâ\n","err":""},{"err":"","code":"say \"wotcher\"\n","out":"wotcher\n"},{"code":"say (\"wotcher\")\n","err":"","out":"wotcher\n"},{"out":"banAPPLEana","err":"","code":"$s = \"banana\"; substr($s, 3,0) = \"APPLE\"; $s\n"},{"out":"","err":"","code":"/(?<!S)\\b/i\n"},{"err":"","code":"'   ' =~ /\\s\\B\\s/\n","out":"1"},{"code":"s/(?<\\b!STYLESY0B\\$\\$)\\b$k\\b/<span class=\"kw1\">$k<\\/span>/igs\n","err":"","out":"ERROR: Group name must start with a non-digit word character in regex; marked by <-- HERE in m/(?<\\ <-- HERE b!STYLESY0B\\$\\$)\\b\\b/ at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[1]","code":"[ *_{SCALAR} == \\$_ ]\n","err":""},{"out":"scalar @_[0]","err":"","code":"scalar @_[0]\n"},{"out":"[\"00000\"]","err":"","code":"[scalar( (0) x 5 )]\n"},{"code":"scalar (() = (1..10))\n","err":"","out":"10"},{"out":"ERROR: Not enough arguments for scalar at (eval 1) line 1, near \"scalar () \"\n","err":"","code":"scalar () = (1..10)\n"},{"out":"[\"\",\"\",\"\",\"\"]","err":"","code":"[ scalar('Ù£' =~ /^\\d$/a), scalar('Ù£' =~ /^.$/a), scalar(\"Ù¢\" =~ /^[Ù¡-Ù£]$/a), scalar('Ù£' =~ /^\\D$/a) ]\n"},{"out":"","err":"","code":"scalar @{$arrayref}[1,2,3]\n"},{"out":"1","err":"","code":"scalar \"asd1312321asd1212asd121212\" =~/(asd\\d+)/g;\n"},{"out":"AAA","code":"scalar  ( \"A\" ) x 3\n","err":""},{"err":"","code":"scalar  +( \"A\" ) x 3\n","out":"AAA"},{"out":"0","err":"","code":"scalar @{ $foo{bar}{baz} // [] }\n"},{"err":"","code":"scalar(()=glob('*'))  # probably 0\n","out":"0"},{"code":"scalar grep /isnt/, qw/list of words/\n","err":"","out":"0"},{"err":"","code":"scalar grep /is/, qw/list of words/\n","out":"1"},{"err":"","code":"scalar \\%hash\n","out":"{}"},{"out":"0","err":"","code":"scalar %hash\n"},{"code":"scalar(@order) = 2; @order and @order = grep $_, @order[-2, -1]\n","err":"","out":"ERROR: Can't modify scalar in scalar assignment at (eval 1) line 1, at EOF\n"},{"out":"3","err":"","code":"scalar qw/1 2 3/;   # this should be more confusing :p\n"},{"out":"[\"AttachmentAttachmentAttachment\"]","err":"","code":"[scalar qw(Attachment) x 3]\n"},{"out":"cba","code":"scalar reverse 'abc'\n","err":""},{"out":"oof","err":"","code":"\"${\\scalar reverse 'foo'}\"\n"},{"err":"","code":"[ scalar reverse \"psychology\" ]\n","out":"[\"ygolohcysp\"]"},{"out":"[1,\"\"]","err":"","code":"[ scalar '' =~ /^$/, scalar 'a' =~ /^$/]\n"},{"out":"[1,3,5]","code":"scalar scalar scalar [1, 3, 5]\n","err":""},{"err":"","code":"\"${\\scalar sub { wantarray() ? 'list' : 'scalar' }->()}\"\n","out":"scalar"},{"code":"[ Scalar::Util::looks_like_number '1 ' ]\n","err":"","out":"[1]"},{"err":"","code":"Scalar::Util::looks_like_number(\"4\")\n","out":"1"},{"out":"1","err":"","code":"Scalar::Util::looks_like_number( 'inf')\n"},{"err":"","code":"Scalar::Util::looks_like_number('-INF')\n","out":"1"},{"err":"","code":"Scalar::Util::looks_like_number('INF')\n","out":"1"},{"code":"Scalar::Util::looks_like_number( 'inferior')\n","err":"","out":""},{"code":"Scalar::Util::looks_like_number \"nan\"\n","err":"","out":"1"},{"out":"1","code":"Scalar::Util::looks_like_number 'NaN'\n","err":""},{"err":"","code":"Scalar::Util::looks_like_number( 'NaN')\n","out":"1"},{"out":"1.4202","err":"","code":"Scalar::Util->VERSION\n"},{"out":"[\"??????????\"]","err":"","code":"[scalar  ('?') x 10 ] # lol?\n"},{"err":"","code":"{ scalar => ('?' x 3), list => [ ('?') x 3 ] }\n","out":"{list => [\"?\",\"?\",\"?\"],scalar => \"???\"}"},{"err":"","code":"!!\"scotsmen\"\n","out":"1"},{"out":"","code":"s///course\n","err":""},{"err":"","code":"$script = \"cats\"; \"script/\\@id=$script\"\n","out":"script/@id=cats"},{"out":"[\"foobar\"]","code":"$_ = 'sdfaosdkf!foobar!pokasdf!'; [ m/!(.+?)!/ ];\n","err":""},{"out":"1","err":"","code":"s///eeeeeeeeeeeeeee\n"},{"code":"s/^/\"-\"/ee if 0;\n","err":"","out":"0"},{"out":"ERROR: Can't locate object method \"see\" via package \"your\" (perhaps you forgot to load \"your\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"see your paste\n","err":""},{"code":"s///eieio\n","err":"","out":"1"},{"err":"","code":"s/^/-/e if 0;\n","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"out":"ERROR: Final $ should be \\$ or $name at (eval 1) line 1, within string\nsyntax error at (eval 1) line 1, near \"; s/$/$/\"\n","err":"","code":"s/$/$/$///$//e # $ in regex makes perl uneasy too\n"},{"code":"select\n","err":"","out":"\\*{'::$stdh'}"},{"code":"[select]\n","err":"","out":"[\\*{'::$stdh'}]"},{"err":"","code":"\"SELECT id, name, unidade_id, pcu, regexp_replace(barcode, '\\\\s+', '', 'g') as barcode from articles;\"\n","out":"SELECT id, name, unidade_id, pcu, regexp_replace(barcode, '\\s+', '', 'g') as barcode from articles;"},{"out":"hmm","code":"select->print(\"hmm\")\n","err":""},{"out":"[\"SELECT \\@rownum:=0\",\"SELECT \\@rownum:=0\"]","err":"","code":"[ \"SELECT \\@rownum:=0\", 'SELECT @rownum:=0' ]\n"},{"out":"","err":"","code":"\"$self\"\n"},{"out":"","code":"$self\n","err":""},{"err":"","code":"[ \"    Sender:example\\@domain.com\\n\" =~ qr/(?|from=<([^>]+)>,src=|^\\s+Sender:(.*?)$)/ ]\n","out":"[\"example\\@domain.com\"]"},{"out":"[undef,\"example\\@domain.com\"]","code":"[ \"    Sender:example\\@domain.com\\n\" =~ qr/from=<([^>]+)>,src=|^\\s+Sender:(.*?)$/ ]\n","err":""},{"err":"","code":"[ '    Sender:example@domain.com' =~ qr/from=<([^>]+)>,src=|^\\s+Sender:(.*?)$/ ]\n","out":"[undef,\"example\\@domain.com\"]"},{"out":"[undef,\"example.com\"]","code":"[ \"    Sender:example@domain.com\" =~ qr/from=<([^>]+)>,src=|^\\s+Sender:(.*?)$/ ]\n","err":""},{"code":"s***exmag\n","err":"","out":"1"},{"code":"$s = 'foo'; undef $s; $s .= 'bar';\n","err":"","out":"bar"},{"err":"","code":"sftp> ls\n","out":""},{"code":"s/(...)...)?//g\n","err":"","out":"ERROR: Unmatched ) in regex; marked by <-- HERE in m/(...)...) <-- HERE ?/ at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"s/\\+\\/g\n","out":"ERROR: Substitution pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"//","code":"\"////\" =~ s{//}{/}gr\n","err":""},{"code":"\"////\" =~ s{/+}{/}gr\n","err":"","out":"/"},{"err":"","code":"\"+-\" =~ s/[+-]/!/gr\n","out":"!!"},{"out":"shift @_","code":"shift @_\n","err":""},{"code":"shift $foo;\n","err":"","out":"ERROR: Experimental shift on scalar is now forbidden at (eval 1) line 1, at EOF\n"},{"out":"","err":"","code":"shift; # fully optimized\n"},{"out":"00_1000003","err":"","code":"\"shop_image/importer/1000003/00_1000003.jpg\" =~ /(\\d\\d_\\d{7,7})\\.jpg/; $1\n"},{"out":"[\"k2\",\"v2\"]","code":"$s=\"http://a?k1=v1&k2=v2\"; [$s=~/.*?\\?(?:([^=]+)=([^&]+)&?)+/g]\n","err":""},{"out":"[\"k1\",\"v1\",\"k2\",\"v2\"]","err":"","code":"$s = \"http://a?k1=v1&k2=v2\"; [ $s =~ /[?&]([^=]+)=([^&]+)/g ]\n"},{"err":"","code":"$SIG{CHLD}\n","out":""},{"out":"don't do this: you didn't see me, right at (eval 1) line 1, <STDIN> line 1.\n","code":"$SIG{__DIE__} = sub { print \"don't do this: @_\" }; eval { die \"you didn't see me, right\" };\n","err":""},{"code":"$SIG{__DIE__} = sub { print q(dead!)}; ...;\n","err":"","out":"dead!ERROR: Unimplemented at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","err":"","code":"$SIG{__DIE__} = sub { $|++; say 42; exit }; a bc\n"},{"out":"dead!\nERROR: Unimplemented at (eval 1) line 1, <STDIN> line 1.\n","code":"$SIG{__DIE__} = sub { say q(dead!) }; ...;\n","err":""},{"out":"2","err":"","code":"\"SIMCOP48.856934\"^2\n"},{"out":"NaN","err":"","code":"sin 9**9**9\n"},{"err":"","code":"\"size=473\" =~ s/size=\\K(\\d+)/int($1*2.5)/er\n","out":"size=1182"},{"err":"","code":"$_ = \"sj4jdj345k3dasssdf32\"; tr/0-9//cd; print $_;\n","out":"4345332"},{"code":"sleep -1\n","err":"","out":"0"},{"out":"hello","err":"","code":"sleep 5; print \"hello\"\n"},{"out":"","err":"","code":"sleep( 60 * 60 * 8 ) if $!{EINSUFFICIENTCAFFIENE}; # g'night folks.\n"},{"code":"s///mansex\n","err":"","out":"1"},{"err":"","code":"s///mulder\n","out":"ERROR: Regexp modifiers \"/u\" and \"/l\" are mutually exclusive at (eval 1) line 1, near \"; \"\nRegexp modifiers \"/u\" and \"/d\" are mutually exclusive at (eval 1) line 1, near \"; \"\n"},{"out":"yes","code":"$s = '\\\\n'; \"\\n\" =~ /$s/ ? \"yes\" : \"no\"\n","err":""},{"out":"","err":"","code":"s///nordic\n"},{"err":"","code":"snork gorble pow fwee\n","out":"ERROR: Usage: POSIX::pow(x, exponent) at (eval 1) line 1.\n"},{"out":"ERROR: Can't locate object method \"poww\" via package \"fwee\" (perhaps you forgot to load \"fwee\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"snork gorble poww fwee\n","err":""},{"out":"ERROR: can't - Bad file descriptor at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"socket(my $fh, 6, 2, 17) or die \"can't - $!\";\n"},{"out":"1","code":"'some-help-approver@example.net' =~ /(?<!^help-approver)\\@example\\.net$/\n","err":""},{"err":"","code":"\"some text [3] some more text [4] even more text\" =~ s/(?=\\[\\d+\\])/\\n/gr # or rather this, I guess\n","out":"some text \n[3] some more text \n[4] even more text"},{"code":"\"some text [3] some more text [4] even more text\" =~ s/(?=\\[)/â¤/gr # tlhiv_laptop\n","err":"","out":"some text ÃÂ¢ÃÂÃÂ¤[3] some more text ÃÂ¢ÃÂÃÂ¤[4] even more text"},{"err":"","code":"[ \"some text here\" =~ /((some) (text))/p, ${^MATCH} ] # no, preferably not $&\n","out":"[\"some text\",\"some\",\"text\",\"some text\"]"},{"err":"","code":"[ \"some text\" =~ m/o|t/ ]\n","out":"[1]"},{"code":"[ \"some text\" =~ m/o|t/g ]\n","err":"","out":"[\"o\",\"t\",\"t\"]"},{"code":"$_ = 'something123.pl'; s/\\w.*?\\K(\\d\\.pl)/0$1/; $_ # why .*-like-things may not work as you wanted\n","err":"","out":"something1203.pl"},{"out":"sprintf \"%x \", ord ssprintf \"%x \", ord osprintf \"%x \", ord msprintf \"%x \", ord esprintf \"%x \", ord tsprintf \"%x \", ord hsprintf \"%x \", ord isprintf \"%x \", ord nsprintf \"%x \", ord gsprintf \"%x \", ord  sprintf \"%x \", ord lsprintf \"%x \", ord isprintf \"%x \", ord ksprintf \"%x \", ord esprintf \"%x \", ord  sprintf \"%x \", ord tsprintf \"%x \", ord hsprintf \"%x \", ord isprintf \"%x \", ord ssprintf \"%x \", ord ?","err":"","code":"\"something like this?\" =~ s/(.)/sprintf \"%x \", ord $1/gr\n"},{"out":"73 6f 6d 65 74 68 69 6e 67 20 6c 69 6b 65 20 74 68 69 73 3f ","code":"\"something like this?\" =~ s/(.)/sprintf \"%x \", ord $1/gre\n","err":""},{"err":"","code":"$_ = \"something like this? x x\"; my $state = 0; s/(\\w)/++$state % 2 ? (uc $1) : (lc $1)/ge; $_\n","out":"SoMeThInG lIkE tHiS? x X"},{"code":"$s = \"one two three\"; %h = ( one => 1, two => 2 ); $s =~ s/$_/$h{$_}/ for keys %h; $s\n","err":"","out":"1 2 three"},{"err":"","code":"[sort { 0 } 5, 2, 3]\n","out":"[5,2,3]"},{"out":"[1,101,102,12,13,2]","err":"","code":"[sort 1, 2, 12, 13, 101, 102]\n"},{"code":"( sort ( 1..9 ));\n","err":"","out":""},{"code":"sort ( [8,6,7,4,2,3,9] )\n","err":"","out":""},{"out":"","err":"","code":"sort (8, 6, 7, 5, 2, 3, 9)\n"},{"code":"sort(99, 111)\n","err":"","out":""},{"err":"","code":"[ sort { $a->[1] cmp $b->[1] || $a->[0] <=> $b->[0] } [2, 'd'], [3, 'c'], [1, 'd'] ]\n","out":"[[3,\"c\"],[1,\"d\"],[2,\"d\"]]"},{"err":"","code":"[ sort { $a <=> $b } 1386778719, 1386778075 ]\n","out":"[1386778075,1386778719]"},{"out":"[8,3,2,1,8,0,8]","err":"","code":"[ sort { $a < $b } 2, 3, 1, 8, 0, 8, 8 ] # like, really easy\n"},{"err":"","code":"[ sort { $a <=> $b } 4, 15, 11, \"NaN\", 11, 2, 1, 4, 3, \"nan\", 8 ]\n","out":"[1,2,3,4,4,11,11,15,\"NaN\",\"nan\",8]"},{"err":"","code":"[ sort { $a <=> $b } 7, 0, \"nan\", 3 ]\n","out":"[0,7,\"nan\",3]"},{"out":"[3,7,\"nan\"]","err":"","code":"[ sort { $a <=> $b } 7, \"nan\", 3 ]\n"},{"err":"","code":"[ sort { $a <=> $b } 8, 6, 7, 5, 3, 0, 9 ] # tell sort to compare $a and $b numerically instead of as strings\n","out":"[0,3,5,6,7,8,9]"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n","err":"","code":"[sort { $a cmp $b } qw/w x/\n"},{"out":"[\"w\",\"x\"]","code":"[sort { $a cmp $b } qw/w x/]\n","err":""},{"code":"sort ( qw(8,6,7,4,2,3,9) )\n","err":"","out":""},{"err":"","code":"sort ( qw[8,6,7,4,2,3,9] )\n","out":""},{"err":"","code":"[sort qw(9 3 4 5 6 3 4 1)] #thats how it works\n","out":"[1,3,3,4,4,5,6,9]"},{"out":"[0,1,2,29,3,38,381,39,4,5,5,9]","code":"[ sort qw/ 9 39 5 38 4 5 381 29 0 1 2 3 / ]\n","err":""},{"err":"","code":"[ sort qw/a fan of w k r p in Cincinnati/ ]\n","out":"[\"Cincinnati\",\"a\",\"fan\",\"in\",\"k\",\"of\",\"p\",\"r\",\"w\"]"},{"out":"[\"Compnent\",\"Component::A\",\"Component::B\",\"Your::Mother\"]","code":"[sort qw/Compnent Component::A Component::B Your::Mother/]\n","err":""},{"out":"[\"could\",\"could\",\"could\",\"must\",\"must\",\"must\",\"should\",\"should\"]","code":"[ sort qw(must should could could must could should must) ]\n","err":""},{"out":"[\"i\",\"h\"]","code":"[ sort { return 42 } \"h\", \"i\" ]\n","err":""},{"out":"[\"hi\"]","err":"","code":"[ sort { return 42 } \"hi\" ]\n"},{"out":"[0,1,2,3,772,9]","err":"","code":"[sort &{sub {$_[0] <=> $_[1]}}, qw,1 3 2 772 9,]\n"},{"err":"","code":"('so this should match,even,though,,it,seems,very,different,from,requirements?' =~ m/\\w+,\\w+,,\\w+,\\w+/) ? 'match' : 'no match'\n","out":"match"},{"code":"so we don't get double action once perlbot is back in commission\n","err":"","out":"ERROR: Can't locate object method \"in\" via package \"commission\" (perhaps you forgot to load \"commission\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate object method \"so\" via package \"what\" (perhaps you forgot to load \"what\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"${\"so what\"} = 123; \"see? ${so what}\"\n"},{"code":"${\"so what\"} = 123; \"see? ${'so what'}. fu\"\n","err":"","out":"see? 123. fu"},{"out":"1","err":"","code":"! ! ! ! ! ! \"spaces\"\n"},{"err":"","code":"@spec = ('abcd', 1, 2); say &CORE::substr(@spec)\n","out":"bc\n"},{"code":"@spec = ('abcd', 1, 2); say substr(@spec)\n","err":"","out":"ERROR: Not enough arguments for substr at (eval 1) line 1, near \"@spec)\n\"\n"},{"err":"","code":"s/perl/python/;\n","out":""},{"out":"ERROR: Experimental splice on scalar is now forbidden at (eval 1) line 1, near \"5)\n\"\n","code":"splice((0..9),3,5)\n","err":""},{"out":"ERROR: Experimental splice on scalar is now forbidden at (eval 1) line 1, near \"5)\n\"\n","code":"splice([0..9],3,5)\n","err":""},{"out":"[\"foo\",\"bar\"]","err":"","code":"splice @a, 2, 2, qw/foo bar/; \\@a\n"},{"code":"splice @test, 2; \\@test\n","err":"","out":"[]"},{"out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"[ split /(?<!^),/, '\n","err":""},{"out":"[3,18,50,33]","code":"[ split /[^0-9]+/, \"3 day 18 hr 50 min 33 sec\" ]\n","err":""},{"code":"[ split \" \", \"1.1.1 POWER SUPPLY DEFECT\" ]\n","err":"","out":"[\"1.1.1\",\"POWER\",\"SUPPLY\",\"DEFECT\"]"},{"out":"[\"1.1.1 POWER SUPPLY DEFECT\"]","err":"","code":"[ split /\\./, \"1.1.1 POWER SUPPLY DEFECT\", 1 ]\n"},{"out":"[\"1.1.1 POWER SUPPLY DEFECT\"]","code":"[ split \" \", \"1.1.1 POWER SUPPLY DEFECT\", 1 ]\n","err":""},{"code":"[ split \" \", \"1.1.1 POWER SUPPLY DEFECT\", 2 ]  # ?\n","err":"","out":"[\"1.1.1\",\"POWER SUPPLY DEFECT\"]"},{"out":"[12,\"33.\"]","err":"","code":"[ split \"/\", \"12/33.\",2]\n"},{"out":"[12,33]","err":"","code":"[ split \"/\", \"12/33\", 2 ]\n"},{"code":"[ split \".\", \"12.33\" ]  # because this\n","err":"","out":"[]"},{"code":"[ split \" \", \"- 14:56:45,344 -\", 4 ]\n","err":"","out":"[\"-\",\"14:56:45,344\",\"-\"]"},{"out":"[\"-\",\"14:56:45,484\",\"Info\",\": Trying to load VINGCARD_VISION.dll\"]","err":"","code":"[ split \" \", \"- 14:56:45,484 Info  : Trying to load VINGCARD_VISION.dll\", 4 ]\n"},{"out":"[25,\"25.175\",\"jitter\"]","code":"[ split ' ', '25 25.175 jitter' ]\n","err":""},{"out":"0","code":"split[4]\n","err":""},{"code":"[ split /\\40/, \" a  b\\tc \", 0 ]\n","err":"","out":"[\"\",\"a\",\"\",\"b\\tc\"]"},{"code":"[split /(.{4}/, \"thisisatest\"]\n","err":"","out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/( <-- HERE .{4}/ at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"[split /(.{4})/, \"thisisatest\"]\n","err":"","out":"[\"\",\"this\",\"\",\"isat\",\"est\"]"},{"out":"[7,3,5,5,6,0,8]","code":"[ split //, 7355608 ]\n","err":""},{"code":"[ split(/aaa/, '') ]\n","err":"","out":"[]"},{"out":"[\"a\"]","code":"[ split(/aaa/, 'a') ]\n","err":""},{"err":"","code":"[ split(/aaa/, 'aaa') ]\n","out":"[]"},{"err":"","code":"[ split(/aaa/, 'aaaaa') ]\n","out":"[\"\",\"aa\"]"},{"code":"[ split /a/, 'aabcadeaa' ] # derp\n","err":"","out":"[\"\",\"\",\"bc\",\"de\"]"},{"out":"[\"\",\"b\",\"cus\"]","code":"[split(/a/, \"abacus\")]\n","err":""},{"out":"3","code":"split(/a/, \"abacus\")\n","err":""},{"code":"[split / /, 'a   b']\n","err":"","out":"[\"a\",\"\",\"\",\"b\"]"},{"out":"[\"a\",\"b\"]","code":"[split ' ', 'a   b']\n","err":""},{"out":"[\"a\",\"b\",undef,undef]","err":"","code":"[ (split /:/, \"a:b\")[0..3] ]\n"},{"code":"[ split //, \" a b c \" ]\n","err":"","out":"[\" \",\"a\",\" \",\"b\",\" \",\"c\",\" \"]"},{"err":"","code":"[split //, 'abc']\n","out":"[\"a\",\"b\",\"c\"]"},{"code":"(split /,/, \"a,b,c\")[1]\n","err":"","out":"b"},{"out":"b","code":"(split \",\", \"a,b,c\")[1]\n","err":""},{"out":"[\"a b c\"]","err":"","code":"[ split ' ', \"a b c\", 1 ]\n"},{"err":"","code":"[split /(?<=-)\\+(?=-)/, \"a+b+cc-+-d-e-f\"]\n","out":"[\"a+b+cc-\",\"-d-e-f\"]"},{"err":"","code":"[split /(?<=-)+(?=-)/, \"a+b+cc-+-d-e-f\"]\n","out":"[\"a+b+cc-+-d-e-f\"]"},{"out":"[\"ab\",\"cd\"]","code":"[split /\\./,\"ab.cd.\"]\n","err":""},{"code":"[split /\\./,\"ab.cd.\",-1]\n","err":"","out":"[\"ab\",\"cd\",\"\"]"},{"err":"","code":"[split /\\./,\"ab.cd.\",2]\n","out":"[\"ab\",\"cd.\"]"},{"out":"[\"ab\",\"cd.df.\"]","code":"[split /\\./,\"ab.cd.df.\",2]\n","err":""},{"err":"","code":"[split /\\./,\"ab.cd.df\",2]\n","out":"[\"ab\",\"cd.df\"]"},{"code":"[ split //, \"abcde\" ]\n","err":"","out":"[\"a\",\"b\",\"c\",\"d\",\"e\"]"},{"out":"5","err":"","code":"split(//, \"abcde\")\n"},{"err":"","code":"split(//, \"abcde\") . \"\"\n","out":"5"},{"out":"[\"a\",\"b\",\"c\"]","code":"[split \" \",\"a b c\\n\"]\n","err":""},{"err":"","code":"[ split \" \", \" a  b\\tc \" ]\n","out":"[\"a\",\"b\",\"c\"]"},{"out":"[\"amarok\"]","code":"[ split \" \", \"  amarok\" ]\n","err":""},{"err":"","code":"[ split ' ', \" a real split \" ]\n","out":"[\"a\",\"real\",\"split\"]"},{"out":"[\"where\\nis\\nyour\\ngod\\nnow?\"]","code":"[ split /\\A/, \"where\\nis\\nyour\\ngod\\nnow?\" ]\n","err":""},{"out":"[123,\" \",5,\" \",12,\" \",7,\" \"]","code":"[split /\\b/, \"123 5 12 7 \"]\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"/\\b/ \"123 5 12 7 \"\"\n","err":"","code":"split /\\b/ \"123 5 12 7 \"\n"},{"code":"[ split //, \"banana\" ]\n","err":"","out":"[\"b\",\"a\",\"n\",\"a\",\"n\",\"a\"]"},{"code":"[split /\\b/, \"foo_bar\"]\n","err":"","out":"[\"foo_bar\"]"},{"err":"","code":"[ split /\\D/, \"1k10k1|11dld1\" ]\n","out":"[1,10,1,11,\"\",\"\",1]"},{"out":"[1,10,1,11,1]","code":"[ split /\\D+/, \"1k10k1|11dld1\" ]\n","err":""},{"err":"","code":"[ split ' ', 'foo bar baz' ]\n","out":"[\"foo\",\"bar\",\"baz\"]"},{"err":"","code":"[split /(?<!\\\\),/, \"foo\\\\,bar,baz\"]\n","out":"[\"foo\\\\,bar\",\"baz\"]"},{"out":"[\"foo bar baz\"]","err":"","code":"[split \",\", \"foo bar baz\"]\n"},{"err":"","code":"[split \",\", \"foo, bar, baz\"]\n","out":"[\"foo\",\" bar\",\" baz\"]"},{"err":"","code":"(split /\\./, 'foo.bar.baz')[1]\n","out":"bar"},{"out":"[\"foo\",\"bar:baz\"]","code":"[ split /=|==|:|--/, \"foo:bar:baz\", 2 ]\n","err":""},{"err":"","code":"[[ split / /, \"foo     bar\" ], [ split ' ', \"foo     bar\" ]]\n","out":"[[\"foo\",\"\",\"\",\"\",\"\",\"bar\"],[\"foo\",\"bar\"]]"},{"code":"[ split / /, \" foo\\tbar  baz \" ]\n","err":"","out":"[\"\",\"foo\\tbar\",\"\",\"baz\"]"},{"out":"[\"foo\",\"bar\",\"baz\"]","code":"[ split \" \", \" foo\\tbar  baz \" ]\n","err":""},{"code":"[ split /(?<=@free.fr)/, \"example@free.frexample2@free.fr\" ] #hmm, why doesn't this keep the @free.fr part in the results?\n","err":"","out":"[\"example.fr\",\"example2.fr\"]"},{"out":"[\"example\\@free.fr\",\"example2\\@free.fr\"]","err":"","code":"[ split /(?<=@free\\.fr)/, 'example@free.frexample2@free.fr' ] #right\n"},{"out":"[\"Fri\",\"Dec\",4,\"18:54:59\",\"EST\",2015]","code":"[split \" \", \"Fri Dec  4 18:54:59 EST 2015\"]\n","err":""},{"err":"","code":"[ split //, \"FÂ­uÂ­dge\" ]\n","out":"[\"F\",\"\\302\",\"\\255\",\"u\",\"\\302\",\"\\255\",\"d\",\"g\",\"e\"]"},{"code":"[split//,\"Hello\"]\n","err":"","out":"[\"H\",\"e\",\"l\",\"l\",\"o\"]"},{"err":"","code":"[ split '.', 'horsey.surprise' ]\n","out":"[]"},{"err":"","code":"[ split '\\\\.', 'horsey.surprise' ]\n","out":"[\"horsey\",\"surprise\"]"},{"code":"[ split /[&=]/, \"http://a?k1=v1&k2=v2\" ]\n","err":"","out":"[\"http://a?k1\",\"v1\",\"k2\",\"v2\"]"},{"err":"","code":"[ split m{/}, \"12/33.\" ]\n","out":"[12,\"33.\"]"},{"code":"[ split /^/m, \"hello\\nworld\" ]\n","err":"","out":"[\"hello\\n\",\"world\"]"},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"[ split m!/|\\.html!, \"dirs/123/abc.def/ghi999.html ]\n"},{"code":"[ split m!/|\\.html!, \"dirs/123/abc.def/ghi999.html\" ]\n","err":"","out":"[\"dirs\",123,\"abc.def\",\"ghi999\"]"},{"out":"[\"\",\"just\",\"a\",\"demo\"]","err":"","code":"[ split m{/}, '/just/a/demo/' ]\n"},{"err":"","code":"[ split ',', 'money.perl.com,money.python.com,money.nei.com' ]\n","out":"[\"money.perl.com\",\"money.python.com\",\"money.nei.com\"]"},{"out":"[\",one\",\"two\",\"three\"]","code":"[ split /(?<!^),/, ',one,two,three' ]\n","err":""},{"err":"","code":"[split //, \"perl\"]\n","out":"[\"p\",\"e\",\"r\",\"l\"]"},{"out":"[\"example\\@free.fr\",\"example2\\@free.fr\"]","err":"","code":"[ split qr'(?<=@free\\.fr)', 'example@free.frexample2@free.fr' ] #look ma! no han^Wescapes! (except that . one)\n"},{"code":"[ split qr{[\\[\\]=]+}, \"something[a=b][c=d][e=f]\" ]\n","err":"","out":"[\"something\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]"},{"code":"[split('\\Qx+', \"abxxcdex+fg\")]\n","err":"","out":"[\"abxxcdex+fg\"]"},{"out":"[\"abxxcde\",\"fg\"]","err":"","code":"[split(\"\\Qx+\", \"abxxcdex+fg\")]\n"},{"err":"","code":"[split /\\s+/, \" \"]\n","out":"[]"},{"err":"","code":"[split /\\s+/, \" \", -1]\n","out":"[\"\",\"\"]"},{"err":"","code":"[split /\\s+/, \"a \", -1]\n","out":"[\"a\",\"\"]"},{"out":"[\"a\",\"\",\"\",\"\",\"\",\"b\"]","err":"","code":"[ split /\\s/, \"a     b\" ]\n"},{"code":"[split /\\s+/, \" a\"] # but this one doesn't need the limit\n","err":"","out":"[\"\",\"a\"]"},{"out":"[\"\",\"amarok\"]","code":"[ split /\\s+/, \"  amarok\" ]\n","err":""},{"code":"[ split \"\\s+\", \"  amarok\" ]\n","err":"","out":"[\"  amarok\"]"},{"code":"[ split /\\s+/, \" a real split \", -1 ]\n","err":"","out":"[\"\",\"a\",\"real\",\"split\",\"\"]"},{"out":"[\"foo\",\"baz\"]","code":"[ split /[@\\s]/, \"foo@bar baz\" ]\n","err":""},{"code":"[ split /[\\@\\s]/, 'foo@bar baz' ]\n","err":"","out":"[\"foo\",\"bar\",\"baz\"]"},{"err":"","code":"[ split /[\\@\\s]/, \"foo@bar baz\" ]\n","out":"[\"foo\",\"baz\"]"},{"err":"","code":"[ split /[\\@\\s]/, \"foo\\@bar baz\" ]\n","out":"[\"foo\",\"bar\",\"baz\"]"},{"err":"","code":"[split /(,\\s*)/, \"foo, bar, baz\"]\n","out":"[\"foo\",\", \",\"bar\",\", \",\"baz\"]"},{"out":"5","err":"","code":"split /(,\\s*)/, \"foo, bar, baz\"\n"},{"code":"[ split /\\s+/, grep /x/, qw(abc def kzx lol) ]\n","err":"","out":"[1]"},{"out":"australia","code":"(split /-/, (split /\\//, \"http://www.site.com/letters0241/something-in-australia-a-h\")[-1])[2]\n","err":""},{"out":"[1,0,1,0,0]","code":"[split //, sprintf \"%b\", 20]\n","err":""},{"out":"[\"Knark\",\". \",\"knark\",\",\"]","err":"","code":"[ split /([\\s[:punct:]]+)/, \"Knark. knark,\" ]\n"},{"out":"[\"Knark\",\".\",\"\",\" \",\"knark\",\",\"]","err":"","code":"[ split /(\\s+|[[:punct:]])/, \"Knark. knark,\" ] # or ask perlbot\n"},{"err":"","code":"[split /\\s*=\\s*/, 'name=val=ue', 2]\n","out":"[\"name\",\"val=ue\"]"},{"code":"[ split(/\\s+/, 'split th\\is line') ]\n","err":"","out":"[\"split\",\"th\\\\is\",\"line\"]"},{"err":"","code":"[ split /\\s+/, \" word \" ]\n","out":"[\"\",\"word\"]"},{"out":"[]","err":"","code":"[split /\\t/, \"\"]\n"},{"out":"[\"\\\\\",\"t\"]","code":"[split '', '\\t']\n","err":""},{"out":"[\"\\t\"]","code":"[split '', \"\\t\"]\n","err":""},{"code":"[ split /=/, \"test='string=ignore this symbol'\", 2 ] # presumably you want key + value\n","err":"","out":"[\"test\",\"'string=ignore this symbol'\"]"},{"err":"","code":"[ split /(?<!\\\\);/, \"this;is; a test; with\\\\; escaped delimiters;;\" ]\n","out":"[\"this\",\"is\",\" a test\",\" with\\\\; escaped delimiters\"]"},{"out":"[\"this\",\"is\",\" a test\",\" with\\\\\\\\; escaped delimiters\"]","err":"","code":"[split /(?<!\\\\);/, 'this;is; a test; with\\\\\\; escaped delimiters;;']\n"},{"out":"[\"sajkhsdahkj\"]","code":"[split /\\t/, \"sajkhsdahkj\"]\n","err":""},{"out":"[\"a\",\".\",\"b\",\"!\",\"c\",\"?\",\"d\",\" \",\"e\"]","err":"","code":"[split /(\\W)/, \"a.b!c?d e\"]\n"},{"out":"[\"\",\"foo\"]","err":"","code":"[ split /\\W+/, \"(foo)\" ]\n"},{"out":"[\"foo\",\" \",\"bar\",\".\",\"baz\",\" \",\"quux\",\"?\",\"derp\",\" \",\"ermintrude\"]","code":"[split /(\\W)/, \"foo bar.baz quux?derp ermintrude\"]\n","err":""},{"code":"[ split \" \", \"what are you on about\", 2 ] # wodim?\n","err":"","out":"[\"what\",\"are you on about\"]"},{"code":"[ split /,/, 'where,is,\"your,god\",now' ]\n","err":"","out":"[\"where\",\"is\",\"\\\"your\",\"god\\\"\",\"now\"]"},{"code":"[ split \",\", \"worker1,\" ]\n","err":"","out":"[\"worker1\"]"},{"err":"","code":"[ split \",\", \"worker1,\", -1 ]\n","out":"[\"worker1\",\"\"]"},{"out":"[\"\",\"x\",\"\"]","code":"[ split /,/, ',x,', -1 ]\n","err":""},{"out":"[\"ab\",\"cde\",\"+fg\"]","code":"[split('x+', \"abxxcdex+fg\")]\n","err":""},{"out":"[\"a\",\"b\"]","code":"[split /x/, 'axb', 'yxz']\n","err":""},{"out":"0000000000ff","code":"sprintf '%012x', 0xff\n","err":""},{"out":"00000000ffff","err":"","code":"sprintf '%012x', 0xffff\n"},{"out":"09","err":"","code":"sprintf('%02d', 9)\n"},{"out":"c0ff3f","code":"sprintf('%02x%02x%02x', 192, 255, 63)\n","err":""},{"code":"sprintf \"%*02X\", \" \", \"bar\"\n","err":"","out":"%*02X"},{"code":"sprintf \"%02*X\", \" \", \"bar\"\n","err":"","out":"%02*X"},{"code":"sprintf(\".%03u\", 85)\n","err":"","out":".085"},{"err":"","code":"sprintf(\".%03u\", 850)\n","out":".850"},{"out":".8500","err":"","code":"sprintf(\".%03u\", 8500)\n"},{"err":"","code":"sprintf '%04d', 1\n","out":"0001"},{"code":"[ sprintf \"%04o\", 0755 ]\n","err":"","out":"[\"0755\"]"},{"code":"sprintf '%04o', 0777\n","err":"","out":"0777"},{"out":"dead","err":"","code":"sprintf '%04x', hex 'dead'\n"},{"err":"","code":"sprintf '%05.2f', 5/3\n","out":"01.67"},{"out":"00009","code":"sprintf('%0.5d',9)\n","err":""},{"code":"sprintf('%0.5f', 7.15255737304688e-06)\n","err":"","out":"0.00001"},{"code":"sprintf \"%08b\", 1 | 15\n","err":"","out":"00001111"},{"out":"114","code":"sprintf '%.0f', 1.139999999999999 * 100\n","err":""},{"out":"3","err":"","code":"sprintf \"%.0f\", 2.6\n"},{"code":"sprintf \"%.0f\", 6 * 99.90 * 100\n","err":"","out":"59940"},{"err":"","code":"sprintf'%.0f',log(~0)/log(2)\n","out":"64"},{"out":"0.000000","err":"","code":"sprintf '%' . 0xfffffff . '$f'\n"},{"err":"","code":"sprintf \"[%-10d]\", 123\n","out":"[123       ]"},{"code":"sprintf \"%.10f\", 942993 / 1236732346368\n","err":"","out":"0.0000007625"},{"code":"sprintf \"%.10f%% ram used\", 942993 / 1236732346368 * 100\n","err":"","out":"0.0000762488% ram used"},{"out":"       599.4","err":"","code":"sprintf(\"%12.6g\", 6 * 99.90)\n"},{"err":"","code":"[ sprintf '%.14f', '1.43531262539073e-11' ] # or sprintf, if you want to do something other than display the result\n","out":"[\"0.00000000001435\"]"},{"code":"sprintf \"%.15f\", 942993 / 1236732346368\n","err":"","out":"0.000000762487536"},{"out":"9","err":"","code":"sprintf('%1d',9)\n"},{"code":"sprintf \"%.20f %.20f\", 0.1, 0.3\n","err":"","out":"0.10000000000000000555 0.29999999999999998890"},{"out":"599.40000000000009094947","err":"","code":"sprintf \"%.20f\", 6 * 99.90\n"},{"code":"sprintf \"%2.2e\", 1234.567\n","err":"","out":"1.23e+03"},{"out":"[\"0.0000000000143531262539072984\"]","err":"","code":"[ sprintf '%.28f', '1.43531262539073e-11' ]\n"},{"code":"[sprintf \"%.2f\", 3/4]\n","err":"","out":"[\"0.75\"]"},{"out":"second then first","err":"","code":"sprintf '%2$s then %1$s', 'first', 'second';\n"},{"code":"sprintf \"%.30f\", \"134.95\"\n","err":"","out":"134.949999999999988631316227838397"},{"out":"134.949999999999988631316227838397","err":"","code":"sprintf \"%.30f\", 134.95\n"},{"err":"","code":"sprintf \"%.30f\", \"134.95\" * 100\n","out":"13494.999999999998181010596454143524"},{"code":"sprintf \"%.30f\", 134.95 * 100\n","err":"","out":"13494.999999999998181010596454143524"},{"out":"0.000","code":"sprintf \"%.3f\", ((10/1*225)/(18))-125\n","err":""},{"err":"","code":"sprintf \"%.3f\", 2.34525\n","out":"2.345"},{"err":"","code":"[ sprintf \"%4o\", 0644 ]\n","out":"[\" 644\"]"},{"err":"","code":"sprintf('%5s', 'corn flakes');\n","out":"corn flakes"},{"out":"0.3333333333333333148296162562473909929394721984863281250000000000000000","err":"","code":"sprintf \"%.70f\", 1/3\n"},{"code":"sprintf \"%8b\", 1 | 15\n","err":"","out":"    1111"},{"out":"[\"1.000000\",\"15.000000\"]","code":"[  (sprintf \"%8f\", 1) , (sprintf \"%8f\", 15) ]\n","err":""},{"out":"0","err":"","code":"sprintf \"%b\", 0.1\n"},{"out":"0","err":"","code":"sprintf \"%b\", 0.21875\n"},{"code":"sprintf \"%b\", 0376\n","err":"","out":"11111110"},{"code":"sprintf \"%b\", 1 | 15\n","err":"","out":"1111"},{"out":"100101101010110010001","code":"sprintf \"%b\", 1234321\n","err":""},{"err":"","code":"sprintf \"%b\", 152944\n","out":"100101010101110000"},{"err":"","code":"sprintf \"%b\", 21845\n","out":"101010101010101"},{"err":"","code":"sprintf \"%b\", 341\n","out":"101010101"},{"err":"","code":"sprintf '%b', 50\n","out":"110010"},{"out":"1010010","code":"sprintf '%b', 82\n","err":""},{"out":"10101000100000001","err":"","code":"sprintf \"%b\", 86273\n"},{"err":"","code":"sprintf \"%b\", 87381\n","out":"10101010101010101"},{"code":"sprintf \"%b\", 96\n","err":"","out":"1100000"},{"code":"sprintf '%b', 96000\n","err":"","out":"10111011100000000"},{"out":"[\"100000000000 & 11111111 -> 0\"]","err":"","code":"[ sprintf \"%b & %b -> %b\", 2048, 0xFF, 2048 & 0xFF ]\n"},{"out":"0.1","err":"","code":"sprintf \"%b.%b\", split /\\./, 0.1\n"},{"out":"0.101010101110011","err":"","code":"sprintf \"%b.%b\", split /\\./, 0.21875\n"},{"out":"[\"A\"]","err":"","code":"[sprintf\"%c\", 65]\n"},{"code":"[sprintf\"%c\", 'a']\n","err":"","out":"[\"\\0\"]"},{"err":"","code":"sprintf \"%c%c%c\", map ord,(97,98,99)\n","out":"999"},{"out":"abc","code":"sprintf \"%c%c%c\", map ord,('a','b','c')\n","err":""},{"err":"","code":"sprintf '%d', -0.5\n","out":"0"},{"code":"sprintf \"%,d\", 12345678;\n","err":"","out":"%,d"},{"out":"1","code":"sprintf '%d', 1.7\n","err":""},{"code":"sprintf(\"%d\", 2.6)\n","err":"","out":"2"},{"out":"1 2","code":"sprintf \"%d %s\", 1, 2\n","err":""},{"code":"sprintf '%.f', 0.49999999999999994\n","err":"","out":"0"},{"out":"2.0","code":"sprintf '%.*f', 1, 2\n","err":""},{"code":"sprintf '%*f', '.1', 2\n","err":"","out":"2.000000"},{"code":"sprintf '%.f', 134.95 * 100\n","err":"","out":"13495"},{"out":"2","err":"","code":"sprintf '%.f', 1.7\n"},{"code":"sprintf '%.*f', length('9999999999999911'), 0.9999999999999911\n","err":"","out":"0.9999999999999912"},{"out":"1341015082000","err":"","code":"sprintf '%lu', 1341015082000\n"},{"out":"0","err":"","code":"sprintf \"%#o\", 0\n"},{"err":"","code":"[sprintf '%o', '16877']\n","out":"[40755]"},{"err":"","code":"sprintf \"%#o\", 2\n","out":"02"},{"code":"sprintf \"%o\", 272\n","err":"","out":"420"},{"out":"444","code":"sprintf \"%o\", 292\n","err":""},{"out":"47","code":"sprintf \"%o\", 39\n","err":""},{"out":"[00x0000] ","err":"","code":"sprintf(         q{[%02dx%02d}. ($3 ? q{-} : q{}). q{%02d] %s},          $1, $2, ($3 // q{}), $4      )\n"},{"code":"sprintf q{%03d.%d}, split /\\./, 1.2345; # leobut\n","err":"","out":"001.2345"},{"out":"2048.000","err":"","code":"sprintf q{%.3f}, 2047.99999952316 ### Is there a way to do this but truncate instead of rounding, so the result is 2047.999 instead of 2048.000 ?\n"},{"code":"sprintf q{%.3f}, (int (2047.99999952316 * 1000))/1000;\n","err":"","out":"2047.999"},{"code":"sprintf $_ = q{eval: sprintf $_ = q{%s}, $_}, $_\n","err":"","out":"eval: sprintf $_ = q{eval: sprintf $_ = q{%s}, $_}, $_"},{"out":"the cluster is using 0.0000762488% of available ram","code":"sprintf \"the cluster is using %.10f%% of available ram\", 942993 / 1236732346368 * 100\n","err":""},{"code":"sprintf \"the cluster is using %.10f%% of available ram\", (942993 * 2**20) / 1236732346368 * 100\n","err":"","out":"the cluster is using 79.9526130995% of available ram"},{"err":"","code":"sprintf \"%*v02X\", \" \", \"bar\"\n","out":"62 61 72"},{"err":"","code":"sprintf \"%v*02X\", \" \", \"bar\"\n","out":"%v*02X"},{"code":"sprintf \"%*v02x\", \" \", Encode::encode_utf8(\"much \\x{2665}\")\n","err":"","out":"6d 75 63 68 20 e2 99 a5"},{"out":"68.65.6C.6C.6F","err":"","code":"sprintf \"%v02X\", \"hello\"\n"},{"err":"","code":"(sprintf \"%v02X\", \"hello\") =~ s/\\./ /g\n","out":"ERROR: Can't modify constant item in substitution (s///) at (eval 1) line 1, at EOF\n"},{"err":"","code":"(sprintf \"%v02X\", \"hello\") =~ s/\\./ /gr\n","out":"68 65 6C 6C 6F"},{"out":"89 50 4e 47 0d 0a 1a 0a","code":"sprintf \"%*v02x\", \" \", pack \"C*\", qw|137 80 78 71 13 10 26 10|\n","err":""},{"err":"","code":"sprintf \"%v02x\", pack \"N\", 945\n","out":"00.00.03.b1"},{"out":"b1.03.00.00","err":"","code":"sprintf \"%v02x\", pack \"V\", 945\n"},{"out":"0068U+0065U+006CU+006CU+006F","err":"","code":"sprintf \"%*v04X\", \"U+\", \"hello\"\n"},{"out":"1100110.1101111.1101111","err":"","code":"sprintf '%vb', 'foo' # something like this, majuscule?\n"},{"out":"101","code":"sprintf '%vb', \"\\x05\" # binary string, then?\n","err":""},{"out":"80.72.0","err":"","code":"sprintf \"%vd\", \"123\" ^ \"az3\"\n"},{"code":"sprintf \"%vd\", \"3\" ^ \"3\"\n","err":"","out":"0"},{"err":"","code":"sprintf \"%vd\", 'a'\n","out":"97"},{"out":"%,vd","err":"","code":"sprintf \"%,vd\", 'abc'\n"},{"out":"97,98,99","err":"","code":"sprintf \"%*vd\", ',', 'abc'\n"},{"out":"97.98.99","code":"sprintf \"%vd\", 'abc'\n","err":""},{"code":"sprintf \"%vd\", \"foo\\n\\rbar\"\n","err":"","out":"102.111.111.10.13.98.97.114"},{"code":"sprintf \"%vd\", \"something\" ^ \"otherthing\"  # or this...\n","err":"","out":"28.27.5.0.6.28.1.7.9.103"},{"code":"sprintf '%vd', \"string\"\n","err":"","out":"115.116.114.105.110.103"},{"code":"sprintf('%v', v1.2.3)\n","err":"","out":"%v"},{"out":"[0]","code":"[ sprintf \"%x\", 127.0.0.1 ]\n","err":""},{"err":"","code":"sprintf \"%x\", 14644\n","out":"3934"},{"err":"","code":"sprintf '%x', 18*256+44;\n","out":"122c"},{"err":"","code":"sprintf \"%x\", 18446744073709551615\n","out":"ffffffffffffffff"},{"err":"","code":"sprintf '%x', 3 * 256 + 17\n","out":"311"},{"out":"2c12","code":"sprintf '%x', 44*256+18;\n","err":""},{"code":"sprintf \"%x\", 5 * 60 * 10e6\n","err":"","out":"b2d05e00"},{"err":"","code":"sprintf \"%x\", 65280\n","out":"ff00"},{"out":"63c","err":"","code":"sprintf \"%x\", oct \"0b011000111100\"\n"},{"code":"sprintf \"%X\", oct \"0b011000111100\"\n","err":"","out":"63C"},{"code":"sprintf '%x', ord '*';\n","err":"","out":"2a"},{"out":"30","err":"","code":"sprintf \"%x\", ord '0'\n"},{"err":"","code":"sprintf '%x', ord 'c'\n","out":"63"},{"code":"sprintf '%x', ord 'C'\n","err":"","out":"43"},{"err":"","code":"sprintf \"%x\", ord \"\\n\"\n","out":"a"},{"err":"","code":"sprintf \"%x\", ord \"\\x{1234}\"\n","out":"1234"},{"out":"[0]","code":"[ sprintf \"%x\", v127.0.0.1 ]\n","err":""},{"out":"d a","err":"","code":"sprintf \"%x %x\", 015, 012\n"},{"out":"d83d de07","err":"","code":"sprintf \"%x %x\", 55357, 56839\n"},{"code":"sprint \"%x\", ord '0'\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"sprint \"%x\"\"\n"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","err":"","code":"$sql =~ s/constraint \\K`(\\w+)`/$1/gi; maybe?\n"},{"err":"","code":"\"(s)\" =~ qr'\\Q(s)'\n","out":""},{"out":"Match","err":"","code":"$s = quotemeta('*');  \"a*b*c\" =~ /$s/ ? \"Match\" : \"No match\"\n"},{"code":"'!' =~ s/~//r\n","err":"","out":"!"},{"code":"'!' =~ s/!//r\n","err":"","out":""},{"out":"a,b,c,,,","code":"@src=qw(a b c); @dst=grep defined, @src[2..5]; print join(\",\", @src);\n","err":""},{"code":"@src=qw(a b c); @dst=@src[2..5]; print join(\",\", @dst);\n","err":"","out":"c,,,"},{"err":"","code":"@src=qw(a b c); @w=grep defined, @{ [@src[2..5]] }; print join(\",\", @src); #rmah, how about this?\n","out":"a,b,c"},{"out":"a,b,c","err":"","code":"@src=qw(a b c); @w=@src[2..5]; print join(\",\", @src);\n"},{"err":"","code":"s///regexp\n","out":""},{"code":"sretrun\n","err":"","out":"sretrun"},{"code":"sretrun join(',', @accounts);\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"sretrun join\"\n"},{"code":"sreturn join(',', @accounts);\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"sreturn join\"\n"},{"code":"['Ã']\n","err":"","out":"[\"\\303\\237\"]"},{"out":"ERROR: Regexp modifiers \"/u\" and \"/l\" are mutually exclusive at (eval 1) line 1, near \"; \"\nRegexp modifiers \"/u\" and \"/l\" are mutually exclusive at (eval 1) line 1, near \"; \"\nUnknown regexp modifier \"/y\" at (eval 1) line 1, near \"; \"\n","err":"","code":"s///scully\n"},{"out":"False","code":"'Ã' =~ m/^\\Qss\\E\\z/i ? 'True' : 'False';\n","err":""},{"out":"[\"False\"]","code":"[ 'Ã' =~ m/^\\Qss\\E\\z/i ? 'True' : 'False' ];\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"q{})\"\n","code":"s/ / sprintf(         q{[%02dx%02d}. ($3 ? q{-} : q{}). q{%02d] %s},          $1, $2, ($3 // q{}), $4      )  /ex;\n","err":""},{"err":"","code":"'Ã' =~ /\\Ã{UpperCase}/\n","out":""},{"code":"s/(?<!STYLESY0B\\$\\$)\\b$k\\b/<span class=\"kw1\">$k<\\/span>/igs;\n","err":"","out":"ERROR: Variable length lookbehind not implemented in regex m/(?<!STYLESY0B\\$\\$)\\b\\b/ at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"s///supernice\n","out":""},{"out":"ERROR: Regexp modifiers \"/u\" and \"/a\" are mutually exclusive at (eval 1) line 1, near \"; \"\n","code":"s///susanne\n","err":""},{"err":"","code":"s///susi\n","out":"1"},{"out":"catsoverflow","code":"$_ = \"stackoverflow\"; $_ = reverse for substr $_, 0, 5; s/.//r\n","err":""},{"out":"catsoverflow","code":"$_ = \"stackoverflow\"; substr($_,0,5,substr(reverse(substr$_,0,5),1,4)); $_\n","err":""},{"err":"","code":"$_ = \"stackoverflow\"; substr($_,0,5,substr(~~reverse(substr($_,0,5)),1,4)); $_  # fixed\n","out":"catsoverflow"},{"err":"","code":"state $x = 4; $x\n","out":"4"},{"code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?=.*(?!STDERR output success))/ ? 'y' : 'n'\n","err":"","out":"y"},{"out":"y","err":"","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?!.*STDERR output success)/ ? 'y' : 'n'\n"},{"code":"<stdin>\n","err":"","out":""},{"err":"","code":"STDIN\n","out":"STDIN"},{"out":"[*::STDIN]","err":"","code":"[*STDIN]\n"},{"out":"bless( , 'IO::File' )","code":"*STDIN{IO}\n","err":"cannot handle ref type 15 at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/x86_64-linux/Data/Dumper.pm line 233, <STDIN> line 1.\n"},{"out":"0","code":"STDOUT->autoflush(1)\n","err":""},{"err":"cannot handle ref type 15 at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/x86_64-linux/Data/Dumper.pm line 233, <STDIN> line 1.\n","code":"[ *STDOUT{IO} ]\n","out":"[bless( , 'IO::File' )]"},{"err":"","code":"*{ *STDOUT{IO} }\n","out":"*__ANON__::__ANONIO__"},{"out":"IO::File=IO(0x217efb8)","code":"'' . *{ *STDOUT{IO} }{IO}\n","err":""},{"out":"bless( , 'IO::File' )","err":"cannot handle ref type 15 at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/x86_64-linux/Data/Dumper.pm line 233, <STDIN> line 1.\n","code":"*{ *STDOUT{IO} }{IO}\n"},{"code":"[ ''.*STDOUT{IO}, '' . *{ *STDOUT{IO} }{IO} ]\n","err":"","out":"[\"IO::File=IO(0x1adefb8)\",\"IO::File=IO(0x1adefb8)\"]"},{"err":"","code":"STDOUT->print(\"oh no, entire classes\")\n","out":"oh no, entire classes1"},{"out":"ERROR: Variable length lookbehind not implemented in regex m/(?<!ST)/ at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"/(?<!ST)/i\n"},{"err":"","code":"Storable::store \"hallo\"\n","out":"ERROR: not a reference at (eval 1) line 1.\n"},{"code":"$str = '00 00 1c 00'; $num = unpack(\"V\", pack(\"(H2)4\", split / /, $str)); [ $num ]\n","err":"","out":"[1835008]"},{"out":"[1835008]","err":"","code":"$str = '00 00 1c 00'; $num = unpack(\"V\", pack(\"H8\", $str =~ tr/ //dr)); [ $num ]\n"},{"err":"","code":"$str = '00 00 1c 00'; $str = join '', reverse split ' ', $str; $num = hex $str; [ $num ]\n","out":"[1835008]"},{"err":"","code":"$str = '00 00 1c 00'; $str =~ tr/ //d; $num = hex $str; [ $num ]\n","out":"[7168]"},{"out":"00 11 22 33 44 55","code":"$str = '001122334455'; @m = ($str =~ m/(\\d{2})/g); \"@m\"\n","err":""},{"err":"","code":"$str = '00 1c 00 00'; $str =~ tr/ //d; $num = hex $str; [ $num ]\n","out":"[1835008]"},{"out":"00110001","code":"$str = 0b10000000 ^ 0b00000100; print unpack q/B8/, $str;\n","err":""},{"out":"10000100","err":"","code":"$str = 0b10000000 ^ 0b00000100; sprintf \"%b\", $str\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"$str2(\"\n","code":"$str1=\"1\"; $str2=\"2\"; print ($str1,$str2(; print ($str1.$str2);\n","err":""},{"out":"1212","err":"","code":"$str1=\"1\"; $str2=\"2\"; print ($str1,$str2); print ($str1.$str2);\n"},{"out":"1212","err":"","code":"$str1=\"1\"; $str2=\"2\"; print $str1,$str2; print $str1.$str2;\n"},{"code":"$str = \"123456\"; for($i = 0; $i < length($str)-1; $i+=2) { (substr($str, $i, 1), substr($str, $i+1, 1)) = (substr($str, $i+1, 1), substr($str, $i, 1)); } $str;\n","err":"","out":"214365"},{"err":"","code":"$str = \"123456\"; $str += 90909\n","out":"214365"},{"err":"","code":"$str = \"123456\"; $str += join $., (3 * 3) x 3\n","out":"215375"},{"code":"$str='123abc'; $str =~ +'xyz'; print $str;\n","err":"","out":"123abc"},{"out":"[\"|1\",\"|1|2a\",\"|1|2a|3abc\",\"|1|2a|3abc|4abcd\",\"|1|2a|3abc|4abcd|5abcde\"]","err":"","code":"$str = '|1|2a|3abc|4abcd|5abcde'; [ map { $str =~ /((?:\\|[^\\|]*){$_})/  } 1..5 ]\n"},{"code":"$str=\"1a2s\"; ($s1, $s3)=$str=~m/\\d\\w/g;  print $s1.\"\\n\"; ($s2)=$str=~m//g;  print $s2.\"\\n\".$s3;\n","err":"","out":"1a\n1a\n2s"},{"out":"1a\n1a\n","err":"","code":"$str=\"1a2s\"; ($s1)=$str=~m/\\d\\w/g;  print $s1.\"\\n\"; ($s2)=$str=~m//g;  print $s2.\"\\n\";\n"},{"out":"1a\n2s\n","err":"","code":"$str=\"1a2s\"; $str=~m/(\\d\\w)/g; $s1=$1; print $s1.\"\\n\"; $str=~m//g; $s2=$1; print $s2.\"\\n\";\n"},{"out":"ab","code":"$str1=\"a\"; $str2=\"b\"; print $str1=>$str2;\n","err":""},{"code":"$str1 = 'foobar'; $str2 = 'foobiz'; ($str1 ^ $str2) =~ /(^\\0*)/; length $1\n","err":"","out":"4"},{"out":"2","err":"","code":"$str1 = 'foÃ¶bar'; $str2 = 'foobiz'; ($str1 ^ $str2) =~ /(^\\0*)/; length $1\n"},{"err":"","code":"$str1 = 'foÃ¶bar'; $str2 = 'foÃ¶biz'; ($str1 ^ $str2) =~ /(^\\0*)/; length $1\n","out":"5"},{"out":"6","err":"","code":"$str1 = 'foÃ¶obar'; $str2 = 'foÃ¶obiz'; ($str1 ^ $str2) =~ /(^\\0*)/; length $1\n"},{"err":"","code":"$str1 = 'foÃ¶obar'; $str2 = 'foÃ¶'; ($str1 ^ $str2) =~ /(^\\0*)/; length $1\n","out":"4"},{"code":"$str1=\"one\"; $str2=\"two\"; print ($str1,$str1.$str2);\n","err":"","out":"oneonetwo"},{"out":"twooneonetwo","err":"","code":"$str1=\"one\"; $str2=\"two\"; print ($str2.$str1,$str1.$str2);\n"},{"out":"0.333","err":"","code":"$str=1; printf (\"%.3f\", $str/3);\n"},{"out":"a a x a a a","err":"","code":"$str = 'a a a a a a'; /a/g for ($str) x 3; $str =~ s/a\\G/x/; $str\n"},{"out":"baaaa","code":"$str = 'aaaaa'; $str =~ /a/gc for 1,2,3; $str =~ s/a/b/c; $str\n","err":""},{"out":"aaaba","err":"","code":"$str = 'aaaaa'; $str =~ /a/g for 1 .. 3; $str =~ s/\\Ga/b/; $str\n"},{"err":"","code":"$str='abc123'; map { s/abc/xyz/g; print } $str;\n","out":"xyz123"},{"code":"$str = \"abcdef\"; for($i = 0; $i < length($str)-1; $i+=2) { (substr($str, $i, 1), substr($str, $i+1, 1)) = (substr($str, $i+1, 1), substr($str, $i, 1)); } $str;\n","err":"","out":"badcfe"},{"out":"abcdefghijklm","err":"","code":"$str=\"abcdefghijklmnopqrstuvwxyz\"; $str=~s/(?<=.{13}).*//; print $str;\n"},{"out":"\"abc\"\n","code":"$str=\"abcXYZ 123 pdq\"; $str=~s/(?<=.{3}).*//; print \"\\\"$str\\\"\\n\"\n","err":""},{"out":"ARRAY","code":"$str = [\"a\"..\"m\"]; print ref $str\n","err":""},{"out":"1","err":"","code":"$str.='a'..'m'; print ref $str;\n"},{"out":"1","err":"","code":"$str = 'a'..'m'; print $str;\n"},{"out":"abcdefghijklm","err":"","code":"$str = [\"a\"..\"m\"]; print @$str\n"},{"out":"1","code":"$str.='a'..'m'; print $str;\n","err":""},{"out":"1","code":"$str = 'barfoo'; $str =~ /(?(?{$_=index($str,'foo');$_>0})foo|(*FAIL))/ or 1;\n","err":""},{"out":"bleh","code":"$str=\"bleh\"; $str=~s/(?:test)/$1/; print $str;\n","err":""},{"code":"$str=\"bleh\"; $str=~s/(?test)/$1/; print $str;\n","err":"","out":"ERROR: Sequence (?t...) not recognized in regex; marked by <-- HERE in m/(?t <-- HERE est)/ at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"$str=\"blehtest\"; $str=~s/(?:bleh)/$1/; print $str;\n","out":"test"},{"err":"","code":"$str=\"blehtest\"; $str=~s/(?:test)/$1/; print $str;\n","out":"bleh"},{"out":"[\" b\",\" z\"]","err":"","code":"$str = \"foo a b = z\"; @a = $str =~ m/( \\w)+/g; \\@a\n"},{"code":"$str = '   foo'; $str =~ s/\\A\\s+//; \"[$str]\";\n","err":"","out":"[foo]"},{"out":"foo","code":"$str = '   foo'; $str =~ s/\\A\\s+//; $str;\n","err":""},{"out":"t","err":"","code":"$str=\"ft\\n\"; chomp $str; $str =~ /ft$/ ? 't' : 'f'\n"},{"err":"","code":"$str=\"ft\\n\"; $str =~ /ft\\b/ ? 't' : 'f'\n","out":"t"},{"err":"","code":"$str=\"ft\\n\"; $str =~ /ft$/ ? 't' : 'f'\n","out":"t"},{"out":"f","code":"$str=\"ft\\n\"; $str =~ /ft\\z/ ? 't' : 'f'\n","err":""},{"code":"$str = \"/hallo/\"; qr{blabla $str xxx}\n","err":"","out":"qr/blabla \\/hallo\\/ xxx/u"},{"out":"Hey .140 .568 0kg 0 0 Hey","err":"","code":"$str = \"Hey $1.140 $20.568 16.9kg 12.3 2342342.9 Hey\"; $str =~ s/(\\d+\\.\\d+)/sprintf(\"%0.f\")/eg; print $str;\n"},{"out":"Hey .140 .568 sprintf(\"%0.f\")kg sprintf(\"%0.f\") sprintf(\"%0.f\") Hey","err":"","code":"$str = \"Hey $1.140 $20.568 16.9kg 12.3 2342342.9 Hey\"; $str =~ s/(\\d+\\.\\d+)/sprintf(\"%0.f\")/g; print $str;\n"},{"out":"Hey .140 .568 17kg 12 2342343 Hey","code":"$str = \"Hey $1.140 $20.568 16.9kg 12.3 2342342.9 Hey\"; $str =~ s/(\\d+\\.\\d+)/sprintf(\"%.f\",$1)/eg; print $str;\n","err":""},{"out":"I am 2000 years old","err":"","code":" $str = \"I am 2000 years old\"; $str =~ s/(\\d+(?:\\.\\d+)?)/sprintf('%.f',$1)/er;\n"},{"err":"","code":" $str = \"I bought $155.4954 worth of oregano\"; $str =~ s/(\\d+(?:\\.\\d+)?)/sprintf('%.f',$1)/er;\n","out":"I bought .4954 worth of oregano"},{"code":"'strike' =~ /(?:anywhere)?/ ? 'matches' : 'bad joke';\n","err":"","out":"matches"},{"code":"'strike' =~ /(?anywhere)/ ? 'matches' : 'bad joke';\n","err":"","out":"ERROR: Sequence (?any...) not recognized in regex; marked by <-- HERE in m/(?any <-- HERE where)/ at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"string'","code":"\"string\\'\"\n","err":""},{"out":"1","err":"","code":"$string=\"hello world\"; ($capture) = $string =~ /\\bhello\\b/; print $capture;\n"},{"out":"hello world","code":"$string=\"hello world\"; $capture = $string; $capture =~ /hello/; print $capture;\n","err":""},{"err":"","code":"$string=\"hello world\"; $capture = $string; $capture =~ s/.*(hello).*/$1/; print $capture;\n","out":"hello"},{"err":"","code":"$string=\"hello world\"; ($capture) = $string =~ /hello/; print $capture;\n","out":"1"},{"err":"","code":"$string=\"hello world\"; $capture = $string =~ /hello/; print $capture;\n","out":"1"},{"out":"1","code":"$string=\"hello world\"; ($capture) = $string =~ s/.*(hello).*/$1/; print $capture;\n","err":""},{"code":"$string = \"nah, i don't will hack you. you guys are cool.\"; $string =~ s/\"don't will\"/\"won't\"/g; print $string;\n","err":"","out":"nah, i don't will hack you. you guys are cool."},{"out":"nah, i won't hack you. you guys are cool.","err":"","code":"$string = \"nah, i don't will hack you. you guys are cool.\"; $string =~ s/don't will/won't/g; print $string;\n"},{"out":"bleh","code":"$string = qq/bleh/; print $string;\n","err":""},{"code":"$string = qq/bleh/; print $string => $string;\n","err":"","out":"blehbleh"},{"out":"357","err":"","code":"$string=\"xyz357pdq\"; $string=~s/.*357.*/357/g; print $string\n"},{"code":"$_ = \"stringy stringy string\"; $f = ~m/ingy/; print $f\n","err":"","out":"18446744073709551614"},{"out":"I weight 16kg","err":"","code":" $str = \"I weight 15.6kg\"; $str =~ s/(\\d+(?:\\.\\d+)?)/sprintf('%.f',$1)/er;\n"},{"out":"llam","code":"$str = \"llama\"; print substr($str, 0, -1);\n","err":""},{"out":"1","err":"","code":"$str = \"llama\"; print substr($str, -1, 0);\n"},{"err":"","code":"$str = \"llama\"; print substr($str, 1, -1);\n","out":"lam"},{"out":"l","code":"$str = \"llama\"; print substr($str, 1, 1);\n","err":""},{"out":"la","err":"","code":"$str = \"llama\"; print substr($str, 1, 2);\n"},{"out":"lam","code":"$str = \"llama\"; print substr($str, 1, 3);\n","err":""},{"err":"","code":"$str = 'P98 3G\\xE5\\x85\\xAB\\xE6\\xA0\\xB8(A3HY) Build/KOT49H)'; $str =~ s/\\\\x(..)/chr hex $1/ge; Encode::decode_utf8($str)\n","out":"P98 3GÃÂ¥ÃÂÃÂ«ÃÂ¦ÃÂ ÃÂ¸(A3HY) Build/KOT49H)"},{"out":"P98 3GÃÂ¥ÃÂÃÂ«ÃÂ¦ÃÂ ÃÂ¸(A3HY) Build/KOT49H)","code":"$str = 'P98 3G\\xE5\\x85\\xAB\\xE6\\xA0\\xB8(A3HY) Build/KOT49H)'; $str =~ s/\\\\x(..)/chr hex $1/ge; $str\n","err":""},{"err":"","code":"$str = \"_\"; print \"ok\" if ($str =~ /\\w/)\n","out":"ok"},{"code":"$str=sprintf(\"%.3f\", 1/3); print $str;\n","err":"","out":"0.333"},{"code":"$str=sprintf(%.3f, 1/3); print $str;\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"%.3\"\n"},{"code":"$str=\"status is: active/standby\"; $str =~ s/.*\\://; print $str;\n","err":"","out":" active/standby"},{"out":"active/standby","err":"","code":"$str=\"status is: active/standby\"; $str =~ s/.*\\:\\s+?//; print $str;\n"},{"out":"stringxyz","code":"$str=\"stringAtostringBxyz\"; $str=~s/A.*B//g; print $str;\n","err":""},{"err":"","code":"$str = \"''\"; $str=~ s/\\'\\'/\\'/g; print $str;\n","out":"'"},{"err":"","code":"$str = 'str with [ bracket'; $str =~ /[][]/ ? 'match' : 'no match';\n","out":"match"},{"code":"$str = \"s\\xc3\\x83\\xc2\\xbc\\xc3\\x83\\xc2\\x9fe\"; [ $str, decode_utf8($str), decode_utf8(decode_utf8($str)) ]\n","err":"","out":"[\"s\\303\\203\\302\\274\\303\\203\\302\\237e\",\"s\\x{c3}\\x{bc}\\x{c3}\\x{9f}e\",\"s\\x{fc}\\x{df}e\"]"},{"out":"test Test tEst TEst teSt TeSt tESt TESt tesT TesT tEsT TEsT teST TeST tEST TEST ","code":"$str = 'test'; for my $n (0..2**length($str)-1) { $bit = 0; print $str =~ s/([a-z])/$n & 1<<$bit++ ? uc$1 : lc$1/ger, ' ' } # << may be faster\n","err":""},{"err":"","code":"$str = 'test'; for my $n (0..2**length($str)-1) { $bit = 0; print $str =~ s/([a-z])/$n & 2**$bit++ ? uc$1 : lc$1/ger, ' ' } # another idea\n","out":"test Test tEst TEst teSt TeSt tESt TESt tesT TesT tEsT TEsT teST TeST tEST TEST "},{"err":"","code":"$str = 'test'; for my $n (0..2**length($str)-1) { $bit = 0; print $str =~ s/([a-z])/$n & 2**$bit++ ? uc$1 : lc$1/gier, ' ' } # needs /i (maybe?)\n","out":"test Test tEst TEst teSt TeSt tESt TESt tesT TesT tEsT TEsT teST TeST tEST TEST "},{"code":" $str = âthe 15.7 romulansâ; $str =~ s/((\\d+)(\\.\\d+)?)/int(\\1)/e;\n","err":"","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after /; $str = <-- HERE near column 98 at (eval 1) line 1, <STDIN> line 1.\n"},{"code":" $str = \"the 15.7 romulans\"; $str =~ s/((\\d+)(\\.\\d+)?)/sprintf(\"%.f\",(\\1)/e;\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"out":"1","code":" $str = \"the 15.7 romulans\"; $str =~ s/((\\d+)(\\.\\d+)?)/sprintf(\"%.f\",\\1)/e;\n","err":""},{"out":"the 16 romulans","code":" $str = \"the 15.7 romulans\"; $str =~ s/(\\d+(?:\\.\\d+)?)/sprintf('%.f',$1)/er;\n","err":""},{"out":"the 60632320 romulans","code":" $str = \"the 15.7 romulans\"; $str =~ s/(\\d+(?:\\.\\d+)?)/sprintf(\"%.f\",\\1)/er;\n","err":""},{"out":"(?^ui:brown f) the quick Brown Fox","code":"$str='the quick Brown Fox'; $rex = qr/brown f/i; print $rex; $str =~ $rex; print \" $str\";\n","err":""},{"out":"(?^ui:brown f) the quick ox","err":"","code":"$str='the quick Brown Fox'; $rex = qr/brown f/i; print $rex; $str =~ s/$rex//; print \" $str\";\n"},{"err":"","code":"$str='the rain in spain is not a dancer'; print s/e//g;\n","out":"1"},{"err":"","code":"$str='  trim this  '; $str=~s/^\\s+//g; $str=~s/\\s+$//g; print $str;\n","out":"trim this"},{"err":"","code":"$str = uc(\"foobar\") =~ s/FOO//r; $str\n","out":"BAR"},{"code":"$str = undef; print ref $str;\n","err":"","out":"1"},{"code":"$str = undef; print $str;\n","err":"","out":"1"},{"code":"$str=\"wildcard portion\"; $str=~s/(.)/\\[$&\\]/g; print $str;\n","err":"","out":"[w][i][l][d][c][a][r][d][ ][p][o][r][t][i][o][n]"},{"code":"$str=\"wildcard portion\"; $str=~s/wildcar(d.+)tion/\\[$&\\]/g; print $str;\n","err":"","out":"[wildcard portion]"},{"code":"$str=\"wildcard portion\"; $str=~s/wildcar(d*+)tion/\\[$&\\]/g; print $str;\n","err":"","out":"wildcard portion"},{"code":"$str=\"wildcard portion\"; $str=~s/wildcar(.*)tion/\\[$&\\]/g; print $str;\n","err":"","out":"[wildcard portion]"},{"out":"wildcard portion","code":"$str=\"wildcard portion\"; $str=~s/.*(wild).*/$&/g; print $str;\n","err":""},{"err":"","code":"$str=\"wildcard portion\"; $str=~s/(wild)/\\[$&\\]/g; print $str;\n","out":"[wild]card portion"},{"out":" ","code":"s TT$ Donald Trump\n","err":""},{"err":"","code":"\"stuff\" . 1 + 3\n","out":"3"},{"out":"[1]","err":"","code":"['stuff' =~ /(?:(?!stuff).)*/]\n"},{"code":"/(?<!STYLESY0B\\$\\$)/\n","err":"","out":"1"},{"code":"/(?<!STYLESY0B\\$\\$)\\b/\n","err":"","out":""},{"out":"ERROR: Variable length lookbehind not implemented in regex m/(?<!STYLESY0B\\$\\$)\\b/ at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"/(?<!STYLESY0B\\$\\$)\\b/i\n"},{"err":"","code":"/(?<!STYLESY0B\\$\\$)/i\n","out":"ERROR: Variable length lookbehind not implemented in regex m/(?<!STYLESY0B\\$\\$)/ at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Variable length lookbehind not implemented in regex m/(?<!STYLESY0B\\$\\$)/ at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"/(?<!STYLESY0B\\$\\$)/ia\n"},{"code":"/(?<!STYLESY0B\\$\\$)/iaa\n","err":"","out":"1"},{"out":"","err":"","code":"(sub {}) -> ()\n"},{"out":"[[sub { \"DUMMY\" }]]","err":"","code":"[ [ sub {} ] ]\n"},{"err":"","code":"[ sub {} ]\n","out":"[sub { \"DUMMY\" }]"},{"out":"ERROR: Illegal declaration of anonymous subroutine at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub ã¨ {}\n"},{"code":"(sub { ($_[0] = $_), shift for \"another perl Just hacker,\\n\" =~ /\\S+\\s/g })->(qw,s o r t,); print @a;\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"(sub { ($_[0] = $_), shift for \"another perl Just hacker,\\n\" =~ /\\S+\\s/g })->(sort my @a = qw,s o r t,); print @a;\n","err":"","out":"Just another perl hacker,\n"},{"out":"","err":"Out of memory!\nOut of memory!\n","code":"sub { &{$_[0]} }->( sub { &{$_[0]} } )\n"},{"out":"1","err":"","code":"(sub { 1 }) -> ()\n"},{"out":"Just another Perl hacker,","code":"sub _{@_<2&&return@_;push@{$|--},$_ for@_;map _(@$_),map[splice@$_],0,1}print _ split//,\"huroP cels,tetah Jen akrr\";\n","err":""},{"out":" uhPakatrrorc  ,tlJenehse","err":"","code":"sub _{@_<2&&return@_;push@{$|--},$_ for@_;map _(@$_),map[splice@$_],0,1}print _ split//,\"Just another Perl hacker,\";\n"},{"code":"sub _{@_<2&&return@_;push@{$|--},$_ for@_;map _(@$_),map[splice@$_],0,1}print _ split//,\" uhPakatrrorc  ,tlJenehse\";\n","err":"","out":"lur keePr,tsnacert  ahJho"},{"out":"42","code":"[ sub {42} ]->[0]()  # hehehe\n","err":""},{"err":"","code":"sub {42}->()  # hehehe\n","out":"42"},{"out":"[0]","err":"","code":"[ sub { 55 if 0 }->() ]\n"},{"out":"0","code":"sub { 55 if 0 }->()\n","err":""},{"code":"sub a { (5,7) }; a()->[1]\n","err":"","out":""},{"out":"7","err":"","code":"sub a { (5,7) }; a[1]\n"},{"out":"7","err":"","code":"sub a { (5,7); }  (a(3,1))[1];\n"},{"err":"","code":"sub a { (5,7); }  die (a(3))[1];\n","out":"ERROR: syntax error at (eval 1) line 1, near \")[\"\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \")[\"\n","err":"","code":"sub a { (5,7); }  die (a(3,1))[1];\n"},{"code":"sub a { (5,7); }  die +(a(3,1))[1];\n","err":"","out":"ERROR: 7 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Too many arguments for subroutine at (eval 1) line 1.\n","err":"","code":"sub a () { (5, 7) } print a[1];\n"},{"out":"2","err":"","code":"sub a { @_ } (a 3,2)[1]\n"},{"code":"sub a { @_ }; (a(3,2))[1]\n","err":"","out":"2"},{"err":"","code":"sub aãb { \"hi\" } aãb\n","out":"ERROR: Illegal declaration of subroutine main::a at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"sub a { b() } sub b { goto (caller(1))(3) } a()\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \")(\"\n"},{"code":"sub a { b() } sub b { goto (caller(1))[3] } a()\n","err":"","out":"ERROR: Can't find label main::a at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"Out of memory!\n","code":"sub a { b() } sub b { goto *{+(caller(1))[3]}{CODE} } a()\n","out":""},{"code":"sub accessor { my $self = shift; unless($self->{whatever}) { $self->{whatever} = 'stuff' } } accessor({whatever => 'previous value'}) # obviously no one would write code like that unless they hated the rest of their team, but, y'know. real example, sadly\n","err":"","out":"previous value"},{"err":"","code":"sub add { $_[0]+1 } add 5\n","out":"6"},{"err":"","code":"sub add { $_[0]+$_[1] } say add 2 => 2\n","out":"4\n"},{"err":"","code":"sub add { my $x = shift; sub { $_[0] + $x } } add(1)->(2)\n","out":"3"},{"code":"sub another'Just { \"Just @_,\" } sub hacker'Perl { \"Perl @_\" }  Just another Perl hacker,\n","err":"","out":"Just another Perl hacker,"},{"code":"sub { $anyothername = 'xxx' }->(); [ $anyothername ]\n","err":"","out":"[\"xxx\"]"},{"code":"sub a { @_ } print a(5,7)[1];\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \")[\"\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \")[\"\n","err":"","code":"sub a { return (5, 7); } print (a())[1];\n"},{"code":"sub AUTOLOAD { $AUTOLOAD = 'cats' } sub lol { \"lol\" } notlol()\n","err":"","out":"cats"},{"code":"sub AUTOLOAD { $AUTOLOAD = 'lol' } sub lol { \"lol\" } notlol()\n","err":"","out":"lol"},{"out":"lol","code":"sub AUTOLOAD { $AUTOLOAD = 'lol' } sub lol { \"verylol\" } notlol()\n","err":""},{"out":"main::hello kitty","code":"sub AUTOLOAD{ our $AUTOLOAD; my ( $a ) = @_; print \"$AUTOLOAD $a\"; } hello( 'kitty' );\n","err":""},{"err":"","code":"sub AUTOLOAD { print \"hi\" } &foo\n","out":"hi"},{"code":"sub AUTOLOAD { print \"hi\" } &{\"foo\"}\n","err":"","out":"hi"},{"err":"","code":"sub AUTOLOAD { print \"hi\" } foo;\n","out":"foo"},{"code":"sub AUTOLOAD { print \"hi\" } $x=\\*foo{CODE}; &$x;\n","err":"","out":"ERROR: Not a CODE reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Not a CODE reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub AUTOLOAD { print \"hi\" } $x=\\*foo; &$x;\n"},{"out":"[\"yes\"]","code":"sub AUTOLOAD { say 'test' }; [ 'main'->can('AUTOLOAD') ? 'yes' : 'no' ];\n","err":""},{"out":"10","err":"","code":"sub bar { $_[0]( $_[1] ) }; bar(sub { $_[0] * 2}, 5)\n"},{"code":"sub bar { $foo = 0; return $foo || die; } bar();\n","err":"","out":"ERROR: Died at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"sub bar { $foo = 0; return $foo or die; } bar();\n","out":"0"},{"out":"0","err":"","code":"sub base { my ($d, $n) = @_; my $r = ''; { my $c = $n % $d; if ($c >= 10) { $c = chr($c - 10 + ord 'a'); } $r .= $c; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 16, 0\n"},{"code":"sub base { my ($d, $n) = @_; my $r = ''; { my $c = $n % $d; if ($c >= 10) { $c = chr($c - 10 + ord 'a'); } $r .= $c; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 16, 255\n","err":"","out":"ff"},{"out":"5","code":"sub base { my ($d, $n) = @_; my $r = ''; { $r .= $n % $d; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 10, 5\n","err":""},{"out":"ERROR: Illegal modulus zero at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub base { my ($d, $n) = @_; my $r = ''; { $r .= $n % d; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 10, 5\n"},{"out":"1010","code":"sub base { my ($d, $n) = @_; my $r = ''; { $r .= $n % $d; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 2, 10\n","err":""},{"err":"","code":"sub base { my ($d, $n) = @_; my $r = ''; { $r .= $n % $d; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 2, 5\n","out":"101"},{"out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/( <-- HERE .{8}/ at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub bin2chr { pack 'b8', $_ }   join \"\", map { bin2chr $_ } \"0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010\" =~ m/(.{8}/g;\n"},{"out":"*ÃÂ.\u0016,ÃÂÃÂ¶ÃÂÃÂ¦ÃÂP","code":"sub bin2chr { pack 'b8', $_ }   join \"\", map { bin2chr $_ } \"0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010\" =~ m/(.{8})/g;\n","err":""},{"err":"","code":"sub bin2chr { pack 'B8', $_ }   join \"\", map { bin2chr $_ } \"0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010\" =~ m/(.{8})/g;\n","out":"Tith4cokei\n"},{"err":"","code":"sub blah { $_[0]++ } blah(my $val); ++$val\n","out":"2"},{"err":"","code":"sub blah { my @args = @_; return @args[-1]; } blah(0,1,2,3,4,5,6);\n","out":"6"},{"code":"sub blah { return $_[3] } blah(0,1,2,3,4,5,6);\n","err":"","out":"3"},{"err":"","code":"sub blah { \"value\" } blah()\n","out":"value"},{"code":"sub buildMech { return WWW::Mechanize->(); } sub zeroMech {my $mech = $_[0]; $$mech->clear_credentials(); } my $mech = zeroMech \\buildMech();\n","err":"","out":"ERROR: Undefined subroutine &WWW::Mechanize called at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"sub buildMech { return WWW::Mechanize->(); } sub zeroMech {my $mech = $_[0]; $$mech->clear_credentials(); } my $mech = zeroMech buildMech();\n","out":"ERROR: Undefined subroutine &WWW::Mechanize called at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"sub Bulgaria { print caller; } package Wimbledon; Bulgaria\n","out":"Bulgaria"},{"out":"ERROR: Undefined subroutine &Wimbledon::Bulgaria called at (eval 1) line 1, <STDIN> line 1.\n","code":"sub Bulgaria { print caller; } package Wimbledon; Bulgaria()\n","err":""},{"code":"sub c {$_[0]=~/.*\\.(.*)$/;$1} [map c($_), \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\"]\n","err":"","out":"[\"jpg\",\"pdf\",\"\",\"vimrc\",\"pl\"]"},{"out":"[\"jpg\",\"pdf\",\"\",\"vimrc\",\"pl\",undef]","err":"","code":"sub c {$_[0]=~/.*\\.(.*)$/;$1} [map c($_), \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n"},{"out":"[\"cats\"]","err":"","code":"sub catify { $_[0] = \"cats\" } my $x = \"dogs\"; catify $x; [$x]\n"},{"err":"","code":"sub chomp { \"blah\" }; [ chomp ] # Perl will warn about this with warnings on though\n","out":"[0]"},{"err":"","code":"sub closure { my $foo; sub { $foo ++ } }; my $sub = closure(); my $other = closure() ; [ $sub->(), $sub->() , $other->(), $other->(), $other->() ] # note that the $foo that belongs to $sub is different from the $foo that $other has... and that they both continue to exist due to there being a reference to a sub in the scope they reside within. see also: coping with scoping\n","out":"[0,1,0,1,2]"},{"out":"{a => \"b\"}","code":"sub config { my %x = (a => \"b\"); \\%x }; config\n","err":""},{"code":"sub CONSTANTPLS { 5 } my %stuff = ( +CONSTANTPLS => 7 ); $stuff{+CONSTANTPLS}\n","err":"","out":""},{"out":"7","code":"sub CONSTANTPLS { 5 } my %stuff = ( CONSTANTPLS() => 7 ); $stuff{CONSTANTPLS()}\n","err":""},{"out":"1\n","err":"","code":"sub ctx { say wantarray } \\ctx;\n"},{"out":"\\1","code":"sub ctx { wantarray // 'undef' } \\ctx;\n","err":""},{"out":"ff","code":"sub curry { my ($f) = @_; sub { my ($x) = @_; sub { my ($y) = @_; $f->($x, $y) } } } sub base { my ($d, $n) = @_; my $r = ''; { my $c = $n % $d; if ($c >= 10) { $c = chr($c - 10 + ord 'a'); } $r .= $c; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } curry(\\&base)->(16)->(255)\n","err":""},{"out":"[{name => \"x\"},{name => \"y\"},{name => \"z\"}]","code":"sub custom { my ($k) = @_; $a->{$k} cmp $b->{$k} } [ sort { custom('name') } { name => 'x' }, { name => 'y' }, { name => 'z' } ]\n","err":""},{"err":"","code":"sub d { (0 .. 9, 'a' .. 'z')[$_[0]] } sub b { $_ && b($_[0], $_) for int $_[1] / $_[0]; print d $_[1] % $_[0]; } b 14, 1.4e9\n","out":"d3d12120"},{"code":"sub d { (0 .. 9, 'a' .. 'z')[$_[0]] } sub b { $_ && b($_[0], $_) for int $_[1] / $_[0]; print d $_[1] % $_[0]; } b 16, 255\n","err":"","out":"ff"},{"out":"00","err":"","code":"sub d { (0 .. 9, 'a' .. 'z')[$_[0]] } sub b { $_ && b($_) for int $_[1] / $_[0]; print d $_[1] % $_[0]; } b 14, 1.4e9\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \") die\"\n","err":"","code":"sub dieonAg{ $string = shift; if ($string =~ /A[^ab]/) die \"A and not Aa or Ab\"; return $string};   print dieonAg(\"Hi A.\");\n"},{"err":"","code":"sub dieonAg{ $string = shift; if( $string =~ /A[^ab]/) {die \"A and not Aa or Ab\"}; return $string};   print dieonAg(\"Hi A.\");\n","out":"ERROR: A and not Aa or Ab at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \") die\"\n","err":"","code":"sub dieonAg{ $string = shift; if ($string =~ /A[^ab]/) die \"A and not Aa or Ab\"; return $string};   print dieonAg(\"Hi Ab.\");\n"},{"err":"","code":"sub dieonAg{ $string = shift; if( $string =~ /A[^ab]/) {die \"A and not Aa or Ab\"}; return $string};   print dieonAg(\"Hi Ab.\");\n","out":"Hi Ab."},{"out":"1","code":"sub do_stuff { my ($thing, @morestuff) = @_; return $thing, @morestuff; } do_stuff(0, 'asdf') ? 1 : 0\n","err":""},{"code":"sub do_stuff { undef $_ } [ map { do_stuff(); $_ } (1,2,3) ]\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[[312,56],[326,-186]]","err":"","code":"sub du { my ($x, $N, $V, $C) = @_; unpack('C', $x) + $C * 256 } sub ds { my ($x, $N, $V, $C) = @_; unpack('C', $x) - ($N ^ $V) * 256 } sub p { pack \"B*\", $_[0] } [ map [du(@$_), ds(@$_)], [p('00111000'), 0, 0, 1], [p('01000110'), 0, 1, 1] ]\n"},{"out":"[[312,56],[326,-186]]","code":"sub du { my ($x, $N, $V, $C) = @_; $x + $C * 256 } sub ds { my ($x, $N, $V, $C) = @_; $x - ($N ^ $V) * 256 } [ map [du(@$_), ds(@$_)], [0b0011_1000, 0, 0, 1], [0b0100_0110, 0, 1, 1] ]\n","err":""},{"out":"><","code":"sub eh { print \">\", wantarray, \"<\" } ref(eh)\n","err":""},{"out":"2","code":"sub { eval { return 1 }; return 2 }->()\n","err":""},{"out":"1","err":"","code":"sub f { 1 }; main -> f;\n"},{"out":"f2f1","err":"","code":"sub f1 { print 'f1' } sub f2 { print 'f2' } eval \"f1\\n&f2\"\n"},{"code":"sub f1 { \\@_ } sub f2 { \"f2\" } eval \"f1;\\n&f2\"\n","err":"","out":"f2"},{"out":"[\"f2\"]","code":"sub f1 { \\@_ } sub f2 { \"f2\" } eval \"f1\\n&f2\"\n","err":""},{"out":"123","err":"","code":"sub f { a => 123 } +{ f() }->{a}\n"},{"out":"1","code":"sub f { (a => 1, b => 2) } my $value = { f() }->{a};\n","err":""},{"err":"","code":"sub f { my @array = 1..3; return @array } \\f()\n","out":"\\3"},{"code":"sub foo { ${$_[0]} = 123 } foo \\(my $x); $x\n","err":"","out":"123"},{"code":"sub foo { ${$_[0]} = 123 } foo \\undef; $x\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","err":"","code":"sub foo { $$_[0] = 1 } foo \\(my $x); $x\n"},{"err":"","code":"sub foo{$_[0]<=>$_[1]} [sort &foo, qw,1 3 2 772 9,]\n","out":"[0,1,2,3,772,9]"},{"err":"","code":"sub foo { $_[0] * 2 } sub bar { $_[0]( $_[1] ) }; bar(\\&foo, 5)\n","out":"10"},{"out":"cats","code":"sub foo { $_[0] } \"cats\"->${ \\\\&foo }\n","err":""},{"err":"","code":"sub foo { $_[0] } \"cats\"->${ \\&foo }\n","out":"ERROR: Not a SCALAR reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub foo {$_[0]=\"cats\"}; foo \"dogs\";  # don't cripple your API for no reason\n"},{"code":"sub foo (&) { $_[0]() } foo \\sub {};\n","err":"","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(&)\"\n"},{"err":"","code":"sub foo { $_[0] .= \"Hi\" } my $x = \"Hello \"; foo($x); [$x]\n","out":"[\"Hello Hi\"]"},{"err":"","code":"sub foo { $_[0] = \"hi\"; } sub r_u_kiddin_me { \\@_ } sub bar { local *copy = r_u_kiddin_me @_; foo(@copy); \"@_\" }  $x = \"foo\"; bar $x\n","out":"hi"},{"code":"sub foo { $_[0]++ } my $x = 1; foo($x); $x\n","err":"","out":"2"},{"out":"[4]","err":"","code":"sub foo { $_[0]++ } my $x = 3; foo($x); [$x] #anno, you were saying?\n"},{"out":"[\"A\",\"B\",\"C\"]","code":"sub foo { @{$_[0]}=qw( A B C ); } foo (\\my @y); \\@y;\n","err":""},{"out":"[]","code":"sub foo { @{$_[0]}=qw( A B C ); } foo [my @y]; \\@y;\n","err":""},{"code":"sub foo { @{$_[0]}=qw( A B C ); } foo \\(my @y); \\@y;\n","err":"","out":"[]"},{"code":"sub foo { $_[0] =~ s/foo/bar/ } sub bar { foo(@copy = @_); \"@_\" } $x = \"foo\"; bar($x)  # how about this\n","err":"","out":"foo"},{"out":"bar","err":"","code":"sub foo { $_[0] =~ s/foo/bar/ } sub bar { foo(@_); \"@_\" } $x = \"foo\"; bar($x)\n"},{"out":"\\10","code":"sub foo { 1..10 }; \\foo;\n","err":""},{"out":"[\\1,\\2,\\3]","code":"sub foo { 1, 2, 3 } [ \\foo ]\n","err":""},{"out":"\\3","err":"","code":"sub foo { 1, 2, 3 } \\foo\n"},{"out":"123","code":"sub foo { [1, 2, 3] } { my $arr_ref = foo(); if (@$arr_ref) { print @$arr_ref } }\n","err":""},{"code":"sub foo { 2 } $foo=1; [$foo,foo]\n","err":"","out":"[1,2]"},{"err":"","code":"sub foo { 2 }; $foo=1; [$foo,foo]\n","out":"[1,2]"},{"code":"sub foo { 42 } *bar = \\&foo; bar()\n","err":"","out":"42"},{"out":"[sub { \"DUMMY\" }]","err":"","code":"sub FOO () { 42 } [ $::{FOO} ]\n"},{"out":"ERROR: Not a GLOB reference at (eval 1) line 1, <STDIN> line 1.\n","code":"sub foo { 42 }  *{$main::{foo}}{CODE}\n","err":""},{"out":"sub { \"DUMMY\" }","err":"","code":"sub foo { 42 } our $foo = 2; *{$main::{foo}}{CODE}\n"},{"out":"[1,2,3,4]","code":"sub foo { [ @_ ] }; @a = (1,2,3,4); foo(@a)\n","err":""},{"out":"[1]","err":"","code":"sub foo { [ @_ ] }; @a = 1,2,3,4; foo(@a)\n"},{"err":"","code":"sub foo{$a<=>$b} [sort &foo, qw(1 3 2 772 9)]\n","out":"[0,1,2,3,772,9]"},{"out":"[\\\"a\",\\\"b\",\\\"c\",\\\"d\",\\\"e\",\\\"f\",\\\"g\",\\\"h\",\\\"i\",\\\"j\",\\\"k\",\\\"l\",\\\"m\",\\\"n\",\\\"o\",\\\"p\",\\\"q\",\\\"r\",\\\"s\",\\\"t\",\\\"u\",\\\"v\",\\\"w\",\\\"x\",\\\"y\",\\\"z\"]","code":"sub foo { 'a'..'z' }; [\\(foo)];\n","err":""},{"out":"[\\\"a\",\\\"b\",\\\"c\",\\\"d\",\\\"e\",\\\"f\",\\\"g\",\\\"h\",\\\"i\",\\\"j\",\\\"k\",\\\"l\",\\\"m\",\\\"n\",\\\"o\",\\\"p\",\\\"q\",\\\"r\",\\\"s\",\\\"t\",\\\"u\",\\\"v\",\\\"w\",\\\"x\",\\\"y\",\\\"z\"]","err":"","code":"sub foo { 'a'..'z' }; [\\foo];\n"},{"out":"\\\"z\"","code":"sub foo { 'a'..'z' }; \\(foo);\n","err":""},{"err":"","code":"sub foo { 'a'..'z' }; \\foo;\n","out":"\\\"z\""},{"out":"\\undef","code":"sub foo { 'a'..'z' }; \\( (foo)[0..26] );\n","err":""},{"out":"hi","err":"","code":"sub Foo::Bar::blah { 'hi' } 'Foo::Bar'->blah\n"},{"err":"","code":"sub foo { BLAH: { sub { last BLAH }->(); print \"cats\\n\" } } foo()\n","out":""},{"err":"","code":"sub foo { (caller 0)[3] } foo\n","out":"main::foo"},{"code":"sub foo {(caller(0))[3]}  foo()\n","err":"","out":"main::foo"},{"out":"1","err":"","code":"sub foo { $count++; (1,2,3) } foreach my $x (foo()) { } $count\n"},{"code":"sub Foo { die 'here' } 'Foo'->new\n","err":"","out":"ERROR: Can't locate object method \"new\" via package \"Foo\" (perhaps you forgot to load \"Foo\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"sub foo { $#$_; }; [ foo(1 .. 4) ]\n","out":"[-1]"},{"out":"moo\n","err":"","code":"sub foo; foo \"hi\\n\"; sub foo { print \"moo\\n\"; }\n"},{"code":"sub foo { \"foo!\" }; push @x, \\&foo; $x[0]->()\n","err":"","out":"foo!"},{"code":"sub foo { \"foo!\" }; push @x, \\&foo; $x[0]() # I thought the -> was always needed before () - guess not\n","err":"","out":"foo!"},{"err":"","code":"sub foo (;*); foo($x, $y, length $y);\n","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, at EOF\n"},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(\\\"\n","code":"sub foo (\\&);  # good luck, what does this even mean\n","err":""},{"err":"","code":"sub foo {\" Hello\"}; undef &foo; foo()\n","out":"ERROR: Undefined subroutine &main::foo called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"hi","code":"sub foo { \"hi\" } my @x; bless \\@x; (\\@x)->foo\n","err":""},{"code":"sub foo{if (0) {} else {\"nothing\"}} [foo]\n","err":"","out":"[\"nothing\"]"},{"out":"[]","code":"sub foo{if (1) {} else {\"nothing\"}} [foo]\n","err":""},{"out":"cats","err":"","code":"sub foo ($is_it) { $is_it } foo \"cats\"\n"},{"err":"","code":"sub foo { join '-', @_ } foo 1, 2, 3, \"dogs\"\n","out":"1-2-3-dogs"},{"err":"","code":"sub foo { key1 => value1, key2 => value2 } [foo()]\n","out":"[\"key1\",\"value1\",\"key2\",\"value2\"]"},{"out":"ERROR: Can't return array to lvalue scalar context at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub foo :lvalue { @foo };  foo() = qw/ One Two Three /;\n"},{"out":"Three","code":"sub foo :lvalue { $foo };  foo() = qw/ One Two Three /; $foo\n","err":""},{"err":"","code":"sub foo :lvalue { print \"FOO!\" }  undef &foo; foo()\n","out":"ERROR: Undefined subroutine &main::foo called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"\nERROR: Can't return a readonly value from lvalue subroutine at (eval 1) line 1, <STDIN> line 1.\n","code":"sub foo :lvalue { say wantarray } foo = \"cats\"\n","err":""},{"code":"sub foo :lvalue { say wantarray; our $foo } foo = \"cats\"\n","err":"","out":"\n"},{"code":"sub foo :lvalue { [wantarray] } foo = \"cats\"\n","err":"","out":"cats"},{"out":"[[\"bar\"],[\"main\",\"bar\"]]","err":"","code":"sub foo { \\@_ };  [ main::foo(\"bar\"), main->foo(\"bar\") ]\n"},{"code":"sub foo { map { $_ } 1..10; } my $x = [ foo ]; $x;\n","err":"","out":"[1,2,3,4,5,6,7,8,9,10]"},{"out":"10","err":"","code":"sub foo { map { $_ } 1..10; } my $x = foo; $x;\n"},{"code":"sub foo { map { $_ } 1..10; } my $x = \\foo; $x; ### Why is this produce a different result?\n","err":"","out":"\\10"},{"out":"\\\"c\"","err":"","code":"sub foo { map { $_ } qw/a b c/; } my $x = \\foo; $x;\n"},{"err":"","code":"sub foo { map { $_ } qw/a b c/; } my $x = foo; $x;\n","out":"3"},{"code":"sub foo {  map { @_ }  qw/the futures returned/  }     [ foo(qw/the method parameters/) ]\n","err":"","out":"[\"the\",\"method\",\"parameters\",\"the\",\"method\",\"parameters\",\"the\",\"method\",\"parameters\"]"},{"err":"","code":"sub foo() { my ($arg1, $arg2) = @_ } foo(1,2)\n","out":"ERROR: Too many arguments for subroutine at (eval 1) line 1.\n"},{"out":"35","err":"","code":"sub foo { my ($arg1, $hashref) = @_; $hashref->{asdf} = 35 } my %hash = (asdf => 55); foo('25', \\%hash); $hash{asdf}\n"},{"code":"sub foo { my ($arg1, $hashref) = @_; $hashref->{asdf} } my %hash = (asdf => 55); foo('25', \\%hash)\n","err":"","out":"55"},{"out":"scalarscalarscalarscalar","err":"","code":"sub foo { my $c = wantarray; !defined $c ? \"void\" : $c ? \"list\" : \"scalar\" } (foo) x 4\n"},{"code":"sub foo { my $c = wantarray; !defined $c ? \"void\" : $c ? \"list\" : \"scalar\" } [(foo) x 4 ]\n","err":"","out":"[\"list\",\"list\",\"list\",\"list\"]"},{"code":"sub foo { my ($d, @r) = @_; if ($d < 1) { print \"@r; \"; return; } for my $i (1 .. 3) { foo($d - 1, @r, $i); } } foo 2;\n","err":"","out":"1 1; 1 2; 1 3; 2 1; 2 2; 2 3; 3 1; 3 2; 3 3; "},{"out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n","code":"sub foo { my $_ = \\@_; $#$_ } [ foo(1..4) ]\n","err":""},{"out":"[\"\"]","err":"","code":"sub foo { } my $foo = \\&foo; my $bar = \\&bar; [ $foo eq $bar ]\n"},{"err":"","code":"sub foo { } my $foo = \\&foo; my $bar = \\&foo; [ $foo == $bar ]\n","out":"[1]"},{"err":"","code":"sub foo { my ($num, @els) = @_; $num + @els } foo( 3, 1, 2, 3)\n","out":"6"},{"out":"[\"two is undef\"]","err":"","code":"sub foo { my ($one, $two, $three) = @_; return defined($two) ? \"two is defined\" : \"two is undef\"; } [foo('hello',undef(),'three')]\n"},{"out":"foo","code":"sub foo { my $x = $_[0]; $x =~ s/foo/bar/ } sub bar { foo(@_); \"@_\" } $x = \"foo\"; bar($x)\n","err":""},{"out":"","code":"sub foo { my $x = 42; sub { eval shift } } foo()->('$x')\n","err":""},{"out":"42","err":"","code":"sub foo { my $x = 42; sub { $x; eval shift } } foo()->('$x')\n"},{"out":"1","err":"","code":"sub foo { my $x = do { return 1 }; $x + 1 } foo\n"},{"out":"[77,\"b\",456,\"a\",123]","code":"sub foo { my ($x, $y, $z, @rest) = @_; bar( $x, @rest ); } sub bar { [ @_ ]; } my %h = ( a => 123, b => 456 ); foo 77, 88, 99, %h;\n","err":""},{"code":"sub Foo { our $nested; local $nested unless $nested; my @p = ( [ shift, $nested // 0, $nested ? q{Nested} : q{First} ] ); {  if ( @_ ) { $nested++; push @p, Foo( @_ ); }  }; if ( $nested ) { $nested--; @p; } else { [ @p ]; } }   { RUN1 => Foo(qw(A B C)), RUN2 => Foo(qw(X Y Z)) };\n","err":"","out":"{RUN1 => [[\"A\",0,\"First\"],[\"B\",1,\"Nested\"],[\"C\",2,\"Nested\"]],RUN2 => [[\"X\",0,\"First\"],[\"Y\",1,\"Nested\"],[\"Z\",2,\"Nested\"]]}"},{"err":"","code":"sub Foo { our $nested; local $nested unless $nested; my @p = ( [ shift, $nested ? q{Nested} : q{First} ] ); {  if ( @_ ) { $nested++; push @p, Foo( @_ ); }  }; if ( $nested ) { $nested--; @p; } else { [ @p ]; } }   { RUN1 => Foo(qw(A B C)), RUN2 => Foo(qw(X Y Z)) };\n","out":"{RUN1 => [[\"A\",\"First\"],[\"B\",\"Nested\"],[\"C\",\"Nested\"]],RUN2 => [[\"X\",\"First\"],[\"Y\",\"Nested\"],[\"Z\",\"Nested\"]]}"},{"code":"sub Foo { our $nested; local $nested unless $nested; my @p = ( [ shift, $nested ? q{Nested} : q{First} ] ); { $nested++; push @p, Foo( @_ ) if @_ }; if ( $nested ) { $nested--; @p; } else { [ @p ]; } } [ Foo( qw( A B C ) ), Foo( qw( X Y Z ) ) ];\n","err":"","out":"[[\"A\",\"First\"],[\"B\",\"Nested\"],[\"C\",\"Nested\"],[\"X\",\"First\"],[\"Y\",\"Nested\"],[\"Z\",\"Nested\"]]"},{"out":"[[\"A\",\"First call\"],[\"B\",\"Nested\"],[\"C\",\"Nested\"],[\"X\",\"First call\"],[\"Y\",\"Nested\"],[\"Z\",\"Nested\"]]","code":"sub Foo { our $p; $p = [ ] unless defined $p; push @$p, [ shift, ( (caller(0))[3] eq (caller(1))[3] ? q{Nested} : q{First call} ) ]; Foo( @_ ) if @_; my $x = $p; $x; } Foo qw( A B C ); Foo qw( X Y Z );\n","err":""},{"out":"GLOB(0x55e2820)","code":"sub foo { print \"bar\" }; use constant { baz => *foo }; print $::{baz};\n","err":""},{"code":"sub foo { print \"bar\" }; use constant { baz => *foo }; print $::{baz}, *foo;\n","err":"","out":"GLOB(0x4607820)*main::foo"},{"out":"*main::foo","err":"","code":"sub foo { print \"bar\" }; use constant { baz => *foo }; print main->baz;\n"},{"err":"","code":"sub foo::print { CORE::print \"bar\" }; print foo::; print \"\\n\";\n","out":"\n"},{"code":"sub foo { print \"Debug\\n\", return 1 if (1); } foo();\n","err":"","out":"1"},{"err":"","code":"sub foo { print (\"Debug\\n\"), return 1 if (1); } foo();\n","out":"Debug\n"},{"err":"","code":"sub foo { print(\"Debug\\n\"), return 1 if (1); } foo();\n","out":"Debug\n"},{"code":"sub foo () { print \"-> @_ <-\" } do foo(42);\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"do foo(\"\n"},{"out":"eh","code":"sub foo { print \"eh\" } foo()\n","err":""},{"err":"","code":"sub foo () { print \"foo\"; };   foo;\n","out":"foo"},{"out":"quuxbazquux","code":"sub foo { print $foo } sub bar { local $foo = 'baz'; foo }        $foo = 'quux';          foo(); bar(); foo()\n","err":""},{"out":"ERROR: Undefined subroutine &main::foo called at (eval 1) line 1, <STDIN> line 1.\n","code":"sub foo { print \"FOO!\" }  undef &foo; foo()\n","err":""},{"code":"sub foo { print \"foo\" }; use constant FOO => *foo; print FOO();\n","err":"","out":"*main::foo"},{"out":"*main::foo","code":"sub foo { print \"foo\" }; use constant FOO => *foo; print main->FOO;\n","err":""},{"code":"sub foo { print \"my arguments are [@_]\"; } foo(1, 2, 3);\n","err":"","out":"my arguments are [1 2 3]"},{"err":"","code":"sub foo { print \"my arguments are [@_]\"; } sub { foo(42) }->()\n","out":"my arguments are [42]"},{"err":"","code":"sub foo { print \"my arguments are [@_]\"; } sub { foo(42, @_) }->(1, 2, 3)\n","out":"my arguments are [42 1 2 3]"},{"out":"my arguments are [42]","err":"","code":"sub foo { print \"my arguments are [@_]\"; } sub { foo(42) }->(1, 2, 3)\n"},{"err":"Debug\n","code":"sub foo { print (STDERR \"Debug\\n\"), return 1 if (1); } foo();\n","out":"1"},{"out":"1","err":"Debug\n","code":"sub foo { print (STDERR \"Debug\\n\"); return 1 if (1); } foo();\n"},{"code":"sub foo { print STDERR (\"Debug\\n\"), return 1 if (1); } foo();\n","err":"","out":"1"},{"out":"1","err":"Debug\n","code":"sub foo { print(STDERR \"Debug\\n\"), return 1 if (1); } foo();\n"},{"out":"1","err":"","code":"sub foo { print STDOUT (\"Debug\\n\"), return 1 if (1); } foo();\n"},{"out":"Debug\n1","err":"","code":"sub foo { print STDOUT (\"Debug\\n\"); return 1 if (1); } foo();\n"},{"out":"8","code":"sub foo($q) {$q + 3}; foo(5);\n","err":""},{"err":"","code":"sub foo { @_ = qw(hello world); } sub bar { &foo; \"@_\" }  bar\n","out":"hello world"},{"err":"","code":"sub foo { @_ = qw(hello world); } sub bar { foo(@_); \"@_\" }  bar\n","out":""},{"out":"1","err":"","code":"sub foo { return [1, 2, 3] } if (@{(my $arr_ref = foo())}) { print @$arr_ref }\n"},{"err":"","code":"sub foo { return(40) + 2 } foo()\n","out":"42"},{"out":"[42,42]","code":"sub foo { return 42; }  [ foo(), foo() ]\n","err":""},{"err":"","code":"sub foo {return caller()} print Dumper(foo());\n","out":"$VAR1 = 'main';\n$VAR2 = '(eval 1)';\n$VAR3 = 1;\n"},{"code":"sub foo { return 'foo', 'bar' } sub bar { return map uc, @_ } print bar foo\n","err":"","out":"FOOBAR"},{"err":"","code":"sub foo { s/a// }; { my $_ = 'bar'; foo(); print $_ }\n","out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n"},{"out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n","code":"sub foo { s/a// }; { my $_ = 'bar'; our $_ = 'baz'; foo(); print $_ }\n","err":""},{"out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n","err":"","code":"sub foo { s/a// }; { my $_ = 'bar'; our $_ = 'baz'; s/a//; print $_ }\n"},{"out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n","err":"","code":"sub foo { s/a// }; { my $_ = 'bar'; s/a//; print $_ }\n"},{"err":"","code":"{ sub foo { say } } foo for 123\n","out":"123\n"},{"out":"1\n","err":"","code":"sub foo { say wantarray() } \\foo();\n"},{"err":"","code":"sub foo { shift()*2 } sub bar :prototype() { shift()*2 } [(foo + 5), (bar + 5)]\n","out":"[10,5]"},{"out":"[8,8]","err":"","code":"sub foo { shift()+3 } sub bar :prototype() { shift()+3 } [(foo + 5), (bar + 5)]\n"},{"out":"[8]","code":"sub foo { shift()+3 } sub bar :prototype() { shift()+3 } [foo + 5, bar + 5]\n","err":""},{"out":"ERROR: Too many arguments for subroutine at (eval 1) line 1.\n","code":"sub foo { shift()+3 } sub bar () { shift()+3 } [foo + 5, bar + 5]\n","err":""},{"code":"sub foo { shift+3 } sub bar () { shift+3 } [foo + 5, bar + 5]\n","err":"","out":"ERROR: Type of arg 1 to shift must be array (not constant item) at (eval 1) line 1, at EOF\nType of arg 1 to shift must be array (not constant item) at (eval 1) line 1, at EOF\n"},{"out":"{foo => \"bar\"}","err":"","code":"sub foo {shift} { foo => 'bar' }->${ \\\\&foo }\n"},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(\\\"\n","code":"sub foo (\\&) { shift->() } sub myfunc { say +(caller 0)[3] } foo &myfunc;\n","err":""},{"code":"sub foo (\\&) { shift->() } sub myfunc { say +(caller 0)[3] } foo myfunc;\n","err":"","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(\\\"\n"},{"out":"hi","err":"","code":"sub foo; sub AUTOLOAD { print 'hi' } foo;\n"},{"code":"sub foo { sub bar { } }\n","err":"","out":""},{"out":"sub { \"DUMMY\" }","err":"","code":"sub foo { __SUB__ } foo\n"},{"code":"sub foo { {thingy => $_[0]} } [foo 1, 2, 3]\n","err":"","out":"[{thingy => 1}]"},{"out":"lol","err":"","code":"sub foo { undef; } my $x = foo() or print \"lol\"\n"},{"code":"sub foo () { wantarray ? \"list\" : \"scalar\" } [ foo x 4 ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"x 4\"\n"},{"code":"sub foo { wantarray ? \"list\" : \"scalar\" } [ foo x 4 ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"x 4\"\n"},{"out":"1","err":"had 0 items\n","code":"sub foo { warn \"had \" . @_ . \" items\\n\" } foo(\\(my @x)); # foo is given a list of refs to everything in the list returned by (my @x), i.e. empty list\n"},{"err":"","code":"sub foo ($y) { $y++ } my $x = 1; foo($x); $x\n","out":"1"},{"err":"","code":"sub f { return; } @a = f();  print $a[1];\n","out":"1"},{"code":"sub f{return} for (f) {print 'a' if defined $_}\n","err":"","out":""},{"out":"1","code":"sub f { return (undef,undef); } @a = f();  print $a[1];\n","err":""},{"out":"ERROR: Can't localize lexical variable $x at (eval 1) line 1, <STDIN> line 1.\n","code":"sub f { state $x; if ($x) { print \"rec\\n\"; return } local $x = 1; f() }\n","err":""},{"out":"ERROR: Can't localize through a reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub f{ state $x; if ($$x) { print \"rec\\n\"; return } local $$x = 1; f() } f()\n"},{"err":"","code":"sub f{ state %x; if ($x{rec}) { print \"rec\\n\"; return -3 } local $x{rec} = 1; f() }\n","out":""},{"code":"sub f{ state %x; if ($x{rec}) { print \"rec\\n\"; return } local $x{rec} = 1; f() }\n","err":"","out":""},{"err":"","code":"sub f{ state %x; if ($x{rec}) { print \"rec\\n\"; return } local $x{rec} = 1; f() } f()\n","out":"rec\n"},{"out":"","code":"sub f { state %x; print \">$x{rec}<\"; if ($x{rec}) { print \"rec\\n\"; return -3 } local $x{rec} = 1; f() }\n","err":""},{"out":"","err":"","code":"sub f{ statse %x; if ($x{rec}) { print \"rec\\n\"; return } local $x{rec} = 1; f() }\n"},{"code":"sub fwee::poww { 42 } sub gorble::snork { 2 * pop }  snork gorble poww fwee  # it can be made valid perl :)\n","err":"","out":"84"},{"err":"","code":"sub get_var { warn \"GET VAR\\n\"; return \\my $var }   ${ get_var } += 1\n","out":"1"},{"err":"","code":"[ sub glob { my %hash = ( \"*.txt\" => [qw/ 1.txt 2.txt/], \"*.pl\" => [qw/ 1.pl 2.pl/ ], ); return $_[0] ? $hash{$_[0]} || [ \"a.txt\" ] : [ \"a.txt\" ];}@{ &glob($_) }[0] for (qw/ *.pl *.rb /); ]\n","out":"ERROR: syntax error at (eval 1) line 1, near \"[ sub glob \"\nCan't use global @_ in \"my\" at (eval 1) line 1, near \"return $_\"\nsyntax error at (eval 1) line 1, near \";}\"\n"},{"code":"sub glob { my %hash = ( \"*.txt\" => [qw/ 1.txt 2.txt/], \"*.pl\" => [qw/ 1.pl 2.pl/ ], ); return $_[0] ? $hash{$_[0]} || [ \"a.txt\" ] : [ \"a.txt\" ];}@{ &glob($_) }[0] for (qw/ *.pl *.rb /);\n","err":"","out":""},{"out":"hello, lalupa!","err":"","code":"sub greet { my ($name) = @_; print \"hello, $name!\"; } greet(\"lalupa\");\n"},{"code":"(sub { ${^HasBeen} = 1 })->(); [ ${^HasBeen} ]\n","err":"","out":"[1]"},{"err":"","code":"sub hi { print \"hi\" }; $::{wtf} = \\*hi; wft();\n","out":"ERROR: Undefined subroutine &main::wft called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"hi","err":"","code":"sub hi { print \"hi\" }; $::{wtf} = \\*hi; wtf();\n"},{"out":"cats","err":"","code":"sub href { $_[0]->{Val} = 'cats' } href\n"},{"out":"ERROR: Illegal declaration of anonymous subroutine at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub Ä§ { say \"42\"; } Ä§\n"},{"err":"","code":"sub huf { \\1 } ${;huf}\n","out":"1"},{"out":"72951","err":"","code":"sub hx { sprintf \"%x\", $_[0] } join '0x', hx(0x23267) + hx(0x49684)\n"},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n","code":"sub inc { $_+=1 for @_} inc(1,2,3)\n","err":""},{"code":"sub inc { $_+=1 for @_}; inc(1,2,3)\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"sub inc { $_+=1 for @_} my @x = (1,2,3); inc(@x); \\@x\n","out":"[2,3,4]"},{"out":"1","code":"sub inc {my ($intref) = @_; ${ $intref }++;} my $i = 0; inc(\\$i); $i\n","err":""},{"out":"blah","code":"sub inner { \"blah\" } sub outer { my $inner = shift; $inner->() } outer \\&inner;\n","err":""},{"out":"[33596209,33597447]","err":"","code":"sub ip2num { my @f = split /\\./, shift; $f[0] << 24 | $f[1] << 16 | $f[2] << 8 | $f[3] } [ map { ip2num($_) } (\"2.0.163.49\", \"2.0.168.7\") ]\n"},{"err":"","code":"sub kv(\\%@){my $h = shift; map { $_ => $h->{$_} } @_ }; my %options = (light => 'on', color => 'red', height => 3); my @subset = qw(light color refraction); [\\%options, kv(%options, @subset)]\n","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(\\\"\nCan't use global $_ in \"my\" at (eval 1) line 1, near \"{ $_ \"\nsyntax error at (eval 1) line 1, near \"@_ }\"\n"},{"err":"","code":"sub lala { 'lala' } my $name = 'lala'; my $cref = __PACKAGE__->can('lala'); $cref->()\n","out":"lala"},{"err":"","code":"sub lala {my @x = qw(a b c), my @y = qw(d e); (@x, @y)} lala();\n","out":"2"},{"out":"12345","code":"sub learn_list_context { my($first,@rest) = (1,2,3,4,5); print $first,@rest; }; learn_list_context\n","err":""},{"code":"sub letters_from ($) { $_[0] =~ /(\\D+)/; $1 } sub numbers_from ($) { $_[0] =~ /(\\d+)/; $1 } [sort { letters_from $a cmp letters_from $b || numbers_from $a <=> numbers_from $b } qw/a1 b1 b2 a4 c3 d11 d12 a12 c3/]\n","err":"","out":"[\"a1\",\"b1\",\"b2\",\"a4\",\"c3\",\"d11\",\"d12\",\"a12\",\"c3\"]"},{"code":"sub List::Util::0sum {my ($a, $b)=(0,0); $a+=$_, $b-=$_ for @_; ($a, $b)}; [List::Util::0sum(1,2,3,4,5)]\n","err":"","out":"[15,-15]"},{"out":"ERROR: Can't modify constant item in local at (eval 1) line 1, at EOF\n","code":"sub local {}  local(-1)\n","err":""},{"out":"","err":"","code":"sub { ${^Local} = 'xxx' }->() [ ${^Local} ]\n"},{"out":"[\"xxx\"]","code":"sub { ${^Local} = 'xxx' }->(); [ ${^Local} ]\n","err":""},{"code":"sub lol (\\@) { \"$_[0]\" } lol([])\n","err":"","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(\\\"\n"},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(\\\"\n","err":"","code":"sub lol (\\@) { \"$_[0]\" } my @arr = 1..3; lol(@arr)\n"},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(\\\"\n","code":"sub lol (\\@\\@) { \"$_[0]\" } my @arr = 1..3; lol(@arr, @arr)\n","err":""},{"out":"[1]","code":"sub lol { return 0 || 1 } [ lol ]\n","err":""},{"out":"[0]","err":"","code":"sub lol { return 0 or 1 } [ lol ]\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"new main \"\n","code":"sub main { bless [] }; [ new main ]\n","err":""},{"out":"sub { \"DUMMY\" }","err":"","code":"sub meow { print @_ } \\&meow\n"},{"out":"[\"main\",\"lala\"]","code":"sub meth { [@_] } __PACKAGE__->meth('lala')\n","err":""},{"out":"A:M","err":"","code":"sub M::foo { print \"A:@_\" }; sub foo { print \"B:@_\" }; foo M:: , ;\n"},{"out":"A:M","err":"","code":"sub M::foo { print \"A:@_\" }; sub foo { print \"B:@_\" }; foo M:: ;\n"},{"out":"B:M","err":"","code":"sub M::foo { print \"A:@_\" }; sub foo { print \"B:@_\" }; foo( M:: );\n"},{"out":"A:M","code":"sub M::foo { print \"A:@_\" }; sub foo { print \"B:@_\" }; foo M:: , 2;\n","err":""},{"out":"[\"foo\"]","code":"sub m() { 'foo' }; sub i() { 'bar' }; [ &m() // i() ]\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"m // i \"\n","err":"","code":"sub m() { 'foo' }; sub i() { 'bar' }; [ m // i ]\n"},{"err":"","code":"sub m() { 'foo' }; sub i() { 'bar' }; [ m() || i() ]\n","out":"[1]"},{"out":"[1]","err":"","code":"sub m() { 'foo' }; sub i() { 'bar' }; [ m() // i ]\n"},{"code":"sub m() { 'foo' }; sub i() { 'bar' }; [ m() // i() ]\n","err":"","out":"[1]"},{"code":"sub MODIFY_SCALAR_ATTRIBUTES { grep $_ ne \"SupposedToBeUndef\", @_[2 .. $#_] } my $foo :SupposedToBeUndef;\n","err":"","out":""},{"out":"","err":"","code":"sub M::TIEARRAY { shift } sub M::FETCH { print \"Element $_[1]\" }  tie my @arr, \"M\";   $arr[123]\n"},{"code":"[ sub { my %a = @_; $a{-something} }->(-something => 'blah') ]\n","err":"","out":"[\"blah\"]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \") ]\"\n","err":"","code":"{ sub { my %a = @_; $a{-something} }->(-something => 'blah') ]\n"},{"out":"1","code":"sub mychomp { chomp $_[0] } my $x = \"\\n\"; $x = mychomp($x); $x\n","err":""},{"code":"sub my_class::new { sub { bless { @_ }, 'my_class' } } my_class::new->(foo => 'bar') # you could do that, but it doesn't seem all that useful\n","err":"","out":"bless( {foo => \"bar\"}, 'my_class' )"},{"out":"[\"z\",\"y\",\"x\"]","err":"passed as sub mysort { warn \"passed as @_,a=$a,b=$b\\n\" } [ sort mysort qw(x y z) ],a=x,b=y\npassed as sub mysort { warn \"passed as @_,a=$a,b=$b\\n\" } [ sort mysort qw(x y z) ],a=y,b=z\n","code":"sub mysort { warn \"passed as @_,a=$a,b=$b\\n\" } [ sort mysort qw(x y z) ]\n"},{"out":"1","code":"sub my_sub { warn join ', ', @_ } my_sub(1, 2, 3)\n","err":"1, 2, 3 at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"[sub { my ($x, $y) = @_; ($x*10+$y)}->(5,6)]\n","err":"","out":"[56]"},{"code":"sub new { bless [] }; [ new main ]\n","err":"","out":"[bless( [], 'main' )]"},{"out":"[bless( [], 'main' )]","code":"sub new { bless [] }; package foo; [ new main ]\n","err":""},{"out":"[bless( [], 'main' )]","code":"sub new { bless [] }; package foo; sub new { bless [] }; [ new main ]\n","err":""},{"out":"[bless( [], 'foo' )]","err":"","code":"sub new { bless [] }; package foo; sub new { bless [] }; [ new(main) ]\n"},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(*)\"\n","err":"","code":"sub new { bless [] }; package foo; sub new(*) { bless [] }; [ new main ]\n"},{"code":"sub nextPoT { my %hash; keys %hash = shift; $hash{x} = 1; [split(\"/\", scalar %hash)]->[1] } [ map { nextPoT($_) } (1..20) ]\n","err":"","out":"[8,8,8,8,8,8,8,8,16,16,16,16,16,16,16,16,32,32,32,32]"},{"code":"sub nextPoT { my %hash; keys %hash = shift; $hash{x} = 1; split(\"/\", scalar %hash)[1] } [ map { nextPoT($_) } (1..20) ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \")[\"\n"},{"code":"sub oldy { return 'goody' }; print &oldy;\n","err":"","out":"goody"},{"err":"","code":"sub oldy { return \\@_ } sub goody { &oldy } goody 'obfuscated', 'is', 'not', 'a', 'goal'\n","out":"[\"obfuscated\",\"is\",\"not\",\"a\",\"goal\"]"},{"err":"","code":"sub oldy { return \\@_ } sub goody { oldy } goody 'obfuscated', 'is', 'not', 'a', 'goal'\n","out":"[]"},{"out":"ERROR: Can't locate object method \"new\" via package \"lowercase sub names are more common in perl\" (perhaps you forgot to load \"lowercase sub names are more common in perl\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"sub Open_Logfile { 'lowercase sub names are more common in perl' } Open_Logfile->new\n","err":""},{"out":"onetwo","code":"sub outer { my $var if 0; $var = shift; sub inner { print $var||'three' } }   outer(\"one\"); inner(); outer(\"two\"); inner()\n","err":""},{"out":"oneone","err":"","code":"sub outer { my ($var) = @_; sub inner { print $var } }   outer(\"one\"); inner(); outer(\"two\"); inner()\n"},{"out":"threetwo","code":"sub outer { my ($var) = @_; sub inner { print $var||'three' } }    inner(); outer(\"two\"); inner()\n","err":""},{"err":"","code":"sub outer { my ($var) = @_; sub inner { print $var||'three' } }   outer(\"one\"); inner(); outer(\"two\"); inner()\n","out":"oneone"},{"err":"","code":"sub outer { my ($var) = @_; sub inner { print $var//'three' } }   outer(\"one\"); inner(); outer(\"two\"); inner()\n","out":"oneone"},{"code":"sub _ { print /::(.*)/, ' ' }; *AUTOLOAD = *_; Just(), another(), Perl(), &{\"hacker,\"};\n","err":"","out":"Just another Perl hacker, "},{"out":"scalar","err":"","code":"sub { print qw(scalar list void)[wantarray // 2] }->()\n"},{"code":"sub { print qw(scalar list void)[wantarray // 2] }->(); ()\n","err":"","out":"void"},{"err":"","code":"() = (sub { print qw(scalar list void)[wantarray // 2] }->()) x 4; ()\n","out":"list"},{"out":"scalar","err":"","code":"(sub { print qw(scalar list void)[wantarray // 2] }->()) x 4; ()\n"},{"code":"sub { print qw(scalar list void)[wantarray // 2] }->() x 4; ()\n","err":"","out":"scalar"},{"out":"","err":"","code":"sub printSvPVIV { printf \"SvPV is %s but SvIV is %d\\n\", $_[0], $_[0] }    $! = 1; print SvPVIV $!\n"},{"out":"SvPV is Operation not permitted but SvIV is 1\n","err":"","code":"sub printSvPVIV { printf \"SvPV is %s but SvIV is %d\\n\", $_[0], $_[0] }    $! = 1; printSvPVIV $!\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"/user/:\"\n","err":"","code":"sub :prototype(/user/:user_id) {}\n"},{"err":"","code":"sub { qw(scalar list void)[wantarray // 2] }->()\n","out":"scalar"},{"err":"","code":"(sub { qw(scalar list)[wantarray] }->()) x 4\n","out":"scalarscalarscalarscalar"},{"out":"[\"list\",\"list\",\"list\",\"list\"]","code":"[ (sub { qw(scalar list)[wantarray] }->()) x 4 ]\n","err":""},{"err":"","code":"sub { qw(scalar list)[wantarray] }->() x 4\n","out":"scalarscalarscalarscalar"},{"err":"","code":"sub { qw(void scalar list)[wantarray + defined wantarray] }->()\n","out":"scalar"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n","err":"","code":"sub { qw(void scalar list)[wantarray + defined wantarray}->()\n"},{"out":"[4,5,6,7,8,9]","code":"sub range { $_[0] .. $_[1] } $_ = \"4-9\"; [ range /(\\d+)-(\\d+)/ ]\n","err":""},{"out":"[4,5,6,7,8,9]","err":"","code":"sub range { $_[0] .. $_[1] } [ range \"4-9\" =~ /(\\d+)-(\\d+)/ ]\n"},{"out":"a  c a b","err":"","code":"sub remove_nth { my ($string, $substring, $n) = @_; my $pos = 0; while ($n > 0) { $pos = index($string, $substring, $pos); $n-- } substr($string, $pos, length($substring), \"\"); return $string }; remove_nth(\"a b c a b\", \"b\", 1)\n"},{"out":"ERROR: substr outside of string at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub replace_nth { my ($n, $pattern, $replacement, $str) = @_; $str =~ /$pattern/g or return $str for 1 .. $n; substr $str, $-[0], $+[0] - $-[0], $replacement; $str } replace_nth 3, qr/\\w/, 'X', 'hello'\n"},{"code":"sub replace_nth { my ($n, $pattern, $replacement, $str) = @_; while ($n > 0) { $str =~ /$pattern/g or last; $n--; if ($n == 0) { substr $str, $-[0], $+[0] - $-[0], $replacement; } } $str } replace_nth 3, qr/\\w/, 'X', 'hello'\n","err":"","out":"heXlo"},{"out":"heLlo","err":"","code":"sub replace_nth { my ($n, $pattern, $repl, $str) = @_; while ($n > 0) { $str =~ /$pattern/g or last; $n--; if ($n == 0) { substr $str, $-[0], $+[0] - $-[0], ref($repl) ? $repl->() : $repl; } } $str } replace_nth 3, qr/(\\w)/, sub { uc $1 }, 'hello'\n"},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":" sub replace { s/A/b/ for shift }; replace \"Abc\"\n"},{"out":"","code":"sub replace{ s/A/b/; return $_}  replace(\"Abc\")\n","err":""},{"out":"","code":" sub replace { s/A/b/r for shift }; replace \"Abc\"\n","err":""},{"out":"2","err":"","code":"sub ret { eval 1+1; }; print &ret();\n"},{"err":"","code":"sub ret { $str=\"some string\"; }; print &ret();\n","out":"some string"},{"err":"","code":"sub ret { $str=\"some string\"; }; print &ret; print ret();\n","out":"some stringsome string"},{"err":"","code":"sub return_false { 0 }  my $msg = \"pizza\";   if ( ($msg =~ m/pizza/i) and ( return_false() ) ) { print \"Are we really here?\" } # I can't reproduce from your problem description so far\n","out":"0"},{"out":"1/8","err":"","code":"(%{sub{ return {hello=>'World'}}->()})\n"},{"out":"[\"hello\",\"World\"]","err":"","code":"[%{sub{ return {hello=>'World'}}->()}]\n"},{"code":"{%{sub{ return {hello=>'World'}}->()}}\n","err":"","out":"1/8"},{"out":"1/8","err":"","code":"%{sub{ return {hello=>'World'}}->()}\n"},{"out":"{hello => \"World\"}","err":"","code":"sub{ return {hello=>'World'}}->()\n"},{"err":"","code":"sub select {} sub from {}; select '*' from;\n","out":"ERROR: syntax error at (eval 1) line 1, near \"'*' from\"\n"},{"out":"ERROR: Not enough arguments for select system call at (eval 1) line 1, at EOF\n","code":"sub select {} sub from {}; select '*', from;\n","err":""},{"out":"[\"virtualization\",\"VBox\"]","code":"sub set { [ @_ ] }; set virtualization => \"VBox\";\n","err":""},{"out":"","err":"","code":"sub set { } set virtualization => \"VBox\";\n"},{"out":"a b c d","code":"sub show_args { print join \" \", @{$_[0]} } my @array1 = qw/a b c d/; my @array2 = qw/1 a 3 3 x/; show_args (\\@array1, \\@array2)\n","err":""},{"code":"sub show_args { print join \" \", @_ } my @array1 = qw/a b c d/; my @array2 = qw/1 a 3 3 x/; show_args (@array1, @array2)  # KURT__\n","err":"","out":"a b c d 1 a 3 3 x"},{"out":"[\"before\",\"about to skip\",\"after block\"]","code":"sub skip { last SOMEBLOCK } my @x = 'before'; SOMEBLOCK: { push @x, 'about to skip'; skip; push @x, 'after skip' } push @x, 'after block'; \\@x\n","err":""},{"out":"[undef]","err":"","code":"sub sneakysub { my %foo; while (each %foo) {} } local $_ = 25; sneakysub(); [$_]\n"},{"out":"5","code":"sub SOME_CONSTANT { 5 } my %hash = (thing => SOME_CONSTANT); $hash{thing}\n","err":""},{"out":"ERROR: DIE DIE DIE at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub sort { die \"DIE DIE DIE\"; } [ ::sort( 1,2,3 ) ]\n"},{"err":"","code":"sub sort { die \"DIE DIE DIE\"; } [ sort 1,2,3 ]\n","out":"[1,2,3]"},{"code":"sub sort { die \"DIE DIE DIE\"; } [ sort( 1,2,3 ) ]\n","err":"","out":"[1,2,3]"},{"err":"","code":"sub sreturn{} sreturn join(',', @accounts);\n","out":""},{"err":"","code":"sub STDOUT::autoflush { die \"Ohnoes!\" }   STDOUT->autoflush(1)\n","out":"0"},{"out":"trolled\nERROR: Can't locate object method \"print\" via package \"1\" (perhaps you forgot to load \"1\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub STDOUT() {say \"trolled\"} STDOUT->print(123)\n"},{"code":"sub STDOUT () { \\*STDOUT } STDOUT->print(123)\n","err":"","out":"1231"},{"code":"$_=\"ââââ\"; substr($_,0,1,''); $_\n","err":"","out":"ÃÂÃÂÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂ"},{"out":"11","code":"$_=\"ââââ\"; substr($_,0,1,''); length $_\n","err":""},{"err":"","code":"substr 193, 1, 1\n","out":"9"},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n","code":"substr \"4-9\", 1, 1, \"..\" and eval\n","err":""},{"code":"substr \"4-9\", 1, 1, \"..\" && eval\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"b\"]","err":"","code":"[substr 'abc', 1, -1 ]\n"},{"code":"substr \"abcde\", -1\n","err":"","out":"e"},{"out":"[\"four\"]","code":"[ substr \"four\", 0, 6 ]\n","err":""},{"out":"four","code":"substr \"four\", 0, 6\n","err":""},{"out":"hell","err":"","code":"substr(\"hello\", 0, -1)\n"},{"out":"Hello w","code":"substr \"Hello world\", 0, -4\n","err":""},{"err":"","code":"[ substr \"Keihanaikukauakahihulihe'ekahaunaele\", 0, 20 ] # or Hawaiian names\n","out":"[\"Keihanaikukauakahihu\"]"},{"out":"[\"flour\"]","err":"","code":"substr(my $F = \"four\",1,0,\"l\"); [$F]\n"},{"out":"[\"Z\"]","err":"","code":"[substr(\"qqz\", 2) =~ y/z/Z/r]\n"},{"code":"substr \"the_cool_string\", 5\n","err":"","out":"ool_string"},{"out":"[101001]","code":"[ substr unpack(\"b*\", pack \"H*\", \"AB12C0\"), 7, 6 ]\n","err":""},{"err":"","code":"substr(v1.2.3, 1)\n","out":"\u0002\u0003"},{"code":"$subst = \"s\\xc3\\xbc\\xc3\\x0fe\"; [ $subst, decode_utf8 $subst ]\n","err":"","out":"[\"s\\303\\274\\303\\17e\",\"s\\x{fc}\\x{fffd}\\17e\"]"},{"out":"[\"s\\303\\274\\303\\237e\",\"s\\x{fc}\\x{df}e\"]","code":"$subst = \"s\\xc3\\xbc\\xc3\\x9fe\"; [ $subst, decode_utf8 $subst ]\n","err":""},{"code":"sub { __SUB__ }\n","err":"","out":"sub { \"DUMMY\" }"},{"code":"sub { __SUB__ }->()\n","err":"","out":"sub { \"DUMMY\" }"},{"err":"","code":"sub swap { @_[0,1] = @_[1,0] } my $x = 'foo'; swap(substr($x, 2, 1), substr($x, 0, 1)); [ $x ]\n","out":"[\"oof\"]"},{"out":"[\"bar\",\"foo\"]","code":"sub swap { @_[0,1] = @_[1,0] } my ($x, $y) = qw(foo bar); swap($x, $y); [ $x, $y ]\n","err":""},{"out":"3","code":"sub t { 1, 2, 3 } t[0]\n","err":""},{"out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after , 2, 3 } t<-- HERE near column 110 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub t { 1, 2, 3 } tâ¦0â¦\n"},{"out":"42","err":"","code":"sub t { 1, 2, 42 } t[0]\n"},{"err":"","code":"sub t { 1, 2, 42 } t->[0][1]\n","out":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"][\"\n","code":"sub t { 1, 2, 42 } t[0][1]\n","err":""},{"out":"[1,2,3]","err":"","code":"sub take { my ($n, @arr) = @_; @arr[ 0 .. $n - 1 ]} [take 3, 1 .. 20]\n"},{"code":"sub test { \"don't do this\" }; [ test { 'main' } ]\n","err":"","out":"[\"don't do this\"]"},{"err":"","code":"sub test { \"foo\" } my %hash = (bar => test()); \\%hash\n","out":"{bar => \"foo\"}"},{"code":"sub test { print \"foo\" } my %hash = (bar => foo());\n","err":"","out":"ERROR: Undefined subroutine &main::foo called at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"sub test { print \"foo\" } my %hash = (bar => test());\n","out":"foo"},{"out":"ERROR: Illegal declaration of subroutine main::tle at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub tle <>\n"},{"out":"compliant","err":"","code":"sub t { \"non-compliant\", \"compliant\" } t[BS-6008]\n"},{"out":"compliant","code":"sub t { \"non-compliant\", \"compliant\" } t[ISO-3103]\n","err":""},{"err":"","code":"sub to_cases { map scalar /[[:upper:]]/, split //, shift }; sub caseify { my ($string, $re, $repl) = @_; $string =~ s[($re)][caseify( $repl, to_cases($1) )]ire }; caseify( \"DoÃ\" qr(doÃ), \"cat\" );\n","out":"ERROR: syntax error at (eval 1) line 1, near \"\"DoÃÂÃÂ\" qr(doÃÂÃÂ)\"\n"},{"out":"DoÃÂÃÂ","err":"","code":"sub to_cases { map scalar /[[:upper:]]/, split //, shift }; sub caseify { my ($string, $re, $repl) = @_; $string =~ s[($re)][caseify( $repl, to_cases($1) )]ire }; caseify( \"DoÃ\", qr(doÃ), \"cat\" );\n"},{"code":"sub to_cases { map scalar /[[:upper:]]/, split //, shift }; sub caseify { my ($string, $re, $repl) = @_; $string =~ s[($re)][caseify( $repl, to_cases($1) )]ire }; caseify( \"DoÃ\", qr(doÃ)i, \"cat\" );\n","err":"","out":"cat"},{"out":"lala","err":"","code":"sub trololo::b { \"lala\" }; $a = bless {}, \"trololo\"; $a->b\n"},{"out":"lala\n","code":"sub trololo::b { \"lala\" }; $a = bless {}, \"trololo\"; say $a->b\n","err":""},{"out":"true","code":"sub true { \"true\" }       my $requesturl = \"/register/?123\"; if($requesturl =~ m!register!io){ return true; }\n","err":""},{"out":"[\"blah blah \\\"3\\\" blah blah\"]","err":"","code":"sub unhexstr { (my $ret = shift) =~ s/\\\\x([0-9a-fA-F]{2})/chr hex $1/eg } my $str = q{blah blah \"\\x65\\x66\\x67\" blah blah}; $str =~ s/\"((?:\\\\x[0-9a-fA-F]{2})+)\"/'\"'.unhexstr($1).'\"'/eg; [$str]\n"},{"out":"[\"blah blah \\\"\\\\x65\\\\x66\\\\x67\\\" blah blah\"]","err":"","code":"sub unhexstr { (my $ret = shift) =~ s/\\x([0-9a-fA-F]{2})/chr hex $1/eg } my $str = q{blah blah \"\\x65\\x66\\x67\" blah blah}; $str =~ s/\"((?:\\x[0-9a-fA-F]{2})+)\"/'\"'.unhexstr($1).'\"'/eg; [$str]\n"},{"out":"[\"blah blah \\\"\\\\x65\\\\x66\\\\x67\\\" blah blah\"]","err":"","code":"sub unhexstr { (my $ret = shift) =~ s/\\x([0-9a-fA-F]{2})/chr hex $1/eg } my $str = q{blah blah \"\\x65\\x66\\x67\" blah blah}; $str =~ s/\"(\\x[0-9a-fA-F]{2}+)\"/'\"'.unhexstr($1).'\"'/eg; [$str]\n"},{"code":"sub unhexstr { (my $ret = shift) =~ s/\\\\x([0-9a-fA-F]{2})/chr hex $1/eg; $ret } my $str = q{blah blah \"\\x65\\x66\\x67\" blah blah}; $str =~ s/\"((?:\\\\x[0-9a-fA-F]{2})+)\"/'\"'.unhexstr($1).'\"'/eg; [$str]\n","err":"","out":"[\"blah blah \\\"efg\\\" blah blah\"]"},{"code":"sub (/user/:user_id) { $_{user_id} };\n","err":"","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(/user/\"\n"},{"out":"ERROR: Undefined subroutine &Sub::Util::prototoype called at (eval 1) line 1, <STDIN> line 1.\n","code":"Sub::Util::prototoype(\\&CORE::die)\n","err":""},{"err":"","code":"Sub::Util::prototype(\\&CORE::prototype)\n","out":"_"},{"code":"\"${\\sub { wantarray() ? 'list' : 'scalar' }->()}\"\n","err":"","out":"list"},{"out":"sub { \"DUMMY\" }","code":"sub { wantarray ? \"list\" : \"scalar\" }\n","err":""},{"out":"[[]]","err":"","code":"sub wa { print '[[' . wantarray . ']]' } split /x/, wa\n"},{"out":"ERROR: the fuck at (eval 1) line 1, <STDIN> line 1.\n","code":"sub what { } what / 25 ; # / ; die \"the fuck\";\n","err":""},{"code":"sub x (\\@) { \"$_[0]\" }; my @a = (3, 4); print x(@a); ()\n","err":"","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(\\\"\n"},{"err":"","code":"sub x { (1..3) } (x)[1]\n","out":"2"},{"out":"ERROR: Too many arguments for subroutine at (eval 1) line 1.\n","err":"","code":" sub x (){1}; x x x x x;\n"},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(_\"\n","err":"","code":"sub x (_) { \\@_ } $_ = 'a'; x\n"},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(_\"\n","code":"sub x (_) { \\@_ } $_ = 'a'; $_ x x\n","err":""},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(_\"\n","err":"","code":"sub x (_) { \\@_ } $_ = 'a'; x x x\n"},{"code":"sub x ($) { @_ }; my $x = \\&x; [ join ' ', $x->('a'..'c'), '|', x('a'..'c') ]\n","err":"","out":"ERROR: Too many arguments for subroutine at (eval 1) line 1.\n"},{"err":"","code":"sub x{my $y=$_; sub { $y++ } } $foo=x(2); [$foo->(),$foo->()]\n","out":"[0,1]"},{"out":"12\n","code":"sub x { return [[12, 13]]; } say +(@{x()}[0])[0][0];\n","err":""},{"out":"[12,13]","err":"","code":"sub x { return [[12, 13]]; }@{x()}[0]\n"},{"out":"12","code":"sub x { return [[12, 13]]; } @{x()}[0]->[0]\n","err":""},{"err":"","code":"sub x { return (1,2,3) } print( $x = x() );\n","out":"3"},{"code":"sub x { return (1,2,3) } print( $x = x() ); print 7;\n","err":"","out":"37"},{"out":"2","err":"","code":"sub x { return 2 if (defined shift); return 1 }; x(\"\\0\");\n"},{"out":"2","code":"sub x { return 2 if (defined shift) }; x(\\0);\n","err":""},{"out":"7","code":"sub x { return (7,8,9) } print( ($x) = x() );\n","err":""},{"code":"sub x { return (7,8,9) } print( $x = x() );\n","err":"","out":"9"},{"out":"main::x","code":"sub x {} Sub::Util::subname(\\&x)\n","err":""},{"code":"sub x { sub y { \"1\" } } y()\n","err":"","out":"ERROR: Transliteration replacement not terminated at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"sub x { sub Y { \"1\" } } Y()\n","err":"","out":"1"},{"code":"sub x {} x || die \"poop\"\n","err":"","out":"ERROR: poop at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"2","code":"sub xyz { my @foo = (10, 11); return @foo } $x = xyz(); $x\n","err":""},{"out":"","code":"sub yz { my $x = @_; return ref($x->[0]) }; return yz({blah=>1},'d');\n","err":""},{"err":"","code":"sub zeroMech { my $mech = shift; $mech->clear_credentials(); } sub buildMech { return zeroMech ( WWW::Mechanize->new() ); } my $mech = buildMech();\n","out":"ERROR: Can't locate object method \"new\" via package \"WWW::Mechanize\" (perhaps you forgot to load \"WWW::Mechanize\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"`sudo cpan -i Diagnostics`\n","err":"","out":""},{"code":"s///ugar\n","err":"","out":"ERROR: Regexp modifiers \"/u\" and \"/a\" are mutually exclusive at (eval 1) line 1, near \"; \"\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"sum grep\"\n","code":"sum grep { ($_ % 2) == 0 } @vals;\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"sum map\"\n","err":"","code":"sum map { 1 / $_ } ( 1,3,5,7,9,11,13,15,17 )\n"},{"err":"","code":"\"Su-Shee: I've never actually gotten a memo from memoserv so I don't know\"\n","out":"Su-Shee: I've never actually gotten a memo from memoserv so I don't know"},{"code":"@s/ // # whatever\n","err":"","out":"0"},{"code":"/(?<!SX)/i\n","err":"","out":"1"},{"code":"system \"echo\" \"list\";\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"\"echo\" \"list\"\"\n"},{"out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after /; system(<-- HERE near column 98 at (eval 1) line 1, <STDIN> line 1.\n","code":"system(âls /â);\n","err":""},{"err":"","code":"^T\n","out":"ERROR: syntax error at (eval 1) line 1, near \"; ^\"\n"},{"out":"ab34","err":"","code":"@t = (1,2,3,4); splice @t, 0,2, 'a','b'; print @t\n"},{"code":"@t = 1 .. 4; splice @t, 0, 2, qw(a b); \\@t\n","err":"","out":"[\"a\",\"b\",3,4]"},{"code":"\"tacos\"\n","err":"","out":"tacos"},{"out":"1","code":"\"\\t\" =~ /[[:cntrl:]]/\n","err":""},{"out":"3","err":"","code":"\"test123Wow\" =~ /^.*(\\d+).*$/g; $1\n"},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"test\" (1 line) at http://fpaste.scsys.co.uk/498962\n","err":""},{"out":"Test4","code":"$_ = \"Test4\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"; $_ =~ s/\\0+$//;  $_\n","err":""},{"out":"54.65.73.74.34","code":"$_ = \"Test4\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"; $_ =~ s/\\0+$//;  sprintf \"%v.02x\", $_\n","err":""},{"out":"[\"test.,best.\"]","code":"[ \"(test.,best.)\" =~ /\\(([\\w\\s,\\.]+)\\)/g ]\n","err":""},{"code":"\"testfile.csv\" =~ m/(\\.xls$|\\.xlsx$)/\n","err":"","out":""},{"code":"\"testfile.csv\" =~ m/(\\.xls$|\\.xlsx$)/ ? \"matches\" : \"doesn't match\"\n","err":"","out":"doesn't match"},{"err":"","code":"\"test\" =~ /foo || bar/\n","out":"1"},{"err":"","code":"[ \"test\\n\" =~ m/(.*?)$/s ]\n","out":"[\"test\"]"},{"err":"","code":"@test = qw(lala lulu); [\"test@test\", \"test\\@test\"]\n","out":"[\"testlala lulu\",\"test\\@test\"]"},{"err":"","code":"\"test\" =~ s`e`true`r\n","out":"ttruest"},{"out":"1","code":"@test = \"test\"; @_[0] =~ /test/ ? 1 : 0\n","err":""},{"code":"[ 'test' ] == [ 'test' ] ? \"equal\" : \"not equal\"\n","err":"","out":"not equal"},{"err":"","code":"$test->{Val} = 'cats'; $test\n","out":"{Val => \"cats\"}"},{"out":"testÃÂÃÂ§","err":"","code":"\"test\\x{327}\"\n"},{"err":"","code":"\"tes\\x{21b}\"\n","out":"tesÃÂÃÂ"},{"out":"","code":"<text>\n","err":""},{"out":"[1]","code":"[ 'text text blah text 123 ahoy there' =~ /blah.*\\Kahoy .*/ ]\n","err":""},{"code":"$_ = \"text with-hypenated word-like-things\"; s/(\\w+(?:-\\w+))/lc join \"\", map ucfirst, split \"-\", $1/ge; $_\n","err":"","out":"text withhypenated wordlike-things"},{"out":"text withhypenated wordlikethings","code":"$_ = \"text with-hypenated word-like-things\"; s/(\\w+(?:-\\w+)+)/lc join \"\", map ucfirst, split \"-\", $1/ge; $_\n","err":""},{"out":"thanks","err":"","code":"thanks\n"},{"out":"[\"the\",\"brown\",\"the\",\"brown\",\"fox\"]","code":"[ \"the brown dog jumps over the brown fox\" =~ /the|brown|fox/g ]\n","err":""},{"code":"[\"the brown fox jumps over the brown dog\" =~ m/brown|dog|the|b/g];\n","err":"","out":"[\"the\",\"brown\",\"the\",\"brown\",\"dog\"]"},{"out":"[\"the\",\"brown\",\"the\",\"dog\"]","code":"[\"the brown fox jumps over the lazy dog\" =~ m/brown|dog|the|b/g]\n","err":""},{"code":"[\"the brown fox jumps over the lazy dog\" =~ m/b|the|brown|dog/g]\n","err":"","out":"[\"the\",\"b\",\"the\",\"dog\"]"},{"out":"[\"the\",\"b\",\"the\",\"dog\"]","code":"[\"the brown fox jumps over the lazy dog\" =~ m/b|the|dog|brown/g]\n","err":""},{"out":"[\"cool_string\"]","code":"[ 'the_cool_string' =~ m[_(.*)] ]\n","err":""},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"\"the_cool_string =~ s/^[^_]+_//;\n"},{"err":"","code":"\"the_cool_string =~ s/^[^_]+_//r;\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"\"the_cool_string\" =~ s/^[^_]*_//r\n","out":"cool_string"},{"out":"cool_string","code":"\"the_cool_string\" =~ s/^[^_]+_//r;\n","err":""},{"code":"[ 'the_cool_string' =~ s/.*?_//r ]\n","err":"","out":"[\"cool_string\"]"},{"out":"[\"cool_string\"]","code":"[ 'the_cool_string' =~ s/the_//r ]\n","err":""},{"out":"","err":"","code":"\"the cow says hello\" =~ /^(the cow says) (moo )+$/\n"},{"code":"\"the cow says hello\" =~ /^(the cow says) (moo )+$/ ? \"Matches\" : \"Doesn't\"\n","err":"","out":"Doesn't"},{"out":"ERROR: Unknown regexp modifier \"/r\" at (eval 1) line 1, at end of line\nUnknown regexp modifier \"/e\" at (eval 1) line 1, at end of line\n","code":"/the/mreason\n","err":""},{"out":"[\"\",\"\",\"\",\" \",\"\",\"\",\"\",\"\",\"\",\" \",\"\",\"dog\",\" \",\"\",\"\",\"\",\"\",\"\",\"\"]","err":"","code":"[ \"the quick dog jumps\" =~ /\\s*|dog/g ]\n"},{"out":"just fantasy","code":"(\"the real life\", \"just fantasy\")[!!\"is this\"]\n","err":""},{"out":"the real life","err":"","code":"(\"the real life\", \"just fantasy\")[!\"is this\"]\n"},{"out":"[\"t\",\"a\",\"c\",\"o\",\" \",\"n\",\"i\",\"g\",\"h\",\"t\"]","err":"","code":"@thingies = split //, 'taco night'; [ @thingies ]\n"},{"out":"","err":"","code":"\"@things\"\n"},{"err":"","code":"\"<this> and that but not <other thing>\" =~ /<this>((?:(?!<other thing>).)*)/; $1\n","out":" and that but not "},{"out":"ERROR: Can't call method \"isa\" on an undefined value at (eval 1) line 1, <STDIN> line 1.\n","code":" $this->isa('#perl');\n","err":""},{"err":"","code":"\"This is a string\"\n","out":"This is a string"},{"code":"['{%this is a string%} and this is {% another string %}' =~ m/{%(.+?)%}/g];\n","err":"","out":"[\"this is a string\",\" another string \"]"},{"out":"[{},{lala => \"is\"}]","err":"","code":"'this is a string' =~ /(?<lala>is)/; [\\ %+, {%+}] # funny behavior of %+\n"},{"code":"'{%this is a string%}' =~ m/{%(.+?)%}/; $1;\n","err":"","out":"this is a string"},{"err":"","code":"'{%this is\\%} a string%}' =~ m/{%(.+?)%}/; $1;\n","out":"this is\\"},{"out":"[\"this\\n is \\na st\\nring\\n\"]","err":"","code":"[ 'this is a string' =~ s/.{4}\\K/\\n/gr ]\n"},{"err":"","code":"[ 'this-is-a-string-with-9-something-3ls3' ]\n","out":"[\"this-is-a-string-with-9-something-3ls3\"]"},{"err":"","code":"[ 'this-is-a-string-with-9-something-3ls3' =~ tr/-/ /r ]\n","out":"[\"this is a string with 9 something 3ls3\"]"},{"err":"","code":"[ \"this is (a test,a problem)\" =~ /(?:.*\\()?([^,()]+)(?:\\).*)?/g ]\n","out":"[\"a test\",\"a problem\"]"},{"out":"[\"a test\",\"a problem\"]","err":"","code":"[ \"this is (a test,a problem)\" =~ s/.*\\(|\\).*//gr =~ /[^,]+/g ]\n"},{"out":"[\"a test\",\"a problem\"]","code":"[ \"this is (a test,a problem)\" =~ /(?:.*\\()?([\\w ]+)(?:\\).*)?/g ]\n","err":""},{"out":"[\"a test\",\"a problem\"]","err":"","code":"[ \"this is (a test,a problem)\" =~ /(?:.*\\()?([\\w ]+)(?:\\).*)?/g ] # in one regex and nothing extra :)\n"},{"code":"[ \"this is a test foo\" =~ /((?:(?!test|a)[\\w ])+)/ ] #does this work?\n","err":"","out":"[\"this is \"]"},{"err":"","code":"[ \"this is a test foo\" =~ /((?:(?!test)[\\w ])+)/ ] # if you want the space after the a\n","out":"[\"this is a \"]"},{"out":"[\"this is a\"]","code":"[ \"this is a test foo\" =~ /((?:(?! test)[\\w ])+)/ ] #well you can just do this then\n","err":""},{"out":"[\"t\"]","err":"","code":"[ \"this is a test foo\" =~ /([\\w ]+?)(?: test)?/ ]\n"},{"code":"[ \"this is a test foo\" =~ /([\\w ]+) (?:test)?/ ]\n","err":"","out":"[\"this is a test\"]"},{"out":"[\"this is a test foo\",undef]","code":"[ \"this is a test foo\" =~ /([\\w ]+)( ?:test)?/ ]\n","err":""},{"code":"[ \"this is a test foo\" =~ /([\\w ]+)(?: test)?/ ]\n","err":"","out":"[\"this is a test foo\"]"},{"out":"[\"this\"]","err":"","code":"[ \"this is a test foo\" =~ /(\\w+) (?:test)?/ ]\n"},{"out":"[1]","err":"","code":"[ \"this is a test foo\" =~ /\\w+ (?:test)?/ ]\n"},{"out":"this is a test","err":"","code":"\"this is a test foo\" =~ /([\\w ]+) (?:test)?/; $1\n"},{"code":"[ \"this is a test foo\" =~ /((?:[\\w ](?!test))+)/ ] # is this the kind of thing you're looking for ?\n","err":"","out":"[\"this is a\"]"},{"out":"[\"this is a\"]","code":"[ \"this is a test foo\" =~ /((?:[\\w ](?!test|yutz|butz))+)/ ]\n","err":""},{"out":"[\"this is a test of\",\" a few words off the front with trailing text.\"]","err":"","code":"[ 'this is a test of a few words off the front with trailing text.' =~ /((?:\\s*\\w+){0,5})(.*)/s ]\n"},{"out":"[\"this is a test of\",\" a few words off the front with trailing text.\"]","code":"[ 'this is a test of a few words off the front with trailing text.' =~ /((?:\\W*\\w+){0,5})(.*)/s ]  # s/s/W/ better\n","err":""},{"out":"","code":"$this =~ /is/; $perl;\n","err":""},{"out":"this is what I wanted, without the outer @ { } bit:  2 baz 1 bar 0 foo","err":"","code":"\"this is what I wanted, without the outer @ { } bit:  @{ [ %{ [qw/ foo bar baz /] }[2,1,0] ] }\"\n"},{"out":"[1]","err":"","code":"[ 'this' =~ m|this\\|that|m ];\n"},{"code":"[ 'this' =~ m,this\\|that,m ];\n","err":"","out":"[]"},{"code":"$_ = 'this repeated word is repeated again along with the word again'; [ /(.{3,})(?=.*?\\1)/g ] # buu  :)\n","err":"","out":"[\"is repeated \",\"word \",\"d again\"]"},{"err":"","code":"\"This\" =~ s/(.)/sprintf \"%b \", ord $1/gre\n","out":"1010100 1101000 1101001 1110011 "},{"err":"","code":"\\&this_sub_doesnt_exist\n","out":"sub { \"DUMMY\" }"},{"err":"","code":"tie *STDOUT, 'foo'; sub foo::new { return bless {} } sub foo::print { print \"TEST\" } print \"hello\"\n","out":"ERROR: Can't locate object method \"TIEHANDLE\" via package \"foo\" at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","err":"","code":"tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {},'foo' } sub foo::PRINT { return 42 } print \"hello\"\n"},{"out":"","err":"42 at (eval 1) line 1, <STDIN> line 1.\n","code":"tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {},'foo' } sub foo::PRINT { warn 42 } print \"\"\n"},{"out":"","err":"42 at (eval 1) line 1, <STDIN> line 1.\n","code":"tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {},'foo' } sub foo::PRINT { warn 42 } print \"hello\"\n"},{"code":"tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {},shift } sub foo::PRINT { print \"TEST\" } print \"hello\"\n","err":"Out of memory!\n","out":""},{"err":"Can't locate object method \"PRINT\" via package \"main\" at /home/ryan/bots/perlbuut/lib/eval.pl line 279, <STDIN> line 1.\n","code":"tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {} } sub foo::print { print \"TEST\" } print \"hello\"\n","out":""},{"out":"","err":"Can't locate object method \"PRINT\" via package \"main\" at /home/ryan/bots/perlbuut/lib/eval.pl line 279, <STDIN> line 1.\n","code":"tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {} } sub foo::PRINT { print \"TEST\" } print \"hello\"\n"},{"out":"tm605","code":"$_ = \"tm604\"; $_++; $_\n","err":""},{"err":"","code":"\"tm604\" + 1\n","out":"1"},{"out":"I am a link","code":"$toolType = 'foo'; $fooLink = 'I am a link'; ${$toolType . 'Link'}\n","err":""},{"code":"@topics = qw/alias:topic topic2 topic/; [ map { (/^alias:/ ? $_ : \"alias:$_\") => $_ } @topics ]\n","err":"","out":"[\"alias:topic\",\"alias:topic\",\"alias:topic2\",\"topic2\",\"alias:topic\",\"topic\"]"},{"err":"","code":"@topics = qw/alias:topic topic2 topic/; %t = map { (/^alias:/ ? $_ : \"alias:$_\") => $_ } @topics; \\%t\n","out":"{\"alias:topic\" => \"topic\",\"alias:topic2\" => \"topic2\"}"},{"err":"","code":"@topics = qw/topic topic2 alias:topic/; %t = map { (/^alias:/ ? $_ : \"alias:$_\") => $_ } @topics; \\%t\n","out":"{\"alias:topic\" => \"alias:topic\",\"alias:topic2\" => \"topic2\"}"},{"out":"2","err":"","code":"\"--\" =~ tr/-/-/\n"},{"code":"\"--\" =~ tr/-/-1/\n","err":"","out":"ERROR: Can't modify constant item in transliteration (tr///) at (eval 1) line 1, at EOF\n"},{"code":"tree == stone? yes : no\n","err":"","out":"ERROR: \"no\" not allowed in expression at (eval 1) line 1, near \": \"\nsyntax error at (eval 1) line 1, near \": no\n\"\n"},{"out":"/","err":"","code":"\"////\" =~ tr!/!!sr\n"},{"out":"","code":"`true`\n","err":""},{"out":"1","code":"'true' == 0 #dbolser, here's something to illustrate your error\n","err":""},{"err":"","code":"' ' ? 'true' : 'false'\n","out":"true"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"' ' ? 'true' ? 'false'\n","err":""},{"err":"","code":"[ '' ? 'true' : 'false' ]\n","out":"[\"false\"]"},{"code":"[ true == false ]\n","err":"","out":"[1]"},{"err":"","code":"{} ? \"true\" : \"false\"\n","out":"true"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"&({\"\n","code":"&({})? \"true\" : \"false\"\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"&{\"\n","code":"&{}? \"true\" : \"false\"\n","err":""},{"code":"\"TRUE\" if \"\\0\\0\"\n","err":"","out":"TRUE"},{"code":"\"\\t\" =~ /\\s/\n","err":"","out":"1"},{"out":"1","err":"","code":"'tshaper.3.input.rate' =~ /(tshaper\\.\\d\\.(?:input|output)\\.rate)/\n"},{"out":"1","code":"'tshaper.3.output.rate' =~ /(tshaper\\.\\d\\.(?:input|output)\\.rate)/\n","err":""},{"out":"[\"\"]","err":"","code":"[ -t \\*STDERR ]\n"},{"err":"","code":"[ -t \\*STDOUT ]\n","out":"[\"\"]"},{"out":"test","err":"","code":"$t = \"test\"\n"},{"out":"banana","err":"","code":"$t = \"This string is multi-line\\nLine 2\\n Last word is banana\"; $t =~ s/.*(?=\\b\\w+\\Z)//s; $t\n"},{"err":"","code":"$t = \"This string is multi-line\\nLine 2\\n Last word is banana\"; $t =~ s/(?s:.*)(?=\\b\\w+\\Z)//; $t # if you can't put a /s modifier\n","out":"banana"},{"out":"banana","err":"","code":"$t = \"This string is multi-line\\nLine 2\\n Last word is banana\"; ($t) = $t =~ /(\\S+)\\Z/; $t\n"},{"code":"\"Two plus Two is \" . ( 2 + 2 )\n","err":"","out":"Two plus Two is 4"},{"err":"","code":"two + two == five ? \"true\" : \"false\"\n","out":"true"},{"code":"$type=\"a\"; $stationId=\"b\"; [ grep { /$type/ && /$stationId/ } qw/abc cat bat/ ]\n","err":"","out":"[\"abc\",\"bat\"]"},{"out":"","code":"$^U\n","err":""},{"out":"[\"\\303\\274\"]","err":"","code":"[ \"Ã¼\" ]\n"},{"code":"\"\\u0265\\u01DD\\u028E\"\n","err":"","out":"026501DD028E"},{"err":"","code":"\"\\UaÃ¤\" # looks right to me, lustiger_seth\n","out":"AÃÂÃÂ¤"},{"out":"Strstr","err":"","code":"ucfirst 'str_str' =~ tr/_//dr;\n"},{"err":"","code":"ucfirst 'str_str' =~ tr/_/ /r;\n","out":"Str str"},{"err":"","code":"[uc \"hello corin\"]\n","out":"[\"HELLO CORIN\"]"},{"out":"UTF-32","err":"","code":"\"UCS-4\" =~ s/^UCS-?4-?(BE|LE|)?$/UTF-32\\U$1/ir\n"},{"out":"ÃÂÃÂ","err":"","code":"uc 'Ã'\n"},{"code":"uc \"Ã\"\n","err":"","out":"ÃÂÃÂ"},{"err":"","code":"u eq n\n","out":""},{"err":"","code":"[\"\\Ufoo\", \"\\ufoo\"]\n","out":"[\"FOO\",\"Foo\"]"},{"out":"Hello","err":"","code":"\"\\uhello\"\n"},{"err":"","code":"`uname -a`\n","out":""},{"err":"","code":"undef\n","out":""},{"out":"","code":"''.undef\n","err":""},{"err":"","code":"'\\undef'\n","out":"\\undef"},{"code":"undef // []\n","err":"","out":"[]"},{"code":"[ undef == 0]\n","err":"","out":"[1]"},{"code":"[ undef => 1 ]\n","err":"","out":"[\"undef\",1]"},{"code":"[ undef != 1 ]\n","err":"","out":"[1]"},{"out":"[1]","err":"","code":"[(undef) + 1]\n"},{"err":"","code":"undef=>1\n","out":"1"},{"err":"","code":"undef + 1\n","out":"ERROR: Can't modify constant item in undef operator at (eval 1) line 1, at EOF\n"},{"err":"","code":"undef // 2\n","out":"2"},{"out":"ERROR: Can't locate object method \"undefined\" via package \"function\" (perhaps you forgot to load \"function\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"undefined function these\n"},{"err":"","code":"$undefined =~ s//bar/;\n","out":"1"},{"err":"","code":"undef my $x;\n","out":""},{"err":"","code":"[ undef | 'n', 0 | 'n', \"0\" | 'n' ]\n","out":"[\"n\",0,\"~\"]"},{"out":"ERROR: Not a SCALAR reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"(\\undef)->${ +sub { 'here' } }\n"},{"out":"here","err":"","code":"undef->${ \\sub { 'here' } }\n"},{"err":"","code":"undef->${ +sub { 'here' } }\n","out":"ERROR: Not a SCALAR reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"false","code":"undef ? true : false\n","err":""},{"out":"[undef,\"\"]","err":"","code":"[undef, ''.undef]\n"},{"err":"","code":"undef $_ = undef\n","out":""},{"out":"undef","err":"","code":"$undef=undef; print $undef ? 'true' : 'undef';\n"},{"code":"$undef=undef; print $undef ? 'true' : 'undef'; print \"ERROR: $!\";\n","err":"","out":"undefERROR: Too many open files"},{"code":"$undef=undef; print $undef ? 'undef' : 'true';\n","err":"","out":"true"},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"[undef undef undef]\n"},{"code":"undef->{Val} = 'cats'; $test\n","err":"","out":"ERROR: Can't use an undefined value as a HASH reference at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"Unicode::UCD::charinfo('x')\n","out":"ERROR: Undefined subroutine &Unicode::UCD::charinfo called at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"[ UNIVERSAL->can(\"import\") ]\n","err":"","out":"[undef]"},{"out":"[\"\\303\\274nix\",\"\\303\\274nix\"]","err":"","code":"[ \"Ã¼nix\", glob \"Ã¼nix\" ] # an amusingly-useful one, pls to not be killing it\n"},{"out":"0","err":"","code":"unlink '/'\n"},{"out":"0","err":"","code":"unlink \"Jello\"\n"},{"err":"","code":"unlink '/' or $!\n","out":"Is a directory"},{"out":"[\"00\",\"02\",\"02\",\"05\",\"6D\",\"4C\"]","code":"[ unpack \"(a2)*\", \"000202056D4C\" ]\n","err":""},{"code":"[ unpack \"(a2)8\", \"here is a very long string that is too long for a mere sixteen characters\" ]\n","err":"","out":"[\"he\",\"re\",\" i\",\"s \",\"a \",\"ve\",\"ry\",\" l\"]"},{"out":"[\"fo\",\"o \",\"ba\",\"r\"]","code":"[ unpack '(a2)*', 'foo bar' ]\n","err":""},{"err":"","code":"[ unpack '(a3)*', '1234567890' ]\n","out":"[123,456,789,0]"},{"out":"[\"Hell\",\"o, w\",\"orld\",\"!\"]","err":"","code":"[ unpack \"(A4)*\", \"Hello, world!\" ]\n"},{"out":"[\"3b00\",\"1a28\",1100,\"0012\",\"0000\",\"0000\",\"0000\",\"0046\"]","err":"","code":"[ unpack \"(a4)*\", reverse \"6.4.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.1.0.0.0.0.1.1.8.2.a.1.0.0.b.3\" =~ tr/.//dr ]\n"},{"out":"[\"this\",\"isat\",\"est\"]","code":"[ unpack \"(a4)*\", \"thisisatest\" ]\n","err":""},{"code":"[ unpack \"a8\", \"ABCD\" ]\n","err":"","out":"[\"ABCD\"]"},{"code":"[unpack(\"b*\",\"01010\")]\n","err":"","out":"[\"0000110010001100000011001000110000001100\"]"},{"out":"[\"0011000000110001001100000011000100110000\"]","code":"[unpack(\"B*\",\"01010\")]\n","err":""},{"code":"unpack \"b\", 0.21875\n","err":"","out":"0"},{"out":"00001100011101000100110010001100000111001110110010101100","code":"unpack \"b*\", 0.21875\n","err":""},{"out":"0011000100111000001101000011010000110110001101110011010000110100001100000011011100110011001101110011000000111001001101010011010100110001001101100011000100110101","code":"unpack 'B*', ~0 # maybe?\n","err":""},{"err":"","code":"[ unpack 'B8', 0x5A ] # see perldoc perlpacktut\n","out":"[\"00111001\"]"},{"err":"","code":"unpack \"b\",87381\n","out":"0"},{"err":"","code":"unpack \"(b8)*\", split ' ', \"text\"\n","out":"10001100"},{"code":"[ unpack '(b8)*', 'This' ]\n","err":"","out":"[\"00101010\",\"00010110\",10010110,11001110]"},{"err":"","code":"unpack \"b*\", $entry )\n","out":"ERROR: syntax error at (eval 1) line 1, near \"$entry )\n\"\n"},{"out":"1011110111111111111111111111111111111111111111111111011111111100","code":"unpack \"b*\",(pack \"d\", 0.9999999999999926)\n","err":""},{"err":"","code":"[ unpack \"b*\", pack \"H*\", \"AB12C0\" ]\n","out":"[\"110101010100100000000011\"]"},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"unpack \"b*\",\"$phrase\"\"\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"\"$phrase\" into a \"\n","err":"","code":"unpack \"b*\",\"$phrase\" into a variable\n"},{"out":"01010100011010000110100101110011","code":"unpack \"B*\", \"This\"\n","err":""},{"out":"0010101000010110100101101100111000000100100101101100111000000100100001100000010000101110101001101100111000101110","err":"","code":"unpack \"b*\", \"This is a test\"\n"},{"err":"","code":"[ unpack 'B', 'wibble' ]\n","out":"[0]"},{"out":"[\"011101110110100101100010011000100110110001100101\"]","err":"","code":"[ unpack 'B*', 'wibble' ]\n"},{"out":"49","err":"","code":"unpack \"%c\", '1'\n"},{"out":"[104,101,108,108,111]","code":"[ unpack \"(C2)*\", \"hello\" ]\n","err":""},{"err":"","code":"unpack \"%c\", 'a'\n","out":"97"},{"out":"[97,98,99,100]","code":"[unpack \"C*\", \"abcd\"]\n","err":""},{"out":"[97,115,99,105,105]","code":"[ unpack \"C*\", \"ascii\" ]\n","err":""},{"err":"","code":"[ unpack \"C*\", \"hello\" ]\n","out":"[104,101,108,108,111]"},{"code":"unpack \"C*\", pack \"n\", 945\n","err":"","out":"3"},{"out":"-128","code":"unpack('C', \"\\x80\") - 256\n","err":""},{"out":"3030303031633030","err":"","code":"unpack 'H*', '00001c00';\n"},{"out":"313239","code":"unpack(\"H*\", 0x81)\n","err":""},{"err":"","code":"unpack 'H*', \"\\1\\2\\3\\4\"\n","out":"01020304"},{"out":"a3","err":"","code":"unpack \"h2\", \":\"\n"},{"code":"unpack \"H2\", \":\"\n","err":"","out":"3a"},{"out":"00","err":"","code":"unpack '(H2)4', pack 'V', 1835008\n"},{"err":"","code":"[ unpack \"H2H*\", \"like this\" ]\n","out":"[\"6c\",\"696b652074686973\"]"},{"out":"3c","code":"unpack \"h2\", \"Ã¶\"\n","err":""},{"err":"","code":"unpack '(H2)*', pack 'V', 1835008\n","out":"00"},{"out":"[70,72,65,61,63,74,69,\"6f\",\"6e\"]","code":"[ unpack \"(H2)*\", \"preaction\" ]\n","err":""},{"err":"","code":"unpack \"(H2)*\", \"preaction\"\n","out":"70"},{"out":"[\"194609193239\"]","err":"","code":"[ unpack \"H*\", \"\\31F\\t\\03129\" ]\n"},{"out":"4313","code":"unpack 'h*', '41'\n","err":""},{"out":"3431","err":"","code":"unpack 'H*', '41'\n"},{"out":"55000000","err":"","code":"unpack(\"H8\", pack(\"V8\",85))\n"},{"out":"39653962393239363931","err":"","code":"unpack \"H*\", '9e9b929691'\n"},{"err":"","code":"unpack 'H*', 'aÌ'\n","out":"61cc80"},{"out":"c3a0","code":"unpack 'H*', 'Ã '\n","err":""},{"out":"5a","code":"unpack(\"H*\", chr(1446686042));\n","err":""},{"code":"unpack 'H*', chr(18).chr(44)\n","err":"","out":"122c"},{"out":"0","code":"unpack '(HH)*', pack 'V', 1835008\n","err":""},{"out":"0500041a001500","err":"","code":"unpack \"H*\", (\"kitties\" ^ \"nipnips\")\n"},{"code":"[ unpack 'H*', pack 'F', (9/10-1)*100 ]\n","err":"","out":"[\"ffffffffffff23c0\"]"},{"code":"unpack 'H*', pack 'h*', 123456\n","err":"","out":"214365"},{"code":"unpack \"H*\", pack \"NV\", 945, 945\n","err":"","out":"000003b1b1030000"},{"code":"unpack \"H*\", v127.0.0.1\n","err":"","out":"7f000001"},{"out":"2231","err":"","code":"unpack \"H*\", \"\\x{22}\\x{31}\"\n"},{"out":"[5,4,3]","err":"","code":"[ unpack \"i<3\", \"\\x05\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x3\\x00\\x00\\x00\" ]\n"},{"out":"[5]","code":"[ unpack \"i<\", \"\\x05\\x00\\x00\\x00\" ]\n","err":""},{"out":"[83886080]","err":"","code":"[ unpack \"i>\", \"\\x05\\x00\\x00\\x00\" ]\n"},{"out":"[17]","code":"[ unpack \"l>\", \"\\0\\0\\0\\cQ\" ]\n","err":""},{"err":"","code":"unpack \"l<\", 0x00.0x00.0x72.0x00\n","out":"825307184"},{"code":"unpack \"l\", 0x00.0x00.0x72.0x00\n","err":"","out":"825307184"},{"out":"[1701995880,544434464,1702240353,1814067570]","code":"[ unpack \"(L)4\", \"here is a very long string that is too long for a mere sixteen characters\" ]\n","err":""},{"out":"7471104","code":"unpack \"l<\", \"\\x00\\x00\\x72\\x00\"\n","err":""},{"err":"","code":"unpack \"l>\", \"\\x00\\x00\\x72\\x00\"\n","out":"29184"},{"code":"unpack \"l\", \"\\x00\\x00\\x72\\x00\"\n","err":"","out":"7471104"},{"out":"6","err":"","code":"unpack \"l<\", \"\\x06\\x00\\x00\\x00\";\n"},{"code":"unpack \"n\", 945\n","err":"","out":"14644"},{"out":"16725","err":"","code":"unpack \"n\", \"AU\"\n"},{"err":"","code":"[ -~unpack 'N', join '', map chr, '192.168.254.43' =~ /\\d+/g ]\n","out":"[\"-1.84467440704773e+19\"]"},{"code":"[ unpack 'N!', join '', map chr, '192.168.254.43' =~ /\\d+/g ]\n","err":"","out":"['-1062666709']"},{"code":"[ unpack 'N!', pack 'C4', split /\\./, '192.168.254.43' ]\n","err":"","out":"['-1062666709']"},{"out":"49408","code":"unpack 'N', pack 'h*', '00001c00';\n","err":""},{"out":"7168","code":"unpack 'N', pack 'H*', '00001c00';\n","err":""},{"err":"","code":"[ unpack \"n*\", \"\\x41\\x42\\x43\\x44\" ]\n","out":"[16706,17220]"},{"err":"","code":"[ unpack \"(Q)4\", \"here is a very long string that is too long for a mere sixteen characters\" ]\n","out":"['2338328219397285224','7791360887586431073','7598263559141158511','2338601207764903790']"},{"out":"[\"00000100\"]","err":"","code":"[ unpack q{(B8)*}, pack q{C*}, 260 ] ### Why is this only printing one byte when 260 consumes two (8-bit) bytes ?\n"},{"out":"[\"30b0\",\"0000\",\"10a0\",2080,1010,\"0000\",\"0000\",1020,\"0000\",\"0000\",\"0000\",\"0000\",\"0000\",\"0000\",\"0000\",4060]","err":"","code":"[ unpack q{(h4)*}, pack q{(h2)*}, split /\\./, reverse q{6.4.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.1.0.0.0.0.1.1.8.2.a.1.0.0.b.3} ]\n"},{"err":"","code":"[ unpack q{N}, pack q{H8}, q{6060FF} ] # alanjf\n","out":"[1616969472]"},{"code":"[ unpack q{N*}, pack q{H*}, q{6060FF} ];\n","err":"","out":"[]"},{"err":"","code":"unpack( \"q>\", pack \"H*\", \"000001448e317907\" ) / 1000\n","out":"1393955010.823"},{"code":"[ unpack 'q', \"\\xff\" x 8 ]\n","err":"","out":"[-1]"},{"code":"[ unpack \"(S)4\", \"here is a very long string that is too long for a mere sixteen characters\" ]\n","err":"","out":"[25960,25970,26912,8307]"},{"err":"","code":"unpack \"V\", \"1703\"\n","out":"858797873"},{"out":"12648448","err":"","code":"unpack 'V', pack 'h*', '00001c00';\n"},{"err":"","code":"unpack 'V', pack 'H*', '00001c00';\n","out":"1835008"},{"code":"unpack \"V\", \"\\x17\\x03\\x01\\x00\"\n","err":"","out":"66327"},{"err":"","code":"unpack \"v\", \"\\x52\\x12\"\n","out":"4690"},{"out":"[216]","code":"[ unpack \"v\", \"\\xd8\\x00\" ]\n","err":""},{"out":"127.0.0.1","err":"","code":"$_=\"us 127.0.0.1 8000\"; (split)[1]\n"},{"code":"usa {STDOUT} 'IO::Handle';\n","err":"","out":"ERROR: Can't locate object method \"usa\" via package \"IO::File\" at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","code":"use 0 warnings;\n","err":""},{"out":"ERROR: Perl v10.0.0 required--this is only v5.24.0, stopped at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use 10;\n"},{"code":"use 1 strict;\n","err":"","out":""},{"err":"","code":"use 2 Moose;\n","out":""},{"out":"ERROR: Can't locate threads.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use 2 threads;\n","err":""},{"out":"ERROR: Can't locate strictures.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use 3 strictures;\n","err":""},{"err":"","code":" use 5.006_001;\n","out":""},{"out":"","err":"","code":"use 5.010;\n"},{"err":"","code":"use 5.010; my $str = \"foo:12 bar:34 baz:45\"; $str =~ /foo:(?<foo>\\d+) bar:(?<bar>\\d+) baz:(?<baz>\\d+)/; \\%+\n","out":"{}"},{"err":"","code":"use 5.010; my $x = 42; [  map { my $y = $x++; $y } 0..3 ];\n","out":"[42,43,44,45]"},{"out":"[42,42,42,42]","code":"use 5.010; my $x = 42; [  map { state $y = $x++; $y } 0..3 ];\n","err":""},{"err":"","code":"use 5.010; say((\"a\" x 100000) =~ /^(ab?)*$/ ? \"Yes\" : \"No\");\n","out":"No\n"},{"out":"Yes\n","err":"","code":"use 5.010; say((\"a\" x 10000) =~ /^(ab?)*$/ ? \"Yes\" : \"No\");\n"},{"err":"","code":"use 5.010; say `ls -a`;\n","out":"\n"},{"code":"use 5.010; say \"one\"; say \"two\"\n","err":"","out":"one\ntwo\n"},{"out":"[41,41,1,1,1,1,75,75,\"zof!\",\"zof!\",\"zof!\"]","code":"use 5.010; sub foo { state $foo = 123; @_ and $foo = shift; $foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo(\"zof!\"), foo, foo]\n","err":""},{"out":"[123,41,41,1,1,1,1,75,75,\"zof!\",\"zof!\",\"zof!\"]","code":"use 5.010; sub foo { state $foo = 123; @_ and $foo = shift; $foo }; [ foo, foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo(\"zof!\"), foo, foo]\n","err":""},{"code":"use 5.010; sub foo { state $foo = shift; @_ and $foo = shift;$foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo(\"zof!\"), foo, foo]\n","err":"","out":"[41,41,1,1,1,1,75,75,\"zof!\",\"zof!\",\"zof!\"]"},{"code":"use 5.010; sub foo { state $foo = shift; if ( @_ ) { $foo = shift; } $foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo(\"zof!\"), foo, foo]\n","err":"","out":"[41,41,1,1,1,1,75,75,\"zof!\",\"zof!\",\"zof!\"]"},{"err":"","code":"use 5.010; sub x :lvalue {state $x; $x} x = 1; { local x = 3; print $x } $x\n","out":""},{"out":"3","err":"","code":"use 5.010; sub x :lvalue { $x; $x} x = 1; { local x = 3; print $x } $x\n"},{"out":"1","code":"use 5.012; $foo = 'bar'; ++$$foo; $bar\n","err":""},{"out":"1","code":"use 5.012; ++$x\n","err":""},{"out":"foo","code":"use 5.014; $foo = 'foo'\n","err":""},{"out":"4","err":"","code":"use 5.014; state $x = 4; $x\n"},{"code":"use 5.014; $x = 5\n","err":"","out":"5"},{"out":"[\"main\",undef]","code":"use 5.01600; [__PACKAGE__, __SUB__]\n","err":""},{"code":"use 5.016; ++$x\n","err":"","out":"1"},{"err":"","code":"use 5.018; my %hash;  push $hash{key}, \"more\";  \\%hash\n","out":"ERROR: Experimental push on scalar is now forbidden at (eval 1) line 1, at EOF\n"},{"out":"1","code":"use 5.018; print fc(\"Å\") cmp fc(\"z\")\n","err":""},{"out":"1","err":"error message\n","code":"use 5.01; say STDERR \"error message\";\n"},{"out":"","code":"use 5.020; fc('er') eq fc('3r')\n","err":""},{"code":"use 5.020; fc('er') eq fc('er')\n","err":"","out":"1"},{"err":"","code":"use 5.020; fc('er') eq fc('Er')\n","out":"1"},{"code":"use 5.020; [ fc 'foo' ]; # how do I do this on an older perl?\n","err":"","out":"[\"foo\"]"},{"out":"[\"\\343\\237\"]","code":"use 5.020; [ fc 'Ã' ];\n","err":""},{"err":"","code":"use 5.020; [ fc 'Ã' ]; # <BenGoldberg>\n","out":"[\"\\343\\237\"]"},{"code":"use 5.020; [ fc('Ã') eq fc('ss') ];\n","err":"","out":"[\"\"]"},{"code":"use 5.020; [ fc \"\\xdf\" ]\n","err":"","out":"[\"ss\"]"},{"err":"","code":"use 5.020; $foo = 'bar'; ++$$foo; $bar\n","out":"1"},{"err":"","code":"use 5.020; $foo = 'foo'\n","out":"foo"},{"out":"foobar","err":"","code":"use 5.020; for ( [qw/foo bar/]->@* ) { print}\n"},{"out":"123","code":"use 5.020; map print, [1,2,3]->@*\n","err":""},{"out":"[0,\"a\",1,\"b\",2,\"c\"]","err":"","code":"use 5.020; my @a = 'a'..'c'; [ %a[0..2] ]\n"},{"err":"","code":"use 5.020; my @a = 'a'..'c'; forhash my ($x, $y) (%a[0..2]) { say \"$x: $y\" }\n","out":"ERROR: syntax error at (eval 1) line 1, near \"forhash my \"\n"},{"out":"[0,\"a\",1,\"b\",2,\"c\",3,\"d\",4,\"e\",5,\"f\",6,\"g\",7,\"h\",8,\"i\",9,\"j\",10,\"k\",11,\"l\",12,\"m\",13,\"n\",14,\"o\",15,\"p\",16,\"q\",17,\"r\",18,\"s\",19,\"t\",20,\"u\"]","err":"","code":"use 5.020; my @a = 'a'..'z'; [ %a[0..20] ]\n"},{"out":"u","err":"","code":"use 5.020; my @a = 'a'..'z'; { %a[0..20] }; # not in order\n"},{"out":"{16 => \"q\",7 => \"h\",5 => \"f\",3 => \"d\",2 => \"c\",9 => \"j\",17 => \"r\",1 => \"b\",4 => \"e\",8 => \"i\",14 => \"o\",13 => \"n\",6 => \"g\",12 => \"m\",15 => \"p\",20 => \"u\",19 => \"t\",10 => \"k\",11 => \"l\",0 => \"a\",18 => \"s\"}","err":"","code":"use 5.020; my @a = 'a'..'z'; +{ %a[0..20] }; # not in order\n"},{"out":"","err":"","code":"use 5.020; open 'file'\n"},{"out":"ERROR: Malformed prototype for main::add: $x = return 0, $y = return $x at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use 5.020; sub add ($x = return 0, $y = return $x) { return $x + $y }   [ add(), add(2), add(2,3)  ]\n"},{"err":"","code":"use 5.020; use feature 'postderef'; no warnings 'experimental::postderef'; for ( [qw/foo bar/]->@* ) { print}\n","out":"foobar"},{"out":"","err":"Use of uninitialized value in open at (eval 1) line 1, <STDIN> line 1.\n","code":"use 5.020; use warnings; open 'file'\n"},{"code":"use 5.021011; say \"hi\"\n","err":"","out":"hi\n"},{"out":"foo","err":"","code":"use 5.022; $foo = 'foo'\n"},{"code":"use 5.10;\n","err":"","out":"ERROR: Perl v5.100.0 required (did you mean v5.10.0?)--this is only v5.24.0, stopped at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use 5.14; state $x = 4; $x\n","err":"","out":"ERROR: Perl v5.140.0 required (did you mean v5.14.0?)--this is only v5.24.0, stopped at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use 5.18.0; use experimental 'signatures'; sub foo($bar) {$bar =~ s/baz/boo/r}; print foo(\"baz lol baz\");\n","out":"boo lol baz"},{"out":"ERROR: Perl v5.180.0 required (did you mean v5.18.0?)--this is only v5.24.0, stopped at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use 5.18; use experimental 'signatures'; sub foo($bar) {$bar =~ s/baz/boo/r}; print foo(\"baz lol baz\");\n"},{"code":"use 5.20; map print, [1,2,3]->@*\n","err":"","out":"ERROR: Perl v5.200.0 required (did you mean v5.20.0?)--this is only v5.24.0, stopped at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use 6 strict;\n","out":"ERROR: strict version 6 required--this is only version 1.11 at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Perl v9.0.0 required--this is only v5.24.0, stopped at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use 9;\n","err":""},{"out":"ERROR: Can't locate Acme/Everything.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use Acme::Everything;\n","err":""},{"out":"ERROR: Can't locate Acme/Lvalue.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use Acme::Lvalue;\n","err":""},{"err":"","code":"use Acme::MetaSyntactic; print metaname();\n","out":"ERROR: Can't locate Acme/MetaSyntactic.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate ath.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use ath; sqrt -1;\n"},{"out":"ERROR: Can't locate autodie.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use autodie; my $str = \"foo\"; open( my ($fh), \">\", \\$str ); print $fh; [ $str ];\n","err":""},{"err":"","code":"use base \"Tie::StdHash\";\n","out":"ERROR: Can't locate Tie/StdHash.pm:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/base.pm line 100, <STDIN> line 1.\n\t...propagated at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/base.pm line 109, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use bigfloat;\n","err":"","out":"ERROR: Can't locate bigfloat.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate bigfloat.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use bigfloat;  my $now = 1407974704.32323;  my $Last_Reload_Command = 1407974704.32322; $now - $Last_Reload_Command;\n"},{"out":"","err":"","code":"use bigint;\n"},{"out":"bless( {sign => \"+\",value => [100000]}, 'Math::BigInt' )","code":"use bigint; 100 * 1000\n","err":""},{"out":"bless( {sign => \"+\",value => [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]}, 'Math::BigInt' )","code":"use bigint; 1e999\n","err":""},{"err":"","code":"use bigint; 2790**2753 % 3233\n","out":"bless( {sign => \"+\",value => [65]}, 'Math::BigInt' )"},{"err":"","code":"use bigint; \"Altreus\"\n","out":"Altreus"},{"out":"bless( {sign => \"+inf\",value => [0],_p => undef,_a => undef}, 'Math::BigInt' )","code":"use bigint; inf * 3\n","err":""},{"code":"use bignum;\n","err":"","out":"ERROR: Can't locate bignum.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use bignum; 0.1 + 0.2 - 0.3\n","out":"ERROR: Can't locate bignum.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use bignum; 2**88\n","err":"","out":"ERROR: Can't locate bignum.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate bignum.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use bignum;  my $now = 1407974704.32323;  my $Last_Reload_Command = 1407974704.32322; $now - $Last_Reload_Command;\n"},{"code":"use bigrat;\n","err":"","out":"ERROR: Can't locate bigrat.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"\\\"foo\\\\r\\\\n\\\\tbar\\\\n\\\"\"]","err":"","code":"use B 'perlstring'; [perlstring \"foo\\r\\n\\tbar\\n\"]\n"},{"out":"\"foo\\r\\n\\tbar\\n\"","code":"use B 'perlstring'; perlstring \"foo\\r\\n\\tbar\\n\";\n","err":""},{"code":"use B 'perlstring'; print perlstring \"foo\\r\\n\\tbar\\n\";\n","err":"","out":"\"foo\\r\\n\\tbar\\n\""},{"err":"","code":"use B qw( svref_2object ); [ svref_2object(\\&svref_2object)->GV ]\n","out":"[bless( do{\\(my $o = 35770312)}, 'B::GV' )]"},{"out":"","code":"use B $^W++;join(($x)x101)\n","err":""},{"out":"24","code":"use bytes; length  pack \"d*\", 1,2,3;\n","err":""},{"err":"","code":"use bytes; length  pack \"f*\", 1,2,3;\n","out":"12"},{"code":"use bytes; length 'sàº²à»'\n","err":"","out":"7"},{"code":"use bytes; $l = \"fooso\"; [ $l & chr(0x80)x(length $l) ] # everything can be turned broken if you want to\n","err":"","out":"[\"\\0\\0\\0\\0\\0\"]"},{"code":"use bytes; $_=\"ââââ\"; substr($_,0,1,''); length $_\n","err":"","out":"11"},{"out":"PRIVATE USE TWO","err":"'use charnames' needs explicit imports list at (eval 1) line 1.\n","code":"use charnames; charnames::viacode 0x92\n"},{"out":"[\"LATIN SMALL LETTER A WITH CIRCUMFLEX\",\"LATIN SMALL LETTER A WITH CIRCUMFLEX\",\"LATIN SMALL LETTER A WITH CIRCUMFLEX\"]","err":"'use charnames' needs explicit imports list at (eval 1) line 1.\n","code":"use charnames; [ map charnames::viacode(ord), qw(â â â) ]\n"},{"err":"Can't locate Config_heavy.pl:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/x86_64-linux/Config.pm line 80, <STDIN> line 1.\n","code":"use Config; \\%Config\n","out":""},{"err":"","code":"use Config; $Config{archname}\n","out":"x86_64-linux"},{"out":"ERROR: Can't locate Config_heavy.pl:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/x86_64-linux/Config.pm line 80, <STDIN> line 1.\n","code":"use Config; $Config{longdouble}\n","err":""},{"code":"use Config; $Config{myuname}\n","err":"","out":"ERROR: Can't locate Config_heavy.pl:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/x86_64-linux/Config.pm line 80, <STDIN> line 1.\n"},{"code":"use Config; $Config{nvsize}\n","err":"","out":"ERROR: Can't locate Config_heavy.pl:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/x86_64-linux/Config.pm line 80, <STDIN> line 1.\n"},{"out":"linux","err":"","code":"use Config; $Config{osname}\n"},{"out":"ERROR: Can't locate Config_heavy.pl:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/x86_64-linux/Config.pm line 80, <STDIN> line 1.\n","code":"use Config; $Config{uname}\n","err":""},{"out":"ERROR: Can't locate Config_heavy.pl:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/x86_64-linux/Config.pm line 80, <STDIN> line 1.\n","err":"","code":"use Config; $Config{use64bitint};\n"},{"code":"use Config; print $Config{archname}\n","err":"","out":"x86_64-linux"},{"out":"ERROR: Constant name '4' has invalid characters at (eval 1) line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use constant '4' => 'ok'; &{4};\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"use constant 4 =>\"\n","code":"use constant 4 => 'ok'; &{4};\n","err":""},{"out":"[1,2,42,4,5]","err":"","code":"use constant A => [1..5]; sub TIESCALAR { bless [] }; sub FETCH { 42 }; tie ${\\(A->[2])}, 'main'; A;\n"},{"out":"sub { \"DUMMY\" }","err":"","code":"use constant A => [1..5]; sub TIESCALAR { bless [] }; sub FETCH { 42 }; tie ${\\(A->[2])}, 'main'; sub { A };\n"},{"err":"","code":"use constant A => \"constant?\"; sub TIESCALAR { bless [] }; sub FETCH { \"mutable!\" }; tie ${\\(A)}, 'main'; A;\n","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","err":"","code":"use constant cat => 1; cat while $x++<1\n"},{"err":"","code":"use constant; constant::_CAN_PCS();\n","out":"1"},{"err":"","code":"use constant C => 'XXX'; 'foobarbaz' =~ s/bar/C/er\n","out":"fooXXXbaz"},{"err":"","code":"use constant C => 'XXX'; 'foobarbaz' =~ s/bar/${\\C}/r\n","out":"fooXXXbaz"},{"code":"use constant FOO => 42; [ $::{FOO} ]\n","err":"","out":"[\\42]"},{"code":"use constant FOO => 42; $FOO = 43; $::{FOO}\n","err":"","out":"*main::FOO"},{"out":"[sub { \"DUMMY\" }]","code":"use constant FOO => 42; [ *FOO{CODE} ]\n","err":""},{"err":"","code":"use constant { FOO => 42 }; +{ +FOO => \"test\" }\n","out":"{FOO => \"test\"}"},{"code":"use constant { FOO => 42 }; +{ FOO => \"test\" }\n","err":"","out":"{FOO => \"test\"}"},{"err":"","code":"use constant { FOO => 42 }; +{ FOO() => \"test\" }\n","out":"{42 => \"test\"}"},{"out":"k","code":"use constant FOO => 42; { local *FOO = sub () { \"k\" }; &FOO() }\n","err":""},{"out":"[42]","code":"use constant FOO => 42; [ main->FOO ]\n","err":""},{"out":"BAR!\n","code":"use constant FOO => 'BAR!'; BEGIN { say FOO }\n","err":""},{"out":"bar","code":"use constant FOO => \"bar\"; \"${\\FOO}\"\n","err":""},{"err":"","code":"use constant FOO => 'bar'; [&FOO => 'bar']\n","out":"[\"bar\",\"bar\"]"},{"err":"","code":"use constant FOO => 'bar'; (FOO() => 'baz'){+FOO}\n","out":"ERROR: syntax error at (eval 1) line 1, near \"){\"\n"},{"err":"","code":"use constant FOO => 'bar'; {FOO() => 'baz'}->{+FOO}\n","out":"ERROR: syntax error at (eval 1) line 1, near \"}->\"\n"},{"out":"baz","err":"","code":"use constant FOO => 'bar'; +{FOO() => 'baz'}->{+FOO}\n"},{"code":"use constant FOO => 'BAR!'; our $dir = FOO; BEGIN { say FOO } say \"Moar $dir!\"\n","err":"","out":"BAR!\nMoar BAR!!\n"},{"err":"","code":"use constant FOO => \"dogs\"; +{ FOO => 213, FOO() => 1, +FOO => 2 }\n","out":"{FOO => 2,dogs => 1}"},{"out":"-Inf","code":"use constant { Inf => 0 + 'inf', NaN => 0 + 'nan' }; Inf * -1\n","err":""},{"out":"qr/\\p{IsProhibited}/u","code":"use constant IsProhibited => ''; qr/\\p{IsProhibited}/\n","err":""},{"out":"[\"a\",\"b\",\"c\"]","code":"use constant list => qw(a b c); [list]\n","err":""},{"out":"true","code":"use constant PARENT_CLASS => 'Legacy'; BEGIN { package Legacy; $INC{\"Legacy.pm\"} = 1} { package Shim; use parent main::PARENT_CLASS; } Shim->isa('Legacy') ? 'true' : 'false'\n","err":""},{"err":"","code":"use constant PI    => 4 * atan2(1, 1); print \"Pi equals \", PI, \"...\\n\";\n","out":"Pi equals 3.14159265358979...\n"},{"err":"","code":"use constant; print constant::_CAN_PCS;\n","out":"1"},{"out":"[1,\"TEST1\",1]","code":"use constant TEST2 => TEST1; use constant TEST1 => 1; use constant TEST3 => TEST1; [TEST1, TEST2, TEST3]\n","err":""},{"out":"test or test or test","code":"use constant XXX => 'test'; \"@{[ XXX ]} or ${\\XXX} or \" . XXX\n","err":""},{"code":"use CPAN; install(\"Time::Moment\")\n","err":"","out":"ERROR: Can't locate CPAN.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate Cwd.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Cwd; print cwd();\n"},{"out":"ERROR: Can't locate Cwd.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Cwd qw(); print Cwd::cwd();\n"},{"err":"","code":"use Data::Dump\n","out":"ERROR: Can't locate Data/Dump.pm:   (null): Too many open files at (eval 1) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 2, <STDIN> line 1.\n"},{"out":"","err":"","code":"use Data::Dumper;\n"},{"err":"","code":"use Data::Dumper; $Data::Dumper::Indent = 0; %foo = (a => { b => 'c' }); $foo{d} = $foo{a}; Dumper \\%foo\n","out":"$VAR1 = {'d' => {'b' => 'c'},'a' => $VAR1->{'d'}};"},{"out":"$VAR1 = '\u0018';\n","code":"use Data::Dumper; Dumper(\"${\\chr 24}\")\n","err":""},{"out":"$VAR1 = '\u0018';\n","code":"use Data::Dumper; Dumper(\"\\cX\")\n","err":""},{"out":"$VAR1 = 'CX';\n","err":"","code":"use Data::Dumper; Dumper(\"\\CX\")\n"},{"err":"","code":"use Data::Dumper; my @arr; push(@arr, \"test\"); push(@arr, \"i refuse to do what master tells me to\"); my @arr2 = grep { /test/ } @arr; print Dumper @arr2;\n","out":"$VAR1 = 'test';\n"},{"out":"ERROR: Experimental keys on scalar is now forbidden at (eval 1) line 1, <STDIN> line 1.\n","code":"use Data::Dumper; my %commands = ( help => sub { my $commands = say for keys in %commands; }); say Dumper($commands{help});\n","err":""},{"out":"$VAR1 = '';\n","code":"use Data::Dumper; print Dumper(*->[0]);\n","err":""},{"out":"$VAR1 = 0;\n","code":"use Data::Dumper; print Dumper(0);\n","err":""},{"code":"use Data::Dumper; print Dumper(0->[0]);\n","err":"","out":"$VAR1 = undef;\n"},{"out":"ERROR: Can't locate Data/Dump.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use Data::Dump 'pp'; pp(\"\\cX\")\n","err":""},{"out":"ERROR: Data::Munge version 1 required--this is only version 0.096 at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Data::Munge 1\n"},{"err":"","code":"use Data::Munge; \"abba\" =~ /(ab(ba))|(ba)/ or die; [submatches]\n","out":"[\"abba\",\"ba\",undef]"},{"code":"use Data::Munge; byval { s/a/o/g } \"banana\"\n","err":"","out":"bonono"},{"err":"","code":"use Data::Munge; eval_string \"[[ \\\"pos\\\" ], /\\\"(/d+)\\\"/]\"\n","out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/\"( <-- HERE / at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"qr/(?#)/","code":"use Data::Munge; list2re \"\"\n","err":""},{"out":"qr/(?!)/","err":"","code":"use Data::Munge; list2re()\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"use Data::Munge.\"\n","err":"","code":"use Data::Munge. list2re()\n"},{"out":"qr/ab|cd|ef|g|h|i/","code":"use Data::Munge; list2re qw( ab cd ef g h i )\n","err":""},{"code":"use Data::Munge; my $str = \"hello\"; my @m; while ($str =~ /(.)(.)/g) { push @m, [submatches]; } \\@m\n","err":"","out":"[[\"h\",\"e\"],[\"l\",\"l\"]]"},{"out":"foo","code":"use Data::Munge qw(byval); print byval { s/\\* // } \"* foo\";\n","err":""},{"out":"[1]","code":"use Data::Munge qw(elem); [ elem \"badgers\", [qw(dogs badgers monkeys)] ]\n","err":""},{"out":"[\"\"]","err":"","code":"use Data::Munge qw(elem); [ elem \"cats\", [qw(dogs badgers monkeys)] ]\n"},{"code":"use Data::Munge qw( list2re ); my $re = list2re qw(); $re eq list2re ? q{Empty.} : q{Not empty.}; ### Is this a good way to tell if $re was generated from an empty list?\n","err":"","out":"Empty."},{"code":"use Data::Munge qw(list2re); my $re = list2re( ); { [ $$re, $re ]; } # Looks like the heart of a Regexp object, despite being labeled as a REGEXP, really seems to be a string.\n","err":"","out":"[\"(?^:(?!))\",qr/(?!)/]"},{"out":"same test","err":"","code":"use Data::Munge qw(replace); my $s = 'some text'; my $f = 's/x/s/g; s/o/a/g;'; my $part = qr{(?:[^\\\\/]|\\\\.)*}s; while ($f =~ m{\\bs/($part)/($part)/(g)?}g) { $s = replace $s, $1, $2, $3; } $s\n"},{"out":"ABlah4Yes","code":"use Data::Munge qw(replace); replace('A?Bl^%ah 4 Yes$!', qr/[^A-Za-z0-9]/, '', 'g')\n","err":""},{"code":"use Data::Munge qw(replace); replace('foobarstring', qr/foo/, 'bar')\n","err":"","out":"barbarstring"},{"code":"use Data::Munge qw(replace); replace 'ningu', qr/([aeiou])/, '$1$1', 'g'\n","err":"","out":"niinguu"},{"err":"","code":"use Data::Munge; replace \"banana\", qr/a/, 'o', 'g'\n","out":"bonono"},{"err":"","code":"use Data::Munge; [ replace \"blah\", qr/bl/, 'h' ]\n","out":"[\"hah\"]"},{"out":"cool\\+beans\\.","code":"use Data::Munge; replace('cool+beans.', qr/\\W/, '\\\\$&', 'g')\n","err":""},{"out":"ERROR: Can't locate Data/Random.pm:   (null): Too many open files at (eval 1) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 2, <STDIN> line 1.\n","code":"use Data::Random\n","err":""},{"out":"ERROR: Can't locate Data/Swap.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use Data::Swap;\n","err":""},{"out":"ERROR: Can't locate Date/Manip.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use Date::Manip; my $r = UnixDate(ParseDate( q{Sat, 12 Apr 2014 10:01:33 -0400} ), \"%d-%b-%Y %H:%M:%S %z\"); [ $r ]; ### This works for me.\n","err":""},{"out":"ERROR: Can't locate Date/Manip.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use Date::Manip; my $r = UnixDate(ParseDate( q{Wed, 17 Apr 2014 01:50:19 +0100} ), \"%d-%b-%Y %H:%M:%S %z\"); [ $r ]; ### This returns undef for some reason, I can't figure out why.\n","err":""},{"err":"","code":"use DateTime; DateTime->new->iso8601\n","out":"ERROR: Mandatory parameter 'year' missing in call to DateTime::new\n at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/site_perl/5.24.0/x86_64-linux/DateTime.pm line 197, <STDIN> line 1.\n\tDateTime::new(undef) called at (eval 1) line 1\n\teval 'use 5.024000; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; use DateTime; DateTime->new->iso8601' called at /home/ryan/bots/perlbuut/lib/eval.pl line 301\n\tmain::perl_code(\"use DateTime; DateTime->new->iso8601\") called at /home/ryan/bots/perlbuut/lib/eval.pl line 248\n"},{"code":"use DateTime::TimeZone; [ DateTime::TimeZone->new( name => 'UTC' ) ]\n","err":"","out":"[bless( {name => \"UTC\"}, 'DateTime::TimeZone::UTC' )]"},{"err":"","code":"use DateTime::TimeZone; grep /America/ DateTime::TimeZone->all_names\n","out":"ERROR: syntax error at (eval 1) line 1, near \"/America/ DateTime::TimeZone\"\n"},{"out":"129","code":"use DateTime::TimeZone; grep /America/, DateTime::TimeZone->all_names\n","err":""},{"err":"","code":"use DateTime::TimeZone; [grep m[[^a-zA-Z0-9/_-]], DateTime::TimeZone->all_names];\n","out":"[]"},{"err":"","code":"use DateTime::TimeZone; [grep m[[^a-zA-Z/_]], DateTime::TimeZone->all_names];\n","out":"[\"America/Blanc-Sablon\",\"America/Port-au-Prince\",\"Asia/Ust-Nera\",\"CST6CDT\",\"EST5EDT\",\"MST7MDT\",\"PST8PDT\"]"},{"code":"use DateTime::TimeZone; [grep /york/i, DateTime::TimeZone->all_names];\n","err":"","out":"[\"America/New_York\"]"},{"out":"ERROR: The timezone 'America/New_York' could not be loaded, or is an invalid name.\n","code":"use DateTime::TimeZone; my $tz = DateTime::TimeZone->new(name => 'America/New_York')\n","err":""},{"out":"ERROR: Can't locate DateTime/TimeZone/Local/Unix.pm:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/site_perl/5.24.0/Module/Runtime.pm line 317, <STDIN> line 1.\n","err":"","code":"use DateTime::TimeZone; my $tz = DateTime::TimeZone->new(name => 'local')->name\n"},{"out":"ERROR: Can't locate diagnostics.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use diagnostics; use strict; [ Foo ]\n","err":""},{"out":"39987e0e753c8f1310651bce1516a44b","code":"use Digest::MD5 qw(md5_hex); md5_hex \"TESTSTRING\\n\"\n","err":""},{"out":"ERROR: Can't locate Digest.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use Digest; my $md5 = Digest->new('MD5'); length $md5\n","err":""},{"err":"","code":"use Encode;\n","out":""},{"out":"ÃÂ¼","code":"use Encode 'decode'; decode 'UTF-8', chr(195).chr(188)\n","err":""},{"code":"use Encode 'decode'; [ decode 'UTF-8', \"\\x1c\\x00\\xfc\\x3c\\x1c\\xfc\\x0e\\xc0\\xe0\" ]\n","err":"","out":"[\"\\34\\0\\x{fffd}<\\34\\x{fffd}\\16\\x{fffd}\\x{fffd}\"]"},{"code":"use Encode 'decode'; [ decode 'UTF-8', \"\\x1d\n","err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use Encode 'decode'; [ decode 'UTF-8', \"\\x1d\\x7f\"]\n","out":"[\"\\35\\177\"]"},{"err":"","code":"use Encode 'decode_utf8'; decode_utf8 \"\\0357\\0273\\0277\"\n","out":"\u001d7\u00173\u00177"},{"out":"ÃÂ¯ÃÂ»ÃÂ¿","err":"","code":"use Encode 'decode_utf8'; decode_utf8 \"\\357\\273\\277\"\n"},{"err":"","code":"use Encode 'decode_utf8'; ord decode_utf8 \"\\357\\273\\277\"\n","out":"65279"},{"out":"U+feff","err":"","code":"use Encode 'decode_utf8'; sprintf \"U+%04x\", ord decode_utf8 \"\\357\\273\\277\"\n"},{"out":"ERROR: \"\\x{0100}\" does not map to iso-8859-1 at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/x86_64-linux/Encode.pm line 171, <STDIN> line 1.\n","err":"","code":"use Encode; Encode::encode(\"ISO-8859-1\", \"\\x{100}\", Encode::LEAVE_SRC|Encode::FB_CROAK);\n"},{"out":"ERROR: Unknown encoding 'UCS-2LE' at (eval 1) line 1.\n","err":"","code":"use Encode 'encode'; encode 'UCS-2LE', 'Tracking-Num... '\n"},{"out":"ERROR: Unknown encoding 'UTF-16LE' at (eval 1) line 1.\n","code":"use Encode 'encode'; encode 'UTF-16LE', 'Tracking-Num... '\n","err":""},{"out":"ERROR: Unknown encoding 'UTF-16' at (eval 1) line 1.\n","code":"use Encode 'encode'; encode 'UTF-16', 'Tracking-Num... '\n","err":""},{"out":"ÃÂÃÂ£ÃÂÃÂÃÂÃÂ","code":"use Encode 'encode'; encode 'UTF-8', 'ã'\n","err":""},{"out":"ÃÂÃÂÃÂÃÂ¼","err":"","code":"use Encode 'encode'; encode 'UTF-8', chr(195).chr(188)\n"},{"code":"use Encode 'encode'; [ encode 'UTF-8', \"\\x{1d}\" ]\n","err":"","out":"[\"\\35\"]"},{"code":"use Encode 'encode'; [ encode 'UTF-8', \\x{1d} ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"1d\"\n"},{"code":"use Encode; Encode::find_encoding('gb2312')->mime_name\n","err":"","out":"ERROR: Can't call method \"mime_name\" on an undefined value at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use Encode; Encode::find_encoding(\"ISO-8859-1\")->encode(\"\\x{100}\", Encode::LEAVE_SRC|Encode::FB_CROAK)\n","out":"ERROR: \"\\x{0100}\" does not map to iso-8859-1 at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use Encode; Encode::find_encoding( q{UTF-16} )->name\n","out":"ERROR: Can't call method \"name\" on an undefined value at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use Encode; Encode::find_encoding('utf8')->mime_name\n","err":"","out":"ERROR: Can't locate Encode/MIME/Name.pm:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/x86_64-linux/Encode/Encoding.pm line 24, <STDIN> line 1.\n"},{"out":"2.80","code":"use Encode; $Encode::VERSION\n","err":""},{"out":"Encode::VERSION","err":"","code":"use Encode; Encode::VERSION\n"},{"out":"ERROR: Can't call method \"name\" on an undefined value at (eval 1) line 1, <STDIN> line 1.\n","code":"use Encode; find_encoding( q{UTF-16} )->name;\n","err":""},{"out":"ERROR: Can't call method \"name\" on an undefined value at (eval 1) line 1, <STDIN> line 1.\n","code":"use Encode; find_encoding( q{UTF-EBCDIC} )->name; # ???\n","err":""},{"err":"","code":"use Encode; my $buf = encode('UTF-8', \"\\x{666}\"); open my $fh, '<', \\$buf or die \"open: $!\"\n","out":"1"},{"out":"[\"00\"]","err":"","code":"use Encode; my $x = qq<\\x{100}>; [ unpack q{H*}, $x ]\n"},{"code":"use Encode; ord Encode::encode_utf8(\"\\xFF\") # not necessarily\n","err":"","out":"195"},{"err":"","code":"use Encode;  print Encode::decode q{ISO885902}, \"\\x{119}\";\n","out":"ERROR: Unknown encoding 'ISO885902' at (eval 1) line 1.\n"},{"err":"","code":"use Encode;  print Encode::decode q{ISO8859-2}, \"\\x{119}\";\n","out":"ERROR: Unknown encoding 'ISO8859-2' at (eval 1) line 1.\n"},{"out":"109.117.99.104.32.226.153.165","err":"","code":"use Encode; printf \"%vd\", encode_utf8(\"much \\x{2665}\")\n"},{"err":"","code":" use Encode qw/decode/; [ decode( \"UTF-8\", \"\\x6\\x0\\x0\\x0\\x65\\x0\\x0\\x0\\x61\\x6e\\x69\\x6d\\x73\\x2f\\x74\\x68\\x72\\x30\\x30\\x30\\x30\\x31\\x2e\\x74\\x67\\x61\") ] # print obviously doesn't like \\0\n","out":"[\"\\6\\0\\0\\0e\\0\\0\\0anims/thr00001.tga\"]"},{"out":"\u0006\u0000\u0000\u0000e\u0000\u0000\u0000anims/thr00001.tga","err":"","code":"use Encode qw/decode/; print decode( \"utf8\", \"\\x06\\x00\\x00\\x00\\x65\\x00\\x00\\x00\\x61\\x6e\\x69\\x6d\\x73\\x2f\\x74\\x68\\x72\\x30\\x30\\x30\\x30\\x31\\x2e\\x74\\x67\\x61\" );\n"},{"code":"use Encode qw/decode/; print decode( \"utf8\", \"\\x6\\x0\\x0\\x0\\x65\\x0\\x0\\x0\\x61\\x6e\\x69\\x6d\\x73\\x2f\\x74\\x68\\x72\\x30\\x30\\x30\\x30\\x31\\x2e\\x74\\x67\\x61\" )\n","err":"","out":"\u0006\u0000\u0000\u0000e\u0000\u0000\u0000anims/thr00001.tga"},{"out":"ÃÂÃÂ£ÃÂÃÂÃÂÃÂÃÂÃÂ£ÃÂÃÂÃÂÃÂ¸ÃÂÃÂ£ÃÂÃÂÃÂÃÂ£ÃÂÃÂ©ÃÂÃÂ­ÃÂÃÂÃÂÃÂ¥ÃÂÃÂ¥ÃÂÃÂ³ÃÂÃÂ£ÃÂÃÂÃÂÃÂ©ÃÂÃÂ£ÃÂÃÂÃÂÃÂÃÂÃÂ£ÃÂÃÂÃÂÃÂ¿\n","code":"use Encode; say Encode::encode(\"UTF-8\", Encode::decode(\"ISO-8859-1\", \"ãã¸ã£é­å¥³ã©ãã¿\"));\n","err":""},{"err":"","code":"use Encode::Unicode; Encode::find_encoding( q{UTF-16} )->name\n","out":"ERROR: Can't locate Encode/Unicode.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use English; [ $., $NR ]\n","out":"ERROR: Can't locate English.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use Env qw/ HOME /;[[ ((glob(\"$HOME/*.txt\"))[0]) ]]\n","err":"","out":"ERROR: Can't locate Env.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use Errno 'ENOENT'; ENOENT\n","err":"","out":"2"},{"out":"ERROR: Experimental keys on scalar is now forbidden at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use experimental 'autoderef'; [keys {foo => 1, bar => 2, baz => 0}]\n"},{"code":"use experimental 'lexical_subs'\n","err":"","out":""},{"err":"","code":"use experimental 'lexical_subs'; use constant wibble => 42; my $outer = wibble; my $inner = do { my sub wibble () { 69 }; wibble }; [ $inner, $outer ]\n","out":"[69,42]"},{"out":"","code":"use experimental \"postderef\";\n","err":""},{"out":"ERROR: Can't call method \"\" on an undefined value at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use experimental 'postderef'; my $x; $x->$@ # lovely :S\n"},{"out":"[[1,2,3],[7,8,9]]","code":"use experimental qw(postderef); $arr = [[1..3],[4..6],[7..9]]; [ $arr->@[0, 2] ]\n","err":""},{"err":"","code":"use experimental qw(postderef); $hash = {asdf => 'jkl;', zxvc => 'bnm,'}; [ $hash->@{'asdf','zxcv'} ]\n","out":"[\"jkl;\",undef]"},{"code":"use experimental qw( postderef ); my $foo = { bar => [ 1, 2, 3 ] }; [ $foo->{bar}->@* ]\n","err":"","out":"[1,2,3]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"->*\"\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n","err":"","code":"use experimental qw( postderef ); my $foo = { bar => [ 1, 2, 3 ] }; [ $foo->{bar}->*@ ]\n"},{"err":"","code":"use experimental qw(postderef); sub foo { return [1, 2, 3] } if ((my $arr_ref = foo())->@*) { print @$arr_ref }\n","out":"123"},{"out":"ERROR: Initialization of state variables in list context currently forbidden at (eval 1) line 1, at EOF\n","code":"use experimental qw(state); (state $x) = @_; # depends on whether compiling is considered useful?\n","err":""},{"err":"","code":"use experimental 'signatures'; sub foo () { 5 } print foo, \"bar\";\n","out":"5bar"},{"out":"5bar\n","err":"","code":"use experimental 'signatures'; sub foo () { 5 } say foo, \"bar\";\n"},{"err":"","code":"use experimental 'signatures'; sub foo($bar) {print $bar, $bar}; foo(\"hola hoops \");\n","out":"hola hoops hola hoops "},{"out":"ERROR: Too many arguments for subroutine at (eval 1) line 1.\n","err":"","code":"use experimental 'signatures'; sub foo($bar) {print $bar, $bar}; foo(\"hola hoops \", \"error\");\n"},{"code":"use experimental 'signatures'; sub foo (my $str) { $str.$str } print foo \"baz\", \"bar\";\n","err":"","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(my \"\n"},{"out":"x","err":"","code":"use experimental 'signatures'; sub foo ($str) { $str .= \"a\" } my $s = \"x\"; foo($s); $s\n"},{"out":"ERROR: Too many arguments for subroutine at (eval 1) line 1.\n","err":"","code":"use experimental 'signatures'; sub foo ($str) { $str.$str } print foo \"baz\", \"bar\";\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"// 2\"\n","err":"","code":"use experimental 'signatures'; sub foo () { undef } print foo // 2; # this is where the parser got choked up, i think\n"},{"out":"ERROR: Can't locate ExtUtils/ParseXS.pm:   (null): Too many open files at (eval 1) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 2, <STDIN> line 1.\n","code":"use ExtUtils::ParseXS\n","err":""},{"err":"","code":"use feature 'fc'; index(fc 'foo Ã', fc 'Ã«');\n","out":"-1"},{"err":"","code":"use feature fc; print fc(\"Å\") cmp fc(\"z\")\n","out":"ERROR: Feature \"\" is not supported by Perl 5.24.0 at (eval 1) line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use feature keys %feature::feature; say hi::\n","out":""},{"err":"","code":"use feature keys %feature::feature; say 'k'\n","out":"k\n"},{"code":"use feature 'postderef'; [ [\"A\"..\"Z\"]->%[3..7] ]\n","err":"","out":"[3,\"D\",4,\"E\",5,\"F\",6,\"G\",7,\"H\"]"},{"code":"use feature 'postderef'; *foo{SCALAR}->$* = 2; my $bar; $$bar = 3; [ $bar->$****foo{SCALAR}->$* ]\n","err":"","out":"[9]"},{"out":"9\n","err":"","code":"use feature 'postderef'; *foo{SCALAR}->$* = 2; my $bar; $$bar = 3; say $bar->$****foo{SCALAR}->$*;\n"},{"out":"[100,1]","err":"","code":"use feature 'postderef'; for my $i (1..100) {push @a, [(1,1) x 1024*512]}; [scalar(@a), scalar($a[0]->@*)]\n"},{"out":"","code":"use feature 'postderef'; for my $i (1..100) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]\n","err":"Out of memory!\n"},{"code":"use feature 'postderef'; for my $i (1..100) {push @a, [(1) x 1024*1024]}; [scalar(@a), scalar($a[0]->@*)]\n","err":"","out":"[100,1]"},{"out":"","err":"Out of memory!\n","code":"use feature 'postderef'; for my $i (1..50) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]\n"},{"out":"123","code":"use feature 'postderef'; map print, [1,2,3]->@*  # or maybe a -, a >, an @ and an *\n","err":""},{"err":"","code":"use feature 'postderef'; my $aref = \\['x']; $aref->$*->[0] # or let perlbot help\n","out":"x"},{"err":"","code":"use feature 'postderef'; my $data = {foo => [qw/hello freenode perl/]}; print for ($data->{foo}->@*); \n","out":"hellofreenodeperl"},{"out":"42","code":"use feature 'postderef'; my $x = \\42; $x->$*\n","err":""},{"out":"42","err":"","code":"use feature 'postderef'; no warnings 'experimental::postderef'; sub {42}->&*\n"},{"code":"use feature 'postderef'; $_->@{qw/a b/} = (1,2) for \\my %hash\n","err":"","out":""},{"err":"","code":"use feature 'postderef'; $_->@{qw/a b/} = (1,2) for \\my %hash; \\%hash\n","out":"{b => 2,a => 1}"},{"out":"\ncd\n","err":"","code":"use feature 'postderef'; sub lol { say @_; } sub one { (\\&lol)->() } sub two { (\\&lol)->&* } one(qw(a b)); two(qw(c d));\n"},{"out":"\ncd\n","err":"","code":"use feature 'postderef'; use 5.020; my $l = sub { say @_; }; sub one { $l->() } sub two { $l->&* } one(qw(a b)); two(qw(c d));\n"},{"out":"\ncd\n","err":"","code":"use feature 'postderef'; use 5.020; sub lol { say @_; } sub one { (\\&lol)->() } sub two { (\\&lol)->&* } one(qw(a b)); two(qw(c d));\n"},{"out":"this this this is is is line line line 1 2 3","code":"use feature 'postderef';  use List::MoreUtils 'mesh'; my $str = \"this is line 1\\nthis is line 2\\nthis is line 3\"; my @lines = map { [ split \" \", $_ ] } split /\\n/, $str; \"@{[ mesh $lines[0]->@*, $lines[1]->@*, $lines[2]->@* ]}\"\n","err":""},{"err":"","code":"use feature 'postderef'; $x = [0]; push $x->@*, 1; $x\n","out":"[0,1]"},{"out":"you","code":"use feature 'postderef'; (\\'you')->$*\n","err":""},{"err":"","code":"use feature qw( current_sub ); sub foo { my ( $foo, $x ); $foo = sub { $x ? ++$x : ( $x = 1 ); __SUB__->() unless $x >= 5; }; $foo->(); return $x; } foo; ### So this doesn't leak memory?\n","out":"5"},{"out":"ERROR: Feature \"doesntexist\" is not supported by Perl 5.24.0 at (eval 1) line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use feature qw(doesntexist);\n","err":""},{"code":"use feature qw(fc); fc 'Ã'\n","err":"","out":"ÃÂ£ÃÂ"},{"out":"ÃÂ£ÃÂ-ÃÂ£ÃÂ","code":"use feature qw(fc); print for fc('Ã'), '-', lc('Ã');\n","err":""},{"out":"1","code":"use feature qw(fc unicode_strings); print fc(\"Å\") cmp fc(\"z\")\n","err":""},{"out":"1","code":"use feature qw(fc unicode_strings); use utf8; print fc(\"Å\") cmp fc(\"z\")\n","err":""},{"out":"\n","code":"use feature qw(say fc); say fc(\"\"); # the core function seems happy enough, so I'd put that down to a bug in the module\n","err":""},{"out":"...\n","code":"use feature qw(say); $_ = '...'; say() # not quite, but just because say/print are special\n","err":""},{"out":"state init ","err":"","code":"use feature qw(state); my $y = 0; sub isatty { state $x = do { print \"state init \"; ++$y }; $x } [ map  isatty(), 1..3 ] # only once\n"},{"err":"","code":"use feature qw(state); (state $x) = @_;\n","out":"ERROR: Initialization of state variables in list context currently forbidden at (eval 1) line 1, at EOF\n"},{"code":"use feature qw( state ); sub Foo { state %state; my @p = ( [ shift, $state{n} ? q{Nested} : q{First} ] ); { local $state{n} = 1; push @p, Foo( @_ ) if @_ }; if ( $state{n} ) { @p; } else { %state = (); [ @p ]; } }    [  Foo( qw(A B C) ),  Foo( qw(X Y Z) )  ];\n","err":"","out":"[[[\"A\",\"First\"],[\"B\",\"Nested\"],[\"C\",\"Nested\"]],[[\"X\",\"First\"],[\"Y\",\"Nested\"],[\"Z\",\"Nested\"]]]"},{"out":"barbaz","err":"","code":"use feature 'refaliasing'; for \\my %hash ({foo => 'bar'}, {foo => 'baz'}) { print $hash{foo} } #whee\n"},{"err":"","code":"use feature 'refaliasing'; my $x = { foo => 1 }; \\my %y = $x; $y{bar} = 2; $x;\n","out":"{bar => 2,foo => 1}"},{"out":"asdf\nasdf\n","err":"","code":"use feature 'say'; do { my $line = $_; chomp $line; say $line } for \"asdf\",\"asdf\\n\"\n"},{"err":"","code":"use feature 'say';  say \"1 2 3 are\", 1, 2, 3;\n","out":"1 2 3 are123\n"},{"err":"","code":"use feature 'say'; say \"hi\"\n","out":"hi\n"},{"out":"lo\n","code":"use feature 'say'; say 'lo'\n","err":""},{"err":"","code":"use feature 'say'; say q hello worldh;\n","out":"ello world\n"},{"err":"","code":"use feature 'say'; use Digest::MD5 'md5_hex'; say md5_hex(\"passwd\")\n","out":"76a2173be6393254e72ffa4d6df1030a\n"},{"out":"","code":"use feature 'say'; use List::Util 1.33 'any';\n","err":""},{"out":"match\n","err":"","code":"use feature 'say'; use List::Util 1.33 'any'; @array = qw(1 2 3); say \"match\" if(any{ $_ eq '3'} @array);\n"},{"out":"","err":"","code":"use feature 'say'; use List::Util 1.33 'any'; @array = qw(1,2,3); say \"match\" if(any{ $_ eq '3'} @array);\n"},{"out":"","code":"use feature 'say'; use List::Util 1.33 'any'; @array = qw(1,2,3); say \"match\" if(any{ $_ eq '4'} @array);\n","err":""},{"code":"use feature 'signatures'; sub add ($x = (return 0), $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]\n","err":"","out":"[0,2,5]"},{"code":"use feature 'signatures'; sub add ($x = return 0, $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]\n","err":"","out":"ERROR: Too many arguments for subroutine at (eval 1) line 1.\n"},{"code":"use feature 'state'; state $x = 4; $x\n","err":"","out":"4"},{"out":"wat","code":"use feature 'switch'; given (0) { when ('0 but true') { print 'wat' } }\n","err":""},{"err":"","code":"use feature 'switch'; given (\"0\") { when ('0 but true') { print 'wat' } default { print 'nope' } }\n","out":"nope"},{"out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use File::Basename; [ fileparse(\"/foo/bar/baz.anyextensionyoulike\", qr/\\.[^.]*/) ]\n","err":""},{"err":"","code":"use File::Basename; [ fileparse(\"/foo/bar/baz.csv\", qr/\\.[^.]*/) ]\n","out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use File::Basename; [ fileparse(\"foo/bar.baz\", qr/[^.]*$/) ]\n","err":"","out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use File::Basename; [ fileparse(\"/foo/bar/baz.txt\", qr/\\.[^.]*/) ]\n","out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tAr.Bz2}, qr{\\.(?:tar.*|zip)}i ];\n","out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tar.fooBarBaz}, q{tar.*}, q{zip} ];\n","err":"","out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tar.gz}, ( map qq{.$_}, map( qq{tar.$_}, qw(gz bz2 xz Z) ), q{zip} ) ];\n","out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tar.gz}, q{tar.*}, q{zip} ];\n"},{"out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tAr.gz}, q{.tar.*}, q{.zip} ];\n"},{"err":"","code":"use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tar.gz.zip},  qr/\\.(?:zip|tar\\..*?)$/i ];\n","out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.ZIP}, qr{\\.(?:tar.*|zip)}i ];\n","out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use File::Basename; fileparse_set_fstype q{MSWin32}; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tAr.gz}, q{.tar.*}, q{.zip} ];\n","err":""},{"code":"use File::Basename; [map +(fileparse $_, qr/(?<=\\.)[^.]+/)[2], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n","err":"","out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use File::Basename; [map +(fileparse $_, qr/[^.]+/)[2], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n","err":"","out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use File::HomeDir; print File::HomeDir->my_data;\n","err":"","out":"ERROR: Can't locate File/HomeDir.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","code":"use Function::Parameters;\n","err":""},{"code":"use Function::Parameters; fun foo(A[[) {}\n","err":"","out":"ERROR: In fun foo: missing type name after '[' at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"    my(%{__rest}) = @_;\n    my $x = ${__rest}{'x'};\n    (%{__rest}) = ();\n    ();\n}","err":"","code":"use Function::Parameters; fun foo(:$x) {}  substr B::Deparse->new()->coderef2text(\\&foo), 1288\n"},{"code":"use Function::Parameters qw(:strict); fun add ($x = return 0, $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]\n","err":"","out":"ERROR: Too many arguments for fun add (expected 1, got 2) at (eval 1) line 1.\n"},{"out":"ERROR: Can't find string terminator \")\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Function::Parameters qw((:strict);; fun add ($x = return 0, $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]\n"},{"code":"use Function::Parameters qw(:strict); fun foo($bar) {print $bar, $bar}; foo(\"hola hoops \", \"error\");\n","err":"","out":"ERROR: Too many arguments for fun foo (expected 1, got 2) at (eval 1) line 1.\n"},{"code":"use Function::Parameters qw(:strict); fun mynumbs :(@$;$) {}\n","err":"","out":""},{"code":"use Function::Parameters qw(:strict); method new($class: :$name, :$value, :$path = '/', :$domain = undef, :$secure = undef, :$expires = undef, :$max_age = undef, :$httponly = undef) { [$name, $value] }  __PACKAGE__->new(name => \"Some_cookie\" -value => \"Some_value\")\n","err":"","out":"ERROR: Too few arguments for method new (expected 5, got 4) at (eval 1) line 1.\n"},{"code":"use Function::Parameters qw(:strict); method new($class: :$name, :$value, :$path = '/', :$domain = undef, :$secure = undef, :$expires = undef, :$max_age = undef, :$httponly = undef) { [$name, $value] }  __PACKAGE__->new(name => \"Some_cookie\", Value => \"Some_value\")\n","err":"","out":"ERROR: In method new: missing named parameter: value at (eval 1) line 1.\n"},{"err":"","code":"use Function::Parameters qw(:strict); substr B::Deparse->new->coderef2text(fun (:$x) {}), 1470\n","out":"(anon)') if @_ > 0 and @_ % 2;\n    my(%{__rest}) = @_;\n    my $x = exists ${__rest}{'x'} ? delete ${__rest}{'x'} : Function::Parameters::_croak('In fun (anon): missing named parameter: x');\n    Function::Parameters::_croak('In fun (anon): no such named parameter: ' . join(', ', sort(keys %{__rest}))) if keys %{__rest};\n    ();\n}"},{"out":"ripts'} = '';\n        $^H{'charnames_short'} = '0';\n        $^H{'charnames_stringified_inverse_ords'} = '';\n        $^H{'charnames_stringified_names'} = '';\n        $^H{'charnames_stringified_ords'} = '';\n    }\n    Function::Parameters::_croak('Too few arguments for fun (anon) (expected 2, got ' . @_ . ')') if @_ < 2;\n    Function::Parameters::_croak('Too many arguments for fun (anon) (expected 2, got ' . @_ . ')') if @_ > 2;\n    my($x, $y) = @_;\n    ();\n}","code":"use Function::Parameters qw(:strict); substr B::Deparse->new->coderef2text( fun ($x, $y) {} ), 1077\n","err":""},{"out":"ERROR: Too few arguments for fun routine (expected 3, got 1) at (eval 1) line 1.\n","code":"use Function::Parameters ':strict'; fun routine($one, $two, $three) {} routine(\"!\");\n","err":""},{"out":"ERROR: \"strict\" is not exported by the Function::Parameters module at (eval 1) line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Function::Parameters 'strict'; strict foo($x) { $x * 2 } foo 21\n"},{"code":"use Function::Parameters; use warnings; fun lala :(_;) {}\n","err":"","out":""},{"err":"","code":"use Hash::Util; $href = { \"foo\"=>\"bar\" }; Hash::Util::lock_ref_keys($href); map { print \"\\\"$_\\\":$href->{$_}\\n\" } %{$href}\n","out":"ERROR: Can't locate Hash/Util.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use Hindsight 20/20;\n","out":"ERROR: Can't locate Hindsight.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use HTML::Entities\n","err":"","out":"ERROR: Can't locate HTML/Entities.pm:   (null): Too many open files at (eval 1) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 2, <STDIN> line 1.\n"},{"err":"","code":"use HTTP::Tiny; my $http = HTTP::Tiny->new; $http->verify_SSL(1)\n","out":"ERROR: Can't locate HTTP/Tiny.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"1","err":"","code":"use if 0 1 == 0, strict; $foo = $bar; 1\n"},{"out":"","err":"","code":"use if 0 1 == 1, strict;\n"},{"code":"use if 1.0 == 0, strict; $foo = $bar; 1\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"use if 1.0 ==\"\n"},{"out":"1","err":"","code":"use if 1+0 == 0, strict; $foo = $bar; 1\n"},{"err":"","code":"use if (1 == 0), strict => \"\"; $foo = $bar; 1\n","out":"1"},{"code":"use if 1 == 0, strict => \"\"; $foo = $bar; 1\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"use if 1 ==\"\n"},{"code":"use if 1 == 0, strict; $foo = $bar; 1\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"use if 1 ==\"\n"},{"err":"","code":"use if 1 == 1, strict; \n","out":"ERROR: syntax error at (eval 1) line 1, near \"use if 1 ==\"\n"},{"out":"ERROR: Global symbol \"$foo\" requires explicit package name (did you forget to declare \"my $foo\"?) at (eval 1) line 1, <STDIN> line 1.\nGlobal symbol \"$bar\" requires explicit package name (did you forget to declare \"my $bar\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"use if (1 == 1), strict; $foo = $bar; 1\n","err":""},{"err":"","code":"use if 1e0 == 0, strict; $foo = $bar; 1\n","out":"1"},{"out":"ERROR: if version 9 required--this is only version 0.0606 at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use if 9;\n"},{"out":"ERROR: Can't locate Image/Magick.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use Image::Magick; print Image::Magick->QuantumDepth\n","err":""},{"err":"","code":"use integer; 1 / 2\n","out":"0"},{"out":"1","err":"","code":"use integer; 5/3\n"},{"out":"[4,6]","err":"","code":"use integer; [ ~-5, -~5 ]\n"},{"err":"","code":"use IO::Handle; my $fh = IO::Handle->new; open $fh , q{>}, \\(my $str); $fh->say( q{foo} ); [ ref $fh ];\n","out":"[\"IO::Handle\"]"},{"code":"use IO::Handle; my $io = IO::Handle->new; ilike $io\n","err":"","out":"ERROR: Can't locate object method \"ilike\" via package \"IO::Handle\" at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"26","code":"use IO::Handle; my $io = IO::Handle->new; length $io\n","err":""},{"err":"","code":"use IO::Handle; open my $fh, '>', \\my $buffer; ref $fh\n","out":"GLOB"},{"out":"ERROR: Can't locate IO/Socket/INET.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use IO::Socket::INET; IO::Socket::INET->new()\n","err":""},{"code":"use IO::Socket::INET;  my $sock = IO::Socket::INET->new(Timeout => 4, Proto => \"tcp\" , PeerAddr => \"www.gamezstorm.com\", PeerPort => 25) or die $!;  for(<$sock>){print $_ ,\"\\n\";}\n","err":"","out":"ERROR: Can't locate IO/Socket/INET.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use IPC::Shm\n","out":"ERROR: Can't locate IPC/Shm.pm:   (null): Too many open files at (eval 1) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 2, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate iso.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use iso-8859-1; uc \"Ã±\"\n","err":""},{"out":"ERROR: Can't locate iso8859.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use iso8859-1; uc \"Ã±\"\n","err":""},{"out":"ERROR: Can't locate iso8859.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use iso8859; uc \"Ã±\"\n"},{"out":"ERROR: Can't call method \"encode_json\" on unblessed reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use JSON (); { abc => 123 }->JSON::encode_json\n"},{"code":"use JSON; from_json q~ { \"a\" : \"b\" } ~\n","err":"","out":"{a => \"b\"}"},{"out":"[{\"name\":3},{\"name\":4}]","err":"","code":"use JSON; @list = ({name => 1}, {name => 2}, {name => 3}, {name => 4}); to_json([grep { $_->{name} > 2 } @list])\n"},{"out":"[\"three\",\"four\"]","code":"use JSON; @list = ({name => 1, x => one}, {name => 2, x => two}, {name => 3, x => three}, {name => 4, x => four}); to_json([map {$_->{x}} grep { $_->{name} > 2 } @list])\n","err":""},{"code":"use JSON'MaybeXS;\n","err":"","out":""},{"err":"","code":"use JSON::MaybeXS; [encode_json [''.1341015082000]]\n","out":"[\"[\\\"1341015082000\\\"]\"]"},{"err":"","code":"use JSON::MaybeXS; [encode_json [1341015082000]]\n","out":"[\"[1341015082000]\"]"},{"out":"ERROR: hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use JSON::MaybeXS; [encode_json 1341015082000]\n"},{"err":"","code":"use JSON::MaybeXS; encode_json { foo => '1.20' }\n","out":"{\"foo\":\"1.20\"}"},{"code":"use JSON::MaybeXS; encode_json { foo => '1.22' }\n","err":"","out":"{\"foo\":\"1.22\"}"},{"out":"{\"foo\":\"1.22\"}","code":"use JSON::MaybeXS; encode_json { foo => sprintf '%.2f', 1.22 }\n","err":""},{"out":"Cpanel::JSON::XS","err":"","code":"use JSON::MaybeXS; JSON()\n"},{"err":"","code":"use JSON::MaybeXS; JSON::MaybeXS->new(allow_nonref => 1, ascii => 0)->encode(\"\\07\")\n","out":"\"\\u0007\""},{"out":"\"\\u2603\"","code":"use JSON::MaybeXS; JSON::MaybeXS->new(allow_nonref => 1, ascii => 1)->encode(\"\\x{2603}\")\n","err":""},{"code":"use JSON::MaybeXS; JSON::MaybeXS->new(allow_nonref => 1)->encode(\"\\07\")\n","err":"","out":"\"\\u0007\""},{"out":"[0,1,2,3,4,5,6,7,11,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]","err":"","code":"use JSON::MaybeXS; my $j = JSON::MaybeXS->new(allow_nonref => 1, ascii => 1); [grep { $j->encode(chr($_)) =~ /\\\\u/ } 0..127]\n"},{"out":"[\"\\\"\\\\u2603\\\"\",\"\\x{2603}\"]","code":"use JSON::MaybeXS; my $json = JSON::MaybeXS->new(allow_nonref => 1, ascii => 1); my $encoded = $json->encode(\"\\x{2603}\"); [$encoded, $json->decode($encoded)]\n","err":""},{"err":"","code":"use JSON::MaybeXS; my $json_str = JSON::MaybeXS->new(allow_nonref => 1, ascii => 1)->encode(\"\\x{2603}\"); [$json_str]\n","out":"[\"\\\"\\\\u2603\\\"\"]"},{"out":"{\n   \"name\" : true\n}\n","err":"","code":"use JSON::MaybeXS; my %test = (name => JSON->true); JSON::MaybeXS->new(pretty => 1)->encode(\\%test)\n"},{"code":"use JSON::MaybeXS; my $var = 1341015082000; [encode_json [\"$var\"]]\n","err":"","out":"[\"[\\\"1341015082000\\\"]\"]"},{"err":"","code":"use JSON; my $aoh = [{1=>2},{3=>4}];my $str=encode_json($aoh); my $new_aoh = decode_json($str); push @{ $new_aoh  }, {5=>6}; my $new_str = encode_json($new_aoh); $new_str\n","out":"[{\"1\":2},{\"3\":4},{\"5\":6}]"},{"err":"","code":"use JSON; my $var = ~~\"0\"; encode_json([$var])\n","out":"[\"0\"]"},{"out":"{\n   \"name\" : true\n}\n","code":"use JSON; use strict; my %test = ( name => \\1, ); print JSON->new->pretty->encode(\\%test);\n","err":""},{"out":"[\"\\x{1d11e}\"]","err":"","code":"use JSON::XS; decode_json('[\"\\ud834\\udd1e\"]')\n"},{"out":"ERROR: Can't locate less.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use less 'abomination';\n"},{"out":"ERROR: Can't locate Lingua/EN/Numbers.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Lingua::EN::Numbers qw(num2en);Â sub isodd {return (num2en shift) =~ /e.?$/}Â \n"},{"err":"","code":"use List::MoreUtils 'any'; if (any {$_ eq 'a'}, 'b', 'c') { 1 }\n","out":"1"},{"err":"","code":"use List::MoreUtils 'firstidx'; sub merge_refs { my $input = shift; return $input unless @_; my @indices; for my $ref (@_) { push @indices, firstidx { $ref == \\$_ } @$input }; my $merged = $input->[pop @indices]; unshift @$merged, @{splice @$input, $_, 1} for @indices; return $input } my $x = [ [1,2], [3,4], [5,6,7,8] ]; merge_refs $x, \\$x->[0], \\$x->[2];\n","out":"[[3,4],[1,2,5,6,7,8]]"},{"out":"[1,2,3,\"above\",4,5,6,7]","err":"","code":"use List::MoreUtils qw(firstidx); my $y = 3; my @list = (1,2,3,4,5,6,7); splice @list, $_, 0, 'above' for grep defined, firstidx { $_ > $y } @list; \\@list\n"},{"out":"{x => {b => 3,c => 2,a => 1},z => {a => 3}}","code":"use List::MoreUtils qw(uniq); my %x = (x => {a => 1, c => 2}, z => { a => 3 }); my %y = (x => {b => 3}, z => {a => 4}); my %z = %x; for my $k (uniq keys(%x), keys(%y)) { $z{$k}{$_} = $y{$k}{$_} for grep !exists $x{$k}{$_}, keys %{$y{$k}} } \\%z\n","err":""},{"out":"[\"a\",\"b\",\"c\",\"a\"]","err":"","code":"use List::MoreUtils qw/uniq/; [ sort uniq qw/a b c a/ ];\n"},{"out":"[\"a\",\"b\",\"c\",\"a\"]","err":"","code":"use List::MoreUtils qw/uniq/; [ sort(uniq qw/a b c a/) ];\n"},{"out":"[\"a\",\"b\",\"c\"]","err":"","code":"use List::MoreUtils qw/uniq/; [ sort(uniq(qw/a b c a/)) ];\n"},{"err":"","code":"use List::MoreUtils qw/uniq/; [ uniq qw/a b c a/ ];\n","out":"[\"a\",\"b\",\"c\"]"},{"out":"1","code":"use List::MoreUtils qw(zip); $ab = [ \"a\",\"b\"]; $xyz = [\"u\",\"v\",\"a\",\"b\",\"w\"]; grep defined, @{ { zip @$xyz, @$xyz } }{@$ab} == @$ab\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"&zip \\\"\n","code":"use List::MoreUtils qw(zip); my @list = qw( AAA BBB CCC ); [ &zip \\@list, [('|') x @list - 1] ]\n","err":""},{"out":"ERROR: Type of arg 2 to List::MoreUtils::mesh must be array (not subtraction (-)) at (eval 1) line 1, near \"1 ]\"\n","code":"use List::MoreUtils qw(zip); my @list = qw( AAA BBB CCC ); [ zip @list, ('|') x @list - 1 ]\n","err":""},{"code":"use List::MoreUtils qw(zip); my @list = qw( AAA BBB CCC ); [ &zip(\\@list, [('|') x @list - 1]) ]  # hardly worth it\n","err":"","out":"[\"AAA\",-1,\"BBB\",undef,\"CCC\",undef]"},{"err":"","code":"use List::Util 0.0 qw(9999);\n","out":"ERROR: List::Util version 9999 required--this is only version 1.4202 at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/Exporter/Heavy.pm line 125, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use List::Util 0 qw(9999);\n","out":"ERROR: List::Util version 9999 required--this is only version 1.4202 at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/Exporter/Heavy.pm line 125, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use List::Util 1.33 'any';@array = qw(1 2 3); print \"match\" if(any{ $_ eq '4'} @array);\n","err":"","out":""},{"out":"ERROR: List::Util version 9999 required--this is only version 1.4202 at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/Exporter/Heavy.pm line 125, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use List::Util '9999';\n"},{"out":"ERROR: List::Util version 9999 required--this is only version 1.4202 at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/Exporter/Heavy.pm line 125, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use List::Util (9999);\n","err":""},{"out":"ERROR: Can't \"goto\" out of a pseudo block at (eval 1) line 1, <STDIN> line 1.\n","code":"use List::Util 'first';  first { goto HERE } 1, 2, 3; HERE: print \"hello\"\n","err":""},{"out":"1.4202","err":"","code":"use List::Util; $List::Util::VERSION\n"},{"out":"3","code":"use List::Util 'max';max 2,3;\n","err":""},{"code":"use List::Util 'max';max 2,3;max(2,3);\n","err":"","out":"3"},{"out":"9","err":"","code":"use List::Util 'max';  max(4, 9)\n"},{"out":"1","code":"use List::Util; my $c = [qw(a b c)]; print \"1\" if List::Util::any { $_ eq \"a\" } @{$c}\n","err":""},{"out":"0","err":"","code":"use List::Util 'product';  product 0, 1\n"},{"code":"use List::Util () qw(9999);\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \") qw(9999)\"\n"},{"out":"ERROR: List::Util version 9999 required--this is only version 1.4202 at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/Exporter/Heavy.pm line 125, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use List::Util qw(9999);\n"},{"code":"use List::Util qw(any 9999);\n","err":"","out":"ERROR: List::Util version 9999 required--this is only version 1.4202 at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/Exporter/Heavy.pm line 125, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use List::Util qw(any); my @x = qw(a b c); my @y = qw(d e f); for my $_ (@x) { print \"found\" if any { /b/ } @y } # I know it's in Texas, probably in Tennnessee...\n","err":"","out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\nType of arg 1 to List::Util::any must be block or sub {} (not reference constructor) at (eval 1) line 1, at EOF\n"},{"out":"2","err":"","code":"use List::Util qw/first/; --$i if first { $i++; /z/ } qw/foo bar baz/   # even more vomit inducing\n"},{"err":"","code":"use List::Util qw(first); my $y = 3; my @list = (1,2,3,4,5,6,7); $_ = 'above' for grep defined, first { $_ > $y } @list; \\@list # ?\n","out":"[1,2,3,\"above\",5,6,7]"},{"out":"[30]","err":"","code":"use List::Util qw(max); my $str = '( G1 Z0.252 F7200.000 )'; [ max 30, $str =~ /G1 Z(\\d+\\.\\d+)/ ];\n"},{"code":"use List::Util qw(max); my $str = '( G1 Z0.252 F7200.000 )'; my ($value) = $str =~ /G1 Z(\\d+\\.\\d+)/; max 30, $value\n","err":"","out":"30"},{"out":"ERROR: Experimental push on scalar is now forbidden at (eval 1) line 1, at EOF\nType of arg 1 to List::Util::pairmap must be block or sub {} (not reference constructor) at (eval 1) line 1, at EOF\n","err":"","code":"use List::Util qw( pairmap ); do { my %pairs; pairmap { push $pairs{$a}, $b; } ( \"x\", \"1\", \"x\", \"2\", \"y\", \"baz\" ); \\%pairs; };\n"},{"out":"{x => [1,2],y => [\"baz\"]}","err":"","code":"use List::Util qw( pairmap ); my %pairs; pairmap { push @{ $pairs{$a} }, $b; } ( \"x\", \"1\", \"x\", \"2\", \"y\", \"baz\" ); \\%pairs\n"},{"out":"[\"T\",\"F\",\"T\",\"T\"]","err":"","code":"use List::Util qw(pairmap); [ pairmap { !($a * !$b) ? 'T' : 'F' } qw(1 1 1 0 0 1 0 0) ]\n"},{"code":"use List::Util qw(pairmap); [ pairmap { !$a || $b ? 'T' : 'F' } qw(1 1 1 0 0 1 0 0) ]\n","err":"","out":"[\"T\",\"F\",\"T\",\"T\"]"},{"out":"3628800\n","err":"","code":"use List::Util qw(product); say product 1..10;\n"},{"out":"[\"a list of errors\"]","code":"use List::Util qw(reduce); my @ar = qw /a list of errors/; [reduce {$a.\" \".$b} @ar]\n","err":""},{"err":"","code":"use List::Util qw(reduce); my @output; reduce { push @output, ($a, $b); $b } qw(1 2 3 4 5); \\@output\n","out":"[1,2,2,3,3,4,4,5]"},{"out":"0","code":"use List::Util qw(reduce); reduce {$1*$b} 1..10;\n","err":""},{"code":"use List::Util qw(reduce); reduce {$a*$b} 1..10;\n","err":"","out":"3628800"},{"out":"[12,24]","err":"","code":"use List::Util qw(sum0); [ map sum0(@$_), grep $_->[0] ** 2 == $_->[1] ** 2 + $_->[2] ** 2, map { my ($x, $y) = @$_; map [ $x, $y, $_ ], 1..$y } map { my $x = $_; map [ $x, $_ ], 1..$x } 1..10 ] # probably wrong, but you can see why the map approach isn't great here\n"},{"code":"use List::Util qw(sum); chr sum map ord, qw(A B C);\n","err":"","out":"ÃÂ"},{"out":"[262]","err":"","code":"use List::Util qw/sum/; [ sum '92.168.1.1' =~ /(\\d+)/g ]\n"},{"out":"198","code":"use List::Util qw(sum); sum map ord, qw(A B C);\n","err":""},{"out":"1","err":"","code":"use List::Util 'reduce';  reduce { die \"BOK\" } 1\n"},{"code":"use List::Util 'reduce';  reduce { die \"BOK\" } 1, 2\n","err":"","out":"ERROR: BOK at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use List::Util 'reduce';  reduce { die \"BOK\" } 1. 2\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"1. 2\"\n"},{"code":"use List::UtilsBy;\n","err":"","out":""},{"out":"[[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\"],[\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\"],[\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]]","err":"","code":"use List::UtilsBy 'bundle_by'; my @array = split '', 'abcdefghijklmnopqrstuvwxyz'; [bundle_by { [@_] } 9, @array]\n"},{"code":"use List::UtilsBy qw(partition_by); +{ partition_by { $_ % 3 } 1..12 } # perlbot has all the things\n","err":"","out":"{1 => [1,4,7,10],0 => [3,6,9,12],2 => [2,5,8,11]}"},{"code":"use List::UtilsBy qw(sort_by); [ sort_by { $_->{name} } { name => 'x' }, { name => 'y' }, { name => 'z' } ]\n","err":"","out":"[{name => \"x\"},{name => \"y\"},{name => \"z\"}]"},{"code":"use List::UtilsBy qw(zip_by); @a=map{$_%10}zip_by{$_[0]+$_[1]}[9,5,3],[map{9-$_}1,7,6];++@a[-1]; [@a]\n","err":"","out":"[7,7,7]"},{"err":"","code":"use List::UtilsBy 'sort_by'; @topics = qw/alias:topic alias:topic2 topic/; %t =map { s/^alias://r => $_ } sort_by { ! /^alias:/ } @topics; [ values %t ]\n","out":"[\"topic\",\"alias:topic2\"]"},{"out":"{\"alias:topic\" => \"topic\",\"alias:topic2\" => \"topic2\"}","err":"","code":"use List::UtilsBy 'sort_by'; @topics = qw/alias:topic topic2 topic/; %t =map { (/^alias:/ ? $_ : \"alias:$_\") => $_ } sort_by { ! /^alias:/ } @topics; \\%t\n"},{"out":"[\"topic\",\"topic2\"]","err":"","code":"use List::UtilsBy 'sort_by'; @topics = qw/alias:topic topic2 topic/; %t =map { s/^alias://r => $_ } sort_by { ! /^alias:/ } @topics; [ values %t ]\n"},{"out":"{\"alias:topic\" => \"topic\",\"alias:topic2\" => \"topic2\"}","err":"","code":"use List::UtilsBy 'sort_by'; @topics = qw/topic topic2 alias:topic/; %t =map { (/^alias:/ ? $_ : \"alias:$_\") => $_ } sort_by { ! /^alias:/ } @topics; \\%t\n"},{"out":"{\"alias:topic\" => \"alias:topic\",\"alias:topic2\" => \"topic2\"}","code":"use List::UtilsBy 'sort_by'; @topics = qw/topic topic2 alias:topic/; %t =map { (/^alias:/ ? $_ : \"alias:$_\") => $_ } sort_by { /^alias:/ } @topics; \\%t\n","err":""},{"out":"AaBbCc","err":"","code":"use List::UtilsBy 'zip_by'; my $u = 'ABC'; my $l = 'abc'; join '', zip_by { @_ } map { [split //] } $u, $l\n"},{"err":"","code":"use List::UtilsBy 'zip_by'; my $u = 'ABC'; my $l = 'abc'; join '', zip_by { @_ } [split //, $u], [split //, $l]\n","out":"AaBbCc"},{"out":"2.08062395121219","code":"use List::Util 'sum'; sum map { 1 / $_ } ( 1,3,5,7,9,11,13,15,17 )\n","err":""},{"code":"use List::Util 'sum'; sum map { 1 / $_ } ( 1,3,5,7,9,13,15,17,19 )\n","err":"","out":"2.04234643925046"},{"out":"ERROR: Can't call method \"max\" on an undefined value at (eval 1) line 1, <STDIN> line 1.\n","code":"use List::Util; use strict; use warnings; my $y = max $a, $b; # perl5.20 gives me \"Useless use of a variable in void context\" there, not sure why this one doesn't\n","err":""},{"out":"ERROR: Can't locate LWP/UserAgent.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use LWP::UserAgent; my $ua = LWP::UserAgent->new; length $ua\n","err":""},{"err":"","code":"use manager::dedicated::dedicated.fr;\n","out":"ERROR: syntax error at (eval 1) line 1, near \"use manager::dedicated::dedicated.\"\n"},{"err":"","code":"use Math::BigInt\n","out":""},{"out":"[bless( {sign => \"NaN\",value => [0]}, 'Math::BigInt' )]","code":"use Math::BigInt; [157 + \"9.95\" + Math::BigInt->new(13) + 0]\n","err":""},{"out":"Inf","code":"use Math::BigInt; 1e1000\n","err":""},{"code":"use Math::BigInt; 2790**2753 % 3233\n","err":"","out":"NaN"},{"code":"use Math::BigInt; atan2(0, -1);\n","err":"","out":"3.14159265358979"},{"code":"use Math::BigInt; Math::BigInt->new(\"3432902008176640045\")\n","err":"","out":"bless( {sign => \"+\",value => [176640045,432902008,3]}, 'Math::BigInt' )"},{"out":"[\"0x7d0\"]","code":"use Math::BigInt; my $x = Math::BigInt->new(2000); [ $x->as_hex ]\n","err":""},{"out":"24","err":"","code":"use Math::BigInt; $x=Math::BigInt->new(4); print $x->bfac();\n"},{"out":"242","err":"","code":"use Math::BigInt; $x=Math::BigInt->new(4); $y=Math::BigInt->new(2); print $x->bfac(); print $y->bfac();\n"},{"out":"ERROR: Can't locate Math/Complex.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Math::Complex; sqrt -1\n"},{"err":"","code":"use Math::Round; round(3.2939232942 * 100) / 100\n","out":"ERROR: Can't locate Math/Round.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate Math.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Math; sqrt -1;\n"},{"out":"ERROR: Can't locate MIME/Base64.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use MIME::Base64;\n","err":""},{"code":"use Missing::Thing;\n","err":"","out":"ERROR: Can't locate Missing/Thing.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use Module::Build\n","err":"","out":"ERROR: Can't locate Module/Build.pm:   (null): Too many open files at (eval 1) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 2, <STDIN> line 1.\n"},{"err":"","code":"use Module::Corelist; [ Module::Corelist->first_release( 'experimental' ) ]\n","out":"ERROR: Can't locate Module/Corelist.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use Module::CoreList; [ Module::CoreList->first_release( 'experimental' ) ]\n","out":"ERROR: Can't locate Module/CoreList.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate Mojo/DOM.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Mojo::DOM;\n"},{"out":"ERROR: Can't locate Mojo/DOM.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use Mojo::DOM; my $dom = Mojo::DOM->new('<html><head></head><body></body></html>'); $dom->at('head')->append_content('<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"></meta>'); $dom->to_string\n","err":""},{"err":"","code":"use Mojo::DOM; my $dom = Mojo::DOM->new('<html><head></head><body></body></html>'); $dom->at('head')->append('<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"></meta>'); $dom\n","out":"ERROR: Can't locate Mojo/DOM.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate Mojo/DOM.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use Mojo::DOM; my $dom = Mojo::DOM->new('<html><head></head><body></body></html>'); $dom->at('head')->append('<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"></meta>'); $dom->to_string\n","err":""},{"err":"","code":"use Mojo::DOM; use Mojo::DOM::CSS; use Mojo::Collection;\n","out":"ERROR: Can't locate Mojo/DOM.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate Mojo/JSON.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Mojo::JSON; my $var = 1341015082000; [encode_json [\"$var\"]]\n"},{"err":"","code":"use Mojo::Util 'punycode_decode'; encode 'UTF-8', punycode_decode 'wkr'\n","out":"ERROR: Can't locate Mojo/Util.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use Mojo::Util 'punycode_decode'; encode 'UTF-8', punycode_decode zkr\n","out":"ERROR: Can't locate Mojo/Util.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate Mojo/Util.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Mojo::Util 'punycode_encode', 'decode'; punycode_encode decode('UTF-8', 'â')\n"},{"err":"","code":"use Mojo::Util 'punycode_encode'; punycode_encode decode('UTF-8', 'â')\n","out":"ERROR: Can't locate Mojo/Util.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate Moo.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Moo;\n"},{"out":"","err":"","code":"use Moose ()\n"},{"out":"","err":"","code":"use Moose;\n"},{"out":"7","code":"use Moose; 7;\n","err":""},{"out":"ERROR: Can't locate Net/HTTP/Spore.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use Net::HTTP::Spore;\n","err":""},{"out":"ERROR: Can't locate Number/Format.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use Number::Format qw(:subs :vars); $THOUSANDS_SEP = '.'; my $a = 123456789; say format_number($a);\n","err":""},{"out":"ERROR: Can't locate open.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use open IN  => \":crlf\", OUT => \":bytes\"; [ ${^OPEN} ]\n"},{"out":"ERROR: Can't locate or.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use or die perl;\n","err":""},{"err":"","code":"use overload q|\"\"| => sub { 42 }; my @a; $a[42] = 'forty two'; [ $a[bless {}, 'main'] ]\n","out":"[\"forty two\"]"},{"out":"ERROR: Died at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use overload qw,\"\",=> sub { die }; bless {}, bless []; 42;\n"},{"code":"use overload '\"\"' => sub { \"\" }, \"bool\" => sub { 1 }; my $foo = bless []; if( $foo ) { print \"_${foo}\" } else { print \"aww\" }\n","err":"","out":"_"},{"code":"use overload '@{}' => sub { print 'converting to array'; ['42'] }; my $foo; bless \\$foo; (\\$foo)->[0];\n","err":"","out":"converting to array"},{"out":"ERROR: Undefined subroutine &main::primt called at (eval 1) line 1, <STDIN> line 1.\n","code":"use overload '@{}' => sub { print 'converting to array'; ['42'] }; my $foo; bless \\$foo; primt (\\$foo)->[0];\n","err":""},{"code":"use overload '@{}' => sub { print 'converting to array'; ['42'] }; my $foo; bless \\$foo; print + (\\$foo)->[0];\n","err":"","out":"converting to array42"},{"code":"use overload '+' => sub { print \"foo\" }; my $x = bless []; $x + 2;\n","err":"","out":"foo"},{"out":"converting to array\n","err":"","code":"use overload '@{}' => sub { say 'converting to array'; ['42'] }; my $foo; bless \\$foo; (\\$foo)->[0];\n"},{"out":"Just another Perl hacker,","err":"","code":"use overload '\"\"' => sub { shift @{ shift() } || '' }; $, = bless [' another ', ' hacker']; print qw(Just Perl ,);\n"},{"err":"","code":"use overload '\"\"' => sub { \"wibble\" }; $x = []; bless $x; $y = []; bless $y, $x; ref $y\n","out":"wibble"},{"err":"","code":"use Perl;\n","out":"ERROR: Can't locate Perl.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"3.29","code":"use POSIX; floor((3.2949232942 + 0.005) * 100)/100\n","err":""},{"out":"3.3","code":"use POSIX; floor((3.2959232942 + 0.005) * 100)/100\n","err":""},{"code":"use POSIX qw(atan); 4*atan(1) # if you disapprove of passing multiple parameters to a function, there are alternatives\n","err":"","out":"3.14159265358979"},{"code":"use POSIX qw(floor); floor(5/3)\n","err":"","out":"1"},{"code":"use POSIX qw/locale_h/; say setlocale(LC_TIME, \"ja_JP.utf-8\");\n","err":"","out":"\n"},{"err":"","code":"use POSIX qw( modf ); my $n = 1.2345; sprintf q{%02d%s}, reverse map { s/^0+//r } modf $n; ### leobut\n","out":"01.2345"},{"out":"01","code":"use POSIX qw( modf ); my $n = 1; sprintf q{%02d%s}, reverse map { s/^0+//r } modf $n; ### leobut\n","err":""},{"err":"","code":"use POSIX qw(sysconf); [ sysconf(_SC_PAGE_SIZE) ]\n","out":"[78643200]"},{"out":"23.45","err":"","code":"use POSIX; setlocale(LC_NUMERIC, \"de_DE\"); sprintf(\"%.2f\", 23.45)\n"},{"err":"","code":"use Psychic::Hotline;\n","out":"ERROR: Can't locate Psychic/Hotline.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use Quote::Code\n","out":"ERROR: Can't locate Quote/Code.pm:   (null): Too many open files at (eval 1) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 2, <STDIN> line 1.\n"},{"err":"","code":"use Quote::Code; qc{!}\n","out":"ERROR: Can't locate Quote/Code.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate Quote/Code.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use Quote::Code; [ qcw< a {$_} b > ]\n","err":""},{"err":"","code":"[ 'user:anything-else:' !~ /^user:!!:$/ ]\n","out":"[1]"},{"out":"1","err":"Compiling REx \"^+\"\nFinal program:\n   1: CURLYX[0]{1,INFTY} (5)\n   3:   SBOL /^/ (4)\n   4: WHILEM[1/1] (0)\n   5: NOTHING (6)\n   6: END (0)\nanchored(SBOL) minlen 0 \nMatching REx \"^+\" against \"\"\n   0 <> <>                   |   0| 1:CURLYX[0]{1,INFTY}(5)\n   0 <> <>                   |   1|  4:WHILEM[1/1](0)\n                             |   1|  whilem: matched 0 out of 1..32767\n   0 <> <>                   |   2|   3:SBOL /^/(4)\n   0 <> <>                   |   2|   4:WHILEM[1/1](0)\n                             |   2|   whilem: matched 1 out of 1..32767\n                             |   2|   whilem: empty match detected, trying continuation...\n   0 <> <>                   |   3|    5:NOTHING(6)\n   0 <> <>                   |   3|    6:END(0)\nMatch successful!\nFreeing REx: \"^+\"\n","code":"use re 'debug'; /^+/\n"},{"code":"use re 'debug'; /a(bc)+/o;\n","err":"Compiling REx \"a(bc)+\"\nFinal program:\n   1: EXACT <a> (3)\n   3: CURLYM[1]{1,INFTY} (13)\n   7:   EXACT <bc> (11)\n  11:   SUCCEED (0)\n  12: NOTHING (13)\n  13: END (0)\nanchored \"abc\" at 0 floating \"bc\" at 1..9223372036854775807 (checking anchored) minlen 3 \nFreeing REx: \"a(bc)+\"\n","out":""},{"out":"ERROR: Can't locate Regexp/Assemble.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use Regexp::Assemble;\n","err":""},{"err":"","code":"use Regexp::Common; (\"12 bananas buys you 0.1231e10 ruby\" =~ /$RE{num}{real}/g)[1]\n","out":"0.1231e10"},{"out":"","err":"","code":"use Regexp::Common; print \"ok\" if (\"foo bar)\" eq \"(foo bar))\" =~ s/($RE{balanced}{-parens => \"()\"})/$1/r);\n"},{"err":"","code":"use Regexp::Common qw/net/; my $ip = q(100.10.1.101); [$ip =~ /$RE{net}{IPv4}/]\n","out":"[1]"},{"err":"","code":"use Regexp::Common qw/net/; my $ip = q(100.10.1.101); [$ip =~ /\\[$RE{net}{IPv4}\\]/]\n","out":"[]"},{"code":"use Regexp::Common qw/net/; my $ip = q(100.10.1.101); [$ip =~ /($RE{net}{IPv4})/] # I meant that\n","err":"","out":"[\"100.10.1.101\"]"},{"code":"use Regexp::Common qw( net ); $_ = q(00:11:22:33:44:55); if (/$RE{net}{MAC}{-keep}/) { print \"<b>$3:$4</b>\"; }\n","err":"","out":"<b>11:22</b>"},{"out":"ERROR: Can't locate Return/MultiLevel.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use Return::MultiLevel;\n","err":""},{"out":"[\"\"]","code":"[ 'user:!!:' !~ /^user:!!:$/ ]\n","err":""},{"out":"1","err":"","code":"'user' =~ /user(?!-agent)/\n"},{"out":"","code":"use Scalar::Util\n","err":""},{"out":"[\"Regexp\"]","err":"","code":"use Scalar::Util 'blessed'; my $re = qr/hai/; [blessed $re]\n"},{"err":"","code":"use Scalar::Util 'looks_like_number'; looks_like_number '10%s'\n","out":""},{"err":"","code":"use Scalar::Util 'looks_like_number'; looks_like_number('123abc   ')\n","out":""},{"code":"use Scalar::Util 'looks_like_number'; looks_like_number('     9') ? 1 : 0\n","err":"","out":"1"},{"err":"","code":"use Scalar::Util 'looks_like_number'; my $s = qq{ 123 4.5 0xFF 5E7 }; [ grep looks_like_number $_, split /\\s+/, $s ];\n","out":"[123,\"4.5\",\"5E7\"]"},{"code":"use Scalar::Util 'looks_like_number'; my $s = qq{ 123 4.5 0xFF 5E7 }; [ map 0+$_, grep looks_like_number $_, split /\\s+/, $s ];\n","err":"","out":"[123,\"4.5\",50000000]"},{"out":"aww","code":"use Scalar::Util qw(dualvar); my $foo = dualvar 42, \"\"; if ($foo) { print \"_${foo}_\"; } else { print \"aww\"; }\n","err":""},{"out":"[\"two\",\"one\"]","code":"use Scalar::Util qw/dualvar/; my $i = dualvar 1, 'forty two'; my @a = qw/one two/; [ $a[ $i ], $a[ \"$i\" ] ]; # fun :)\n","err":""},{"out":"[12,\"twelve\"]","code":"use Scalar::Util qw(dualvar); my $x = dualvar 12, 'twelve'; my $y = $x; [ 0+$y, \"$y\" ] # so something like this\n","err":""},{"out":"[42,\"forty two\"]","code":"use Scalar::Util qw/dualvar/; my $x = dualvar 42, 'forty two'; [$x+0, \"$x\"]\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"use Scalar::Util qw/dualvar/; my $x = dualvar 42, 'forty two'; [$x+0, \"$x\"]>\n","err":""},{"out":"[\"foo\",42]","err":"","code":"use Scalar::Util qw/dualvar/; $x = dualvar 42, 'foo'; [ $x.'', $x+0 ]\n"},{"err":"","code":"use Scalar::Util qw(looks_like_number); looks_like_number '4'\n","out":"1"},{"out":"\\o/","code":"use Scalar::Util qw(looks_like_number); looks_like_number 'infinity' ? '\\o/' : '/o\\\\'\n","err":""},{"out":"1","err":"","code":"use Scalar::Util qw(looks_like_number); looks_like_number 'Inf'  # wat\n"},{"out":"1","code":"use Scalar::Util qw(looks_like_number); looks_like_number 'nan'\n","err":""},{"code":"use Scalar::Util qw(looks_like_number); looks_like_number 'NAN'\n","err":"","out":"1"},{"out":"","code":"use Scalar::Util qw(looks_like_number); looks_like_number 'nandos';\n","err":""},{"out":"[1]","code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'sNan' ]\n","err":""},{"out":"{23 => \"Yes\",106000 => \"Yes\",-32 => \"Yes\",\"123.456\" => \"Yes\",255 => \"Yes\",\"0xFF\" => \"No\",FF => \"No\",abc => \"No\",0 => \"Yes\"}","err":"","code":"use Scalar::Util qw(looks_like_number); +{ map { $_ => looks_like_number $_ ? q{Yes} : q{No} } 0, 123.456, 10.6E4, q{abc}, q{FF}, q{0xFF}, 0xFF, +23, \"-32\" }; ### Seems to fill my needs. I'm wondering if there are any gotchas.\n"},{"out":"[69636144,69636144]","code":"use Scalar::Util qw(refaddr); my $meow = []; [refaddr($meow), refaddr(\\@{$meow})]\n","err":""},{"out":"[\"\"]","code":"use Scalar::Util qw( refaddr); sub foo { } my $foo = \\&foo; my $bar = \\&bar; [ refaddr $foo eq refaddr $bar ]\n","err":""},{"err":"","code":"use Scalar::Util qw/reftype blessed/; my $obj = bless {}, 'ARRAY'; my $obj2 = bless {}, 'Foo'; { obj => [ ref($obj), reftype($obj), blessed($obj) ], obj2 => [ref($obj2), reftype($obj2), blessed($obj2)], ref => [ ref([]), reftype([]), blessed([]) ]\n","out":"ERROR: Missing right curly or square bracket at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, at EOF\n"},{"out":"{obj2 => [\"Foo\",\"HASH\",\"Foo\"],ref => [\"ARRAY\",\"ARRAY\",undef],obj => [\"ARRAY\",\"HASH\",\"ARRAY\"]}","code":"use Scalar::Util qw/reftype blessed/; my $obj = bless {}, 'ARRAY'; my $obj2 = bless {}, 'Foo'; { obj => [ ref($obj), reftype($obj), blessed($obj) ], obj2 => [ref($obj2), reftype($obj2), blessed($obj2)], ref => [ ref([]), reftype([]), blessed([]) ] }\n","err":""},{"out":"[\"IO\"]","err":"","code":"use Scalar::Util qw,reftype,; [ reftype *STDOUT{IO} ]\n"},{"err":"","code":"use Scalar::Util qw(weaken); my $v; $v = sub { my $x = $v; 1 }; $v->(); weaken $v; die if $v # dropping the extra var and moving weaken() after the call looks okay to me\n","out":""},{"out":"[43073584,51662576,{foo => 43}]","code":"use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $h2={foo=>43}; %$h=%$h2; [ refaddr($h), refaddr($h2), $h ]\n","err":""},{"err":"","code":"use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $h2={foo=>43}; %$h=%h2; [ refaddr($h), refaddr($h2), $h ]\n","out":"[44400688,52989680,{}]"},{"out":"ERROR: Can't call method \"mh\" on an undefined value at (eval 1) line 1, <STDIN> line 1.\n","code":"use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $hadd1 = refaddr $h; my $h2={foo=>43}; mh $h2add1 = refaddr $h2; %$h=%h2; [ $hadd1, $h2add1, refaddr($h), refaddr($h2), $h ]\n","err":""},{"out":"[71766064,80355056,71766064,80355056,{foo => 43}]","code":"use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $hadd1 = refaddr $h; my $h2={foo=>43}; my $h2add1 = refaddr $h2; %$h=%$h2; [ $hadd1, $h2add1, refaddr($h), refaddr($h2), $h ]\n","err":""},{"out":"[51978288,60567280,51978288,60567280,{}]","code":"use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $hadd1 = refaddr $h; my $h2={foo=>43}; my $h2add1 = refaddr $h2; %$h=%h2; [ $hadd1, $h2add1, refaddr($h), refaddr($h2), $h ]\n","err":""},{"out":"[71884848,71884848]","code":"use Scalar::Util 'refaddr'; my $h = { foo => 42 }; [ refaddr($h), refaddr(\\%{$h}) ]\n","err":""},{"code":"use Scalar::Util 'reftype'; eval: $x = 'three'; $y = \\$x; [ reftype $x, reftype $y ] #as contrast\n","err":"","out":"[undef,\"SCALAR\"]"},{"code":"use Scalar::Util 'reftype'; eval: $x = 'three'; $y = \\$x; $x = \\$x; [ reftype $x, reftype $y ]\n","err":"","out":"[\"REF\",\"REF\"]"},{"out":"ARRAY","code":"use Scalar::Util 'reftype'; my $r = bless [], \"HASH\";  reftype $r\n","err":""},{"code":"use Scalar::Util 'reftype'; [ ref undef, reftype undef ]\n","err":"","out":"[\"\",undef]"},{"code":"use Scalar::Util 'weaken'; my $foo = {}; my $bar = {}; my $closure; { my ($foo2, $bar2) = ($foo, $bar); $closure = sub { $foo2 }; } weaken $foo; weaken $bar; [$foo, $bar]\n","err":"","out":"[{},undef]"},{"err":"","code":"use signatures; sub foo () { 5 } say foo, \"bar\";\n","out":"ERROR: Can't locate signatures.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate Socket.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Socket 'inet_aton'; [unpack 'N', inet_aton '92.168.1.1']\n"},{"err":"","code":"use Socket 'pack_sockaddr_in6'; length pack_sockaddr_in6( 80, \"\\0\" x 16 )\n","out":"ERROR: Can't locate Socket.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use Socket::pack_sockaddr_in6; length pack_sockaddr_in6( 80, \"\\0\" x 16 )\n","out":"ERROR: Can't locate Socket/pack_sockaddr_in6.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use Socket qw(inet_pton AF_INET6); my $ip_addr = inet_pton(AF_INET6, \"::ffff:127.0.0.1\"); $ip_addr\n","out":"ERROR: Can't locate Socket.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use Socket;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in(8989,inet_aton(\"107.191.117.124\")))){print S hi};\n","out":"ERROR: Can't locate Socket.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[[],[]]","code":"use Storable qw,dclone,; my @arr = ([], []); my $copyref = dclone(\\@arr); $copyref->[0][0] = 3; \\@arr\n","err":""},{"err":"","code":"use Storable; use strict; use warnings; my $x = { A => 123, B => q/foo/, C => [ qw(x y z) ] }; my $y = Storable::dclone $x; [ $x, $y ];\n","out":"[{A => 123,B => \"foo\",C => [\"x\",\"y\",\"z\"]},{A => 123,B => \"foo\",C => [\"x\",\"y\",\"z\"]}]"},{"out":"ERROR: Can't store REGEXP items at (eval 1) line 1, <STDIN> line 1.\n","code":"use Storable; use strict; use warnings; my $x = { A => 123, B => qr/foo/, C => [ qw(x y z) ] }; my $y = Storable::dclone $x; [ $x, $y ];\n","err":""},{"out":"ERROR: Can't store REGEXP items at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Storable; use strict; use warnings; my $x = { A => 123, B => qr/foo/, C => [ qw(x y z) ] }; my $y = Storable::dclone $x; [ $x, $y ]; ### Why is it so hard to clone Regexp objects?\n"},{"out":"","err":"","code":"use strict;\n"},{"out":"[60]","err":"","code":"use strict; [ %~, @/, $= ]\n"},{"code":"use strict; 0->[0];\n","err":"","out":""},{"code":"use strict; &{0 == &{0 == 0}} * 0\n","err":"","out":"0"},{"out":"","code":"${use strict; 1;};\n","err":""},{"out":"ERROR: Can't use string (\"1\") as a SCALAR ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; ${;1}\n","err":""},{"out":"","code":"use strict; ${1}\n","err":""},{"out":"ERROR: Can't use string (\"2\") as a SCALAR ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; ${1 + 1}\n","err":""},{"out":"","code":"use strict; 1234->{key}\n","err":""},{"out":"ERROR: Can't use string (\"57\") as a SCALAR ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; \"${ 12+45 }\"\n","err":""},{"out":"","code":"use strict; ${2}\n","err":""},{"out":"ERROR: Undefined subroutine &main::404 called at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; 404->();\n","err":""},{"err":"","code":"use strict; *4 = sub { 'ok' }; &{4};\n","out":"ok"},{"out":"ok","code":"use strict; *4 = sub { 'ok' }; main->${ \\4 };\n","err":""},{"code":"use strict; @5 = \"hi\";\n","err":"","out":"1"},{"err":"","code":"use strict; @5 = \"hi\"; \\@5\n","out":"[\"hi\"]"},{"out":"ERROR: Global symbol \"@a\" requires explicit package name (did you forget to declare \"my @a\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; @a\n","err":""},{"code":"use strict; $a->[0];\n","err":"","out":""},{"code":"use strict; a->[0]\n","err":"","out":"ERROR: Can't use bareword (\"a\") as an ARRAY ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use strict; $a = \"it works\"; print \"${chr 97}\"\n","err":"","out":"ERROR: Can't use string (\"a\") as a SCALAR ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't use an undefined value as a symbol reference at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; *{$::{Altreus}}{SCALAR}\n","err":""},{"out":"","err":"","code":"use strict; $ARGV\n"},{"out":"1","code":"use strict; \"asd\" ~~ s/^[:ascii:]]//g;\n","err":""},{"err":"","code":"use strict; \"asd\" ~~ s/^[:ascii:]]/g;\n","out":"ERROR: Substitution replacement not terminated at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Global symbol \"@b\" requires explicit package name (did you forget to declare \"my @b\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; @b = 42;\n","err":""},{"code":"use strict; BEGIN { package Zomg; *::foo = \\$::foo; }  $foo = 42;\n","err":"","out":"42"},{"out":"ERROR: Bareword \"blargh\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; blargh\n"},{"out":"ERROR: Undefined subroutine &main::blargh called at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; blargh()\n"},{"code":"use strict; config\n","err":"","out":"ERROR: Bareword \"config\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Global symbol \"$thing\" requires explicit package name (did you forget to declare \"my $thing\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; defined (my $thing = $_[0]) or $thing = 'default'; $thing;\n"},{"err":"","code":"use strict; @F = 42;\n","out":"ERROR: Global symbol \"@F\" requires explicit package name (did you forget to declare \"my @F\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Global symbol \"$foo\" requires explicit package name (did you forget to declare \"my $foo\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; $foo\n","err":""},{"out":"sub { \"DUMMY\" }","err":"","code":"use strict; \\&{\"foo\"}\n"},{"out":"ERROR: Bareword \"Foo\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; [ Foo ]\n","err":""},{"out":"ERROR: Global symbol \"$foo\" requires explicit package name (did you forget to declare \"my $foo\"?) at (eval 1) line 1, <STDIN> line 1.\nGlobal symbol \"$foo\" requires explicit package name (did you forget to declare \"my $foo\"?) at (eval 1) line 1, <STDIN> line 1.\nGlobal symbol \"$bar\" requires explicit package name (did you forget to declare \"my $bar\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; $foo = 'bar'; ++$$foo; $bar\n"},{"err":"","code":"use strict; grep my $x = 1, 1, 2, 3; $x\n","out":""},{"err":"","code":"use strict; {{@{[\"I get it now\"=>2, bar=>3]}}}->{\"I get it now\"}\n","out":"ERROR: syntax error at (eval 1) line 1, near \"}->\"\n"},{"out":"I get it now","err":"","code":"use strict; {{@{[\"I get it now\"=>2, bar=>3]}}}{\"I get it now\"}\n"},{"out":"2","code":"use strict; ${{@{[\"I get it now\"=>2, bar=>3]}}}{\"I get it now\"}\n","err":""},{"err":"","code":"use strict; +{ @{[\"I get it now\"=>2, bar=>3]} }->{\"I get it now\"}\n","out":"2"},{"err":"","code":"use strict; ${ { @{[\"I get it now\"=>'So this takes an arrayref, converts it to a array, then converts it to a hashref which is needed index the key because a hashref puts it into a hash context.  %{@a} does not work because % expects a \"scalar\" like a hashref or an arrayref (same with @), so you have to %{ {@a} }.', bar=>3]} } }{\"I get it now\"}\n","out":"So this takes an arrayref, converts it to a array, then converts it to a hashref which is needed index the key because a hashref puts it into a hash context.  %{@a} does not work because % expects a \"scalar\" like a hashref or an arrayref (same with @), so you have to %{ {@a} }."},{"out":"","code":"use strict; $INC\n","err":""},{"out":"ERROR: Can't use string (\"2\") as a HASH ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; keys (%{ 'dave' => 1, 'bob' => 2 });\n","err":""},{"err":"","code":"use strict; [ map { my $foo if 0; ++$foo } 1 .. 10 ]\n","out":"[1,2,3,4,5,6,7,8,9,10]"},{"out":"ERROR: Global symbol \"$k2\" requires explicit package name (did you forget to declare \"my $k2\"?) at (eval 1) line 1, <STDIN> line 1.\nGlobal symbol \"$v2\" requires explicit package name (did you forget to declare \"my $v2\"?) at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, at EOF\n","code":"use strict; my $a = {a=>\"BLA\", b=>\"BLO\"}; print \"$k2:$v2\\n\" while((my($k2,$v2) = each %$a);\n","err":""},{"out":"ERROR: Can't use string (\"foo\") as a subroutine ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; my $action = \"foo\"; &{$action}()\n"},{"err":"","code":"use strict; my $action = \"foo\"; &{\\&{$action}}()\n","out":"ERROR: Undefined subroutine &main::foo called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"2","code":"use strict; my $bar; (my $foo, $bar) = 1 .. 2;\n","err":""},{"code":"use strict; my $cat, $dog;\n","err":"","out":"ERROR: Global symbol \"$dog\" requires explicit package name (did you forget to declare \"my $dog\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Bareword \"todayDay\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\nBareword \"serviceEndDay\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; my $diff=todayDay-serviceEndDay;\n"},{"code":"use strict; (my $foo, $bar) = ''\n","err":"","out":"ERROR: Global symbol \"$bar\" requires explicit package name (did you forget to declare \"my $bar\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use strict; my $foo = 'bar' and $foo\n","out":"ERROR: Global symbol \"$foo\" requires explicit package name (did you forget to declare \"my $foo\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't use string (\"foo\") as a HASH ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; my %foo; %{ 'foo' }\n"},{"err":"","code":"use strict; my %foo; %{ foo }\n","out":"0"},{"err":"","code":"use strict; my %foo; %{ foo; }\n","out":"ERROR: Bareword \"foo\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"sub { \"DUMMY\" }","err":"","code":"use strict; my $foo; $foo = sub { return $foo };\n"},{"code":"use strict; (my $foo, my $bar) = 1 .. 2;\n","err":"","out":"2"},{"out":"hi there!","err":"","code":"use strict; my $foo = sub { 'hi there!' }; $foo->()\n"},{"out":"ERROR: Global symbol \"$foo\" requires explicit package name (did you forget to declare \"my $foo\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; my $foo = sub { return $foo };\n","err":""},{"err":"","code":"use strict; my %hash = (one => 'foo'); sub bar { my $href = @_; $href->{one} = 'baz'; } bar(\\%hash);  [ %hash ]\n","out":"ERROR: Can't use string (\"1\") as a HASH ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use strict; @{\\my %hash}{qw(a b)} = (1, 2); \\%hash\n","err":"","out":"ERROR: Global symbol \"%hash\" requires explicit package name (did you forget to declare \"my %hash\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Bareword \"SOME_CONSTANT\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; my %hash = (thing => SOME_CONSTANT); sub SOME_CONSTANT { 5 }; $hash{thing}\n"},{"code":"use strict; my $h; [ (delete $h->{foo}), $h ]\n","err":"","out":"[undef,{}]"},{"out":"[undef]","err":"","code":"use strict; my $h; [ delete $h->{foo}, %$h ]\n"},{"err":"","code":"use strict; my $h; [ $h and %$h ]\n","out":"[undef]"},{"out":"ERROR: Can't use an undefined value as a HASH reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; my $h; [ scalar %$h ]\n"},{"out":"ERROR: Global symbol \"$i\" requires explicit package name (did you forget to declare \"my $i\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; { my $i = 0; } $i\n"},{"out":"ERROR: Global symbol \"$nwe\" requires explicit package name (did you forget to declare \"my $nwe\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; my $new = \"foo\"; print $nwe;\n","err":""},{"code":"use strict; my $params; my $student; my $search_name = $params->{name} && $student->name =~ /\\Q$search_name/i\n","err":"","out":"ERROR: Global symbol \"$search_name\" requires explicit package name (did you forget to declare \"my $search_name\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use strict; my %test = ( name => true, );\n","out":"ERROR: Bareword \"true\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use strict; my $x = 'code'; $$x;\n","err":"","out":"ERROR: Can't use string (\"code\") as a SCALAR ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use strict; my %x = (-+CONSTANT => 123); [keys %x]\n","err":"","out":"[\"-CONSTANT\"]"},{"code":"use strict; my %x = (-CONSTANT => 123); [keys %x]\n","err":"","out":"[\"-CONSTANT\"]"},{"err":"","code":"use strict; my %x = (+CONSTANT => 123); [keys %x]\n","out":"[\"CONSTANT\"]"},{"out":"1","code":"use strict; my %x = (+CONSTANT => 123); keys %x\n","err":""},{"err":"","code":"use strict; my %x = (+CONSTANT => 123); %x\n","out":"1/8"},{"out":"ERROR: Global symbol \"$x\" requires explicit package name (did you forget to declare \"my $x\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; my $x if $x || 1;\n"},{"code":"use strict; my $x = 'nope'; use warnings my $x = 'all'; $x\n","err":"","out":"nope"},{"out":"1","err":"","code":"use strict; my @x =  qw(1 2); undef @x; push @x,1;\n"},{"code":"use strict; my %x; $x[1] = 123;\n","err":"","out":"ERROR: Global symbol \"@x\" requires explicit package name (did you forget to declare \"my @x\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Global symbol \"$x\" requires explicit package name (did you forget to declare \"my $x\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; my $x->{y} = $x;\n"},{"out":"ERROR: Global symbol \"$y\" requires explicit package name (did you forget to declare \"my $y\"?) at (eval 1) line 1, <STDIN> line 1.\nGlobal symbol \"$x\" requires explicit package name (did you forget to declare \"my $x\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; my ($x, $y) = ($y, $x);\n"},{"out":"[\"[1]\",\"[2]\"]","code":"use strict; package foo; sub bar { our $baz; package fizzbuz; \"[\". ++$baz . \"]\" }; [ bar(), bar()  ]\n","err":""},{"out":"ERROR: Global symbol \"$baz\" requires explicit package name (did you forget to declare \"my $baz\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; package foo; sub bar { our $baz; package fizzbuz; \"[\". ++$baz . \"]\" }; [ bar(), bar(), $baz ]\n"},{"out":"[\"[1]\",\"[2]\",2]","err":"","code":"use strict; package foo; sub bar { our $baz; package fizzbuz; \"[\". ++$baz . \"]\" }; [ bar(), bar(), $foo::baz ]\n"},{"out":"ERROR: Global symbol \"@optype\" requires explicit package name (did you forget to declare \"my @optype\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; package Foo; use B '@optype'; package Bar; [ @optype ]\n"},{"out":"[\"OP\",\"UNOP\",\"BINOP\",\"LOGOP\",\"LISTOP\",\"PMOP\",\"SVOP\",\"PADOP\",\"PVOP\",\"LOOP\",\"COP\",\"METHOP\",\"UNOP_AUX\"]","err":"","code":"use strict; package Foo; use B '@optype'; package Foo; [ @optype ]\n"},{"err":"","code":"use strict; print \"${chr(24)}\"\n","out":"ERROR: Can't use string (\"\u0018\") as a SCALAR ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use strict; print foo::\n","err":"","out":""},{"err":"","code":"use strict; print foo::, bar:: ;\n","out":"foobar"},{"out":"foo\n","err":"","code":"use strict; print(foo::,\"\\n\");\n"},{"out":"hi","code":"use strict; print 'hi' if my $x = 1;\n","err":""},{"err":"","code":"use strict; print STDOUT:: foo:: ;\n","out":"foo1"},{"code":"use 'strict'; print $x;\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"use 'strict'\"\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"qw(subs):\"\n\"use\" not allowed in expression at (eval 1) line 1, near \": \"\n","err":"","code":"use strict qw(subs): use warnings;\n"},{"err":"","code":"use strict; @% = qw(x y z); [ \\@%, \"@%\" ] # doesn't even seem to interpolate in a string\n","out":"[[\"x\",\"y\",\"z\"],\"\\@%\"]"},{"out":"ERROR: Can't use string (\"\") as a HASH ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict \"refs\"; %{\"\"}\n","err":""},{"out":"ERROR: Bareword \"pl\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; require foo.pl;\n","err":""},{"err":"","code":"use strict; \"string\"->{key}\n","out":"ERROR: Global symbol \"%string\" requires explicit package name (did you forget to declare \"my %string\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use strict; ${\\\"string\"}->{key}  # why is this different\n","out":"ERROR: Can't use string (\"string\") as a HASH ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use strict; sub AUTOLOAD { our $AUTOLOAD; print \"[$AUTOLOAD]\" }; foo();\n","err":"","out":"[main::foo]"},{"err":"","code":"use strict; sub AUTOLOAD { our $AUTOLOAD; print \"[$AUTOLOAD]\" }; my $obj = bless []; $obj->foo();\n","out":"[main::foo][main::DESTROY]"},{"out":"ERROR: Global symbol \"$AUTOLOAD\" requires explicit package name (did you forget to declare \"my $AUTOLOAD\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; sub AUTOLOAD { print \"[$AUTOLOAD]\" }; foo();\n","err":""},{"out":"[main::foo]","err":"","code":"use strict; sub AUTOLOAD { print \"[$main::AUTOLOAD]\" }; foo();\n"},{"out":"meow","err":"","code":"use strict; sub config { return \"meow\" } config\n"},{"err":"","code":"use strict; sub Foo { \"Bar\" }; [ Foo ]\n","out":"[\"Bar\"]"},{"out":"foohoo","code":"use strict; sub foo { 'foohoo' } my $str = 'foo'; __PACKAGE__->can($str)->()\n","err":""},{"code":"use strict; sub foo { quux(); } # Grinnz_ I think he means that all his subs don't actually get called..\n","err":"","out":""},{"err":"","code":"use strict; sub foo { return false; }\n","out":"ERROR: Bareword \"false\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"hej","err":"","code":"use strict; sub lala { 'hej' } my $name = 'lala'; my $ref = \\&$name; $ref->()\n"},{"err":"","code":"use strict; subname();\n","out":"ERROR: Undefined subroutine &main::subname called at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use strict; subname(); { no strict 'refs'; *{__PACKAGE__ . \"::subname\"} = sub {1} }\n","out":"ERROR: Undefined subroutine &main::subname called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"5","code":"use strict; sub SOME_CONSTANT; my %hash = (thing => SOME_CONSTANT); sub SOME_CONSTANT { 5 }; $hash{thing}\n","err":""},{"code":"use strict; sub what { my ($foo, @_) = @_; \\@_ } what(qw(a b c d));\n","err":"","out":"ERROR: Can't use global @_ in \"my\" at (eval 1) line 1, near \", @_\"\n"},{"out":"ERROR: Can't call method \"catch\" without a package or object reference at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; try {} catch {};\n","err":""},{"code":"use strict; $_ = undef; say @$_[1]; [ $_ ]\n","err":"","out":"\n"},{"code":"use strict; $_ = undef; say @$_[1]; say Data::Dumper::Dumper [ $_ ]\n","err":"","out":"\n$VAR1 = [\n          []\n        ];\n\n"},{"out":"[\"OP\",\"UNOP\",\"BINOP\",\"LOGOP\",\"LISTOP\",\"PMOP\",\"SVOP\",\"PADOP\",\"PVOP\",\"LOOP\",\"COP\",\"METHOP\",\"UNOP_AUX\"]","code":"use strict; use B '@optype'; [ @optype ]\n","err":""},{"out":"ERROR: Global symbol \"$y\" requires explicit package name (did you forget to declare \"my $y\"?) at (eval 1) line 1, <STDIN> line 1.\nGlobal symbol \"$x\" requires explicit package name (did you forget to declare \"my $x\"?) at (eval 1) line 1, <STDIN> line 1.\nGlobal symbol \"$y\" requires explicit package name (did you forget to declare \"my $y\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use feature 'signatures'; sub add ($x = return 0, $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]\n"},{"out":"42","err":"","code":"use strict; use Function::Parameters qw(:strict); fun func($foo, $bar = sub { $foo }) { $bar } func(42)->()\n"},{"err":"","code":"use strict; use v5.20; say \"hi\" for Altreus =>\n","out":"hi\n"},{"err":"","code":"use strict; use v5.20; say \"hi\" for Altreus;\n","out":"ERROR: Bareword \"Altreus\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; [\"$ -\"]\n","err":"","out":"[0]"},{"err":"","code":"use strict; use warnings; 1234->{key}\n","out":""},{"out":"[undef]","err":"","code":"use strict; use warnings; [ @$_[3] ]\n"},{"code":"use strict; use warnings; [ @{$_[3]} ] # you sure about that\n","err":"","out":"ERROR: Can't use an undefined value as an ARRAY reference at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"Argument \"\" isn't numeric in multiplication (*) at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; ['' * 5]\n","out":"[0]"},{"out":"no","err":"Unescaped left brace in regex is deprecated, passed through in regex; marked by <-- HERE in m/\\d{ <-- HERE ,3}/ at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; $_ = \"abc123xyz\"; /\\d{,3}/ ? \">$&<\" : \"no\"\n"},{"out":"ERROR: Global symbol \"@a\" requires explicit package name (did you forget to declare \"my @a\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"Variable \"@a\" is not imported at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; @a = {foo => 1, bar => 2}; print ${$a}{\"foo\"}\n"},{"code":"use strict; use warnings; blasdsdasdsa->import\n","err":"","out":""},{"code":"use strict; use warnings; CORE::say \"test\" # use 5.016 mostly just covers imports, I think\n","err":"","out":"test\n"},{"err":"","code":"use strict; use warnings; @F=('5'); [@F]\n","out":"ERROR: Global symbol \"@F\" requires explicit package name (did you forget to declare \"my @F\"?) at (eval 1) line 1, <STDIN> line 1.\nGlobal symbol \"@F\" requires explicit package name (did you forget to declare \"my @F\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; $_ = \"First Name Position first.name\\@somewhere.com 745 45363\\nSome One Worker some.one\\@somewhere.com 343 5454\\n\" =~ s/^\\s*(\\S)\\S*\\s+(\\S+).+?(\\d\\d\\d \\d\\d\\d\\d)\\s*/$1., $2, $3/gmr # for milfjord :)\n","err":"","out":"F., Name, 745 45363\nS., One, 343 5454"},{"out":"F., Name, 745 45363S., One, 343 5454","err":"","code":"use strict; use warnings; $_ = \"First Name Position first.name\\@somewhere.com 745 45363\\nSome One Worker some.one\\@somewhere.com 343 5454\\n\" =~ s/^\\s*(\\S)\\S*\\s+(\\S+).+?(\\d\\d\\d \\d+)\\s*/$1., $2, $3/gmr # for milfjord :)\n"},{"err":"","code":"use strict; use warnings; [ \"First Name Position first.name\\@somewhere.com 745 45363\\nSome One Worker some.one\\@somewhere.com 343 5454\\n\" =~ s/^\\s*(\\S)\\S*\\s+(\\S+).+?(\\d\\d\\d \\d+)\\s*/$1., $2, $3\\n/gmr ]\n","out":"[\"F., Name, 745 45363\\nS., One, 343 5454\\n\"]"},{"code":"use strict; use warnings; [-foo]\n","err":"","out":"[\"-foo\"]"},{"out":"[\"foo\"]","code":"use strict; use warnings; [foo=>]\n","err":""},{"err":"","code":"use strict; use warnings; @foo = (1, 2, undef, 4); for my $foo (@foo) { print $foo }\n","out":"ERROR: Global symbol \"@foo\" requires explicit package name (did you forget to declare \"my @foo\"?) at (eval 1) line 1, <STDIN> line 1.\nGlobal symbol \"@foo\" requires explicit package name (did you forget to declare \"my @foo\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; foo; sub foo { \"foo\" }\n","err":"","out":"ERROR: Bareword \"foo\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"foo","err":"","code":"use strict; use warnings; foo(); sub foo { \"foo\" }\n"},{"err":"","code":"use strict; use warnings; [ 'hentai' =~ m/#(?:hentai|yuri)/ ] # that line looks fine\n","out":"[]"},{"out":"Perfectly OK\n","code":"use strict; use warnings; if (0) {i_am_not_defined();} else {print \"Perfectly OK\\n\";}\n","err":""},{"code":"use strict; use warnings; if (1) {} elseif (2) {}\n","err":"elseif should be elsif at (eval 1) line 1, <STDIN> line 1.\n","out":"ERROR: syntax error at (eval 1) line 1, near \") {\"\n"},{"out":"Inf","err":"","code":"use strict; use warnings; 'inf' * 3\n"},{"out":"bless( {sign => \"+inf\",value => [0],_p => undef,_a => undef}, 'Math::BigInt' )","err":"","code":"use strict; use warnings; inf * 3\n"},{"out":"ERROR: Can't use string (\"main::\") as a HASH ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; keys %{'main::'};\n"},{"out":"1495","err":"","code":"use strict; use warnings; keys %{main::};\n"},{"out":"","code":"use strict; use warnings;  length $12345678987654321\n","err":""},{"out":"UTF-32","err":"Use of uninitialized value $1 in concatenation (.) or string at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; local $_ = \"UCS-4\"; eval q@qr/^UCS-?4-?(BE|LE)?$/i; uc(\"UTF-32$1\")@\n"},{"out":"UTF-32","err":"","code":"use strict; use warnings; local $_ = \"UCS-4\"; my $p = qr/^UCS-?4-?(BE|LE|)?$/i; s@$p@uc(\"UTF-32$1\")@er\n"},{"err":"","code":"use strict; use warnings; { local $x = 123; } # nor on undeclared variables\n","out":"ERROR: Global symbol \"$x\" requires explicit package name (did you forget to declare \"my $x\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; [map { $_; last } (1,2,3)]\n","err":"Useless use of a variable in void context at (eval 1) line 1, <STDIN> line 1.\nExiting eval via last at (eval 1) line 1, <STDIN> line 1.\n","out":""},{"code":"use strict; use warnings; ''.methods.length\n","err":"","out":"ERROR: Bareword \"methods\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"a\"]","err":"Argument \"\" isn't numeric in array element at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my @a = 'a'..'z'; [ $a[ 2..1 ] ];\n"},{"err":"","code":"use strict; use warnings; my $abc = 'xyz'; my $asdf = 'mno'; sub asdf { return \\$abc; } print \"${asdf}\"\n","out":"mno"},{"out":"ERROR: Global symbol \"$asdf\" requires explicit package name (did you forget to declare \"my $asdf\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; my $abc = 'xyz'; sub asdf { return \\$abc; } print \"${asdf}\"\n"},{"code":"use strict; use warnings; my $abc = 'xyz'; sub asdf { return \\$abc; } print ${asdf()}\n","err":"","out":"xyz"},{"code":"use strict; use warnings; my $abc = 'xyz'; sub asdf { return \\$abc; } print ${asdf}\n","err":"Ambiguous use of ${asdf} resolved to $asdf at (eval 1) line 1, <STDIN> line 1.\nVariable \"$asdf\" is not imported at (eval 1) line 1, <STDIN> line 1.\n\t(Did you mean &asdf instead?)\n","out":"ERROR: Global symbol \"$asdf\" requires explicit package name (did you forget to declare \"my $asdf\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; my  @a = ({foo=> \"foo\", moo => \"bar\", desc=> \"lambda\",},{foo=>\"baz\", moo=>\"moo\", desc=>\"bring_it\",}); my @keys = ('foo', 'desc'); [join(\", \", map { my $href = $_; map { my $key = $_; \"$key=\\\"$href->{$key}\\\"\" } @keys } @a)]\n","err":"","out":"[\"foo=\\\"foo\\\", desc=\\\"lambda\\\", foo=\\\"baz\\\", desc=\\\"bring_it\\\"\"]"},{"out":"ERROR: Can't modify constant item in scalar assignment at (eval 1) line 1, near \"\"bring_it\",\"\nBareword \"desc\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my  @a = ({foo=> \"foo\", moo => \"bar\", desc=> \"lambda\",},{foo=>\"baz\", moo=>\"moo\", desc=\"bring_it\",}); my @keys = ('foo', 'desc'); [join(\", \", map { my $href = $_; map { my $key = $_; \"$key=\\\"$href->{$key}\\\"\" } @keys } @a)]\n","err":""},{"code":"use strict; use warnings; my  @a = ({foo=> \"foo\", moo => \"bar\"},{foo=>\"baz\", moo=>\"moo\"}); my $key = 'foo'; [join(\", \", map { \"$key=\\\"$_->{$key}\\\"\" } @a)]\n","err":"","out":"[\"foo=\\\"foo\\\", foo=\\\"baz\\\"\"]"},{"out":"[9,\":\",\"[\",\"]\"]","err":"","code":"use strict; use warnings; my @allowed = ('a'..'z','A'..'Z',' ', '{','}');my%allowed_hash = (map { $_ => 1 } @allowed); my %found; foreach my $c (split// , q#MPOPCNTSF: INTEGER[9]#) { if (!exists($allowed_hash{$c})) { $found{$c} = 1; } } [sort {$a cmp $b } keys%found]\n"},{"err":"","code":"use strict; use warnings; my @allowed = ('a'..'z','A'..'Z',' ', '{','}');my%allowed_hash = (map { $_ => 1 } @allowed}; my %found; foreach my $c (split// , q#MPOPCNTSF: INTEGER[9]#) { if (!exists($allowed_hash{$c})) { $found{$c} = 1; } } [sort {$a cmp $b } keys%found]\n","out":"ERROR: Unmatched right curly bracket at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, at EOF\n"},{"code":"use strict; use warnings;  my $aref = [1,2,3];  @{ $aref + 1 }\n","err":"","out":"ERROR: Can't use string (\"48545841\") as an ARRAY ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"100","err":"","code":"use strict; use warnings; my %args = ( number => 100 ); print $args{number};\n"},{"code":"use strict; use warnings; my %args = { number => 100 }; print $args{number};\n","err":"Reference found where even-sized list expected at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value in print at (eval 1) line 1, <STDIN> line 1.\n","out":"1"},{"out":"x","err":"Argument \"\" isn't numeric in array element at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $ar = [qw(x y z a b c)]; $ar->[2..4] # warnings to the rescue?\n"},{"out":"3","err":"Useless use of a constant (2) in void context at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $array = (1,2,3);\n"},{"out":"[3]","code":"use strict; use warnings; my $array_ref = [3,4,5]; [scalar @$array_ref]\n","err":""},{"err":"","code":"use strict; use warnings; my @arr = ('One', 'Two', 'Three', 'Four'); @arr = grep { !/\\AT/ } @arr; [@arr]\n","out":"[\"One\",\"Four\"]"},{"err":"Parentheses missing around \"my\" list at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $cat, $dog;\n","out":"ERROR: Global symbol \"$dog\" requires explicit package name (did you forget to declare \"my $dog\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; my @c=qw(a b c d);print((map{$_ >1}@c)/@c)\n","err":"Argument \"a\" isn't numeric in numeric gt (>) at (eval 1) line 1, <STDIN> line 1.\nArgument \"b\" isn't numeric in numeric gt (>) at (eval 1) line 1, <STDIN> line 1.\nArgument \"c\" isn't numeric in numeric gt (>) at (eval 1) line 1, <STDIN> line 1.\nArgument \"d\" isn't numeric in numeric gt (>) at (eval 1) line 1, <STDIN> line 1.\n","out":"1"},{"out":"[\"Match\"]","code":"use strict; use warnings; my $cwd = \"/archivepath/SHORT\"; my $ARCHIVEPATH=\"/archivepath/\"; [$cwd =~ m#^${ARCHIVEPATH}(SHORT|MEDIUM|LONG)$# ? \"Match\" : \"No match\"]\n","err":""},{"out":"[\"No match\"]","code":"use strict; use warnings; my $cwd = \"/archivepath/SHORT\"; my $ARCHIVEPATH=\"/archivepath/\"; [$cwd =~ m#^${ARCHIVEPATH}(SHORT|MEDIUM|LONG)\\$# ? \"Match\" : \"No match\"]\n","err":""},{"err":"","code":"use strict; use warnings; my @data = (\"foo\"); $data[0]{label} = $data[0]; [@data]\n","out":"ERROR: Can't use string (\"foo\") as a HASH ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; my @data = (\"foo\"); $data[0] = {label => $data[0]}; [$data[0]{label}]\n","err":"","out":"[\"foo\"]"},{"code":"use strict; use warnings; my $data = [{}, { url => 'xyz' }]; $data->[\"1\\n\"]{url} # shouldn't matter\n","err":"","out":"xyz"},{"err":"","code":"use strict; use warnings; my @default = qw(d e f a u l t); my $h = { y => [ qw(A B C) ] }; [ map Data::Munge::list2re(@{ $h->{$_} // \\@default }), qw(x y) ]\n","out":"[qr/a|d|e|f|l|t|u/,qr/A|B|C/]"},{"out":"[\"d|e|f|a|u|l|t\",\"A|B|C\"]","code":"use strict; use warnings; my @default = qw(d e f a u l t); my $h = { y => [ qw(A B C) ] }; [ map {   join q{|}, map { qq{\\Q$_\\E} } ( ref $h->{$_} eq q{ARRAY} && @{ $h->{$_} } ? @{ $h->{$_} } : @default )   } qw(x y) ];\n","err":""},{"err":"","code":"use strict; use warnings; my $foo = 1; my $bar = 2; my $name = \"foo\"; print \"ok\" if (defined(${$name}));\n","out":"ERROR: Can't use string (\"foo\") as a SCALAR ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"bar1","code":"use strict; use warnings; my %foo = (bar => 1); print %{foo};\n","err":""},{"out":"ERROR: Can't use string (\"stuff\") as a HASH ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; my $foo = { bar => \"stuff\" }; $foo->{bar}->{baz}\n"},{"code":"use strict; use warnings; my %foo = (hello => [1,22,303]); [$foo{hello}[1]]\n","err":"","out":"[22]"},{"code":"use strict; use warnings; my @foo = \"hi\"; \"class ${foo[0]}{ ... };\"\n","err":"","out":"class hi{ ... };"},{"out":"class hi{ ... };","code":"use strict; use warnings; my @foo = \"hi\"; \"class $foo[0]\\{ ... };\"\n","err":""},{"out":"[1]","code":"use strict; use warnings; my $foo; push @$foo, 1; $foo\n","err":""},{"out":"[[\"foo\",\"bar\",\"baz\\n\"],[\"x\",\"y\",\"z\"]]","code":"use strict; use warnings; my @groups; my $chunk = []; for my $x (\"foo\", \"bar\", \"baz\\n\", \"x\", \"y\", \"z\") { push @$chunk, $x; if ($x =~ /\\R\\z/) { push @groups, $chunk; $chunk = []; } } push @groups, $chunk if @$chunk; [ @groups ]\n","err":""},{"code":"use strict; use warnings; my %h = ( 1 => 200, 0 => 100, q{} => 50, undef => 25 ); $h{undef};\n","err":"","out":"25"},{"code":"use strict; use warnings; my %h = ( 1 => 200, 0 => 100, q{} => 50, undef => 25 ); my $x; $h{$x}; ### Wtf?\n","err":"Use of uninitialized value $x in hash element at (eval 1) line 1, <STDIN> line 1.\n","out":"50"},{"err":"","code":"use strict; use warnings; my %h = (1 => 2); sub x {my $ref = shift; $ref->{1} = 3}; x(\\%h); $h{1}\n","out":"3"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"m/(.)/$h\"\nBareword \"b\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\nBareword \"d\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\nBareword \"f\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my %h = (a => b, c => d, e => f); my $str = \"abcdef\"; $str =~ m/(.)/$h{$1}/g; print \"$str\";\n","err":"Scalar found where operator expected at (eval 1) line 1, near \"m/(.)/$h\"\n"},{"err":"Useless use of division (/) in void context at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my %h = (a => \"b\", c => \"d\", e => \"f\"); my $str = \"abcdef\"; $str =~ s/(.)/$h{$1} // $1 /eg; print \"$str\";\n","out":"ERROR: Bareword \"eg\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; my $h = {a => \"b\", c => \"d\", e => \"f\"}; my $str = join \",\", grep defined, @$h{qw/a b c/}; print $str;\n","err":"","out":"b,d"},{"err":"","code":"use strict; use warnings; my $h = {a => \"b\", c => \"d\", e => \"f\"}; my $str = join(\",\", grep {defined($h->{$_})} (qw/a b c/)); print $str;\n","out":"a,c"},{"err":"","code":"use strict; use warnings; my $h = {a => \"b\", c => \"d\", e => \"f\"}; my $str = join(\",\", map { $h->{$_} // () } (qw/a b c/)); print $str; # or do both in the map\n","out":"b,d"},{"out":"1","err":"","code":"use strict; use warnings; my $h = {a => \"b\", c => \"d\", e => \"f\"}; my $str = map $h->{$_}, join(\",\", grep {defined($h->{$_})} (qw/a b c/)); print $str;\n"},{"err":"","code":"use strict; use warnings; my %hash;  \"hash\"->{key} = \"message\"; \\%hash\n","out":"ERROR: Global symbol \"%hash\" requires explicit package name (did you forget to declare \"my %hash\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't use string (\"hash\") as a HASH ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my %hash; ${\"hash\"}{key} = \"message\"; \\%hash\n","err":""},{"code":"use strict; use warnings; my $hash_ref = { 'foo' => 'bar' }; $%hash_ref{'foo'};\n","err":"Bareword found where operator expected at (eval 1) line 1, near \"$%hash_ref\"\n\t(Missing operator before hash_ref?)\n","out":"ERROR: syntax error at (eval 1) line 1, near \"$%hash_ref\"\n"},{"out":"ERROR: Global symbol \"%hash_ref\" requires explicit package name (did you forget to declare \"my %hash_ref\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; my $hash_ref = { 'foo' => 'bar' }; $hash_ref{'foo'};\n"},{"code":"use strict; use warnings; my $hash_ref = { 'foo' => 'bar' }; %$hash_ref{'foo'};\n","err":"","out":"bar"},{"code":"use strict; use warnings; my %hash_ref = { 'foo' => 'bar' }; $hash_ref{'foo'};\n","err":"Reference found where even-sized list expected at (eval 1) line 1, <STDIN> line 1.\n","out":""},{"out":"{b => \"This is B\",c => \"Foobar\",a => \"One A too many.\"}","code":"use strict; use warnings; my %h = ('a' => \"This is A\", 'b' => \"This is B\"); $h{'a'} = \"One A too many.\"; $h{'c'} = \"Foobar\"; \\%h\n","err":""},{"code":"use strict; use warnings; my $_ # hence the \"experimental\" - generally safer not to use it, and avoid things that do\n","err":"","out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ # hence the \"experimental\" - generally safer not to use it, and avoid things that do\n\"\n"},{"out":"[[\"rindolf\",2],[\"fling\",1],[\"gamo\",3]]","err":"","code":"use strict; use warnings; my %h = ('fling' => 1, 'rindolf' => 2, 'gamo' => 3); my @arr = (map { [$_, $h{$_}] } keys %h); [@arr]\n"},{"out":"ERROR: Not an ARRAY reference at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $h = {\"foo\" => 5, \"bar\" => 6, \"baz\" => 2}; print Dumper(@{$h}->{qw/foo bar baz/});\n","err":""},{"out":"[{foo => \"dexter\"},$VAR1->[0],$VAR1->[0]]","code":"use strict; use warnings; my %h = (foo => 'bar'); my $aref = [\\%h,\\%h,\\%h]; $aref->[0]{foo} = 'dexter'; $aref\n","err":""},{"out":"ERROR: Bareword \"bar\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; my %h = (foo => bar); my $aref = [\\%h,\\%h,\\%h]; $aref->[0]{foo} = 'dexter'; $aref\n"},{"err":"","code":"use strict; use warnings; my %h = (foo => bar); my $aref = [\\%h,\\%h,\\%h]; $aref[0]{foo} = 'dexter'; $aref\n","out":"ERROR: Global symbol \"@aref\" requires explicit package name (did you forget to declare \"my @aref\"?) at (eval 1) line 1, <STDIN> line 1.\nBareword \"bar\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"{\"foo\\34bar\" => \"much\"}","err":"","code":"use strict; use warnings; my %h; $h{'foo','bar'} = \"much\"; \\%h\n"},{"out":"ERROR: Can't use an undefined value as a HASH reference at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $href; %$href\n","err":""},{"out":"[\"55.668840408325195\",\"20.794050693511963\",\"58.08229207992554\",\"28.241150379180908\"]","code":"use strict; use warnings; my $input=\"Exact map coverage is (55.668840408325195,20.794050693511963) to (58.08229207992554,28.241150379180908)\"; [ $input =~ m#([0-9]+(?:\\.[0-9]+)?)#g]\n","err":""},{"err":"","code":"use strict; use warnings; my $input=\"Exact map coverage is (55.668840408325195,20.794050693511963) to (58.08229207992554,28.241150379180908)\"; [ $input =~ m#([0-9]+(\\.[0-9]+)?#g]\n","out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/( <-- HERE [0-9]+(\\.[0-9]+)?/ at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","code":"use strict; use warnings; my $my->{my}\n","err":""},{"err":"","code":"use strict; use warnings; my $name = 'something'; $$name = 'data'; { our $something; $something } # if you get an error when you make that change...\n","out":"ERROR: Can't use string (\"something\") as a SCALAR ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use strict; use warnings; my $name = 'Tectu'; print \"Hello $name!\\n\";\n","out":"Hello Tectu!\n"},{"out":"[\"5.232\"]","code":"use strict; use warnings; my $num = 5.2323232; $num = sprintf(\"%.3f\", $num); [$num]\n","err":""},{"out":"{\"\" => 3,2 => 1}","err":"Use of uninitialized value $old_hash{\"3\"} in hash element at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my %old_hash = (1 => 2, 3 => undef); my %new_hash; $new_hash{$old_hash{$_}} = $_ for keys %old_hash; \\%new_hash\n"},{"err":"Use of uninitialized value $old_hash{\"3\"} in list assignment at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my %old_hash = (1 => 2, 3 => undef); my %new_hash = reverse %old_hash; \\%new_hash\n","out":"{2 => 1,\"\" => 3}"},{"code":"use strict; use warnings; my $ref = [qw(hi one two)]; unshift(@$ref, \"Hello\"); [$ref]\n","err":"","out":"[[\"Hello\",\"hi\",\"one\",\"two\"]]"},{"out":"[19770505]","code":"use strict; use warnings; my $s = \"5/5/1977\"; $s =~ s/(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})/sprintf(\"%04d%02d%02d\", $3, $2, $1)/e; [$s]\n","err":""},{"err":"","code":"use strict; use warnings; my $s = \"aabaaaaaaaaaaaab\"; my @x = $s =~ /(a++b)/; [@x]\n","out":"[\"aab\"]"},{"out":"ERROR: Global symbol \"@x\" requires explicit package name (did you forget to declare \"my @x\"?) at (eval 1) line 1, <STDIN> line 1.\nGlobal symbol \"@x\" requires explicit package name (did you forget to declare \"my @x\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $s = \"aabaaaaaaaaaaaab\"; @x = $s =~ /(a++b)/; [@x]\n","err":""},{"out":"[\"maroloccio. How is your day.\"]","err":"","code":"use strict; use warnings; my $s = \"Hello maroloccio___. How is your day.\"; $s =~ s#\\AHello (\\w+)# my $name = $1; $name =~ s/_+\\z//; $name#e; [$s]\n"},{"code":"use strict; use warnings; my $s = \"Hello maroloccio___. How is your day.\"; $s =~ s#\\AHello (\\w+)# my $name = $1; $name =~ s/_+\\z//; $name#; [$s]\n","err":"Unrecognized escape \\z passed through at (eval 1) line 1, <STDIN> line 1.\n","out":"ERROR: Global symbol \"$name\" requires explicit package name (did you forget to declare \"my $name\"?) at (eval 1) line 1, <STDIN> line 1.\nGlobal symbol \"$name\" requires explicit package name (did you forget to declare \"my $name\"?) at (eval 1) line 1, <STDIN> line 1.\nGlobal symbol \"$name\" requires explicit package name (did you forget to declare \"my $name\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"bar1","err":"","code":"use strict; use warnings; my %shift = (bar => 1); print %shift\n"},{"out":"bar1","err":"Ambiguous use of %{shift} resolved to %shift at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my %shift = (bar => 1); print %{shift}\n"},{"out":"Match: \n","err":"Use of uninitialized value $1 in substitution (s///) at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value $1 in concatenation (.) or string at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $s = q{<a rel=\"nofollow\" href=\"http://www.FOOtube.com/v/ABCDEFG\" target=\"_blank\">Youtube Video</a>}; $s =~ s#<a(?:\\s+(?:href=(\\S+\\byoutube\\.com/\\S+)|[^>]*?))+\\s*\\>.*?</a>#$1# && print qq{Match: $1\\n}; [ $s, $1 ];\n"},{"out":"Match: \"http://www.youtube.com/v/ABCDEFG\"\n","err":"","code":"use strict; use warnings; my $s = q{<a rel=\"nofollow\" href=\"http://www.youtube.com/v/ABCDEFG\" target=\"_blank\">Youtube Video</a>}; $s =~ s#<a(?:\\s+(?:href=(\\S+\\byoutube\\.com/\\S+)|[^>]*?))+\\s*\\>.*?</a>#$1# && print qq{Match: $1\\n}; [ $s, $1 ];\n"},{"out":"foo\",$1,\"baz","err":"","code":"use strict; use warnings; my $s = q{foo=bar=baz}; my $p = qr/=(.*?)=/; my $r = q{\",$1,\"}; $s =~ s/$p/$r/re;\n"},{"out":"ERROR: Substitution pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; my $s = q{}; my $r = s =~ s///; OK wtf?\n"},{"out":"ERROR: Substitution pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; my $s = q{}; my $r = s =~ s///; # wtf?\n"},{"out":"012","err":"","code":"use strict; use warnings; my $str = \"012\"; my @f = (qw/2 1 0/); $str =~ s/(join(\"|\", @f))/$f[$1]/g; print $str\n"},{"code":"use strict; use warnings; my $str = \"\\\"foo bar baz\\\"\"; print \"pre [$str]\\n\"; $str =~ s/(?:[^\\\\])\"$//; print \"post [$str]\\n\";\n","err":"","out":"pre [\"foo bar baz\"]\npost [\"foo bar ba]\n"},{"err":"","code":"use strict; use warnings; my $str; length($str)\n","out":""},{"code":"use strict; use warnings; my %table = {}; # strict+warnings may help with issues like that\n","err":"Reference found where even-sized list expected at (eval 1) line 1, <STDIN> line 1.\n","out":"1"},{"out":"[\"Def\"]","code":"use strict; use warnings; my $test = \"\"; [defined($test) ? \"Def\" : \"Undef\"]\n","err":""},{"err":"","code":"use strict; use warnings; my @things; (my $x = '%%123@@@@456&&234') =~ s/([\\$%\\@&])\\1+\\K([0-9]+)/push @things, $2/ge; \\@things # could even do something like this, for example\n","out":"[123,456,234]"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","err":"","code":"use strict; use warnings; { my $v=0; sub foo : lvalue { $v } } foo++;\n"},{"code":"use strict; use warnings; { my $v=0; sub x : lvalue { $v } } ++x;\n","err":"","out":"1"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"use strict; use warnings; { my $v=0; sub x : lvalue { $v } } x++;\n","err":""},{"out":"ERROR: Can't use an undefined value as an ARRAY reference at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $var = undef; @{$var} # and you understand why this fails but Bar(@{$var}) doesn't, right?\n","err":""},{"err":"","code":"use strict; use warnings; my $v = sub { \"Miesco\", 1+1, print(\"Blessed are the cheese makers\") }->(); print \" Return value was: [ $v ]\" # seems print turns off auto-value-dump in perlbot?\n","out":"Blessed are the cheese makers Return value was: [ 1 ]"},{"err":"","code":"use strict; use warnings; my $v = sub { \"Miesco\", 1+1, print(\"Blessed are the cheese makers\") }->(); [ $v ]\n","out":"Blessed are the cheese makers"},{"code":"use strict; use warnings; my $word_re = qr/\\w+/; my $pat_re = qr/(?:$word_re-)*$word_re/; [grep { $_ =~ /\\A$pat_re\\z/ } (\"foo-123\")]\n","err":"","out":"[\"foo-123\"]"},{"out":"[\"foo-123\",\"bar-3600-Zab\"]","err":"","code":"use strict; use warnings; my $word_re = qr/\\w+/; my $pat_re = qr/(?:$word_re-)*$word_re/; [grep { $_ =~ /\\A$pat_re\\z/ } (\"foo-123\", \"bar-3600-Zab\",\"Maj+4\")]\n"},{"code":"use strict; use warnings; my %x = { };\n","err":"Reference found where even-sized list expected at (eval 1) line 1, <STDIN> line 1.\n","out":"1"},{"code":"use strict; use warnings; my @x = ([0,1,2]) x 5; $x[0][2] = 100; [@x]\n","err":"","out":"[[0,1,100],$VAR1->[0],$VAR1->[0],$VAR1->[0],$VAR1->[0]]"},{"out":"[\"1.00000000000000066613381477509392425417900085449219\"]","code":"use strict; use warnings; my $x = 0; for my $i (1 .. 100) { $x += 0.01; } [sprintf(\"%.50f\", $x)]\n","err":""},{"err":"","code":"use strict; use warnings; my $x = -100 ; for my $y (0 .. $x) { hello_there(); } 1;\n","out":"1"},{"err":"","code":"use strict; use warnings; my @x = (1 .. 5); @x[0,2] = (100,200); [@x]\n","out":"[100,2,200,4,5]"},{"err":"","code":"use strict; use warnings; my $x = 1; my $h = do { if ( $x == 2 ) { \\*STDERR; } elsif ( $x == 1 ) { \\*STDOUT; } }; $h\n","out":"\\*::STDOUT"},{"out":"\\*::STDOUT","code":"use strict; use warnings; my $x = 1; my $h = do { if ( $x == 2 ) { \\*STDERR; } if ( $x == 1 ) { \\*STDOUT; } }; $h\n","err":"Useless use of single ref constructor in void context at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; my $x = 1; my $h = do { \\*STDERR if $x == 2; \\*STDOUT if $x == 1; }; $h\n","err":"Useless use of single ref constructor in void context at (eval 1) line 1, <STDIN> line 1.\n","out":"\\*::STDOUT"},{"out":"2","err":"\"our\" variable $x masks earlier declaration in same scope at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $x = 1; our $x = 2; $x\n"},{"code":"use strict; use warnings; my $ x = 2  # or even\n","err":"","out":"2"},{"err":"","code":"use strict; use warnings; my @x = (500, 24, 300, 2800); $#x = -1; [@x]\n","out":"[]"},{"out":"[500,24]","code":"use strict; use warnings; my @x = (500, 24, 300, 2800); $#x = 1; [@x]\n","err":""},{"err":"Ambiguous use of ${x} resolved to $x at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $x = 'abc'; ${x}\n","out":"abc"},{"code":"use strict; use warnings; my $x = \"| |\"; [\"Foo $x y $x\"]\n","err":"","out":"[\"Foo | | y | |\"]"},{"code":"use strict; use warnings; my $x = []; push $x, '...';\n","err":"","out":"ERROR: Experimental push on scalar is now forbidden at (eval 1) line 1, at EOF\n"},{"out":"4","code":"use strict; use warnings; my %x = ( qw(AAA 1111 BBB 222 CCC 333 DDD 444) ); (()=%x)/2;\n","err":""},{"out":"2","err":"Argument \"2/8\" isn't numeric in addition (+) at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my %x = ( qw(AAA 1111 BBB 222) ); %x+0\n"},{"out":"","err":"","code":"use strict; use warnings; my $x; sub Foo : lvalue { $x } sub Bar { } my $var = undef; Bar(@{Foo()}) # does that make it any clearer?\n"},{"out":"[\"test\"]","code":"use strict; use warnings; my $x = \"test\"; [\"$ x\"] # any clearer?\n","err":""},{"err":"","code":"use strict; use warnings; my ($x, undef) = (5,10);\n","out":"2"},{"err":"Use of uninitialized value $x in numeric lt (<) at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $x; undef $x; length($x) < 4 # the length() warnings can be mildly confusing\n","out":"1"},{"out":"[0,1,2,3,4,5]","err":"","code":"use strict; use warnings ; my @x; $x[5] = 5; [keys@x]\n"},{"out":"5","err":"","code":"use strict; use warnings;  my %x; $x{a} = 4; @x{a} = (5); print $x{a};\n"},{"code":"use strict; use warnings; my $x; --$x if $x > 1; \\$x; # Just wondering, is there a nice rewrite this to avoid the warning, without using something like if $x && $x > 1 (is there a shorter/simpler way?)\n","err":"Use of uninitialized value $x in numeric gt (>) at (eval 1) line 1, <STDIN> line 1.\n","out":"\\undef"},{"out":"\\\"test\"","code":"use strict; use warnings; my $x; $$x = 'test'; $x # even scalars\n","err":""},{"code":"use strict; use warnings; my $x; ($x ? $x++ : $x ) = 1; $x;\n","err":"","out":"ERROR: Can't modify postincrement (++) in scalar assignment at (eval 1) line 1, at EOF\n"},{"out":"1","err":"","code":"use strict; use warnings; my $x; $x ? $x++ : ($x = 1); $x;\n"},{"code":"use strict; use warnings; my $x; $x ? $x++ : $x = 1; $x;\n","err":"","out":"ERROR: Can't modify postincrement (++) in scalar assignment at (eval 1) line 1, at EOF\n"},{"out":"55","err":"","code":"use strict; use warnings; my $x->{y} = 55\n"},{"code":"use strict; use warnings; $_ = my ($x, $y); $x = \"hi\"\n","err":"","out":"hi"},{"out":"{hey => 100,y => \"z\"}","err":"","code":"use strict; use warnings; my %x = (y => 'z'); $x{'hey'} += 100; \\%x\n"},{"code":"use strict; use warnings; my $y; my @x = @$y; # rvalue\n","err":"","out":"ERROR: Can't use an undefined value as an ARRAY reference at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use strict; use warnings; my $y; my @x; @$y = @x; # lvalue\n","out":"0"},{"out":"","err":"\"my\" variable $z masks earlier declaration in same scope at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $z = {}; (my $z)->{z}\n"},{"err":"\"my\" variable $z masks earlier declaration in same scope at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $z = {}; my ($z->{z})\n","out":"ERROR: Can't declare hash element in \"my\" at (eval 1) line 1, at EOF\n"},{"err":"\"my\" variable $z masks earlier declaration in same scope at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $z = {}; my $z->{z}\n","out":""},{"out":"[\"NaN\"]","code":"use strict; use warnings; [ 'NaN' + 'sNaN' ]\n","err":""},{"out":"data","err":"","code":"use strict; use warnings; no strict 'refs'; my $name = 'something'; $$name = 'data'; { our $something; $something } # ... then add no strict 'refs';\n"},{"code":"use strict; use warnings; 'ok'; ()\n","err":"Useless use of a constant (\"ok\") in void context at (eval 1) line 1, <STDIN> line 1.\n","out":""},{"out":"[undef]","err":"","code":"use strict; use warnings; [open my $fh, '<', '']\n"},{"code":"use strict; use warnings; open(my $fh, \">\", \"myfic.txt\");my ($fh) = @_; # because this should give you a warning\n","err":"\"my\" variable $fh masks earlier declaration in same scope at (eval 1) line 1, <STDIN> line 1.\n","out":"1"},{"out":"[undef]","code":"use strict; use warnings; [open my $fh, '<', undef]\n","err":""},{"err":"hi","code":"use strict; use warnings; open my $out2, q{>&=}, 2 or die qq{open failed: $!}; print $out2 \"hi\";\n","out":"1"},{"out":"2","err":"\"my\" variable $x masks earlier declaration in same scope at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; our $x = 1; my $x = 2; $x\n"},{"code":"use strict; use warnings; package foo {} foo->import;\n","err":"","out":""},{"out":"42","err":"","code":"use strict; use warnings; { package Foo; our $bar = 42; } my $pkg = \"Foo\"; my $var = do { no strict 'refs'; \\${\"${pkg}::bar\"} }; $$var\n"},{"out":"42","err":"","code":"use strict; use warnings; { package Foo; our $bar = 42; } my $pkg = \"Foo\"; ${ $::{$pkg . '::'}->{bar} }\n"},{"code":"use strict; use warnings; { package Foo; sub bar { 42 } } my $pkg = \"Foo\"; my $fn = \\&{\"${pkg}::bar\"}; $fn->()\n","err":"","out":"42"},{"out":"ERROR: Can't use string (\"Foo::bar\") as a subroutine ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; { package Foo; sub bar { 42 } } my $pkg = \"Foo\"; \"${pkg}::bar\"->()\n","err":""},{"err":"","code":"use strict; use warnings; package Obj; sub new { return bless {} , shift; } sub w_state { state $foo; return ++$foo; } ; package main; my @x; my $t = Obj->new; my $r = Obj->new; push @x, $t->w_state; push @x, $r->w_state; [@x]\n","out":"[1,2]"},{"out":"[1,12,13,15,2,3,31,42]","code":"use strict; use warnings; {package sort::numeric; BEGIN { $INC{'sort/numeric.pm'} = 1 } sub import { no strict 'refs'; *{caller . '::sort'} = sub { GLOBAL::CORE::sort { $a <=> $b } @_ } } } use sort::numeric; [ sort 1,3,2,31,13,12,15,42 ] # pragma\n","err":""},{"out":"Good bye cruel wor...\n5","err":"","code":"use strict; use warnings; package SubTest; sub DESTROY { print qq{Good bye cruel wor...\\n}; } package main; sub foo { my ( $x, $worker ); $worker = bless sub { $x++; $worker->() unless $x >= 5; }, q{SubTest}; $worker->(); undef $worker; $x; } print foo;\n"},{"err":"","code":"use strict; use warnings; package SubTest; sub DESTROY { print qq{Good bye cruel wor...\\n}; } package main; sub foo { my ( $x, $worker ); $worker = bless sub { $x++; $worker->() unless $x >= 5; }, q{SubTest}; $worker->(); $x; } print foo;\n","out":"5Good bye cruel wor...\n"},{"err":"","code":"use strict; use warnings; package SubTest; sub DESTROY { print qq{Good bye cruel wor...\\n}; } package main; sub foo { my ( $x, $worker ); $worker = bless sub { $x++; $worker->() unless $x >= 5; undef $worker; }, q{SubTest}; $worker->(); $x; } foo;\n","out":"Good bye cruel wor...\n"},{"out":"Good bye cruel wor...\n5","code":"use strict; use warnings; package SubTest; sub DESTROY { print qq{Good bye cruel wor...\\n}; } package main; sub foo { my ( $x, $worker ); $worker = bless sub { $x++; $worker->() unless $x >= 5; undef $worker; }, q{SubTest}; $worker->(); $x; } print foo;\n","err":""},{"out":"Too many open files","err":"","code":"use strict; use warnings; print $!\n"},{"code":"use strict; use warnings; print &$!;\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"&$!\"\n"},{"code":"use strict; use warnings; print chr(0xe08)\n","err":"Wide character in print at (eval 1) line 1, <STDIN> line 1.\n","out":"ÃÂ ÃÂ¸ÃÂ"},{"err":"","code":"use strict; use warnings; print \"Foo $_\" foreach qw(one two three);\n","out":"Foo oneFoo twoFoo three"},{"err":"Number found where operator expected at (eval 1) line 1, near \"reduce 1\"\n\t(Do you need to predeclare reduce?)\n","code":"use strict; use warnings; reduce 1;\n","out":"ERROR: syntax error at (eval 1) line 1, near \"reduce 1\"\n"},{"out":"ERROR: Undefined subroutine &main::reduce called at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; reduce(1)\n"},{"code":"use strict; use warnings; say 1.2.3\n","err":"","out":"\u0001\u0002\u0003\n"},{"code":"use strict; use warnings; sort { $a <=> $x } 1,2,3; # looks like an error to me\n","err":"","out":"ERROR: Global symbol \"$x\" requires explicit package name (did you forget to declare \"my $x\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"Useless use of non-destructive substitution (s///r) in void context at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; s/^\\///r for ''; ''\n","out":""},{"out":"[]","err":"Subroutine main::xyz redefined at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; sub abc { } sub xyz { } *xyz = sub { 123 }; { no warnings \"redefine\"; *abc = sub { 4 }; [] } # no warnings '...' is usefully self-documenting, any particular reason to do things manually?\n"},{"out":"[3]","err":"","code":"use strict; use warnings; sub ALL_EMPS { return +{ one => 1, two => 2, three => 3}}; my %h = %{ ALL_EMPS() }; [$h{three}]\n"},{"out":"20\n","code":"use strict; use warnings; sub a :lvalue { $a } a=10;a=20; print \"$a\\n\"; # <--- see, strict and warnings clean\n","err":""},{"out":"[]","code":"use strict; use warnings; sub Bar { ++$_ for @_ } my $x; 1 for @{$x}; $x # note that it's not just function calls, you'll get the same with foreach aliasing\n","err":""},{"err":"","code":"use strict; use warnings; sub create_iterator { my ($val) = @_; my $iter = sub { return ++$val; } ; return $iter } my $iter1 = create_iterator(100); my $iter2 = create_iterator(5); [$iter1->(),$iter2->(),$iter1->(),$iter2->()]\n","out":"[101,6,102,7]"},{"code":"use strict; use warnings; sub flatten { return map { ref($_) eq 'ARRAY' ? flatten(@$_) : $_ } @_ } [flatten([1, [2, 3], [4, [5]], 6])]\n","err":"","out":"[1,2,3,4,5,6]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"6]\"\nUnmatched right square bracket at (eval 1) line 1, at end of line\n","code":"use strict; use warnings; sub flatten { return map { ref($_) eq 'ARRAY' ? flatten(@$_) : $_ } @_ } [flatten(1, [2, 3], [4, [5]], 6])]\n","err":""},{"code":"use strict; use warnings; sub foo { 42 } *bar = \\&foo; bar()\n","err":"","out":"42"},{"err":"","code":"use strict; use warnings; sub foo { 42 } my $name = 'foo'; 'main'->$name\n","out":"42"},{"err":"","code":"use strict; use warnings; sub foo { \"foo\" } foo\n","out":"foo"},{"code":"use strict; use warnings; sub foo { my ($ch, $name) = @_; } foo(undef, undef); #are you sure?\n","err":"","out":"2"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","err":"","code":"use strict; use warnings; sub foo { shift } my $name = 'foo'; 'main'->can($name\n"},{"err":"","code":"use strict; use warnings; sub foo { shift } my $name = 'foo'; 'main'->can($name)->(42)\n","out":"42"},{"out":"ERROR: syntax error at (eval 1) line 1, near \")(\"\n","err":"","code":"use strict; use warnings; sub foo { shift } my $name = 'foo'; 'main'->can($name)(42)\n"},{"out":"ERROR: Can't use an undefined value as an ARRAY reference at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; sub Foo { undef } sub Bar { } Bar(@{Foo()}) # you're saying this one works, or did you mean the else { } clause?\n","err":""},{"out":"ERROR: Can't use an undefined value as an ARRAY reference at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; sub Foo {undef } sub Bar { } my $x; Bar(@{$x = Foo()})\n","err":""},{"err":"","code":"use strict; use warnings; sub func { return undef;} if(1 and defined(func(\"Foo\"))) { print \"Success!\"; }\n","out":""},{"code":"use strict; use warnings; sub func { return undef;} if(1 and !defined(func(\"Foo\"))) { print \"Success!\\n\"; }\n","err":"","out":"Success!\n"},{"out":"","code":"use strict; use warnings; sub func { return undef;} if(1 and defined(func(\"Foo\"))) { print \"Success!\\n\"; }\n","err":""},{"out":"[125]","code":"use strict; use warnings; sub get_closure { my $x = 124; my $returnval = sub { return $x; }; ++$x; return $returnval; } my $foo = get_closure(); [$foo->()]\n","err":""},{"out":"ERROR: Global symbol \"$retval\" requires explicit package name (did you forget to declare \"my $retval\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; sub get_closure { my $x = 124; my $returnval = sub { return $x; }; ++$x; return $retval; } my $foo = get_closure(); [$foo->()]\n"},{"code":"use strict; use warnings; sub get_closure { my $x = 124; return sub { return $x; } } my $foo = get_closure(); [$foo->()]\n","err":"","out":"[124]"},{"err":"","code":"use strict; use warnings; sub get_closure { my $x = 124; return sub { return $x; }; ++$x; } my $foo = get_closure(); [$foo->()]\n","out":"[124]"},{"out":"3","err":"","code":"use strict; use warnings; sub ls{my ($n, $h)=@_;my $ret;for(0..$#$h){$ret=$_ and last if $n eq $h->[$_]}$ret}; ls (3,[0,1,4,3,2])\n"},{"out":"","code":"use strict; use warnings; sub { my $x = 42; sub { eval '$x' } }->()->()\n","err":"Variable \"$x\" is not available at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"oneone","err":"Variable \"$var\" will not stay shared at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; sub outer { my ($var) = @_; sub inner { print $var||'three' } }   outer(\"one\"); inner(); outer(\"two\"); inner() # as the warning implies, \"don't do this\"\n"},{"err":"","code":"use strict; use warnings; sub sort { CORE::GLOBAL::sort { $a <=> $b } @_ } [ sort 1,3,2,31,13,12,15,42 ] # huh, maybe\n","out":"[1,12,13,15,2,3,31,42]"},{"code":"use strict; use warnings; sub sort { GLOBAL::CORE::sort { $a <=> $b } @_ } [ sort 1,3,2,31,13,12,15,42 ] # all \u0002*your*\u0002 sorts, sure, but not all sorts everywhere\n","err":"","out":"[1,12,13,15,2,3,31,42]"},{"out":"42","err":"","code":"use strict; use warnings; sub test { return bareword { return 42; } }; test()\n"},{"err":"","code":"use strict; use warnings; sub what { (my $foo, @_) = @_; \\@_ } what(qw(a b c d));\n","out":"[\"b\",\"c\",\"d\"]"},{"out":"ERROR: Can't use global @_ in \"my\" at (eval 1) line 1, near \", @_\"\n","code":"use strict; use warnings; sub what { my ($foo, @_) = @_; \\@_ } what(qw(a b c d));\n","err":""},{"err":"","code":"use strict;use warnings;sub x { my($x,$y,$z)=@_;print $x } x(1,2);\n","out":"1"},{"err":"Possible unintended interpolation of @xxxxxxxx in string at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; system \"echo 'xxx@xxxxxxxx$' rsync\"\n","out":"ERROR: Global symbol \"@xxxxxxxx\" requires explicit package name (did you forget to declare \"my @xxxxxxxx\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"sub { \"DUMMY\" }","err":"","code":"use strict; use warnings; \\&this_sub_doesnt_exist\n"},{"out":"UTF-32","err":"Use of uninitialized value $1 in concatenation (.) or string at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; \"UCS-4\" =~ /^UCS-?4-?(BE|LE)?$/i; eval q@uc(\"UTF-32$1\")@\n"},{"out":"1","code":"use strict; use warnings; (undef) = 10;\n","err":""},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; undef = 10;\n","err":""},{"out":"ERROR: Global symbol \"$f\" requires explicit package name (did you forget to declare \"my $f\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; undef $f; my $f;\n","err":""},{"err":"","code":"use strict; use warnings; use 5.016; package Obj; sub new { return bless {} , shift; } sub w_state { state $foo; return ++$foo; } ; package main; my @x; my $t = Obj->new; my $r = Obj->new; push @x, $t->w_state; push @x, $r->w_state; [@x]\n","out":"[1,2]"},{"err":"","code":"use strict; use warnings; use constant TEST2 => TEST1; use constant TEST1 => 1; use constant TEST3 => TEST1; [TEST1, TEST2, TEST3]\n","out":"ERROR: Bareword \"TEST1\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\nBEGIN not safe after errors--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use strict; use warnings; use DateTime::TimeZone; my $tz = DateTime::TimeZone->new(name => '-0400')->name\n","out":"-0400"},{"out":"ERROR: The timezone 'America/New_York' could not be loaded, or is an invalid name.\n","code":"use strict; use warnings; use DateTime::TimeZone; my $tz = DateTime::TimeZone->new(name => 'America/New_York')\n","err":""},{"err":"","code":"use strict; use warnings; use experimental qw[signatures]; sub test ($foo) { say $foo } test ('moo')\n","out":"moo\n"},{"err":"","code":"use strict; use warnings; use experimental qw(signatures); sub whatever($=) { print $= } whatever(3) # I'm happy enough with the way signatures work at the moment though\n","out":"60"},{"out":"foo\n--\nbar\n","err":"","code":"use strict; use warnings; use feature qw(say); say for qw(foo -- bar); # what makes you think it throws an error?\n"},{"code":"use strict; use warnings; use feature qw(say); use XML::LibXML; my $t1 = XML::LibXML::Text->new( q{foo} ); my $t2 = XML::LibXML::Text->new( q{bar} ); $t1->appendChild( $t2 ); say $t1;\n","err":"","out":"ERROR: Can't locate XML/LibXML.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[1]","code":"use strict; use warnings; use List::MoreUtils qw(any all); my $count = 5; my @nums = (sort { $a <=> $b} qw(10 4 3 4 4 59 39 5 3)); [any { my $x = $_; my $p = $nums[$_]; all { $nums[$x+$_]-$p <= 3 } (0 .. $count-1) } 0 .. (@nums-$count)]\n","err":""},{"code":"use strict; use warnings; use List::MoreUtils qw(any all); my @nums = (sort { $a <=> $b} qw(10 4 3 4 4 59 39 5 3)); [any { my $x = $_; my $p = $nums[$_]; all { $nums[$x+$_]-$p <= 3 } (0 .. 5) } } keys(@nums)]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\nUnmatched right square bracket at (eval 1) line 1, at end of line\n"},{"out":"[1]","err":"","code":"use strict; use warnings; use List::MoreUtils qw(any all); my @nums = (sort { $a <=> $b} qw(10 4 3 4 4 59 39 5 3)); [any { my $x = $_; my $p = $nums[$_]; all { $nums[$x+$_]-$p <= 3 } (0 .. 5) } keys(@nums)]\n"},{"err":"Unquoted string \"uniq\" may clash with future reserved word at (eval 1) line 1, <STDIN> line 1.\nArgument \"b\" isn't numeric in sort at (eval 1) line 1, <STDIN> line 1.\nArgument \"a\" isn't numeric in sort at (eval 1) line 1, <STDIN> line 1.\nArgument \"c\" isn't numeric in sort at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; use List::MoreUtils qw/uniq/; [ sort(uniq qw/a b c a/) ];\n","out":"[\"a\",\"b\",\"c\",\"a\"]"},{"out":"[\"a\",\"b\",\"c\"]","code":"use strict; use warnings; use List::MoreUtils qw/uniq/; [ sort(uniq(qw/a b c a/)) ];\n","err":""},{"out":"1","code":"use strict; use warnings; use List::Util; my $c = [qw(a b c)]; print \"1\" if List::Util::any { $_ eq \"a\" } @{$c}\n","err":""},{"out":"[]","code":"use strict; use warnings; use List::Util qw(pairmap); $_ = qq{foo}; my @l = /(\\R)/; push @l, undef if @l%2; [ pairmap { [$a, $b] } @l ]\n","err":""},{"code":"use strict; use warnings; use List::Util qw(pairmap); $_ = qq{foo\\n}; [ pairmap { } split /\\R/ ];\n","err":"Odd number of elements in pairmap at (eval 1) line 1, <STDIN> line 1.\n","out":"[]"},{"out":"[]","code":"use strict; use warnings; use List::Util qw(pairmap); $_ = qq{foo}; [ pairmap { } split /(\\R)/ ]; # Better test case.\n","err":"Odd number of elements in pairmap at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; use List::Util qw[sum]; my $var = {  a => {count => 1},  b => {count => 5} }; [sum map { $_->{count} } values %{ $var }]\n","err":"","out":"[6]"},{"out":"[117799512]","err":"","code":"use strict; use warnings; use List::Util qw[sum]; my $var = {  a => {count => 1},  b => {count => 5} }; [sum values %{ $var }]\n"},{"err":"","code":"use strict; use warnings; use POSIX qw(sysconf); [ sysconf(POSIX::_SC_PAGESIZE()) ]\n","out":"[4096]"},{"out":"ERROR: Too many open files at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; use POSIX; setlocale(LC_NUMERIC, \"de_DE\") or die $!; sprintf(\"%.2f\", 23.45)\n"},{"code":"use strict; use warnings; use POSIX; setlocale(LC_NUMERIC, \"de_DE\"); sprintf(\"%.2f\", 23.45)\n","err":"","out":"23.45"},{"out":"[\"Regexp\"]","code":"use strict; use warnings; use Scalar::Util qw(blessed); [ blessed qr/foo/ ]\n","err":""},{"code":"use strict; use warnings; use Scalar::Util qw( reftype ); my $foreach = q{}; ref $foreach eq q{CODE}; # No warning.\n","err":"","out":""},{"err":"Use of uninitialized value in string eq at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; use Scalar::Util qw( reftype ); my $foreach = q{}; reftype $foreach eq q{CODE}; # Why does this warning occur?\n","out":""},{"out":"[\"Regexp\",\"REGEXP\"]","code":"use strict; use warnings; use Scalar::Util qw(reftype); my $re = qr/foo/; [ ref $re, reftype $re ];\n","err":""},{"out":"[\"main\",\"GLOB\"]","code":"use strict; use warnings; use Scalar::Util qw(reftype); my $x = bless \\*STDOUT; [ ref $x, reftype $x ];\n","err":""},{"err":"","code":"use strict; use warnings; use Scalar::Util qw(reftype); my $x = []; [ ref $x, reftype $x ];\n","out":"[\"ARRAY\",\"ARRAY\"]"},{"err":"","code":"use strict; use warnings; use Scalar::Util qw(reftype); my $x = {}; [ ref $x, reftype $x ];\n","out":"[\"HASH\",\"HASH\"]"},{"out":"[\"GLOB\",\"GLOB\"]","code":"use strict; use warnings; use Scalar::Util qw(reftype); my $x = \\*STDOUT; [ ref $x, reftype $x ];\n","err":""},{"err":"","code":"use strict; use warnings; use Scalar::Util qw(reftype); my $x = sub{}; [ ref $x, reftype $x ];\n","out":"[\"CODE\",\"CODE\"]"},{"err":"","code":"use strict; use warnings; vA.10\n","out":"ERROR: Bareword \"vA\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"like this","err":"","code":"use strict; use warnings; $::whatever = 'like this'; $::whatever\n"},{"code":"use strict; while (my $x = 1) { last } continue { say $x }\n","err":"","out":""},{"out":"ERROR: Global symbol \"$x\" requires explicit package name (did you forget to declare \"my $x\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; $x->()\n","err":""},{"code":"use strict; @x = (foo => 1, bar => 2); ${{@x}}{\"foo\"}\n","err":"","out":"ERROR: Global symbol \"@x\" requires explicit package name (did you forget to declare \"my @x\"?) at (eval 1) line 1, <STDIN> line 1.\nGlobal symbol \"@x\" requires explicit package name (did you forget to declare \"my @x\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use strict; $x = inf;\n","out":"ERROR: Global symbol \"$x\" requires explicit package name (did you forget to declare \"my $x\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use String::Util qw/trim/; trim(\"pink_mist\");\n","err":"","out":"ERROR: Can't locate String/Util.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate strit.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strit; 404->();\n"},{"out":"ERROR: Can't locate subs.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use subs 'defined'; sub defined { 42 } defined\n","err":""},{"code":"use subs 'foo'; sub AUTOLOAD { print 'hi' } foo;\n","err":"","out":"ERROR: Can't locate subs.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use subs print; sub print {CORE::print \"foo: @_\"}; print bar;\n","err":"","out":"ERROR: Can't locate subs.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate subs.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use subs qw/print/; sub *print {CORE::print \"foo: @_\"}; print bar;\n"},{"code":"use subs qw/print/; sub print {CORE::print \"foo: @_\"}; print bar;\n","err":"","out":"ERROR: Can't locate subs.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","code":"use Sub::Util\n","err":""},{"out":"ERROR: Can't locate Switch/Plain.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Switch::Plain;\n"},{"out":"ERROR: Can't locate Test/more.pm:   (null): Too many open files at (eval 1) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 2, <STDIN> line 1.\n","err":"","code":"use Test::more\n"},{"out":"ERROR: Can't locate Test/More.pm:   (null): Too many open files at (eval 1) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 2, <STDIN> line 1.\n","err":"","code":"use Test::More\n"},{"out":"ERROR: Can't locate Tie/IxHash.pm:   (null): Too many open files at (eval 1) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 2, <STDIN> line 1.\n","code":"use Tie::IxHash\n","err":""},{"out":"ERROR: Time::HiRes::usleep(-1): negative time not invented yet at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Time::HiRes 'usleep'; usleep(-1);\n"},{"code":"use Time::Moment\n","err":"","out":"ERROR: Can't locate Time/Moment.pm:   (null): Too many open files at (eval 1) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 2, <STDIN> line 1.\n"},{"err":"","code":"use Time::Seconds; say ONE_YEAR\n","out":"31556930\n"},{"out":"ERROR: Missing right curly or square bracket at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, at EOF\n","code":"use Try::Tiny; $a=1; $b=1; LABL: while($a--) {try {die if $b--} catch {redo LABL;} finally {print \"bark \"; print \"hello world\"};\n","err":""},{"code":"use Try::Tiny; $a=1; $b=1; LABL: while($a--) {try {die if $b--} catch {redo LABL;} finally {print \"bark \"}; print \"hello world\"};\n","err":"","out":"bark bark hello world"},{"code":"use Try::Tiny; $a=1; $b=1; LABL: while($a--) {try {die if $b--} catch {redo LABL;}; print \"hello world\"};\n","err":"","out":"hello world"},{"code":"use Try::Tiny; try {die \"baz\";} catch {die \"foo\"} finally { print \"hoyl shit that broke\"};\n","err":"","out":"hoyl shit that brokeERROR: foo at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use Unicode::UCD qw(charinfo); charinfo('x')\n","out":"ERROR: Can't locate Unicode/UCD.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use URI\n","out":""},{"out":"","code":"use URI;\n","err":""},{"out":"%3Carg%3E","code":"use URI::Encode qw/uri_encode/; uri_encode \"<arg>\", {\"encode_reserved\", 1}; \n","err":""},{"code":"use URI::Escape;\n","err":"","out":""},{"code":"use URI::Escape qw( uri_escape ); uri_escape q{foo+bar};\n","err":"","out":"foo%2Bbar"},{"out":"http%3A%2F%2Fweb.de%2F","err":"","code":"use URI::Escape; uri_escape_utf8 \"http://web.de/\"\n"},{"code":"use URI; my $foo = URI->new('http://www.example.com?q=Ãthelo&s=blah'); $foo->as_string;\n","err":"","out":"ERROR: Can't locate URI/http.pm:   (null): Too many open files at (eval 1) line 2, <STDIN> line 1.\n"},{"code":"use URI; my $u = URI->new( q{http://foo.com/bar?x=1&x=2&y=baz} ); +{ $u->query_form };\n","err":"","out":"ERROR: Can't locate URI/http.pm:   (null): Too many open files at (eval 1) line 2, <STDIN> line 1.\n"},{"code":"use URI; my $u = URI->new( q{http://foo} ); do { no overload; print $u; }\n","err":"","out":"ERROR: Can't locate URI/http.pm:   (null): Too many open files at (eval 1) line 2, <STDIN> line 1.\n"},{"code":"use URI; $u = URI->new(\"foo\", \"http\"); [ $u->as_string, $u->canonical ]\n","err":"","out":"ERROR: Can't locate URI/http.pm:   (null): Too many open files at (eval 1) line 2, <STDIN> line 1.\n"},{"code":"use utf8;  Â§$Â§\")/\"\n","err":"","out":"ERROR: Unrecognized character \\x{a7}; marked by <-- HERE after se utf8;  <-- HERE near column 102 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ÃÂ¢ÃÂÃÂ","code":"use utf8; \"â\"\n","err":""},{"err":"","code":"use utf8; $â = 1; $â\n","out":"ERROR: Unrecognized character \\x{2603}; marked by <-- HERE after se utf8; $<-- HERE near column 102 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"\\x{662}\\x{660}\\x{661}\\x{666}-\\x{660}\\x{663}-\\x{662}\\x{662}\",\"\\x{661}\\x{668}:\\x{665}\\x{664}:\\x{663}\\x{662}\"]","err":"","code":"use utf8; ['Ù¢Ù Ù¡Ù¦-Ù Ù£-Ù¢Ù¢ Ù¡Ù¨:Ù¥Ù¤:Ù£Ù¢' =~ /(\\d{4}-\\d{2}-\\d{2}) (\\d{2}:\\d{2}:\\d{2})/]\n"},{"code":"use utf8; ['Ù¢Ù Ù¡Ù¦-Ù Ù£-Ù¢Ù¢ Ù¡Ù¨:Ù¥Ù¤:Ù£Ù¢' =~ /(\\d{4}-\\d{2}-\\d{2}) (\\d{2}:\\d{2}\\d{2})/]\n","err":"","out":"[]"},{"err":"","code":"use utf8; ['Ù¢Ù Ù¡Ù¦-Ù Ù£-Ù¢Ù¢ Ù¡Ù¨:Ù¥Ù¤:Ù£Ù¢' =~ /(\\d{4}-\\d{2}-\\d{2}) (\\d{2}:\\d{2}:\\d{2})/a]\n","out":"[]"},{"code":"use utf8; \"Ù¢Å±\" =~ /^\\w+$/ # thomas_d\n","err":"","out":"1"},{"out":"1","code":"use utf8; 'Ù£' =~ /\\d/\n","err":""},{"out":"[1,1,1]","code":"use utf8; [ 'Ù£' =~ /\\d/a, 'Ù£' =~ /./a, \"Ù¢\" =~ /[Ù¡-Ù£]/a, 'Ù£' =~ /\\D/a ]\n","err":""},{"err":"","code":"use utf8; $ð¾ = 42;\n","out":"ERROR: Unrecognized character \\x{1f5fe}; marked by <-- HERE after se utf8; $<-- HERE near column 102 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Unrecognized character \\x{2706}; marked by <-- HERE after se utf8; $<-- HERE near column 102 at (eval 1) line 1, <STDIN> line 1.\n","code":"use utf8; $â = 5;\n","err":""},{"code":"use utf8; $_ = \"Ã¦Ã¸Ã¥\"; s/(.)/sprintf('\\\\u%04x', ord $1)/ger\n","err":"","out":"\\u00e6\\u00f8\\u00e5"},{"out":"testÃÂÃÂ¦","code":"use utf8; binmode STDOUT, ':utf8'; my $foo = \"test\\x{327}\"; $foo =~ tr/\\x{327}/\\x{326}/; $foo\n","err":""},{"err":"","code":"use utf8; $bit = \"C\"; print unpack(\"b8\", $bit) . \"\\n\"; $bit | 1 << 6; $bit = unpack(\"b8\", $bit); print $bi\n","out":"11000010\n"},{"err":"","code":"use utf8; bless {}, \"skjÃ¦rgÃ¥rdsÃ¸l\";\n","out":"bless( {}, 'skjÃÂ¦rgÃÂ¥rdsÃÂ¸l' )"},{"code":"use utf8; 'ð¢' =~ /\\d/\n","err":"","out":"1"},{"out":"","err":"","code":"use utf8; 'ð¢' =~ /\\d/a\n"},{"out":"1","code":"use utf8; $_=\"Ã©\"; $_++; $_\n","err":""},{"err":"","code":"use utf8; ['Ã©' =~ /[[:alpha:]]/ . '', 'Ã©' =~ /[[:alpha:]]/a . '']\n","out":"[1,\"\"]"},{"code":"use utf8; fc \"Ã\"\n","err":"","out":"ss"},{"out":"[\"\\x{561}\",\"\\x{4e55}\"]","err":"","code":"use utf8; [fc(\"Ô±\"), fc(\"ä¹\")]\n"},{"err":"","code":"use utf8; $ããã«ã¡ã¯ = \"Good afternoon\"; $ããã«ã¡ã¯\n","out":"Good afternoon"},{"out":"[\"\\0\\0\\0\\0\\0\"]","code":"use utf8; $l = \"fooso\"; [ $l & chr(0x80)x(length $l) ]\n","err":""},{"err":"","code":"use utf8; $l = \"fooso\"; [ $l =~tr/\\0-\\225//dr   ]\n","out":"[\"\"]"},{"code":"use utf8; [ map fc, qw(SS ss Ã Î£ Ï Ï I i Ä° Ä±) ]\n","err":"","out":"[\"ss\",\"ss\",\"ss\",\"\\x{3c3}\",\"\\x{3c3}\",\"\\x{3c3}\",\"i\",\"i\",\"i\\x{307}\",\"\\x{131}\"]"},{"err":"Use of uninitialized value $list in pattern match (m//) at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/utf8_heavy.pl line 599, <STDIN> line 1.\n","code":"use utf8; [ map lc, qw(SS ss Ã Î£ Ï Ï I i Ä° Ä±) ]\n","out":"[\"ss\",\"ss\",\"\\x{df}\",\"\\x{3a3}\",\"\\x{3c3}\",\"\\x{3c2}\",\"i\",\"i\",\"\\x{130}\",\"\\x{131}\"]"},{"code":"use utf8; my $Ã¥ = \"buu\"\n","err":"","out":"buu"},{"code":"use utf8; my %foo = ('â¥' => 'lukelove'); print $foo{'â¥'} . 'fuckit';\n","err":"","out":"lukelovefuckit"},{"out":"lukelove\n","code":"use utf8; my %foo = ('â¥' => 'lukelove'); say $foo{'â¥'};\n","err":""},{"code":"use utf8; my $foo = \"test\\x{327}\"; $foo =~ tr/\\x{327}/\\x{326}/; $foo\n","err":"","out":"testÃÂÃÂ¦"},{"out":"42\n","err":"","code":"use utf8; my $input = 'Ù£'; say $input + 42;\n"},{"out":"[\"\\x{c4}\"]","err":"","code":"use utf8; my $str = \"ÃÃ¶\"; [ $str =~ /([[:upper:]])/ ]\n"},{"out":"2","err":"","code":"use utf8;  my $szÃ­n = 1; $szÃ­n + 1\n"},{"err":"","code":"use utf8; my $x = \"ABC\"; $x =~ tr/ABC/ï¼¡ï¼¢ï¼£/; sprintf \"%vx\", $x\n","out":"ff21.ff22.ff23"},{"out":"42.69.e8.72.65","code":"use utf8; my $x = \"BiÃ¨re\"; printf \"%vx\", $x;\n","err":""},{"err":"","code":"use utf8; my $x = \"cafÃ©\"; my $y = substr($x, 1); [ utf8::is_utf8($x), utf8::is_utf8($y) ]\n","out":"[1,1]"},{"out":"","code":"use utf8; my $Î±, $Î²; #these are fine, my $a, $b; is not :P\n","err":""},{"err":"","code":"use utf8; [ord \"Ä\"]\n","out":"[265]"},{"err":"","code":"use utf8; ord \"Ä\"\n","out":"265"},{"code":"use utf8; [ord \"Ã¸\"]\n","err":"","out":"[248]"},{"code":"use utf8; [ord \"Å±\"]\n","err":"","out":"[369]"},{"out":"209","code":"use utf8; ord uc \"Ã±\"\n","err":""},{"code":"use utf8; package Âµ; sub message { \"Hi\" };  say Âµ->message;\n","err":"","out":"Hi\n"},{"code":"use utf8; 'pokÃ¨mon' =~ /\\bpok[eÃ¨]mon\\b/\n","err":"","out":"1"},{"code":"use utf8; print \"a\"Í¾ print \"b\"\n","err":"","out":"ERROR: Unrecognized character \\x{37e}; marked by <-- HERE after  print \"a\"<-- HERE near column 110 at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use utf8; print join \"\", (\"?\"..\"?\");\n","err":"","out":"?"},{"out":"hello","code":"use utf8; q ÌhelloÌ\n","err":""},{"code":"use utf8; qÌhelloÌ\n","err":"","out":"qÃÂÃÂhelloÃÂÃÂ"},{"out":"ÃÂÃÂ","code":"use utf8; quotemeta \"Ç\"\n","err":""},{"err":"","code":"use utf8; \"Ç\" =~ s/([^A-Za-z_0-9])/\\\\$1/gr\n","out":"\\ÃÂÃÂ"},{"out":"[\"\",1,1,1]","err":"","code":"use utf8; [ scalar('Ù£' =~ /^\\d$/a), scalar('Ù£' =~ /^.$/a), scalar(\"Ù¢\" =~ /^[Ù¡-Ù£]$/a), scalar('Ù£' =~ /^\\D$/a) ]\n"},{"code":"use utf8; [ scalar('Ù£' =~ /\\d/a), scalar('Ù£' =~ /./a), scalar(\"Ù¢\" =~ /[Ù¡-Ù£]/a), scalar('Ù£' =~ /\\D/a) ]\n","err":"","out":"[\"\",1,1,1]"},{"err":"","code":"use utf8; sprintf \"%x\", ord \"Å\"\n","out":"151"},{"code":"use utf8; sprintf \"%x\", ord uc \"Ã±\"\n","err":"","out":"d1"},{"err":"","code":"use utf8; [ 'Ã' =~ m/^\\Qss\\E\\z/i ? 'True' : 'False' ];\n","out":"[\"True\"]"},{"code":"use utf8; sub aâb { \"hi\" } aâb\n","err":"","out":"ERROR: Illegal declaration of subroutine main::a at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"whee","code":"use utf8; sub fÃ¥bar { print \"whee\" } fÃ¥bar();\n","err":""},{"out":"1","code":"use utf8; sub InGerm { join \"\\n\", map sprintf(\"%x\", ord($_)), qw(Ã¤ Ã¶ Ã¼) } \"Ã¶\" =~ /\\p{InGerm}/\n","err":""},{"out":"ERROR: Illegal declaration of anonymous subroutine at (eval 1) line 1, <STDIN> line 1.\n","code":"use utf8; sub Â» { print \"whee\" } Â»()\n","err":""},{"code":"use utf8; sub t { 1, 2, 3 } tâ¦0â¦\n","err":"","out":"ERROR: Unrecognized character \\x{2987}; marked by <-- HERE after , 2, 3 } t<-- HERE near column 120 at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use utf8; sub à² _à²  { \"yay\" } à² _à² \n","err":"","out":"yay"},{"out":"whee","err":"","code":"use utf8; sub ä¸ª { print \"whee\" } ä¸ª();\n"},{"out":"ÃÂ","err":"","code":"use utf8; uc \"Ã±\"\n"},{"out":"SS","err":"","code":"use utf8; uc \"Ã\"\n"},{"out":"51","err":"","code":"use utf8; unpack \"H2\", \"Å\"\n"},{"out":"ERROR: Can't find Unicode property definition \"Foo\" in regex; marked by <-- HERE in m/\\p{Foo} <-- HERE / at (eval 1) line 1, <STDIN> line 1.\n","code":"use utf8; use constant Foo => join \"\\n\", map sprintf(\"%x\", ord($_)), qw(Ã¤ Ã¶ Ã¼); [ \"Ã¶\" =~ /\\p{Foo}/ ];\n","err":""},{"code":"use utf8; use constant InFoo => join \"\\n\", map sprintf(\"%x\", ord($_)), qw(Ã¤ Ã¶ Ã¼); [ \"Ã¶\" =~ /\\p{InFoo}/ ];\n","err":"","out":"[1]"},{"out":"ERROR: Feature \"\" is not supported by Perl 5.24.0 at (eval 1) line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use utf8; use feature fc; [fc(\"Ô±\"), fc(\"ä¹\")]\n","err":""},{"out":"ERROR: Can't locate Mojo/UserAgent.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use utf8; use Mojo::UserAgent; Mojo::UserAgent->new->get('http://maÃ±ana.com')->res->dom->at('title')->text\n","err":""},{"out":"ERROR: Illegal declaration of subroutine main::ÃÂ¢ÃÂÃÂ at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use utf8; use strict; sub ââ () { \"cool\" } ââ\n"},{"out":"[\"\\x{4e6}ser\",\"B\\x{e1}nana\"]","code":"use utf8; [ \"Ó¦ser BÃ¡nana\" =~ /\\w+/g ]\n","err":""},{"out":"ÃÂÃÂ¯ ÃÂÃÂ¾ÃÂÃÂÃÂÃÂµÃÂÃÂ½ÃÂÃÂ ÃÂÃÂ¿ÃÂÃÂ»ÃÂÃÂ¾ÃÂÃÂÃÂÃÂ¾ ÃÂÃÂ³ÃÂÃÂ¾ÃÂÃÂ²ÃÂÃÂ¾ÃÂÃÂÃÂÃÂ ÃÂÃÂ¿ÃÂÃÂ¾ ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂºÃÂÃÂ¸ÃÂÃÂ¹","err":"","code":"use utf8; \"Ð¯ Ð¾ÑÐµÐ½Ñ Ð¿Ð»Ð¾ÑÐ¾ Ð³Ð¾Ð²Ð¾ÑÑ Ð¿Ð¾ ÑÑÑÑÐºÐ¸Ð¹\"\n"},{"out":"[12]","err":"","code":"use utf8; $Ô± = 5; $ä¹ = 7; [ $Ô± + $ä¹ ]\n"},{"code":"use utf8; [\"Ô±\" < \"ä¹\"?\"yes\":\"no\"]\n","err":"","out":"[\"no\"]"},{"out":"1","code":"use v5.12; $foo = 'bar'; ++$$foo; $bar\n","err":""},{"err":"","code":"use v5.12; \"foo\" =~ /(.*)/; say $1; { if (\"bar\" =~ /(.*)/) { say $1; } } say $1;\n","out":"foo\nbar\nfoo\n"},{"out":"foo\nbar\nbar\n","code":"use v5.12; \"foo\" =~ /(.*)/; say $1; if (\"bar\" =~ /(.*)/) { say $1; } say $1;\n","err":""},{"err":"","code":"use v5.12; sub combine { my $f = shift; @_ or return $f->(); my $xs = shift; for my $x (@$xs) { combine(sub { $f->($x, @_) }, @_); } } combine sub { say join(\", \", @_) }, ['a', 'b'], [1], [2, 3];\n","out":"a, 1, 2\na, 1, 3\nb, 1, 2\nb, 1, 3\n"},{"out":"a, 1, 2 | \na, 1, 3 | \nb, 1, 2 | \nb, 1, 3 | \n","code":"use v5.12; sub combine { my $f = shift; @_ or return $f->(); my $xs = shift; for my $x (@$xs) { combine(sub { $f->($x, @_) }, @_); } } combine sub { say join(\", \", @_), \" | \"; }, ['a', 'b'], [1], [2, 3];\n","err":""},{"out":"1","err":"","code":"use v5.12; ++$x\n"},{"out":"0","err":"","code":"use v5.16; $[ = 0\n"},{"out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 1) line 1, <STDIN> line 1.\n","code":"use v5.16; $[ = 1\n","err":""},{"err":"","code":"use v5.16; $_=1; $0xfc\n","out":"ERROR: syntax error at (eval 1) line 1, near \"$0xfc\n\"\n"},{"out":"/home/ryan/bots/perlbuut/lib/eval.pl","code":"use v5.16; $_=1; $0x fc\n","err":""},{"code":"use v5.16; $[ = -5;\n","err":"","out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"5 4 3 2 1 0 ","err":"","code":"use v5.16; my $f = sub { my ($n) = @_; print \"$n \"; $n or return; @_ = $n - 1; goto __SUB__; }; $f->(5);\n"},{"out":"1","err":"","code":"use v5.16; ++$x\n"},{"err":"","code":"use v5.18; 1;\n","out":"1"},{"err":"","code":"use v5.18.2;\n","out":""},{"out":"[0,1,2,3]","err":"","code":"use v5.20; my @x; push @x, foo(), foo(); sub foo { state $var = 0; $var++ } push @x, foo(), foo(); \\@x\n"},{"out":"","err":"","code":"use v5.20; say hi\n"},{"code":"use v5.20; say \"hi\" for Altreus;\n","err":"","out":"hi\n"},{"out":"sub { \"DUMMY\" }","err":"","code":"use v5.20; sub foo { __SUB__ } foo\n"},{"out":"[0,1,2]","err":"","code":"use v5.20; use warnings; { package Hi; sub foo { state $x = 0; $x++ }  sub new { bless {}, $_[0] } }  [ Hi->new->foo, Hi->new->foo, Hi->new->foo ]\n"},{"out":"","code":" use v5.6.1;\n","err":""},{"out":"surprise!\n","err":"","code":"use Variable::Magic qw(cast wizard); cast my $foo = 4, wizard get => sub { ${$_[0]}++ }; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say \"surprise!\" }\n"},{"err":"","code":"use vars qw( $foo ); $foo = 123; $foo;\n","out":"123"},{"code":"use warnings;\n","err":"","out":""},{"out":"1","code":"use warnings; \"\" == \"\"\n","err":"Argument \"\" isn't numeric in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\nArgument \"\" isn't numeric in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","code":"use warnings; ();\n","err":""},{"out":"{}","code":"use warnings; {{}}\n","err":""},{"out":"","err":"$# is no longer supported at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; $#\n"},{"out":"[1]","err":"","code":"use warnings;  [ !!\"\" == 0 ]\n"},{"code":"use warnings;  [ \"\" == 0 ]\n","err":"Argument \"\" isn't numeric in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\n","out":"[1]"},{"code":"use warnings; @_[0]\n","err":"Scalar value @_[0] better written as $_[0] at (eval 1) line 1, <STDIN> line 1.\n","out":"use warnings; @_[0]"},{"code":"use warnings; 0 + ''\n","err":"Argument \"\" isn't numeric in addition (+) at (eval 1) line 1, <STDIN> line 1.\n","out":"0"},{"code":"use warnings; 0+''\n","err":"Argument \"\" isn't numeric in addition (+) at (eval 1) line 1, <STDIN> line 1.\n","out":"0"},{"out":"0","err":"Argument \"\" isn't numeric in addition (+) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; 0+\"\"\n"},{"out":"73117744","err":"","code":"use warnings; 0+{}\n"},{"err":"","code":"use warnings; 0->[0];\n","out":""},{"out":"ERROR: Incomplete expression within '(?[ ])' in regex; marked by <-- HERE in m/(?[() <-- HERE ])/ at (eval 1) line 1, <STDIN> line 1.\n","err":"The regex_sets feature is experimental in regex; marked by <-- HERE in m/(?[ <-- HERE ()])/ at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; 00./(?[()])/\n"},{"out":"0","code":"use warnings; 0+!1\n","err":""},{"code":"use warnings; 0 + !5\n","err":"","out":"0"},{"err":"","code":"use warnings; 0+'    9'\n","out":"9"},{"err":"","code":"use warnings; 0+\"    9e5\";  # boo!\n","out":"900000"},{"out":"9","code":"use warnings; 0+\"    9e\";  # yay!\n","err":"Argument \"    9e\" isn't numeric in addition (+) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use warnings; 0+(\"a\" eq \"b\")\n","out":"0"},{"out":"[1]","code":"use warnings; [ '' == 0 ] # but you'll get a warning\n","err":"Argument \"\" isn't numeric in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"0","err":"","code":"use warnings; 0 + defined( undef )\n"},{"code":"use warnings; 0+'Inf'\n","err":"","out":"Inf"},{"out":"NaN","err":"Argument \"nanny\" isn't numeric in addition (+) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; 0+'nanny'\n"},{"err":"Use of uninitialized value in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; '0' == undef\n","out":"1"},{"code":"use warnings; $0 = undef; \"hello $0\"\n","err":"Use of uninitialized value $0 in scalar assignment at (eval 1) line 1, <STDIN> line 1.\n","out":"hello "},{"code":"use warnings; [ 1 + \"\" ]\n","err":"Argument \"\" isn't numeric in addition (+) at (eval 1) line 1, <STDIN> line 1.\n","out":"[1]"},{"out":"1","code":"use warnings; !1 == !1\n","err":""},{"out":"[1]","code":"use warnings; [ 1 == \"1\" ]\n","err":""},{"out":"[1]","code":"use warnings; [ 1 == \"1foo\" ]\n","err":"Argument \"1foo\" isn't numeric in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use warnings; 1+2; 3+4\n","err":"Useless use of a constant (3) in void context at (eval 1) line 1, <STDIN> line 1.\n","out":"7"},{"out":"","code":"use warnings; '15.8' == '123abc   '\n","err":"Argument \"123abc   \" isn't numeric in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","err":"Use of uninitialized value in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; '15.8' == undef\n"},{"out":"","code":"use warnings; '15.8' == (undef // '')\n","err":"Argument \"\" isn't numeric in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"use warnings; '15.8' == (undef // ')'\n","err":""},{"code":"use warnings; '15.8' == undef // ''\n","err":"Use of uninitialized value in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\n","out":""},{"out":"ERROR: Unknown warnings category '1' at (eval 1) line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings 1e0;\n","err":""},{"out":"[\"NaN\"]","err":"","code":"use warnings; [ 1 + \"NaN\" ]\n"},{"out":"[\"NaN\"]","err":"Argument \"Nanny may I have another?\" isn't numeric in addition (+) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; [ 1 + \"Nanny may I have another?\" ]\n"},{"err":"Argument \"not a number\" isn't numeric in addition (+) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; [ 1 + \"not a number\" ]\n","out":"[1]"},{"out":"2","err":"Argument \"0 but foo\" isn't numeric in addition (+) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; 2 + '0 but foo'\n"},{"out":"2","code":"use warnings; 2 + '0 but true'\n","err":""},{"out":"ERROR: Unmatched right square bracket at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, near \"$#a ]\"\n","code":"use warnings; $[ = 2; my @a = 5..9; [ keys @a], $#a ]\n","err":""},{"code":"use warnings; 3 + undef\n","err":"Use of uninitialized value in addition (+) at (eval 1) line 1, <STDIN> line 1.\n","out":"3"},{"out":"[-1,undef]","err":"Argument \"infinityandbeyond\" isn't numeric in numeric comparison (<=>) at (eval 1) line 1, <STDIN> line 1.\nArgument \"nananananananananaBATMAN\" isn't numeric in numeric comparison (<=>) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; [ 5 <=> \"infinityandbeyond\", 8 <=> \"nananananananananaBATMAN\" ]\n"},{"out":"[1]","err":"Argument \"cats\" isn't numeric in numeric comparison (<=>) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; [ 7 <=> \"cats\" ]\n"},{"out":"[undef]","err":"","code":"use warnings; [ 7 <=> \"nan\" ]\n"},{"err":"Argument \"nand\" isn't numeric in numeric comparison (<=>) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; [ 7 <=> \"nand\" ]\n","out":"[undef]"},{"code":"use warnings; [ 7 <=> \"nandos\" ]\n","err":"Argument \"nandos\" isn't numeric in numeric comparison (<=>) at (eval 1) line 1, <STDIN> line 1.\n","out":"[undef]"},{"out":"","code":"use warnings; 'a' < 0\n","err":"Argument \"a\" isn't numeric in numeric lt (<) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","code":"use warnings; @a[1]\n","err":"Scalar value @a[1] better written as $a[1] at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[1]","err":"Unescaped left brace in regex is deprecated, passed through in regex; marked by <-- HERE in m/a{ <-- HERE / at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; [ \"a{b\" =~ /a{/ ]\n"},{"code":"use warnings; \"a{b\" =~ m/{/;\n","err":"","out":"1"},{"err":"Unescaped left brace in regex is deprecated, passed through in regex; marked by <-- HERE in m/a{ <-- HERE / at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; \"a{b\" =~ m/a{/;\n","out":"1"},{"out":"true","err":"Use of uninitialized value in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; @a = (); print 'true' if @a == undef;\n"},{"out":"1","err":"","code":"use warnings; @array[0]=5\n"},{"code":"use warnings; $array[99999]=5; 0+ $array[99998]\n","err":"Use of uninitialized value $array[99998] in addition (+) at (eval 1) line 1, <STDIN> line 1.\n","out":"0"},{"out":"","err":"Scalar value @array[...] better written as $array[...] at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value $index in array slice at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; @array[$index]\n"},{"out":"","code":"use warnings; \"a\" =~ s/./$1/gr\n","err":"Use of uninitialized value $1 in substitution (s///) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","err":"Use of uninitialized value $1 in substitution (s///) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; \"a\" =~ s/./$1/r\n"},{"out":"","err":"Use of uninitialized value $dict{\"1\"} in substitution iterator at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; \"a\" =~ s/./$dict{1}/r\n"},{"code":"use warnings; 'bill.gates@microsoft.com' =~ /[\\w.]+\\@microsoft\\.com$/ ? \"matches\" : \"does not\"\n","err":"","out":"matches"},{"out":"Ã°ÂÂÂ©","err":"Wide character in print at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; binmode STDOUT; print \"\\x{1f4a9}\"\n"},{"code":"use warnings; \"blah\" == \"bleh\"\n","err":"Argument \"bleh\" isn't numeric in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\nArgument \"blah\" isn't numeric in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\n","out":"1"},{"out":"","err":"Use of uninitialized value in hash slice at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; @bucket_store_content{ $_path_dismantled_tmp[-2] }\n"},{"out":"1","code":"use warnings; @confignew{ \"vm-id\" } = [@listvm];\n","err":""},{"err":"","code":"use warnings; die, die, die;\n","out":"ERROR: Died at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","err":"dump() better written as CORE::dump() at (eval 1) line 1, <STDIN> line 1.\n/home/ryan/workspace/perlblead-ci/runeval.sh: line 5:   779 Aborted                 /home/ryan/perl5/perlbrew/perls/perlbot-blead-intest/bin/perl /home/ryan/bots/perlbuut/lib/eval.pl\n","code":"use warnings; dump\n"},{"err":"","code":"use warnings; each []\n","out":"ERROR: Experimental each on scalar is now forbidden at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use warnings; -e \"foo\\nbar\";\n","out":""},{"err":"Argument \"strength\" isn't numeric in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\nArgument \"endurance\" isn't numeric in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; [ 'endurance' == 'strength' ? 'yes' : 'no' ]\n","out":"[\"yes\"]"},{"code":"use warnings; eval{print 1; next; print 2}\n","err":"Exiting eval via next at (eval 1) line 1, <STDIN> line 1.\nExiting eval via next at (eval 1) line 1, <STDIN> line 1.\n","out":"1"},{"code":"use warnings; eval{print 1; next; print 2}; print 'code: '.$?\n","err":"Exiting eval via next at (eval 1) line 1, <STDIN> line 1.\nExiting eval via next at (eval 1) line 1, <STDIN> line 1.\n","out":"1"},{"out":"","code":"use warnings; eval { $x->{a}{b} }\n","err":""},{"code":"use warnings; exit \"with a string\"\n","err":"Argument \"with a string\" isn't numeric in exit at (eval 1) line 1, <STDIN> line 1.\n","out":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"1 { \"\n\"my\" variable $x masks earlier declaration in same statement at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"; }\"\n","err":"","code":"use warnings FATAL => \"all\"; if (1 { my $x = 42; print $x; }\n"},{"err":"","code":"use warnings FATAL => 'utf8'; use Unicode::UTF8 'decode_utf8'; decode_utf8 \"\\x20\\xf8\\x20\"\n","out":"ERROR: Can't locate Unicode/UTF8.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"Use of uninitialized value in -f at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; [ -f \"/\", -f \"/does-not-exist\", -f undef ]\n","out":"[\"\",undef,undef]"},{"err":"length() used on @foo (did you mean \"scalar(@foo)\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; @foo = (1,2,3); length(@foo)\n","out":"1"},{"err":"Smartmatch is experimental at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; \"foo\" ~~ \"Bar\"\n","out":""},{"out":"1","err":"Unescaped left brace in regex is deprecated, passed through in regex; marked by <-- HERE in m/{{ <-- HERE f/ at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; \"{{foo\" =~ /{{f/\n"},{"out":"abc","err":"Use of uninitialized value $foo in concatenation (.) or string at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; $foo = $foo . \"abc\";\n"},{"code":"use warnings; 'foo' =~ s/(.)/\\1/\n","err":"\\1 better written as $1 at (eval 1) line 1, <STDIN> line 1.\n","out":"ERROR: Can't modify constant item in substitution (s///) at (eval 1) line 1, at EOF\n"},{"err":"\\1 better written as $1 at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; \"foo\"=~s/(foo)/\\1/r\n","out":"foo"},{"out":"","code":"use warnings; @hash{$key}\n","err":"Scalar value @hash{...} better written as $hash{...} at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value $key in hash slice at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use warnings; @hash{$key} = [ @list ]\n","err":"Use of uninitialized value $key in hash slice at (eval 1) line 1, <STDIN> line 1.\n","out":"1"},{"out":"","err":"Useless use of hash element in void context at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; $hash{thing} => $value;\n"},{"out":"","err":"Use of uninitialized value $^HELLO_GUYS in concatenation (.) or string at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; ${^HELLO_GUYS} . \"\"\n"},{"code":"use warnings; hex q{112233445566778899}\n","err":"Integer overflow in hexadecimal number at (eval 1) line 4, <STDIN> line 1.\nHexadecimal number > 0xffffffff non-portable at (eval 1) line 4, <STDIN> line 1.\n","out":"3.16059037807746e+20"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"1 { \"\nsyntax error at (eval 1) line 1, near \"; }\"\n","code":"use warnings; if (1 { my $x = 42; print $x; }\n","err":"\"my\" variable $x masks earlier declaration in same statement at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"Argument \"b\" isn't numeric in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\nArgument \"a\" isn't numeric in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; if(\"a\" == \"b\"){print \"true\";}else{print \"false\";}\n","out":"true"},{"out":"","code":"use warnings; if (my $blah) { my $count = read $fh, my ($chunk), $chunk_size; }\n","err":""},{"out":"","code":"use warnings; if (my $blah) { my $count = read $fh, my $chunk, ($chunk_size); }\n","err":""},{"out":"","code":"use warnings; if (my $blah) { my $count = read $fh, my $chunk, $chunk_size }\n","err":""},{"out":"","err":"Parentheses missing around \"my\" list at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; if (my $blah) { my $count = read $fh, my $chunk, $chunk_size; }\n"},{"err":"","code":"use warnings; if (my $blah) { my $count = read $fh, my $chunk, +$chunk_size; }\n","out":""},{"out":"","err":"Subroutine foo redefined at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; if ($_) { sub foo { ... } } else { sub foo { ... } }\n"},{"err":"","code":"use warnings; if (\"this section commented out\" x 0) { die }\n","out":""},{"err":"","code":"use warnings; $INC{42}\n","out":""},{"code":"use warnings; int(q(\"1\"))\n","err":"Argument \"\"1\"\" isn't numeric in int at (eval 1) line 1, <STDIN> line 1.\n","out":"0"},{"out":"  ","err":"Use of uninitialized value in join or string at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value in join or string at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value in join or string at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; join \" \", undef, undef, undef;\n"},{"code":"use warnings; keys +{}\n","err":"","out":"ERROR: Experimental keys on scalar is now forbidden at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Type of arg 1 to keys must be hash (not constant item) at (eval 1) line 1, at EOF\n","err":"","code":"use warnings; keys INC\n"},{"err":"Exiting subroutine via last at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; LABEL: { sub { last LABEL }->(); print \"fail\" }; print \"ok\";\n","out":"ok"},{"err":"","code":"use warnings; [ map { $_ + 0 } !!0, !!\"\", !!undef ]\n","out":"[0,0,0]"},{"out":"[\"False\",\"False\",\"False\",\"False\",\"False\"]","code":"use warnings; [ map { ($_+0) ? 'True' : 'False' } 0, '0', '0 but true', '0e0', '0.0' ]\n","err":""},{"out":"[\"False\",\"False\",\"True\",\"True\",\"True\"]","code":"use warnings; [ map { $_ ? 'True' : 'False' } 0, '0', '0 but true', '0e0', '0.0' ]\n","err":""},{"out":"methods","err":"Unquoted string \"methods\" may clash with future reserved word at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value in concatenation (.) or string at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; ''.methods.length\n"},{"code":"use warnings; \"@microsoft.com\" =~ /microsoft.com$/ ? \"matches\" : \"does not\"\n","err":"Possible unintended interpolation of @microsoft in string at (eval 1) line 1, <STDIN> line 1.\n","out":"does not"},{"out":"1","err":"Use of uninitialized value $var in regexp compilation at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value $_ in pattern match (m//) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; m/$var/\n"},{"out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_\"\n","code":"use warnings; my $_;\n","err":""},{"code":"use warnings; my @a = 1..3; my %hash = @a;\n","err":"Odd number of elements in hash assignment at (eval 1) line 1, <STDIN> line 1.\n","out":"3"},{"out":"hello\n","err":"","code":"use warnings; my $a=5+3, \"hello\\n\";\n"},{"err":"Useless use of a constant (\"hello\\n\") in void context at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my $a=5+3, \"hello\\n\"; print $a\n","out":"8"},{"out":"","err":"","code":"use warnings; my @a = 5..9; delete $a[3] [ keys @a ]\n"},{"code":"use warnings; my @a = 5..9; delete $a[3]; [ keys @a ]\n","err":"","out":"[0,1,2,3,4]"},{"code":"use warnings; my @a = 5..9; delete $a[4]; [ keys @a ]\n","err":"","out":"[0,1,2,3]"},{"out":"[[0,1,2,3],3]","err":"","code":"use warnings; my @a = 5..9; delete $a[4]; [ [keys @a], $#a ]\n"},{"out":"[0,1,2,3,4]","code":"use warnings; my @a = 5..9; [ keys @a ]\n","err":""},{"out":"2","err":"","code":"use warnings; my $aref = [1,2,3]; @{$aref}[1]\n"},{"out":"2","err":"","code":"use warnings; my $aref = [1,2,3]; my $two = @{$aref}[1]\n"},{"out":"1","code":"use warnings; my %args = { foo => 'bar' };\n","err":"Reference found where even-sized list expected at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use warnings; my @arr = 1 .. 10; length(0 + @arr)\n","out":"2"},{"err":"","code":"use warnings; my @arr = 1 .. 10; length('' . @arr)\n","out":"2"},{"out":"2","code":"use warnings; my @arr = 1 .. 10; length(@arr)\n","err":"length() used on @arr (did you mean \"scalar(@arr)\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"2","code":"use warnings; my $arr = [1 .. 10]; length('' . @$arr)\n","err":""},{"out":"2","err":"","code":"use warnings; my @arr = 1 .. 10; length(map \"now that's just silly\", @arr)\n"},{"code":"use warnings; my @arr = (1, 3); @arr[0]\n","err":"Scalar value @arr[0] better written as $arr[0] at (eval 1) line 1, <STDIN> line 1.\n","out":"1"},{"err":"Argument \"anything\" isn't numeric in array element at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my @arr; $arr[\"anything\"] = 42;\n","out":"42"},{"code":"use warnings; my @arr; $arr[\"inf\"] = 42; [ @arr ]\n","err":"","out":"[42]"},{"out":"42","code":"use warnings; my @arr; $arr[\"NaN\"] = 42;\n","err":""},{"code":"use warnings; my @arr; $arr[\"NaN\"] = 42; [ @arr ]\n","err":"","out":"[42]"},{"out":"1","err":"Use of uninitialized value in print at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my @array; print $array[5];\n"},{"out":"ERROR: open: Invalid argument at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my $buf = \"\\x{666}\"; open my $fh, '<', \\$buf or die \"open: $!\"\n","err":"Strings with code points over 0xFF may not be mapped into in-memory file handles\n"},{"out":"ERROR: open: Too many open files at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my $buf = \"\\x{666}\"; open my $fh, '<:encoding(utf8)', \\$buf or die \"open: $!\"\n","err":"Unknown PerlIO layer \"encoding\" at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"Unknown PerlIO layer \"encoding\" at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my $buf = \"\\xd9\\xa6\"; open my $fh, '<:encoding(utf8)', \\$buf or die \"open: $!\"\n","out":"ERROR: open: Too many open files at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"this matches","code":"use warnings; my @foo = 0..10; print \"this matches\" if \"0 but true\" ~~ @foo;\n","err":"Smartmatch is experimental at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"this matches","code":"use warnings; my @foo = 0..10; print \"this matches\" if \"0 but true\" ~~ @foo; # thanks, pink_mist++\n","err":"Smartmatch is experimental at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"Smartmatch is experimental at (eval 1) line 1, <STDIN> line 1.\nUnquoted string \"mean\" may clash with future reserved word at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my @foo = 0..10; print \"this matches\" if \"0 but true\" ~~ @foo; ... too vague for predictable behavior, use the comparison you mean or try Smart::Match for explicit smartmatching\n","out":"ERROR: syntax error at (eval 1) line 1, near \"... too vague \"\n\"use\" not allowed in expression at (eval 1) line 1, near \", \"\n"},{"err":"Smartmatch is experimental at (eval 1) line 1, <STDIN> line 1.\nUnquoted string \"mean\" may clash with future reserved word at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my @foo = 0..10; print \"this matches\" if \"0 but true\" ~~ @foo; ... too vague for predictable behavior, use the comparison you mean or try Smart::Match for explicit smartmatching | \"Any non-trivial example of smartmatch usually does something other than the author intended.\"\n","out":"ERROR: syntax error at (eval 1) line 1, near \"... too vague \"\n\"use\" not allowed in expression at (eval 1) line 1, near \", \"\n"},{"err":"Smartmatch is experimental at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my @foo = 0..10; \"this matches\" if \"0 but true\" ~~ @foo;\n","out":"this matches"},{"code":"use warnings; my $foo = 1,2;\n","err":"","out":"2"},{"code":"use warnings; my $foo = 1,2,3; $foo\n","err":"Useless use of a constant (2) in void context at (eval 1) line 1, <STDIN> line 1.\nUseless use of a constant (3) in void context at (eval 1) line 1, <STDIN> line 1.\n","out":"1"},{"out":"1","err":"Useless use of a constant (2) in void context at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my $foo = 1,2; $foo\n"},{"out":"","code":"use warnings; my $foo = 1; my $bar = 2; my $name = \"foo\"; print \"ok\" if (defined(${$name}));\n","err":""},{"code":"use warnings; my $foo = 1; my $foobar = 2; \"$foo\\bar\"\n","err":"","out":"1\bar"},{"out":"\n","err":"Use of uninitialized value $foo in say at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my $foo = 1; undef $foo; say $foo\n"},{"err":"","code":"use warnings; my $foo, *bar;\n","out":"*main::bar"},{"out":"ERROR: Can't use 'defined(@array)' (Maybe you should just omit the defined()?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use warnings; my @foo; defined @foo\n"},{"err":"Useless use of private variable in void context at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my $foo; $foo; 1;\n","out":"1"},{"out":"ERROR: Experimental keys on scalar is now forbidden at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use warnings; my $foo = { foo => 42}; [ keys  $foo]\n"},{"err":"\"my\" variable $foo masks earlier declaration in same scope at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; { my $foo; my $foo; }\n","out":""},{"err":"","code":"use warnings; my $foo; { my $foo; }\n","out":""},{"err":"","code":"use warnings; my $foo = sub { +{ content => 'content' }; }; $foo->()->{content};\n","out":"content"},{"out":"content","err":"","code":"use warnings; my $foo = sub { +{ content => 'content' }; }; $foo->(){'content'};\n"},{"code":"use warnings; my $foo = sub { +{ content => 'content' }; }; $foo->(){content};\n","err":"Unquoted string \"content\" may clash with future reserved word at (eval 1) line 1, <STDIN> line 1.\n","out":"content"},{"err":"Use of uninitialized value $foo in string at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my $foo = undef; \"$foo\"\n","out":""},{"err":"Odd number of elements in hash assignment at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value in list assignment at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my %hash = undef;\n","out":"1"},{"err":"","code":"use warnings; my @list = 0 .. 10; [%list[1..2]]\n","out":"[1,1,2,2]"},{"code":"use warnings; my @list = \"a\" .. \"h\"; [%list[1..3]]\n","err":"","out":"[1,\"b\",2,\"c\",3,\"d\"]"},{"out":"Ã¯Â¼ÂªustÃ¯Â¼ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂtÃ¯Â½ÂÃ¯Â½ÂrÃ¯Â¼ÂÃ¯Â¼ÂµÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂrÃ¯Â¼Â","err":"","code":"use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; eval qq{ 'Just another Unicode hacker,' =~ tr[\\Q$l\\E][\\Q$r\\E]r };\n"},{"code":"use warnings; my $n=split(/\\|/,\"one|two|three|four\");\n","err":"","out":"4"},{"code":"use warnings; my $n = () = split(/\\|/,\"one|two|three|four\");\n","err":"","out":"1"},{"code":"use warnings; my $ref = []; @$ref[0]\n","err":"","out":""},{"code":"use warnings; my $ret = \"foo\" =~ s/Z/; [ $ret.\"\", $ret+0 ]\n","err":"","out":"ERROR: Substitution replacement not terminated at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use warnings; my $ret = \"foo\" =~ s/Z//; [ $ret.\"\", $ret+0 ]\n","err":"","out":"ERROR: Can't modify constant item in substitution (s///) at (eval 1) line 1, at EOF\n"},{"out":"[\"\",0]","code":"use warnings; my $ret = ( my $tmp = \"foo\" ) =~ s/Z//; [ $ret.\"\", $ret+0 ]\n","err":""},{"err":"Use of uninitialized value $str in scalar chomp at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my $str; chomp($str);\n","out":"0"},{"code":"use warnings; my $undefined; $undefined =~ s///;\n","err":"Use of uninitialized value $undefined in substitution (s///) at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value $undefined in substitution (s///) at (eval 1) line 1, <STDIN> line 1.\n","out":"1"},{"out":"","code":"use warnings; my $value = undef;  undef == 2\n","err":"Use of uninitialized value in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","err":"Use of uninitialized value $value in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my $value = undef;  $value == 2\n"},{"code":"use warnings; my $x = 12; [ \"19\" . $x ]\n","err":"","out":"[1912]"},{"out":"[1912]","code":"use warnings; my $x = 12; [ 19 . $x ]\n","err":""},{"out":"1235","err":"Argument \"1234abc\" isn't numeric in preincrement (++) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my $x = \"1234abc\"; $x++; $x\n"},{"out":"abce","code":"use warnings; my $x = \"abcd\"; $x++; $x\n","err":""},{"err":"","code":"use warnings; my $xml = { sessions => [ { session => { status => 42 } } ] }; $xml->{sessions}{session}{status}\n","out":"ERROR: Not a HASH reference at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"\"my\" variable $x masks earlier declaration in same statement at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my $x, my $x;\n","out":""},{"out":"","err":"\"my\" variable $x masks earlier declaration in same statement at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my ($x, $x)\n"},{"code":"use warnings; my $x; $x += 2;\n","err":"","out":"2"},{"code":"use warnings; my $x; $x .= \"foo\";\n","err":"","out":"foo"},{"err":"Use of uninitialized value $x in concatenation (.) or string at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my $x; $x . 'foo'\n","out":"foo"},{"code":"use warnings; my $x; $x = $x . 'foo'; # Zoffix\n","err":"","out":"foo"},{"code":"use warnings; my ($x, $y, $var) = (42, 37, 0); $var += max $x, $y; $var\n","err":"Useless use of private variable in void context at (eval 1) line 1, <STDIN> line 1.\n","out":"ERROR: Can't locate object method \"max\" via package \"42\" (perhaps you forgot to load \"42\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","code":"use warnings; my($x, $y, $x)\n","err":"\"my\" variable $x masks earlier declaration in same statement at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use warnings; my ($x, $y) = ($y, $x);\n","out":"2"},{"err":"","code":"use warnings; no warnings 'experimental::autoderef'; keys +{}\n","out":"ERROR: Unknown warnings category 'experimental::autoderef' at (eval 1) line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use warnings \"\\N{U+7FFFFFFF}\"\n","out":"ERROR: Unknown warnings category 'ÃÂ½ÃÂ¿ÃÂ¿ÃÂ¿ÃÂ¿ÃÂ¿' at (eval 1) line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ÃÂ½ÃÂ¿ÃÂ¿ÃÂ¿ÃÂ¿ÃÂ¿","code":"use warnings; \"\\N{U+7FFFFFFF}\"\n","err":""},{"err":"","code":"use warnings; opendir my $dirh, \".\";\n","out":""},{"code":"use warnings; open $fh, '<', \\\"lala\\nlulu\"; join '|', <$fh>\n","err":"","out":"lala\n|lulu"},{"out":"","err":"readline() on closed filehandle $fh at (eval 1) line 1.\n","code":"use warnings; open $fh, \"lala\\nlulu\"; join '|', <$fh>\n"},{"code":"use warnings; open $fh, \\ \"lala\\nlulu\"; join '|', <$fh>\n","err":"readline() on closed filehandle $fh at (eval 1) line 1.\n","out":""},{"out":"1","code":"use warnings; open my $fh, '>&=', 2\n","err":""},{"code":"use warnings;  our $NEGATIVE_INDICES = 1; sub M::TIEARRAY { bless {}, shift } sub M::FETCH { print \"Element $_[1]\" }  tie my @arr, \"M\";   $arr[\"onetwothree\"]\n","err":"Argument \"onetwothree\" isn't numeric in array element at (eval 1) line 1, <STDIN> line 1.\n","out":"Element 0"},{"out":"ERROR: Type of arg 1 to pop must be array (not constant item) at (eval 1) line 1, at EOF\n","err":"","code":"use warnings; pop INC\n"},{"out":"","err":"","code":"use warnings; print 'argh' and exit if $error;\n"},{"code":"use warnings; print(\"~/\").\"\\n\"\n","err":"","out":"~/"},{"out":"ÃÂ¢ÃÂÃÂ","code":"use warnings; print \"\\x{2603}\"\n","err":"Wide character in print at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use warnings; push INC, undef;\n","out":"ERROR: Type of arg 1 to push must be array (not constant item) at (eval 1) line 1, at EOF\n"},{"out":"ERROR: Switch (?(condition)... not terminated in regex; marked by <-- HERE in m/(?(DEFINE)(?<A>(?&B)|(?&C)) <-- HERE / at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; qr{(?(DEFINE)(?<A>(?&B)|(?&C))}xms;\n","err":""},{"code":"use warnings; qw(1,2,3)\n","err":"Possible attempt to separate words with commas at (eval 1) line 1, <STDIN> line 1.\n","out":"1,2,3"},{"err":"The lexical_subs feature is experimental at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings qw(experimental); my sub foo { ... }\n","out":""},{"out":"","err":"readline() on unopened filehandle at (eval 1) line 1.\n","code":"use warnings; readline \"{a,b,c}\"\n"},{"out":"[\"\"]","err":"","code":"use warnings; [ ref undef ]\n"},{"out":"1","code":"use warnings; reset\n","err":""},{"out":"\n","err":"Use of uninitialized value in say at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; say undef\n"},{"out":"1","err":"","code":"use warnings; scalar( 0, 1, 0, 1 );\n"},{"out":"5","code":"use warnings; scalar( 2, 3, 4, 5 );\n","err":"Useless use of a constant (2) in void context at (eval 1) line 1, <STDIN> line 1.\nUseless use of a constant (3) in void context at (eval 1) line 1, <STDIN> line 1.\nUseless use of a constant (4) in void context at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"14804","err":"","code":"use warnings; scalar grep {     $_ == 0 or $_ % 2 == 0 or $_ % 3 == 0 or $_ % 5 == 0 or $_ % 7 == 0 } map eval, glob join '{+,-,}', split //, \"7474810769\";\n"},{"out":"15197","err":"","code":"use warnings; scalar grep {     $_ == 0 or $_ % 2 == 0 or $_ % 3 == 0 or $_ % 5 == 0 or $_ % 7 == 0 } map eval, map s{[^0-9]\\K0([0-9])}{$1}gr, glob join \"{+,-,}\", split //, \"7474810769\";\n"},{"out":"available","err":"Useless use of a constant (\"set_status\") in void context at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; set_status => 'available';\n"},{"out":"ERROR: Unknown regexp modifier \"/I\" at (eval 1) line 1, near \"; \"\n","code":"use warnings; s///gI\n","err":""},{"out":"[0,3,7,\"nan\"]","err":"","code":"use warnings; [ sort { $a != $a ? 1 : $b != $b ? -1 : $a <=> $b } 0, 7, \"nan\", 3 ]\n"},{"out":"[1,2,3,4,4,11,11,15,\"NaN\",\"nan\",8]","err":"Use of uninitialized value in sort at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; [ sort { $a <=> $b } 4, 15, 11, \"NaN\", 11, 2, 1, 4, 3, \"nan\", 8 ]\n"},{"out":"[0,7,\"nan\",3]","code":"use warnings; [ sort { $a <=> $b } 7, 0, \"nan\", 3 ]\n","err":"Use of uninitialized value in sort at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[4,15,11,11,2,1,4,3,8]","err":"","code":"use warnings; [ sort { \"NaN\" } 4, 15, 11, 11, 2, 1, 4, 3, 8 ]\n"},{"out":"[\"foo\",\"bar\"]","code":"use warnings; splice @a, 2, 2, qw/foo bar/; \\@a\n","err":"splice() offset past end of array at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","code":"use warnings; \"string\"->{key}\n","err":""},{"code":"use warnings; ${\\\"string\"}->{key}\n","err":"","out":""},{"code":"use warnings; sub a { my $x=2; sub b { print $x } } a()\n","err":"Variable \"$x\" will not stay shared at (eval 1) line 1, <STDIN> line 1.\n","out":"2"},{"out":"2","err":"The signatures feature is experimental at (eval 1) line 1, <STDIN> line 1.\n\"my\" variable $x masks earlier declaration in same scope at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; sub a { my $x=2; sub b ($x) { my $x = $_[0]; print $x; } } a()\n"},{"out":"0 01 ","code":"use warnings; sub f { my $foo .= \"x\" if shift; $foo .= shift; \"$foo \"; } f(0,0).f(0,1);\n","err":""},{"out":"x0 1 ","err":"","code":"use warnings; sub f { my $foo .= \"x\" if shift; $foo .= shift; \"$foo \"; } f(1,0).f(0,1);\n"},{"out":"1","code":"use warnings; sub foo {1} $x = foo and 1\n","err":""},{"out":"0","err":"The signatures feature is experimental at (eval 1) line 1, <STDIN> line 1.\nAmbiguous use of %{foo} resolved to %foo at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; sub foo(){{}} %{foo}\n"},{"out":"[\"a\",\"b\"]","code":"use warnings; sub foo { @foos = 0; return @foos } @x = 'a' .. 'c'; [@x[foo()], $x[foo()]];\n","err":""},{"code":"use warnings; sub foo { @foos = 0 } @x = 'a' .. 'c'; @x[foo()]\n","err":"","out":"a"},{"out":"[\"b\",\"b\"]","err":"","code":"use warnings; sub foo { @foos = 1; return @foos } @x = 'a' .. 'c'; [@x[foo()], $x[foo()]];\n"},{"err":"","code":"use warnings; sub foo { @foos = 1 } @x = 'a' .. 'c'; [@x[foo()], $x[foo()]];\n","out":"[\"b\",\"b\"]"},{"code":"use warnings; sub foo(){{}} my %foo; %{foo}\n","err":"The signatures feature is experimental at (eval 1) line 1, <STDIN> line 1.\nAmbiguous use of %{foo} resolved to %foo at (eval 1) line 1, <STDIN> line 1.\n","out":"0"},{"out":"2","err":"","code":"use warnings; sub foo { my $x = 1; sub bar {my $y = 2;}}; foo(); bar();\n"},{"out":"","code":"use warnings; sub foo { my $x = 1; sub bar {my $y = $x} }\n","err":"Variable \"$x\" will not stay shared at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"Variable \"$x\" will not stay shared at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; sub foo { my $x = 1; sub bar {$x++}}; foo(); bar();\n","out":"1"},{"err":"The signatures feature is experimental at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; sub foo (&@) { sub foo; }\n","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(&@\"\n"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"use warnings; sub format {} format\n","err":""},{"err":"","code":"use warnings sub get_var { warn \"GET VAR\\n\"; return \\my $var }   ${ get_var } += 1\n","out":"ERROR: syntax error at (eval 1) line 1, near \"use warnings sub get_var \"\nsyntax error at (eval 1) line 1, near \"$var }\"\n"},{"err":"Ambiguous use of ${get_var} resolved to $get_var at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; sub get_var { warn \"GET VAR\\n\"; return \\my $var }   ${ get_var } += 1\n","out":"1"},{"err":"Ambiguous call resolved as CORE::index(), qualify as such or use & at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; sub index { ... } index \"asdf\", \"d\"\n","out":"2"},{"out":"ERROR: Invalid CODE attribute: index at (eval 1) line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; sub index :index { ... } index \"asdf\", \"d\"\n","err":""},{"code":"use warnings; sub index :method { ... } index \"asdf\", \"d\"\n","err":"","out":"2"},{"out":"ERROR: Unimplemented at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use warnings; sub index :method { ... } main::index\n"},{"code":"use warnings; sub index :method { scalar @_ } main::index qw( A B C D E )\n","err":"","out":"5"},{"out":"Element 0","err":"Argument \"onetwothree\" isn't numeric in array element at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings;  sub M::TIEARRAY { bless {}, shift } sub M::FETCH { print \"Element $_[1]\" }  tie my @arr, \"M\";   $arr[\"onetwothree\"]\n"},{"err":"The signatures feature is experimental at (eval 1) line 1, <STDIN> line 1.\nScalar found where operator expected at (eval 1) line 1, near \"$;$)\"\n\t(Missing operator before $)?)\n","code":"use warnings; sub mynumbs (@$;$);\n","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"@$;\"\n"},{"out":"1","err":"","code":"use warnings; sub push :method { ... }  my @array; push @array, \"value\";\n"},{"err":"Ambiguous call resolved as CORE::push(), qualify as such or use & at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; sub push { ... }  my @array; push @array, \"value\";\n","out":"1"},{"out":"","err":"Argument \"a\" isn't numeric in numeric lt (<) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; sub test { $_[0] < 0 and return } test('a')\n"},{"out":"","code":"use warnings; \"@things\"\n","err":"Possible unintended interpolation of @things in string at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","err":"","code":"use warnings; !!undef\n"},{"out":"[1]","err":"Use of uninitialized value in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; [ undef == 0 ]\n"},{"out":"","code":"use warnings; undef @foo;\n","err":""},{"out":"1","code":"use warnings; $undefined =~ s//bar/;\n","err":"Use of uninitialized value $undefined in substitution (s///) at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value $undefined in substitution (s///) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"Use of uninitialized value in substitution (s///) at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value in substitution (s///) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; undef =~ s//foo/r;\n","out":"foo"},{"err":"Use of uninitialized value in concatenation (.) or string at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; [undef, ''.undef]\n","out":"[undef,\"\"]"},{"out":"","err":"Useless use of a constant (15) in void context at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; use constant cat => 15; cat while $x++<1\n"},{"out":"","code":"use warnings; use constant cat => 1; cat while $x++<1\n","err":""},{"out":"","code":"use warnings; use constant cat => 1; cat() while $x++<1\n","err":""},{"code":"use warnings; use Encode; my $buf = encode('UTF-8', \"\\x{666}\"); open my $fh, '<', \\$buf or die \"open: $!\"; printf \"%vx\", <$fh>;\n","err":"","out":"d9.a6"},{"err":"Unknown PerlIO layer \"encoding\" at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; use Encode; my $buf = encode('UTF-8', \"\\x{666}\"); open my $fh, '<:encoding(UTF-8)', \\$buf or die \"open: $!\" #fine, Grinnz_\n","out":"ERROR: open: Too many open files at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"c480\"]","err":"","code":"use warnings; use Encode; my $x = qq<\\x{100}>; [ unpack q{H*}, Encode::encode_utf8 $x ]\n"},{"out":"[\"00\"]","code":"use warnings; use Encode; my $x = qq<\\x{100}>; [ unpack q{H*}, $x ]\n","err":"Character in 'H' format wrapped in unpack at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","code":"use warnings; use experimental 'smartmatch'; \"foo\" ~~ \"Bar\"\n","err":""},{"out":"","err":"prototype after '@' for fun mynumbs: $;$ at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; use Function::Parameters qw(:strict); fun mynumbs :(@$;$) {}\n"},{"code":"use warnings; use List::Uil 'max'; my ($x, $y, $var) = (42, 37, 0); $var += max $x, $y; $var\n","err":"","out":"ERROR: Can't locate List/Uil.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"42","err":"","code":"use warnings; use List::Util 'max'; my ($x, $y, $var) = (42, 37, 0); $var += max $x, $y; $var\n"},{"err":"","code":"use warnings; use Moose; has foo => (isa => 'rw); $x = $main->new; $x->foo(undef)\n","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use warnings; use strict; \"foo bar\" =~ /(?<A>\\w+)/ or die; print \"outer1: @{[%+]}; \"; { \"baz\" =~ /(?<B>failed match)/ or die; print \"inner: @{[%+]}; \"; } print \"outer2: @{[%+]}; \";\n","err":"","out":"outer1: A foo; ERROR: Died at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use warnings; use strict; \"foo bar\" =~ /(?<A>\\w+)/ or die; print \"outer1: @{[%+]}; \"; { \"baz\" =~ /(?<B>failed match)/; print \"inner: @{[%+]}; \"; } print \"outer2: @{[%+]}; \";\n","out":"outer1: A foo; inner: A foo; outer2: A foo; "},{"out":"outer1: A foo; inner: B baz; outer2: A foo; ","err":"","code":"use warnings; use strict; \"foo bar\" =~ /(?<A>\\w+)/ or die; print \"outer1: @{[%+]}; \"; { \"baz\" =~ /(?<B>\\w+)/ or die; print \"inner: @{[%+]}; \"; } print \"outer2: @{[%+]}; \";\n"},{"err":"","code":"use warnings; use strict; my @arr; $arr[-1] = 'foo';\n","out":"ERROR: Modification of non-creatable array value attempted, subscript -1 at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use warnings; use strict; my $bar; if (my $foo = $bar) { 1 }\n","err":"","out":""},{"code":"use warnings; use strict; my $fh; print $fh 42\n","err":"","out":"ERROR: Can't use an undefined value as a symbol reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't redeclare \"our\" in \"my\" at (eval 1) line 1, at end of line\n","code":"use warnings; use strict; my (our $x) = 42; [$x, $::x]\n","err":""},{"out":"afsfasdfsdafasf","code":"use warnings; use strict; my $str = 'afgasfasdf{afsfasdfsdafasf}asdfasfasdf'; my ($blah) = $str =~ m#^.*?{(.*?)}#; $blah\n","err":""},{"out":"afsfasdfsdafasfasdfasfasdf","code":"use warnings; use strict; my $str = 'afgasfasdf{afsfasdfsdafasfasdfasfasdf'; my ($blah) = $str =~ m#^.*?{(.*)#; $blah\n","err":""},{"err":"","code":"use warnings; use strict; my $x = UNIVERSAL->can('can'); ''->$x('can')\n","out":""},{"err":"","code":"use warnings; use strict; my %x; $x{1}++;\n","out":"0"},{"code":"use warnings; use strict; my $x; $x++; $x\n","err":"","out":"1"},{"out":"ERROR: Can't redeclare \"my\" in \"our\" at (eval 1) line 1, at end of line\n","err":"","code":"use warnings; use strict; our (my $x) = 42; [$x, $::x]\n"},{"code":"use warnings; use strict; package Don; sub t { 'cats' } package main; Don't;\n","err":"","out":"cats"},{"out":"/foo/bar","err":"","code":"use warnings; use strict; { package Foo; sub TIESCALAR { '/foo/bar' } } tie my $var, Foo::\n"},{"code":"use warnings; use strict; { package Foo; sub TIESCALAR { '/foo/bar' } } tie my $var, Foo::; \"$var\"\n","err":"Use of uninitialized value $var in string at (eval 1) line 1, <STDIN> line 1.\n","out":""},{"code":"use warnings; use strict; sub foo{{}} %{foo}\n","err":"Ambiguous use of %{foo} resolved to %foo at (eval 1) line 1, <STDIN> line 1.\nVariable \"%foo\" is not imported at (eval 1) line 1, <STDIN> line 1.\n\t(Did you mean &foo instead?)\n","out":"ERROR: Global symbol \"%foo\" requires explicit package name (did you forget to declare \"my %foo\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use warnings; use strict; sub foo { my $x; BEGIN { $x = 42; } $x++ } [ foo, foo ]\n","err":"Variable \"$x\" will not stay shared at (eval 1) line 1, <STDIN> line 1.\n","out":"[42,0]"},{"err":"The signatures feature is experimental at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; use strict; sub test($hr) { print Dumper(%$hr); }\n","out":""},{"code":"use warnings; use strict; { test => sub { print shift }, color => 'blue' }->{color}->(\"bar\")\n","err":"","out":"ERROR: Can't use string (\"blue\") as a subroutine ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"bar","code":"use warnings; use strict; { test => sub { print shift } }->{test}->(\"bar\")\n","err":""},{"out":"ERROR: Can't use an undefined value as an ARRAY reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use warnings; use strict; use experimental 'postderef'; my $x; my @z = @{ $x || [] }; $x->@*\n"},{"out":"1","code":"use warnings; v6.0.1 < 4\n","err":"Argument \"^F\\0^A\" isn't numeric in numeric lt (<) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"{^\"\n","code":"use warnings; ${^WIBBLE}{wat} = 42; [ keys %{^wibble} ]\n","err":"Unquoted string \"wibble\" may clash with future reserved word at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use warnings; ${^WIBBLE}{wat} = 42; [ keys %{^WIBBLE} ]\n","err":"","out":"[\"wat\"]"},{"err":"Use of uninitialized value $worldlen in numeric gt (>) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; $worldlen > 20\n","out":""},{"out":"","err":"Use of uninitialized value $x in string at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; \"$x\"\n"},{"err":"","code":"use warnings; $x\n","out":""},{"out":"","err":"Useless use of a constant (121321) in void context at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; $x=0;121321 while $x++<1\n"},{"code":"use warnings; $x = !0 + 1; $y = !0 . ''\n","err":"","out":"1"},{"out":"","code":"use warnings; $x = [ 0 ]; $x->[0][2]\n","err":""},{"code":"use warnings; $_=\"\\x19\"; $_=\"$_\\x00\"; print unpack \"B*\", $_&\"\\x80\\x00\"\n","err":"","out":"0000000000000000"},{"out":"1","code":"use warnings; $x = 1 and 1\n","err":"Found = in conditional, should be == at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use warnings; $x = 1; @bucket_store_content{ $x }\n","err":"Scalar value @bucket_store_content{...} better written as $bucket_store_content{...} at (eval 1) line 1, <STDIN> line 1.\n","out":""},{"out":"75","err":"Argument \"32 string\" isn't numeric in addition (+) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; $x = \"32 string\"; $y = 43; $x + $y\n"},{"err":"","code":"use warnings; $x[3] = 9; [exists $x[0], exists $x[4]];\n","out":"[\"\",\"\"]"},{"out":"4","err":"","code":"use warnings; $x=[4,5,6]; @$x[0]\n"},{"out":"7","err":"print() on unopened filehandle 43 at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; $x = \"4\"; $y = \"3\"; $l = $x . $y; $s = $x + $y; print $l print $s\n"},{"code":"use warnings; $x .= \"hallo\";\n","err":"","out":"hallo"},{"out":"","err":"","code":"use warnings; $xml->{sessions}{session}{'status'}\n"},{"out":"[\"a\",\"b\",\"c\"]","code":"use warnings; @x = qw(a b); splice @x, 2, 0, 'c'; \\ @x\n","err":""},{"err":"Scalar value @x[0] better written as $x[0] at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; $x = @x[0]\n","out":""},{"err":"Use of uninitialized value $x in repeat (x) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; $x x101\n","out":""},{"out":"1","err":"Use of uninitialized value $y in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value $x in numeric eq (==) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; $x == $y\n"},{"err":"","code":"use warnings; @y = (42); $x = delete $y[0]; [ $x, \\@y ]\n","out":"[42,[]]"},{"out":"ERROR: Can't locate x.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use x $^W++;join(($x)x101)\n"},{"out":"U+0068 U+0065 U+006C U+006C U+006F","code":"\"U+\" . sprintf \"%*v04X\", \" U+\", \"hello\"\n","err":""},{"code":"#!/usr/bin/perl -w                                      # camel code\n","err":"","out":""},{"err":"","code":"[ '/usr/local/bin/openerp-server' =~ m{([^/]+)$} ]\n","out":"[\"openerp-server\"]"},{"out":"ÃÂ´","code":"utf8::downgrade(my $o = \"\\x{f4}\"); $o\n","err":""},{"err":"","code":"utf8::downgrade(my $o = \"\\x{f4}\"); use Data::Dumper; Dumper($o)\n","out":"$VAR1 = 'ÃÂ´';\n"},{"out":"","code":"utf8::encode(chr(2<<15))\n","err":""},{"code":"utf8::encode(my $s = chr(2<<15)); $s\n","err":"","out":"ÃÂ°ÃÂÃÂÃÂ"},{"code":"utf8::is_utf8 chr 255\n","err":"","out":""},{"out":"1","err":"","code":"utf8::is_utf8 chr 321\n"},{"out":"ÃÂ´","err":"","code":"utf8::upgrade(my $o = \"\\x{f4}\"); $o\n"},{"code":"utf8::upgrade(my $o = \"\\x{f4}\"); use Data::Dumper; Dumper($o)\n","err":"","out":"$VAR1 = \"\\x{f4}\";\n"},{"code":"'Ã¼' =~ /\\w/\n","err":"","out":"1"},{"code":"'Ã¼' =~ /\\w/a\n","err":"","out":""},{"out":"","err":"","code":"\"Ã¼\" xor \"Ã¼\"\n"},{"code":"[\"Ã¼\" xor \"Ã¼\"]\n","err":"","out":"[\"\"]"},{"out":"","err":"","code":"$V\n"},{"code":"$v = 0x100202020; $v =( ($v << 1) & 0xFFFFFFFF) | (($v >> 31) & 0x1); sprintf \"%08X\", $v\n","err":"","out":"00404040"},{"out":"00000000","err":"","code":"$v = 0x100202020; $v =( ($v << 4) & 0xF) | (($v >> (32-4)) & 0x7); sprintf \"%08X\", $v\n"},{"out":"20404040","code":"$v = 0x10202020; $v =( ($v << 1) & 0xFFFFFFFF) | (($v >> 31) & 0x1); sprintf \"%08X\", $v\n","err":""},{"out":"02020201","code":"$v = 0x10202020; $v =( ($v << 4) & 0xFFFFFFFF) | (($v >> (32-4)) & 0x7); sprintf \"%08X\", $v\n","err":""},{"out":"pan","err":"","code":"v112.97.110\n"},{"out":"thx pink_mist","err":"","code":"v116.104.120.32.112.105.110.107.95.109.105.115.116\n"},{"out":"[v1.2.3]","err":"","code":"[v1.2.3]\n"},{"out":"\u0001\u0002\u0003","code":"v1.2.3\n","err":""},{"out":"ERROR: Can't modify constant item in scalar assignment at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, near \"echo \"${v//[^0-9]/}\"\"\n","code":"v=\"123 abc\"; echo \"${v//[^0-9]/}\";\n","err":""},{"code":"[ v127.0.0.1 ]\n","err":"","out":"[v127.0.0.1]"},{"out":"ÃÂPNG\r\n\u001a\n","err":"","code":"v137.80.78.71.13.10.26.10\n"},{"out":"\u0005\u000e\u0000","err":"","code":"v5.14.0\n"},{"out":"\u0005\u0016\u0000","code":"v5.22.0\n","err":""},{"out":"Tracking-Num... ","code":"v84.114.97.99.107.105.110.103.45.78.117.109.46.46.46.32\n","err":""},{"code":"vA.10 <=> vB.9\n","err":"","out":"0"},{"code":"vA.10 < vB.9\n","err":"","out":""},{"code":"$val = 'a'; [map $val++, 1 .. 3]\n","err":"","out":"[\"a\",\"b\",\"c\"]"},{"code":"$_ = '\"Validation25\",,,,,1,1,1,1,,'; s/,(?=,)/,\\\\N/g; $_\n","err":"","out":"\"Validation25\",\\N,\\N,\\N,\\N,1,1,1,1,\\N,"},{"out":"11","code":"@values = (1, 0, 1, 1); $n = 0; $idx = $#values; $n += $_ * (2 ** ($#values - $idx)), --$idx foreach reverse @values; $n;\n","err":""},{"out":"13","code":"@values = (1, 0, 1, 1);  $n = 0; ($n *= 2) += $_ for reverse @values; $n;\n","err":""},{"code":"$var = 0; $var = ! $var;\n","err":"","out":"1"},{"code":"$var1 = ''; $var2 = 0; $var3 = undef; [ defined $var1, defined $var2, defined $var3 ]\n","err":"","out":"[1,1,\"\"]"},{"out":"0777\n","code":"$variable = sprintf \"%04o\\n\",0777;\n","err":""},{"out":"raddtiz lol","err":"","code":"$varname=\"raddtiz\"; print \"$varname lol\"\n"},{"err":"","code":"$var = 'original '; print $var; { local $var = 'replacement '; print $var }; print $var;\n","out":"original replacement original "},{"code":"$var =[]; ref \\$var\n","err":"","out":"REF"},{"out":"[\"ARRAY\",\"REF\"]","code":"$var = []; [ref $var, ref \\$var]\n","err":""},{"out":"GLOB","err":"","code":"$var = *STDOUT; ref \\$var\n"},{"out":"[\"\",\"GLOB\"]","code":"$var = *STDOUT; [ref $var, ref \\$var]\n","err":""},{"out":"[\"GLOB\",\"REF\"]","code":"$var = \\*STDOUT; [ref $var, ref \\$var]\n","err":""},{"out":"LVALUE","code":"*var = \\substr $_, 0, 1; ref \\$var\n","err":""},{"err":"","code":"vec($_,7,1)=1; [unpack \"s>\", $_]\n","out":"[]"},{"err":"","code":"vec($_,8,1)=1; [unpack \"s>\", $_]\n","out":"[1]"},{"out":"\u0000\u0002","code":"vec($_,9,1)=1; print $_\n","err":""},{"code":"vec($_,9,1)=1; print ord $_\n","err":"","out":"01"},{"err":"","code":"vec( my $x, 4, 4 ) = 1; printf '%*08b', ' ', $x;\n","out":"%*08b"},{"out":"00000000 00000000 00000001","code":"vec( my $x, 4, 4 ) = 1; printf '%*v08b', ' ', $x;\n","err":""},{"err":"","code":"vec( my $x, 4, 4 ) = 8; printf '%*v08b', ' ', $x;\n","out":"00000000 00000000 00001000"},{"err":"","code":"'<' =~ /[[:vowel:]]/\n","out":"ERROR: POSIX class [:vowel:] unknown in regex; marked by <-- HERE in m/[[:vowel:] <-- HERE ]/ at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"255","code":"$v = unpack('C', pack('B8', '11111111')); $v\n","err":""},{"out":"[0,0,0,0,0,0,0,0,0,0,0,0]","err":"","code":"$w = 3; $h = 4; @out = ( (0) x $w ) x $h; \\@out\n"},{"out":"[[0,0,0],$VAR1->[0],$VAR1->[0],$VAR1->[0]]","err":"","code":"$w = 3; $h = 4; @out = ([ (0) x $w ]) x $h; \\@out\n"},{"out":"[\\0,$VAR1->[0],$VAR1->[0],$VAR1->[0],$VAR1->[0],$VAR1->[0],$VAR1->[0],$VAR1->[0],$VAR1->[0],$VAR1->[0],$VAR1->[0],$VAR1->[0]]","err":"","code":"$w = 3; $h = 4; @out = (\\( (0) x $w )) x $h; \\@out\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"] 1\"\n","code":"$w = 3; $h = 4; @out = map [ (0) x $w ] 1..$h; \\@out\n","err":""},{"out":"[[0,0,0],[0,0,0],[0,0,0],[0,0,0]]","err":"","code":"$w = 3; $h = 4; @out = map [ (0) x $w ], 1..$h; \\@out\n"},{"code":"wantarray\n","err":"","out":""},{"err":"","code":"wantarray ? \"list context\" : defined wantarray ? \"scalar context\" : \"void context\" # there, made it more clearer\n","out":"scalar context"},{"code":"\"${\\( wantarray() ? 'list' : 'scalar' )}->()}\"\n","err":"","out":"scalar->()}"},{"err":"","code":"\"${\\( wantarray() ? 'list' : 'scalar' )}\"\n","out":"scalar"},{"err":"","code":"wantarray() ? 'list' : 'scalar'\n","out":"scalar"},{"out":"no","err":"","code":"wantarray ? \"yes\" : defined wantarray ? \"no\" : \"maybe\"\n"},{"code":"warn\n","err":"Warning: something's wrong at (eval 1) line 1, <STDIN> line 1.\n","out":"1"},{"out":"1","code":"warn \"hello\"\n","err":"hello at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"warn \"hello\\n\"\n","err":"hello\n","out":"1"},{"out":"1","err":"Warning: something's wrong at (eval 1) line 1, <STDIN> line 1.\n","code":"warn undef\n"},{"out":"","err":"","code":"$^W++;eval \"0\".\".undef\"x101\n"},{"out":"1","code":"'/**' =~ /^\\/\\*\\*/ # wfm\n","err":""},{"out":"ERROR: Can't modify constant item in transliteration (tr///) at (eval 1) line 1, at EOF\n","err":"","code":"'wftedskaebjgdpjgidbsmnjgc' =~ tr/a-z/oh, turtleneck Phrase Jar!/;\n"},{"code":"$_ = \"wftedskaebjgdpjgidbsmnjgc\"; tr/a-z/oh, turtleneck Phrase Jar!/; print;\n","err":"","out":"Just another Perl hacker,"},{"err":"","code":"$_ = \"wftedskaebjgdpjgidbsmnjgc\";tr/a-z/oh, turtleneck Phrase Jar!/; print;\n","out":"Just another Perl hacker,"},{"out":"Just another Perl hacker,","err":"","code":"'wftedskaebjgdpjgidbsmnjgc' =~ tr/a-z/oh, turtleneck Phrase Jar!/r;\n"},{"err":"","code":"@what = ([a,b],[1,2],[3,4]); [ map { s/_//r=~s/_/, /gr } glob join '', map { $\"=',_'; \"{_@$_}\" } @what ]\n","out":"[\"a, 1, 3\",\"a, 1, 4\",\"a, 2, 3\",\"a, 2, 4\",\"b, 1, 3\",\"b, 1, 4\",\"b, 2, 3\",\"b, 2, 4\"]"},{"out":"[0]","err":"","code":"[$whatever++]\n"},{"out":"","err":"Out of memory!\n","code":"while ( 1 ) { print \"Don't break\\n\"; }\n"},{"code":"while(@ARGV){@ARVG[1] = \"test\"; print \"true\"; exit()}\n","err":"","out":"0"},{"err":"","code":"while(@ARGV){print \"true\"; exit()}\n","out":"0"},{"code":"'while cloud dark CLoud fluffy CLOUD ClOuD' =~ s/(cloud)/ (~($1 & ' ' x length $1) ^ ' ' x length $1) & lc 'butt' /egir\n","err":"","out":"while butt dark BUtt fluffy BUTT BuTt"},{"err":"","code":"while(my $e = glob \"{foo,bar}\") {print $e, \"    \"}\n","out":"foo    bar    "},{"code":"while((my $pid = -1) > 0) { print $pid } \"done\"\n","err":"","out":"done"},{"out":"[[\"e\",\"a\"],[\"a\",\"n\"],[\"a\",\"r\"],[\"o\",\"t\"]]","code":"while ('peas and carrots' =~ /([aeiou])(.)/g) { push @bar, [ $1, $2 ] } \\@bar\n","err":""},{"code":"while ('peas and carrots' =~ /(?<v>[aeiou])(?<n>.)/g) { push @bar, { %+ } } \\@bar\n","err":"","out":"[{v => \"e\",n => \"a\"},{v => \"a\",n => \"n\"},{v => \"a\",n => \"r\"},{v => \"o\",n => \"t\"}]"},{"err":"","code":"whoami\n","out":"whoami"},{"out":"","code":"`whoami`\n","err":""},{"err":"","code":"\"who knows?\"\n","out":"who knows?"},{"out":"ERROR: Substitution replacement not terminated at (eval 1) line 1, <STDIN> line 1.\n","code":"\"wibble\" =~ s/wi(b+)/{\"a\".(\"g\"x length $1)}re\n","err":""},{"out":"aggle","err":"","code":"\"wibble\" =~ s{wi(b+)}{\"a\".(\"g\"x length $1)}re\n"},{"out":"","err":"","code":"$^W++;join(($x)x101)\n"},{"out":"1","err":"","code":"'word $3' =~ /^\\w+ \\$\\d$/\n"},{"out":"1","err":"","code":"'word $3' =~ /^\\w+\\s\\$\\d$/\n"},{"code":"$word = 'hangman'; $sofar = $word =~ s/./_/gr; for $guess (qw(n m z a g h)){ $sofar ^= $word =~ s/[^$guess]/\\0/gr =~ s/$guess/$guess ^ '_'/ger; print \"$sofar  \" }\n","err":"","out":"__n___n  __n_m_n  __n_m_n  _an_man  _angman  hangman  "},{"out":"[\"words\",\"in\",\"quotes\"]","code":"['\"words in quotes\"' =~ /\\b(\\w+)\\b/g ]\n","err":""},{"out":"[\"worker2\"]","err":"","code":"[\"worker1worker2\" =~ /^(worker[0-9],?)+$/]\n"},{"code":"[\"worker1worker2\" =~ /(worker[0-9],?)+/]\n","err":"","out":"[\"worker2\"]"},{"out":"[]","code":"[\"worker1worker2\" =~ /^(worker[0-9],?)\\1*$/]\n","err":""},{"code":"[\"worker1worker2\" =~ /(worker[0-9],?)\\1*/]\n","err":"","out":"[\"worker1\"]"},{"out":"[\"worker_1\",\"worker_2\",\"worker_3\",\"worker_4\",\"worker_5\"]","err":"","code":"$_ = ' worker.loadbalancer.balance_workers=  worker_1,worker_2,worker_3,worker_4,worker_5'; my (@out, @tmp); m{ \\A \\s* \\Qworker.loadbalancer.balance_workers=\\E \\s* (worker_[0-9]) (?{ push @tmp, $1 }) (?: , (worker_[0-9]) (?{ push @tmp, $2 }) )* \\z (?{ @out = @tmp }) }x; [ @out ]\n"},{"err":"","code":"... works too\n","out":"ERROR: syntax error at (eval 1) line 1, near \"... works too\n\"\n"},{"out":"","err":"","code":"$worldlen > 20\n"},{"err":"","code":"write($sock, $request, length($request));\n","out":""},{"out":"[0,1,2]","err":"","code":"[$^W, $^S, $^F]\n"},{"err":"","code":"$w=\"specific\"; $len=length $w; for my $i (0..$len-1) { for my $j (1..$len-$i) { push @parts,substr $w,$i,$j}} \\@parts\n","out":"[\"s\",\"sp\",\"spe\",\"spec\",\"speci\",\"specif\",\"specifi\",\"specific\",\"p\",\"pe\",\"pec\",\"peci\",\"pecif\",\"pecifi\",\"pecific\",\"e\",\"ec\",\"eci\",\"ecif\",\"ecifi\",\"ecific\",\"c\",\"ci\",\"cif\",\"cifi\",\"cific\",\"i\",\"if\",\"ifi\",\"ific\",\"f\",\"fi\",\"fic\",\"i\",\"ic\",\"c\"]"},{"code":"$::{wtf} = \\*hi; wft();\n","err":"","out":"ERROR: Undefined subroutine &main::wft called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Undefined subroutine &main::wtf called at (eval 1) line 1, <STDIN> line 1.\n","code":"$::{wtf} = \\\"hi\"; wtf()\n","err":""},{"code":"\"$x\"\n","err":"","out":""},{"err":"","code":"\"\\x<\"\n","out":"\u0000<"},{"code":"\"\\x\"\n","err":"","out":"\u0000"},{"err":"","code":"[x=>~~[]]\n","out":"[\"x\",70574128]"},{"err":"","code":"$x\n","out":""},{"out":"ERROR: Can't use an undefined value as a subroutine reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"$x->()\n"},{"err":"","code":"\\$x\n","out":"\\undef"},{"out":"1","code":"++$x\n","err":""},{"out":"1","code":"$x**0\n","err":""},{"out":"ERROR: Invalid quantifier in {,} in regex; marked by <-- HERE in m/x{ <-- HERE 00}/ at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"/x{00}/\n"},{"err":"","code":"/x{01}/\n","out":"ERROR: Invalid quantifier in {,} in regex; marked by <-- HERE in m/x{ <-- HERE 01}/ at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"0.00537109375","code":"$x = '0.101010101110011'; hex(\"0b$x\")/2**(length($x) - 2)\n","err":"Illegal hexadecimal digit '.' ignored at (eval 1) line 4, <STDIN> line 1.\n"},{"err":"","code":"\"\\x{0265}\\x{01DD}\\x{028E}\"\n","out":"ÃÂÃÂ¥ÃÂÃÂÃÂÃÂ"},{"out":"[\"042\",\"042\"]","err":"","code":"$x = '042'; [ $x, \"$x\" ]\n"},{"code":"@x = (0 .. 5); [\\@x, $#x, scalar @x]\n","err":"","out":"[[0,1,2,3,4,5],5,6]"},{"code":"${\"\\x{06}\"} = 1; ++${\"\\x{06}\"};\n","err":"","out":"2"},{"out":"9","code":"@x = (0 .. 9); pop @x;\n","err":""},{"out":"0","err":"","code":"@x = (0 .. 9); shift @x;\n"},{"out":"[\"\\n\"]","code":"[\"\\x0a\"]\n","err":""},{"out":"00000100","err":"","code":"$x = 0b00001000; $x >>= 1; sprintf '%08b', $x\n"},{"out":"1.35308431126191e-16","err":"","code":"$x = 0; for (1..1000) {$x += 0.01;}; for (1..1000) {$x -= 0.01}; $x\n"},{"code":"$x = 0; for (1 .. 1000) { $x += 0.01; } $x\n","err":"","out":"9.99999999999983"},{"out":"[\"0.5\",\"0.75\",\"0.875\",\"0.9375\",\"0.96875\",\"0.984375\",\"0.9921875\",\"0.99609375\",\"0.998046875\",\"0.9990234375\",\"0.99951171875\",\"0.999755859375\",\"0.9998779296875\",\"0.99993896484375\",\"0.999969482421875\",\"0.999984741210938\",\"0.999992370605469\",\"0.999996185302734\",\"0.999998092651367\",\"0.999999046325684\",\"0.999999523162842\",\"0.999999761581421\",\"0.99999988079071\",\"0.999999940395355\",\"0.999999970197678\",\"0.999999985098839\",\"0.999999992549419\",\"0.99999999627471\",\"0.999999998137355\",\"0.999999999068677\",\"0.999999999534339\",\"0.999999999767169\",\"0.999999999883585\",\"0.999999999941792\",\"0.999999999970896\",\"0.999999999985448\",\"0.999999999992724\",\"0.999999999996362\",\"0.999999999998181\",\"0.999999999999091\",\"0.999999999999545\",\"0.999999999999773\",\"0.999999999999886\",\"0.999999999999943\",\"0.999999999999972\",\"0.999999999999986\",\"0.999999999999993\",\"0.999999999999996\",\"0.999999999999998\",\"0.999999999999999\",1,1,1,1,1,1,1,1,1,1,1,1,1,1]","err":"","code":"$x = 0; [ map {; $x += 1/(2**$_); $x } 1..64 ]\n"},{"code":"$x = 0; [ map {; $x += 1/(2**$_); $x } 1..8 ]\n","err":"","out":"[\"0.5\",\"0.75\",\"0.875\",\"0.9375\",\"0.96875\",\"0.984375\",\"0.9921875\",\"0.99609375\"]"},{"err":"","code":"$x = 0; [ map {; $x += 1/(2**$_); $x =~ /\\.(9*)/ ? length($1) : -1 } 1..64 ]\n","out":"[0,0,0,1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,5,6,6,6,6,7,7,7,8,8,8,9,9,9,9,10,10,10,11,11,11,12,12,12,12,13,13,13,14,14,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]"},{"out":"","code":"$x = [ 0 ]; $x->[0][2]\n","err":""},{"out":"[undef]","err":"","code":"'x' =~ /./; [$1]\n"},{"err":"","code":"[ %x{1} ]\n","out":"[1,undef]"},{"code":"[x=>~~-1]\n","err":"","out":"[\"x\",'18446744073709551615']"},{"code":"$x[-1]\n","err":"","out":""},{"code":"/x{10}/\n","err":"","out":""},{"err":"","code":"\"x\"=~/\\{10}/;\n","out":""},{"out":"ÃÂÃÂ","err":"","code":"\"\\x{100}\"\n"},{"out":"10","code":"$x = '10.12'; $x =~ s/\\..+$//; $x\n","err":""},{"err":"","code":"\"\\x{10c}\\x{e1}ste\\x{10d}n\\x{11b} schv\\x{e1}leno\"\n","out":"ÃÂÃÂÃÂÃÂ¡steÃÂÃÂnÃÂÃÂ schvÃÂÃÂ¡leno"},{"out":"","code":"$x[10e10]++\n","err":"Out of memory!\n"},{"code":"[ ('?') x 10 ] # magic ()\n","err":"","out":"[\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\"]"},{"out":"[\"??????????\"]","code":"[ ('?' x 10) ] # the () do nothing\n","err":""},{"out":"[9,8,7,6,5,4,3,2,1,0]","code":"$x = 10; while ( $x --> 0 ) { push @arr, $x } \\@arr\n","err":""},{"out":"ERROR: Can't modify constant item in scalar assignment at (eval 1) line 1, at EOF\n","err":"","code":"x = 10 || (x > 20 && x < 30)\n"},{"err":"","code":"$x = 10; $y = 9; [ [$x, $y], $x <= $y, [$x, $y]->[\"\"] ]\n","out":"[[10,9],\"\",10]"},{"out":"[[10,9],\"\",10]","err":"","code":"$x = 10; $y = 9; [ [$x, $y], $x <= $y, [$x, $y]->[$x <= $y] ]\n"},{"err":"","code":"@x=(11,12,13); grep { s/1/9/ } @x; \\@x\n","out":"[91,92,93]"},{"out":"1-1+2-2+3-3+4-4","err":"","code":"$x = '11223344'; join( '+', map {  join('-', map { $_  } split //) } $x =~/../g);\n"},{"out":"${\\1+1}","err":"","code":"$x='${\\1+1}'; eval qq{ \"\\Q$x\\E\" }\n"},{"code":"@x = (12, 13); sprintf '%d %d', @x\n","err":"","out":"12 13"},{"out":"[undef,undef,1]","code":"@x = (1, 2, 1); delete @x[@x]; \\@x\n","err":""},{"code":"@x = (1, 2, 3,4 ,5 , 6, 7, 8); foreach my $x (@x[0..2]) { print $x; }\n","err":"","out":"123"},{"code":"@x = (1, 2, 3,4 ,5 , 6, 7, 8); @x[0..2];\n","err":"","out":"3"},{"out":"5","code":"@x=([[1,2],[3,4]],[5]); $x[1][0]\n","err":""},{"err":"","code":"@x=([[1,2],[3,4]],[5]); $x[1][1]\n","out":""},{"code":"@x=([[1,2],[3,4]],[5]); $x[1][2]\n","err":"","out":""},{"err":"","code":"@x=(1,2,3,4,5); [$x[-20], \\@x]\n","out":"[undef,[1,2,3,4,5]]"},{"code":"@x=(1,2,3,4); scalar @x\n","err":"","out":"4"},{"out":"5","code":"$x = (1, (2, 3), 5);\n","err":""},{"out":"$VAR1 = [\n          [\n            1,\n            2,\n            3\n          ],\n          $VAR1->[0]\n        ];\n","err":"","code":"$x = [1,2,3]; Data::Dumper::Dumper([$x, $x])\n"},{"out":"[undef,2]","code":"@x=(1,2,3); delete @x[0,2]; \\@x\n","err":""},{"code":"@x=(1,2,3); delete $x[1];\n","err":"","out":"2"},{"code":"@x=(1,2,3); delete @x[1,2]; \\@x\n","err":"","out":"[1]"},{"out":"[1,undef,3]","code":"@x=(1,2,3); delete @x[1]; \\@x\n","err":""},{"err":"","code":"@x=(1,2,3); delete $x[1]; \\@x\n","out":"[1,undef,3]"},{"err":"","code":"$x = '1.23'; $x =~ s/\\D+//g; $x\n","out":"123"},{"code":"$x = () = (1,2,4); print($x)\n","err":"","out":"3"},{"out":"12","code":"$x = 12; { ++local($x) } $x\n","err":""},{"out":"[{x => 12},{x => 13},{x => 14}]","err":"","code":"[{x => 12}, {x => 13}, {x => 14}]\n"},{"out":", 0x1]","err":"","code":"$x = \"1   2\"; @y = split(' ', $x); print \"$x[0], $[x1]\";\n"},{"out":"1, 2","code":"$x = \"1   2\"; @y = split(' ', $x); print \"$y[0], $y[1]\";\n","err":""},{"out":"3\n","err":"","code":"@x = (1..547); say length @x\n"},{"out":"547\n","err":"","code":"@x = (1..547); say scalar @x\n"},{"out":"6","err":"","code":"@x = 1 .. 6; scalar @x\n"},{"err":"","code":"@x = (1 .. 8); print @x[0..2];\n","out":"123"},{"out":"0000000000000000","err":"","code":"$_=\"\\x19\"; $_=\"$_\\x00\"; print unpack \"B*\", $_&\"\\x80\\x00\"\n"},{"out":"yes","code":"$_=\"\\x19\"; $_=\"$_\\x00\"; print \"yes\" if $_&\"\\x80\\x00\"\n","err":""},{"out":"ÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ¨","err":"","code":"\"\\x{1f441}\\x{200d}\\x{1f5e8}\"\n"},{"code":"\"\\x{1F478}\\x{200D}\\x{2764}\\x{FE0F}\\x{200D}\\x{1F48B}\\x{200D}\\x{1F438}\"\n","err":"","out":"ÃÂ°ÃÂÃÂÃÂ¸ÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂ¤ÃÂ¯ÃÂ¸ÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ¸"},{"code":"\"\\x{1F64C}\"\n","err":"","out":"ÃÂ°ÃÂÃÂÃÂ"},{"code":"$x = 1; sub { @_[0] = 2; }->($x); print $x\n","err":"","out":"2"},{"out":"1431655765","err":"","code":"$x =1; $x *= (2**2**$_ + 1) for 1 .. 4; $x\n"},{"out":"3628800","err":"","code":"$x=1; $x *= $_ for 2..10; $x\n"},{"out":"2","err":"","code":"$x=1; $x = \\$x; $$x=2; $x\n"},{"out":"2015-02-23","code":"$x = \"2015-0223\"; substr($x,7,0) = \"-\"; $x\n","err":""},{"err":"","code":"$x = 20; [ ++$x, $x++, $x ] # wheeee\n","out":"[22,21,22]"},{"out":"[2]","code":"@x = (2, 1, 2); delete @x[@dup = @x]; \\ @x # this one is right\n","err":""},{"code":"@x = (2, 1, 2); delete @x[@x]; \\ @x # right\n","err":"","out":"[]"},{"out":"[]","err":"","code":"@x = (2, 1, 2); delete @x[@x]; \\ @x # wrong!\n"},{"out":"x21\\x21","err":"","code":"'\\x21\\x21' =~ s/(.)/qq(\"$1\")/eer\n"},{"code":"'\\x21\\x21' =~ s/(.*)/qq(\"$1\")/eer\n","err":"","out":"!!"},{"code":"'\\x22\\x22' =~ s/(.*)/qq(\"$1\")/eer\n","err":"","out":"\"\""},{"code":"\"\\x{22}\\x{31}\"\n","err":"","out":"\"1"},{"code":"@{ $x->[2] } = (4, 5); $x\n","err":"","out":"[undef,undef,[4,5]]"},{"err":"","code":"[\"\\x27\"]\n","out":"[\"'\"]"},{"code":"($x = 2903000)/($y = 2903000)*100\n","err":"","out":"100"},{"out":"\\\"2+@","code":"$x='\\\"2+@'; eval qq{ \"\\Q$x\\E\" }\n","err":""},{"out":"/vi","code":"'\\x2F\\x76\\x69' =~ s/\\\\x([[:xdigit:]]{1,2})/chr hex $1/ger\n","err":""},{"out":"[0,1,2,3]","code":"$x[3] = 123; [keys @x]\n","err":""},{"out":"3","err":"","code":"@x = 31 .. 33; scalar @x\n"},{"out":"75","err":"","code":"$x = \"32 string\"; $y = 43; $x + $y\n"},{"err":"","code":"@x = (3, 4); print scalar @x\n","out":"2"},{"out":"4","err":"","code":"@x = (3, 4); print scalar @x[0,1];\n"},{"out":"$x == 3 is true","code":"$x = 3; $cond = '$x == 3'; print \"$cond is true\" if (eval $cond) # still, though -- ugh\n","err":""},{"err":"","code":"('?') x 4\n","out":"????"},{"code":"[ ('?') x 4 ]\n","err":"","out":"[\"?\",\"?\",\"?\",\"?\"]"},{"out":"[\"????\"]","code":"[ ('?'x4) ]\n","err":""},{"code":"'\\x40\\x40' =~ s/(.*)/qq(\"$1\")/eer\n","err":"","out":"@@"},{"out":"\\x41\\x41","code":"'\\x41\\x41'\n","err":""},{"out":"AA","code":"'\\x41\\x41' =~ s/(.*)/qq(\"$1\")/eer  # /me ducks\n","err":""},{"out":"AA","err":"","code":"'\\x41\\x41' =~ s/\\\\x([0-9a-fA-F]{2})/pack 'H*', $1/rge;\n"},{"out":"AA","err":"","code":"'\\x41\\x41' =~ s/\\\\x(\\d\\d)/chr hex $1/rge;\n"},{"out":"ERROR: Can't modify constant item in substitution (s///) at (eval 1) line 1, at EOF\n","err":"","code":"'\\x41\\x41' =~ s/\\\\x(\\d\\d)/hex $1/ge;\n"},{"err":"","code":"'\\x41\\x41' =~ s/\\\\x(\\d\\d)/pack 'H*', $1/rge;\n","out":"AA"},{"out":"@\u0000@\u0000","code":"'\\x41\\x41' =~ s/\\\\x(\\d\\d)/pack 'HH', $1/rge;\n","err":""},{"err":"","code":"'\\x41\\x41' =~ s/(\\\\x..)/'qq('.$1.')'/rgee;\n","out":"AA"},{"code":"'\\x41\\x41' =~ s/(\\\\x..)/qq(qq($1))/rgee;\n","err":"","out":"AA"},{"err":"","code":"'\\x41\\x41' =~ s((\\\\x..))(qq(qq($1)))rgee; # lisp-y?\n","out":"AA"},{"code":"$x = 42; $first3 = ($x & 56) >> 3; $last3 = $x & 7; [ $first3, $last3 ]\n","err":"","out":"[5,2]"},{"out":"42","code":"$x = 42; sub foo { $x += 23 } { local $x; foo() } $x\n","err":""},{"err":"","code":"$x = 42; $x /= 2; $x\n","out":"21"},{"code":"$x = 42; \"x is ${\\$x}, eh\"\n","err":"","out":"x is 42, eh"},{"out":"[37,\\37]","err":"","code":"$x = 42; $x_ref = \\$x; ${$x_ref} = 37; [ $x, $x_ref ]\n"},{"out":"[\\42,42]","err":"","code":"$x = 42; $x_ref = \\$x; [ $x_ref, ${ $x_ref } ]\n"},{"code":"$x=[4,5,6]; @$x[0]\n","err":"","out":"4"},{"out":"4","err":"","code":"$x=[4,5,6]; $$x[0]\n"},{"out":"5","err":"","code":"$x = [4, 5, 6]; @$x[0, 1]\n"},{"out":"4","err":"","code":"$x = 4; $x //= 3;\n"},{"err":"","code":"(' ') x 5\n","out":"     "},{"code":"[ \" \" x 5 ]\n","err":"","out":"[\"     \"]"},{"code":"[ (' ') x 5 ]\n","err":"","out":"[\" \",\" \",\" \",\" \",\" \"]"},{"out":"[\" \",\" \",\" \",\" \",\" \"]","err":"","code":"[ (\" \") x 5 ]\n"},{"out":"[\"_ _ _ _ _ \"]","code":"[\"_ \" x 5]\n","err":""},{"err":"","code":"[(\" \") x 5]\n","out":"[\" \",\" \",\" \",\" \",\" \"]"},{"out":"[\"_ \",\"_ \",\"_ \",\"_ \",\"_ \"]","err":"","code":"[(\"_ \") x 5]\n"},{"code":"[\"#\" x 50 . \"\\n\"]\n","err":"","out":"[\"##################################################\\n\"]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"50.\"\\n\"\"\n","err":"","code":"[\"#\"x50.\"\\n\"]\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"] [\"\n","code":"[(\"_ \") x 5] [16:44] <perlbot> Altreus: [\"_ \",\"_ \",\"_ \",\"_ \",\"_ \"]\n","err":""},{"err":"","code":"$x=5; qq'$x'\n","out":"5"},{"err":"","code":"$x = 6.7233 * 1.22345;\n","out":"8.225621385"},{"out":"[\"8.225621\",\"\"]","code":"$x = 6.7233 * 1.22345; [ sprintf(\"%f\", $x), unpack(\"H*\",$f) ]\n","err":""},{"code":"$x = 9; $y = 10; [ [$x, $y], $x <= $y, [$x, $y]->[1] ]\n","err":"","out":"[[9,10],1,10]"},{"code":"$x={'{a}'=2}; $x->{{a}};\n","err":"","out":"ERROR: Can't modify constant item in scalar assignment at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, near \"{{\"\n"},{"code":"%x = (a => 3, b => 4); print scalar %x\n","err":"","out":"2/8"},{"err":"","code":"%x = (a => 3, b => 4); print scalar @x{'a','b'}\n","out":"4"},{"err":"","code":"%x = ( 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'); my @sortedkeys = sort(keys(%x)); my $highestkey = $sortedkeys[-1]; print $highestkey;\n","out":"d"},{"out":"9","err":"","code":"%x = ( 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'); my @sortedkeys = sort(values(%x)); my $highestkey = $sortedkeys[-1]; print $highestkey;\n"},{"out":"abcd","err":"","code":"%x = ( 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'); print sort { $a cmp $b } keys %x;\n"},{"code":"%x = { 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'}; print $x{'c'};\n","err":"","out":"1"},{"out":"ERROR: Unknown regexp modifier \"/3\" at (eval 1) line 1, near \"=~ \"\n","err":"","code":"$x = \"a a a a a a\"; $x =~ s/a/x/3;print $x\n"},{"code":"$x = () = 'Ã¥' =~ /[Ã¥Ã¤]/g\n","err":"","out":"2"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","err":"","code":"$x=\"aa\";++;print ++$x\n"},{"out":"ac","err":"","code":"$x=\"aa\";++$x;print ++$x\n"},{"out":"ERROR: Can't modify constant item in scalar assignment at (eval 1) line 1, at EOF\n","err":"","code":"$x = { 'a.b' = 'c' }\n"},{"out":"abCDEFG","code":"$x = 'abcdefg'; substr($x, 2) =~ y/a-z/A-Z/; $x\n","err":""},{"out":"abcdefghi","code":"$x = \"abcdfghi\"; substr($x, 4, 0, 'e'); $x\n","err":""},{"out":"abcdefghi","code":"$x=\"abcdfghi\"; $x=~s/(abcd).*(fghi)/$1e$2/g; print $x;\n","err":""},{"code":"$x=\"abcd\"; push @{$x{j}}, split(//,$x); print join(\"\", @{$x{j}}[2,3]), \"\\n\"\n","err":"","out":"cd\n"},{"err":"","code":"$x=\"abcd\"; push @{$x{j}}, split(//,$x); print join(\"\", @{$x{j}}[2..3]), \"\\n\"\n","out":"cd\n"},{"err":"","code":"$x->{abc} #so it might\n","out":""},{"code":"$x->{abc}; $x\n","err":"","out":"{}"},{"err":"","code":"@x = 'a' .. 'c'; sub lala { my ($aref) = @_; \"@$aref\" } lala \\@x\n","out":"a b c"},{"out":"1","err":"","code":"%x=(a=>undef); exists $x{a}\n"},{"err":"","code":"$x = { a => 'value', b => $x->{a} }; $x\n","out":"{b => undef,a => \"value\"}"},{"code":"$x->{a}; $x\n","err":"","out":"{}"},{"err":"cannot handle ref type 10 at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/x86_64-linux/Data/Dumper.pm line 233, <STDIN> line 1.\n","code":"$x = \"banana\"; \\substr($x, 2)\n","out":""},{"out":"ARRYY(0xDEADBEEF)","err":"","code":"$x = bless [], 'ARRYY(0xDEADBEEF)'; ref $x\n"},{"code":"$x = bless {}, \"Banana\"; [$x, $x =~ /t/]\n","err":"","out":"[bless( {}, 'Banana' )]"},{"err":"","code":"$x = []; bless $x, $x; ref $x\n","out":"ERROR: Attempt to bless into a reference at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"\"\\x^C\"\n","err":"","out":"\u0000^C"},{"err":"","code":"\"\\xc6\"\n","out":"ÃÂ"},{"code":"[\"\\x{cf}\", \"\\xcf\" ]\n","err":"","out":"[\"\\317\",\"\\317\"]"},{"code":"$x = chr(0xC6); Encode::encode_utf8($x)\n","err":"","out":"ÃÂÃÂ"},{"out":"c386","code":"$x = chr(0xC6); unpack \"H*\", Encode::encode_utf8($x)\n","err":""},{"out":"[\"\\x{0}\",\"\\317\"]","code":"$x = chr 0xcf; $y = chr 0xcf; Encode::_utf8_on($x); Encode::_utf8_off($y); [$x, $y]\n","err":"Malformed UTF-8 character (1 byte, need 2, after start byte 0xcf) in subroutine entry at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/x86_64-linux/Data/Dumper.pm line 233, <STDIN> line 1.\nMalformed UTF-8 character (1 byte, need 2, after start byte 0xcf) in subroutine entry at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/x86_64-linux/Data/Dumper.pm line 233, <STDIN> line 1.\n"},{"err":"","code":"\"\\xd1\"\n","out":"ÃÂ"},{"code":"$x=\"@\" . \"{[ die 'horribly' ]}\"; eval qq{ \"\\Q$x\\E\" }\n","err":"","out":"@{[ die 'horribly' ]}"},{"out":"ERROR: horribly at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"$x=\"@{[ die 'horribly' ]}\"; eval qq{ \"\\Q$x\\E\" }\n"},{"err":"","code":"@x=([],{},$\",\\&f,\\0);s/..(..).*/$1/ for@x;$\"=\"\";\"@x\"\n","out":"RASH DEAL"},{"out":"RASH DEAL","code":"$\"=\"\";@x=([],{},\" \",\\&f,\\0);s/..(..).*/$1/ for@x;\"@x\"\n","err":""},{"out":"ÃÂ°ÃÂÃÂÃÂ","code":"\"\\xF0\\x9F\\x99\\x8C\"\n","err":""},{"out":"ÃÂ´","err":"","code":"\"\\x{f4}\"\n"},{"out":"ÃÂ¶","err":"","code":"\"\\xf6\"\n"},{"err":"","code":"\"\\xFE\\xAB\"\n","out":"ÃÂ¾ÃÂ«"},{"out":"ÃÂ¿","err":"","code":"\"\\xff\"\n"},{"out":"1","err":"","code":"@x = (foo => 1, bar => 2); print ${{@x}}{\"foo\"}\n"},{"err":"","code":"@x = (foo => 1, bar => 2); ${{@x}}{\"foo\"}\n","out":"1"},{"out":"1","err":"","code":"@x = ( {foo => 1} ); $x[0]->{foo}\n"},{"out":"","err":"","code":"@x = (foo => 3, bar => 4); ${{[a=>2, b=>3]}}{\"foo\"}\n"},{"code":"@x = (foo => 3, bar => 4); ${[foo=>2, bar=>3]}{\"foo\"}\n","err":"","out":"ERROR: Not a HASH reference at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"@x = (foo => 3, bar => 4); ${{[foo=>2, bar=>3]}}{\"foo\"}\n","out":""},{"err":"","code":"@x = (foo => 3, bar => 4); ${{@x}}{\"foo\"}\n","out":"3"},{"out":"1","code":"$x = \\@Foo::bar; delete $Foo::{bar}; @$x = \"meow\";\n","err":""},{"out":"fooval","err":"","code":"@x = (foo => \"fooval\", bar => \"barval\"); print +{@x}->{\"foo\"}\n"},{"out":"1","code":"$x = \\@{\"Foo::ISA\"}; delete $Foo::{ISA}; @$x = \"Bar\"\n","err":""},{"out":"[\"foo\",1]","code":"$x=\"foo\\n\"; [ $x, chomp $x ];\n","err":""},{"err":"","code":"$x=\"foo\\n\"; [ $x, chomp $x, $x ];\n","out":"[\"foo\",1,\"foo\"]"},{"out":"1","err":"","code":"$x{foo}++, $x{foo}\n"},{"err":"","code":"$x = \"foo\"; [ $x, $x =~ s/foo/bar/r ]\n","out":"[\"foo\",\"bar\"]"},{"out":"{b => 1,c => 1,a => 1}","err":"","code":"$x{$_}++ for qw[a b c]; \\%x\n"},{"code":"@x = grep /[^\\Wt]/, qw<q w t 6 ! . X>; [@x]\n","err":"","out":"[\"q\",\"w\",6,\"X\"]"},{"err":"","code":"@x = 'hello'; my @y = $x[@x] = 'world'; [ \\@y, \\@x ]\n","out":"[[\"world\"],[\"hello\",\"world\"]]"},{"err":"","code":"[ ('?'x@ids) ]\n","out":"[\"\"]"},{"err":"","code":"$x = { key => 'value' }, push @{$x->{foo}}, 'bar'; push @{$x->{foo}}, 'baz'; $x\n","out":"{key => \"value\",foo => [\"bar\",\"baz\"]}"},{"code":"$x = \"lala\"; *$x = \"cat\"; $lala\n","err":"","out":""},{"code":"$x = \"lala\"; *$x = \\\"cat\"; $lala\n","err":"","out":"cat"},{"code":"$x = \"lala\"; *$x = sub {2*3}; lala();\n","err":"","out":"6"},{"code":"$x = 'loooong'; substr($x, 4, 0) = 'XX'; # substr is an lvalue\n","err":"","out":"XX"},{"out":"loooXXong","err":"","code":"$x = 'loooong'; substr($x, 4, 0) = 'XX'; $x ; # substr is an lvalue\n"},{"out":"[*::X,*::X,*::X,*::X]","err":"","code":"[*::X, *main::X, *::main::X, *main::main::main::main::X]\n"},{"code":"@x = ( map ord, split //, 64.64.64.5000000000.64.64.64 );  $x = join \",\", @x;  print \"$x\\n\"\n","err":"","out":"64,64,64,5000000000,64,64,64\n"},{"out":"[\"\"]","err":"","code":"$x = \"\\n\"; chomp $x; [$x]\n"},{"code":"[ \"x\\n   \\t \\t   \\n \\n\\n\\n\\n\\n\\n\\ny\" =~ /^(.*)\\s*$/gm ]\n","err":"","out":"[\"x\",\"\",\"y\"]"},{"err":"","code":"[ \"x\\n   \\t \\t   \\n \\n\\n\\n\\n\\n\\n\\ny\" =~ /^\\s*(.*)$/gm ] # like this?\n","out":"[\"x\",\"y\"]"},{"code":"[ \"x\\n   \\t \\t   \\n \\n\\n\\n\\n\\n\\n\\ny\" =~ /^\\s*(.*)\\s*$/gm ] # so perhaps you wanted \\h instead of \\s?\n","err":"","out":"[\"x\",\"y\"]"},{"code":"$x = \"(??{print 42})\"; \"banana\" =~ /$x/\n","err":"","out":"ERROR: Eval-group not allowed at runtime, use re 'eval' in regex m/(??{print 42})/ at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"qr/^cats$/u","err":"","code":"$x = qr/^cats$/\n"},{"out":"[qr/lala/u,qr/lala/u]","err":"","code":"$x = qr/lala/; $xx = qr/$x/; [$x, $xx]\n"},{"out":"1","code":"$x = qr/something/; \"that's something\" =~ $x\n","err":""},{"code":"\"X\\\\Q(s)Y\" =~ qr'\\Q(s)' ? [$`, $&, $'] : \"no\"\n","err":"","out":"no"},{"err":"","code":"\"X\\\\QsY\" =~ qr'\\Q(s)' ? [$`, $&, $'] : \"no\"\n","out":"[\"X\\\\\",\"Qs\",\"Y\"]"},{"out":"b c a","code":"@x=qw(a b c); push @x, shift @x; \"@x\"\n","err":""},{"out":"3","code":"@x=qw(a b c); push @x, shift @x; @x\n","err":""},{"out":"[5,\"b\",\"c\"]","err":"","code":"@x=qw(a b c); sub z{$_[0]=5;} z(@x); \\@x\n"},{"err":"","code":"@x=qw(a b c); unshift @x, pop @x; \"@x\"\n","out":"c a b"},{"code":"@x{qw{a b c}}++; \\%x\n","err":"","out":"{b => undef,c => 1,a => undef}"},{"out":"[3,\"a\"]","err":"","code":"@x=qw(a b c); $x=@x;($y)=@x;[$x,$y]\n"},{"out":"bc","err":"","code":"@x=qw/a b c/; $z=[@x[0,1]]; for(@$z){$_++; print} \\@x\n"},{"out":"[\"a\",\"b\",\"c\"]","err":"","code":"@x=qw/a b c/; $z=[@x[0,1]]; for(@$z){$_++} \\@x\n"},{"out":"3","code":"@x=qw( a b ); print push @x, 'c'\n","err":""},{"out":"{baz => undef,bar => undef,foo => undef}","code":"@x{qw/foo bar baz/}=(); \\%x\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"})\"\n","err":"","code":"@x{qw/foo bar baz/})=(); \\%x\n"},{"err":"","code":"$x = { site => 'lol' }; $y = \"foo\";  \"lefoobar\" =~ s/$y/$x->{site}/r\n","out":"lelolbar"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"} $x\"\n","err":"","code":"$x = sub { 3 } $x->() + 1\n"},{"out":"4","code":"$x = sub { 3 }; $x->() + 1\n","err":""},{"err":"","code":"$x = [ sub { 'here ' . shift } ]; $x->[0]->('we go')\n","out":"here we go"},{"out":"RA SH   DE AL","err":"","code":"@x=([],{},\" \",sub{},\\\"\");map{s/..(..).*/$1/}@x;\"@x\"\n"},{"err":"","code":"$\"=\"\";@x=([],{},\" \",sub{},\\\"\");map{s/..(..).*/$1/}@x;\"@x\"\n","out":"RASH DEAL"},{"out":"RASH DEAL","err":"","code":"$\"=\"\";@x=([],{},\" \",sub{},\\\"\");s/..(..).*/$1/ for@x;\"@x\"\n"},{"out":"foo625","code":"$x = 'text25more text25fdsdf'; $x =~ s/text(\\d+)more text(\\1)fdsdf/'foo' . ($1 * $1)/e; $x\n","err":""},{"err":"","code":"' ' =~ /[ ]/x ? 'T' : 'F';\n","out":"T"},{"code":"%x = (this => {0..3}, that => {'a'..'d'}); \\%x;\n","err":"","out":"{that => {c => \"d\",a => \"b\"},this => {0 => 1,2 => 3}}"},{"err":"","code":"@x = \"This\" =~ s/(.)/sprintf \"%b \", ord $1/gre; [@x]\n","out":"[\"1010100 1101000 1101001 1110011 \"]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"] is it \"\n","err":"","code":"@x = \"This\" =~ s/(.)/sprintf \"%b \", ord $1/gre; [@x] is it a command ?\n"},{"code":"$x = 'three'; $y = \\$x; $x = \\$x; [ $x, $y ]\n","err":"","out":"[\\$VAR1->[0],$VAR1->[0]]"},{"out":"3","err":"","code":"$x = undef; $x //= 3;\n"},{"out":"","err":"","code":"@x[$wa = wantarray]; $wa\n"},{"out":"[0,1]","err":"","code":"[ $x++, $x ]\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"} [\"\n","err":"","code":"$x = {} [ \"$x\", 0+$x ]\n"},{"out":"[12,13,14]","code":"@x = $x || (12, 13, 14); \\ @x\n","err":""},{"err":"","code":" @x = \"\\x{2019}\"; push @x, ($x[0] =~ s/\\x{2019}/'/r); [@x]\n","out":"[\"\\x{2019}\",\"'\"]"},{"out":"[\"xxxxx\"]","err":"","code":"[ 'x' x 5 ]\n"},{"err":"","code":"$x = \"\\x65\\x66\\x67\";\n","out":"efg"},{"err":"","code":"$x = \"\\x65\\x66\\x67\"; eval \"qq($x)\" # not recommended\n","out":"efg"},{"out":"C","code":"@x = \"xAyxByxCy\" =~ /x(.)y/g; $1 # last capture, not first\n","err":""},{"out":"[]","code":"[ 'XX' =~ /((?i)x)x/ ]\n","err":""},{"code":"\"xx: m:q\" =~ /(^[a-z367]*?: |\\s|^)(?:m|mixer):(\\S+)/; [$1, $2]\n","err":"","out":"[\"xx: \",\"q\"]"},{"err":"","code":"'xxS01E32yy' =~ s/S01E([0-9][0-9])/\"S01E\" . ($1*2) . \"E\" . ($1*2 + 1)/er\n","out":"xxS01E64E65yy"},{"out":"xx1yy","err":"","code":"'xxS01E32yy' =~ s/S01E([0-9][0-9])/\"S01E\" . $1*2 . \"E\" . $1*2 + 1/er\n"},{"err":"","code":"[ ++$x . '', ++$x . '', ++$x . '' ]\n","out":"[1,2,3]"},{"out":"[3,3,3]","err":"","code":"[ ++$x, ++$x, ++$x ]\n"},{"err":"","code":"[$x++, $x++, $x++]\n","out":"[0,1,2]"},{"err":"","code":"\"xxx\" + 5\n","out":"5"},{"out":"\u0000<\u0000-\f\u0000t\u0000r\f","code":"\"\\x<\\x-\\xc\\xt\\xr\\xc\"\n","err":""},{"out":"1","err":"","code":"{ \"XXX\" =~ /(.*)/; } print $1\n"},{"out":"X!xX!x!X!","code":"$_ = \"x!xx!x!x!\"; my $state = 0; s/(\\w)/++$state % 2 ? (uc $1) : (lc $1)/ge; $_\n","err":""},{"err":"","code":"\"x x xx xxx xxxxx\\n\" =~ /^\\s*(?:((?(1)(?(3)(?(2)\\2|\\3)(\\1)|(\\S))|\\S))\\s+)+$/ ? \"\\\\o/\" : \":-(\"\n","out":"\\o/"},{"out":"ERROR: Missing braces on \\o{} at (eval 1) line 1, within string\n","code":"\"x x xx xxx xxxxx\\n\" =~ /^\\s*(?:((?(1)(?(3)(?(2)\\2|\\3)(\\1)|(\\S))|\\S))\\s+)+$/ ? \"\\o/\" : \":-(\"\n","err":""},{"err":"","code":"\"x x xx xxx xxxxx xxxxxxxx\\n\" =~ /^\\s*(?:((?(1)(?(3)(?(2)\\2|\\3)(\\1)|(\\S))|\\S))\\s+)+$/ ? \"a fibonacci sequence\" : \"bzzt\"\n","out":"a fibonacci sequence"},{"out":"3","code":"$x = 'XYZ XYZ XYZ'; $y =()= $x =~ /XYZ/g; $y\n","err":""},{"out":"\\undef","err":"","code":"\\$x = \\$y\n"},{"out":"[\"\"]","code":"'x' =~ /(y?)/; [$1]\n","err":""},{"out":"[undef]","err":"","code":"'x' =~ /(y)?/; [$1]\n"},{"out":"[5,6]","err":"","code":"[ ($x, $y) = 5 .. 10 ]\n"},{"out":"[\"ab\",\"c\"]","code":"($x, $y) = 'abc' =~ /(..)(.)/; [$1, $2] # $1, $2 are populated even when storing the values elsewhere\n","err":""},{"out":"4","code":"($x, $y) = qw(a b c d)\n","err":""},{"out":"[\"z\"]","code":"$x=\"y\"; [ ++$x ]\n","err":""},{"err":"","code":"%x = { \"y\" => \"z\" }; $x{\"hey\"} += 5; print $x{\"hey\"};\n","out":"5"},{"code":"[ 'xyzzy' =~ /(\\w)\\g{1}/ ]\n","err":"","out":"[\"z\"]"},{"out":"1","err":"","code":"'xZx' =~ m'Z'\n"},{"out":"1","code":"'xZx' =~ m\"Z\"\n","err":""},{"code":"$x=\"z\"; $x++; $x\n","err":"","out":"aa"},{"out":"aaaa","err":"","code":"$x = 'zzz'; $x++; $x\n"},{"err":"","code":"@y = (1, 2, 3); \\ @y\n","out":"[1,2,3]"},{"out":"[1]","code":"@y = 1, 2, 3; \\ @y\n","err":""},{"code":"$y=1; *x = (sub { \\@_ })->($y); $x[0] = 2; print \"$y\\n\";\n","err":"","out":"2\n"},{"out":"yÃÂs","err":"","code":"$_ = \"yes\" ; y/e/Ã©/; $_\n"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"$_ = \"yes\" ; y/e/Ã©//; $_\n","err":""},{"out":"1","err":"","code":"$y=\"one\"; $z = undef; $y = $z || ''; print $z;\n"},{"code":"$y=\"one\"; $z = undef; $y = $z || undef; print $z;\n","err":"","out":"1"},{"err":"","code":"\\\"you\"\n","out":"\\\"you\""},{"out":"ERROR: \"use\" not allowed in expression at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 2, near \"you can use sprintf\n\"\n","err":"","code":"you can use sprintf\n"},{"err":"","code":"your code\n","out":"ERROR: Can't locate object method \"your\" via package \"code\" (perhaps you forgot to load \"code\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Global symbol \"$x\" requires explicit package name (did you forget to declare \"my $x\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"$y; { use strict; $x }\n"},{"err":"","code":"$z=new IO::Handle; \"$z\"\n","out":"IO::Handle=GLOB(0x3c89ef0)"},{"err":"","code":"[ \"Zoffix doubts that map example works\" =~ /(?=(..))/sg ]\n","out":"[\"Zo\",\"of\",\"ff\",\"fi\",\"ix\",\"x \",\" d\",\"do\",\"ou\",\"ub\",\"bt\",\"ts\",\"s \",\" t\",\"th\",\"ha\",\"at\",\"t \",\" m\",\"ma\",\"ap\",\"p \",\" e\",\"ex\",\"xa\",\"am\",\"mp\",\"pl\",\"le\",\"e \",\" w\",\"wo\",\"or\",\"rk\",\"ks\"]"},{"err":"","code":"'zoom' =~ m moom\n","out":"1"},{"out":"[\"\\316\\221RR\\316\\221\\316\\245\"]","err":"","code":"[ \"ÎRRÎÎ¥\" ]\n"},{"code":"[ 'Î©' cmp 'Î' ]\n","err":"","out":"[1]"},{"out":"ÃÂÃÂ¯ ÃÂÃÂ¾ÃÂÃÂÃÂÃÂµÃÂÃÂ½ÃÂÃÂ ÃÂÃÂ¿ÃÂÃÂ»ÃÂÃÂ¾ÃÂÃÂÃÂÃÂ¾ ÃÂÃÂ³ÃÂÃÂ¾ÃÂÃÂ²ÃÂÃÂ¾ÃÂÃÂÃÂÃÂ ÃÂÃÂ¿ÃÂÃÂ¾ ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂºÃÂÃÂ¸ÃÂÃÂ¹","code":"\"Ð¯ Ð¾ÑÐµÐ½Ñ Ð¿Ð»Ð¾ÑÐ¾ Ð³Ð¾Ð²Ð¾ÑÑ Ð¿Ð¾ ÑÑÑÑÐºÐ¸Ð¹\"\n","err":""}],"evals/evals-magnet-#perl.lst":[{"out":"1","err":"","code":"$.\n"},{"err":"","code":"0 && 1\n","out":"0"},{"out":"{\"02\" => [\"Maria\"]}","code":"$_ = '02 Maria';  my ( $n, $name ) = split ' '; my %h; push @{ $h{ $n } }, $name; \\%h\n","err":""},{"out":"[0,3,1,2]","code":"[0b00, 0b11, 0b01, 0b10]\n","err":""},{"code":"0 && print \"foo\"\n","err":"","out":"0"},{"out":"[1]","code":"[1]\n","err":""},{"out":"1e+20","err":"","code":"10**20\n"},{"err":"","code":"1 + 1\n","out":"2"},{"err":"","code":"11+16\n","out":"27"},{"out":"5676","code":"12*473\n","err":""},{"out":"1496.25","code":"1995 * .75\n","err":""},{"code":"@_=(1); [ defined(1), defined(shift) ]\n","err":"","out":"[1,\"\"]"},{"out":"NaN","code":"1+nan\n","err":""},{"err":"","code":"@_ = (1); print 'YES' if( shift == undef )\n","out":"YES"},{"err":"","code":" 2 * @\n","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"err":"","code":" 2 * 2\n","out":"4"},{"err":"","code":"220/8*4/60\n","out":"1.83333333333333"},{"out":"8","err":"","code":"2 ** 3\n"},{"out":"46340.9000237371","code":"(2**32)/92682\n","err":""},{"err":"","code":"[ 2.5 * 6 ];\n","out":"[15]"},{"err":"","code":"2 == ('a','b')\n","out":""},{"code":"2 == @{['a','b']}\n","err":"","out":"1"},{"code":"(3/2)*(3/2)*(19/16)*(271/512)\n","err":"","out":"1.41421508789062"},{"code":"34/26.81\n","err":"","out":"1.26818351361432"},{"code":"473*12*.04\n","err":"","out":"227.04"},{"out":"7568","code":"473*16\n","err":""},{"out":"6.2375","err":"","code":"499/80\n"},{"out":"0.375","err":"","code":"6/16\n"},{"code":" $_ = \"a[b]\"; [ \"a[b]\" =~ /$_/ ]\n","err":"","out":"[]"},{"out":"[1]","code":" $_ = \"a[b]\"; [ \"a[b]\" =~ /\\Q$_\\E/ ]\n","err":""},{"code":"@ARGV = \"hello\"; [ shift ]\n","err":"","out":"[\"hello\"]"},{"err":"","code":"a..z\n","out":""},{"err":"","code":"binmode STDOUT; $_ = \"Just another Perl/BIDI Hacker,\"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/; # does this show up right for everyone?\n","out":"Ã¢ÂÂ­JÃ¢ÂÂ®,Ã¢ÂÂ­uÃ¢ÂÂ®rÃ¢ÂÂ­sÃ¢ÂÂ®eÃ¢ÂÂ­tÃ¢ÂÂ®kÃ¢ÂÂ­ Ã¢ÂÂ®cÃ¢ÂÂ­aÃ¢ÂÂ®aÃ¢ÂÂ­nÃ¢ÂÂ®HÃ¢ÂÂ­oÃ¢ÂÂ® Ã¢ÂÂ­tÃ¢ÂÂ®IÃ¢ÂÂ­hÃ¢ÂÂ®DÃ¢ÂÂ­eÃ¢ÂÂ®IÃ¢ÂÂ­rÃ¢ÂÂ®BÃ¢ÂÂ­ Ã¢ÂÂ®/Ã¢ÂÂ­PÃ¢ÂÂ®lÃ¢ÂÂ­eÃ¢ÂÂ®r"},{"out":"Ã¯Â¼ÂµÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ£ÂÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ£ÂÂÃ¯Â½ÂÃ¯Â½ÂÃ£ÂÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼Â","err":"","code":"binmode STDOUT; 'Unicode can be confusing,' =~ tr[\\x20-\\x7f][\\x{3000}\\x{ff01}-\\x{ff5f}]r; # tr is better\n"},{"err":"","code":"binmode \\*STDOUT, ':utf8'; print v3232.95.3232\n","out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ "},{"out":"ERROR: Missing comma after first argument to binmode function at (eval 1) line 1, at EOF\n","code":"binmode STDOUT ':utf8'; print v3232.95.3232\n","err":""},{"out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ ","err":"","code":"binmode(STDOUT, ':utf8'); print v3232.95.3232\n"},{"err":"","code":"binmode \\*STDOUT, ':utf8'; say v3232.95.3232\n","out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ \n"},{"err":"","code":"binmode \\&STDOUT, ':utf8'; say v3232.95.3232\n","out":"ERROR: Not a GLOB reference at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"binmode STDOUT; v3232.95.3232\n","out":"Ã Â²Â _Ã Â²Â "},{"code":"do{...;\"abc\"} if 0;\n","err":"","out":"0"},{"out":"ERROR: Unimplemented at (eval 1) line 1, <STDIN> line 1.\n","code":"do{...;\"abc\"} if 1;\n","err":""},{"code":"'$equation'\n","err":"","out":"$equation"},{"out":"1","code":"'example@gmail.com' =~ m/[a-z0-9A-Z-_]+\\@[a-z0-9A-Z-_]+\\./\n","err":""},{"code":"\"fmekmftestdwadwad\" =~ m/test/i\n","err":"","out":"1"},{"err":"","code":"\"fmekmftestdwadwad\" =~ m/tesT/i\n","out":"1"},{"code":"\"fmekmftestdwadwad\" =~ /tesT/i # \"m\" is optional with standard / / delimiters\n","err":"","out":"1"},{"out":"fntty","err":"","code":"'fnnny' =~ s/nn(?!n)/tt/r\n"},{"code":"'foo'\n","err":"","out":"foo"},{"err":"","code":"'foo&amp;bar' =~ /&amp;/;\n","out":"1"},{"err":"","code":"'foo bar' =~ s/(foo) bar/$1 $1/r\n","out":"foo foo"},{"err":"","code":"'&foo' =~ /\\b&foo/;\n","out":""},{"code":"'&foo' =~ /&\\bfoo/;\n","err":"","out":"1"},{"code":"$_++ for map $_, qw(hobbs mst)\n","err":"","out":""},{"err":"","code":"for \\my @foo (['foo', 'foo'], ['foo', 'bar'], ['bar', 'foo'], ['bar', 'bar']) { my $correct = ($foo[0] ne 'foo' && $foo[1] ne 'foo');  my $x = !($foo[0] eq 'foo' && $foo[1] eq 'foo'); my $y = !($foo[0] eq 'foo' || $foo[1] eq 'foo');  print $correct == $x ? '' : 'x is wrong'; print $correct == $y ? '' : 'y is wrong'; }\n","out":"x is wrongx is wrong"},{"code":"@_ = \"hello\"; [ shift ]\n","err":"","out":"[undef]"},{"out":"$VAR1 = {\n          'argle' => {\n                       'blargle' => 'blop'\n                     },\n          'bar' => [\n                     'baz'\n                   ],\n          'foo' => 'bar'\n        };\n","code":"%h = (   foo => \"bar\",  bar => [ \"baz\" ],  argle => { \"blargle\" => \"blop\" } ); use Data::Dumper; print Dumper \\%h\n","err":""},{"out":"$VAR1 = 'argle';\n$VAR2 = {\n          'blargle' => 'blop'\n        };\n$VAR3 = 'bar';\n$VAR4 = [\n          'baz'\n        ];\n$VAR5 = 'foo';\n$VAR6 = 'bar';\n","err":"","code":"%h = (   foo => \"bar\",  bar => [ \"baz\" ],  argle => { \"blargle\" => \"blop\" } ); use Data::Dumper; print Dumper %h\n"},{"err":"","code":"index \"banana\", \"na\", -2\n","out":"2"},{"err":"","code":"join('','A'..'Z') =~ s/(.)/chr(ord($1)+1)/ger\n","out":"BCDEFGHIJKLMNOPQRSTUVWXYZ["},{"out":"STFU","code":"join\"\",map uc,map$_ eq\"i\"?\"u\":$_,(\"fist\"=~/./sg)[2,3,0,1] or \"Show Them Fury Unleashed\" or St. Thomas Franciscan University or shut the fuck up or subsiste sermonem statim\n","err":""},{"err":"","code":"kill 19, getppid\n","out":"0"},{"err":"","code":"length sprintf \"%b\", ~0\n","out":"64"},{"out":"","code":"`ls`\n","err":""},{"out":"[\"*\\$\\$;\\$\",\"\\$\\$\"]","err":"","code":"[ map prototype(\"CORE::$_\"), qw(sysopen truncate) ]\n"},{"out":"","err":"","code":"$memper = '60.1'; if ( int $memper > 90 ) { print \"int($memper) is more than 90\"  }\n"},{"err":"","code":"$memper = 60.1; if ( int $memper > 90 ) { print \"int($memper) is more than 90\"  }\n","out":""},{"err":"","code":"my @array = (\"1234567890abcdefghij1234567890\", \"1234567890klmnopqrst1234567890\", \"1234567890bcdefghijk1234567890\");    my @sorted = sort { substr($a, 9, 10) cmp substr($b, 9, 10) } @array;  [ @sorted ] # seems to work for me\n","out":"[\"1234567890abcdefghij1234567890\",\"1234567890bcdefghijk1234567890\",\"1234567890klmnopqrst1234567890\"]"},{"code":"my $a = sub{ shift == undef }; print \"YES\" if $a->( 1 );\n","err":"","out":""},{"out":"YES","err":"","code":"my $a = sub{ shift == undef }; print \"YES\" if $a->( 'AF' );\n"},{"code":"my $copy; for my $foo (1) { $copy = $foo } [$copy]\n","err":"","out":"[1]"},{"code":"my $foo = 42; my $bar = \\$foo; local $$bar = 53;\n","err":"","out":"ERROR: Can't localize through a reference at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"my $foo; for  $foo (1) { $copy = $foo } [$foo]\n","out":"[undef]"},{"out":"[undef]","err":"","code":"my $foo; for $foo (1) { ''; } [$foo]\n"},{"err":"","code":"my @foo; local $foo[0] = 1; \\@foo;\n","out":"[]"},{"code":"my $foo = \"wi(bb)le\"; qr/\\Q$foo\\E/\n","err":"","out":"qr/wi\\(bb\\)le/u"},{"out":"[\"\"]","code":"my $hack_int = 42; [ !!( $hack_int ^ $hack_int ) ]\n","err":""},{"out":"[\"\"]","err":"","code":"my $hack_int = 42; \"$hack_int\"; [ !!( $hack_int ^ $hack_int ) ]\n"},{"err":"","code":"my $hack_str = \"42\"; [ !!( $hack_str ^ $hack_str ) ]\n","out":"[1]"},{"out":"[\"Gwgh\"]","err":"","code":"my %h = ( A => q(W), a => q(w), B => q(G), b => q(g), y => q(h) ); [join q(), map { $h{$_} } split //, q(Baby)]\n"},{"code":"my %h = (a..z)\n","err":"","out":"26"},{"out":"26","code":"my %h = a..z\n","err":""},{"err":"","code":"my %h = (a..z); ${%h}\n","out":""},{"out":"{\"how strange\" => \"is this, anyway?\"}","err":"","code":"my %h = ('a'..'z'); ${%h}{\"how strange\"} = \"is this, anyway?\"; \\%{%h};\n"},{"code":"my %h = (a..z); ${%h}{\"how strange\"} = \"is this, anyway?\"; \\%{%h};\n","err":"","out":"{\"how strange\" => \"is this, anyway?\"}"},{"out":"[\"baz\",\"foo\",\"bar\"]","code":" my $h = {\"foo\" => 5, \"bar\" => 6, \"baz\" => 2}; [ sort { $h->{$a} <=> $h->{$b} } keys %$h ]\n","err":""},{"out":"[\"bar\",\"baz\",\"foo\"]","code":" my $h = {\"foo\" => 5, \"bar\" => 6, \"baz\" => 2}; [ sort keys %$h ]\n","err":""},{"out":"1","err":"HASH(0x2fab030) at (eval 1) line 1, <STDIN> line 1.\n","code":"my $h = {}; undef( %$h ); warn $h\n"},{"out":"Zoffix is awesome!","err":"","code":"my %map = map +( $_ => chr(ord()+1) ), 'A'..'Z', 'a'..'z'; @map{qw/A a Z z/} = qw/Z z A a/; my $encoded = 'Aneehw hr zvdrnld!'; $encoded =~ s#(.)#$map{$1} // $1#ge; $encoded\n"},{"code":"my @names=[\"Bill\", \"Smith\", \"John\", \"Jane\"]; [$names[0][0]]\n","err":"","out":"[\"Bill\"]"},{"err":"","code":"my @nums = 1..10; [\\@nums]\n","out":"[[1,2,3,4,5,6,7,8,9,10]]"},{"code":"my @nums = 1..10; [$nums[0]]\n","err":"","out":"[1]"},{"code":"my $s = sub{wantarray?'YES':'NO'}; $z='a'; my( $fh ) =  $s->()  ||  $s->(); print $fh;\n","err":"","out":"NO"},{"out":"YES","err":"","code":"my $s = sub{wantarray?'YES':'NO'}; $z='a'; my( $fh ) =  $z =~/^(\\d+)$/  ||  $s->(); print $fh;\n"},{"out":"[\"asdf\"]","code":"my $str = \"asdf\"; open(my $fh, \"+<\", \\$str) or die \"open: $!\"; [ <$fh> ]\n","err":""},{"code":"my $str = \"foo\"; open my $fh, '<', \\$str; <$fh>\n","err":"","out":"foo"},{"err":"","code":"my $str = \"\\x{2603}\"; $fh = IO::String->new($str) or die \"new: $!\"; [ <$fh> ]\n","out":"[\"\\x{2603}\"]"},{"out":"ERROR: open: Invalid argument at (eval 1) line 1, <STDIN> line 1.\n","code":"my $str = \"\\x{2603}\"; open(my $fh, \"+<\", \\$str) or die \"open: $!\"; [ <$fh> ]\n","err":""},{"code":"my $test_link = \"http://zombo.com/\"; my $re = q`(?^:[a-zA-Z][a-zA-Z0-9\\+]*):[\\;\\/\\?\\\\@\\&\\=\\+\\$\\,\\[\\]\\p{isAlpha}A-Za-z0-9\\-_\\.\\!\\~\\*\\'\\(\\)%][\\|\\;\\/\\?\\:\\@\\&\\=\\+\\$\\,\\[\\]\\p{isAlpha}A-Za-z0-9\\-_\\.\\!\\~\\*\\'\\(\\)%#]*`; $test_link =~ /$re/g && warn 1; $test_link =~ /$re/g && warn 2; \n","err":"1 at (eval 1) line 1, <STDIN> line 1.\n","out":""},{"err":"","code":"my $test = sub { say 'ran it' }; my $foo = \\&$test;\n","out":"sub { \"DUMMY\" }"},{"out":"ran it\n","err":"","code":"my $test = sub { say 'ran it' }; my $foo = &$test;\n"},{"err":"","code":"my $t = v3232.95.3232;  [map ord, split //, $t]\n","out":"[3232,95,3232]"},{"err":"","code":"my $t = v3232.95.3232; utf8::decode($t); $t\n","out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ "},{"code":"my $t = v3232.95.3232; utf8::downgrade($t); [map ord, split // 4t]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"// 4\"\n"},{"out":"ERROR: Wide character in subroutine entry at (eval 1) line 1, <STDIN> line 1.\n","code":"my $t = v3232.95.3232; utf8::downgrade($t); [map ord, split //, $t]\n","err":""},{"code":"my $t = v3232.95.3232; utf8::downgrade($t); $t\n","err":"","out":"ERROR: Wide character in subroutine entry at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"my $t = v3232.95.3232;  utf8::encode($t); binmode STDOUT; $t\n","err":"","out":"Ã Â²Â _Ã Â²Â "},{"code":"my $t = v3232.95.3232;  utf8::encode($t); binmode STDOUT, \":utf8\"; $t\n","err":"","out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ "},{"out":"[224,178,160,95,224,178,160]","err":"","code":"my $t = v3232.95.3232;  utf8::encode($t); [map ord, split //, $t]\n"},{"out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ ","err":"","code":"my $t = v3232.95.3232; utf8::encode($t); $t\n"},{"out":"ERROR: Undefined subroutine &utf::downgrade called at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my $t = v3232.95.3232; utf::downgrade($t); $t\n"},{"code":"my $t = v3232.95.3232; utf::encode($t); $t\n","err":"","out":"ERROR: Undefined subroutine &utf::encode called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":" camel snake hummingbird hamster  1 2 3 4 ","code":"my %unstricthash = ( a => [ qw / 1 2 3 4 /] , b => [ qw/ camel snake  hummingbird hamster/ ]) ; for ( %unstricthash ) {  print  \" @{ $_ } \"  if (@{ $_ } )  }  ;\n","err":""},{"err":"","code":"my $w = 'The'; my @r = \"The\\nend\" =~ /$w$end/msg; @r;\n","out":"1"},{"err":"","code":"my $w = 'The'; my @r = \"The\\nend\" =~ /$w$end/msg; \\@r\n","out":"[\"The\"]"},{"err":"","code":"my $w = 'The'; \"The\\nend\" =~ /$w$end/msg;\n","out":"1"},{"err":"","code":"my $w = 'The'; (\"The\\nend\" =~ /$w$end/msg);\n","out":"1"},{"out":"35\n","err":"","code":"my $x = [1..10]; say $x->@[2,4]\n"},{"out":"lex\n","code":"my $x = \"lex\"; eval 'say $x'\n","err":""},{"code":"    $     OMG     =     8_0;    $                 OMG\n","err":"","out":"80"},{"out":"4","err":"","code":"package Foo { sub index { ... } index('aaaao', 'o'); }\n"},{"err":"","code":"package Foo; use strict; use warnings; our $VERSION = 'blah'; package main; say Foo->VERSION\n","out":"ERROR: Invalid version format (non-numeric data) at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"package loose; sub import { shift; strict->unimport(@_) }; sub unimport { shift; strict->import(@_) }\n","err":"","out":""},{"code":"[pack 'NI', 12345, 12345]\n","err":"","out":"[\"\\0\\0000990\\0\\0\"]"},{"err":"","code":"perl -e 'warn hey { \"wtf\" }'\n","out":"ERROR: syntax error at (eval 1) line 1, near \"perl -e \"\n"},{"err":"","code":"'Please identify via /msg NickServ identify <password>.' =~ /^(?:If this is your nickname, type|Please identify via|Type) \\/msg NickServ identify/\n","out":"1"},{"out":"12F4bF78Fb11F1314Fb1617F19bF2223Fb26F2829Fb3132","err":"","code":"print\"F\"x!($_%3).b x!($_%5)||$_ for 1..32\n"},{"code":"print \"hi\"\n","err":"","out":"hi"},{"out":"I'm a Perl 5 program.","code":"print \"I'm a Perl \", 5 + !!\"0\", \" program.\"\n","err":""},{"out":"Just another Sort hacker,","err":"","code":"print sort { $|-- or -1 } 'ruJt tc,en hoetokarrasS h' =~ /./g\n"},{"code":"print v3232.95.3232\n","err":"","out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ "},{"out":"","code":"print 'YES'  if( 1 == undef ) \n","err":""},{"err":"","code":"({qw/ a 1 b 2/})->{b} # kes\n","out":"2"},{"code":"qw (foo bar);\n","err":"","out":"bar"},{"out":"ERROR: Unrecognized character \\x81; marked by <-- HERE after ; qw ÃÂÃÂyoÃÂ<-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"qw ÌyoÌ\n"},{"out":"4","err":"","code":"rindex \"banana\", \"na\"\n"},{"out":"2.95147905179353e+20\n","code":"say 0xFFFFFFFFFFFFFFFFF\n","err":""},{"code":"say 1 + 1\n","err":"","out":"2\n"},{"out":"ERROR: Unrecognized character \\xE0; marked by <-- HERE after res/; say <-- HERE near column 95 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"say à¼¡ + à¼¢\n"},{"out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after res/; say <-- HERE near column 95 at (eval 1) line 1, <STDIN> line 1.\n","code":"say âÂ²\n","err":""},{"code":"say `ps ax`\n","err":"","out":"\n"},{"err":"","code":"say qâ42â;\n","out":"ERROR: Unrecognized character \\x80; marked by <-- HERE after ay qÃÂ¢ÃÂÃÂ42ÃÂ¢<-- HERE near column 102 at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"scalar ('a','b')\n","out":"b"},{"code":"sprintf \"%08b\", 0x36\n","err":"","out":"00110110"},{"out":"0.075000000000000011","code":"sprintf '%.18f', .025 + .05\n","err":""},{"out":"0.074999999999999997","code":"sprintf '%.18f', .075\n","err":""},{"code":"sprintf \"%b\", 0x36\n","err":"","out":"110110"},{"out":"1.4142135623731","err":"","code":"sqrt(2)\n"},{"out":"92681.9000236832","err":"","code":"sqrt(2)*(2 ** 16)\n"},{"out":"bless( , 'IO::File' )","err":"cannot handle ref type 15 at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/x86_64-linux/Data/Dumper.pm line 233, <STDIN> line 1.\n","code":"*STDOUT{IO}\n"},{"code":"$str = '2 floor'; $str =~ s/([0-9]*)\\bFlo*r/${1}00/i; say $str\n","err":"","out":"2 00\n"},{"out":"200 floor\n","err":"","code":"$str = '2 floor'; $str =~ s/([0-9]*)( +Flo*r)/${1}00$2/i; say $str\n"},{"out":"200\n","code":"$str = '2 floor'; $str =~ s/([0-9]*) +Flo*r/${1}00/i; say $str\n","err":""},{"out":" ","err":"","code":"s TT$ Donald Trump\n"},{"out":"bar","code":"sub foo { \"bar\" }; goto +foo; print \"foo\"; bar: print \"bar\"\n","err":""},{"out":"bar\n","err":"","code":"sub foo { \"bar\" }; goto +foo; say \"foo\"; bar: say \"bar\"\n"},{"err":"","code":"sub foo :lvalue { print \"foo called\"; $tmp }; tie &foo, \"main\";\n","out":"foo calledERROR: Can't locate object method \"TIESCALAR\" via package \"main\" at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"abc","code":"sub foo { my $bar = \\@_; $bar->[0] = 'abc'; 'def' }; my $quux = 42; foo($quux); $quux;\n","err":""},{"err":"","code":"sub foo { my $bar = \\@_; local $_[0] = 'abc'; 'def' }; my $quux = 42; foo($quux); $quux;\n","out":"42"},{"err":"","code":"sub foo { my $bar = \\@_; local $bar->[0] = 'abc'; 'def' }; my $quux = 42; foo($quux); $quux;\n","out":"42"},{"code":"sub foo { my @x = (0,0,0); @x } [ [foo()], scalar foo() ]\n","err":"","out":"[[0,0,0],3]"},{"err":"","code":"sub hacker'Perl{\"Perl @_,\"}sub another'Just{\"Just @_ \"}     Just another Perl hacker, \n","out":"Just another Perl hacker, "},{"err":"","code":"sub o { (!$_[0]) && (!$_[1]) } sub j { !( $_[0] && $_[1] ) }  sub p { !($_[0] || $_[1]) } [ map [o($_->[0], $_->[1]), j($_->[0], $_->[1]), p($_->[0], $_->[1])], [0, 0], [1, 0], [1, 1], [0, 1] ]\n","out":"[[1,1,1],[\"\",1,\"\"],[\"\",\"\",\"\"],[\"\",1,\"\"]]"},{"out":"1","err":"","code":"substr(\"banana\", -2) =~ /na/\n"},{"err":"","code":"sub test { say 'ran it' }; my $test = *test; my $foo = \\&$test;\n","out":"sub { \"DUMMY\" }"},{"out":"ran it\n","err":"","code":"sub test { say 'ran it' }; my $test = *test; ( \\&$test ) -> ();\n"},{"out":"[undef]","code":"sub TIEHANDLE { [] }; sub READLINE { \"asdf\" }; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ scalar readline FH ];\n","err":""},{"code":"use bigint; my ($k, $c) = (\"3\", \"37\"); say ((($k+0)**($c+0))-1);\n","err":"","out":"450283905890997362\n"},{"out":"450283905890996999\n","err":"","code":"use bigint; my ($k, $c) = (\"3\", \"37\"); say (($k**$c)-1);\n"},{"out":"450283905890997362\n","code":"use bigint; my ($k, $c) = (3, 37); say (($k**$c)-1);\n","err":""},{"err":"","code":"use bigint; print 11**20;\n","out":"672749994932560009201"},{"code":"use experimental 'postderef'; my $z =[ 1..10]; $z->$#* # or this\n","err":"","out":"9"},{"out":"ok","err":"given is experimental at (eval 1) line 1, <STDIN> line 1.\nwhen is experimental at (eval 1) line 1, <STDIN> line 1.\n","code":"use experimental 'switch'; use warnings; given (1) { when (1) { print \"ok\"; } }\n"},{"code":"use feature 'refaliasing'; my @a = (1, 2, 3); \\my (@b) = \\(@a); @b[2] = 5; [@a];\n","err":"","out":"[1,2,5]"},{"out":"[1,2,5]","err":"","code":"use feature 'refaliasing'; my @a = (1, 2, 3); \\my (@b) = \\(@a); @b[2] = 5; shift @b; [@a];\n"},{"code":"use feature 'refaliasing'; my @a = (1, 2, 3); \\my @b = \\@a; @b[2] = 5; shift @b; [@a];\n","err":"","out":"[2,5]"},{"out":"[2,5]","code":"use feature 'refaliasing'; my @a = (1, 2, 3); \\my (@b) = \\(@a); @b[2] = 5; shift @b; [@b];\n","err":""},{"err":"","code":"use feature 'refaliasing'; my $zoit = [1 .. 3]; \\my $narf = \\$zoit; [ $narf ]\n","out":"[[1,2,3]]"},{"err":"","code":"use feature 'refaliasing'; my $zoit = [1 .. 3]; my \\$narf = \\$zoit; say $narf;\n","out":"ERROR: syntax error at (eval 1) line 1, near \"my \\\"\n"},{"code":"use integer; my $x; for $x (1 .. 10 ) { say $x; }\n","err":"","out":"1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n"},{"out":"{abz => [\"baz\",\"bza\"],abr => [\"bar\"],foo => [\"foo\",\"oof\"]}","err":"","code":"use List::Util qw(reduce); reduce { my $key = join '', sort split '', $b; +{ %$a, $key => [ @{$a->{$key}||[]}, $b ] } } {}, qw(foo oof bar baz bza)\n"},{"code":"use List::Utils qw(reduce); reduce { my $key = join '', sort split '', $b; +{ %$a, $key => [ @{$a->{$key}||[]}, $b ] } } {}, qw(foo oof bar baz bza)\n","err":"","out":"ERROR: Can't locate List/Utils.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use open qw(:std utf8); say v3232.95.3232\n","err":"","out":"ERROR: Can't locate open.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"42","code":"use overload '&{}' => sub { sub { 42 } }; (bless [])->();\n","err":""},{"code":"use overload '&{}' => sub { sub { 42 } }; my $foo = bless []; my $bar = bless [], 'baz'; [ $bar->$foo ]\n","err":"","out":"ERROR: Operation \"\"\"\": no method found, argument in overloaded package main at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use strict; my $foo  = () = 3; say $foo;\n","out":"1\n"},{"out":"\n","code":"use strict; my( $foo ) = () = 3; say $foo;\n","err":""},{"out":"ERROR: Global symbol \"$bar\" requires explicit package name (did you forget to declare \"my $bar\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; my $foo = $bar = 3;\n"},{"out":"3\n","code":"use strict; my $foo = my $bar = 3; say $bar;\n","err":""},{"out":"3\n","err":"","code":"use strict; my $foo = my $bar = 3; say $foo;\n"},{"out":"1\n","err":"","code":"use strict; my $foo  = my( $bar ) = 3; say $foo;\n"},{"out":"3\n","code":"use strict; my( $foo  ) = my( $bar ) = 3; say $foo;\n","err":""},{"out":"[]","err":"","code":"use strict; my $w = 'The'; my @r = \"The\\nend\" =~ /$w$(?:)end/msg; \\@r\n"},{"err":"","code":"use strict; my $w = 'The'; my @r = \"The\\nend\" =~ /$w$end/msg; \\@r\n","out":"ERROR: Global symbol \"$end\" requires explicit package name (did you forget to declare \"my $end\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use strict; my $z=7; my ( $fh ) =  $z =~/^(\\d+)$/  ||  $fh; print $fh;\n","err":"","out":"ERROR: Global symbol \"$fh\" requires explicit package name (did you forget to declare \"my $fh\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Not an ARRAY reference at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $h = {\"foo\" => 5, \"bar\" => 6, \"baz\" => 2}; print Dumper(@{$h}->{qw/foo bar baz/});\n","err":""},{"err":"","code":"use strict; use warnings; sub TIEHANDLE { bless [] }; sub READLINE { \"asdf\" }; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ scalar readline FH ];\n","out":"[\"asdf\"]In autoload!"},{"out":"[undef]","code":"use strict; use warnings; sub TIEHANDLE { [] }; sub READLINE { \"asdf\" }; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ scalar readline FH ];\n","err":"readline() on unopened filehandle FH at (eval 1) line 1.\n"},{"err":"","code":"use ut8; sub æ¨å¥½ { say \"æ¨å¥½\" }; æ¨å¥½\n","out":"ERROR: Can't locate ut8.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"Ã¢ÂÂ¥","err":"","code":"use utf8; ${\"âº\"} = \"â¤\"; binmode STDOUT; chr 1 + ord ${\"âº\"}\n"},{"out":"ÃÂ£ÃÂÃÂ¢ÃÂ£ÃÂÃÂ¼\n","err":"","code":"use utf8; package ãã¹ã; sub new { bless {}, shift} sub ã¢ã¼ { say \"ã¢ã¼\" }; package main; ãã¹ã->new->ã¢ã¼\n"},{"out":"ERROR: Can't locate object method \"new\" via package \"ÃÂ£ÃÂÃÂÃÂ£ÃÂÃÂ¹ÃÂ£ÃÂÃÂ\" at (eval 1) line 1, <STDIN> line 1.\n","code":"use utf8; package ãã¹ã; sub ã¢ã¼ { say \"ã¢ã¼\" }; package main; ãã¹ã->new->ã¢ã¼\n","err":""},{"out":"yo","code":"use utf8; qw ÌyoÌ\n","err":""},{"out":"ERROR: Unrecognized character \\x{f21}; marked by <-- HERE after utf8; say <-- HERE near column 105 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use utf8; say à¼¡ + à¼¢\n"},{"err":"","code":"use utf8; sub æ¨å¥½ { say \"æ¨å¥½\" }; æ¨å¥½\n","out":"ÃÂ¦ÃÂÃÂ¨ÃÂ¥ÃÂ¥ÃÂ½\n"},{"out":"hi\n","code":"use v5.20; say \"hi\"; state $your_business;\n","err":""},{"err":"","code":"use warnings; $^I = 42; [ \\$^I, 0, eval(\"\\$\\t;\"), $@ ]\n","out":"[\\42,0,\"\\34\",\"\"]"},{"out":"this matches","err":"Smartmatch is experimental at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my @foo = 0..10; print \"this matches\" if \"0 but true\" ~~ @foo; # thanks, pink_mist++  \n"},{"out":"bar","err":"Scalar value @foo[0] better written as $foo[0] at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my @foo = qw/bar/; print @foo[0] # Perl911 yours will warn I expect\n"},{"out":"4","err":"Ambiguous call resolved as CORE::index(), qualify as such or use & at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; package Foo; sub index { ... }  index('aaaao', 'o');\n"},{"out":"4","err":"","code":"use warnings; package Foo; sub index :method { ... }  index('aaaao', 'o');\n"},{"out":"ok","err":"","code":"use warnings; use experimental 'switch'; given (1) { when (1) { print \"ok\"; } }\n"},{"out":"ok","code":"use warnings; use feature 'switch'; given (1) { when (1) { print \"ok\"; } }\n","err":"given is experimental at (eval 1) line 1, <STDIN> line 1.\nwhen is experimental at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[undef]","err":"","code":"use warnings; use strict; my $x; for $x (1 .. 10) { last if $x % 2 == 0; } [ $x ]\n"},{"out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ ","err":"","code":"v3232.95.3232\n"},{"err":"","code":"v3232.95.3232;  # This looks like Ã  Â² _ Ã  Â² \n","out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ "},{"out":"ERROR: Can't locate object method \"hey\" via package \"wtf\" (perhaps you forgot to load \"wtf\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"warn hey { \"wtf\" }\n"},{"code":"$_=\"Whfg nabgure crey unpxre\"; tr/A-Za-z/N-ZA-Mn-za-m/;\n","err":"","out":"21"},{"out":"42","err":"","code":"$_=\"Whfg nabgure crey unpxre\"; tr/A-Za-z/N-ZA-Mn-za-m/ * 2; \n"},{"code":"$_=\"Whfg nabgure crey unpxre\"; tr/A-Za-z/N-ZA-Mn-za-m/r; \n","err":"","out":"Just another perl hacker"},{"code":"$_=\"Whfg nabgure crey unpxre\"; tr/A-Zn-za-m/N-ZA-Ma-z/r;\n","err":"","out":"Just another perl hacker"},{"out":"ERROR: Undefined format \"$stdh\" called at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"write select\n"},{"code":"\"\\x{02}\" =~ /\\s/\n","err":"","out":""},{"code":"%x = ( 1 => \"a\", b => 3 ); $str = \"ab\"; print $x{ $str =~ /(.)$/ }\n","err":"","out":"a"},{"out":"yes","code":"\"\\x7f\" =~ /[[:cntrl:]]/ ? \"yes\" : \"no\"\n","err":""},{"out":"900900\n","code":"$x = 99; $x =~ s/([0-9])/${1}00/g; say $x\n","err":""},{"out":"9009\n","code":"$x = 99; $x =~ s/([0-9])/${1}00/; say $x\n","err":""},{"out":"ÃÂÃÂ©ÃÂ¢ÃÂÃÂºÃÂ¢ÃÂÃÂ¥","code":"\"\\x{a9}\\x{263a}\\x{2665}\"\n","err":""},{"code":"[ '+-++-X' =~ /([+\\-](?=[+\\-]*X))/g ]\n","err":"","out":"[\"+\",\"-\",\"+\",\"+\",\"-\"]"},{"code":"$z=0; ( $fh ) =  $z =~/^(\\d+)$/  ||  $fh; print $fh;\n","err":"","out":"1"},{"out":"1","err":"","code":"$z=7; ( $fh ) =  $z =~/^(\\d+)$/  ||  $fh; print $fh;\n"},{"out":"YES","code":"$z='a'; my( $fh ) =  $z =~/^(\\d+)$/  ||  sub {wantarray?'YES':'NO'}->(); print $fh;\n","err":""},{"err":"","code":"$z='a'; my( $fh ) =  $z =~/^(\\d+)$/  ||  (wantarray?'YES':'NO'); print $fh;\n","out":"NO"},{"code":"\"Zoffix\" =~ m âzofâi ? 'yes' : 'nope'\n","err":"","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after  m ÃÂ¢ÃÂÃÂzofÃÂ¢<-- HERE near column 112 at (eval 1) line 1, <STDIN> line 1.\n"}],"evals/evals-freenode-#perlbot.lst":[{"out":"","err":"","code":"\n"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","err":"","code":"- -\n"},{"out":"0","code":"- - ' .'\n","err":""},{"err":"","code":"- - ' '\n","out":"0"},{"out":"-","err":"","code":"- - '-'\n"},{"code":"- - '.'\n","err":"","out":"0"},{"err":"","code":"- - '\"'\n","out":"0"},{"err":"","code":"- - '+'\n","out":"+"},{"out":"0","err":"","code":"- - 'â§'\n"},{"err":"","code":";;;;;;;;;;;;;;;;;;;\n","out":""},{"err":"","code":"\"$^\";\n","out":"$stdh_TOP"},{"out":"","code":"()\n","err":""},{"err":"","code":"();\n","out":""},{"out":"[\"::\"]","err":"","code":"[ :: ]\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"\\]\"\n","code":"[{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',\\]\n","err":""},{"code":"@_\n","err":"","out":"1"},{"code":"$^]\n","err":"","out":""},{"err":"","code":"$!\n","out":"Too many open files"},{"out":"[\"\\\\\\@_\"]","err":"","code":"\\@_\n"},{"err":"","code":"Í¾\n","out":"ERROR: Unrecognized character \\xCD; marked by <-- HERE after natures/; <-- HERE near column 91 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Unrecognized character \\xCD; marked by <-- HERE after natures/; <-- HERE near column 91 at (eval 1) line 1, <STDIN> line 1.\n","code":"Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾\n","err":""},{"code":"0^^0\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"^^\"\n"},{"code":"0**0\n","err":"","out":"1"},{"out":"n","code":"'0.00'+0 ? 'y' : 'n'\n","err":""},{"out":"00:02:02:05:6D:4C","err":"","code":"'000202056D4C' =~ s/..\\K\\B/:/gr\n"},{"out":"00:02:02:05:6D:4C:","code":"'000202056D4C' =~ s/..\\K/:/gr\n","err":""},{"out":"y","code":"'0.00' ? 'y' : 'n'\n","err":""},{"out":"y","code":"'0.0'? 'y' : 'n'\n","err":""},{"code":"0%10\n","err":"","out":"0"},{"code":"[ '010' + 0 ]\n","err":"","out":"[10]"},{"err":"","code":" \"!(0 || 1 && (0 || 0)) && !(1 && 1)\"\n","out":"!(0 || 1 && (0 || 0)) && !(1 && 1)"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"((0.1 + 0.2)\n","err":""},{"out":"0.3","err":"","code":"((0.1 + 0.2))\n"},{"out":"[\"0.3\",\"n\"]","code":"[ 0.1 + 0.2, ((0.1 + 0.2) == 0.3) ? 'y' : 'n' ]\n","err":""},{"code":"((0.1 + 0.2) == 0.3) ? 'y' : 'n'\n","err":"","out":"n"},{"err":"","code":"0.1 + 0.2 == 0.3 ? 'y' : 'n'\n","out":"n"},{"out":"64","code":"0+grep - - chr, 0..255;\n","err":""},{"code":"0+grep { length(- - chr) > 1 } 0..255;\n","err":"","out":"53"},{"out":"[0]","code":"[ '0x010' + 0 ]\n","err":""},{"out":"[95,95]","code":"[ 0x7f - 0x20, 0xff5f - 0xff00 ];\n","err":""},{"err":"","code":"0x80\n","out":"128"},{"out":"4095","code":"0xFFF\n","err":""},{"code":"1\n","err":"","out":"1"},{"code":"\"1\"\n","err":"","out":"1"},{"err":"","code":"$! = 1; \"$!\"\n","out":"Operation not permitted"},{"code":"[ !1, !0, !0+0]\n","err":"","out":"[\"\",1,1]"},{"code":"[ !1, !0, !1+0]\n","err":"","out":"[\"\",1,0]"},{"out":"10000000","err":"","code":"10**length q|*******|\n"},{"out":"[\\1,\\1]","code":"[\\1, \\1]\n","err":""},{"err":"","code":"[ 1111111 =~ /^(1+)+$/ ];\n","out":"[1111111]"},{"code":"1111111 =~ /^(1{1,10})(1{1,10})(1{1,10})(?{ push @comb, [$1, $2, $3] })(?!)/; \\@comb\n","err":"","out":"[[11111,1,1],[1111,11,1],[1111,1,11],[1111,1,1],[111,111,1],[111,11,11],[111,11,1],[111,1,111],[111,1,11],[111,1,1],[11,1111,1],[11,111,11],[11,111,1],[11,11,111],[11,11,11],[11,11,1],[11,1,1111],[11,1,111],[11,1,11],[11,1,1],[1,11111,1],[1,1111,11],[1,1111,1],[1,111,111],[1,111,11],[1,111,1],[1,11,1111],[1,11,111],[1,11,11],[1,11,1],[1,1,11111],[1,1,1111],[1,1,111],[1,1,11],[1,1,1]]"},{"code":"1111111 =~ /^(1{1,10})(1{1,10})(1{1,10})(?{ push @comb, [$1, $2, $3] })(?!)/; [map [map length, @$_], @comb]\n","err":"","out":"[[5,1,1],[4,2,1],[4,1,2],[4,1,1],[3,3,1],[3,2,2],[3,2,1],[3,1,3],[3,1,2],[3,1,1],[2,4,1],[2,3,2],[2,3,1],[2,2,3],[2,2,2],[2,2,1],[2,1,4],[2,1,3],[2,1,2],[2,1,1],[1,5,1],[1,4,2],[1,4,1],[1,3,3],[1,3,2],[1,3,1],[1,2,4],[1,2,3],[1,2,2],[1,2,1],[1,1,5],[1,1,4],[1,1,3],[1,1,2],[1,1,1]]"},{"out":"[[5,1,1],[4,2,1],[4,1,2],[3,3,1],[3,2,2],[3,1,3],[2,4,1],[2,3,2],[2,2,3],[2,1,4],[1,5,1],[1,4,2],[1,3,3],[1,2,4],[1,1,5]]","code":"1111111 =~ /^(1{1,10})(1{1,10})(1{1,10})$(?{ push @comb, [$1, $2, $3] })(?!)/; [map [map length, @$_], @comb]\n","err":""},{"out":"[[],[],[],[],[]]","code":"1111111 =~ /^((1+)(?{ local @one = @one, $1 }))+$(?{ push @comb, \\@one })(?!)/; \\@comb;\n","err":""},{"out":"[[],[],[],[],[]]","code":"1111111 =~ /^((1+)(?{ local @one = @one, $2 }))+$(?{ push @comb, \\@one })(?!)/; \\@comb;\n","err":""},{"out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/^( <-- HERE (1+)(?{ local @one = @one, $2 })+$(?{ push @comb, \\@one })(?!)/ at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"1111111 =~ /^((1+)(?{ local @one = @one, $2 })+$(?{ push @comb, \\@one })(?!)/; \\@comb;\n"},{"out":"[]","code":"[ 1111111 =~ /^(<A>1+)+$/ ];\n","err":""},{"err":"","code":"[ 1111111 =~ /^(?<A>1+)+$/ ];\n","out":"[1111111]"},{"out":"","code":"1111111 =~ /^(<A>1+)*$/;\n","err":""},{"err":"","code":"1111111 =~ /^(<A>1+)*$(?{ print 'yes'; push @comb, [@{$-{A}}] })(?!)/; \\@comb;\n","out":"[]"},{"out":"yesyesyesyesyes","code":"1111111 =~ /^(?<A>1+)*$(?{ print 'yes'; push @comb, [@{$-{A}}] })(?!)/; \\@comb;\n","err":""},{"out":"[[1111111],[1],[11],[1],[111]]","code":"1111111 =~ /^(?<A>1+)*$(?{ push @comb, [@{$-{A}}] })(?!)/; \\@comb;\n","err":""},{"err":"","code":"1111111 =~ /^(<A>1+)*$(?{ push @comb, [@{$-{A}}] })(?!)/ ? [map [map length, @$_], @comb] : \n","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"code":"1111111 =~ /^(<A>1+)*$(?{ push @comb, [@{$-{A}}] })(?!)/; [map [map length, @$_], @comb]\n","err":"","out":"[]"},{"err":"","code":"1111111 =~ /^(<A>1+)*$(?{ push @comb, [@{$-{A}}] })(?!)/ ? [map [map length, @$_], @comb] : 'no';\n","out":"no"},{"out":"3","code":"1+2\n","err":""},{"code":"'12' =~ /1\\B2/ ? 'match' : 'nope'\n","err":"","out":"match"},{"code":"[ '1234567890' =~ /.{0,3}/g ]\n","err":"","out":"[123,456,789,0,\"\"]"},{"err":"","code":"[ '1234567890' =~ /.{1,3}/g ]\n","out":"[123,456,789,0]"},{"err":"","code":"[ '1234567890' =~ /.{,3}/g ]\n","out":"[]"},{"out":"ERROR: Search pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n","code":"/13\n","err":""},{"err":"","code":"1.5 * 14\n","out":"21"},{"code":"/1\\b2/ ? 'match' : 'nope'\n","err":"","out":"nope"},{"code":"/1\\B2/ ? 'match' : 'nope'\n","err":"","out":"nope"},{"out":"Inf","err":"","code":"1e1000\n"},{"out":"[\"10000000000000\"]","err":"","code":"[ 1e205 / 1e192 ]\n"},{"code":"1+print 4\n","err":"","out":"4"},{"err":"","code":"1+print \"4\"\n","out":"4"},{"err":"","code":"$[ = 1;  [ qw/Foo Bar/[1] ]\n","out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"1","err":"","code":"'-1' =~ s/(.+)/-$1/er\n"},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\n","code":"++${\\1}; say 1\n","err":""},{"err":"","code":"$! = 2; \"$!\"\n","out":"No such file or directory"},{"err":"","code":"20%10\n","out":"0"},{"out":"4","err":"","code":"2 << 1\n"},{"code":"[ 2 << 1, 2 >> 1 ]\n","err":"","out":"[4,1]"},{"err":"","code":"[ 2 << 1, 4 >> 1 ]\n","out":"[4,2]"},{"out":"8","err":"","code":"2 << 2\n"},{"code":"220/10*4/60\n","err":"","out":"1.46666666666667"},{"out":"1.83333333333333","code":"220/8*4/60\n","err":""},{"code":"*2=2.5; *2+*2\n","err":"","out":"0"},{"err":"","code":"- - '234567'\n","out":"234567"},{"err":"","code":"2**40\n","out":"1099511627776"},{"out":"255.244","code":"255.244\n","err":""},{"err":"","code":"3%10\n","out":"3"},{"err":"","code":"378/462\n","out":"0.818181818181818"},{"code":"[ 3 + asdfadsf->import ]\n","err":"","out":"[3]"},{"out":"15","code":"(4095 & 0xFF00) >> 8;\n","err":""},{"out":"106752","err":"","code":"417 * 256\n"},{"code":"42\n","err":"","out":"42"},{"code":"â42â\n","err":"","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after natures/; <-- HERE near column 91 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"42","code":"('42 bottles of beer' =~ /(\\d+)/)[0]\n","err":""},{"out":"\\undef","err":"","code":"\\42->can(\"foo\");\n"},{"err":"","code":"42->can(\"foo\");\n","out":""},{"out":"42","code":"(42 =~ /(\\d+)/)[0]\n","err":""},{"err":"","code":"473*6\n","out":"2838"},{"out":"ok","code":"*4 = sub { 'ok' }; main->${ \\4 };\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"->4\"\n","code":"*4 = sub { 'ok' }; main->4;\n","err":""},{"code":"*4 = sub { print \"yes\" }; 4->()\n","err":"","out":"yes"},{"out":"6","err":"","code":"6%10\n"},{"out":"117201","code":"71503 + 46697- 999\n","err":""},{"out":"[-12,-11,15]","code":"[ 98-110,106-117,118-103]  \n","err":""},{"out":"997002","code":"998*999\n","err":""},{"err":"","code":"999*999\n","out":"998001"},{"out":"0","code":"- - ' A'\n","err":""},{"code":"- - 'A'\n","err":"","out":"+A"},{"out":"ERROR: Can't use an undefined value as a symbol reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"*$a = 1;\n"},{"out":"","code":"@a=(1..5); $a[-20]\n","err":""},{"out":"ERROR: Can't modify constant item in substitution (s///) at (eval 1) line 1, near \"s/\\D+//,\"\n","err":"","code":"[ 'a 42 b' =~ s/\\D+//, 'a 42 b' =~ s/\\D+//g ]\n"},{"err":"","code":"[ 'a 42 b' =~ s/\\D+//r, 'a 42 b' =~ s/\\D+//gr ]\n","out":"[\"42 b\",42]"},{"code":"$_ = \"aa\"; /^(.)$1$/\n","err":"","out":""},{"out":"1","code":"$_ = \"aa\"; /^(.)\\1$/\n","err":""},{"code":"$a = 'a'; my $b = \\*a; for $$b (0..5) { print $a }\n","err":"","out":"012345"},{"out":"\\undef","err":"","code":"\\$a = \\$b\n"},{"code":"/a\\Ba/ ? 'match' : 'nope'\n","err":"","out":"nope"},{"code":"[ \\'abc', \\'abc' ]\n","err":"","out":"[\\\"abc\",\\\"abc\"]"},{"code":"[ \\abc::, \\abc:: ]\n","err":"","out":"[\\\"abc\",\\\"abc\"]"},{"code":"[ \\('abc' x 2) ]\n","err":"","out":"[\\\"abcabc\"]"},{"code":"[ \\(abc:: x 2) ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"abc:: x \"\n"},{"out":"nope","code":"/a\\b/ ? 'match' : 'nope'\n","err":""},{"code":"/a\\b#/ ? 'match' : 'nope'\n","err":"","out":"nope"},{"code":"$a=\"foo bar\" *$a = 1;\n","err":"","out":"ERROR: Can't modify multiplication (*) in scalar assignment at (eval 1) line 1, at EOF\n"},{"code":"$a=\"foo bar\"; *$a = 1;\n","err":"","out":"*main::1"},{"out":"*main::foo bar","err":"","code":"$a=\"foo bar\"; *$a = sub {\"baz\"};\n"},{"err":"","code":"$a=\"foo bar\"; *$a = sub {\"baz\"}; \"foo bar\"->()\n","out":"baz"},{"out":"nope","code":"/a/ ? 'match' : 'nope'\n","err":""},{"err":"","code":"'A' =~ s/(A)/lcfirst $1/re\n","out":"a"},{"out":"a","code":"'A' =~ s/(A)/'lcfirst $1'/ree\n","err":""},{"code":"[asdfadsf->can('import')]\n","err":"","out":"[undef]"},{"out":"ERROR: Can't locate object method \"fooo\" via package \"asdfadsf\" (perhaps you forgot to load \"asdfadsf\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"asdfadsf->fooo\n"},{"out":"[]","code":"[ asdfadsf->import ]\n","err":""},{"out":"","code":"asdfadsf->import\n","err":""},{"err":"","code":"'/asdf//' =~ m{/[^/]*/(?!/)} ? 'y' : 'n'\n","out":"y"},{"code":"[ ('a' x 30) =~ /(.*a){25,}/ ];\n","err":"","out":"[\"a\"]"},{"err":"","code":"('a' x 30) =~ /([^a]*a){25,}/\n","out":"1"},{"out":"[\"a\"]","code":"[ ('a' x 30) =~ /([^a]*a){25,}/ ];\n","err":""},{"err":"","code":"'aXYbXYcXYdeXfYgX' =~ s/.+\\KXY.+$//r;\n","out":"aXYbXYc"},{"code":"'aXYbXYcXYdeXfYgX' =~ s/(.+)XY.+$/$1/r;\n","err":"","out":"aXYbXYc"},{"code":"'aXYbXYcXYdeXfYgX' =~ s/XY(.(?!=XY))+//r\n","err":"","out":"a"},{"out":"a","code":"'aXYbXYcXYdeXfYgX' =~ s/XY(.(?!=XY))+$//r\n","err":""},{"out":"aXYcXYdeXfYgX","code":"'aXYbXYcXYdeXfYgX' =~ s/XY(.(?!=XY)+)//r\n","err":""},{"code":"'aXYbXYcXYdeXfYgX' =~ s/XY(.(?!=XY)+)$//r\n","err":"","out":"aXYbXYcXYdeXfYgX"},{"out":"a","err":"","code":"'aXYbXYcXYdeXfYgX' =~ s/XY(.(?!=XY)+)+//r\n"},{"code":"'aXYbXYcXYdeXfYgX' =~ s/XY(.(?!XY))+$//r\n","err":"","out":"aXYbXYc"},{"out":"[3]","err":"","code":"[ ('A'..'Z', 0..9)[29] ]\n"},{"out":"[\"y\"]","code":"[(a..z)[24]]\n","err":""},{"code":"[ ('a'..'z')[25] ]\n","err":"","out":"[\"z\"]"},{"out":"[undef]","code":"[ ('a'..'z')[26] ]\n","err":""},{"code":"[ 'babgbag' =~ /.*?b.*?a.*?g.*?/g ]\n","err":"","out":"[\"babg\",\"bag\"]"},{"out":"[\"babgbag\"]","code":"[ 'babgbag' =~ /.*?b.*?a.*?g.*/g ]\n","err":""},{"code":"[ 'babgbag' =~ /.*b.*a.*g.*/g ]\n","err":"","out":"[\"babgbag\"]"},{"out":"[]","code":"[ () = 'babgbag' =~ /.*?b.*?a.*?g.*?/g ]\n","err":""},{"out":"[]","code":"[ () = 'babgbag' =~ /.*b.*a.*g.*/g ]\n","err":""},{"out":"+bar","code":"- - '+bar'\n","err":""},{"err":"","code":"- 'bar'\n","out":"-bar"},{"err":"","code":"--'bar'\n","out":"ERROR: Can't modify constant item in predecrement (--) at (eval 1) line 1, at EOF\n"},{"out":"+bar","code":"-(-'bar')\n","err":""},{"out":"0","err":"","code":"'bar' - 'bar'\n"},{"err":"","code":"BEGIN { *4 = sub () { 'ok' } }; &{ 4 };\n","out":"ERROR: Too many arguments for subroutine at (eval 1) line 1.\n"},{"err":"","code":"BEGIN { *4 = sub () { 'ok' } }; &{ 4 }();\n","out":"ok"},{"err":"","code":"BEGIN { $::{ARRAY} = \\[qw(one two three)] }; ARRAY\n","out":"[\"one\",\"two\",\"three\"]"},{"out":"[bless( {}, 'Foo' )]","code":"BEGIN { *consecrate = \\&CORE::bless }  [ consecrate  {}, 'Foo' ]\n","err":""},{"out":"123","code":"BEGIN{ $^H = 0 }; use strict; use feature 'state';  for( 1..3) { print ++(state $x) }\n","err":""},{"out":"123","err":"","code":"BEGIN{ $^H = 0 }; use strict; use feature 'state';  for( 1..3) { state $x; print ++$x }\n"},{"out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"BEGIN { &Internals::SvREADONLY(\\1, 0); ++${ \\1 } }; say 1\n","err":""},{"out":"ERROR: Type of arg 1 to Internals::SvREADONLY must be one of [$%@] (not constant item) at (eval 1) line 1, near \"0)\"\nBEGIN not safe after errors--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"BEGIN { Internals::SvREADONLY(\\1, 0); ++${ \\1 } }; say 1\n"},{"err":"","code":"BEGIN { &Internals::SvREADONLY(\\undef, 0); ++${ \\undef } }; say undef;\n","out":"ERROR: Modification of a read-only value attempted at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"..","code":"BEGIN { $SIG{__DIE__} = sub { say \"42\"; } } '..'\n","err":""},{"out":"42\nERROR: Can't locate object method \"a\" via package \"ab\" (perhaps you forgot to load \"ab\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"BEGIN { $SIG{__DIE__} = sub { say \"42\"; } }  a ab \n"},{"code":"BEGIN { $SIG{__DIE__} = sub { say 42 };  }  a bc\n","err":"","out":"42\nERROR: Can't locate object method \"a\" via package \"bc\" (perhaps you forgot to load \"bc\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"BEGIN { $SIG{__DIE__} = sub { say 42; };  }  a bc\n","out":"42\nERROR: Can't locate object method \"a\" via package \"bc\" (perhaps you forgot to load \"bc\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","code":"BEGIN { $SIG{__DIE__} = sub { say 42; exit  };  }  a bc\n","err":""},{"out":"42\nERROR: Can't locate object method \"a\" via package \"bc\" (perhaps you forgot to load \"bc\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"BEGIN { $SIG{__DIE__} = sub { say 42; return 0 };  }  a bc\n","err":""},{"out":"42\nERROR: Can't locate object method \"a\" via package \"bc\" (perhaps you forgot to load \"bc\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"BEGIN { $SIG{__DIE__} = sub { say 42; return  };  }  a bc\n","err":""},{"out":"42\nERROR: Can't locate object method \"a\" via package \"bc\" (perhaps you forgot to load \"bc\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"BEGIN { $SIG{__DIE__} = sub { say 42; return false };  }  a bc\n","err":""},{"err":"","code":"\"BenGoldberg \\N{HEAVY SPARKLE}\"\n","out":"BenGoldberg ÃÂ¢ÃÂÃÂ"},{"code":"binmode STDOUT; ($a,$b) = (\"\\x{202d}\", \"\\x{202e}\");\n","err":"","out":"2"},{"err":"","code":"binmode STDOUT; ($a,$b) = (\"\\x{202d}\", \"\\x{202e}\"); $_ = \"Just another BIDI Hacker,\\n\"; print \"$a$1$b$3\" while s/(.)(.*)(.)/$2/;\n","out":"Ã¢ÂÂ­JÃ¢ÂÂ®,Ã¢ÂÂ­uÃ¢ÂÂ®rÃ¢ÂÂ­sÃ¢ÂÂ®eÃ¢ÂÂ­tÃ¢ÂÂ®kÃ¢ÂÂ­ Ã¢ÂÂ®cÃ¢ÂÂ­aÃ¢ÂÂ®aÃ¢ÂÂ­nÃ¢ÂÂ®HÃ¢ÂÂ­oÃ¢ÂÂ® Ã¢ÂÂ­tÃ¢ÂÂ®IÃ¢ÂÂ­hÃ¢ÂÂ®DÃ¢ÂÂ­eÃ¢ÂÂ®IÃ¢ÂÂ­rÃ¢ÂÂ®B"},{"out":"Ã¢ÂÂ­JÃ¢ÂÂ® Ã¢ÂÂ­uÃ¢ÂÂ®,Ã¢ÂÂ­sÃ¢ÂÂ®rÃ¢ÂÂ­tÃ¢ÂÂ®eÃ¢ÂÂ­ Ã¢ÂÂ®kÃ¢ÂÂ­aÃ¢ÂÂ®cÃ¢ÂÂ­nÃ¢ÂÂ®aÃ¢ÂÂ­oÃ¢ÂÂ®HÃ¢ÂÂ­tÃ¢ÂÂ® Ã¢ÂÂ­hÃ¢ÂÂ®IÃ¢ÂÂ­eÃ¢ÂÂ®DÃ¢ÂÂ­rÃ¢ÂÂ®IÃ¢ÂÂ­ Ã¢ÂÂ®B","code":"binmode STDOUT; ($a,$b) = (\"\\x{202d}\", \"\\x{202e}\"); $_ = \"Just another BIDI Hacker, \"; print \"$a$1$b$3\" while s/(.)(.*)(.)/$2/;\n","err":""},{"out":"Ã¢ÂÂ­JÃ¢ÂÂ®rÃ¢ÂÂ­uÃ¢ÂÂ®eÃ¢ÂÂ­sÃ¢ÂÂ®kÃ¢ÂÂ­tÃ¢ÂÂ®cÃ¢ÂÂ­ Ã¢ÂÂ®aÃ¢ÂÂ­aÃ¢ÂÂ®HÃ¢ÂÂ­nÃ¢ÂÂ® Ã¢ÂÂ­oÃ¢ÂÂ®IÃ¢ÂÂ­tÃ¢ÂÂ®DÃ¢ÂÂ­hÃ¢ÂÂ®IÃ¢ÂÂ­eÃ¢ÂÂ®BÃ¢ÂÂ­rÃ¢ÂÂ® ","code":"binmode STDOUT; ($a,$b) = (\"\\x{202d}\", \"\\x{202e}\"); $_ = \"Just another BIDI Hacker\"; print \"$a$1$b$3\" while s/(.)(.*)(.)/$2/;\n","err":""},{"code":"binmode STDOUT, 'encoding(utf8)'; my @o = (\"\\x{202d}\", \"\\x{202e}\"); print \"$o[--$|]$_\" for split //, 'J,ursetk cAanHo tIhDeIrB /Pler'\n","err":"","out":"ÃÂ¢ÃÂÃÂ­JÃÂ¢ÃÂÃÂ®,ÃÂ¢ÃÂÃÂ­uÃÂ¢ÃÂÃÂ®rÃÂ¢ÃÂÃÂ­sÃÂ¢ÃÂÃÂ®eÃÂ¢ÃÂÃÂ­tÃÂ¢ÃÂÃÂ®kÃÂ¢ÃÂÃÂ­ ÃÂ¢ÃÂÃÂ®cÃÂ¢ÃÂÃÂ­AÃÂ¢ÃÂÃÂ®aÃÂ¢ÃÂÃÂ­nÃÂ¢ÃÂÃÂ®HÃÂ¢ÃÂÃÂ­oÃÂ¢ÃÂÃÂ® ÃÂ¢ÃÂÃÂ­tÃÂ¢ÃÂÃÂ®IÃÂ¢ÃÂÃÂ­hÃÂ¢ÃÂÃÂ®DÃÂ¢ÃÂÃÂ­eÃÂ¢ÃÂÃÂ®IÃÂ¢ÃÂÃÂ­rÃÂ¢ÃÂÃÂ®BÃÂ¢ÃÂÃÂ­ ÃÂ¢ÃÂÃÂ®/ÃÂ¢ÃÂÃÂ­PÃÂ¢ÃÂÃÂ®lÃÂ¢ÃÂÃÂ­eÃÂ¢ÃÂÃÂ®r"},{"out":"Ã¢ÂÂ­JÃ¢ÂÂ® Ã¢ÂÂ­uÃ¢ÂÂ®,Ã¢ÂÂ­sÃ¢ÂÂ®rÃ¢ÂÂ­tÃ¢ÂÂ®eÃ¢ÂÂ­ Ã¢ÂÂ®kÃ¢ÂÂ­aÃ¢ÂÂ®cÃ¢ÂÂ­nÃ¢ÂÂ®aÃ¢ÂÂ­oÃ¢ÂÂ®HÃ¢ÂÂ­tÃ¢ÂÂ® Ã¢ÂÂ­hÃ¢ÂÂ®IÃ¢ÂÂ­eÃ¢ÂÂ®DÃ¢ÂÂ­rÃ¢ÂÂ®IÃ¢ÂÂ­ Ã¢ÂÂ®B","err":"","code":"binmode STDOUT; $_ = \"Just another BIDI Hacker, \"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n"},{"err":"","code":"binmode STDOUT; $_ = \"Just another Hexchat Hacker,  \"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n","out":"Ã¢ÂÂ­JÃ¢ÂÂ® Ã¢ÂÂ­uÃ¢ÂÂ® Ã¢ÂÂ­sÃ¢ÂÂ®,Ã¢ÂÂ­tÃ¢ÂÂ®rÃ¢ÂÂ­ Ã¢ÂÂ®eÃ¢ÂÂ­aÃ¢ÂÂ®kÃ¢ÂÂ­nÃ¢ÂÂ®cÃ¢ÂÂ­oÃ¢ÂÂ®aÃ¢ÂÂ­tÃ¢ÂÂ®HÃ¢ÂÂ­hÃ¢ÂÂ® Ã¢ÂÂ­eÃ¢ÂÂ®tÃ¢ÂÂ­rÃ¢ÂÂ®aÃ¢ÂÂ­ Ã¢ÂÂ®hÃ¢ÂÂ­HÃ¢ÂÂ®cÃ¢ÂÂ­eÃ¢ÂÂ®x"},{"out":"Ã¢ÂÂ­JÃ¢ÂÂ® Ã¢ÂÂ­uÃ¢ÂÂ®,Ã¢ÂÂ­sÃ¢ÂÂ®rÃ¢ÂÂ­tÃ¢ÂÂ®eÃ¢ÂÂ­ Ã¢ÂÂ®kÃ¢ÂÂ­aÃ¢ÂÂ®cÃ¢ÂÂ­nÃ¢ÂÂ®aÃ¢ÂÂ­oÃ¢ÂÂ®HÃ¢ÂÂ­tÃ¢ÂÂ® Ã¢ÂÂ­hÃ¢ÂÂ®tÃ¢ÂÂ­eÃ¢ÂÂ®aÃ¢ÂÂ­rÃ¢ÂÂ®hÃ¢ÂÂ­ Ã¢ÂÂ®cÃ¢ÂÂ­HÃ¢ÂÂ®x","code":"binmode STDOUT; $_ = \"Just another Hexchat Hacker, \"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n","err":""},{"out":"Ã¢ÂÂ­JÃ¢ÂÂ®,Ã¢ÂÂ­uÃ¢ÂÂ®rÃ¢ÂÂ­sÃ¢ÂÂ®eÃ¢ÂÂ­tÃ¢ÂÂ®kÃ¢ÂÂ­ Ã¢ÂÂ®cÃ¢ÂÂ­aÃ¢ÂÂ®aÃ¢ÂÂ­nÃ¢ÂÂ®HÃ¢ÂÂ­oÃ¢ÂÂ® Ã¢ÂÂ­tÃ¢ÂÂ®tÃ¢ÂÂ­hÃ¢ÂÂ®aÃ¢ÂÂ­eÃ¢ÂÂ®hÃ¢ÂÂ­rÃ¢ÂÂ®cÃ¢ÂÂ­ Ã¢ÂÂ®xÃ¢ÂÂ­HÃ¢ÂÂ®e","err":"","code":"binmode STDOUT; $_ = \"Just another Hexchat Hacker,\"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n"},{"out":"Ã¢ÂÂ­JÃ¢ÂÂ®,Ã¢ÂÂ­uÃ¢ÂÂ®rÃ¢ÂÂ­sÃ¢ÂÂ®eÃ¢ÂÂ­tÃ¢ÂÂ®kÃ¢ÂÂ­ Ã¢ÂÂ®cÃ¢ÂÂ­aÃ¢ÂÂ®aÃ¢ÂÂ­nÃ¢ÂÂ®HÃ¢ÂÂ­oÃ¢ÂÂ® Ã¢ÂÂ­tÃ¢ÂÂ®IÃ¢ÂÂ­hÃ¢ÂÂ®DÃ¢ÂÂ­eÃ¢ÂÂ®IÃ¢ÂÂ­rÃ¢ÂÂ®BÃ¢ÂÂ­ Ã¢ÂÂ®/Ã¢ÂÂ­PÃ¢ÂÂ®lÃ¢ÂÂ­eÃ¢ÂÂ®r","code":"binmode STDOUT; $_ = \"Just another Perl/BIDI Hacker,\"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n","err":""},{"out":"hÂÂÂ>ÂÂÂÂÂÂ>sÂÂÂÂÂÂ>ÂÂÂÂÂJ","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x10-\\x7f][\\xff00-\\xff5f]r;\n","err":""},{"out":"Ã¯Â¼ÂªÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¢ÂÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¢ÂÂÃ¯Â¼ÂµÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¢ÂÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼Â","err":"","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\x{2000}\\x{ff01}-\\x{ff5f}]r;\n"},{"err":"","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\x{2001}\\x{ff01}-\\x{ff5f}]r;\n","out":"Ã¯Â¼ÂªÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¢ÂÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¢ÂÂÃ¯Â¼ÂµÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¢ÂÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼Â"},{"err":"","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\x{2003}\\x{ff01}-\\x{ff5f}]r;\n","out":"Ã¯Â¼ÂªÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¢ÂÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¢ÂÂÃ¯Â¼ÂµÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¢ÂÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼Â"},{"code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\x{ff00}-\\x{ff5f}]r;\n","err":"","out":"Ã¯Â¼ÂªÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼ÂÃ¯Â¼ÂµÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼Â"},{"out":"XÂÂÂÃ¿o|}ÂvsÂÃ¿c|wq}rsÃ¿voqysÂ:","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\xff00-\\xff5f]r;\n","err":""},{"code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][ \\x{ff01}-\\x{ff5f}]r;\n","err":"","out":"Ã¯Â¼ÂªÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½Â Ã¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½Â Ã¯Â¼ÂµÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½Â Ã¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼Â"},{"err":"","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\xff10-\\xff5f]r;\n","out":"XÂÂÂÃ¿o|}ÂvsÂÃ¿c|wq}rsÃ¿voqysÂ:"},{"out":"XÂÂÂÃ¿o|}ÂvsÂÃ¿c|wq}rsÃ¿voqysÂ:","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\xff20-\\xff5f]r;\n","err":""},{"code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\xff30-\\xff5f]r;\n","err":"","out":"XÂÂÂÃ¿o|}ÂvsÂÃ¿c|wq}rsÃ¿voqysÂ:"},{"out":"XÂÂÂÃ¿o|}ÂvsÂÃ¿c|wq}rsÃ¿voqysÂ:","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\xff40-\\xff5f]r;\n","err":""},{"out":"XÂÂÂÃ¿o|}ÂvsÂÃ¿c|wq}rsÃ¿voqysÂ:","err":"","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\xff50-\\xff5f]r;\n"},{"out":"Hsqr _lmrfcp Slgambc f_aicp,","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x30-\\x7f][\\xff00-\\xff5f]r;\n","err":""},{"out":"8cab O\\]bVS` C\\WQ]RS VOQYS`,","err":"","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x40-\\x7f][\\xff00-\\xff5f]r;\n"},{"out":"Ã¢ÂÂ­JÃ¢ÂÂ®,Ã¢ÂÂ­uÃ¢ÂÂ®rÃ¢ÂÂ­sÃ¢ÂÂ®eÃ¢ÂÂ­tÃ¢ÂÂ®kÃ¢ÂÂ­ Ã¢ÂÂ®cÃ¢ÂÂ­AÃ¢ÂÂ®aÃ¢ÂÂ­nÃ¢ÂÂ®HÃ¢ÂÂ­oÃ¢ÂÂ® Ã¢ÂÂ­tÃ¢ÂÂ®IÃ¢ÂÂ­hÃ¢ÂÂ®DÃ¢ÂÂ­eÃ¢ÂÂ®IÃ¢ÂÂ­rÃ¢ÂÂ®BÃ¢ÂÂ­ Ã¢ÂÂ®/Ã¢ÂÂ­PÃ¢ÂÂ®lÃ¢ÂÂ­eÃ¢ÂÂ®r","err":"","code":"binmode STDOUT; my @o = (\"\\x{202d}\", \"\\x{202e}\"); print \"$o[--$|]$_\" for split //, 'J,ursetk cAanHo tIhDeIrB /Pler'\n"},{"code":"binmode STDOUT; print 'â' .. 'â'\n","err":"","out":"Ã¢ÂÂ"},{"out":"Ã¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂ Ã¢ÂÂ¡Ã¢ÂÂ¢Ã¢ÂÂ£Ã¢ÂÂ¤Ã¢ÂÂ¥Ã¢ÂÂ¦Ã¢ÂÂ§Ã¢ÂÂ¨Ã¢ÂÂ©Ã¢ÂÂªÃ¢ÂÂ«Ã¢ÂÂ¬Ã¢ÂÂ­Ã¢ÂÂ®Ã¢ÂÂ¯Ã¢ÂÂ°Ã¢ÂÂ±Ã¢ÂÂ²Ã¢ÂÂ³Ã¢ÂÂ´Ã¢ÂÂµÃ¢ÂÂ¶Ã¢ÂÂ·Ã¢ÂÂ¸Ã¢ÂÂ¹Ã¢ÂÂºÃ¢ÂÂ»Ã¢ÂÂ¼Ã¢ÂÂ½Ã¢ÂÂ¾Ã¢ÂÂ¿Ã¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂ","code":"binmode STDOUT; print chr($_) for 0x2719 .. 0x2749;\n","err":""},{"code":"binmode STDOUT; print for 'â' .. 'â'\n","err":"","out":"Ã¢ÂÂ"},{"code":"binmode STDOUT; print \"\\x{1f4a9}\"\n","err":"","out":"Ã°ÂÂÂ©"},{"code":"binmode STDOUT, 'utf8'; my @o = (\"\\x{202d}\", \"\\x{202e}\"); print \"$o[--$|]$_\" for split //, 'J,ursetk cAanHo tIhDeIrB /Pler'\n","err":"","out":"ÃÂ¢ÃÂÃÂ­JÃÂ¢ÃÂÃÂ®,ÃÂ¢ÃÂÃÂ­uÃÂ¢ÃÂÃÂ®rÃÂ¢ÃÂÃÂ­sÃÂ¢ÃÂÃÂ®eÃÂ¢ÃÂÃÂ­tÃÂ¢ÃÂÃÂ®kÃÂ¢ÃÂÃÂ­ ÃÂ¢ÃÂÃÂ®cÃÂ¢ÃÂÃÂ­AÃÂ¢ÃÂÃÂ®aÃÂ¢ÃÂÃÂ­nÃÂ¢ÃÂÃÂ®HÃÂ¢ÃÂÃÂ­oÃÂ¢ÃÂÃÂ® ÃÂ¢ÃÂÃÂ­tÃÂ¢ÃÂÃÂ®IÃÂ¢ÃÂÃÂ­hÃÂ¢ÃÂÃÂ®DÃÂ¢ÃÂÃÂ­eÃÂ¢ÃÂÃÂ®IÃÂ¢ÃÂÃÂ­rÃÂ¢ÃÂÃÂ®BÃÂ¢ÃÂÃÂ­ ÃÂ¢ÃÂÃÂ®/ÃÂ¢ÃÂÃÂ­PÃÂ¢ÃÂÃÂ®lÃÂ¢ÃÂÃÂ­eÃÂ¢ÃÂÃÂ®r"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"blahblah q|0.000.000_YYMMDDhhmm|\"\n","code":"blahblah q|0.000.000_YYMMDDhhmm|\n","err":""},{"out":"ERROR: Not enough arguments for bless at (eval 1) line 1, near \"bless()\"\n","code":"bless bless(), \"Bar\"\n","err":""},{"out":"bless( {}, 'Bar' )","err":"","code":"bless bless({}, \"Foo\"), \"Bar\"\n"},{"out":"bless( {}, 'Foo' )","code":"*::bless = sub { print \"foo\" }; bless {}, 'Foo';\n","err":""},{"code":"*bless = sub { print \"foo\" }; bless {}, 'Foo';\n","err":"","out":"bless( {}, 'Foo' )"},{"err":"","code":"$_ = 'CamelCaseXMLParser'; join('_', map {lc} grep {length} split /([A-Z]+[^A-Z]*)/)\n","out":"camel_case_xmlparser"},{"code":"$_ = 'CamelCaseXMLParser'; join '', map { ucfirst lc } split '_', join('_', map {lc} grep {length} split /([A-Z]+[^A-Z]*)/)\n","err":"","out":"CamelCaseXmlparser"},{"code":"$_ = 'CamelCaseXMLParser'; join('', map { ucfirst lc } split '_', join('_', map {lc} grep {length} split /([A-Z]+[^A-Z]*)/)\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"out":"CamelCaseXmlparser","code":"'CamelCaseXMLParser' =~ s/([A-Z]+[^A-Z]*)/\\u\\L$1/gr;\n","err":""},{"out":"ERROR: Can't call method \"can\" without a package or object reference at (eval 1) line 1, <STDIN> line 1.\n","code":"\"\"->can(\"foo\");\n","err":""},{"out":"[0]","err":"","code":"$cat_line = 'Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 3 ? 1 : 0; [ $is_deep ]\n"},{"out":"[[\"Foo\",\"Bar\",\"Ber\",\"Bez\"],\"Foo*::*Bar*::*Ber*::*Bez\"]","err":"","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur*::*Brooze'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my @cat_bits = split /\\Q*::*\\E/, $cat_line; splice @cat_bits, -2; my $unwanted_cat = join '*::*', @cat_bits; [ \\@cat_bits, $unwanted_cat  ]\n"},{"code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (=() = $cat_line =~ /\\Q*::*\\E/) > 3 ? 1 : 0; [ $is_deep ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"(=\"\n"},{"code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/) > 3 ? 1 : 0; [ $is_deep ]\n","err":"","out":"[0]"},{"code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my @cat_bits = split /\\Q*::*\\E/, $cat_line; [ \\@cat_bits ]\n","err":"","out":"[[\"Foo\",\"Bar\",\"Ber\",\"Bez\",\"Bur\"]]"},{"err":"","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my @cat_bits = split /\\Q*::*\\E/, $cat_line; $cat_line = join '*::*', splice @cat_bits, 2; [ \\@cat_bits, $cat_line ]\n","out":"[[\"Foo\",\"Bar\"],\"Ber*::*Bez*::*Bur\"]"},{"code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my @cat_bits = split /\\Q*::*\\E/, $cat_line = join '*::*', splice @cat_bits, 2; [ \\@cat_bits, $cat_line ]\n","err":"","out":"[[],\"\"]"},{"err":"","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my @cat_bits = split /\\Q*::*\\E/, $cat_line = join '*::*', splice @cat_bits, 3; [ \\@cat_bits, $cat_line ]\n","out":"[[],\"\"]"},{"err":"","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my @cat_bits = split /\\Q*::*\\E/, $cat_line; splice @cat_bits, -2; my $unwanted_cat = join '*::*', @cat_bits; [ \\@cat_bits, $unwanted_cat  ]\n","out":"[[\"Foo\",\"Bar\",\"Ber\"],\"Foo*::*Bar*::*Ber\"]"},{"out":"[[\"Foo\",\"Bar\"],\"Foo*::*Bar\"]","err":"","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my @cat_bits = split /\\Q*::*\\E/, $cat_line; splice @cat_bits, 2; my $unwanted_cat = join '*::*', @cat_bits; [ \\@cat_bits, $unwanted_cat  ]\n"},{"out":"ERROR: Missing right curly or square bracket at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, at EOF\n","err":"","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my $prefix = splice 0, 3, @{[split /\\Q*::*\\E/, $cat_line]; [ $prefix ]\n"},{"out":"ERROR: Type of arg 1 to splice must be array (not constant item) at (eval 1) line 1, at EOF\n","err":"","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my $prefix = splice 0, 3, @{[split /\\Q*::*\\E/, $cat_line]}; [ $prefix ]\n"},{"err":"","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my $prefix = splice 0, 3, split /\\Q*::*\\E/, $cat_line; [ $prefix ]\n","out":"ERROR: Type of arg 1 to splice must be array (not constant item) at (eval 1) line 1, at EOF\n"},{"out":"[1]","err":"","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 3 ? 1 : 0; [ $is_deep ]\n"},{"out":"[4]","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = () = $cat_line =~ /\\Q*::*\\E/g;  [ $is_deep ]\n","err":""},{"code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = () = $cat_line =~ /\\Q*::*\\E/;  [ $is_deep ]\n","err":"","out":"[1]"},{"err":"","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = () = $cat_line =~ /\\Q*::*\\E/);  [ $is_deep ]\n","out":"ERROR: syntax error at (eval 1) line 1, near \"/\\Q*::*\\E/)\"\n"},{"out":"[\"Ber*::*Bur]\"]","code":"$cat_line = '[Foo*::*Bar*::*Ber*::*Bez*::*Bur]'; $wanted_cat = join '*::*', (split /\\Q*::*\\E/, $cat_line)[-3,-1]; [ $wanted_cat ]\n","err":""},{"out":"[\"Ber*::*Bur\"]","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; $wanted_cat = join '*::*', (split /\\Q*::*\\E/, $cat_line)[-3,-1]; [ $wanted_cat ]\n","err":""},{"code":"$c=\"{a,v,p,r}\"; [grep {$_ !~ /(.)\\1/} glob $c.$c]\n","err":"","out":"[\"av\",\"ap\",\"ar\",\"va\",\"vp\",\"vr\",\"pa\",\"pv\",\"pr\",\"ra\",\"rv\",\"rp\"]"},{"code":"$_ = 'C########C_##'; /(#*)C/; [ length $1 ]\n","err":"","out":"[0]"},{"err":"","code":"$_ = '########C_##'; /(#+)C/; [ length $1 ]\n","out":"[8]"},{"err":"","code":"$_ = '########C_##'; /C/; [ pos ]\n","out":"[undef]"},{"code":"@charmap = qw/Botje!!!/; @charmap->[qw/Botje/]\n","err":"","out":"ERROR: Can't use an array as a reference at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"@charmap = qw/Botje/; @charmap->[qw/Botje!/]\n","out":"ERROR: Can't use an array as a reference at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"charnames::string_vianame(\"SNOWMAN\")\n","err":"","out":"ÃÂ¢ÃÂÃÂ"},{"out":"CYRILLIC CAPITAL LETTER A WITH DIAERESIS","code":"charnames::viacode(1234)\n","err":""},{"out":"ÃÂ­ÃÂ ÃÂ","code":"chr 0xd800\n","err":""},{"out":"\u0000","err":"","code":"chr 'Î§'\n"},{"out":"[undef]","err":"","code":"$_ = '########_##'; /(#*)C/; [ length $1 ]\n"},{"err":"","code":"*code = sub { print 'ok' }; say '[', code, ']';\n","out":"[code]\n"},{"code":"\\&code = sub { print 'ok' }; say '[', code, ']';\n","err":"","out":"[code]\n"},{"out":"*CORE::bless","code":"*CORE::bless = sub { print \"foo\" }\n","err":""},{"out":"ERROR: Can't modify reference to ref-to-glob cast in scalar assignment at (eval 1) line 1, at EOF\n","code":"\\*$CORE::bless = sub { print \"foo\" }\n","err":""},{"code":"\\*CORE::bless = sub { print \"foo\" }\n","err":"","out":"ERROR: Can't modify reference to ref-to-glob cast in scalar assignment at (eval 1) line 1, at EOF\n"},{"out":"ERROR: Not enough arguments for bless at (eval 1) line 1, at EOF\n","code":"*CORE::bless = sub { print \"foo\" }; bless\n","err":""},{"code":"*CORE::bless = sub { print \"foo\" }; bless {}, 'Foo';\n","err":"","out":"bless( {}, 'Foo' )"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"} die\n\"\n","code":"*CORE::die = sub { say \"42\"; } die  \n","err":""},{"out":"ERROR: Died at (eval 1) line 1, <STDIN> line 1.\n","code":"*CORE::die = sub { say \"42\"; }; die  \n","err":""},{"err":"","code":"$CORE::GLOBAL::print = sub { print 42 }; print \"foo\"\n","out":"foo"},{"out":"foo","err":"","code":"*CORE::GLOBAL::print = sub { print 42 }; print \"foo\"\n"},{"err":"","code":"CORE::GLOBAL{print} = sub { print 42 }; print \"foo\"\n","out":"ERROR: CORE::GLOBAL is not a keyword at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"*CORE::print\n","out":"*CORE::print"},{"out":"\\*CORE::print","err":"","code":"\\*CORE::print\n"},{"out":"0","code":"@d\n","err":""},{"out":"ERROR: Can't modify non-lvalue subroutine call of &Data::Dumper::Deparse in scalar assignment at (eval 1) line 1, at EOF\n","code":"Data::Dumper::Deparse = 1; my $a = sub { say \"Hello World\" }; my $b = $a; \\(sub {say \"Goodbye Mars\"});\n","err":""},{"out":"[[1,2,3,{ber => \"bez\",foo => \"bar\"}],[42,2,3,$VAR1->[0][3]]]","err":"","code":"$Data::Dumper::Terse = 1; $r = [ 1, 2, 3, { foo => bar }, ]; @a = @$r; $r->[0] = 42; $r->[3]{ber} = 'bez'; [ \\@a, $r ]\n"},{"out":"decode_json","err":"","code":"decode_json\n"},{"err":"","code":"deparse: sub foo (;$) { say \"[@_]\"; }; my %h = ( bar => foo(42), meow => 'moo' ); \\%h\n","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, at EOF\n"},{"err":"","code":"deparse: sub foo ($) { say \"[@_]\"; }; my %h = ( bar => foo(42), meow => 'moo' ); \\%h\n","out":"[42]\n"},{"out":"ERROR: Denied. at (eval 1) line 1, <STDIN> line 1.\n","code":"()?(): die 'Denied.';\n","err":""},{"err":"","code":"do {my $print = \\&CORE::GLOBAL::print; *CORE::GLOBAL::print = sub { $print->(\"wut wut: \", @_)}}; CORE::print \"foo\"\n","out":"foo"},{"out":"[1]","code":"do { my @tmp = 1, 2, 3; \\@tmp }\n","err":""},{"err":"","code":"[ $!{EINSUFFICIENT_POO} ]\n","out":"[\"\"]"},{"out":"","code":"$!{EINSUFFICIENT_POO}\n","err":""},{"code":"[ Errno::EBADE ]\n","err":"","out":"[52]"},{"out":"[\"Errno::EBADY\"]","code":"[ Errno::EBADY ]\n","err":""},{"out":"[16]","err":"","code":"[ Errno::EBUSY ]\n"},{"out":"[1]","code":"[ Errno::EPERM ]\n","err":""},{"out":"[109]","code":"[ Errno::ETOOMANYREFS ]\n","err":""},{"out":"","err":"","code":"eval \"!(0 || 1 && (0 || 0)) && !(1 && 1)\"\n"},{"code":"[ eval \"qw(yes yes),\\n#no\\nqw(yes yes)\" ]\n","err":"","out":"[\"yes\",\"yes\",\"yes\",\"yes\"]"},{"code":"exec '/bin/cwd'; $!;\n","err":"","out":"No such file or directory"},{"err":"","code":"exec '/bin/ls'; $!;\n","out":"No such file or directory"},{"out":"No such file or directory","err":"","code":"exec '/usr/bin/ls'; $!;\n"},{"err":"","code":"$_ = '@f@f@f'; s'@f'$b'gr; \n","out":"$b$b$b"},{"err":"","code":"++($foo++)\n","out":"ERROR: Can't modify postincrement (++) in preincrement (++) at (eval 1) line 1, at EOF\n"},{"err":"","code":"++${($foo++)\n","out":"ERROR: Missing right curly or square bracket at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, at EOF\n"},{"code":"* \"foo\" = 1;\n","err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"*'foo' = 1;\n","err":"","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"$foo = 1; $bar = *foo; [ $$bar ]\n","err":"","out":"[1]"},{"err":"","code":"$foo1 = $foo2 = '4 a 2'; ( $foo1 ) = $foo1 =~ /(\\d+)/; $foo2 =~ s/\\D+//g; [ $foo1, $foo2 ]\n","out":"[4,42]"},{"code":"$foo = 42; $bar = *foo; [ *$bar = sub { 53 } ]\n","err":"","out":"[*::foo]"},{"out":"42","err":"","code":"$foo = 42; $bar = *foo; *$bar = sub { 53 }; $$bar;\n"},{"out":"53","code":"$foo = 42; $bar = *foo; *$bar = sub { 53 }; $bar->();\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"^.\"\n","err":"","code":"'foo   ' ^. '   bar'\n"},{"out":"{ber => undef,foo => \"bar\"}","err":"","code":"+{ foo => bar => 'ber' }\n"},{"out":"ERROR: Not a GLOB reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"$foo = 'bar'; $qux = \\$foo; for $$qux (1..3) { print $foo }\n"},{"err":"","code":"$foo = 'bar'; $qux = \\*foo; for $$qux (1..3) { print $foo }\n","out":"123"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n","err":"","code":"'foo' =~ /(?<foo>foo)/; 'bar' =~ /(ba)/; [ $+{foo} \n"},{"err":"","code":"'foo' =~ /(?<foo>foo)/; 'bar' =~ /(ba)/; [ $+{foo} ]\n","out":"[undef]"},{"out":"","code":"'foo' =~ /(?<foo>foo)/; 'bar' =~ /(ba)/; $+{foo}\n","err":""},{"code":"\"foo\" =~ /(?<foo>foo)/; \"bar\" =~ /(ba)/; [ $+{foo} ]\n","err":"","out":"[undef]"},{"out":"foo","code":"'foo' =~ /(?<foo>foo)/; $+{foo}\n","err":""},{"out":"bar","code":"'foo' =~ /.+/; 'foo' =~ s//bar/r;\n","err":""},{"err":"","code":"Foo->meta\n","out":"ERROR: Can't locate object method \"meta\" via package \"Foo\" (perhaps you forgot to load \"Foo\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"n","code":"'foo\\n' =~ /foo$/m ? 'y' : 'n'\n","err":""},{"out":"n","code":"'foo\\n' =~ /foo$/ ? 'y' : 'n'\n","err":""},{"out":"[\"bar\",\"fxx\"]","code":"[ 'foo' =~ s/foo/bar/r, 'foo' =~ tr/o/x/r ]\n","err":""},{"err":"","code":"* \"foo\"* = sub {\"bar\"};\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"*\"foo\" = sub {\"bar\"};\n","err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"*\"foo*\" = sub {\"bar\"};\n","err":""},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"*\"foo*\"* = sub {\"bar\"};\n"},{"out":"foobar","code":"'foo' =~ /x.+/; 'foo' =~ s//bar/r;\n","err":""},{"code":"for (\"a\"..\"z\", \" \") { say ($_ eq \" \" ? \"SPACE\" : $_) if (/(c|a)/i && /[^MCI]/i && /[ai]/i && /[^ki\\sp]/i) }\n","err":"","out":"a\n"},{"out":"","err":"","code":"for (\"a\"..\"z\", \" \") { say ($_ eq \" \" ? \"SPACE\" : $_) if (/(cat|a-t)/i && /[^MCI]/i && /[ai]/i && /[^ki\\sp]/i) }\n"},{"err":"","code":"for (\"a\"..\"z\", \" \") { say if (/[a-gn-z]/i && /[^a-ru-z]/i && /[a-ks-v]/i && /[^a-di-s]/i) }\n","out":"t\n"},{"out":"e\n","code":"for (\"a\"..\"z\", \" \") { say if (/[a-gn-z]/i && /[d-hj-m]/i && /[^f-km-z]/i && /[^a-di-s]/i) }\n","err":""},{"err":"","code":"for (\"a\"..\"z\", \" \") { say \" \" if (/(cat|a-t)/i && /[^MCI]/i && /[ai]/i && /[^ki\\sp]/i) }\n","out":""},{"out":"","code":"for (\"a\"..\"z\", \" \") { say if (/(cat|a-t)/i && /[^MCI]/i && /[ai]/i && /[^ki\\sp]/i) }\n","err":""},{"out":"","code":"for (\"a\"..\"z\") { say if /[HELP\\s]/ }\n","err":""},{"code":"for (\"a\"..\"z\") { say if /[HELP\\s]/i }\n","err":"","out":"e\nh\nl\np\n"},{"code":"for (\"a\"..\"z\", \" \") { say if (/[HELP\\s]/i && /[\\sCOPE]/i && /[^SEAP]/i) }\n","err":"","out":" \n"},{"out":"","err":"","code":"for (\"a\"..\"z\") { say if (/[HELP\\s]/i && /[\\sCOPE]/i && /[^SEAP]/i) }\n"},{"err":"","code":"for (\"a\"..\"z\", \" \") { say \"N\" if (/[a-gn-z]/i && /[^a-ru-z]/i && /[a-ks-v]/i && /[^a-di-s]/i) }\n","out":"N\n"},{"err":"","code":"for (\"a\"..\"z\", \" \") { say \"N\" if (/[a-gn-z]/i && /[d-hj-m]/i && /[^f-km-z]/i && /[^a-di-s]/i) }\n","out":"N\n"},{"out":"N\n","code":"for (\"a\"..\"z\", \" \") { say \"N\" if (/[HELP\\s]/i && /[\\sCOPE]/i && /[^SEAP]/i) }\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"for *code\"\n","err":"","code":"for *code (sub { print 'ok' }) { code() }\n"},{"code":"for \\*code (sub { print 'ok' }) { code() }\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"\\*code\"\n"},{"out":"","err":"","code":"for \\&code (sub { print 'ok' }) { code }\n"},{"code":"for \\&code (sub { print 'ok' }) { code() }\n","err":"","out":"ok"},{"out":"[[[]]]","code":"for \\&code (sub { print 'ok' }) { print \"[[[$asdf]]]\" }\n","err":""},{"out":"","err":"","code":"for \\&code (sub { print 'ok' }) { print code }\n"},{"out":"[code]\n","code":"for \\&code (sub { print 'ok' }) { say '[', code, ']' }\n","err":""},{"out":"","err":"","code":"for \\&code (sub { print 'ok' }) { say code }\n"},{"err":"","code":"for my (\"a\"..\"z\") { say if /[HELP\\s]/ }\n","out":"ERROR: Missing $ on loop variable at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"foobar","err":"","code":"for ( [qw/foo bar/]->@* ) { print}\n"},{"code":"for ( [qw/foo bar/]->*@ ) { print}\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"->*\"\n"},{"out":"0 \n1 \n1 \n0 \n","err":"","code":"for $x (0..1) {for $y (0..1) {say $x ^ $y, \" \"}}\n"},{"out":"{sign => 0,fraction => \"1001100110011001100110011001100110011001110111111100\",exponent => \"10110011001\"}","err":"","code":"@f{qw/sign exponent fraction/} = (unpack \"b*\",(pack \"d\", 0.1)) =~ /^(\\d)(\\d{11,11})(\\d+)$/; \\%f\n"},{"out":"{sign => \"\",fraction => undef,exponent => undef}","err":"","code":"@f{qw/sign exponent fraction/} = unpack \"b*\",(pack \"d\", 0.1) =~ /^(\\d)(\\d{11,11})(\\d+)$/; \\%f\n"},{"out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂ» n-za-m|ÃÂ¢<-- HERE near column 162 at (eval 1) line 1, <STDIN> line 1.\n","code":" 'get http://ignorantdesigner.com/japh.html' =~ y â» a-z:/ â» n-za-m|â»r \n","err":""},{"out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂ¢ n-za-m ÃÂ¢<-- HERE near column 162 at (eval 1) line 1, <STDIN> line 1.\n","code":" 'get http://ignorantdesigner.com/japh.html' =~ y â¢ a-z:/ â¢ n-za-m â»â¢r \n","err":""},{"out":"ERROR: Unrecognized character \\x80; marked by <-- HERE after ÃÂ¢ n-za-m ÃÂ¢<-- HERE near column 162 at (eval 1) line 1, <STDIN> line 1.\n","code":" 'get http://ignorantdesigner.com/japh.html' =~ y â¢ a-z:/ â¢ n-za-m â¢r \n","err":""},{"out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂÃÂ¢ n-za-mÃÂ¢<-- HERE near column 161 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":" 'get http://ignorantdesigner.com/japh.html' =~ y â¢ a-z:/ â¢ n-za-mâ â¢r \n"},{"out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂ» n-za-m|ÃÂ¢<-- HERE near column 161 at (eval 1) line 1, <STDIN> line 1.\n","code":" 'get http://ignorantdesigner.com/japh.html' =~ yâ» a-z:/ â» n-za-m|â»r \n","err":""},{"code":" 'get http://ignorantdesigner.com/japh.html' =~ yâ»a-z:/â»n-za-m|â»r \n","err":"","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂÃÂ»n-za-m|ÃÂ¢<-- HERE near column 158 at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":" 'get http://ignorantdesigner.com/japh.html' =~ yâ»a-z:/â»n-za-m.|â»r \n","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂ»n-za-m.|ÃÂ¢<-- HERE near column 159 at (eval 1) line 1, <STDIN> line 1.\n"},{"code":" [ 'get http://ignorantdesigner.com/japh.html' =~ y â¢ a-z: â¢ n-za-m â¢r ]\n","err":"","out":"ERROR: Unrecognized character \\x80; marked by <-- HERE after ÃÂ¢ n-za-m ÃÂ¢<-- HERE near column 163 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂÃÂ¢ n-za-mÃÂ¢<-- HERE near column 163 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":" [ 'get http://ignorantdesigner.com/japh.html' =~ y â¢ a-z:/ â¢ n-za-mâ â¢r ]\n"},{"err":"","code":"[ 'get http://ignorantdesigner.com/japh.html' =~ y â¢ a-z: â¢ n-za-m â¢ r ]\n","out":"ERROR: Unrecognized character \\x80; marked by <-- HERE after ÃÂ¢ n-za-m ÃÂ¢<-- HERE near column 163 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"trg uggc://vtabenagqrfvtare.pbz/wncu.ugzy\"]","err":"","code":"[ 'get http://ignorantdesigner.com/japh.html' =~ y/a-z/n-za-m/r ]\n"},{"code":" 'get http://ignorantdesigner.com/japh.html' =~ yâ»a-z:/â»n-za-mX|â»r \n","err":"","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂ»n-za-mX|ÃÂ¢<-- HERE near column 159 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"1","code":"'.gitattributes' eq '.gitattributes'\n","err":""},{"out":"[\"a\",\"b\",\"c\"]","err":"","code":"[ glob '{a,b,c}' ]\n"},{"out":"[\"av\",\"ap\",\"ar\",\"va\",\"vp\",\"vr\",\"pa\",\"pv\",\"pr\",\"ra\",\"rv\",\"rp\"]","err":"","code":"[grep {$_ !~ /(.)\\1/} glob \"{a,v,p,r}{a,v,p,r}\"]\n"},{"code":"[ grep { length($_) == 1 and $_ ne 0 } map - - chr, 0..255 ]\n","err":"","out":"[\"+\",\"-\",1,2,3,4,5,6,7,8,9]"},{"code":"[ grep { length(- - chr) == 1 } 0..255 ]\n","err":"","out":"[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,91,92,93,94,96,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255]"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"[ grep { length(- - chr) == 1 } 0..255; ]\n","err":""},{"err":"","code":"[ grep m|^http://(?!.*avatar)|, qw( http://assets.tumblr.com/images/default_avatar/octahedron_open_48.png http://assets.tumblr.com/images/default_avatar/cube_closed_48.png http://40.media.tumblr.com/b3e62ef833996a4ffb544ed37300807d/tumblr_nlf8czGMpJ1s61cido1_500.jpg http://40.media.tumblr.com/c0e108161497f351e40db139289b3818/tumblr_nldblnzio71s61cido1_500.jpg ) ]\n","out":"[\"http://40.media.tumblr.com/b3e62ef833996a4ffb544ed37300807d/tumblr_nlf8czGMpJ1s61cido1_500.jpg\",\"http://40.media.tumblr.com/c0e108161497f351e40db139289b3818/tumblr_nldblnzio71s61cido1_500.jpg\"]"},{"out":"[\"http://default_avatar/octa\"]","err":"","code":"[ grep m|^http://(?=.*avatar)|, qw( http://default_avatar/octa  http://40.media ) ]\n"},{"out":"[\"http://40.media\"]","code":"[ grep m|^http://(?!.*?avatar)|, qw( http://default_avatar/octa  http://40.media ) ]\n","err":""},{"out":"[\"http://40.media\"]","err":"","code":"[ grep m|^http://(?!.*avatar)|, qw( http://default_avatar/octa  http://40.media ) ]\n"},{"err":"","code":"grep { $_ ne 0 } map - - chr, 0..255\n","out":"64"},{"out":"ERROR: syntax error at (eval 1) line 1, near \";print\"\n","code":"$h={a=>1, v=>2}; {av =>{;print 1}, ap=>, ar=>, pv=>, rv=>, pr=>sub{}}\n","err":""},{"err":"","code":"$h={a=>1, v=>2}; sub calc {my %h=@_;my ($a,$v,$p,$r)=@h{qw/a v p r/};  {av =>sub {$r=$v/$a;$p=$v*$a}, ap=>sub{$v=$p/$a;$r=$v/$a}, ar=>sub{$v=$r*$a;$p=$a*$v}, pv=>sub{$a=$p/$v;$r=$v/$a}, rv=>sub{$a=$v*$r}, pr=>sub{$a=sqrt($p/$r);$v=$p/$a}}};\n","out":"{v => 2,a => 1}"},{"out":"{v => 2,a => 1}","err":"","code":"$h={a=>1, v=>2}; sub calc {my %h=@_;my ($a,$v,$p,$r)=@h{qw/a v p r/};  {av =>sub {$r=$v/$a;$p=$v*$a}, ap=>sub{$v=$p/$a;$r=$v/$a}, ar=>sub{$v=$r*$a;$p=$a*$v}, pv=>sub{$a=$p/$v;$r=$v/$a}, rv=>sub{$a=$v*$r;$p=$v*$a}, pr=>sub{$a=sqrt($p/$r);$v=$p/$a}}};\n"},{"out":"[1,2,2,2]","code":"$h={a=>1, v=>2}; sub calc {my %h=@_;my ($a,$v,$p,$r)=@h{qw/a v p r/}; my $c=join '', sort keys %h; {av =>sub {$r=$v/$a;$p=$v*$a}, ap=>sub{$v=$p/$a;$r=$v/$a}, ar=>sub{$v=$r*$a;$p=$a*$v}, pv=>sub{$a=$p/$v;$r=$v/$a}, rv=>sub{$a=$v*$r;$p=$v*$a}, pr=>sub{$a=sqrt($p/$r);$v=$p/$a}}->{$c}->(); [$a, $v, $r, $p]}; calc %$h\n","err":""},{"out":"{v => 2,a => 1}","code":"$h={a=>1, v=>2}; sub calc {my %h=@_;my ($a,$v,$p,$r)=@h{qw/a v p r/}; my $c=sort keys %h; {av =>sub {$r=$v/$a;$p=$v*$a}, ap=>sub{$v=$p/$a;$r=$v/$a}, ar=>sub{$v=$r*$a;$p=$a*$v}, pv=>sub{$a=$p/$v;$r=$v/$a}, rv=>sub{$a=$v*$r;$p=$v*$a}, pr=>sub{$a=sqrt($p/$r);$v=$p/$a}}->{$c}->(); [$a, $v, $r, $p]}\n","err":""},{"code":"$h={a=>1, v=>2}; sub calc {my %h=@_;my ($a,$v,$p,$r)=@h{qw/a v p r/}; my $c=sort keys %h; {av =>sub {$r=$v/$a;$p=$v*$a}, ap=>sub{$v=$p/$a;$r=$v/$a}, ar=>sub{$v=$r*$a;$p=$a*$v}, pv=>sub{$a=$p/$v;$r=$v/$a}, rv=>sub{$a=$v*$r;$p=$v*$a}, pr=>sub{$a=sqrt($p/$r);$v=$p/$a}}->{$c}->(); [$a, $v, $r, $p]}; calc %$h\n","err":"","out":"ERROR: Can't use an undefined value as a subroutine reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"2","err":"","code":"%h = ( -desc => 'created_at' ); \n"},{"err":"","code":"%h = ( -desc => 'created_at' ); \\%h\n","out":"{\"-desc\" => \"created_at\"}"},{"err":"","code":"hex 0x255\n","out":"1431"},{"err":"","code":"hex 0x80\n","out":"296"},{"out":"256","err":"","code":"hex 100\n"},{"code":"hex 255\n","err":"","out":"597"},{"err":"","code":"\"hi \".(v0.01)\n","out":"hi \u0000\u0001"},{"err":"","code":"\"hi \".(v0.1)\n","out":"hi \u0000\u0001"},{"err":"","code":"$holyshit < 0\n","out":""},{"code":"<- htmleval\n","err":"","out":"ERROR: Unterminated <> operator at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"1J2KAFHQk_.jpg\"]","code":" [ 'http://go2web4free.com:7004/img/users/1/1J2KAFHQk_.jpg' =~ m{[^/]+$}g ]\n","err":""},{"code":" 'http://ignorantdesigner.com/japh.html' =~ yâ»a-z:/â»n-za-m|â»r \n","err":"","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂÃÂ»n-za-m|ÃÂ¢<-- HERE near column 154 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂ»n-za-m.|ÃÂ¢<-- HERE near column 155 at (eval 1) line 1, <STDIN> line 1.\n","code":" 'http://ignorantdesigner.com/japh.html' =~ yâ»a-z:/â»n-za-m.|â»r \n","err":""},{"code":" 'http://ignorantdesigner.com/japh.html' =~ yâ»a-z:/â»n-za-mX|â»r \n","err":"","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂ»n-za-mX|ÃÂ¢<-- HERE near column 155 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't use an undefined value as a subroutine reference at (eval 1) line 1, <STDIN> line 1.\n","code":"h->{two}();  sub h { +{ one => sub { 1 }, two => sub { 2 } } } \n","err":""},{"out":"2","err":"","code":"h()->{two}();  sub h { +{ one => sub { 1 }, two => sub { 2 } } } \n"},{"out":"ERROR: Usage: UNIVERSAL::can(object-ref, method) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"huf->can(\"can\")->()\n"},{"out":"ERROR: Can't call method \"can\" on unblessed reference at (eval 1) line 1, <STDIN> line 1.\n","code":"huf->can(\"can\")->can\n","err":""},{"code":"huf->can(\"can\")->(\"can\")->(\"can\")->(\"can\")->(\"can\")->(\"can\")\n","err":"","out":"ERROR: Usage: UNIVERSAL::can(object-ref, method) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"huf->can(\"can\")->(huf => \"can\")\n","out":"sub { \"DUMMY\" }"},{"out":"sub { \"DUMMY\" }","code":"huf->can(\"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")\n","err":""},{"out":"","code":"$^I\n","err":""},{"out":"foo\n","code":"if ( '0.00' ) { say \"foo\" }\n","err":""},{"err":"","code":"if ( 0.00 ) { say \"foo\" }\n","out":"0"},{"out":"","err":"","code":"if (1 ) { last; print \"lols\"; } print \"lulz\"\n"},{"out":"lelz","err":"","code":"{ if (1 ) { last; print \"lols\"; } print \"lulz\"; } print \"lelz\"; \n"},{"out":"matched \"besaid\"\n","err":"","code":"if('besaid' =~ m/(\\w*said)/) {print qq{matched \"$1\"\\n};} \n"},{"out":"1","err":"","code":"if ( $x = \"\\0\" ) { print 1 }\n"},{"out":"_x\b_","code":"if ( $x = \"x\\b\" ) { print \"_${x}_\" }\n","err":""},{"err":"","code":"if ( $x = \"x\\b\" ) { print \"_$x_\" }\n","out":"_"},{"code":"Im a little teapot\n","err":"","out":"ERROR: Can't locate object method \"little\" via package \"teapot\" (perhaps you forgot to load \"teapot\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"[ $INC{'strict.pm'} ]\n","err":"","out":"[\"/home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/strict.pm\"]"},{"err":"","code":"inf\n","out":"bless( {sign => \"+inf\",value => [0],_p => undef,_a => undef}, 'Math::BigInt' )"},{"code":"+Inf\n","err":"","out":"Inf"},{"err":"","code":"\\%ISA;\n","out":"{}"},{"err":"","code":"is [fact htmleval [arg]]  \n","out":"ERROR: syntax error at (eval 1) line 1, near \"is [\"\n"},{"out":"[\"\"]","code":"[join '']\n","err":""},{"err":"","code":"join \"\\035\", qw/freenode.net #regex re101/\n","out":"freenode.net\u001d#regex\u001dre101"},{"out":"JSuosrtt  ahnaoctkheerr, ","err":"","code":"$_ = join '', 'a'..'y'; tr<acegikmoqsuwybdfhjlnprtvx><Just another Sort hacker,>; print\n"},{"out":"[JSuosrtt  ahnaoctkheerr, ]","code":"$_ = join '', 'a'..'y'; tr<acegikmoqsuwybdfhjlnprtvx><Just another Sort hacker,>; print \"[$_]\"\n","err":""},{"out":"ruJt tc,en hoetokarrasS h","code":"$_ = join '', 'a'..'y'; tr/cbvokujpfynsewmtdxlrgqiah/Just another Sort hacker,/; print\n","err":""},{"out":"[\"artuh(h ot anceke8J: r),s\"]","code":"[ (join '', 'a'..'y') =~ tr/sdyckamijgqbhtrfwuelnpovx/Just another :8() hacker,/r ]\n","err":""},{"err":"","code":"[ (join '', 'a'..'y') =~ tr/sdyckamijgqbhtrfwuelnpovx/Just another sort hacker,/ ]\n","out":"ERROR: Can't modify join or string in transliteration (tr///) at (eval 1) line 1, near \"tr/sdyckamijgqbhtrfwuelnpovx/Just another sort hacker,/ ]\"\n"},{"out":"[\"artuhrh ot ancekeoJs rt,s\"]","err":"","code":"[ (join '', 'a'..'y') =~ tr/sdyckamijgqbhtrfwuelnpovx/Just another sort hacker,/r ]\n"},{"out":"J,ursetk cAanHo tIhDeIrB /Pler","code":"$_ = join '', 'a'..'z', 0..3; tr!acegikmoqsuwy0231zxvtrpnljhfdb!Just Another Perl/BIDI Hacker,!; print\n","err":""},{"out":"ERROR: Search pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n","code":"$_ = join '', 'a'..'z', 0..3; tr/acegikmoqsuwy0231zxvtrpnljhfdb/Just Another Perl/BIDI Hacker,/; print\n","err":""},{"out":"bceghijklmnopqrtuvwxyz","err":"","code":"$_ = join '', 'a'..'z'; $_ =~ tr/434dfddsaaaaa//d; $_\n"},{"out":"abceghijklmnopqrtuvwxyz","code":"$_ = join '', 'a'..'z'; $_ =~ tr/434dfdds//d; $_\n","err":""},{"out":"[\"rJust anekocath ehder oUcin\"]","err":"","code":"$_ = join('', 'a'..'z','_'); tr/bcdefghknrtuvx_zywsqpomljifa/Just another Unicode hacker/; [ $_  ]\n"},{"out":"","err":"","code":"$_ = join '', 'a'..'z'; $_ =~ tr/JwG7IpBbAFr4tyoVbbECZ26HYml 5QdDjLicbhUTdvWIzsnOuRTfE9ahgam2EkDqgVSXpUNGCPID KW exU7M//d; $_\n"},{"code":"join('_', map {lc} grep {length} split /([A-Z]{1}[^A-Z]*)/)\n","err":"","out":""},{"out":"[\"Hello World\\342\\230\\203 \"]","code":"[ join '', map { pack \"c\", $_ } 72,101,108,108,111,32,87,111,114,108,100,-30,-104,-125,32]\n","err":""},{"err":"","code":"[join '|', map ref, \\*f, +{}, [], qr//,  \\'', sub{}, \\substr(\\$x, 0, 0), \\\\\"\", \\*STDOUT{FORMAT}, \\*STDIN{IO}, \\v5.10.0 ]\n","out":"[\"GLOB|HASH|ARRAY|Regexp|SCALAR|CODE|LVALUE|REF|SCALAR|REF|VSTRING\"]"},{"err":"","code":"join '', map { ucfirst lc } 'CamelCaseXMLParser' =~ /([A-Z]+[^A-Z]*)/g;\n","out":"CamelCaseXmlparser"},{"err":"","code":"join '', map { ucfirst lc } split /([A-Z]+[^A-Z]*)/, 'CamelCaseXMLParser';\n","out":"CamelCaseXmlparser"},{"out":"Camelcasexmlparser","err":"","code":"join '', map { ucfirst lc } split /([A-Z]+[^A-Z]*)/i, 'CamelCaseXMLParser';\n"},{"out":"[\"cbdafeghjiklnmoprqstvuwxy\"]","code":"[join '', sort {$|--} a..'y']\n","err":""},{"code":"[join '', sort {$|--} split //, \"suJta nohterP er lhakcer,\"]\n","err":"","out":"[\"Juts another Perl hacker,\"]"},{"code":"[join '', sort {$|--} split //, \"sutJa nohterP er lhakcer,\"]\n","err":"","out":"[\"tuJs another Perl hacker,\"]"},{"out":"[\"Just another Perl hacker,\"]","code":"[join '', sort {$|--} split //, \"tuJsa nohterP er lhakcer,\"]\n","err":""},{"code":"[ join \":\", split /../, '000202056D4C' ]\n","err":"","out":"[\"\"]"},{"out":"[\"00:0:2:0:2:0:5:6:D:4:C\"]","err":"","code":"[ join \":\", split /(?<=..)/, '000202056D4C' ]\n"},{"out":"[\"0:0:0:2:0:2:0:5:6:D:4C\"]","code":"[ join \":\", split /(?=..)/, '000202056D4C' ]\n","err":""},{"err":"","code":"[ join \":\", split /(..)/, '000202056D4C' ]\n","out":"[\":00::02::02::05::6D::4C\"]"},{"out":"","err":"","code":"join \":\", split /../, '000202056D4C'\n"},{"code":"[ join \":\", split /(?=\\w{2])/, '000202056D4C' ]\n","err":"","out":"[\"000202056D4C\"]"},{"out":"[\"0:0:0:2:0:2:0:5:6:D:4C\"]","code":"[ join \":\", split /(?=\\w{2})/, '000202056D4C' ]\n","err":""},{"out":"[\"\"]","code":"[join '', undef]\n","err":""},{"out":"ERROR: Undefined subroutine &main::JSON called at (eval 1) line 1, <STDIN> line 1.\n","code":"[ JSON() ]\n","err":""},{"out":"[\"encode_json\",\"decode_json\",\"JSON\"]","err":"","code":"\\@JSON::MaybeXS::EXPORT\n"},{"code":"keys( {} ) = 42\n","err":"","out":"ERROR: Experimental keys on scalar is now forbidden at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"[keys %DB:: ]\n","err":"","out":"[\"args\",\"sub\"]"},{"err":"","code":"'knbZw6mW5RGbCQksNDg64g==' =~ /([\\w=]{12,30})/\n","out":"1"},{"err":"","code":"length @{[10]}\n","out":"1"},{"err":"","code":"length 'barbarbarbarbarbar'\n","out":"18"},{"out":"[28]","code":"[ length 'bcdefghknrtuvx_zywsqpomljifa' ]\n","err":""},{"err":"","code":"length $holyshit < 0\n","out":""},{"err":"","code":"[length \"Just Another Perl/BIDI Hacker,\"];\n","out":"[30]"},{"out":"[25]","code":"[length \"Just another perl hacker,\"]\n","err":""},{"code":"[ length \"Just another Unicode hacker\" ]\n","err":"","out":"[27]"},{"out":"27","code":"length \"Just another Unicode hacker\"\n","err":""},{"out":"1","err":"","code":"length q|\t|\n"},{"out":"78","code":"length q|\"Added note that raw license copy/paste needs modification of copyright owner\"|\n","err":""},{"code":"length q|Croatia [Zagreb], Czechia [Brno Prague], Denmark [Aarhus Copenhagen], Equatorial Guinea [Bata Malabo], France [Lyon Marseille Nice Paris Toulouse], Gabon [Libreville Port-Gentil], Germany [Berlin Cologne Essen Frankfurt Hamburg Munich Stuttgart], Gibraltar, Hungary [Budapest Debrecen], Italy [Milan Naples Palermo Rome Turin], Liechtenstein, Luxembourg, Macedonia [Bitola Skopje], Malta [Valletta]|\n","err":"","out":"398"},{"err":"","code":"length q|Happy New Year to Albania [DurrÃ«s Tirana], Algeria [Algiers Boumerdas Oran], Andorra, Angola [Luanda N'dalatando], Austria [Graz Vienna], Belgium [Antwerp Brussels], Benin [Abomey-Calavi Porto-Novo], Bosnia and Herzegovina [Sarajevo], Cameroon [Douala YaoundÃ©], Central African Republic [Bangui Bimbo], Chad [Moundou N'Djamena], Congo-Brazzaville [Brazzaville Pointe-Noire], Congo-Kinshasa [Kikwit Kinshas|\n","out":"407"},{"err":"","code":"length q|\tif ( !$ok and $@=~/^SKIP:.+BEGIN failed--compilation aborted/si ) {|\n","out":"68"},{"out":"ERROR: Can't find string terminator \"#\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"length q# mojobar.removeClass('animated');\n","err":""},{"out":"84","code":"length q# mojobar.removeClass('animated').css({'position': 'absolute', 'top': start + 'px'});#\n","err":""},{"out":"30","code":"length q|See C<< ->new >> method for mo|\n","err":""},{"out":"[\"\\0\\0\\0\\0\\0\"]","err":"","code":"$l = \"foos\" . chr(0x220); [ $l & chr(0x80)x(length $l) ]\n"},{"out":"[\"\\0\\0\\0\\0\\200\"]","code":"$l = \"foos\" . chr(0xFA); [ $l & chr(0x80)x(length $l) ]\n","err":""},{"out":"[\"\\0\\0\\0\\0\"]","code":"$l = \"foos\"; [ $l & chr(0x80)x(length $l) ]\n","err":""},{"out":"[\"\\0\\0\\0\\0\\0\"]","code":"$l = \"fooso\"; [ $l & chr(0x80)x(length $l) ]\n","err":""},{"out":"{}","err":"","code":"\\%LoadAllMooseXDeclare::\n"},{"out":"abc","code":"local $/ = 'd'; print \"abc\"\n","err":""},{"code":"local $\\ = 'd'; print \"abc\"\n","err":"","out":"abcd"},{"out":"abc","err":"","code":"local $/ = $\\; print \"abc\"\n"},{"out":"abc\n","code":"local $\\ = $/; print \"abc\"\n","err":""},{"out":"[13]","code":"[ log(1e205 / 1e192)/log 10 ]\n","err":""},{"err":"","code":"[ log(1e205 / 1e192)/log 2 ]\n","out":"[\"43.1850652335357\"]"},{"code":"log(2**40)/log(10)\n","err":"","out":"12.0411998265592"},{"out":"I'm fucking rich, I got 0!","code":"$long_var_blah = 42;  $my_pay = $long_var_b1ah * 1000; print \"I'm fucking rich, I got $my_pay!\";\n","err":""},{"err":"","code":"[ main:: ]\n","out":"[\"main\"]"},{"code":"*main::bless = sub { print \"foo\" }; bless {}, 'Foo';\n","err":"","out":"bless( {}, 'Foo' )"},{"out":"ERROR: Can't locate object method \"foo\" via package \"main\" at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"main->foo\n"},{"out":"ERROR: Can't locate object method \"foo\" via package \"main\" at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"main->foo;\n"},{"out":"[undef]","err":"","code":"[ *main::{JSON} ]\n"},{"code":"*main::{JSON}\n","err":"","out":""},{"out":"[undef]","err":"","code":"[ *main::JSON{CODE} ]\n"},{"err":"","code":"[ map [ $_+0, $_ ], Scalar::util::dualvar 6*9, '42 (base 13)' ]\n","out":"ERROR: syntax error at (eval 1) line 1, near \"Scalar::util::dualvar 6\"\n"},{"out":"[[54,\"42 (base 13)\"]]","code":"[ map [ $_+0, $_ ], Scalar::Util::dualvar 6*9, '42 (base 13)' ]\n","err":""},{"out":"[\"args\",[],\"sub\",undef]","err":"","code":"[map --$| ? *{$_}{ARRAY} : $_, %DB:: ]\n"},{"err":"","code":"[map chr, 72,101,108,108,111,32,87,111,114,108,100,226,152,131,32]\n","out":"[\"H\",\"e\",\"l\",\"l\",\"o\",\" \",\"W\",\"o\",\"r\",\"l\",\"d\",\"\\342\",\"\\230\",\"\\203\",\" \"]"},{"code":"[map --$| ? *{$_}{CODE} : $_, %DB:: ]\n","err":"","out":"[\"args\",undef,\"sub\",undef]"},{"code":"[map --$| ? $_ : $$_, %DB:: ]\n","err":"","out":"[undef,*DB::args,undef,*DB::sub]"},{"out":"[\"args\",undef,\"sub\",undef]","err":"","code":"[map --$| ? $$_ : $_, %DB:: ]\n"},{"code":"[map --$| ? \\%$_ : $_, %DB:: ]\n","err":"","out":"[\"args\",{},\"sub\",{}]"},{"out":"[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\"+\",0,\"-\",0,0,0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,\"+A\",\"+B\",\"+C\",\"+D\",\"+E\",\"+F\",\"+G\",\"+H\",\"+I\",\"+J\",\"+K\",\"+L\",\"+M\",\"+N\",\"+O\",\"+P\",\"+Q\",\"+R\",\"+S\",\"+T\",\"+U\",\"+V\",\"+W\",\"+X\",\"+Y\",\"+Z\",0,0,0,0,\"+_\",0,\"+a\",\"+b\",\"+c\",\"+d\",\"+e\",\"+f\",\"+g\",\"+h\",\"+i\",\"+j\",\"+k\",\"+l\",\"+m\",\"+n\",\"+o\",\"+p\",\"+q\",\"+r\",\"+s\",\"+t\",\"+u\",\"+v\",\"+w\",\"+x\",\"+y\",\"+z\",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]","code":"[map { - - $_ } map chr, 0..255]\n","err":""},{"code":"[map { - - $_ }, map chr, 0..255]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"},\"\n"},{"out":"[98,110,106,117,118,103]","code":"[ map ord,  'b' => 'n', 'j' => 'u', 'v' => 'g' ]\n","err":""},{"err":"","code":"[ map ord, split //, '                                                     ' ]\n","out":"[32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32]"},{"out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"map ord, split //, '                                                     \n"},{"out":"53","code":"map ord, split //, '                                                     '\n","err":""},{"out":"[72,101,108,108,111,32,87,111,114,108,100,226,152,131,32]","err":"","code":"[map ord, split //, \"Hello Worldâ \"]\n"},{"code":"[map { pack \"c\", $_ } 72,101,108,108,111,32,87,111,114,108,100,-30,-104,-125,32]\n","err":"","out":"[\"H\",\"e\",\"l\",\"l\",\"o\",\" \",\"W\",\"o\",\"r\",\"l\",\"d\",\"\\342\",\"\\230\",\"\\203\",\" \"]"},{"code":"[map pack \"c\", 72,101,108,108,111,32,87,111,114,108,100,-30,-104,-125,32]\n","err":"","out":"[]"},{"code":"[ map ref, \\1, [], {}, sub{}, qr//,  ]\n","err":"","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\"]"},{"err":"","code":"[ map ref, \\1, [], {}, sub{}, qr//, \\*CORE::substr ]\n","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"GLOB\"]"},{"out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"CODE\"]","err":"","code":"[ map ref, \\1, [], {}, sub{}, qr//, \\&CORE::substr ]\n"},{"out":"ERROR: Not enough arguments for substr at (eval 1) line 1, near \"CORE::substr ]\"\n","code":"[ map ref, \\1, [], {}, sub{}, qr//, \\CORE::substr ]\n","err":""},{"code":"[ map ref, \\1, [], {}, sub{}, qr//, &CORE::substr ]\n","err":"","out":"ERROR: Not enough arguments for substr at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"[ map ref, \\1, [], {}, sub{}, qr//, \\(pos) ]\n","err":"","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"LVALUE\"]"},{"code":"[ map ref, \\1, [], {}, sub{}, qr//, \\(pos),  ]\n","err":"","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"LVALUE\"]"},{"code":"[ map ref, \\1, [], {}, sub{}, qr//, \\pos,  ]\n","err":"","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"LVALUE\"]"},{"out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"LVALUE\",\"VSTRING\"]","err":"","code":"[ map ref, \\1, [], {}, sub{}, qr//, \\pos, \\v1.2  ]\n"},{"out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"CODE\"]","err":"","code":"[ map ref, \\1, [], {}, sub{}, qr//, sub :lvalue{} ]\n"},{"err":"","code":"[ map ref, \\1, [], {}, sub{}, qr//, \\&substr ]\n","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"CODE\"]"},{"err":"","code":"[ map ref, \\1, [], {}, sub{}, qr//, \\substr ]\n","out":"ERROR: Not enough arguments for substr at (eval 1) line 1, near \"substr ]\"\n"},{"err":"","code":"[ map ref, \\1, [], {}, sub{}, qr//, substr ]\n","out":"ERROR: Not enough arguments for substr at (eval 1) line 1, near \"substr ]\"\n"},{"out":"ERROR: Not enough arguments for substr at (eval 1) line 1, near \"substr() \"\n","err":"","code":"[ map ref, \\1, [], {}, sub{}, qr//, substr() ]\n"},{"out":"ERROR: Not enough arguments for substr at (eval 1) line 1, near \"$_) \"\n","err":"","code":"[ map ref, \\1, [], {}, sub{}, qr//, substr($_) ]\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \") ]\"\n","err":"","code":"[ map ref, \\1, [], {}, sub{}, qr//, \\(substr($_,1) ]\n"},{"err":"","code":"[ map ref, \\1, [], {}, sub{}, qr//, \\(substr($_,1)) ]\n","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"LVALUE\"]"},{"out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"\"]","err":"","code":"[ map ref, \\1, [], {}, sub{}, qr//, substr($_, 1) ]\n"},{"err":"","code":"[ map ref, \\1, [], {}, sub{}, qr//, \\(substr($_,1,1) ]\n","out":"ERROR: syntax error at (eval 1) line 1, near \") ]\"\n"},{"err":"","code":"[ map ref, \\1, [], {}, sub{}, qr//, substr($_, 1)=1 ]\n","out":"ERROR: substr outside of string at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\"]","code":"[map ref, \\*f, +{}, [], qr//,  \\'',  ]\n","err":""},{"code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, \\\\\"\" ]\n","err":"","out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\",\"CODE\",\"REF\"]"},{"err":"","code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, sub:lvalue{}, ]\n","out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\",\"CODE\",\"CODE\"]"},{"err":"","code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, substr ''  ]\n","out":"ERROR: Not enough arguments for substr at (eval 1) line 1, near \"''  ]\"\n"},{"err":"","code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, substr(), ]\n","out":"ERROR: Not enough arguments for substr at (eval 1) line 1, near \"substr()\"\n"},{"out":"ERROR: Not enough arguments for substr at (eval 1) line 1, near \"substr()\"\nsyntax error at (eval 1) line 1, near \"\\  ]\"\n","code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, substr(),\\  ]\n","err":""},{"code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, substr(),\\ ]\n","err":"","out":"ERROR: Not enough arguments for substr at (eval 1) line 1, near \"substr()\"\nsyntax error at (eval 1) line 1, near \"\\ ]\"\n"},{"out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\",\"CODE\",\"\"]","code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, substr(\\$x, \"\", \"\", \"\"), ]\n","err":""},{"err":"","code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, \\substr(\\$x, 0, 0), ]\n","out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\",\"CODE\",\"LVALUE\"]"},{"code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, \\substr(\\$x, 0, 0), \\\\\"\" ]\n","err":"","out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\",\"CODE\",\"LVALUE\",\"REF\"]"},{"err":"","code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, substr(\\$x, 0, 0), ]\n","out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\",\"CODE\",\"\"]"},{"code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, substr(\\$x, 0, 0, 0, 0), ]\n","err":"","out":"ERROR: Too many arguments for substr at (eval 1) line 1, near \"0)\"\n"},{"err":"","code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, (substr(\\$x, 0, 0, 0) = \"foo\"), ]\n","out":"ERROR: Can't modify substr in scalar assignment at (eval 1) line 1, near \"\"foo\")\"\n"},{"out":"ERROR: Can't modify substr in scalar assignment at (eval 1) line 1, near \"\"foo\",\"\n","code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, substr(\\$x, 0, 0, 0) = \"foo\", ]\n","err":""},{"out":"ERROR: Assigned value is not a reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, (substr(\\$x, 0, 0) = \"foo\"), ]\n"},{"err":"","code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, \\substr(\\$x, 0, 0), \\\\\"\", *STDOUT{FORMAT} ]\n","out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\",\"CODE\",\"LVALUE\",\"REF\",\"\"]"},{"err":"","code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, \\substr(\\$x, 0, 0), \\\\\"\", *STDOUT{FORMAT}, *STDIN{IO} ]\n","out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\",\"CODE\",\"LVALUE\",\"REF\",\"\",\"IO::File\"]"},{"out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\",\"CODE\",\"LVALUE\",\"REF\",\"SCALAR\",\"REF\",\"VSTRING\"]","err":"","code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, \\substr(\\$x, 0, 0), \\\\\"\", \\*STDOUT{FORMAT}, \\*STDIN{IO}, \\v5.10.0 ]\n"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"[map +ref, \\*, {}, [], qr//,  \\'',  ]\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"[map ref, \\*, {}, [], qr//,  \\'',  ]\n","err":""},{"code":"[map ref, \\*, +{}, [], qr//,  \\'',  ]\n","err":"","out":"[\"\",\"ARRAY\",\"Regexp\",\"SCALAR\"]"},{"out":"[undef,\"main\",\"main\",undef,undef,undef]","err":"","code":"[ map {scalar caller $_} -1 .. 4 ]\n"},{"err":"","code":"[map ~$_, sort map ~$_, 'a'..'z']\n","out":"[\"z\",\"y\",\"x\",\"w\",\"v\",\"u\",\"t\",\"s\",\"r\",\"q\",\"p\",\"o\",\"n\",\"m\",\"l\",\"k\",\"j\",\"i\",\"h\",\"g\",\"f\",\"e\",\"d\",\"c\",\"b\",\"a\"]"},{"err":"","code":"[map { sprintf '%0.0f', $_ } -2.5, -1.5, -0.5, 0.5, 1.5, 2.5]\n","out":"[-2,-2,\"-0\",0,2,2]"},{"out":"[\"-2.500000\",\"-1.500000\",\"-0.500000\",\"0.500000\",\"1.500000\",\"2.500000\"]","code":"[map { sprintf '%0f', $_ } -2.5, -1.5, -0.5, 0.5, 1.5, 2.5]\n","err":""},{"err":"","code":"[ map sprintf('%.f', $_), 6.5, 7.5, 8.5, 11.5 ]\n","out":"[6,8,8,12]"},{"err":"","code":"[ map sprintf('%.f', $_), 6.5, 7.5, 8.5, 9.5 ]\n","out":"[6,8,8,10]"},{"out":"[8,12]","err":"","code":"[ map sprintf('%.f', $_), 8.5, 11.5 ]\n"},{"err":"","code":"[ map //'undef', 1, '', undef, 42 ]\n","out":"ERROR: syntax error at (eval 1) line 1, near \"//'undef'\"\n"},{"code":"[ map $_//'undef', 1, '', undef, 42 ]\n","err":"","out":"[1,\"\",\"undef\",42]"},{"out":"[undef,undef]","code":"[map $$_, values %DB:: ]\n","err":""},{"err":"","code":"methname {'main'} 1;\n","out":"ERROR: Can't locate object method \"methname\" via package \"main\" at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"methname {main} 1;\n","err":"","out":"ERROR: Can't locate object method \"methname\" via package \"main\" at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"1","err":"","code":" $    money   +    $    money   ==    $ $money\n"},{"code":" $    money   +    $    money   ==    $ $    money\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"$ $    money\n\"\n"},{"err":"","code":" $    money   +    $    money   ==    $$money\n","out":"1"},{"code":"my @a = 1..10; [ $a[-20], \\@a ]\n","err":"","out":"[undef,[1,2,3,4,5,6,7,8,9,10]]"},{"out":"[3,[1,2,3,4,5,6,7,8,9,10]]","err":"","code":"my @a = 1..10; [ $a[20%$#a], \\@a ]\n"},{"code":"my @a = 1..10; [ delete $a[-20], \\@a ]\n","err":"","out":"[undef,[1,2,3,4,5,6,7,8,9,10]]"},{"out":"[undef,[1,2,3,4,5,6,7,8,9,10]]","err":"","code":"my @a = 1..10; [ delete $a[20], \\@a ]\n"},{"err":"","code":"my @a = 1..10; [ delete $a[20%$#a], \\@a ]\n","out":"[3,[1,2,undef,4,5,6,7,8,9,10]]"},{"out":"3","err":"","code":"my @a = 1..3; \n"},{"err":"","code":"my @a = 1..3; \\@a\n","out":"[1,2,3]"},{"out":"[1,2,3]","code":"my @a = 1..3; each @a; \\@a\n","err":""},{"err":"","code":"my @a = 1..4; [ @a == grep $_ =~ /42/, @a ]\n","out":"[\"\"]"},{"out":"[\"\"]","err":"","code":"my @a = 1..4; [ @a == grep $_ =~ /4/, @a ]\n"},{"code":"my @a = 1..4; [ @a == grep $_, @a ]\n","err":"","out":"[1]"},{"code":"my @a = 1..4; my %h1 = map +( $_ => $_+1 ), @a[0..@a/2]; my %h2 = map +( $_ => $_+1 ), @a[@a/2-1..$#a]; [ \\%h1, \\%h2 ]\n","err":"","out":"[{1 => 2,3 => 4,2 => 3},{4 => 5,3 => 4,2 => 3}]"},{"out":"[{1 => 2,2 => 3},{4 => 5,3 => 4}]","err":"","code":"my @a = 1..4; my %h1 = map +( $_ => $_+1 ), splice @a, 0, @a/2; my %h2 = map +( $_ => $_+1 ), splice @a, @a/2-1; [ \\%h1, \\%h2 ]\n"},{"code":"my @a = 1..4; my %h1 = map +( $_ => $_+1 ), splice @a, 0, @a/2; my %h2 = map +( $_ => $_+1 ), splice @a, @a/2; [ \\%h1, \\%h2 ]\n","err":"","out":"[{1 => 2,2 => 3},{4 => 5}]"},{"out":"[2,3,4,5]","code":"my @a = 1..5; (shift @a)x3; \\@a\n","err":""},{"code":"my @a = 1..5; (shift @a)x5; \\@a\n","err":"","out":"[2,3,4,5]"},{"out":"ERROR: Not a GLOB reference at (eval 1) line 1, <STDIN> line 1.\n","code":"my $a = 'a'; my $b = \\$a; for $$b (0..5) { print $a }\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n","err":"","code":"my (  @a, @b ) = 1..10; $_%2 and push @b, delete $a[$_\n"},{"out":"ERROR: Can't declare repeat (x) in \"my\" at (eval 1) line 1, near \") =\"\n","err":"","code":"my ($a, $b, (undef) x 3, $c) = (1..10); [$a, $b, $c]\n"},{"out":"{foo => 1}","code":"my $a = {foo => 1}; sub foo {my $b={%{shift()}}; delete $b->{foo}}; foo($a); $a\n","err":""},{"out":"{}","err":"","code":"my $a = {foo => 1}; sub foo {my $b=\\%{shift()}; delete $b->{foo}}; foo($a); $a\n"},{"out":"6","code":"my @a = (grep /2/, 1..4 )[0..5];\n","err":""},{"out":"[2,undef]","code":"my @a = (grep /2/, 1..4 )[0..5]; splice @a, 2; \\@a\n","err":""},{"err":"","code":"my @a = (grep /2/, 1..4 )[0..5]; splice @a, 4; \\@a\n","out":"[2,undef,undef,undef]"},{"code":"[ ++(my $a = \"l\"), ++(my $b = \"1\") ]\n","err":"","out":"[\"m\",2]"},{"err":"","code":"my @a; { local push @a, 1 }; \\@a;\n","out":"ERROR: Can't modify push in local at (eval 1) line 1, at EOF\n"},{"out":"ERROR: Unrecognized character \\xCD; marked by <-- HERE after es/; my $a<-- HERE near column 96 at (eval 1) line 1, <STDIN> line 1.\n","code":"my $aÍ¾ print;\n","err":""},{"code":"my @a; { push (local @a), 42 }; \\@a;\n","err":"","out":"ERROR: Can't localize lexical variable @a at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"one\"]","err":"","code":"my @a = qw/one two/; [ $a['forty two'] ];\n"},{"err":"","code":"my $_ = 'asdf \"foo\"'; my $h = 0x20000; my %h; s/(([\"'])(?:[^\"']+|\\\\.|(?!\\2).)*\\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split ' '; $h = chr($h-1); s/([\\x{20000}-$h])/$h{$1}/g for @words; \\@words;\n","out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n"},{"out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n","code":"my $_ = 'asdf \"foo\"'; my $h = 0x20000; my %h; s/(([\"'])(?:[^\"']+|\\\\.|(?!\\2).)*\\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split ' ', $str; $h = chr($h-1); s/([\\x{20000}-$h])/$h{$1}/g for @words; \\@words;\n","err":""},{"err":"","code":"my $_ = 'asdf \"foo\"'; my $h = 0x20000; my %h; $str =~ s/(([\"'])(?:[^\"']+|\\\\.|(?!\\2).)*\\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split ' ', $str; $h = chr($h-1); s/([\\x{20000}-$h])/$h{$1}/g for @words; \\@words;\n","out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n"},{"err":"","code":"my $a = sub { say \"Hello World\" }; my $b = $a; $a\n","out":"sub { \"DUMMY\" }"},{"code":"my $a = sub { say \"Hello World\" }; my $b = $a; $a->();\n","err":"","out":"Hello World\n"},{"code":"my $a = sub { say \"Hello World\" }; my $b = $a; \\*$a\n","err":"","out":"ERROR: Not a GLOB reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"sub { \"DUMMY\" }","code":"my $a = sub { say \"Hello World\" }; my $b = $a; \\&$a\n","err":""},{"out":"Hello World\n","err":"","code":"my $a = sub { say \"Hello World\" }; my $b = $a; &$a\n"},{"err":"","code":"my $a = sub { say \"Hello World\" }; my $b = $a; *$a = \\(sub {say \"Goodbye Mars\"});\n","out":"ERROR: Not a GLOB reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't modify non-lvalue subroutine call of &main::__ANON__ at (eval 1) line 1, <STDIN> line 1.\n","code":"my $a = sub { say \"Hello World\" }; my $b = $a; &$a = \\(sub {say \"Goodbye Mars\"});\n","err":""},{"out":"ERROR: Can't modify non-lvalue subroutine call of &main::__ANON__ at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my $a = sub { say \"Hello World\" }; my $b = $a; &$a = \\&{sub {say \"Goodbye Mars\"}};\n"},{"out":"Goodbye Mars\nERROR: Can't modify non-lvalue subroutine call of &main::__ANON__ at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my $a = sub { say \"Hello World\" }; my $b = $a; &$a = &{sub {say \"Goodbye Mars\"}};\n"},{"out":"\\sub { \"DUMMY\" }","code":"my $a = sub { say \"Hello World\" }; my $b = $a; \\(sub {say \"Goodbye Mars\"});\n","err":""},{"out":"42\n","code":"my $bar = 42; my @foo = (12, 24, 42); say grep($_ eq $bar, @foo) ? 42 : 52;\n","err":""},{"out":"52\n","err":"","code":"my $bar = 42; my @foo = (12, 24); say grep($_ eq $bar, @foo) ? 42 : 52;\n"},{"out":"ERROR: &CORE::pop cannot be called directly at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my $c = \\&CORE::pop; my @abc = qw,a b c,; [$c->(\\@abc)]\n"},{"code":"my @chars = '$#**\\01000' =~/(.)+?([01]+)$/; \\@chars\n","err":"","out":"[\"\\\\\",\"01000\"]"},{"out":"{}","code":"my $dist = { author => [qw/foo bar/] }; my %z = ( author_id => $dist->{author} // (ref $dist->{authors} ? $dist->{authors}[0] : $dist->{authors}) // 'N/A', url => 'N/A',); \\%h\n","err":""},{"out":"{author_id => [\"foo\",\"bar\"],url => \"N/A\"}","err":"","code":"my $dist = { author => [qw/foo bar/] }; my %z = ( author_id => $dist->{author} // (ref $dist->{authors} ? $dist->{authors}[0] : $dist->{authors}) // 'N/A', url => 'N/A'); \\%z\n"},{"err":"","code":"my $foo = 'BAR!'; BEGIN { say $foo }\n","out":"\n"},{"out":"ERROR: Illegal declaration of subroutine BEGIN at (eval 1) line 1, <STDIN> line 1.\n","code":"my $foo = 'BAR!'; BEGIN say { $foo }\n","err":""},{"code":"my $foo = 'bar' =~ /ber/; [ $foo ]\n","err":"","out":"[\"\"]"},{"out":"-bar","err":"","code":"my $foo = 'bar'; -$foo\n"},{"out":"+bar","err":"","code":"my $foo = 'bar'; $foo = -$foo for 1, 2; $foo\n"},{"err":"","code":"my $foo = '-'; $foo = -$foo for 1, 2; $foo\n","out":"-"},{"err":"","code":"my $foo = ''; $foo = -$foo for 1, 2; $foo\n","out":"0"},{"out":"7","code":"my $foo = grep $_, 1..5, 'a', 'b'; $foo;\n","err":""},{"out":"5","code":"my $foo = grep $_, 1..5; $foo;\n","err":""},{"code":"my ($foo) if 0;\n","err":"","out":"0"},{"code":"my foo $x = 3; [ $x ]\n","err":"","out":"ERROR: No such class foo at (eval 1) line 1, near \"; my foo\"\n"},{"code":"my foo:: $x = 3; [ $x ]\n","err":"","out":"ERROR: No such class foo:: at (eval 1) line 1, near \"; my foo::\"\n"},{"code":"my $h = {1..4};  [$h->@{1, 3}]\n","err":"","out":"[2,4]"},{"err":"","code":"my $hash = {ref => [1, 2, 3]}; while(my $num = $hash->{ref}->\"CORE::each\") {print $num, \" => \";}\n","out":"ERROR: syntax error at (eval 1) line 1, near \"->\"CORE::each\"\"\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"->&\"\n","code":"my $hash = {ref => [1, 2, 3]}; while(my $num = $hash->{ref}->&CORE::each) {print $num, \" => \";}\n","err":""},{"code":"my %hash = ( \"Ø£\" => 1, )\n","err":"","out":"2"},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"my %hash = ( \"Ø£\" => 1\", )\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"1\"\"\"\n","code":"my %hash = ( \"Ø£\" => 1\"\", )\n","err":""},{"out":"{\"how strange\" => \"is this, anyway?\"}","code":"my %h = (a..z); ${%h}{\"how strange\"} = \"is this, anyway?\"; \\%{%h};\n","err":""},{"out":"0","code":"my @heterological_scalar; my %autological_hash;\n","err":""},{"out":"ERROR: Unmatched right curly bracket at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, at EOF\n","code":"my %h = ( foo => { bar => {ber => [boor] } } } ); my $ar = $h{foo}{bar}{ber}; push @$ar, 'foor';  \n","err":""},{"code":"my %h = ( foo => { bar => {ber => [boor] } } ); my $ar = $h{foo}{bar}{ber}; push @$ar, 'foor';  \\%h\n","err":"","out":"{foo => {bar => {ber => [\"boor\",\"foor\"]}}}"},{"out":"ERROR: Unmatched right curly bracket at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, at EOF\n","code":"my %h = ( foo => { bar => {ber => [boor] } } } ); my $ar = $h{foo}{bar}{ber}; push @$ar, 'foor';  \\%h\n","err":""},{"err":"","code":"my ($home) = \"git://github.com/labster/p6-IO-Path-More.git\" =~ m[(?:git|https?)://([\\w\\.]+)/]; $home\n","out":"github.com"},{"code":"my ($home) = \"git://github.com/labster/p6-IO-Path-More.git\" =~ m[(?:git|https?)://([\\w\\.]+)/]; my ($auth, $repo_name) = $url =~ m[(?:git|https?)://$home/([^/]+)/([^/]+)\\.git];\n","err":"","out":"0"},{"err":"","code":"my ($home) = \"http://github.com/labster/p6-IO-Path-More/\" =~ m[(?:git|https?)://([\\w\\.]+)/]; $home\n","out":"github.com"},{"code":"my %h=qw/q 1 d 2 b 3/; [@h{qw/q d b/}]\n","err":"","out":"[1,2,3]"},{"code":"my $hyphenated = 'foo-bar'; *$hyphenated = sub { 'works' }; main->$hyphenated();\n","err":"","out":"works"},{"code":"my $i = 0; ++$i until charnames::viacode($i) =~ /music|note/i; chr $i;\n","err":"","out":"ÃÂÃÂ"},{"err":"","code":"my $i = 0; my $n; ++$i until ($n=charnames::viacode($i)) =~ /music|\\bnote/i; [ chr $i, $n ]\n","out":"[\"\\x{749}\",\"SYRIAC MUSIC\"]"},{"code":"my $i = 0; my $n; ++$i until ($n=charnames::viacode($i)) =~ /music|note/i; [ chr $i, $n ]\n","err":"","out":"[\"\\x{602}\",\"ARABIC FOOTNOTE MARKER\"]"},{"out":"T}}","err":"","code":"my $j = 'Foo'; $j =~ tr/\\x20-\\x7f/\\xff00-\\xff5f/; binmode STDOUT; print $j;\n"},{"code":"my $j = 'Foo'; $j =~ tr/\\x20-\\x7f/\\xff0x-\\xff5f/; binmode STDOUT; print $j;\n","err":"","out":"ÂÃÃ"},{"out":"T}}","err":"","code":"my $j = 'Foo'; $j =~ tr/\\x20-\\x7f/\\xff10-\\xff5f/; binmode STDOUT; print $j;\n"},{"code":"my $j = 'Foo'; $j =~ tr/\\x20-\\x7f/\\xff20-\\xff5f/; binmode STDOUT; print $j;\n","err":"","out":"T}}"},{"err":"","code":"my $j = 'Foo'; $j =~ tr/\\x20-\\xff/\\xff10-\\xff5f/; binmode STDOUT; print $j;\n","out":"T}}"},{"out":"T}}","err":"","code":"my $j = 'Foo'; $j =~ tr/\\x20-\\xff/\\xff10-\\xffff/; binmode STDOUT; print $j;\n"},{"err":"","code":"my $j = 'Just another Perl/Unicode Hacker,'; $j =~ tr/\\x00-\\xff/\\xff00-\\xffff/; binmode STDOUT;  $j;\n","out":"xÂ£Â¡Â¢NÂÂÂÂ¢ÂÂÂ N~ÂÂ Â]ÂÂÂÂÂÂÂNvÂÂÂÂÂ Z"},{"out":"xÂ£Â¡Â¢NÂÂÂÂ¢ÂÂÂ N~ÂÂ Â]ÂÂÂÂÂÂÂNvÂÂÂÂÂ Z","code":"my $j = 'Just another Perl/Unicode Hacker,'; $j =~ tr/\\x00-\\xff/\\xff00-\\xffff/; binmode STDOUT; print $j;\n","err":""},{"code":"my $j = 'Just another Perl/Unicode Hacker,'; $j =~ tr/\\x00-\\xff/\\xff00-\\xffff/; $j;\n","err":"","out":"xÃÂ£ÃÂ¡ÃÂ¢NÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ N~ÃÂÃÂ ÃÂ]ÃÂÃÂÃÂÃÂÃÂÃÂÃÂNvÃÂÃÂÃÂÃÂÃÂ Z"},{"err":"","code":"my $j = 'Just another Perl/Unicode Hacker,'; $j =~ tr/\\x20-\\x7f/\\xff00-\\xff5f/; binmode STDOUT; print $j;\n","out":"XÂÂÂÃ¿o|}ÂvsÂÃ¿^sÂz=c|wq}rsÃ¿VoqysÂ:"},{"err":"","code":"my $l = 0; [ 0 << 2 ]\n","out":"[0]"},{"out":"[2]","err":"","code":"my $l = 0; [ 1 << 1 ]\n"},{"err":"","code":"my $l = 0; [ 1 << 2 ]\n","out":"[4]"},{"err":"","code":"my $l = 0; [ 1 << 2  << 2]\n","out":"[16]"},{"code":"my $l = 0; [ 2 << 1 ]\n","err":"","out":"[4]"},{"out":"[6]","code":"my $l = 0; [ 3 << 1 ]\n","err":""},{"out":"[12]","code":"my $l = 0; [ 3 << 2 ]\n","err":""},{"code":"my $l = 0; [ sprintf('b', 3), sprintf('b', 3 << 1) ]\n","err":"","out":"[\"b\",\"b\"]"},{"out":"ERROR: Experimental shift on scalar is now forbidden at (eval 1) line 1, at EOF\n","err":"","code":"my $lambda = sub { shift @_+1 }; @a=1..4; [{map{$_=>$lambda->($_)}@a[0..@a/2-1]},{map{$_=>$lambda->($_)}@a[@a/2..$#a]}]\n"},{"out":"[{1 => 2,2 => 3},{4 => 5,3 => 4}]","err":"","code":"my $lambda = sub { shift()+1 }; @a=1..4; [{map{$_=>$lambda->($_)}@a[0..@a/2-1]},{map{$_=>$lambda->($_)}@a[@a/2..$#a]}]\n"},{"out":"ERROR: Type of arg 1 to shift must be array (not constant item) at (eval 1) line 1, at EOF\n","code":"my $lambda = sub { shift+1 }; @a=1..4; [{map{$_=>$lambda->($_)}@a[0..@a/2-1]},{map{$_=>$lambda->($_)}@a[@a/2..$#a]}]\n","err":""},{"err":"","code":"my main $x = 3; [ $x ]\n","out":"[3]"},{"out":"[\"|1|2a|3abc\"]","err":"","code":"my $n = 3; my $str = q(|1|2a|3abc|4abcd|5abcde); [join q(|), (split /\\|/, $str)[0..$n]];\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"CORE::GLOBAL::print \"foo\"\"\n","err":"","code":"{my $print = \\&CORE::GLOBAL::print; *CORE::GLOBAL::print = sub { $print->(\"wut wut: \", @_)}}; CORE::GLOBAL::print \"foo\"\n"},{"out":"foo","err":"","code":"{my $print = \\&CORE::GLOBAL::print; *CORE::GLOBAL::print = sub { $print->(\"wut wut: \", @_)}}; CORE::print \"foo\"\n"},{"err":"","code":"{my $print = \\&CORE::GLOBAL::print; *CORE::GLOBAL::print = sub { $print->(\"wut wut: \", @_)}}; print \"foo\"\n","out":"foo"},{"out":"ERROR: Undefined subroutine &CORE::GLOBAL::print called at (eval 1) line 1, <STDIN> line 1.\n","code":"my $print = \\&CORE::GLOBAL::print; sub myprint {$print->(\"I don't wanna\");}; *CORE::GLOBAL::print = &myprint; print \"foo\"\n","err":""},{"out":"foo","code":"{my $print = \\&CORE::print; *CORE::GLOBAL::print = sub { $print->(\"wut wut: \", @_)}}; print \"foo\"\n","err":""},{"out":"ERROR: Can't modify reference to ref-to-glob cast in scalar assignment at (eval 1) line 1, at EOF\n","err":"","code":"{my $print = \\&CORE::print; \\*CORE::GLOBAL::print = sub { $print->(\"wut wut: \", @_)}}; print \"foo\"\n"},{"out":"ERROR: Not a CODE reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my $print = \\*CORE::print; sub myprint {$print->(\"I don't wanna\");}; *CORE::GLOBAL::print = &myprint; print \"foo\"\n"},{"out":"ERROR: Undefined subroutine &CORE::print called at (eval 1) line 1, <STDIN> line 1.\n","code":"my $print = \\&CORE::print; sub myprint {$print->(\"I don't wanna\");}; *CORE::GLOBAL::print = &myprint; print \"foo\"\n","err":""},{"out":"foo","err":"","code":"{my $print = \\&CORE::print; sub print { $print->(\"wut wut: \", @_)}}; print \"foo\"\n"},{"err":"","code":"{my $print = \\&CORE::print; sub print { $print->(\"wut wut: \", @_}}; print \"foo\"\n","out":"ERROR: syntax error at (eval 1) line 1, at EOF\n"},{"out":"ERROR: Can't use global $_ in \"my\" at (eval 1) line 1, near \"my $_ \"\n","err":"","code":"my $_ = q,asdf \"foo\"='bar baz',; my $h = 0x20000; my %h; s/(([\"'])(?:[^\"']+|\\\\.|(?!\\2).)*\\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split ' '; $h = chr($h-1); s/([\\x{20000}-$h])/$h{$1}/g for @words; \\@words;\n"},{"out":"[{t => \"Foo bar \"},{t => \"meow\",shiny => 1},{t => \" lulz  !!mooo!!\"}]","code":"my $rule = qr/!!(.+?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; my @s; { my @bits = split /$rule/, $s, 2; push @s, @bits == 1 ? { t => $bits[0] } : ( { t => $bits[0]}, { t => $bits[1], shiny => 1 }, { t => $bits[2] } );  last if @bits == 1; $s =~ s/$rule//; } \\@s\n","err":""},{"err":"Out of memory!\n","code":"my $rule = qr/!!(.+?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; my @s; { my @bits = split /$rule/, $s, 2; push @s, @bits == 1 ? { t => $bits[0] } : ( { t => $bits[0]}, { t => $bits[1], shiny => 1 }, { t => $bits[2] } );  redo unless @bits == 1} \\@s\n","out":""},{"err":"","code":"my $rule = qr/!!(.+?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; my @s; { my @bits = split /$rule/, $s, 2; push @s, @bits == 1 ? { t => $bits[0] } : ( { t => $bits[0]}, { t => $bits[1], shiny => 1 }, { t => $bits[2] } ); } \\@s\n","out":"[{t => \"Foo bar \"},{t => \"meow\",shiny => 1},{t => \" lulz  !!mooo!!\"}]"},{"err":"","code":"my $rule = qr/!!(.+?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; my @s; { my @bits = split /$rule/, $s, 2; push @s, @bits == 1 ? { t => $bits[0] } : ( { t => $bits[0]}, { t => $bits[1] }, { t => $bits[2] } ); } \\@s\n","out":"[{t => \"Foo bar \"},{t => \"meow\"},{t => \" lulz  !!mooo!!\"}]"},{"out":"ERROR: Missing right curly or square bracket at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, at EOF\n","err":"","code":"my $rule = qr/!!(.+?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; my @s; { my @bits = split /$rule/, $s, 2; push @s, @bits == 1 ? { t => $bits[0] } : ( { t => $bits[0]}, { t => $bits[1] }, { t => $bits[2] } ); \\@s\n"},{"out":"[\"Foo bar !!meow!! lulz  !!mooo!!\"]","code":"my $rule = qr/!!(.?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; [  split /$rule/, $s ]\n","err":""},{"out":"[\"Foo bar !!meow!! lulz  !!mooo!!\"]","code":"my $rule = qr/!!(.?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; [  split $rule, $s ]\n","err":""},{"code":"my $rule = qr/!!(.+?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; [  split /$rule/, $s ]\n","err":"","out":"[\"Foo bar \",\"meow\",\" lulz  \",\"mooo\"]"},{"code":"my $rule = qr/!!(.+?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; [  split /$rule/, $s, 1 ]\n","err":"","out":"[\"Foo bar !!meow!! lulz  !!mooo!!\"]"},{"err":"","code":"my $rule = qr/!!(.+?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; [  split /$rule/, $s, 2 ]\n","out":"[\"Foo bar \",\"meow\",\" lulz  !!mooo!!\"]"},{"out":"{}","code":"my %seen; $seen{foo}; $seen{bar}; \\%seen\n","err":""},{"code":"my %seen; $seen{''} //= keys(%seen); print $seen{''}.\"\\n\";\n","err":"","out":"1\n"},{"err":"","code":"my %seen; $test=\"one\"; $seen{$test} //= [keys(%seen)]; \\%seen\n","out":"{one => [\"one\"]}"},{"out":"[\"a\",2,3]","err":"","code":"my $self; $self->{messages} = [1,2,3]; $self->{messages}->[0] = \"a\"; $self->{messages}\n"},{"out":"[undef]","err":"","code":"my $stash = \\%{ __PACKAGE__ . \"::\" } ; sub foo { 42 }; [ $main->{foo} ]\n"},{"out":"[sub { \"DUMMY\" }]","err":"","code":"my $stash = \\%{ __PACKAGE__ . \"::\" } ; sub foo { 42 }; [ $stash->{foo} ]\n"},{"code":"my sub stat;\n","err":"","out":""},{"code":"my sub stat { 1.3 }; [ stat ]\n","err":"","out":"[\"1.3\"]"},{"out":"Ã¯Â¼Â¹Ã¯Â¼Â¯Ã¯Â¼Âµ  Ã¯Â¼Â¨Ã¯Â¼Â¡Ã¯Â¼Â¶Ã¯Â¼Â¥","err":"","code":"my $t = 'ï¼¹ï¼¯ï¼µ  ï¼¨ï¼¡ï¼¶ï¼¥'; binmode STDOUT;  $t;\n"},{"out":"[\"gi|300707803|ref|XP_002996096.1|hypothetical protein NCER_100860 \",\"Nosema ceranae BRL01] >gi|239605364|gb|EEQ82425.1| hypothetical protein NCER_100860 \"]","code":"my @tmp; $tmp[3] = \"gi|300707803|ref|XP_002996096.1|hypothetical protein NCER_100860 [Nosema ceranae BRL01] >gi|239605364|gb|EEQ82425.1| hypothetical protein NCER_100860 [Nosema ceranae BRL01]\"; my($ia,$ib) = split(/\\[/,$tmp[3]); [ $ia, $ib]\n","err":""},{"code":"my $t = 'ï¼¹ï¼¯ï¼µ  ï¼¨ï¼¡ï¼¶ï¼¥'; $t;\n","err":"","out":"ÃÂ¯ÃÂ¼ÃÂ¹ÃÂ¯ÃÂ¼ÃÂ¯ÃÂ¯ÃÂ¼ÃÂµ  ÃÂ¯ÃÂ¼ÃÂ¨ÃÂ¯ÃÂ¼ÃÂ¡ÃÂ¯ÃÂ¼ÃÂ¶ÃÂ¯ÃÂ¼ÃÂ¥"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"/./pos $u\"\n","code":"my $u = 'ABC'; say $u =~ /./pos $u/ger;\n","err":""},{"err":"","code":"my $u = 'ABC'; say $u =~ s/./pos $u/ger;\n","out":"\n"},{"out":"[undef,undef]","code":"my $url = \"http://github.com/labster/p6-IO-Path-More/\"; my ($auth, $repo_name) = $url =~ m[(?:git|https?)://$home/([^/]+)/([^/]+)\\.git]; [ $auth, $repo_name ]\n","err":""},{"out":"[undef,undef]","code":"my $url = \"http://github.com/labster/p6-IO-Path-More/\"; my ($home) = $url =~ m[(?:git|https?)://([\\w\\.]+)/]; my ($auth, $repo_name) = $url =~ m[(?:git|https?)://$home/([^/]+)/([^/]+)\\.git]; [ $auth, $repo_name ]\n","err":""},{"out":"[\"github.com\",undef,undef]","err":"","code":"my $url = \"http://github.com/labster/p6-IO-Path-More/\"; my ($home) = $url =~ m[(?:git|https?)://([\\w\\.]+)/]; my ($auth, $repo_name) = $url =~ m[(?:git|https?)://$home/([^/]+)/([^/]+)\\.git]; [ $home, $auth, $repo_name ]\n"},{"out":"pwned\n","code":"my ( $user, $nick ) = ( 'root', 'ro.+' ); if($user =~ /^$nick$/){ say 'pwned' }\n","err":""},{"code":"my ( $user, $nick ) = ( 'root', 'ro.+' ); if($user =~ /^$nick$/){ say 'pwned' } else { say 'you are not root' }\n","err":"","out":"pwned\n"},{"code":"my utf8 $x = 3; [ $x ]\n","err":"","out":"[3]"},{"err":"","code":"my @vals = (0); [pack(\"C*\", @vals)];\n","out":"[\"\\0\"]"},{"err":"","code":"my $x = 0.1 + 0.2; [ $x,  (\"$x\" == \"0.3\") ? 'y' : 'n' ]\n","out":"[\"0.3\",\"y\"]"},{"out":"[\"0.3\",\"n\"]","code":"my $x = 0.1 + 0.2; [ $x,  ($x == 0.3) ? 'y' : 'n' ]\n","err":""},{"out":"[\"Inf\",\"Inf\"]","err":"","code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 123456; [ exp $x, $y ];\n"},{"out":"[\"1323904.4924838\",\"Inf\",\"Inf\"]","err":"","code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 123456; [ $x, exp $x, $y ];\n"},{"out":"[\"Inf\",\"Inf\"]","err":"","code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 12345; [ exp $x, $y ];\n"},{"code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 12345; [ $x, exp $x, $y ];\n","err":"","out":"[\"103962.95347845\",\"Inf\",\"Inf\"]"},{"out":"[\"7554.11001047673\",\"Inf\",\"Inf\",\"NaN\"]","err":"","code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 1234; [ $x, exp $x, $y, (exp $x) - $y ];\n"},{"out":"[\"7554.11001047673\",\"Inf\",\"Inf\",0]","code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 1234; [ $x, exp $x, $y, exp $x - $y ];\n","err":""},{"code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 123; [ $x, exp $x, $y ];\n","err":"","out":"[\"472.224383926981\",\"1.21463043670265e+205\",\"1.21463043670253e+205\"]"},{"err":"","code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 123; [ $x, exp $x, $y, (exp $x) - $y ];\n","out":"[\"472.224383926981\",\"1.21463043670265e+205\",\"1.21463043670253e+205\",\"1.17625422173072e+192\"]"},{"err":"","code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 123; [ $x, exp $x, $y, $y - exp $x ];\n","out":"[\"472.224383926981\",\"1.21463043670265e+205\",\"1.21463043670253e+205\",\"-1.17625422173072e+192\"]"},{"err":"","code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 12; [ $x, exp $x, $y, $y - exp $x ];\n","out":"[\"19.9872144956619\",\"479001600.000001\",479001600,\"-1.01327896118164e-06\"]"},{"out":"123456! is a 552111 digit number","code":"my $x = 0; $x += log for 1 .. 123456; \"123456! is a \" . int($x / log 10 + .99999) . \" digit number\";\n","err":""},{"code":"my $x = 0; $x += log for 1 .. 123456; \"123456! is a \" . int($x / log 10) . \" digit number\";\n","err":"","out":"123456! is a 574964 digit number"},{"code":"my $x = 0; $x += log for 1 .. 123456; \"123456! is a \" . ($x / log 10) . \" digit number\";\n","err":"","out":"123456! is a 574964.415652639 digit number"},{"out":"123456! is a 574964.415652639","err":"","code":"my $x = 0; $x += log for 1 .. 123456; \"123456! is a \" . $x / log 10 . \" digit number\";\n"},{"err":"","code":"my $x = 0; $x += log for 1 .. 123456; [ $x, $x / log 10, $x / log 2 ];\n","out":"[\"1323904.4924838\",\"574964.415652639\",\"1909990.445917\"]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"logfor 1\"\n","err":"","code":"my $x = 0; $x += logfor 1 .. 123456; [ $x, $x / log 10, $x / log 2 ];\n"},{"out":"0.00999999999999979","err":"","code":"my $x = 10.01; $x -= 10.00; print $x\n"},{"out":"0.00999999999999979","code":"my $x = 10.01; $x -= 10; print $x\n","err":""},{"code":"my $x = [1..10]; say $x->@[2,4]\n","err":"","out":"35\n"},{"out":"[1,{x => \"z\"},2]","err":"","code":"my @x = (1, { x => z }, 2); sub foo {my @t = @_; undef @t } foo(@x); \\@x\n"},{"out":"","code":"my $x = [3, 4, 5]; for my $y (map @$_, $x) { ++$y }\n","err":""},{"out":"[3,4,5]","err":"","code":"my $x = [3, 4, 5]; for my $y (map @$_, $x) { ++$y }; $x;\n"},{"out":"45453363","code":"my $x = [3, 4, 5]; for my $y (map @$_, $x) { ++$y, ++$x }; $x;\n","err":""},{"out":"[3,4,5]","code":"my $x = [3, 4, 5]; for my $y (map @$_, $x) { ++$y, ++$y }; $x;\n","err":""},{"code":"my $x = [3, 4, 5]; for my $y (@$x) { ++$y, ++$y }; $x;\n","err":"","out":"[5,6,7]"},{"err":"","code":"my $x = 42; join ' ', ++$x, ++$x, ++$x;\n","out":"45 45 45"},{"code":"my $x = '$5.99'; $x =~ tr/0-9//cd; $x\n","err":"","out":"599"},{"err":"","code":"my $x = 5; until ( $x-- == 0 ) { print \"foos \" }\n","out":"foos foos foos foos foos "},{"out":"[\"GLOB\"]","err":"","code":"my $x = *a; [ ref \\$x ]\n"},{"err":"","code":"my $x = bless [], 'foo'; [ ref($x)->isa( 'main' ) ]\n","out":"[\"\"]"},{"out":"[\"sutJa nohterP er lhakcer,\"]","err":"","code":"my $x = \"cbdafeghjiklnmoprqstvuwxy\"; $x =~ tr/a-y/Just another Perl hacker,/; [$x];\n"},{"code":"my $x; [ defined &$x ]\n","err":"","out":"[\"\"]"},{"out":"s-foo42\n","code":"my $x = 'foo bar baz'; say 's-' . ($x =~ s/\\s.+//r) . '42'\n","err":""},{"err":"","code":"my $x = 'foo bar baz'; say 's-' . $x =~ s/\\s.+//r . '42'\n","out":"s-foo42\n"},{"out":"s-42\n","code":"my $x = 'foo bar baz'; say 's-' . ($x =~ s/\\S.+//r) . '42'\n","err":""},{"err":"","code":"my $x = 'foo bar baz'; say 's-' . $x =~ s/\\S.+//r . '42\n","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"s-42\n","err":"","code":"my $x = 'foo bar baz'; say 's-' . $x =~ s/\\S.+//r . '42'\n"},{"code":"my $x = \\*foo; $x\n","err":"","out":"\\*::foo"},{"err":"","code":"my $x = \\*foo; *$x\n","out":"*main::foo"},{"err":"","code":"my $x = '+foo'; $x =~ s/^\\+// and say \"42\";\n","out":"42\n"},{"out":"","err":"","code":"my $x = 'foo'; $x =~ s/^\\+// and say \"42\";\n"},{"code":"my @x; local $x[0] = 1; \\@x\n","err":"","out":"[]"},{"code":"my $x; local $x->[0] = 1; [ $x ]\n","err":"","out":"[[]]"},{"code":"my @x; local $x[0] = 42; \"@x\";\n","err":"","out":"42"},{"out":"[]","code":"my @x; local $x[0] = 42; \\@x\n","err":""},{"out":"ERROR: Can't localize through a reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my $x; local $$x = 1; [ $x ]\n"},{"out":"[\"SCALAR\"]","code":"my $x = \"main::a\"; [ ref \\$x ]\n","err":""},{"code":"my $x = 'nowhere'; eval { goto $x }; [ 'got', $@ ]\n","err":"","out":"[\"got\",\"Can't find label nowhere at (eval 1) line 1, <STDIN> line 1.\\n\"]"},{"err":"","code":"my $x = []; [ ref($x)->isa( 'main' ) ]\n","out":"[\"\"]"},{"code":"my $x = []; [ ref($x)->SUPER::isa( 'main' ) ]\n","err":"","out":"[\"\"]"},{"out":"[\"\\r\"]","code":"my $x = \"\\r\\n\"; chomp $x; [ $x ]\n","err":""},{"out":"\r","code":"my $x = \"\\r\\n\"; chomp $x; $x\n","err":""},{"code":"my $x = (sub { [1..3], [a..c] })->();\n","err":"","out":"[\"a\",\"b\",\"c\"]"},{"err":"","code":"my $x = []; $x->@*\n","out":"0"},{"err":"","code":"my $x; $x += 4;\n","out":"4"},{"out":"{bar => \"bar\",foo => \"foo\"}","code":"my $x = {}; $x->@{qw/foo bar/} = (\"foo\", \"bar\"); $x\n","err":""},{"err":"","code":"my $x = {}; $x->@*{qw/foo bar/} = (\"foo\", \"bar\"); $x\n","out":"ERROR: syntax error at (eval 1) line 1, near \"@*{\"\n"},{"out":"ERROR: Can't call method \"isa\" on unblessed reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"my $x = []; [ $x->SUPER::isa( 'main' ) ]\n"},{"out":"Zoooooofix","code":"my $x = 'Zoffix'; substr($x, 2, 1) = 'ooooo'; $x\n","err":""},{"out":"[\"z\\r\"]","code":"my $x = \"z\\r\\n\"; chomp $x; [ $x ]\n","err":""},{"code":"my @Z = 'a'..'z'; my @Z2; for ( @Z ) { push @Z2, $_, uc $_; } \\@Z2;\n","err":"","out":"[\"a\",\"A\",\"b\",\"B\",\"c\",\"C\",\"d\",\"D\",\"e\",\"E\",\"f\",\"F\",\"g\",\"G\",\"h\",\"H\",\"i\",\"I\",\"j\",\"J\",\"k\",\"K\",\"l\",\"L\",\"m\",\"M\",\"n\",\"N\",\"o\",\"O\",\"p\",\"P\",\"q\",\"Q\",\"r\",\"R\",\"s\",\"S\",\"t\",\"T\",\"u\",\"U\",\"v\",\"V\",\"w\",\"W\",\"x\",\"X\",\"y\",\"Y\",\"z\",\"Z\"]"},{"code":"$n == 0 + reverse $n\n","err":"","out":"1"},{"out":"No such file or directory","err":"","code":"$! = 'NaN'; $!\n"},{"err":"","code":"$! = 'NaN'; $1\n","out":""},{"err":"","code":"\"\\N{DONG SIGN}\"\n","out":"ÃÂ¢ÃÂÃÂ«"},{"out":"ERROR: Type of arg 1 to main::foo must be one of [$@] (not constant item) at (eval 1) line 1, near \"42,\"\n","err":"","code":"no feature ':all'; sub foo (;\\[$@]) { [@_] }; my %h = ( bar => foo 42, bar => meow => 'moo' );  \\%h\n"},{"err":"","code":"no feature ':all'; sub foo (+) { [@_] }; my %h = ( bar => foo 42, bar => meow => 'moo' );  \\%h\n","out":"{moo => undef,bar => \"meow\"}"},{"out":"ERROR: Too many arguments for main::foo at (eval 1) line 1, near \"'moo' )\"\n","err":"","code":"no feature ':all'; sub foo (+$) { [@_] }; my %h = ( bar => foo 42, bar => meow => 'moo' );  \\%h\n"},{"code":"no feature ':all'; sub foo (;$) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \\%h\n","err":"","out":"{meow => \"moo\",bar => [42]}"},{"err":"","code":"no feature ':all'; sub foo (;%$) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \\%h\n","out":"{bar => [42,\"meow\",\"moo\"]}"},{"out":"{bar => [42,\"x\",\"meow\",\"moo\"]}","code":"no feature ':all'; sub foo ($;@) { [@_] }; my %h = ( bar => foo 42, x => meow => 'moo' );  \\%h\n","err":""},{"err":"","code":"no feature ':all'; sub foo ($@) { [@_] }; my %h = ( bar => foo 42, x => meow => 'moo' );  \\%h\n","out":"{bar => [42,\"x\",\"meow\",\"moo\"]}"},{"err":"","code":"no feature ':all'; sub foo (+) { [@_] }; my %h = ( bar => foo 42, x => meow => 'moo' );  \\%h\n","out":"{moo => undef,x => \"meow\",bar => [42]}"},{"code":"no feature ':all'; sub foo (++) { [@_] }; my %h = ( bar => foo 42, x => meow => 'moo' );  \\%h\n","err":"","out":"ERROR: Too many arguments for main::foo at (eval 1) line 1, near \"'moo' )\"\n"},{"out":"[42]","code":"no feature ':all'; sub foo ($) { print  \"[@_]\"; }; my %h = ( bar => foo(42), meow => 'moo' ); \\%h\n","err":""},{"err":"","code":"no feature ':all'; sub foo (;$) { print \"[@_]\"; }; my %h = ( bar => foo 42, meow => 'moo' ); print Dumper \\%h\n","out":"[42]$VAR1 = {\n          'meow' => 'moo',\n          'bar' => 1\n        };\n"},{"err":"","code":"no feature ':all'; sub foo ($) { say \"[@_]\"; }; my %h = ( bar => foo(42), meow => 'moo' ); \\%h\n","out":"ERROR: syntax error at (eval 1) line 1, near \"say \"[@_]\"\"\n"},{"out":"","code":"no feature 'signatures'; sub foo (\\@) { say @_ };\n","err":""},{"out":"ERROR: Type of arg 1 to main::foo must be array (not split) at (eval 1) line 1, at EOF\n","err":"","code":"no feature 'signatures'; sub foo (\\@) { say @_ };  foo +(split //, \"foobar\")\n"},{"out":"hwERROR: hello at (eval 1) line 1, <STDIN> line 1.\n","code":"no indirect; try {print \"hw\"} catch {die \"hello\"};\n","err":"Indirect call of method \"catch\" on a block at (eval 1) line 1.\nIndirect call of method \"try\" on a block at (eval 1) line 1.\n"},{"out":"","code":"'nonexist'->import();\n","err":""},{"out":"ÃÂ°ÃÂÃÂÃÂ©","err":"","code":"\"\\N{PILE OF POO}\"\n"},{"err":"","code":"\"\\N{SNOWMAN}\"\n","out":"ÃÂ¢ÃÂÃÂ"},{"err":"","code":"\"\\N{SPARKLE}\"\n","out":"ÃÂ¢ÃÂÃÂ"},{"out":"\u0002ÃÂ¢ÃÂÃÂ\u0002ÃÂ¢ÃÂÃÂ","code":"\"\u0002\\N{SPARKLE}\u0002\\N{SPARKLE}\"\n","err":""},{"out":"\u0002ÃÂ¢ÃÂÃÂ\u0002\u001dÃÂ¢ÃÂÃÂ\u001d","code":"\"\u0002\\N{SPARKLE}\u0002\u001d\\N{SPARKLE}\u001d\"\n","err":""},{"err":"","code":"\"\u0002\\N{SPARKLE}\u0002\u001d\u0002\\N{SPARKLE}\u001d\"\n","out":"\u0002ÃÂ¢ÃÂÃÂ\u0002\u001d\u0002ÃÂ¢ÃÂÃÂ\u001d"},{"err":"","code":"'\\n' =~ /^$/ ? 'y' : 'n'\n","out":"n"},{"code":"\"\\n\" =~ /^$/ ? 'y' : 'n'\n","err":"","out":"y"},{"err":"","code":"\"\\n\" =~ /^\\z/ ? 'y' : 'n'\n","out":"n"},{"err":"","code":"[ 'o010' + 0 ]\n","out":"[0]"},{"out":"","code":"    $     OMG     =     8_0         ;$_;\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"$_$;\n\"\n","code":"    $     OMG     =     8_0         ;$_$;\n","err":""},{"code":"    $     OMG     =     8_0      ;$    OMG\n","err":"","out":"80"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"$    OMG!\"\n","err":"","code":"    $     OMG     =     8_0      ;$    OMG!\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"$    OMG\\\"\n","err":"","code":"    $     OMG     =     8_0      ;$    OMG\\\n"},{"code":"    $     OMG     =     8_0;                 $    OMG\n","err":"","out":"80"},{"code":"    $     OMG     =     8_0;    $                 OMG\n","err":"","out":"80"},{"code":"open my $fh, '<', $z; [ map ref, \\1, [], {}, sub{}, qr//, \\pos, \\v1.2, $fh ]\n","err":"","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"LVALUE\",\"VSTRING\",\"GLOB\"]"},{"err":"","code":"open my $fh, '<', $z; [ map ref, \\1, [], {}, sub{}, qr//, \\pos, \\v1.2, \\$fh ]\n","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"LVALUE\",\"VSTRING\",\"REF\"]"},{"out":"97","code":"ord 'a'\n","err":""},{"out":"88","code":"ord 'X'\n","err":""},{"out":"206","err":"","code":"ord 'Î§'\n"},{"code":"our @a; { push (local @a), 42 }; \\@a;\n","err":"","out":"[]"},{"out":"[undef]","code":"our %temp = (1,2); [ *main::{ temp } ]\n","err":""},{"err":"","code":"our %temp = (1,2); [ $main::{ 'temp' }{ HASH } ]\n","out":"[undef]"},{"out":"ERROR: Can't use an undefined value as a HASH reference at (eval 1) line 1, <STDIN> line 1.\n","code":"our %temp = (1,2); [ *main::{ 'temp' }{ HASH } ]\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n","err":"","code":"our %temp; [ $main::{ 'temp' }\n"},{"code":"our %temp; [ $main::{ 'temp' } ]\n","err":"","out":"[*::temp]"},{"err":"","code":"our %temp; [ $main::{ 'temp' }{ 'HASH' ]\n","out":"ERROR: syntax error at (eval 1) line 1, near \"'HASH' ]\"\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n"},{"code":"our %temp; [ $main::{ 'temp' }{ 'HASH' } ]\n","err":"","out":"[undef]"},{"code":"our %temp; [ $main::{ 'temp' }{ HASH } ]\n","err":"","out":"[undef]"},{"out":"ERROR: Invalid version format (non-numeric data) at (eval 1) line 1, <STDIN> line 1.\n","code":"our $VERSION = 'blah';  __PACKAGE__->VERSION\n","err":""},{"code":"%p = (1, 2); ++$$_ for \\(%p); \\%p\n","err":"","out":"{1 => 3}"},{"err":"","code":"%p = (1, 2); [ (()=%p) ]\n","out":"[]"},{"out":"[\\1,\\2]","code":"%p = (1, 2); [ \\(%p) ]\n","err":""},{"out":"[{1 => 2}]","code":"%p = (1, 2); [ \\%p, map s/\\d/3/, (()=%p) ]\n","err":""},{"out":"[{1 => 3},1,1]","code":"%p = (1, 2); [ \\%p, map s/\\d/3/, %p ]\n","err":""},{"out":"[{1 => 2},3,3]","code":"%p = (1, 2); [ \\%p, map s/\\d/3/r, %p ]\n","err":""},{"code":"%p = 1, 2; [ \\%p, map s/\\d/3/r, %p ]\n","err":"","out":"[{1 => undef},3,undef]"},{"code":"%p = 1, 2; \\%p, map s/\\d/3/r, %p\n","err":"","out":"2"},{"err":"","code":"__PACAKAGE__\n","out":"__PACAKAGE__"},{"code":"pacakge Foo; sub foo { bar() }; BEGIN { print join \",\", keys %Foo:: }; \n","err":"","out":"ERROR: Can't locate object method \"pacakge\" via package \"Foo\" at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"main","code":"__PACKAGE__\n","err":""},{"out":"Later: CHECK,quux,BEGIN","code":"package Bar; CHECK { my @early; BEGIN { @early = keys %Bar:: }; print \"CHECK: @early\" }; sub quux { 42 }; print \"Later: \", join(\",\", keys %Bar:: )\n","err":""},{"out":"Later: CHECK,quux,BEGIN","err":"","code":"package Bar; CHECK { my @early; BEGIN { @early = keys %Bar:: }; print \"@early\" }; sub quux { 42 }; print \"Later: \", join(\",\", keys %Bar:: )\n"},{"err":"","code":"package Bar; [ keys %Bar:: ]\n","out":"[]"},{"out":"[]","err":"","code":"package Bar; [ keys %Foo:: ]\n"},{"code":"package Charlie; sub talk { 'blah' }; package main; $::{'DB::Sandie::'} = $::{'Charlie::'};\n","err":"","out":"*main::Charlie::"},{"out":"ERROR: Can't locate object method \"talk\" via package \"DB::Sandie\" (perhaps you forgot to load \"DB::Sandie\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"package Charlie; sub talk { 'blah' }; package main; $::{'DB::Sandie::'} = $::{'Charlie::'}; DB::Sandie->talk\n"},{"code":"package Charlie; sub talk { 'blah' }; package main; *::{'DB::Sandie::'} = $::{'Charlie::'}; DB::Sandie->talk\n","err":"","out":"ERROR: Can't modify glob elem in scalar assignment at (eval 1) line 1, at EOF\n"},{"out":"ERROR: Can't modify glob elem in scalar assignment at (eval 1) line 1, at EOF\n","err":"","code":"package Charlie; sub talk { 'blah' }; package main; *::{'DB::Sandie::'} = *::{'Charlie::'}; DB::Sandie->talk\n"},{"out":"ERROR: Can't modify glob elem in scalar assignment at (eval 1) line 1, at EOF\n","err":"","code":"package Charlie; sub talk { 'blah' }; package main; *::{'DB::Sandie::'} = \\%$::{'Charlie::'}; DB::Sandie->talk\n"},{"code":"package Charlie; sub talk { 'blah' }; package main; *{$::{'DB::Sandie::'}} = \\%{$::{'Charlie::'}}; DB::Sandie->talk\n","err":"","out":"ERROR: Can't use an undefined value as a symbol reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't use an undefined value as a HASH reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"package Charlie; sub talk { 'blah' }; package main; *{$::{'DB::Sandie::'}} = \\%{*::{'Charlie::'}}; DB::Sandie->talk\n"},{"out":"blah","err":"","code":"package Charlie; sub talk { 'blah' }; package main; *DB::Sandie:: = *Charlie:: ; DB::Sandie->talk;\n"},{"out":"blah","err":"","code":"package Charlie; sub talk { 'blah' }; package main; local *DB::Sandie:: = *Charlie:: ; DB::Sandie->talk;\n"},{"out":"ERROR: Can't locate object method \"talk\" via package \"DB::Sandy\" (perhaps you forgot to load \"DB::Sandy\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"package Charlie; sub talk { 'blah' }; package main; local $::{'DB::Sandy::'} = $::{'Charlie::'}; DB::Sandy->talk;\n","err":""},{"code":"package Charlie; sub talk { 'blah' }; package main; local *::{'DB::Sandy::'} = *::{'Charlie::'}; DB::Sandy->talk;\n","err":"","out":"ERROR: Can't modify glob elem in local at (eval 1) line 1, near \"} =\"\n"},{"out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"package Charlie; sub talk { 'blah' }; package main; local *::{'DB::Sandy::} = *::{'Charlie::'}; DB::Sandy->talk;\n"},{"err":"","code":"package Charlie; sub talk { 'blah' }; package main; local %$::{'DB::Sandy::'} = %$::{'Charlie::'}; DB::Sandy->talk;\n","out":"ERROR: Can't modify key/value hash slice in local at (eval 1) line 1, near \"} =\"\n"},{"out":"blah","err":"","code":"package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; Charlie->talk;\n"},{"out":"ERROR: Can't locate object method \"talk\" via package \"DB::Sandie\" (perhaps you forgot to load \"DB::Sandie\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; DB::Sandie->talk;\n"},{"err":"","code":"package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; $g = $Charlie::{'::'} [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]\n","out":""},{"err":"","code":"package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; $g = *Charlie:: ; [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]\n","out":"[{talk => *Charlie::talk},\\undef,undef,\\*{'::Charlie::'}]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"*Charlie:: [\"\n","code":"package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; $g = *Charlie:: [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]\n","err":""},{"out":"","code":"package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; $g = $DB::Sandie::{'::'} [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]\n","err":""},{"out":"[{talk => *Charlie::talk},\\undef,undef,\\*{'::Charlie::'}]","code":"package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]\n","err":""},{"code":"package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]\n","err":"","out":"[{talk => *Charlie::talk},\\undef,undef,\\*{'::Charlie::'}]"},{"code":"package Charlie; sub talk { 'blah' }; package main; my $g = \\*::{'Charlie::'}; [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]\n","err":"","out":"ERROR: Not a GLOB reference at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"package Charlie; sub talk { 'blah' }; package main; print $::{'Charlie::'}\n","err":"","out":"*main::Charlie::"},{"out":"1","err":"","code":"package Charlie; sub talk { 'blah' }; package main; print *::{'Charlie::'}\n"},{"out":"[]","err":"","code":"package Foo; [ keys %Foo:: ]\n"},{"out":"[undef,\"main\",\"main\",undef,undef,undef]","code":"package Foo; [ map {scalar caller $_} -1 .. 4 ]\n","err":""},{"code":"package Foo; our $foo = 42; package main; \\%{\\Foo}::\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"}::\n\"\n"},{"err":"","code":"package Foo; our $foo = 42; package main; \\%Foo::\n","out":"{foo => *Foo::foo}"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"%{Foo}::foo\n\"\n","err":"","code":"package Foo; our $foo = 42; package main; \\%{Foo}::foo\n"},{"out":"{}","code":"package Foo; our $foo = 42; package main; \\%Foo::foo\n","err":""},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"package Foo; our $foo = 42; package main; my $z = 'Foo';  \\%\"$x\"::\n","err":""},{"code":"package Foo; our $foo = 42; package main; my $z = 'Foo';  \\%{{$x}::\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"}::\n\"\nMissing right curly or square bracket at (eval 1) line 1, at end of line\n"},{"err":"","code":"package Foo; our $foo = 42; package main; my $z = 'Foo';  \\%{$x}::\n","out":"ERROR: syntax error at (eval 1) line 1, near \"}::\n\"\n"},{"err":"","code":"package Foo; our $foo = 42; package main; my $z = 'Foo';  \\%$x::\n","out":"{}"},{"out":"ERROR: Invalid version format (non-numeric data) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"package Foo; our $VERSION = 'blah'; package main; say Foo->VERSION\n"},{"out":"[undef]","err":"","code":"package Foo; package main; [ Foo->can('import') ]\n"},{"code":"package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );\n","err":"","out":"2"},{"out":"42","code":"package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );  $x->can($foo{bar})->()\n","err":""},{"err":"","code":"package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );  $x->\"$foo{bar}\"\n","out":"ERROR: syntax error at (eval 1) line 1, near \"->\"$foo{bar}\"\"\n"},{"err":"","code":"package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );  $x->(\"$foo{bar}\")\n","out":"ERROR: Not a CODE reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"->\\\"\n","err":"","code":"package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );  $x->\\\"$foo{bar}\"\n"},{"code":"package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' ); $x->($foo{bar})\n","err":"","out":"ERROR: Not a CODE reference at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' ); $x->(\\\"$foo{bar}\")\n","out":"ERROR: Not a CODE reference at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' ); $x->(\\$foo{bar})\n","err":"","out":"ERROR: Not a CODE reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"baz","code":"package foo; sub bar {\"baz\"}; sub boo {\"boobs\"}; $a = \"bar\"; *{\"foo::\".$a}->()\n","err":""},{"out":"\\*foo::bar","code":"package foo; sub bar {\"baz\"}; sub boo {\"boobs\"}; $a = \"bar\"; \\*{\"foo::\".$a}\n","err":""},{"err":"","code":"package foo; sub bar {\"baz\"}; sub boo {\"boobs\"}; $a = \"bar\"; \\*{\"foo::\".$a}->()\n","out":"\\\"baz\""},{"out":"ERROR: Bad name after foo:: at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"package foo; sub bar {\"baz\"}; sub boo {\"boobs\"}; $a = \"bar\"; \\*{foo::$a}\n"},{"err":"","code":"package Foo; sub bar; [ grep defined &$_, keys %Foo:: ]\n","out":"[]"},{"code":"package Foo; sub bar; [ keys %Foo:: ]\n","err":"","out":"[\"bar\"]"},{"err":"","code":"package Foo; sub bar; use strict; [ grep defined &$_, keys %Foo:: ]\n","out":"[]"},{"err":"","code":"package Foo; sub foo { bar() }; BEGIN { print join \",\", keys %Foo:: }; \n","out":"BEGIN,foo,bar"},{"out":"[sub { \"DUMMY\" }]","err":"","code":"package Foo; sub import {} package main; [ Foo->can('import') ]\n"},{"err":"","code":"package FOO; sub new { return bless [42], __PACKAGE__ };  package main; use constant BAR => 'FOO';  BAR->new\n","out":"bless( [42], 'FOO' )"},{"code":"package FOO; sub new { return bless [42], __PACKAGE__;  use constant BAR => 'FOO';  BAR->new\n","err":"","out":"ERROR: Missing right curly or square bracket at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, at EOF\n"},{"err":"Out of memory!\n","code":"package foo; tie *STDOUT, 'foo'; sub TIEHANDLE { return bless {}, 'foo' } sub PRINT { CORE::print \"TEST\" } print \"hello\"\n","out":""},{"out":"","err":"Out of memory!\n","code":"package foo; tie *STDOUT, 'foo'; sub TIEHANDLE { return bless {}, 'foo' } sub PRINT { print \"TEST\" } print \"hello\"\n"},{"code":"package Foo; use overload q{\"\"} => sub {42 }; package main; my $x = bless {}, 'Foo'; 'foo'->$x\n","err":"","out":"ERROR: Can't locate object method \"42\" via package \"foo\" (perhaps you forgot to load \"foo\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"package Foo; use overload q{\"\"} => sub {42 }; package main; my $x = bless sub{ 45 }, 'Foo'; [ 'foo'->$x // 'z', \"$x\" //'z' ]\n","err":"","out":"[45,42]"},{"out":"","err":"","code":"package Foo; use overload q{\"\"} => sub {42 }; package main; my $x = bless sub{}, 'Foo'; 'foo'->$x\n"},{"out":"[42]","err":"","code":"package Foo; use overload q{\"\"} => sub {42 }; package main; my $x = bless sub{}, 'Foo'; [ 'foo'->$x, \"$x\" ]\n"},{"err":"","code":"package Foo; use overload q{\"\"} => sub {42 }; package main; my $x = bless sub{}, 'Foo'; [ 'foo'->$x, \"$x\"]\n","out":"[42]"},{"err":"","code":"package Foo; use overload q{\"\"} => sub {42 }; package main; my $x = bless sub{}, 'Foo'; [ 'foo'->$x // 'z', \"$x\" //'z' ]\n","out":"[\"z\",42]"},{"out":"[\"foo\",42]","code":"package Foo; use overload q{\"\"} => sub {42 }; package main; my $x = bless sub{ shift }, 'Foo'; [ 'foo'->$x // 'z', \"$x\" //'z' ]\n","err":""},{"err":"","code":"package Foo; use strict; use warnings; 'blah'->VERSION;\n","out":""},{"code":"package Foo; use strict; use warnings; our $VERSION = 'blah';\n","err":"","out":"blah"},{"code":"package Foo; use strict; use warnings; our $VERSION = 'blah'; package main; say Foo->VERSION\n","err":"","out":"ERROR: Invalid version format (non-numeric data) at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"package Foo; use warnings; sub foo { undef()+0 }; package main; foo();\n","err":"","out":"ERROR: Undefined subroutine &main::foo called at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"package Foo; use warnings; sub foo { undef+0 }; package main; foo();\n","err":"Warning: Use of \"undef\" without parentheses is ambiguous at (eval 1) line 1, <STDIN> line 1.\n","out":"ERROR: Can't modify constant item in undef operator at (eval 1) line 1, at EOF\n"},{"err":"Use of uninitialized value in addition (+) at (eval 1) line 1, <STDIN> line 1.\n","code":"package Foo; use warnings; sub foo { undef()+0 }; package main; Foo::foo();\n","out":"0"},{"out":"0","err":"Use of uninitialized value in addition (+) at (eval 1) line 1, <STDIN> line 1.\n","code":"package Foo; use warnings; sub foo { undef()+0 }; package main; $Foo::{'^WARNING_BITS'}=0; Foo::foo();\n"},{"out":"[1]","err":"Use of uninitialized value in addition (+) at (eval 1) line 1, <STDIN> line 1.\n","code":"package Foo; use warnings; sub foo { undef()+0 }; package main; $Foo::{'^WARNING_BITS'}=0; Foo::foo(); [1]\n"},{"code":"package Foo; use warnings; sub foo { undef()+0 }; package main; no warnings; Foo::foo();\n","err":"Use of uninitialized value in addition (+) at (eval 1) line 1, <STDIN> line 1.\n","out":"0"},{"out":"ERROR: Unknown warnings category 'Foo::uninitialized' at (eval 1) line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"package Foo; use warnings; sub foo { undef()+0 }; package main; no warnings 'Foo::uninitialized'; Foo::foo();\n","err":""},{"out":"compare","code":"package OOBLA; sub _compare {\"compare\"}; $self = bless {}; my $method = $self->can(\"_compare_\".ref $comp) || $self->can(\"_compare\"); &$method($self, \"foo\");\n","err":""},{"err":"","code":"package OOBLA; sub _compare {\"compare\"}; $self = bless {}; my $method = $self->can(\"_compare_\".ref $comp) || $self->can(\"_compare\"); &$method($self, \\\"foo\");\n","out":"compare"},{"out":"compare","code":"package OOBLA; sub _compare {\"compare\"}; sub _compare_SCALAR {\"compare_scalar\"}; my $self = bless {}; my $comp = \"foo\"; my $method = $self->can(\"_compare_\".ref $comp) || $self->can(\"_compare\"); &$method($self, $comp);\n","err":""},{"out":"compare_scalar","err":"","code":"package OOBLA; sub _compare {\"compare\"}; sub _compare_SCALAR {\"compare_scalar\"}; my $self = bless {}; my $comp = \\\"foo\"; my $method = $self->can(\"_compare_\".ref $comp) || $self->can(\"_compare\"); &$method($self, $comp);\n"},{"err":"","code":"package OOBLA; sub _compare {\"compare\"}; sub _compare_SCALAR {\"compare_scalar\"}; $self = bless {}; my $method = $self->can(\"_compare_\".ref $comp) || $self->can(\"_compare\"); &$method($self, \\\"foo\");\n","out":"compare"},{"out":"[bless( {}, 'OOBLA' ),$VAR1->[0]]","code":"package OOBLA; sub _compare_OOBLA {\"compare_OOBLA\"; \\@_}; sub _compare {\"compare\"}; sub _compare_SCALAR {\"compare_scalar\"}; my $self = bless {}; my $comp = $self; my $method = $self->can(\"_compare_\".ref $comp) || $self->can(\"_compare\"); $method->($self, $comp);\n","err":""},{"out":"compare_OOBLA","code":"package OOBLA; sub _compare_OOBLA {\"compare_OOBLA\"}; sub _compare {\"compare\"}; sub _compare_SCALAR {\"compare_scalar\"}; my $self = bless {}; my $comp = $self; my $method = $self->can(\"_compare_\".ref $comp) || $self->can(\"_compare\"); $method->($self, $comp);\n","err":""},{"out":"compare_OOBLA","code":"package OOBLA; sub _compare_OOBLA {\"compare_OOBLA\"}; sub _compare {\"compare\"}; sub _compare_SCALAR {\"compare_scalar\"}; my $self = bless {}; my $comp = $self; my $method = $self->can(\"_compare_\".ref $comp) || $self->can(\"_compare\"); &$method($self, $comp);\n","err":""},{"err":"","code":"package OOBLA; sub _compare_OOBLA {\"compare_OOBLA\"; \\@_}; sub _compare {\"compare\"}; sub _compare_SCALAR {\"compare_scalar\"}; my $self = bless {}; my $comp = $self; $self->${[\"_compare\"]}\n","out":"ERROR: Not a SCALAR reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"compare","code":"package OOBLA; sub _compare_OOBLA {\"compare_OOBLA\"; \\@_}; sub _compare {\"compare\"}; sub _compare_SCALAR {\"compare_scalar\"}; my $self = bless {}; my $comp = $self; $self->${\\(\"_compare\")}\n","err":""},{"err":"","code":"package _; use constant test => 1; [ _->test ]\n","out":"[1]"},{"err":"","code":"package Ï; package main; require Ï;\n","out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"package Ï; sub 2 {atan2(1,1) * 2}; Ï::2\n"},{"code":"package Ï; sub new { bless {}, shift } package main;   my $x = Ï->new; say $x\n","err":"","out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"package Ï; use overload fallback => 1, '+' => sub () {atan2(0,-1)}; 0+bless []\n"},{"err":"","code":"package Ï; use overload fallback => 1, '+' => sub {atan2(0,-1)}; 0+bless []\n","out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n","code":"package Ï; use overload fallback => 1, '+' => sub () {atan2(0,-1)}; ''.bless []\n","err":""},{"out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n","code":"package Ï; use overload '+' => sub () {atan2(0,-1)}; ''.bless []\n","err":""},{"out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n","code":"package Ï; use Ï;\n","err":""},{"out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n","code":"package Ï; \\*{\"Ï::2\"}\n","err":""},{"out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"package Ï; *{\"Ï::2\"} = sub {atan2(0,-1)}; Ï->${\\2}\n"},{"out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"package Ï; *{\"Ï::2\"} = sub {atan2(1,1) * 2}\n"},{"out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"package Ï; *{\"Ï::2\"} = sub {atan2(1,-1) * 2}; Ï->${\\2}\n"},{"out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n","code":"package Ï; *{\"Ï::2\"} = sub {atan2(1,1) * 2}; Ï->2\n","err":""},{"err":"","code":"package Ï; *{\"Ï::2\"} = sub {atan2(1,1) * 2}; Ï->${\\2}\n","out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"package Ï; *{\"Ï::2\"} = sub {atan2(1,1) * 2}; Ï::2\n","err":"","out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"package Ï; *{\"Ï::2\"} = sub {atan2(1,-1)}; Ï->${\\2}\n","out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n","code":"package Ï; *{\"Ï::(+\"} = sub () {atan2(0,-1)}; ''.bless []\n","err":""},{"code":"package Ï; *{\"Ï::+)\"} = sub () {atan2(0,-1)}; ''.bless []\n","err":"","out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"\\0\"]","err":"","code":"[pack(\"C*\", 0)];\n"},{"code":"pack(\"C*\", 0);\n","err":"","out":"\u0000"},{"out":"ÃÂÃÂÃÂÃÂÃÂÃÂÃÂ¹?","code":"pack \"d\", 0.1\n","err":""},{"out":"[\"\\20\"]","err":"","code":"[ pack 'H', 1 ]\n"},{"out":"@ÃÂ","code":"pack(\"H*\", 4095);\n","err":""},{"out":"Truth ","code":"pack \"H*\", \"547275746820\"\n","err":""},{"out":"Truth was the only da","code":"pack \"H*\", \"54727574682077617320746865206f6e6c79206461\"\n","err":""},{"out":"Truth was the only daughter of Time.","err":"","code":"pack \"H*\", \"54727574682077617320746865206f6e6c79206461756768746572206f662054696d652e\"\n"},{"code":"print 'â' .. 'â'\n","err":"","out":"ÃÂ¢ÃÂÃÂ"},{"err":"","code":"print 1\n","out":"1"},{"err":"","code":"print 1; 1\n","out":"1"},{"out":"1","err":"","code":"print 1; 2\n"},{"err":"","code":"print 123 =~ /[[digit]]/;\n","out":"1"},{"out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after s/; print <-- HERE near column 97 at (eval 1) line 1, <STDIN> line 1.\n","code":"print â42â\n","err":""},{"err":"","code":"print 4; 2\n","out":"4"},{"err":"","code":"print \"\\a\"\n","out":"\u0007"},{"err":"","code":"printf '[%5s]', 'x'\n","out":"[    x]"},{"code":"print \"I'm a Perl \", 5 + !!\"0\", \" program.\"\n","err":"","out":"I'm a Perl 5 program."},{"out":"ERROR: Unrecognized character \\xBE; marked by <-- HERE after  q ÃÂÃÂ¾ $a ÃÂ<-- HERE near column 106 at (eval 1) line 1, <STDIN> line 1.\n","code":"print q Í¾ $a Í¾ \n","err":""},{"code":"print qÍ¾ $aÍ¾ \n","err":"","out":"ERROR: Unrecognized character \\xBE; marked by <-- HERE after nt qÃÂÃÂ¾ $aÃÂ<-- HERE near column 104 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"foo/bar","err":"","code":"print q\u001dfoo/bar\u001d\n"},{"err":"","code":"print sort { $|-- or -1 } 'a'..'y'\n","out":"cbvokujpfynsewmtdxlrgqiah"},{"err":"","code":"print sort { $|-- or -1 } 'ruJt tc,en hoetokarrasS h'\n","out":"ruJt tc,en hoetokarrasS h"},{"out":"Just another Sort hacker,","code":"print sort { $|-- or -1 } 'ruJt tc,en hoetokarrasS h' =~ /./g\n","err":""},{"code":"print \"\\x{1f4a9}\"\n","err":"","out":"ÃÂ°ÃÂÃÂÃÂ©"},{"code":"push(@$campaigns_by_type->{$$campaign{'campaign_type'}}, $campaign);  [ $campaigns_by_type ]\n","err":"","out":"ERROR: Experimental push on scalar is now forbidden at (eval 1) line 1, near \"$campaign)\"\n"},{"out":"ERROR: Recursive inheritance detected in package 'main' at (eval 1) line 1, <STDIN> line 1.\n","code":"push @ISA, 'main'; [ main::->can('foo') ]\n","err":""},{"out":"ERROR: Unrecognized character \\xBE; marked by <-- HERE after res/; qÃÂÃÂ¾ÃÂ<-- HERE near column 95 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"qÍ¾Í¾\n"},{"out":"ERROR: Unrecognized character \\xBE; marked by <-- HERE after res/; qÃÂÃÂ¾ÃÂ<-- HERE near column 95 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"qÍ¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾\n"},{"code":"q=;$a;=;\n","err":"","out":";$a;"},{"out":";$a; ","err":"","code":"q=;$a; =;\n"},{"out":"; $a; ","code":"q =; $a; =;\n","err":""},{"code":"q =; $a; =; 5; \n","err":"","out":"5"},{"out":"ERROR: Unrecognized character \\xBE; marked by <-- HERE after  q ÃÂÃÂ¾ $a ÃÂ<-- HERE near column 117 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"q= $a = 5; print q Í¾ $a Í¾ \n"},{"out":"ERROR: Unrecognized character \\xBE; marked by <-- HERE after  q ÃÂÃÂ¾ $a ÃÂ<-- HERE near column 121 at (eval 1) line 1, <STDIN> line 1.\n","code":"q =; $a; =; 5; print q Í¾ $a Í¾ \n","err":""},{"out":"Js nte othce,utaohrSr akr","err":"","code":"$_ = q<acegikmoqsuwybdfhjlnprtvx>; tr/a-y/Just another Sort hacker,/; print\n"},{"out":"ERROR: Unrecognized character \\xBB; marked by <-- HERE after hjlnprtvxÃÂ<-- HERE near column 125 at (eval 1) line 1, <STDIN> line 1.\n","code":"$_ = qÂ«acegikmoqsuwybdfhjlnprtvxÂ»; tr/a-y/Just another Sort hacker,/; print\n","err":""},{"err":"","code":"q|{:amount($[4.95e0, 4.85e0, 2.4e0]), :description($[\"Hot beef burrito\", \"Mild fish taco\", \"Medium size orange juice\"]), :name($[\"BUBH\", \"TAFM\", \"BEOM\"]), :price($[4.95e0, 4.85e0, 1.2e0]), :quantity($[1, 1, 2])}| eq q|{:amount($[4.95e0, 4.85e0, 2.4e0]), :description($[\"Hot beef burrito\", \"Mild fish taco\", \"Medium size orange juice\"]), :name($[\"BUBH\", \"TAFM\", \"BEOM\"]), :price($[4.95e0, 4.85e0, 1.2e0]), :quantity($[1, 1, 2])}|\n","out":"1"},{"out":"ERROR: Can't find string terminator \"=\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"q= $a; print q Í¾ $a Í¾ \n"},{"err":"","code":"q = $a; print q Í¾ $a Í¾ \n","out":"ERROR: Can't find string terminator \"=\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"$a","err":"","code":"q=;$a;==~s/;//gr\n"},{"err":"","code":"q=;$a;=~s/;//r\n","out":"ERROR: syntax error at (eval 1) line 1, near \"q=;$a;=~\"\n"},{"out":"$a;","code":"q=;$a;==~s/;//r\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \";=~\"\n","err":"","code":"q=;$a;=;=~s/;//r\n"},{"code":"[ q(\\d) ]\n","err":"","out":"[\"\\\\d\"]"},{"out":"[\"echo\",\"foo\",\"bar=baz\",\"hmm=\\\"1 2 3\\\"\",\"nn='aa bb'\"]","err":"","code":"$_ = q,echo foo bar=baz hmm=\"1 2 3\" nn='aa bb',; my @h; s/(([\"'])(?:[^\"']+|\\\\.|(?!\\2).)*\\2)/push @h, $1;\"\\xFFFD\"/ge; my @words = split ' '; s/\\xFFFD/shift @h/ge for @words; \\@words;\n"},{"code":"[  q{\"foo bar \\\"something\\\"\"} =~ s/(?!<=\\\\)\"//gr ]\n","err":"","out":"[\"foo bar \\\\something\\\\\"]"},{"out":"ERROR: Unrecognized character \\x80; marked by <-- HERE after s/; q ÃÂ¢ÃÂÃÂ¤ÃÂ¢<-- HERE near column 97 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"q â¤â Happy Valentine's Day, #perl â¤â  s â¤ â¤ â¤âr\n"},{"code":"q â¤â Happy Valentine's Day, #perl â¤â  s â¤ â¤âr\n","err":"","out":"ERROR: Unrecognized character \\x80; marked by <-- HERE after s/; q ÃÂ¢ÃÂÃÂ¤ÃÂ¢<-- HERE near column 97 at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"q{Number::RGB->new_from_guess() couldn't guess type} =~ /new_from_guess() couldn't guess/ ? 'y' : 'n'\n","out":"n"},{"err":"","code":"q ð âº Perl \\o/ âº  ð\n","out":"ERROR: Unrecognized character \\x9F; marked by <-- HERE after \\o/ ÃÂ¢ÃÂÃÂº  ÃÂ°<-- HERE near column 117 at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"[ quotemeta \"~!@#$%^&*()_\\\\+?\" ]\n","err":"","out":"[\"\\\\~\\\\!\\\\\\@\\\\#0\\\\^\\\\&\\\\*\\\\(\\\\)_\\\\\\\\\\\\+\\\\?\"]"},{"out":"\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)_\\\\\\{\\}\\.\\,\\+\\?","code":"quotemeta '~!@#$%^&*()_\\\\{}.,+?'\n","err":""},{"out":"\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)_\\\\\\+\\?","code":"quotemeta '~!@#$%^&*()_\\\\+?'\n","err":""},{"out":"\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)_\\+\\?","code":"quotemeta '~!@#$%^&*()_+?'\n","err":""},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","code":"quotemeta \"Ç\n","err":""},{"out":"ÃÂ­ÃÂÃÂ","code":"quotemeta \"\\x{D000}\"\n","err":""},{"err":"","code":"({qw/ a 1 b 2/})->{b}\n","out":"2"},{"code":"{qw/ a 1 b 2/}->{b}\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"}->\"\n"},{"out":"bar","err":"","code":"qw[foo bar]\n"},{"out":"[[1,2,3,{ber => \"bez\",foo => \"bar\"}],[42,2,3,$VAR1->[0][3]]]","code":"$r = [ 1, 2, 3, { foo => bar }, ]; @a = @$r; $r->[0] = 42; $r->[3]{ber} = 'bez'; [ \\@a, $r ]\n","err":""},{"out":"","code":"readpipe q(echo foo)\n","err":""},{"out":"[\"foo\"]","err":"","code":"[ref bless [], 'foo' ]\n"},{"err":"","code":"ref &CORE::GLOBAL::print\n","out":"ERROR: Undefined subroutine &CORE::GLOBAL::print called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","code":"ref *CORE::print\n","err":""},{"out":"GLOB","code":"ref \\*CORE::print\n","err":""},{"out":"ERROR: Undefined subroutine &CORE::print called at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"ref &CORE::print\n"},{"out":"ERROR: Undefined subroutine &main::print called at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"ref &print\n"},{"err":"","code":"ref qr//\n","out":"Regexp"},{"out":"[1]","code":"[ require File::Spec ]\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"Foo::bar \"baz\"\"\n","err":"","code":"require Foo; [ Foo::bar \"baz\" ]\n"},{"err":"","code":"require Foo; [ Foo::bar( \"baz\" ) ]\n","out":"ERROR: Can't locate Foo.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"s/(A)/'lcfirst $1'/ee\n","out":""},{"out":"","code":"s/(A)/'lcfirst $1'/ee; $_\n","err":""},{"out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after res/; say <-- HERE near column 95 at (eval 1) line 1, <STDIN> line 1.\n","code":"say â\n","err":""},{"out":"\u0002\n","err":"","code":"say \"\\002\"\n"},{"out":"!(0 || 1 && (0 || 0)) && !(1 && 1)\n","err":"","code":"say \"!(0 || 1 && (0 || 0)) && !(1 && 1)\"\n"},{"code":"say '4c6567f85f0980f30987b69b78767647c2165a26' =~ /^[[:hexdigit:]]{40}$/ ? 'y' : 'n'\n","err":"","out":"ERROR: POSIX class [:hexdigit:] unknown in regex; marked by <-- HERE in m/^[[:hexdigit:] <-- HERE ]{40}$/ at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"say '4c6567f85f0980f30987b69b78767647c2165a26' =~ /^[[:xdigit:]]{40}$/ ? 'y' : 'n'\n","err":"","out":"y\n"},{"code":"say '4c6567f85f0980f30987b69b78767647c2165a26' ? 'y' : 'n'\n","err":"","out":"y\n"},{"err":"","code":"say blahblah \n","out":""},{"err":"","code":"say chr 0xFE86\n","out":"ÃÂ¯ÃÂºÃÂ\n"},{"out":"ÃÂ¢ÃÂ§ÃÂ\n","err":"","code":"say chr 10689\n"},{"out":"0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n","err":"","code":"say for 0.. 0xFF\n"},{"out":"66\n","err":"","code":"say hex 42\n"},{"out":"250\n","err":"","code":"say hex 'FA'\n"},{"out":"1\n","code":"say length chr 0xFE86\n","err":""},{"out":"1\n","err":"","code":"say length chr 10689\n"},{"code":"say length q|0.99999999999992|\n","err":"","out":"16\n"},{"code":"say length quotemeta chr 0xFE86\n","err":"","out":"1\n"},{"err":"","code":"say length quotemeta chr 10689\n","out":"2\n"},{"err":"","code":"say length \"ïº\"\n","out":"3\n"},{"code":"say \"\\N{COMBINING ACCUTE ACCENT}y\"\n","err":"","out":"ERROR: Unknown charname 'COMBINING ACCUTE ACCENT' at (eval 1) line 1, within string\n"},{"err":"","code":"say ord \"\\n\"\n","out":"10\n"},{"out":"1\n","code":"say q|{:amount($[4.95e0, 4.85e0, 2.4e0]), :description($[\"Hot beef burrito\", \"Mild fish taco\", \"Medium size orange juice\"]), :name($[\"BUBH\", \"TAFM\", \"BEOM\"]), :price($[4.95e0, 4.85e0, 1.2e0]), :quantity($[1, 1, 2])}| eq q|{:amount($[4.95e0, 4.85e0, 2.4e0]), :description($[\"Hot beef burrito\", \"Mild fish taco\", \"Medium size orange juice\"]), :name($[\"BUBH\", \"TAFM\", \"BEOM\"]), :price($[4.95e0, 4.85e0, 1.2e0]), :quantity($[1, 1, 2])}|\n","err":""},{"out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"say q|{:amount($[4.95e0, 4.85e0, 2.4e0]), :description($[\"Hot beef burrito\", \"Mild fish taco\", \"Medium size orange juice\"]), :name($[\"BUBH\", \"TAFM\", \"BEOM\"]), :price($[4.95e0, 4.85e0, 1.2e0]), :quantity($[1, 1, 2])}| eq q|{:amount($[4.95e0, 4.85e0, 2.4e0]), :description($[\"Hot beef burrito\", \"Mild fish taco\", \"Medium size orange juice\"]), :name($[\"BUBH\", \"TAFM\", \"BEOM\"]), :price($[4.95e0, 4.85e0, 1.2e0]), :quantity($[1, 1, 2])}| ? 's\n"},{"out":"Just another Sort hacker,\n","err":"","code":"say sort { $|-- or -1 } 'ruJt tc,en hoetokarrasS h' =~ /./g\n"},{"err":"","code":"say sprintf '%x', 100\n","out":"64\n"},{"out":"f\n","err":"","code":"say sprintf '%x', 15\n"},{"code":"say sprintf '%x', 16\n","err":"","out":"10\n"},{"code":"say sprintf '%x', 96\n","err":"","out":"60\n"},{"out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after res/; say <-- HERE near column 95 at (eval 1) line 1, <STDIN> line 1.\n","code":"say â * Ï\n","err":""},{"out":"[undef]","err":"","code":"[ scalar asdfadsf->import ]\n"},{"out":"5","code":"scalar grep $_, 1..5\n","err":""},{"code":"$self->{messages} = [1,2,3]; $self->{messages}->[0] = \"a\"; $self->{messages}\n","err":"","out":"[\"a\",2,3]"},{"out":"$$$","err":"","code":"$_ = '@@@'; s'@'$'gr; \n"},{"out":"ERROR: Substitution replacement not terminated at (eval 1) line 1, <STDIN> line 1.\n","code":"\"\\\\\" =~ s'\\'\\\\'gsr;\n","err":""},{"out":"\\","code":"\"\\\\\" =~ s'\\\\'\\\\'gsr;\n","err":""},{"err":"","code":"s â¤â Happy Valentine's Day, #perl â¤â â¤â â¤âr\n","out":"ERROR: Unrecognized character \\x9D; marked by <-- HERE after y, #perl ÃÂ¢<-- HERE near column 130 at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"[shift]\n","err":"","out":"[undef]"},{"err":"","code":"$SIG{__DIE__} = sub { say \"42\"; } '..'\n","out":"ERROR: syntax error at (eval 1) line 1, near \"} '..'\"\n"},{"err":"","code":"$SIG{__DIE__} = sub { say 42 };  die  \n","out":"42\nERROR: Died at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"-sin\n","out":"0"},{"out":"[\"-sin\"]","code":"[ -(sin =>)  ]\n","err":""},{"out":"[\"-sin\"]","code":"[ -sin =>  ]\n","err":""},{"err":"","code":"[ -sin  ]\n","out":"[0]"},{"out":"[\"sin\"]","code":"[ sin =>  ]\n","err":""},{"code":"\"some text [3] some more text [4] even more text\" =~ s/(?=\\[\\d+\\])/\\n/gr\n","err":"","out":"some text \n[3] some more text \n[4] even more text"},{"code":"\"some text [3] some more text [4] even more text\" =~ s/(?=\\[)/â¤/gr\n","err":"","out":"some text ÃÂ¢ÃÂÃÂ¤[3] some more text ÃÂ¢ÃÂÃÂ¤[4] even more text"},{"code":"\"some text [3] some more text [4] even more text\" =~ s/(?=[)/\\n/gr\n","err":"","out":"ERROR: Unmatched [ in regex; marked by <-- HERE in m/(?=[ <-- HERE )/ at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"some text \n[3] some more text \n[4] even more text","err":"","code":"\"some text [3] some more text [4] even more text\" =~ s/(?=\\[)/\\n/gr\n"},{"out":"[5,3,2]","code":"[sort { -1 } 5, 2, 3]\n","err":""},{"err":"","code":"[sort {--$|} a..'y']\n","out":"[\"a\",\"b\",\"d\",\"c\",\"e\",\"f\",\"h\",\"g\",\"i\",\"j\",\"l\",\"k\",\"m\",\"n\",\"p\",\"o\",\"q\",\"r\",\"t\",\"s\",\"u\",\"v\",\"x\",\"w\",\"y\"]"},{"code":"[sort {--$|} a..y]\n","err":"","out":"ERROR: Transliteration pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"c\",\"b\",\"d\",\"a\",\"f\",\"e\",\"g\",\"h\",\"j\",\"i\",\"k\",\"l\",\"n\",\"m\",\"o\",\"p\",\"r\",\"q\",\"s\",\"t\",\"v\",\"u\",\"w\",\"x\",\"y\"]","code":"[sort {$|--} a..'y']\n","err":""},{"err":"","code":"[sort { --$| or -1 } 'a'..'y']\n","out":"[\"a\",\"b\",\"u\",\"p\",\"l\",\"v\",\"i\",\"o\",\"e\",\"y\",\"m\",\"t\",\"f\",\"x\",\"n\",\"s\",\"d\",\"w\",\"k\",\"q\",\"h\",\"r\",\"j\",\"c\",\"g\"]"},{"code":"[sort { $|-- or -1 } 'a'..'y']\n","err":"","out":"[\"c\",\"b\",\"v\",\"o\",\"k\",\"u\",\"j\",\"p\",\"f\",\"y\",\"n\",\"s\",\"e\",\"w\",\"m\",\"t\",\"d\",\"x\",\"l\",\"r\",\"g\",\"q\",\"i\",\"a\",\"h\"]"},{"out":"","err":"","code":"sort { --$| or -1 } 'a'..'y'\n"},{"out":"[\"foo\",\"\",\"\",\"\",\"\",\"bar\"]","code":"[ split / /, \"foo     bar\" ]\n","err":""},{"out":"[[\"foo\",\"\",\"\",\"\",\"\",\"bar\"],[\"foo\",\"bar\"]]","code":"[[ split / /, \"foo     bar\" ], [ split ' ', \"foo     bar\" ]]\n","err":""},{"code":"[ split ' ', \"foo  \\n  bar\\nmer\\n  \"]\n","err":"","out":"[\"foo\",\"bar\",\"mer\"]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"bin sprintf\"\n","err":"","code":"[ sprintf('%020b', 4), bin sprintf('%b', 4 << 1) ]\n"},{"out":"[\"00000000000000000100\",8]","code":"[ sprintf('%020b', 4), oct '0b' .  sprintf('%b', 4 << 1) ]\n","err":""},{"code":"[ sprintf('%020b', 4), sprintf('%b', 4 << 1) ]\n","err":"","out":"[\"00000000000000000100\",1000]"},{"out":"[\".0f%\"]","err":"","code":"[ sprintf '.0f%', 8.5 ]\n"},{"err":"","code":"[ sprintf '%.0f', 8.5 ]\n","out":"[8]"},{"out":"foo foo","code":"sprintf '%1$s %1$s', 'foo'\n","err":""},{"out":"[\"                 100\",1000]","code":"[ sprintf('%20b', 4), sprintf('%b', 4 << 1) ]\n","err":""},{"err":"","code":"[ sprintf('%2b', 4), sprintf('%b', 4 << 1) ]\n","out":"[100,1000]"},{"out":"[11,110]","err":"","code":"[ sprintf('%b', 3), sprintf('%b', 3 << 1) ]\n"},{"err":"","code":"[ sprintf('b', 3), sprintf('b', 3 << 1) ]\n","out":"[\"b\",\"b\"]"},{"out":"[100,1000]","code":"[ sprintf('%b', 4), sprintf('%b', 4 << 1) ]\n","err":""},{"code":"[ sprintf '%.f', 8.5 ]\n","err":"","out":"[8]"},{"out":"[8]","err":"","code":"[ sprintf '%.f', 8.5, 11.5 ]\n"},{"err":"","code":"$_ = '@@@'; s'@'$'r; \n","out":"$@@"},{"out":"wolfrevostac","code":"$_ = \"stackoverflow\"; reverse 'catsoverflow'\n","err":""},{"out":"catsoverflow","err":"","code":"$_ = \"stackoverflow\"; reverse 'wolfrevostac'\n"},{"out":"","code":"state $x;\n","err":""},{"code":"state $x; ++$x\n","err":"","out":"1"},{"out":"n","err":"","code":"$_ = \"STDERR output success\\nSTDERR output fsuccess\\n\";  /^STDERR output success(?=.(?!STDERR output success))/ ? 'y' : 'n'\n"},{"out":"n","err":"","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STD42ERR output success(?!STDERR output success)/ ? 'y' : 'n'\n"},{"out":"y","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?=\\nSTDERR output success)/ ? 'y' : 'n'\n","err":""},{"out":"n","err":"","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?!\\nSTDERR output success)/ ? 'y' : 'n'\n"},{"out":"n","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?!.*STDERR output success)/s ? 'y' : 'n'\n","err":""},{"err":"","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success.*?(?!STDERR output success)/ ? 'y' : 'n'\n","out":"y"},{"code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success.*(?!STDERR output success)/ ? 'y' : 'n'\n","err":"","out":"y"},{"out":"n","err":"","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?=.(?!STDERR output success))/ ? 'y' : 'n'\n"},{"out":"y","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?=.*(?!STDERR output success))/ ? 'y' : 'n'\n","err":""},{"out":"n","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?=STDERR output success)/ ? 'y' : 'n'\n","err":""},{"err":"","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?!.*STDERR output success)/ ? 'y' : 'n'\n","out":"y"},{"code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?!.+STDERR output success)/ ? 'y' : 'n'\n","err":"","out":"y"},{"code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?!.+STDERR output success))/ ? 'y' : 'n'\n","err":"","out":"ERROR: Unmatched ) in regex; marked by <-- HERE in m/^STDERR output success(?!.+STDERR output success)) <-- HERE / at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?!STDERR output success)/ ? 'y' : 'n'\n","out":"y"},{"code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?.*(?!STDERR output success))/ ? 'y' : 'n'\n","err":"","out":"ERROR: Sequence (?....) not recognized in regex; marked by <-- HERE in m/^STDERR output success(?. <-- HERE *(?!STDERR output success))/ at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Too many arguments for subroutine at (eval 1) line 1.\n","code":"sub add ( $x = return 0, $y = return $x ) { return $x + $y }   [ add(), add(2), add(2,3), add(2,3,4) ]\n","err":""},{"out":"fizzbuzz","code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/ }; fizz(), buzz();\n","err":""},{"out":"fizz 2 fizz buzz 4 fizz 6 fizz buzz 8 fizz 10 fizz buzz 12 fizz 14 fizz buzz 16 fizz 18 fizz buzz 20 fizz 22 fizz buzz 24 fizz 26 fizz buzz 28 fizz 30 fizz buzz 32 fizz 34 fizz buzz 36 fizz 38 fizz buzz 40 fizz 42 fizz buzz 44 fizz 46 fizz buzz 48 fizz 50 fizz buzz 52 fizz 54 fizz buzz 56 fizz 58 fizz buzz 60 fizz 62 fizz buzz 64 fizz 66 fizz buzz 68 fizz 70 fizz buzz 72 fizz 74 fizz buzz 76 fizz 78 fizz buzz 80 fizz 82 fizz buzz 84 fizz 86 fizz buzz 88 fizz 90 fizz buzz 92 fizz 94 fizz buzz 96 fizz 98 fizz buzz 100 ","err":"","code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/, \" \" }; for(1..100) { undef($f), fizz() if 2 == ++$f; undef($b), buzz() if 4 == ++$b; $f && $b || &{$_}() }\n"},{"out":"nope 1 fizz 2 nope 3 fizz buzz 4 nope 5 fizz 6 nope 7 fizz buzz 8 nope 9 fizz 10 nope 11 fizz buzz 12 nope 13 fizz 14 nope 15 fizz buzz 16 nope 17 fizz 18 nope 19 fizz buzz 20 nope 21 fizz 22 nope 23 fizz buzz 24 nope 25 fizz 26 nope 27 fizz buzz 28 nope 29 fizz 30 nope 31 fizz buzz 32 nope 33 fizz 34 nope 35 fizz buzz 36 nope 37 fizz 38 nope 39 fizz buzz 40 nope 41 fizz 42 nope 43 fizz buzz 44 nope 45 fizz 46 nope 47 fizz buzz 48 nope 49 fizz 50 nope 51 fizz buzz 52 nope 53 fizz 54 nope 55 fizz buzz 56 nope 57 fizz 58 nope 59 fizz buzz 60 nope 61 fizz 62 nope 63 fizz buzz 64 nope 65 fizz 66 nope 67 fizz buzz 68 nope 69 fizz 70 nope 71 fizz buzz 72 nope 73 fizz 74 nope 75 fizz buzz 76 nope 77 fizz 78 nope 79 fizz buzz 80 nope 81 fizz 82 nope 83 fizz buzz 84 nope 85 fizz 86 nope 87 fizz buzz 88 nope 89 fizz 90 nope 91 fizz buzz 92 nope 93 fizz 94 nope 95 fizz buzz 96 nope 97 fizz 98 nope 99 fizz buzz 100 ","code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/, \" \" }; for(1..100) { undef($f), fizz() if 2 == ++$f; undef($b), buzz() if 4 == ++$b; $f && $b && nope(); &{$_}() }\n","err":""},{"out":"1 fizz nope 2 3 fizz buzz nope 4 5 fizz nope 6 7 fizz buzz nope 8 9 fizz nope 10 11 fizz buzz nope 12 13 fizz nope 14 15 fizz buzz nope 16 17 fizz nope 18 19 fizz buzz nope 20 21 fizz nope 22 23 fizz buzz nope 24 25 fizz nope 26 27 fizz buzz nope 28 29 fizz nope 30 31 fizz buzz nope 32 33 fizz nope 34 35 fizz buzz nope 36 37 fizz nope 38 39 fizz buzz nope 40 41 fizz nope 42 43 fizz buzz nope 44 45 fizz nope 46 47 fizz buzz nope 48 49 fizz nope 50 51 fizz buzz nope 52 53 fizz nope 54 55 fizz buzz nope 56 57 fizz nope 58 59 fizz buzz nope 60 61 fizz nope 62 63 fizz buzz nope 64 65 fizz nope 66 67 fizz buzz nope 68 69 fizz nope 70 71 fizz buzz nope 72 73 fizz nope 74 75 fizz buzz nope 76 77 fizz nope 78 79 fizz buzz nope 80 81 fizz nope 82 83 fizz buzz nope 84 85 fizz nope 86 87 fizz buzz nope 88 89 fizz nope 90 91 fizz buzz nope 92 93 fizz nope 94 95 fizz buzz nope 96 97 fizz nope 98 99 fizz buzz nope 100 ","code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/, \" \" }; for(1..100) { undef($f), fizz() if 2 == ++$f; undef($b), buzz() if 4 == ++$b; $f && $b or nope(); &{$_}() }\n","err":""},{"out":"fizz3buzz5fizz6fizz9buzz10fizz12fizzbuzz15fizz18buzz20fizz21fizz24buzz25fizz27fizzbuzz30fizz33buzz35fizz36fizz39buzz40fizz42fizzbuzz45fizz48buzz50fizz51fizz54buzz55fizz57fizzbuzz60fizz63buzz65fizz66fizz69buzz70fizz72fizzbuzz75fizz78buzz80fizz81fizz84buzz85fizz87fizzbuzz90fizz93buzz95fizz96fizz99buzz100","err":"","code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/ }; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b || &{$_}() }\n"},{"err":"","code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/ }; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b && &{$_}(); &{\" \"}() }\n","out":"1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 17 fizz 19 buzz fizz 22 23 fizz buzz 26 fizz 28 29 fizzbuzz 31 32 fizz 34 buzz fizz 37 38 fizz buzz 41 fizz 43 44 fizzbuzz 46 47 fizz 49 buzz fizz 52 53 fizz buzz 56 fizz 58 59 fizzbuzz 61 62 fizz 64 buzz fizz 67 68 fizz buzz 71 fizz 73 74 fizzbuzz 76 77 fizz 79 buzz fizz 82 83 fizz buzz 86 fizz 88 89 fizzbuzz 91 92 fizz 94 buzz fizz 97 98 fizz buzz "},{"code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/ }; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b && &$_; &{\" \"} }\n","err":"","out":"1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 17 fizz 19 buzz fizz 22 23 fizz buzz 26 fizz 28 29 fizzbuzz 31 32 fizz 34 buzz fizz 37 38 fizz buzz 41 fizz 43 44 fizzbuzz 46 47 fizz 49 buzz fizz 52 53 fizz buzz 56 fizz 58 59 fizzbuzz 61 62 fizz 64 buzz fizz 67 68 fizz buzz 71 fizz 73 74 fizzbuzz 76 77 fizz 79 buzz fizz 82 83 fizz buzz 86 fizz 88 89 fizzbuzz 91 92 fizz 94 buzz fizz 97 98 fizz buzz "},{"out":"fizz 3 buzz 5 fizz 6 fizz 9 buzz 10 fizz 12 fizz buzz 15 fizz 18 buzz 20 fizz 21 fizz 24 buzz 25 fizz 27 fizz buzz 30 fizz 33 buzz 35 fizz 36 fizz 39 buzz 40 fizz 42 fizz buzz 45 fizz 48 buzz 50 fizz 51 fizz 54 buzz 55 fizz 57 fizz buzz 60 fizz 63 buzz 65 fizz 66 fizz 69 buzz 70 fizz 72 fizz buzz 75 fizz 78 buzz 80 fizz 81 fizz 84 buzz 85 fizz 87 fizz buzz 90 fizz 93 buzz 95 fizz 96 fizz 99 buzz 100 ","code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/, \" \" }; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b || &{$_}() }\n","err":""},{"err":"","code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/, \" \" }; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b && &{$_}() }\n","out":"1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizz buzz 16 17 fizz 19 buzz fizz 22 23 fizz buzz 26 fizz 28 29 fizz buzz 31 32 fizz 34 buzz fizz 37 38 fizz buzz 41 fizz 43 44 fizz buzz 46 47 fizz 49 buzz fizz 52 53 fizz buzz 56 fizz 58 59 fizz buzz 61 62 fizz 64 buzz fizz 67 68 fizz buzz 71 fizz 73 74 fizz buzz 76 77 fizz 79 buzz fizz 82 83 fizz buzz 86 fizz 88 89 fizz buzz 91 92 fizz 94 buzz fizz 97 98 fizz buzz "},{"out":"nope 1 nope 2 fizz 3 nope 4 buzz 5 fizz 6 nope 7 nope 8 fizz 9 buzz 10 nope 11 fizz 12 nope 13 nope 14 fizz buzz 15 nope 16 nope 17 fizz 18 nope 19 buzz 20 fizz 21 nope 22 nope 23 fizz 24 buzz 25 nope 26 fizz 27 nope 28 nope 29 fizz buzz 30 nope 31 nope 32 fizz 33 nope 34 buzz 35 fizz 36 nope 37 nope 38 fizz 39 buzz 40 nope 41 fizz 42 nope 43 nope 44 fizz buzz 45 nope 46 nope 47 fizz 48 nope 49 buzz 50 fizz 51 nope 52 nope 53 fizz 54 buzz 55 nope 56 fizz 57 nope 58 nope 59 fizz buzz 60 nope 61 nope 62 fizz 63 nope 64 buzz 65 fizz 66 nope 67 nope 68 fizz 69 buzz 70 nope 71 fizz 72 nope 73 nope 74 fizz buzz 75 nope 76 nope 77 fizz 78 nope 79 buzz 80 fizz 81 nope 82 nope 83 fizz 84 buzz 85 nope 86 fizz 87 nope 88 nope 89 fizz buzz 90 nope 91 nope 92 fizz 93 nope 94 buzz 95 fizz 96 nope 97 nope 98 fizz 99 buzz 100 ","err":"","code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/, \" \" }; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b && nope(); &{$_}() }\n"},{"out":"hi","err":"","code":"sub AUTOLOAD { print \"hi\" } 'foo'->();\n"},{"out":"ERROR: Can't use an undefined value as a subroutine reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub AUTOLOAD { print \"hi\" } ${*foo}->();\n"},{"out":"hi","code":"sub AUTOLOAD { print \"hi\" } foo();\n","err":""},{"code":"sub AUTOLOAD { print \"hi\" } main->foo();\n","err":"","out":"hi"},{"code":"sub AUTOLOAD { print \"hi\" } $x=\\*foo; (&$x)->();\n","err":"","out":"ERROR: Not a CODE reference at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"sub AUTOLOAD { print \"hi\" } $x=\\*foo; $x->();\n","out":"ERROR: Not a CODE reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Not a CODE reference at (eval 1) line 1, <STDIN> line 1.\n","code":"sub AUTOLOAD { print \"hi\" } $x=\\*foo; &$x->();\n","err":""},{"code":"sub AUTOLOAD { print \"hi\" } $x = *foo; $x->();\n","err":"","out":"hi"},{"code":"sub AUTOLOAD { print \"hi\" } $x = *foo; &{$x}();\n","err":"","out":"hi"},{"out":"ERROR: Not a CODE reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub AUTOLOAD { print \"hi\" } $x = \\*foo; $x->();\n"},{"out":"hi","code":"sub AUTOLOAD { print \"hi\" } $x = \\*foo; *{$x}->();\n","err":""},{"out":"ERROR: Not a CODE reference at (eval 1) line 1, <STDIN> line 1.\n","code":"sub AUTOLOAD { print \"hi\" } $x = \\*foo; &{$x}();\n","err":""},{"code":"sub AUTOLOAD { print \"hi\" } $x = \\*foo; &{*$x}();\n","err":"","out":"hi"},{"out":"ERROR: Can't use an undefined value as a subroutine reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub AUTOLOAD { print \"hi\" } $x = *foo; *$x{CODE}->();\n"},{"out":"ERROR: Can't use an undefined value as a subroutine reference at (eval 1) line 1, <STDIN> line 1.\n","code":"sub AUTOLOAD { print \"hi\" } $x = \\*foo; *$x{CODE}->();\n","err":""},{"out":"[\"\",1]","err":"","code":"sub blah { !!@_ } [ blah, blah(1) ]\n"},{"out":"","code":"sub bubsort { my $arr = shift; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i] } }\n","err":""},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, near \"1 if\"\n","code":"sub Buffalo(;@) {return 1 if ($_[0] eq 'buffalo')}; sub buffalo {\"buffalo\"}; \n","err":""},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, near \"1 if\"\n","code":"sub Buffalo(;@) {return 1 if $_[0] eq 'buffalo'}; sub buffalo {\"buffalo\"}; \n","err":""},{"code":"sub Buffalo(;@) {return 1;}; sub buffalo {\"buffalo\"}; \n","err":"","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, at EOF\n"},{"err":"","code":"sub Buffalo(@) {return 1;}; sub buffalo {\"buffalo\"}; \n","out":""},{"out":"ERROR: Can't modify constant item in chomp at (eval 1) line 1, near \"\"x\\n\" ]\"\n","code":"sub chomp { 42 }; [chomp \"x\\n\" ]\n","err":""},{"code":"sub chomp { \"blah\" }; [ chomp ]\n","err":"","out":"[0]"},{"out":"ok[1]\n","code":"sub code; for \\&code (sub { print 'ok' }) { say '[', code, ']' }\n","err":""},{"out":"ERROR: Illegal declaration of anonymous subroutine at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub *CORE::die { say \"42\"; } die  \n"},{"err":"","code":"sub CORE::die { say \"42\"; } die  \n","out":"ERROR: Died at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Died at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub die { say \"42\"; } die  \n"},{"code":"sub { 'FILE' = 42; } say $FILE;\n","err":"","out":"ERROR: Can't modify constant item in scalar assignment at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, near \"} say\"\n"},{"out":"[\"a\",\"b\",\"c\"]","code":"sub foo { [1..3], [a..c] }; my $x = foo;\n","err":""},{"out":"","code":"sub foo {\" Hello\"}; undef &foo;\n","err":""},{"out":"ERROR: Undefined subroutine &main::foo called at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub foo {\" Hello\"}; undef &foo; foo()\n"},{"err":"","code":"sub foo :lvalue { print \"FOO!\" }  undef &foo; foo()\n","out":"ERROR: Undefined subroutine &main::foo called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[2,\\1]","code":"sub foo { my $x = 1; use constant FOO => \\$x; 2 }; [ foo, FOO ];\n","err":""},{"out":"[1,\\1]","code":"sub foo { my $x = 1; use constant FOO => \\$x }; [ foo, FOO ];\n","err":""},{"code":"sub foo { my @xs = \"a\" .. \"c\"; return (\"X\", \"Y\", @xs); }  my $x = foo; $x\n","err":"","out":"3"},{"out":"[42]","code":"sub foo { my $x = shift; use constant FOO => \\$x; 42 }; [ foo(1) ];\n","err":""},{"out":"[42,1]","code":"sub foo { my $x = shift; use constant FOO => \\$x; 42 }; [ foo(1), ${ FOO() } ];\n","err":""},{"out":"[42,1,42]","err":"","code":"sub foo { my $x = shift; use constant FOO => \\$x; 42 }; [ foo(1), ${ FOO() }, foo(2) ];\n"},{"code":"sub foo { my $x = shift; use constant FOO => \\$x; 42 }; my @a = foo(1), @{FOO()}; my @b = foo(2), @{FOO()}; [ @a, @b ];\n","err":"","out":"ERROR: Not an ARRAY reference at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"sub foo { my $x = shift; use constant FOO => \\$x; 42 }; my @a = foo(1), ${FOO()}; my @b = foo(2), ${FOO()}; [ @a, @b ];\n","out":"[42,42]"},{"code":"sub foo { my $x = shift; use constant FOO => \\$x; () }; [ foo(1), ${ FOO() }, foo(2), ${ FOO() } ];\n","err":"","out":"[1,1]"},{"out":"[1,1]","err":"","code":"sub foo { my $x = shift; use constant FOO => \\$x; ${ &{'FOO'}() } }; [ foo(1), foo(2) ];\n"},{"out":"[\\1,$VAR1->[0]]","code":"sub foo { my $x = shift; use constant FOO => \\$x; &{'FOO'}() }; [ foo(1), foo(2) ];\n","err":""},{"out":"[\"a\",\"b\",\"c\"]","err":"","code":"sub foo { my @z = (1, 2, 3); my @y = qw<a b c>; return \\@z, \\@y; } my $x = foo(); $x\n"},{"code":"sub foo { print \"FOO!\" }  foo()\n","err":"","out":"FOO!"},{"out":"ERROR: Undefined subroutine &main::foo called at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub foo { print \"FOO!\" }  undef &foo; foo()\n"},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(\\\"\n","err":"","code":"sub foo (\\@) { say @_ };\n"},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(\\\"\n","err":"","code":"sub foo (\\@\\@;\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@) { say @_ };\n"},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(\\\"\n","err":"","code":"sub foo (\\@) { say @_ }; foo +(split //, \"foobar\")\n"},{"code":"sub foo (;$) { say \"[@_]\"; }; my %h = ( bar => foo(42), meow => 'moo' ); \\%h\n","err":"","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, at EOF\n"},{"err":"","code":"sub foo { say \"[@_]\"; }; my %h = ( bar => foo(42), meow => 'moo' ); \\%h\n","out":"[42]\n"},{"err":"","code":"sub foo(;$) { say \"[@_]\"; }; my %h = ( bar => foo 42, meow => 'moo' ); \\%h\n","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, near \"foo 42\"\n"},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, at EOF\nsyntax error at (eval 1) line 1, at EOF\n","err":"","code":"sub foo(;$) { say \"[@_]\"; }; my %h = ( bar => foo(42), meow => 'moo' ); \\%h\n"},{"err":"","code":"sub foo($) { say \"[@_]\"; }; my %h = ( bar => foo(42), meow => 'moo' ); \\%h\n","out":"[42]\n"},{"out":"[\"b\",\"c\",\"d\"]","err":"","code":"sub foo { shift }; @_ = 'a'..'d'; &foo; [ @_ ]\n"},{"out":"{foo => \"bar\"}","err":"","code":"sub foo {shift} { foo => 'bar' }->${ \\\\&foo }\n"},{"out":"[]","err":"","code":"sub foo { wantarray ? 'foos' : 'bars' }  [ () = foo ]\n"},{"err":"","code":"sub j { !( $_[0] && $_[1] ) }  sub p { !($_[0] || $_[1]) } [ map [j($_->[0], $_->[1]), p($_->[0], $_->[1])], [0, 0], [1, 0], [1, 1], [0, 1] ]\n","out":"[[1,1],[1,\"\"],[\"\",\"\"],[1,\"\"]]"},{"out":"","code":"sub List::Util::0sum {\"Hello World\"};\n","err":""},{"code":"sub List::Util::0sum {\"Hello World\"}; List::Util::0sum()\n","err":"","out":"Hello World"},{"err":"","code":"sub List::Util::0sum {my ($a, $b)=(0,0); $a+=$_, $b-=$_ for @_; ($a, $b)}; [List::Util::0sum(1,2,3,4,5)]\n","out":"[15,-15]"},{"err":"","code":"sub o { (!$_[0]) && (!$_[1]) } sub j { !( $_[0] && $_[1] ) }  sub p { !($_[0] || $_[1]) } [ map [j($_->[0], $_->[1]), j($_->[0], $_->[1]), p($_->[0], $_->[1])], [0, 0], [1, 0], [1, 1], [0, 1] ]\n","out":"[[1,1,1],[1,1,\"\"],[\"\",\"\",\"\"],[1,1,\"\"]]"},{"out":"[[1,1,1],[1,1,\"\"],[\"\",\"\",\"\"],[1,1,\"\"]]","code":"sub o { ((!$_[0]) && (!$_[1])) } sub j { !( ($_[0] && $_[1]) ) }  sub p { !($_[0] || $_[1]) } [ map [j($_->[0], $_->[1]), j($_->[0], $_->[1]), p($_->[0], $_->[1])], [0, 0], [1, 0], [1, 1], [0, 1] ]\n","err":""},{"err":"","code":"sub _ { print /::(.*)/ }; *AUTOLOAD = *_; for(1..100) { $f=0, fizz() if 3 == ++$f; $b=0, buzz() if 5 == ++$b; $f && $b && &$_; &{\" \"} }\n","out":"1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 17 fizz 19 buzz fizz 22 23 fizz buzz 26 fizz 28 29 fizzbuzz 31 32 fizz 34 buzz fizz 37 38 fizz buzz 41 fizz 43 44 fizzbuzz 46 47 fizz 49 buzz fizz 52 53 fizz buzz 56 fizz 58 59 fizzbuzz 61 62 fizz 64 buzz fizz 67 68 fizz buzz 71 fizz 73 74 fizzbuzz 76 77 fizz 79 buzz fizz 82 83 fizz buzz 86 fizz 88 89 fizzbuzz 91 92 fizz 94 buzz fizz 97 98 fizz buzz "},{"out":"ERROR: Undefined subroutine &main::1 called at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub _ { print /::(.*)/ }; *_ = *AUTOLOAD; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b && &$_; &{\" \"} }\n"},{"out":"1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 17 fizz 19 buzz fizz 22 23 fizz buzz 26 fizz 28 29 fizzbuzz 31 32 fizz 34 buzz fizz 37 38 fizz buzz 41 fizz 43 44 fizzbuzz 46 47 fizz 49 buzz fizz 52 53 fizz buzz 56 fizz 58 59 fizzbuzz 61 62 fizz 64 buzz fizz 67 68 fizz buzz 71 fizz 73 74 fizzbuzz 76 77 fizz 79 buzz fizz 82 83 fizz buzz 86 fizz 88 89 fizzbuzz 91 92 fizz 94 buzz fizz 97 98 fizz buzz ","err":"","code":"sub _ { print /::(.*)/ }; *AUTOLOAD = *_; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b && &$_; &{\" \"} }\n"},{"out":"1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 17 fizz 19 buzz fizz 22 23 fizz buzz 26 fizz 28 29 fizzbuzz 31 32 fizz 34 buzz fizz 37 38 fizz buzz 41 fizz 43 44 fizzbuzz 46 47 fizz 49 buzz ","err":"","code":"sub _ { print /::(.*)/ }; *AUTOLOAD = *_; for(1..50) { $f=0, fizz() if 3 == ++$f; $b=0, buzz() if 5 == ++$b; $f && $b && &$_; &{\" \"} }\n"},{"out":"Just another Perl hacker, ","err":"","code":"sub _ { print /::(.*)/, ' ' }; *AUTOLOAD = *_; Just(), another(), Perl(), &{\"hacker,\"};\n"},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"$ & )\"\nsyntax error at (eval 1) line 1, near \"proc 'foo'\"\n","code":"sub proc ( $ & ) {}; [ proc 'foo', {; } ]\n","err":""},{"err":"","code":"sub proc ( $ & ) {}; [ proc 'foo', {;} ]\n","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"$ & )\"\nsyntax error at (eval 1) line 1, near \"proc 'foo'\"\n"},{"code":"sub proc ( $ & ) {}; [ proc 'foo', {} ]\n","err":"","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"$ & )\"\nsyntax error at (eval 1) line 1, near \"proc 'foo'\"\n"},{"err":"","code":"sub proc ( $ & ) {}; [ proc 'foo', +{} ]\n","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"$ & )\"\nsyntax error at (eval 1) line 1, near \"proc 'foo'\"\n"},{"code":"sub proc ( $ & ) {}; [ proc 'foo', { 42} ]\n","err":"","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"$ & )\"\nsyntax error at (eval 1) line 1, near \"proc 'foo'\"\n"},{"err":"","code":"sub proc ( $ & ) {}; [ proc 'foo', {; 42} ]\n","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"$ & )\"\nsyntax error at (eval 1) line 1, near \"proc 'foo'\"\nsyntax error at (eval 1) line 1, near \"42}\"\n"},{"code":"sub proc ( $ & ) {}; [ proc 'foo', { 42; 45; } ]\n","err":"","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"$ & )\"\nsyntax error at (eval 1) line 1, near \"proc 'foo'\"\nsyntax error at (eval 1) line 1, near \"; }\"\n"},{"out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(&@\"\nCan't redeclare \"my\" in \"my\" at (eval 1) line 1, near \"; \"\nsyntax error at (eval 1) line 1, near \"$#_]\"\nUnmatched right curly bracket at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, near \"} }\"\n","err":"","code":"sub ps(&@) { my $c = shift; my $p = ''; while(1) { my $i = 0; 1 until ++vec $p, $i++, 8; return if vec $p, @_, 1; $c->(@_[grep vec $p, $_, 1], 0..$#_]) } }\n"},{"code":"sub ps(&@) { my $c = shift; my $p = ''; while(1) { my $i = 0; 1 until ++vec $p, $i++, 8; return if vec $p, @_, 1; $c->(@_[grep vec($p, $_, 1), 0..$#_]) } }; my @a;ps { push @a, \"@_\" } 'a'..'c'; \\@a\n","err":"","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(&@\"\nCan't redeclare \"my\" in \"my\" at (eval 1) line 1, near \"; \"\nsyntax error at (eval 1) line 1, near \"} }\"\n"},{"code":"sub ps(&@) { my $c = shift; my $p = ''; while(1) { my $i = 0; 1 until ++vec $p, $i++, 8; return if vec $p, @_, 1; $c->(@_[grep vec($p, $_, 1), 0..$#_]) } }; my @a;ps { push @a, \"@_\" } 'a'..'d'; \\@a\n","err":"","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(&@\"\nCan't redeclare \"my\" in \"my\" at (eval 1) line 1, near \"; \"\nsyntax error at (eval 1) line 1, near \"} }\"\n"},{"err":"","code":"sub ps(&@) { my $c = shift; my $p = ''; while(1) { my $i = 0; 1 until ++vec $p, $i++, 8; return if vec $p, @_, 1; $c->(@_[grep vec $p, $_, 1], 0..$#_]) } }; my @a;ps { push @a, \\@_ } 'a'..'e'; \\@a\n","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(&@\"\nCan't redeclare \"my\" in \"my\" at (eval 1) line 1, near \"; \"\nsyntax error at (eval 1) line 1, near \"$#_]\"\nUnmatched right curly bracket at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, near \"} }\"\n"},{"err":"","code":"sub ps(&@) { my $c = shift; my $p = ''; while(1) { my $i = 0; 1 until ++vec $p, $i++, 8; return if vec $p, @_, 1; $c->(@_[grep vec($p, $_, 1), 0..$#_]) } }; my @a;ps { push @a, \"@_\" } 'a'..'e'; \\@a\n","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(&@\"\nCan't redeclare \"my\" in \"my\" at (eval 1) line 1, near \"; \"\nsyntax error at (eval 1) line 1, near \"} }\"\n"},{"err":"","code":"sub ps(&@) { my $c = shift; my $p = ''; while(1) { my $i = 0; 1 until ++vec $p, $i++, 8; return if vec $p, @_, 1; $c->(@_[grep vec($p, $_, 1), 0..$#_]) } }; my @a;ps { push @a, \\@_ } 'a'..'e'; \\@a\n","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(&@\"\nCan't redeclare \"my\" in \"my\" at (eval 1) line 1, near \"; \"\nsyntax error at (eval 1) line 1, near \"} }\"\n"},{"out":"ERROR: Illegal declaration of anonymous subroutine at (eval 1) line 1, <STDIN> line 1.\n","code":"sub { @_ = qw/foo bar baz/; } my @z = 1..10; sub @z; \\@z\n","err":""},{"code":"substr 'foo', 0, -1\n","err":"","out":"fo"},{"code":"substr 'foo', -1\n","err":"","out":"o"},{"out":"[undef]","code":"sub TIEHANDLE { [] }; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ scalar <FH> ];\n","err":""},{"err":"","code":"sub TIEHANDLE { [] }; sub READLINE { \"asdf\" }; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ scalar <FH> ];\n","out":"[undef]"},{"out":"[undef]","err":"","code":"sub TIEHANDLE { [] }; sub READLINE { \"asdf\" }; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ scalar readline FH ];\n"},{"err":"","code":"sub TIEHANDLE { [] }; sub READLINE; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ scalar <FH> ];\n","out":"[undef]"},{"out":"[undef]","err":"","code":"sub TIEHANDLE { [] }; tie *FH, 'main'; [ print FH \"foo\" ];\n"},{"err":"","code":"sub TIEHANDLE { [] }; tie *FH, 'main'; print FH \"foo\";\n","out":""},{"code":"sub TIEHANDLE { [] }; tie *FH, 'main'; [ scalar <FH> ];\n","err":"","out":"[undef]"},{"out":"ERROR: Illegal declaration of subroutine main::use at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"sub use constant foo::bar => 42; foo::bar\n"},{"code":"sub x { my $params ||= '0' || '0'; $params } [ x(42), x(43) ]\n","err":"","out":"[0,0]"},{"out":"[\"b\",\"b\"]","err":"","code":"sub x { my $params ||= '0' || 'b'; $params } [ x(42), x(43) ]\n"},{"out":"[undef,undef]","code":"sub x { my $params ||= '0' || undef; $params } [ x(42), x(43) ]\n","err":""},{"out":"[\"a\",\"a\"]","err":"","code":"sub x { my $params ||= 'a' || 'b'; $params } [ x(42), x(43) ]\n"},{"out":"[42,43]","code":"sub x { my $params ||= shift; $params } [ x(42), x(43) ]\n","err":""},{"out":"[1,2,3,4,5,6,7,8,9,10]","err":"","code":"sub x { @_ = qw/foo bar baz/; } my @z = 1..10; x @z; \\@z\n"},{"out":"","code":"sub z { }  z('â´')\n","err":""},{"code":"sub z { }  z(â´)\n","err":"","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after  z { }  z(<-- HERE near column 104 at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"sub Ï { atan2(1,1) * 4; } say Ï\n","err":"","out":"ERROR: Illegal declaration of anonymous subroutine at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"'\t' =~ /\\t/\n","err":"","out":"1"},{"code":"\"test\"\n","err":"","out":"test"},{"err":"","code":"\"test123Wow\" =~ /^.*(\\d+).*$/g; $1\n","out":"3"},{"out":"[1]","code":"*{'$::test'} = sub { 1 }; [ '$'->test ]\n","err":""},{"out":"the real life","code":"(\"the real life\", \"just fantasy\")[\"is this\"]\n","err":""},{"out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after |ÃÂ¢ÃÂÃÂ»a-z:/ÃÂ¢<-- HERE near column 158 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":" 'trg uggc|||vtabenagqrfvtare.pbz|wncu.ugzy' =~ yâ»n-za-m|â»a-z:/â»r \n"},{"out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after |ÃÂ¢ÃÂÃÂ»a-z:/ÃÂ¢<-- HERE near column 159 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":" 'trg uggc.||vtabenagqrfvtare.pbz|wncu.ugzy' =~ yâ»n-za-m.|â»a-z:/â»r \n"},{"out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after |ÃÂ¢ÃÂÃÂ»a-z:/ÃÂ¢<-- HERE near column 166 at (eval 1) line 1, <STDIN> line 1.\n","code":"'trg uggcX||vtabenagqrfvtare.pbz|wncu.ugzy //obql' =~ yâ»n-za-mX|â»a-z:/â»r\n","err":""},{"out":"ERROR: Can't locate object method \"try\" via package \"foo\" (perhaps you forgot to load \"foo\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"try {foo}\n","err":""},{"err":"","code":"try {print \"hw\"\n","out":"ERROR: Missing right curly or square bracket at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, at EOF\n"},{"out":"hwERROR: Can't locate object method \"try\" via package \"1\" (perhaps you forgot to load \"1\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"try {print \"hw\"}\n","err":""},{"err":"","code":"try {print \"hw\"} catch {die \"foo\"}\n","out":"hwERROR: foo at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"($two4s, $delta, $secs)\n","out":""},{"out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after |ÃÂ¢ÃÂÃÂ»a-z:/ÃÂ¢<-- HERE near column 155 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":" 'uggc|||vtabenagqrfvtare.pbz|wncu.ugzy' =~ yâ»n-za-m.|â»a-z:/â»r \n"},{"err":"","code":" 'uggc.||vtabenagqrfvtare.pbz|wncu.ugzy' =~ yâ»n-za-m.|â»a-z:/â»r \n","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after |ÃÂ¢ÃÂÃÂ»a-z:/ÃÂ¢<-- HERE near column 155 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after |ÃÂ¢ÃÂÃÂ»a-z:/ÃÂ¢<-- HERE near column 155 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":" 'uggcX||vtabenagqrfvtare.pbz|wncu.ugzy' =~ yâ»n-za-mX|â»a-z:/â»r \n"},{"out":"ERROR: Unterminated <> operator at (eval 1) line 1, <STDIN> line 1.\n","code":"undef < 0\n","err":""},{"err":"","code":"[\\undef, \\undef]\n","out":"[\\undef,$VAR1->[0]]"},{"out":"ok","code":"UNITCHECK { print 'ok' }; 42;\n","err":""},{"out":"[undef]","err":"","code":"[UNIVERSAL->can('import')]\n"},{"out":"","err":"","code":"unless( $a or $b ){}\n"},{"code":"unless( a or b ){}\n","err":"","out":"a"},{"code":"[ unpack '(A3)*', 'abcdefghi' ]\n","err":"","out":"[\"abc\",\"def\",\"ghi\"]"},{"out":"[\"Hello World\"]","err":"","code":"[unpack \"a*\", \"Hello World\"]\n"},{"err":"","code":"unpack \"b*\",(pack \"d\", 0.1)\n","out":"0101100110011001100110011001100110011001100110011001110111111100"},{"out":"[97,98,99]","err":"","code":"[ unpack 'C3', 'abcdefghi' ]\n"},{"code":"[unpack \"c*\", \"Hello World\"]\n","err":"","out":"[72,101,108,108,111,32,87,111,114,108,100]"},{"err":"","code":"[unpack \"c*\", \"Hello Worldâ \"]\n","out":"[72,101,108,108,111,32,87,111,114,108,100,-30,-104,-125,32]"},{"err":"","code":"[unpack \"C*\", \"Hello Worldâ \"]\n","out":"[72,101,108,108,111,32,87,111,114,108,100,226,152,131,32]"},{"out":"","err":"","code":"unpack \"d\", \"0.1\"\n"},{"out":"","err":"","code":"unpack \"d\", 0.1\n"},{"out":"ERROR: Invalid type 'D' in unpack at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"unpack \"D\", \"0.1\"\n"},{"out":"3135","err":"","code":"unpack(\"H*\", (4095 & 0xFF00) >> 8);\n"},{"out":"ff","err":"","code":"unpack(\"H*\", chr 4095);\n"},{"out":"fa0fff","err":"","code":"unpack(\"H*\", pack(\"C*\", 0xFA, 15, 255))\n"},{"out":"fa0cff","code":"unpack(\"H*\", pack(\"C*\", 0xFA, (3192 & 0x0F00) >> 8, 255))\n","err":""},{"err":"","code":"unpack \"h*\", pack \"d\", 0.1\n","out":"a999999999999bf3"},{"out":"a999999999999bf3","err":"","code":"unpack \"h*\",(pack \"d\", 0.1)\n"},{"out":"ERROR: Can't locate URI/_generic.pm:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/site_perl/5.24.0/URI.pm line 104, <STDIN> line 1.\n","code":"URI->new('/product/IDHEREFUCKER');\n","err":""},{"err":"","code":"use 10;\n","out":"ERROR: Perl v10.0.0 required--this is only v5.24.0, stopped at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: syntax error at (eval 1) line 1, at EOF\n","code":"use 5.008; You know what I like about perl? It's the fact that this English sentence is perfectly parsable!\n","err":""},{"out":"ERROR: Can't locate object method \"Some\" via package \"may\" (perhaps you forgot to load \"may\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"use 5.008; You know what I like about perl? It's the fact that this English sentence is perfectly parsable! Some may say: \"no way\", but I got deparse to prove it\n","err":""},{"out":"567856785678","code":"use 5.010; for( 1..3 ) { my $x = sub { state $x = 5; print $x++ }; $x->() for 1..4 }\n","err":""},{"err":"","code":"use 5.010; for( 1..3 ) { sub { state $x = 5; print $x++ }->() }\n","out":"555"},{"err":"","code":"use 5.010; my $x; sub foo { ++$foo }; [ foo, foo, foo ]\n","out":"[1,2,3]"},{"err":"","code":"use 5.010; my $x; sub foo :lvalue { ++$foo }; [ foo, foo, foo ]\n","out":"[3,3,3]"},{"out":"[3,3,3]","code":"use 5.010; my $x; [ ++$x,++$x,++$x ]\n","err":""},{"code":"use 5.010; say `ls -a`;\n","err":"","out":"\n"},{"err":"","code":"use 5.010; say sort { $|-- or -1 } 'ruJt tc,en hoetokarrasS h' =~ /./g\n","out":"Just another Sort hacker,\n"},{"err":"","code":"use 5.010; sub foo :lvalue { state $foo = shift; @_ and $foo = shift;$foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo(\"zof!\"), foo, foo]\n","out":"[\"zof!\",\"zof!\",\"zof!\",\"zof!\",\"zof!\",\"zof!\",\"zof!\",\"zof!\",\"zof!\",\"zof!\",\"zof!\"]"},{"out":"TEST","err":"","code":"use 5.010; sub foo { state $foo = do { print \"TEST\" }; @_ and $foo = shift; $foo }; [ foo, foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo(\"zof!\"), foo, foo]\n"},{"out":"[1,2,3]","err":"","code":"use 5.010; sub foo { ++state $foo }; [ foo, foo, foo ]\n"},{"err":"","code":"use 5.010; sub foo { state $foo = shift; @_ and $foo = 42;$foo }; [ foo(41), , foo(1), foo]\n","out":"[41,42,42]"},{"code":"use 5.010; sub foo { state $foo = shift; @_ and $foo = 42;$foo }; [ foo(41), foo, foo]\n","err":"","out":"[41,41,41]"},{"out":"[41,41,42,42]","code":"use 5.010; sub foo { state $foo = shift; @_ and $foo = 42;$foo }; [ foo(41), foo , foo(1), foo]\n","err":""},{"code":"use 5.010; sub foo { state $foo = shift; @_ and $foo = 42;$foo }; [ foo, foo, foo]\n","err":"","out":"[undef,undef,undef]"},{"code":"use 5.010; sub foo { state $foo = shift; @_ and $foo = shift;$foo }; [ foo(41), foo , foo(1), foo]\n","err":"","out":"[41,41,1,1]"},{"err":"","code":"use 5.010; sub foo { state $foo = shift; @_ and $foo = shift;$foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo(\"zof!\"), foo, foo]\n","out":"[41,41,1,1,1,1,75,75,\"zof!\",\"zof!\",\"zof!\"]"},{"out":"[undef,undef,1,undef,undef,undef,75,undef,\"zof!\",undef,undef]","err":"","code":"use 5.010; sub foo { state $foo = shift; $foo = shift;$foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo(\"zof!\"), foo, foo]\n"},{"out":"foobar","code":"use 5.020; for ( [qw/foo bar/]->@* ) { print}\n","err":""},{"out":"ERROR: syntax error at (eval 1) line 1, near \"->*\"\n","err":"","code":"use 5.020; for ( [qw/foo bar/]->*@ ) { print}\n"},{"err":"","code":"use 5.020; my $x = \\42; $x->$*\n","out":"42"},{"out":"ERROR: Malformed prototype for main::add: $x = return 0, $y = return $x at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use 5.020; sub add ($x = return 0, $y = return $x) { return $x + $y }   [ add(), add(2), add(2,3)  ]\n"},{"out":"ERROR: Malformed prototype for main::add:  $x = return 0, $y = return $x  at (eval 1) line 1, <STDIN> line 1.\n","code":"use 5.020; sub add ( $x = return 0, $y = return $x ) { return $x + $y }   [ add(), add(2), add(2,3), add(2,3,4) ]\n","err":""},{"out":"ERROR: Malformed prototype for main::add: $x = return 0, $y = return $x at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use 5.020; sub add ($x = return 0, $y = return $x) { return $x + $y }   [ add(), add(2), add(2,3), add(2,3,4) ]\n"},{"out":"foobar","err":"","code":"use 5.020; use feature 'postderef'; no warnings 'experimental::postderef'; for ( [qw/foo bar/]->@* ) { print}\n"},{"err":"","code":"use 5.08; You know what I like about perl? It's the fact that this English sentence is perfectly parsable! Some may say: \"no way\", but I got deparse to prove it\n","out":"ERROR: Perl v5.80.0 required--this is only v5.24.0, stopped at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Perl v5.200.0 required (did you mean v5.20.0?)--this is only v5.24.0, stopped at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use 5.20; my $x = \\42; $x->$*\n","err":""},{"out":"ERROR: Perl v6.0.0 required--this is only v5.24.0, stopped at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use 6;\n","err":""},{"code":"use 999;\n","err":"","out":"ERROR: Perl v999.0.0 required--this is only v5.24.0, stopped at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"bless( {sign => \"+\",value => [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10]}, 'Math::BigInt' )","code":"use bigint; 1e1000\n","err":""},{"out":"[\"PRIVATE USE TWO\"]","code":"use charnames (); [ charnames::viacode 0x92 ]\n","err":""},{"code":"use constant ARRAY => [qw(one two three)]; [ $::{ARRAY} ]\n","err":"","out":"[\\[\"one\",\"two\",\"three\"]]"},{"out":"\\[\"one\",\"two\",\"three\"]","code":"use constant ARRAY => [qw(one two three)]; $::{ARRAY}\n","err":""},{"err":"","code":"use constant ARRAY => [qw(one two three)]; ${$::{ARRAY}}\n","out":"[\"one\",\"two\",\"three\"]"},{"out":"42","code":"use constant foo::bar => 42; foo::bar\n","err":""},{"out":"BAR!\n","err":"","code":"use constant FOO => 'BAR!'; BEGIN { say FOO }\n"},{"err":"","code":"use constant FOO => 'BAR!'; BEGIN say { FOO }\n","out":"ERROR: Illegal declaration of subroutine BEGIN at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use constant FOO => 'BAR!'; our $dir = FOO; BEGIN { say FOO } say $dir\n","err":"","out":"BAR!\nBAR!\n"},{"err":"","code":"use constant FOO => 'BAR!'; our $dir = FOO; BEGIN { say FOO } say \"Moar $dir!\"\n","out":"BAR!\nMoar BAR!!\n"},{"err":"","code":"use constant foo => bar; package bar; sub baz { 'quux' }; package main; [ baz { foo } ];\n","out":"[\"quux\"]"},{"err":"","code":"use constant foo => bar; package bar; sub baz { 'quux' }; package main; [ baz { foo() } ];\n","out":"[\"quux\"]"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"baz foo \"\n","code":"use constant foo => bar; package bar; sub baz { 'quux' }; package main; [ baz foo ];\n","err":""},{"err":"","code":"use constant foo => bar; package bar; sub baz() { 'quux' }; package main; [ baz { foo } ];\n","out":"ERROR: Too many arguments for subroutine at (eval 1) line 1.\n"},{"out":"ERROR: Too many arguments for subroutine at (eval 1) line 1.\n","code":"use constant foo => bar; package bar; sub baz() { 'quux' }; package main; [ baz { foo() } ];\n","err":""},{"code":"use constant foo => bar; package bar; sub baz() { 'quux' }; package main; [ baz foo ];\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"baz foo \"\n"},{"out":"","err":"","code":"use constant foo => 'ok'; *main::{foo};\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"list[\"\n","code":"use constant list => qw(a b c); [list[2]]\n","err":""},{"out":"ERROR: Can't use an array as a reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use constant list => qw(a b c); list->[2]\n"},{"code":"use constant one => 1; BEGIN { &Internals::SvREADONLY(\\one, 0); ++${ \\one } }; say one;\n","err":"","out":"2\n"},{"out":"ERROR: Missing $ on loop variable at (eval 1) line 1, <STDIN> line 1.\n","code":"use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); for my \\%hash (@a) {print Dumper(%hash);}\n","err":""},{"code":"use Devel::Peek qw,SvREFCNT,;\n","err":"","out":"ERROR: Can't locate Devel/Peek.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","code":"use Encode;\n","err":""},{"code":"use Encode; [Encode->encodings()];\n","err":"","out":"[\"ascii\",\"ascii-ctrl\",\"cp1252\",\"iso-8859-1\",\"null\",\"utf-8-strict\",\"utf8\"]"},{"out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂÃÂ¢ n-za-mÃÂ¢<-- HERE near column 194 at (eval 1) line 1, <STDIN> line 1.\n","code":"use Encode; print encode 'utf8', 'get http://ignorantdesigner.com/japh.html' =~ y â¢ a-z:/ â¢ n-za-mâ â¢r \n","err":""},{"out":"ERROR: Can't call method \"\" on an undefined value at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use experimental 'postderef'; my $x; $x->$@\n"},{"code":"use experimental 'postderef'; my $x;  @{ $x || [] }; $x->@*\n","err":"","out":""},{"out":"ERROR: Can't call method \"\" on an undefined value at (eval 1) line 1, <STDIN> line 1.\n","code":"use experimental 'postderef'; my $x;  @{ $x || [] }; $x->$@\n","err":""},{"out":"ERROR: Can't call method \"\" on an undefined value at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use experimental 'postderef'; my @z = 1..10; $z->$#\n"},{"code":"use experimental 'postderef'; my $z =[ 1..10]; $z->$*#\n","err":"","out":"ERROR: Not a SCALAR reference at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use experimental 'postderef'; my $z =[ 1..10]; $z->$#\n","err":"","out":"ERROR: Can't call method \"\" on unblessed reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"9","code":"use experimental 'postderef'; my $z =[ 1..10]; $z->$#*\n","err":""},{"out":"ERROR: Can't call method \"\" on an undefined value at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use experimental 'postderef'; undef->$@\n"},{"out":"ERROR: Undefined subroutine &main::__CODE__ called at (eval 1) line 1, <STDIN> line 1.\n","code":"use feature ':all'; sub add (@) { __CODE__->(1,2) }   [ add(), add(2), add(2,3)  ]\n","err":""},{"err":"","code":"use feature ':all'; sub add (__CODE__->(2,2)) { }   [ add(), add(2), add(2,3)  ]\n","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(__CODE__\"\n"},{"err":"Out of memory!\n","code":"use feature ':all'; sub add (@) { __SUB__->(1,2) }   [ add(), add(2), add(2,3)  ]\n","out":""},{"code":"use feature ':all'; sub add (__SUB__->(2,2)) { }   [ add(), add(2), add(2,3)  ]\n","err":"","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(__SUB__\"\n"},{"out":"ERROR: Too many arguments for subroutine at (eval 1) line 1.\n","code":"use feature ':all'; sub add ($x = return 0, $y = return $x) { return $x + $y }   [ add(), add(2), add(2,3)  ]\n","err":""},{"err":"","code":"use feature 'postderef'; \\(42)->$*\n","out":"\\undef"},{"out":"\\undef","code":"use feature 'postderef'; \\42->$*\n","err":""},{"err":"Out of memory!\n","code":"use feature 'postderef'; for my $i (1..10) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]\n","out":""},{"out":"","code":"use feature 'postderef'; for my $i (1..10) {push @a, [(1) x (1024*1024)]}; sleep 15; [scalar(@a), scalar($a[0]->@*)]\n","err":"Out of memory!\n"},{"out":"","err":"Out of memory!\n","code":"use feature 'postderef'; for my $i (1..15) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]\n"},{"err":"Out of memory!\n","code":"use feature 'postderef'; for my $i (1..30) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]\n","out":""},{"out":"","err":"Out of memory!\n","code":"use feature 'postderef'; for my $i (1..5) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]\n"},{"err":"","code":"use feature 'postderef'; my $a; ++$a->$ ;[ $a ]\n","out":"ERROR: syntax error at (eval 1) line 1, near \"$ ;[\"\n"},{"out":"x","code":"use feature 'postderef'; my $aref = \\['x']; $$aref->[0]\n","err":""},{"code":"use feature q,postderef,; my $x = 42; my $y = \\$x; [ \\$x, \\$y->$* ]\n","err":"","out":"[\\42,$VAR1->[0]]"},{"out":"[\\43,$VAR1->[0]]","code":"use feature q,postderef,; my $x = 42; my $y = \\$x; [ \\$x, \\++$y->$* ]\n","err":""},{"err":"","code":"use feature 'say'; say \"!(0 || 1 && (0 || 0)) && !(1 && 1)\"\n","out":"!(0 || 1 && (0 || 0)) && !(1 && 1)\n"},{"code":"use feature 'signatures'; sub add (__SUB__->(2,2)) { }   [ add(), add(2), add(2,3)  ]\n","err":"","out":"ERROR: Parse error at (eval 1) line 1, <STDIN> line 1.\nsyntax error at (eval 1) line 1, near \"(__SUB__\"\n"},{"out":"[0,2,5]","err":"","code":"use feature 'signatures'; sub add ($x = 0, $y = 0) { return $x + $y }   [ add(), add(2), add(2,3)  ]\n"},{"out":"ERROR: Too many arguments for subroutine at (eval 1) line 1.\n","code":"use feature 'signatures'; sub add ($x = return 0, $y = return $x) { return $x + $y }   [ add(), add(2), add(2,3)  ]\n","err":""},{"out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use File::Basename;\n","err":""},{"out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use File::Basename; [map +(fileparse $_)[1], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n","err":""},{"out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use File::Basename; [map +(fileparse $_)[2], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n"},{"code":"use File::Basename; [map +(fileparse $_, qr/(?<=.)[^.]+/)[1], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n","err":"","out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use File::Basename; [map +(fileparse $_, qr/(?<=\\.)[^.]+/)[1], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n"},{"code":"use File::Basename; [map +(fileparse $_, qr/[^.]+/)[1], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n","err":"","out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use File::Basename; [map +(fileparse $_, qr/(?<=\\.)[^.]+/)[2], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n","err":"","out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use File::Basename; [map +(fileparse $_, qr/[^.]+/)[2], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n","err":""},{"out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use File::Basename qw/fileparse/; [map +(basename $_)[2], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n"},{"err":"","code":"use File::Basename qw/fileparse/; [map +(basename$_)[2] \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n","out":"ERROR: Can't locate File/Basename.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"","code":"use File::Spec; \n","err":""},{"out":"ERROR: Can't locate CGI.pm:   (null): Too many open files at (eval 1) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 2, <STDIN> line 1.\n","err":"","code":"use File::Spec; use CGI\n"},{"out":"","code":"use JSON;\n","err":""},{"out":"","code":"use JSON::MaybeXS;\n","err":""},{"code":"use JSON::MaybeXS; JSON\n","err":"","out":"Cpanel::JSON::XS"},{"err":"","code":"use JSON::MaybeXS; [ JSON() ]\n","out":"[\"Cpanel::JSON::XS\"]"},{"out":"Cpanel::JSON::XS","code":"use JSON::MaybeXS; JSON()\n","err":""},{"code":"use JSON::MaybeXS; [ *main::JSON{CODE} ]\n","err":"","out":"[sub { \"DUMMY\" }]"},{"out":"ERROR: Can't locate JSON/PP.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use JSON::PP; no JSON::XS; no Cpanel::JSON::XS; use JSON::MaybeXS; JSON(); # Don't think this will work\n"},{"err":"","code":"use JSON::XS;\n","out":""},{"code":"use  JSON::XS; no Cpanel::JSON::XS; use JSON::MaybeXS; JSON(); # Don't think this will work\n","err":"Prototype mismatch: sub main::decode_json ($) vs ($;$) at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/5.24.0/Exporter.pm line 66, <STDIN> line 1.\n at (eval 1) line 1.\n","out":"Cpanel::JSON::XS"},{"code":"use List::Util;\n","err":"","out":""},{"out":"[55,210,120,136,171,153]","err":"","code":"use List::Util qw/reduce/; [ map { reduce {$a + $b} 1..$_ } 10, 20, 15, 16, 18, 17 ]\n"},{"out":"[55,120,136,153,171,210]","err":"","code":"use List::Util qw/reduce/; [ map { reduce {$a + $b} 1..$_ } sort 10, 20, 15..18 ]\n"},{"code":"use List::Util qw/reduce/; reduce {$a + $b} 1..10\n","err":"","out":"55"},{"code":"use List::Util qw/reduce/; reduce {$a + $b} 1..15\n","err":"","out":"120"},{"out":"136","code":"use List::Util qw/reduce/; reduce {$a + $b} 1..16\n","err":""},{"err":"","code":"use List::Util qw/reduce/; reduce {$a + $b} 1..17\n","out":"153"},{"code":"use List::Util qw/reduce/; reduce {$a + $b} 1..18\n","err":"","out":"171"},{"err":"","code":"use List::Util qw/reduce/; reduce {$a + $b} 1..20\n","out":"210"},{"code":"use List::Util qw(shufffle); [ shuffle 1..20 ]\n","err":"","out":"ERROR: \"shufffle\" is not exported by the List::Util module\nCan't continue after import errors at (eval 1) line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[12,2,3,9,16,5,6,19,10,11,20,7,13,15,14,1,4,8,17,18]","err":"","code":"use List::Util qw(shuffle); [ shuffle 1..20 ]\n"},{"code":"use List::Util qw(shuffle); sub bubsort { my $arr = shift; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i] }; $arr }; bubsort [ shuffle 1..20 ]\n","err":"","out":"[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]"},{"out":"[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]","code":"use List::Util qw(shuffle); sub bubsort { my $arr = shift; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i]; &bubsort }; $arr }; bubsort [ shuffle 1..20 ]\n","err":""},{"err":"","code":"use List::Util qw(shuffle); sub bubsort { my ($arr) = @_; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i]; &bubsort }; $arr }; bubsort [ shuffle 1..100 ]\n","out":"[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]"},{"out":"[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]","err":"","code":"use List::Util qw(shuffle); sub bubsort { my ($arr) = @_; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i]; &bubsort }; $arr }; bubsort [ shuffle 1..20 ]\n"},{"code":"use Math::Complex; \n","err":"","out":"ERROR: Can't locate Math/Complex.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate MIME/Base64.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use MIME::Base64;\n"},{"code":"use MIME::Base64; decode_base64 'aHR0cDovL3NhZnIua2luZ2ZlYXR1cmVzLmNvbS9CZWV0bGVCYWlsZXkvMjAwNC8wNS9CZWV0bGVfQmFpbGV5LjIwMDQwNTIyXzkwMC5naWY='\n","err":"","out":"ERROR: Can't locate MIME/Base64.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use MIME::Base64; use warnings; sub z { substr shift, 1, 1 }  z('â´')\n","out":"ERROR: Can't locate MIME/Base64.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use overload\n","err":"","out":""},{"out":"","code":"use overload;\n","err":""},{"out":"ERROR: Can't bless non-reference value at (eval 1) line 1, <STDIN> line 1.\n","code":"use overload q|\"\"| => sub { 42 }; my @a; $a[42] = 'forty two'; [ $a[bless 'main'] ]\n","err":""},{"err":"","code":"use overload q|\"\"| => sub { 42 }; my @a; $a[42] = 'forty two'; [ $a[bless {}, 'main'] ]\n","out":"[\"forty two\"]"},{"out":"ERROR: Died at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use overload qw,\"\",=> sub { die }; bless {}, bless []; 42;\n"},{"out":"42","code":"use overload qw,\"\",=> sub { die }; my $x = bless []; 42;\n","err":""},{"out":"ERROR: Died at (eval 1) line 1, <STDIN> line 1.\n","code":"use overload qw,\"\",=> sub { die }; my $x = bless []; bless {}, $x; 42;\n","err":""},{"out":"abcdef","code":"use overload '\"\"' => sub { 'abcdef' }; '' . bless [];\n","err":""},{"code":"use overload '\"\"' => sub { 'abcdef' }; ref bless [], bless [];\n","err":"","out":"abcdef"},{"out":"ERROR: abcdef at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use overload '\"\"' => sub { die 'abcdef' }; ref bless [], bless [];\n"},{"code":"use POSIX qw/ceil/; [ ceil(-2.20, int -2.2 ]\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"2.2 ]\"\n"},{"code":"use POSIX qw/ceil/; [ ceil -2.2, int(-2.2) ]\n","err":"","out":"ERROR: Usage: POSIX::ceil(x) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use POSIX qw/ceil/; [ ceil(-2.2), int -2.2 ]\n","out":"[-2,-2]"},{"code":"use Safe;\n","err":"","out":"ERROR: Can't locate Safe.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"two\"]","code":"use Scalar::Util qw/dualvar/; my $i = dualvar 1, 'forty two'; my @a = qw/one two/; [ $a[ $i ] ];\n","err":""},{"err":"","code":"use Scalar::Util qw/dualvar/; my $i = dualvar 1, 'forty two'; my @a = qw/one two/; [ $a[ $i ], $a[ \"$i\" ] ];\n","out":"[\"two\",\"one\"]"},{"err":"","code":"use Scalar::Util qw/dualvar/; my $i = dualvar 1, 'forty two'; my @a = qw/one two/; [ $a[ $i ], $a[ $i+0 ] ];\n","out":"[\"two\",\"two\"]"},{"err":"","code":"use Scalar::Util qw/dualvar/; my $x = dualvar(42,'foo'); [ $x+0, \"$x\" ]\n","out":"[42,\"foo\"]"},{"out":"[55,55]","err":"","code":"use Scalar::Util qw/dualvar/; my $x = dualvar('42','foo'); $x = 55; [ $x+0, \"$x\" ]\n"},{"out":"[42,\"forty two\"]","code":"use Scalar::Util qw/dualvar/; my $x = dualvar 42, 'forty two'; [$x+0, \"$x\"]\n","err":""},{"err":"","code":"use Scalar::Util qw/dualvar/; my $x = dualvar 42, 'forty two'; [$x, \"$x\"]\n","out":"[\"forty two\",\"forty two\"]"},{"code":"use Scalar::Util qw/dualvar/; my $x = dualvar('NaN','foo'); [ $x+0, \"$x\" ]\n","err":"","out":"[\"NaN\",\"foo\"]"},{"out":"[\"foo\",42]","err":"","code":"use Scalar::Util qw/dualvar/; $x = dualvar 42, 'foo'; [ $x.'', $x+0 ]\n"},{"out":"ERROR: \"looks_like_a_number\" is not exported by the Scalar::Util module\nCan't continue after import errors at (eval 1) line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use Scalar::Util qw/looks_like_a_number/; looks_like_a_number 'NaN'\n","err":""},{"out":"[\"\"]","code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'iNan' ]\n","err":""},{"out":"[1]","code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'Nan' ]\n","err":""},{"out":"[1]","err":"","code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'NaN' ]\n"},{"out":"1","code":"use Scalar::Util qw/looks_like_number/; looks_like_number 'NaN'\n","err":""},{"err":"","code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'sdss' ]\n","out":"[\"\"]"},{"err":"","code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'sNan' ]\n","out":"[1]"},{"out":"[1]","code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'sNaN' ]\n","err":""},{"err":"","code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'wtfNan' ]\n","out":"[\"\"]"},{"out":"[\"\"]","code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'xsNan' ]\n","err":""},{"code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'zNan' ]\n","err":"","out":"[\"\"]"},{"err":"","code":"use Scalar::Utils qw/dualvar/; my $x = dualvar 42, 'forty two'; [$x, \"$x\"]\n","out":"ERROR: Can't locate Scalar/Utils.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Not a GLOB reference at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; *4 = sub { 'ok' }; *{ \\4 };\n"},{"out":"*main::4","code":"use strict; *4 = sub { 'ok' }; *{ 4 };\n","err":""},{"err":"","code":"use strict; *4 = sub { 'ok' }; &{ \\4 };\n","out":"ERROR: Not a CODE reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ok","code":"use strict; *4 = sub { 'ok' }; &{4};\n","err":""},{"out":"ok","code":"use strict; *4 = sub { 'ok' }; main->${ \\4 };\n","err":""},{"out":"ERROR: Can't use string (\"foo bar\") as a symbol ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; $a=\"foo bar\"; *$a = sub {\"baz\"}; \"foo bar\"->()\n"},{"out":"ERROR: Global symbol \"$foo\" requires explicit package name (did you forget to declare \"my $foo\"?) at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict;  BEGIN { *::foo = \\$::foo; } $foo = 42;\n"},{"out":"42","code":"use strict; BEGIN { package Zomg; use strict; *::foo = \\$::foo; }  $foo = 42;\n","err":""},{"err":"","code":"use strict;  *::foo = \\$::foo;  $foo = 42;\n","out":"ERROR: Global symbol \"$foo\" requires explicit package name (did you forget to declare \"my $foo\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"bless( {sign => \"+inf\",value => [0],_p => undef,_a => undef}, 'Math::BigInt' )","code":"use strict; inf\n","err":""},{"code":"use strict; \"-inf\"<0\n","err":"","out":"1"},{"err":"","code":"use strict; \"inf\"<0\n","out":""},{"out":"1","err":"","code":"use strict; \"inf\">0\n"},{"out":"Inf","code":"use strict; \"inf\"+0\n","err":""},{"out":"ERROR: Global symbol \"$x_\" requires explicit package name (did you forget to declare \"my $x_\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; my $x; if ( $x = \"x\\b\" ) { print \"_$x_\" }\n","err":""},{"out":"ERROR: Can't use single ref constructor for loop variable at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use v5.21; use feature qw(refaliasing);use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); foreach \\%hash (@a) {print Dumper(%hash);}\n"},{"err":"","code":"use strict; use v5.21; use feature qw(refaliasing);use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); foreach my \\%hash (@a) {print Dumper(%hash);}\n","out":"ERROR: Missing $ on loop variable at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use strict; use v5.21; use feature qw(refaliasing);use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); my %hash; foreach \\%hash (@a) {print Dumper(%hash);}\n","out":"$VAR1 = 'bar';\n$VAR2 = 2;\n$VAR3 = 'foo';\n$VAR4 = 1;\n$VAR1 = 'problems';\n$VAR2 = 99;\n$VAR3 = 'bitches';\n$VAR4 = 0;\n"},{"out":"","err":"","code":"use strict; use warnings; blasdsdasdsa->import\n"},{"err":"","code":"use strict; use warnings; $_ = '@f@f@f'; s'@f'$b'gr; \n","out":"$b$b$b"},{"code":"use strict; use warnings; [ grep defined, @{+{a => \"b\", c => \"d\", e => \"f\"}}{qw/a b c/} ];\n","err":"","out":"[\"b\",\"d\"]"},{"out":"ERROR: \"use\" not allowed in expression at (eval 1) line 1, at end of line\nsyntax error at (eval 1) line 1, near \"use strict use warnings\"\n","code":"use strict use warnings; h->{two}();  sub h { +{ one => sub { 1 }, two => sub { 2 } } }\n","err":""},{"out":"ERROR: Can't use bareword (\"h\") as a HASH ref while \"strict refs\" in use at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; h->{two}();  sub h { +{ one => sub { 1 }, two => sub { 2 } } }\n","err":""},{"code":"use strict; use warnings; h()->{two}();  sub h { +{ one => sub { 1 }, two => sub { 2 } } }\n","err":"","out":"2"},{"out":"ERROR: Bareword \"Inf\" not allowed while \"strict subs\" in use at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; +Inf\n","err":""},{"code":"use strict; use warnings; [ \"+inf\" > 0 ]\n","err":"","out":"[1]"},{"out":"Inf","code":"use strict; use warnings; \"+Inf\"+0\n","err":""},{"err":"","code":"use strict; use warnings; [ \"-Inf\" > 0 ]\n","out":"[\"\"]"},{"code":"use strict; use warnings; [ \"+Inf\" > 0 ]\n","err":"","out":"[1]"},{"err":"Argument \"+Inx\" isn't numeric in numeric gt (>) at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; [ \"+Inx\" > 0 ]\n","out":"[\"\"]"},{"out":"[42]","err":"","code":"use strict; use warnings; my $a = 42; my $z = 42; [ sort { $z <=> $b } 42 ]\n"},{"out":"[]","code":"use strict; use warnings; my $a = 42; [ sort ]\n","err":""},{"out":"","code":"use strict; use warnings; my $a = 42; sort \n","err":"Useless use of sort in scalar context at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[42]","code":"use strict; use warnings; my $a = 42; [ sort { $a <=> $b } 42 ]\n","err":"\"my $a\" used in sort comparison at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use strict; use warnings; my $a = 42; [ sort { $z <=> $b } 42 ]\n","out":"ERROR: Global symbol \"$z\" requires explicit package name (did you forget to declare \"my $z\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"Use of uninitialized value in array element at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my @a; $a[undef]\n","out":""},{"out":"ERROR: Can't use an undefined value as a HASH reference at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $foo; if ( %$foo ) { 1; }\n","err":""},{"code":"use strict; use warnings; my $foo; if ( $foo and %$foo ) { 1; }\n","err":"","out":""},{"out":"b,d","code":"use strict; use warnings; my $h = {a => \"b\", c => \"d\", e => \"f\"}; my $str = join \",\", grep defined, @$h{qw/a b c/}; print $str;\n","err":""},{"code":"use strict; use warnings; my $str = join \",\", grep defined, @{+{a => \"b\", c => \"d\", e => \"f\"}}{qw/a b c/}; print $str;\n","err":"","out":"b,d"},{"out":"[\"\"]","err":"","code":"use strict; use warnings; my $x = 42; [ defined &$x ]\n"},{"err":"Use of uninitialized value $x in subroutine dereference at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $x; [ defined &$x ]\n","out":"[\"\"]"},{"out":"ERROR: Can't use an undefined value as a subroutine reference at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $x; [ &$x ]\n","err":""},{"code":"use strict; use warnings; [ \"nan\" > 0 ]\n","err":"","out":"[\"\"]"},{"err":"","code":"use strict; use warnings; [ \"Nan\" > 0 ]\n","out":"[\"\"]"},{"out":"[\"\"]","err":"","code":"use strict; use warnings; [ \"NaN\" > 0 ]\n"},{"out":"[\"\"]","err":"Argument \"nann\" isn't numeric in numeric gt (>) at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; [ \"nann\" > 0 ]\n"},{"out":"[\"NaN\"]","err":"","code":"use strict; use warnings; [ 'NaN' + 'sNaN' ]\n"},{"err":"","code":"use strict; use warnings; [ 'NaN' + 'sNaN' + 55]\n","out":"[\"NaN\"]"},{"out":"[\"asdf\"]","code":"use strict; use warnings; open( my($fh), \"<\", \\\"asdf\" ); [ <$fh> ];\n","err":""},{"err":"","code":"use strict; use warnings; open( my($fh), \"<\", \\\"asdf\" ); [ <$fh>, scalar <$fh> ];\n","out":"[\"asdf\",undef]"},{"out":"[\"asdf\",undef,undef]","code":"use strict; use warnings; open( my($fh), \"<\", \\\"asdf\" ); [ <$fh>, scalar <$fh>, scalar <$fh> ];\n","err":""},{"out":"[10,9,8,7,6,5,4,3,2,1]","code":"use strict; use warnings; our $a = -1; [ sort {  $b <=> $a } 1..10 ]\n","err":""},{"out":"[10,9,8,7,6,5,4,3,2,1]","err":"","code":"use strict; use warnings; our $a = 42; [ sort {  $b <=> $a } 1..10 ]\n"},{"out":"blah","err":"","code":"use strict; use warnings; our $VERSION = 'blah';\n"},{"err":"","code":"use strict;  use warnings; sub bar { 42 } print \"Return $foo\" if my $foo = bar;\n","out":"ERROR: Global symbol \"$foo\" requires explicit package name (did you forget to declare \"my $foo\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"2","code":"use strict; use warnings; sub h { +{ one => sub { 1 }, two => sub { 2 } } }  h->{two}();  \n","err":""},{"out":"In autoload!In autoload!","code":"use strict; use warnings; sub TIEHANDLE { bless [] }; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ print FH 'adfasdf' ];\n","err":""},{"code":"use strict; use warnings; sub TIEHANDLE { bless [] }; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ scalar readline FH ];\n","err":"","out":"In autoload!In autoload!"},{"err":"","code":"use strict; use warnings; sub TIEHANDLE { bless [] }; sub AUTOLOAD { print \"In autoload! $AUTOLOAD\"; 42 }; tie *FH, 'main'; [ print FH 'adfasdf' ];\n","out":"ERROR: Global symbol \"$AUTOLOAD\" requires explicit package name (did you forget to declare \"my $AUTOLOAD\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[\"asdf\"]In autoload!","code":"use strict; use warnings; sub TIEHANDLE { bless [] }; sub READLINE { \"asdf\" }; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ scalar readline FH ];\n","err":""},{"out":"ERROR: Can't locate autodie.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; use autodie; open( my($fh), \"<\", \\\"asdf\" ); [ <$fh> ];\n","err":""},{"out":"ERROR: Global symbol \"$VERSION\" requires explicit package name (did you forget to declare \"my $VERSION\"?) at (eval 1) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; $VERSION = 'blah';\n","err":""},{"err":"","code":"use Test::More\n","out":"ERROR: Can't locate Test/More.pm:   (null): Too many open files at (eval 1) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 2, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate Text/Soundex.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Text::Soundex;\n"},{"out":"ERROR: Can't locate Text/SoundEx.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use Text::SoundEx;\n","err":""},{"code":"use Tie::Handle; tie *FH, 'Tie::Handle'; \n","err":"","out":"ERROR: Can't locate Tie/Handle.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: foo at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Try::Tiny; try {die \"baz\";} catch {die \"foo\"}; die \"bar\";\n"},{"out":"ERROR: foo at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use Try::Tiny; try {die \"baz\";} catch {die \"foo\"} finally { \"bar\"};\n"},{"out":"ERROR: foo at (eval 1) line 1, <STDIN> line 1.\n","code":"use Try::Tiny; try {die \"baz\";} catch {die \"foo\"} finally { die \"bar\"};\n","err":"Execution of finally() block CODE(0x37d04a0) resulted in an exception, which *CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. Your program will continue as if this event never took place. Original exception text follows:\n\nbar at (eval 1) line 1, <STDIN> line 1.\n\n"},{"out":"hoyl shit that brokeERROR: foo at (eval 1) line 1, <STDIN> line 1.\n","code":"use Try::Tiny; try {die \"baz\";} catch {die \"foo\"} finally { print \"hoyl shit that broke\"};\n","err":""},{"out":"","err":"","code":"use URI::Encode qw/uri_encode/;\n"},{"out":"%3Carg%3E","err":"","code":"use URI::Encode qw/uri_encode/; uri_encode \"<arg>\", {\"encode_reserved\", 1}; \n"},{"err":"","code":"use URI::Encode qw/uri_encode/; uri_encode \"LWP::Authen::Digest\"\n","out":"LWP::Authen::Digest"},{"out":"[\"test\"]","err":"","code":"use URI::Encode; [ URI::Encode::uri_encode \"test\", {encode_reserved=>1} ];\n"},{"out":"ERROR: Can't locate URI/_generic.pm:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/site_perl/5.24.0/URI.pm line 104, <STDIN> line 1.\n","code":"use URI; URI->new('/product/IDHEREFUCKER');\n","err":""},{"out":"ERROR: Can't locate URI/_generic.pm:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perlbot-blead-2016-04-13/lib/site_perl/5.24.0/URI.pm line 104, <STDIN> line 1.\n","code":"use URI; URI->new(\"www.ebay.com\");\n","err":""},{"out":"0","err":"","code":"use utf8; - - 'â§'\n"},{"err":"","code":"use utf8; [ 'get http://ignorantdesigner.com/japh.html' =~ y â¢ a-z: â¢ n-za-m â¢ r ]\n","out":"ERROR: Can't modify constant item in transliteration (tr///) at (eval 1) line 1, near \"y ÃÂ¢ÃÂÃÂ¢ a-z: ÃÂ¢ÃÂÃÂ¢ n-za-m ÃÂ¢ÃÂÃÂ¢ r \"\nsyntax error at (eval 1) line 1, near \"y ÃÂ¢ÃÂÃÂ¢ a-z: ÃÂ¢ÃÂÃÂ¢ n-za-m ÃÂ¢ÃÂÃÂ¢ r \"\n"},{"err":"","code":"use utf8; [ 'get http://ignorantdesigner.com/japh.html' =~ y â¢ a-z: â¢ n-za-m â¢r ]\n","out":"[\"trg uggc //vtabenagqrfvtare.pbz/wncu.ugzy\"]"},{"out":"[\"\\0\\0\\0\\0\\0\"]","err":"","code":"use utf8; $l = \"fooso\"; [ $l & chr(0x80)x(length $l) ]\n"},{"err":"","code":"use utf8; $l = \"fooso\"; [ $l =~tr/[\\0-\\127]//cdr  ]\n","out":"[\"\"]"},{"out":"[\"fooso\"]","err":"","code":"use utf8; $l = \"fooso\"; [ $l =~tr/[\\0-\\127]//dr  ]\n"},{"code":"use utf8; $l = \"fooso\"; [ $l =~tr/\\0-\\127//dr  ]\n","err":"","out":"[\"fooso\"]"},{"out":"[\"fooso\"]","err":"","code":"use utf8; $l = \"fooso\"; [ $l =~tr/[\\0-\\127]//r  ]\n"},{"out":"[\"\"]","code":"use utf8; $l = \"fooso\"; [ $l =~tr/\\0-\\225//dr  ]\n","err":""},{"out":"[\"\"]","code":"use utf8; $l = \"fooso\"; [ $l =~tr/\\0-\\250//dr  ]\n","err":""},{"err":"","code":"use utf8; my $ aÍ¾ print;\n","out":"ERROR: Unrecognized character \\x{37e}; marked by <-- HERE after f8; my $ a<-- HERE near column 107 at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use utf8; my $aÍ¾ print;\n","out":"ERROR: Unrecognized character \\x{37e}; marked by <-- HERE after tf8; my $a<-- HERE near column 106 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Unrecognized character \\x{2019}; marked by <-- HERE after f8; print <-- HERE near column 107 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use utf8; print â42â\n"},{"err":"","code":"use utf8; q â¤â Happy Valentine's Day, #perl â¤â \n","out":"ERROR: Unrecognized character \\x{200e}; marked by <-- HERE after y, #perl ÃÂ¢ÃÂÃÂ¤<-- HERE near column 136 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Unrecognized character \\x{200e}; marked by <-- HERE after y, #perl ÃÂ¢ÃÂÃÂ¤<-- HERE near column 136 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use utf8; q â¤â Happy Valentine's Day, #perl â¤â â¤âr\n"},{"code":"use utf8; q â¤â Happy Valentine's Day, #perl â¤â  s â¤ â¤âr\n","err":"","out":"ERROR: Unrecognized character \\x{200e}; marked by <-- HERE after y, #perl ÃÂ¢ÃÂÃÂ¤<-- HERE near column 136 at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use utf8; q â¤â Happy Valentine's Day, #perl â¤â  s â¤ â¤â â¤r\n","out":"ERROR: Unrecognized character \\x{200e}; marked by <-- HERE after y, #perl ÃÂ¢ÃÂÃÂ¤<-- HERE near column 136 at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use utf8; q â¤â Happy Valentine's Day, perl â¤ ;â  s â¤ â¤â â¤r\n","err":"","out":"ERROR: Unrecognized character \\x{200e}; marked by <-- HERE after , perl ÃÂ¢ÃÂÃÂ¤ ;<-- HERE near column 137 at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use utf8; q â¤â Happy Valentine's Day, perl â¤;â  s â¤ â¤â â¤r\n","out":"ERROR: Unrecognized character \\x{200e}; marked by <-- HERE after y, perl ÃÂ¢ÃÂÃÂ¤;<-- HERE near column 136 at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use utf8; q â¤â Happy Valentine's Day, perl â¤â  s â¤ â¤â â¤r\n","out":"ERROR: Unrecognized character \\x{200e}; marked by <-- HERE after ay, perl ÃÂ¢ÃÂÃÂ¤<-- HERE near column 135 at (eval 1) line 1, <STDIN> line 1.\n"},{"out":" ÃÂ¢ÃÂÃÂº Perl \\o/ ÃÂ¢ÃÂÃÂº  ","code":"use utf8; q ð âº Perl \\o/ âº  ð\n","err":""},{"code":"use utf8; quotemeta 'Ã·'\n","err":"","out":"\\ÃÂ·"},{"err":"","code":"use utf8; quotemeta \"Ç\"\n","out":"ÃÂÃÂ"},{"out":"1\n","err":"","code":"use utf8; say length \"ïº\"\n"},{"code":"use utf8; \"Ç\" =~ s/([^A-Za-z_0-9])/\\\\$1/gr\n","err":"","out":"\\ÃÂÃÂ"},{"code":"use utf8; \"Ç\" =~ s/([^A-Za-z_0-9])/\\\\$1/r\n","err":"","out":"\\ÃÂÃÂ"},{"out":"ERROR: Unrecognized character \\x{2764}; marked by <-- HERE after perl ÃÂ¢ÃÂÃÂ¤ÃÂ¢ÃÂÃÂ ÃÂ¢ÃÂÃÂ¤ <-- HERE near column 140 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use utf8; s â¤â Happy Valentine's Day, #perl â¤â â¤ â¤âr\n"},{"out":"ERROR: Unrecognized character \\x{200e}; marked by <-- HERE after #perl ÃÂ¢ÃÂÃÂ¤ÃÂ¢ÃÂÃÂ ÃÂ¢ÃÂÃÂ¤<-- HERE near column 139 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"use utf8; s â¤â Happy Valentine's Day, #perl â¤â â¤âr\n"},{"err":"","code":"use utf8; s â¤â Happy Valentine's Day, #perl â¤â â¤â â¤âr\n","out":"ERROR: Unrecognized character \\x{200e}; marked by <-- HERE after #perl ÃÂ¢ÃÂÃÂ¤ÃÂ¢ÃÂÃÂ ÃÂ¢ÃÂÃÂ¤<-- HERE near column 139 at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use utf8; use Encode; my $z = 'â';  [ length($z), length(encode 'utf8', $z) ]\n","out":"[1,3]"},{"code":"use utf8; use warnings; sub z { print shift }  z('â´')\n","err":"Wide character in print at (eval 1) line 1, <STDIN> line 1.\n","out":"ÃÂ¢ÃÂÃÂ´"},{"err":"","code":"use utf8; use warnings; sub z { substr shift, 1, 1 }  z('â´')\n","out":""},{"code":"use v5.21; 0.deadbeefp2\n","err":"","out":"ERROR: syntax error at (eval 1) line 1, near \"0.deadbeefp2\n\"\n"},{"err":"","code":"use v5.21; $a = 0.deadbeefp2\n","out":"ERROR: syntax error at (eval 1) line 1, near \"0.deadbeefp2\n\"\n"},{"out":"[1,2,6]","err":"","code":"use v5.21; ($a, $b, (undef) x 3, $c) = (1..10); [$a, $b, $c]\n"},{"out":"ERROR: Can't declare repeat (x) in \"my\" at (eval 1) line 1, near \") =\"\n","err":"","code":"use v5.21; my ($a, $b, (undef) x 3, $c) = (1..10); [$a, $b, $c]\n"},{"out":"ERROR: Missing $ on loop variable at (eval 1) line 1, <STDIN> line 1.\n","code":"use v5.21; use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); for my \\%hash (@a) {print Dumper(%hash);}\n","err":""},{"out":"ERROR: Missing $ on loop variable at (eval 1) line 1, <STDIN> line 1.\n","code":"use v5.21; use feature qw(refaliasing);use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); foreach my \\%hash (@a) {print Dumper(%hash);}\n","err":""},{"code":"use v5.21; use feature qw(refaliasing);use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); for \\%hash (@a) {print Dumper(%hash);}\n","err":"","out":"$VAR1 = 'bar';\n$VAR2 = 2;\n$VAR3 = 'foo';\n$VAR4 = 1;\n$VAR1 = 'problems';\n$VAR2 = 99;\n$VAR3 = 'bitches';\n$VAR4 = 0;\n"},{"code":"use v5.21; use feature qw(refaliasing);use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); for my \\%hash (@a) {print Dumper(%hash);}\n","err":"","out":"ERROR: Missing $ on loop variable at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"use v5.22; use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); for my \\%hash (@a) {print Dumper(%hash);}\n","err":"","out":"ERROR: Missing $ on loop variable at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use warnings; $_ = '@f@f@f'; s'@f'$b'gr; \n","out":"$b$b$b"},{"err":"The signatures feature is experimental at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; foo(3); sub foo(@) { print @_ }\n","out":"3"},{"code":"use warnings; foo(3); sub foo($) { print @_ }\n","err":"The signatures feature is experimental at (eval 1) line 1, <STDIN> line 1.\n","out":"3"},{"out":"","code":"use warnings; \"foo\" ~~ \"Bar\"\n","err":"Smartmatch is experimental at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: syntax error at (eval 1) line 1, near \"\"Bar\":\"\n","code":"use warnings; \"foo\" ~~ \"Bar\":\n","err":"Smartmatch is experimental at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"{ber => undef,foo => \"bar\"}","code":"use warnings; +{ foo => bar => 'ber' }\n","err":"Odd number of elements in anonymous hash at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"1","err":"Use of uninitialized value $key in hash slice at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; @hash{$key} = [ @list ];\n"},{"code":"use warnings; my $foo = 1; my $foo_bar = 2; \"$foo\\_bar\"\n","err":"","out":"1_bar"},{"out":"1\bar","err":"","code":"use warnings; my $foo = 1; my $foobar = 2; \"$foo\\bar\"\n"},{"out":"0","code":"use warnings; my ($foo) if 0;\n","err":"Deprecated use of my() in false conditional at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"use warnings; my $j = 'Foo'; $j =~ tr/\\x20-\\xff/\\xff10-\\xffff/; binmode STDOUT; print $j;\n","out":"T}}"},{"out":"T}}","code":"use warnings; my $j = 'Foo'; $j =~ tr/\\x20-\\xff/\\xff30-\\xffff/; binmode STDOUT; print $j;\n","err":""},{"out":"[]","code":"use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; [ eval qq{ 'Just another Unicode hacker,' =~ tr[$l][$r]r } ];\n","err":""},{"out":"","code":"use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; eval qq{ 'Just another Unicode hacker,' =~ tr[$l][$r]r };\n","err":""},{"out":"Transliteration pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; eval qq{ 'Just another Unicode hacker,' =~ tr[$l][$r]r }; $@\n","err":""},{"code":"use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; eval qq{ 'Just another Unicode hacker,' =~ tr[\\Q$l\\E][\\Q$r\\E]r };\n","err":"","out":"Ã¯Â¼ÂªustÃ¯Â¼ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂtÃ¯Â½ÂÃ¯Â½ÂrÃ¯Â¼ÂÃ¯Â¼ÂµÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂrÃ¯Â¼Â"},{"out":"","code":"use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; eval qq{ 'Just another Unicode hacker,' =~ tr[\\Q$l\\E][\\Q$r\\E]r }; $@\n","err":""},{"code":"use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; $l\n","err":"","out":" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnop"},{"code":"use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; $r\n","err":"","out":"Ã¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼Â Ã¯Â¼Â¡Ã¯Â¼Â¢Ã¯Â¼Â£Ã¯Â¼Â¤Ã¯Â¼Â¥Ã¯Â¼Â¦Ã¯Â¼Â§Ã¯Â¼Â¨Ã¯Â¼Â©Ã¯Â¼ÂªÃ¯Â¼Â«Ã¯Â¼Â¬Ã¯Â¼Â­Ã¯Â¼Â®Ã¯Â¼Â¯Ã¯Â¼Â°Ã¯Â¼Â±Ã¯Â¼Â²Ã¯Â¼Â³Ã¯Â¼Â´Ã¯Â¼ÂµÃ¯Â¼Â¶Ã¯Â¼Â·Ã¯Â¼Â¸Ã¯Â¼Â¹Ã¯Â¼ÂºÃ¯Â¼Â»Ã¯Â¼Â¼Ã¯Â¼Â½Ã¯Â¼Â¾Ã¯Â¼Â¿Ã¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½Â"},{"err":"Use of uninitialized value in substitution iterator at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value in substitution iterator at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value in substitution iterator at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my $u = 'ABC'; say $u =~ s/./pos $u/ger;\n","out":"\n"},{"out":"","code":"use warnings; my @x = (1...4); undef @x;\n","err":""},{"out":"0","code":"use warnings; my $x; $x++;\n","err":""},{"out":"1","code":"use warnings; my $x; ++$x;\n","err":""},{"out":"-4","code":"use warnings; my $x; $x -= 4;\n","err":""},{"out":"4","err":"","code":"use warnings; my $x; $x .= 4;\n"},{"code":"use warnings; my $x; $x += 4;\n","err":"","out":"4"},{"code":"use warnings; my $x; $x . 'foo'\n","err":"Use of uninitialized value $x in concatenation (.) or string at (eval 1) line 1, <STDIN> line 1.\n","out":"foo"},{"out":"-4","err":"Use of uninitialized value $x in subtraction (-) at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; my $x; $x = $x - 4;\n"},{"code":"use warnings; our $foo; sub foo { my $x = shift; BEGIN { $foo = \\$x }; $$foo }; [ foo(1), foo(2) ];\n","err":"Variable \"$x\" will not stay shared at (eval 1) line 1, <STDIN> line 1.\n","out":"[1,1]"},{"code":"use warnings; our $foo; sub foo { my $x = shift; BEGIN { $foo = \\$x }; ${ &{'FOO'}() } }; [ foo(1), foo(2) ];\n","err":"Variable \"$x\" will not stay shared at (eval 1) line 1, <STDIN> line 1.\n","out":"ERROR: Undefined subroutine &main::FOO called at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[0]","code":"use warnings; sub chomp { \"blah\" }; [ chomp ]\n","err":"Ambiguous call resolved as CORE::chomp(), qualify as such or use & at (eval 1) line 1, <STDIN> line 1.\nUse of uninitialized value $_ in scalar chomp at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"[1,1]","err":"Variable \"$x\" will not stay shared at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; sub foo { my $x = shift; use constant FOO => \\$x; ${ &{'FOO'}() } }; [ foo(1), foo(2) ];\n"},{"out":"In autoload! main::PRINTIn autoload! main::DESTROY","code":"use warnings; sub TIEHANDLE { bless [] }; sub AUTOLOAD { print \"In autoload! $AUTOLOAD\"; 42 }; tie *FH, 'main'; [ print FH 'adfasdf' ];\n","err":""},{"code":"use warnings; sub z { print shift }  z('â´')\n","err":"","out":"ÃÂ¢ÃÂÃÂ´"},{"err":"","code":"use warnings; sub z { }  z('â´')\n","out":""},{"code":"use warnings; use experimental 'smartmatch'; \"foo\" ~~ \"Bar\"\n","err":"","out":""},{"out":"","err":"","code":"use warnings; use experimental 'smartmatch'; \"foo\" ~~ \"Bar\";\n"},{"out":"All ok","err":"Useless use of smart match in void context at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; use experimental 'smartmatch'; \"foo\" ~~ \"Bar\"; \"All ok\"\n"},{"err":"","code":"use warnings; use strict; use experimental 'postderef'; my $x; my @z = @{ $x || [] }; $x->@*\n","out":"ERROR: Can't use an undefined value as an ARRAY reference at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't use an undefined value as an ARRAY reference at (eval 1) line 1, <STDIN> line 1.\n","err":"Useless use of a variable in void context at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnings; use strict; use experimental 'postderef'; my $x;  @{ $x || [] }; $x->@*\n"},{"out":"ERROR: Can't locate warnngs.pm:   (null): Too many open files at (eval 1) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 1) line 1, <STDIN> line 1.\n","code":"use warnngs; my $foo = 1; my $foo_bar = 2; \"$foo\\_bar\"\n","err":""},{"out":"v","err":"","code":"; ;;;;;;;;;;;;;;;;;;v\n"},{"code":"$V\n","err":"","out":""},{"out":"\u0000\u0001","code":"\"\".(v0.01)\n","err":""},{"out":"\u0000\u0001","err":"","code":"v0.01\n"},{"err":"","code":"v0.1\n","out":"\u0000\u0001"},{"out":"v255","code":"v.255\n","err":""},{"out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ ","code":"v3232.95.3232\n","err":""},{"code":"v5\n","err":"","out":"\u0005"},{"code":"v5 ^ 2\n","err":"","out":"2"},{"out":"[*DB::args,*DB::sub]","err":"","code":"[values %DB:: ]\n"},{"err":"","code":"$VERSION = 'blah';\n","out":"blah"},{"err":"","code":"$w = 3; $h = 4; @out = ( (0) x $w ) x $h; \n","out":"12"},{"err":"","code":"$w = 3; $h = 4; @out = ( (0) x $w ) x $h; \\@out\n","out":"[0,0,0,0,0,0,0,0,0,0,0,0]"},{"err":"","code":"\"W\\x{200d}â\"\n","out":"WÃÂ¢ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂÃÂ"},{"out":"+x","err":"","code":"- - 'x'\n"},{"code":"$x = 0; for (1..1000) {$x += 0.01;}; for (1..2000) {$x -= 0.005}; $x\n","err":"","out":"-3.32222097054746e-13"},{"out":"[undef,undef,1]","code":"@x = (1, 1, 1); delete @x[@x]; \\@x\n","err":""},{"out":"5","code":"$x = (1, (2, 3), 5); \n","err":""},{"err":"","code":"@x = (1, 2, 3); delete @x[@x]; \\@x\n","out":"[undef,undef,3]"},{"out":"ÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ","code":"\"\\x{1f31b}\\x{200D}\\x{1f31c}\"\n","err":""},{"out":"ÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ","err":"","code":"\"\\x{1f31b}\\x{200D}\\x{1f51c}\\x{200D}\\x{1f31c}\"\n"},{"out":"ÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ","code":"\"\\x{1f31c}\\x{200D}\\x{1f31b}\"\n","err":""},{"err":"","code":"\"\\x{1F466}\\x{200D}\\x{2764}\\x{FE0F}\\x{200D}\\x{1F48B}\\x{200D}\\x{1F468}\"\n","out":"ÃÂ°ÃÂÃÂÃÂ¦ÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂ¤ÃÂ¯ÃÂ¸ÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ¨"},{"out":"ÃÂ°ÃÂÃÂÃÂ¨ÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂ¤ÃÂ¯ÃÂ¸ÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ©","code":"\"\\x{1F468}\\x{200D}\\x{2764}\\x{FE0F}\\x{200D}\\x{1F48B}\\x{200D}\\x{1F469}\"\n","err":""},{"out":"ÃÂ°ÃÂÃÂÃÂ©ÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂ¤ÃÂ¯ÃÂ¸ÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ¨","code":"\"\\x{1F469}\\x{200D}\\x{2764}\\x{FE0F}\\x{200D}\\x{1F48B}\\x{200D}\\x{1F468}\"\n","err":""},{"err":"","code":"\"\\x{1F469}\\x{200D}\\x{2764}\\x{FE0F}\\x{200D}\\x{1F48B}\\x{200D}\\x{1F469}\"\n","out":"ÃÂ°ÃÂÃÂÃÂ©ÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂ¤ÃÂ¯ÃÂ¸ÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ©"},{"out":"ÃÂ°ÃÂÃÂÃÂ¸ÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ","err":"","code":"\"\\x{1F478}\\x{200D}\\x{1f31b}\"\n"},{"code":"\"\\x{1F478}\\x{200D}\\x{2764}\\x{FE0F}\\x{200D}\\x{1F48B}\\x{200D}\\x{1F438}\"\n","err":"","out":"ÃÂ°ÃÂÃÂÃÂ¸ÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂ¤ÃÂ¯ÃÂ¸ÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ¸"},{"err":"","code":"\"\\x{1f4a9}\"\n","out":"ÃÂ°ÃÂÃÂÃÂ©"},{"out":"[\"\\x{1f4a9}\"]","code":"[\"\\x{1f4a9}\"]\n","err":""},{"out":"ÃÂ°ÃÂÃÂÃÂ","err":"","code":"\"\\x{1f51c}\"\n"},{"out":"","code":"@x = (2, 1, 2); delete @x[2, 1, 2]; \n","err":""},{"err":"","code":"@x = (2, 1, 2); delete @x[2, 1, 2]; \\@a\n","out":"[]"},{"code":"@x = (2, 1, 2); delete @x[2, 1, 2]; \\@x\n","err":"","out":"[2]"},{"out":"[2]","err":"","code":"@x = (2, 1, 2); delete @x[2, 2, 1]; \\@x\n"},{"out":"","code":"@x = (2, 1, 2); delete @x[@x];\n","err":""},{"out":"[2,1,2]","code":"@x = (2, 1, 2); delete @x[~~@x]; \\@x\n","err":""},{"out":"[]","code":"@x = (2, 1, 2); delete @x[@x]; \\@x\n","err":""},{"out":"[4,5,6]","code":"@x = (4, 5, 6); delete @x[@x]; \\@x\n","err":""},{"out":"ÃÂÃÂ","err":"","code":"\"\\x{749}\"\n"},{"out":"ERROR: Attempt to bless into a reference at (eval 1) line 1, <STDIN> line 1.\n","code":"$x = []; bless $x, []; ref $x\n","err":""},{"out":"ÃÂ­ÃÂÃÂ","err":"","code":"\"\\x{D000}\"\n"},{"err":"","code":"[ 'X' =~ /(?i)x/]\n","out":"[1]"},{"code":"$_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]{1}(?![A-Z])/)\n","err":"","out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/( <-- HERE [A-Z]{1}(?![A-Z])/ at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"xml_p_arser","code":"$_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]{1}(?![A-Z]))/)\n","err":""},{"out":"xmlparser","err":"","code":"$_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]{1}(?![A-Z]*))/)\n"},{"out":"x_m_l_parser","code":"$_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]{1}[^A-Z]*)/)\n","err":""},{"code":"$_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]+(?=[^A-Z]*)/)\n","err":"","out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/( <-- HERE [A-Z]+(?=[^A-Z]*)/ at (eval 1) line 1, <STDIN> line 1.\n"},{"err":"","code":"$_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]+(?=[^A-Z]*))/)\n","out":"xmlp_arser"},{"err":"","code":"$_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]+[^A-Z]*)/)\n","out":"xmlparser"},{"err":"","code":"$_ = 'XMLParser'; [split /([A-Z]{1}(?![A-Z]))/)]\n","out":"ERROR: syntax error at (eval 1) line 1, near \"/([A-Z]{1}(?![A-Z]))/)\"\n"},{"out":"[\"XML\",\"P\",\"arser\"]","code":"$_ = 'XMLParser'; [split /([A-Z]{1}(?![A-Z]))/]\n","err":""},{"code":"$_ = 'XMLParser'; [split /([A-Z]*[^A-Z]*)/]\n","err":"","out":"[\"\",\"XMLParser\"]"},{"out":"[1]","code":"[ 'XX' =~ /(?i)xx/]\n","err":""},{"out":"[]","code":"[ 'XX' =~ /((?i)x)x/]\n","err":""},{"out":"ERROR: Substitution pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n","code":"'XYXYXYXY foos' =~ s/(XY)*.+\n","err":""},{"code":"'XYXYXYXY foos' =~ s/(XY)+?\\1.+/$1/r\n","err":"","out":"XY"},{"code":"'XYXYXYXY foos' =~ s/(XY)+\\1.+/$1/r\n","err":"","out":"XY"},{"err":"","code":"'XYXYXYXY foos' =~ s/(XY)+?\\1.+//r\n","out":""},{"code":"'XYXYXYXY foos' =~ s/(XY)+\\1.+//r\n","err":"","out":""},{"code":"'XYXYXYXY foos' =~ s/(XY)+\\K\\1.+/$1/r\n","err":"","out":"XYXYXYXY"},{"code":"'XYXYXYXY foos' =~ s/(?:XY)+\\K\\1.+//r\n","err":"","out":"ERROR: Reference to nonexistent group in regex; marked by <-- HERE in m/(?:XY)+\\K\\1 <-- HERE .+/ at (eval 1) line 1, <STDIN> line 1.\n"},{"code":"'XYXYXYXY foos' =~ s/((?:XY))+\\K\\1.+//r\n","err":"","out":"XYXYXY"},{"code":"'XYXYXYXY foos' =~ s/((?:XY)+)\\K\\1.+//r\n","err":"","out":"XYXY"},{"out":"ERROR: Substitution pattern not terminated at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"'XYXYXYXY foos' =~ s/(XY)*XY.+\n"},{"err":"","code":"$x * $y // $z\n","out":"0"},{"code":"You know what I like about perl? It's the fact that this English sentence is perfectly parsable! Some may say: \"no way\", but I got deparse to prove it\n","err":"","out":"\nERROR: Can't locate object method \"Some\" via package \"may\" (perhaps you forgot to load \"may\"?) at (eval 1) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Unrecognized character \\x80; marked by <-- HERE after tures/; $ÃÂ<-- HERE near column 93 at (eval 1) line 1, <STDIN> line 1.\n","err":"","code":"$Ï = 42; say $Ï\n"}]}