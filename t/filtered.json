{"evals/evals-freenode-#perl.lst":[{"out":"18446744073709551615","err":"","code":"~-~()\n"},{"err":"","out":"[1]","code":" [ \"(\" =~ /[(]/ ]\n"},{"code":" [ \"]\" =~ /[\\]]/ ]\n","err":"","out":"[1]"},{"code":"- - _\n","out":"+_","err":""},{"out":"+","err":"","code":"- '-'\n"},{"out":"-HASH(0x58e6110)","err":"","code":"-(''.{})\n"},{"code":"-{}\n","out":"-75293984","err":""},{"code":";;\n","err":"","out":""},{"code":":)\n","out":"ERROR: syntax error at (eval 558) line 1, near \"; :\"\n","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"; ?\"\n","err":"","code":"?\n"},{"code":"?^?\n","out":"ERROR: syntax error at (eval 558) line 1, near \"; ?\"\n","err":""},{"out":"1","err":"","code":"/^+/\n"},{"err":"","out":"","code":"/[^]]/\n"},{"code":"/[/\n","err":"","out":"ERROR: Unmatched [ in regex; marked by <-- HERE in m/[ <-- HERE / at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"1","err":"","code":"/${#}/\n"},{"code":"/$#/\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"; /$#/\"\n"},{"code":"/$#//\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"; /$#/\"\n"},{"out":"ERROR: Quantifier follows nothing in regex; marked by <-- HERE in m/* <-- HERE */ at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"/**/\n"},{"code":"...\n","err":"","out":"ERROR: Unimplemented at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"^\\/\\/","code":"'^\\/\\/'\n"},{"out":"1","err":"","code":"'=' =~ /=/\n"},{"code":"''\n","out":"","err":""},{"out":"ARRAY(0x5571228)","err":"","code":"''.[]\n"},{"code":"'@' ^ '$'\n","err":"","out":"d"},{"code":"\"\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"\"'\" =~ /'/\n","err":"","out":"1"},{"err":"","out":"SCALAR(0x54557e0)","code":"\"\" . \\ \"\"\n"},{"out":"SCALAR(0x4faa728)SCALAR(0x52de348)","err":"","code":"\"\" . \\ \"\" . \\ \"\"\n"},{"code":"\"\" . \\\\ \"\"\n","out":"REF(0x608e6f0)","err":""},{"code":"\"\"->()\n","err":"","out":"ERROR: Undefined subroutine &main:: called at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"1","code":"\"[\" =~ /[[]/\n"},{"code":"\"$_\"\n","err":"","out":""},{"code":"\"$( $)\"\n","out":"65534 65534 65534 65534","err":""},{"code":"\"${}\"\n","out":"ERROR: syntax error at (eval 558) line 1, near \"${}\"\n","err":""},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"\"\\\"\n"},{"code":"\"\\[\"\n","err":"","out":"["},{"code":"\"â\"\n","out":"ÃÂ¢ÃÂÃÂ","err":""},{"code":"\"ã»ã\"\n","err":"","out":"ÃÂ£ÃÂÃÂ»ÃÂ£ÃÂÃÂ"},{"code":"();\n","err":"","out":""},{"err":"","out":"[\"\"]","code":"[~~( )]\n"},{"out":"[1]","err":"","code":"[ !() ]\n"},{"code":"[ @_ ]\n","err":"","out":"[\"[ \\@_ ]\"]"},{"code":"[ $| ]\n","err":"","out":"[1]"},{"err":"","out":"[26662]","code":"[ $$ ]\n"},{"code":"[ $$$ ]\n","out":"[undef]","err":""},{"err":"","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after tures/; [ <-- HERE near column 93 at (eval 558) line 1, <STDIN> line 1.\n","code":"[ â´ ]\n"},{"code":"['\n","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"['']\n","out":"[\"\"]","err":""},{"code":"[\"\"]\n","out":"[\"\"]","err":""},{"out":"[]","err":"","code":"[]\n"},{"out":"","err":"","code":"[] == []\n"},{"code":"[]->$#*\n","err":"","out":"-1"},{"code":"[{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',]\n","out":"[\"HASH(0x5eab750)\",\"HASH(0x5eab678)\",\"HASH(0x5eab708)\",\"HASH(0x5eab690)\",\"HASH(0x4cb5648)\",\"HASH(0x5b75a38)\",\"HASH(0x5b75a08)\",\"HASH(0x5b75a50)\",\"HASH(0x5b75a98)\",\"HASH(0x5b75a80)\",\"HASH(0x5b75ac8)\",\"HASH(0x5eab8e8)\"]","err":""},{"code":"[@_]\n","err":"","out":"[\"[\\@_]\"]"},{"out":"[1,0,1,0]","err":"","code":"[$|--, $|--, $|--, $|--]\n"},{"err":"","out":"[undef]","code":"[$_]\n"},{"code":"[$,, $;]\n","out":"[undef,\"\\34\"]","err":""},{"out":"[\"\\34\"]","err":"","code":"[$;]\n"},{"err":"","out":"[\" \"]","code":"[$\"]\n"},{"err":"","out":"[0]","code":"[$[]\n"},{"err":"","out":"[\"\"]","code":"[$@]\n"},{"code":"[++$|, ++$|, --$|, --$|]\n","err":"","out":"[1,1,1,1]"},{"code":"[++$|, ++$|]\n","err":"","out":"[1,1]"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, near \"$|]\"\n","code":"[++$|; ++$|]\n"},{"code":"{;} + {}\n","err":"","out":"{}"},{"code":"{} {}\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"} {\"\n"},{"code":"{} + {}\n","err":"","out":"207187080"},{"err":"","out":"1","code":"@_\n"},{"code":"@{ [] } // []\n","out":"0","err":""},{"err":"","out":"0","code":"@{[]}=()\n"},{"code":"@#\n","err":"","out":"0"},{"out":"","err":"","code":"@#{ [] }\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":"","code":"$\n"},{"out":"\u001c","err":"","code":"$^_^$;;\n"},{"err":"","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","code":"$_ = '\n"},{"err":"","out":"\u001c","code":"$;\n"},{"code":"$!\n","err":"","out":"Too many open files"},{"code":"$!->()\n","out":"ERROR: Undefined subroutine &main::Too many open files called at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"$?\n","err":"","out":"0"},{"err":"","out":" ","code":"$\"\n"},{"err":"","out":" ","code":"$\";\n"},{"err":"","out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 558) line 1, <STDIN> line 1.\n","code":"$[++\n"},{"code":"$]\n","out":"5.022001","err":""},{"code":"$@\n","err":"","out":""},{"code":"$$\n","err":"","out":"26798"},{"code":"$#\n","out":"","err":""},{"out":"0","err":"","code":"$%\n"},{"out":"*main::_","err":"","code":"*_\n"},{"err":"","out":"*main::","code":"*{\"\"}\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"*{\"\n","err":"","code":"*{}\n"},{"code":"\\[]->[[]]\n","out":"","err":"Out of memory!\n"},{"out":"\\{}","err":"","code":"\\{}\n"},{"out":"[\"\\\\\\@_\"]","err":"","code":"\\@_\n"},{"code":"\\@.\n","err":"","out":"[]"},{"code":"\\$_\n","err":"","out":"\\undef"},{"code":"â\n","err":"","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after natures/; <-- HERE near column 91 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"~0\n","err":"","out":"18446744073709551615"},{"code":"!0\n","out":"1","err":""},{"err":"","out":"","code":"!!0\n"},{"code":"\"\\0\"\n","out":"\u0000","err":""},{"out":"[0]","err":"","code":"[~~\"0\"]\n"},{"code":"[~0]\n","out":"['18446744073709551615']","err":""},{"err":"","out":"[\"\"]","code":"[ !!0 ]\n"},{"code":"[ \"\".{}, 0+{} ]\n","out":"[\"HASH(0x5a18410)\",94471064]","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"\"\"{\"\n","err":"","code":"[ \"\"{}, 0+{} ]\n"},{"err":"","out":"[0]","code":"[ 0 + 'â´' ]\n"},{"err":"","out":"[24,\"Too many open files\"]","code":"[ 0 + $!, \"$!\" ]\n"},{"err":"","out":"[\"\"]","code":"[!!\"0\"]\n"},{"code":"['0' .. ':']\n","err":"","out":"[0,1,2,3,4,5,6,7,8,9]"},{"code":"[\"\\0\"]\n","err":"","out":"[\"\\0\"]"},{"out":"105568408","err":"","code":"[] + 0\n"},{"out":"88392632","err":"","code":"[]+0\n"},{"out":"/home/ryan/bots/perlbuut/lib/eval.pl","err":"","code":"$0\n"},{"code":"$_ = '0'; $_++; $_\n","out":"1","err":""},{"err":"","out":"$_[0]","code":"$_[0]\n"},{"code":"\\0\n","err":"","out":"\\0"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"0!\"\n","code":"0!\n"},{"out":"85156008","err":"","code":"0+[]\n"},{"err":"","out":"97132744","code":"0+{}\n"},{"err":"","out":"1","code":"!!'0.0'\n"},{"err":"","out":"SCALAR(0x66b7ff0)SCALAR(0x66b8068)","code":"\"\" . \\ 0 . \\ 0\n"},{"code":"[ (!!0) + 0 ]\n","out":"[0]","err":""},{"out":"[1]","err":"","code":"[(0 ** 0)]\n"},{"code":"$0->[0]\n","err":"","out":""},{"code":"0 ^ 0\n","err":"","out":"0"},{"code":"0 == 0\n","out":"1","err":""},{"code":"0->[0]\n","out":"","err":""},{"err":"","out":"ERROR: Illegal division by zero at (eval 558) line 1, <STDIN> line 1.\n","code":"0/0\n"},{"err":"","out":"1","code":"0**0\n"},{"out":"ERROR: Unrecognized character \\xC2; marked by <-- HERE after ures/; 0+ <-- HERE near column 94 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"0+ Â½\n"},{"code":"0+'Â½'\n","out":"0","err":""},{"out":"001","err":"","code":"$_ = '000'; $_++; $_\n"},{"err":"","out":"ERROR: Segmentation Fault\n","code":"&{0 == &{0 == 0}} * 0\n"},{"err":"","out":"foo","code":"\"000000\" && \"foo\";\n"},{"code":"[ 0.00_02 ]\n","err":"","out":"[\"0.0002\"]"},{"err":"","out":"[0]","code":"[\"0.00_02\" + 0]\n"},{"code":"'000202056D4C' =~ s/..\\K\\B/:/gr\n","err":"","out":"00:02:02:05:6D:4C"},{"code":"0+!! 0==1\n","out":"","err":""},{"err":"","out":"0","code":"(001234 ^ 01234) =~ /(^\\0*)/; length $1\n"},{"code":"0+!!(0==1) # what I probably meant\n","out":"0","err":""},{"out":"1","err":"","code":"'008' == 8\n"},{"out":"['18446744073709551615',\"18,446,744,073,709,551,615\"]","err":"","code":"[ ~0, ~0 =~ s/(?=(\\d{3})+$)/,/gr ]\n"},{"code":"\"00\" ? \"true\" : \"false\";\n","err":"","out":"true"},{"out":"[-32768]","err":"","code":"$_ = \"\\0\\0\"; vec($_, 7, 1)=1; [unpack \"s>\", $_]\n"},{"code":"[ 0 & 0xFF, 0 >> 8 & 0xFF ]\n","out":"[0,0]","err":""},{"out":"1.84467440737096e+19","err":"","code":"~0 + 1\n"},{"code":"\"0\" | \"1\"\n","out":"1","err":""},{"err":"","out":"[0,1]","code":"[0,1]\n"},{"code":"$< = $$ ? 0+<=><=><=>:+1\n","err":"","out":"65534"},{"code":"$_ = '0.1'; $_++; $_\n","out":"1.1","err":""},{"out":"0","err":"","code":"0/1\n"},{"code":"~0 + 1 > ~0\n","err":"","out":""},{"code":"[0?1:0,0e0?1:0]\n","out":"[0,0]","err":""},{"code":"[0?1:0,0E0?1:0]\n","out":"[0,0]","err":""},{"out":"1","err":"","code":"[0, '1'] ~~ [0, 1]\n"},{"code":"\"010\" ~~ [ 10 ]\n","out":"1","err":""},{"code":"[ 0.1 + 0.2, ((0.1 + 0.2) == 0.3) ? 'y' : 'n' ] #weird\n","out":"[\"0.3\",\"n\"]","err":""},{"code":"((\"010\"+2)/(010+2))*5\n","out":"6","err":""},{"code":"0.1 + 0.2 - 0.3\n","err":"","out":"5.55111512312578e-17"},{"code":"~0 + 1 == ~0 ? 64 : 32\n","err":"","out":"64"},{"code":"0 + \"1+1\"\n","err":"","out":"1"},{"out":"[\"01101000\",\"01100101\",\"01101100\",\"01110000\"]","err":"","code":"[ \"01101000 01100101 01101100 01110000\" =~ /\\d+/g ]; ### ZoffixWeb, why does it return an array when \\d+ isn't in a capture group?\n"},{"code":"\"011112233\" =~ /^0[0-9]*\\s*\\z/\n","out":"1","err":""},{"code":"01.23\n","out":"123","err":""},{"err":"","out":"greater or equal","code":"01.23 >= 2.34 ? \"greater or equal\" : \"nope\"\n"},{"err":"","out":"1","code":"\"0123456\" ~~ 123_456\n"},{"out":"01:23:45:67:89:1b","err":"","code":"'01234567891b' =~ s/(..)(?!$)/$1:/gr\n"},{"code":"'01234567891b' =~ s/..\\K\\B/:/gr\n","out":"01:23:45:67:89:1b","err":""},{"code":"[ \"-0123456789abcdefghi\" =~ /[[:xdigit:]]/g ]\n","err":"","out":"[0,1,2,3,4,5,6,7,8,9,\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]"},{"code":"$_ = \"\\0\\1\\2\"; s/([\\x00-\\x1f])/\"\\x{2400}\" | $1/eg; $_\n","out":"ÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂ","err":""},{"code":"$_ = \"\\0\\1\\2\"; s/([\\x00-\\x1f])/\"\\x{2400}\" | $1/eg; \\$_\n","out":"\\\"\\x{2400}\\x{2401}\\x{2402}\"","err":""},{"err":"","out":"1.5","code":"\"0\" | \"1.5\"\n"},{"code":"[ 0 .. 15 ]\n","out":"[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]","err":""},{"out":"[\"1.5\"]","err":"","code":"[\"0\" | \"1.5\"]\n"},{"out":"0","err":"","code":"(0)*150\n"},{"code":"01777\n","out":"1023","err":""},{"code":"[ Â¡!0, Â¡!1 ] # this might not \"work\", for example\n","err":"","out":"ERROR: Unrecognized character \\xC2; marked by <-- HERE after tures/; [ <-- HERE near column 93 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"~0 + 2\n","out":"1.84467440737096e+19","err":""},{"code":"$#{[0..2]}\n","err":"","out":"2"},{"code":"~0 * 2 > ~0\n","out":"1","err":""},{"err":"","out":"0.166666666666667","code":"02/03/04\n"},{"out":"[5,10,3]","err":"","code":"[@{[0 .. 20]}[5,10,3]]\n"},{"out":"[17,15,13,11,9,\"Illegal octal digit '9' at (eval 559) line 1, at end of line\\n\"]","err":"","code":"[ 021, 017, 015, 013, 011, eval \"09\" || $@ ]\n"},{"err":"","out":"21","code":"025\n"},{"code":"0 % -3\n","err":"","out":"0"},{"code":"[ 0302, 0255 ]\n","err":"","out":"[194,173]"},{"out":"25","err":"","code":"031\n"},{"out":"[208,152]","err":"","code":"[0320, 0230]\n"},{"code":"\"\\034\"\n","out":"\u001c","err":""},{"code":"0377\n","err":"","out":"255"},{"code":"'03' lt '7'\n","err":"","out":"1"},{"code":"$$[0]=3; print @$\n","err":"","out":"3"},{"err":"","out":"[0,1,2,3,4]","code":"[0 .. 4]\n"},{"out":"[42]","err":"","code":"[ 0 || 42 ]\n"},{"code":"0 // 42\n","err":"","out":"0"},{"code":"0444\n","err":"","out":"292"},{"code":"0.45\n","out":"0.45","err":""},{"code":"[ 0.5, 0 .5, 0 . 5 ]\n","out":"[\"0.5\",\"05\",\"05\"]","err":""},{"code":"[ 0.5, 0. 5, 0 .5, 0 . 5 ]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"0. 5\"\n","err":""},{"err":"","out":"[\"0.64\",\"0.68\",\"0.72\"]","code":"[0.6 + 0.04, 0.64 + 0.04, 0.68 + 0.04]\n"},{"out":"476","err":"","code":"0734\n"},{"out":"1","err":"","code":"!! \"0/8\"\n"},{"out":"9","err":"","code":"0+'    9'\n"},{"out":"0.99999999999929","err":"","code":"0.99999999999929\n"},{"code":"0.9999999999999\n","out":"0.9999999999999","err":""},{"code":"0.99999999999999\n","err":"","out":"0.99999999999999"},{"code":"0.9999999999999901\n","out":"0.99999999999999","err":""},{"out":"","err":"","code":"0.9999999999999901 > 0.99999999999999\n"},{"out":"1","err":"","code":"0.9999999999999902 > 0.99999999999999\n"},{"code":"0.9999999999999919 > 0.9999999999999918\n","err":"","out":"1"},{"code":"$_ = \"0.9999999999999926\"; sprintf '%.*f', length, $_\n","err":"","out":"0.999999999999992562"},{"out":"0.999999999999992784","err":"","code":"$_ = \"0.9999999999999927\"; sprintf '%.*f', length, $_\n"},{"err":"","out":"[\"\",1]","code":"[ 0.999999999999999 == 1, 0.9999999999999999 == 1]\n"},{"out":"402","err":"","code":"0b1_10010010\n"},{"code":"0b111 >> 1\n","err":"","out":"3"},{"code":"0b11111\n","out":"31","err":""},{"err":"","out":"[31,25]","code":"[ 0b11111, oct(\"31\") ]\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"0bPortalMeme\n\"\n","code":"0bPortalMeme\n"},{"out":"1","err":"","code":"\"0 but true\" + 1\n"},{"err":"","out":"true","code":"'0 but true' ? 'true' : 'false'\n"},{"out":"Only perl can parse Perl!","err":"","code":"'0BZMNDSFZNQOBNDOFGSN1SFZ!' =~ tr/\\\"-;N-ZA-M/A-Z a-z/r\n"},{"err":"","out":"Only perl can parse Perl!","code":"'0BZMNDSFZNQOBNDOFGSN1SFZ!' =~ tr/\\\"-;N-ZA-M/A-Z a-z/r;\n"},{"code":"0E0 eq 0\n","err":"","out":"1"},{"err":"","out":"true","code":"'0e0' ? 'true' : 'false'\n"},{"code":"\"0e0\" ? \"true\" : \"false\"\n","out":"true","err":""},{"code":"0e0 ? 'true' :'false'\n","out":"false","err":""},{"out":"false","err":"","code":"0e0 ? \"true\" : \"false\"\n"},{"err":"","out":"0","code":"'0' && 'foo'\n"},{"code":"0 if 1\n","out":"0","err":""},{"code":"0+keys %INC\n","err":"","out":"498"},{"code":"0=~m{}=~y///d\n","err":"","out":"0"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"0o734\n\"\n","code":"0o734\n"},{"code":"0;qq{@{sub{]]}}}}}\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"{]\"\nUnmatched right curly bracket at (eval 558) line 1, at end of line\nUnmatched right curly bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, at EOF\n"},{"code":"[\"\\0\" ? \"T\" : \"F\"]\n","out":"[\"T\"]","err":""},{"out":"[\"f\",\"f\"]","err":"","code":"[ 0?'t':'f', 00?'t':'f' ]\n"},{"out":"[1]","err":"","code":"[ 0 == true ]\n"},{"code":"0 ? 'true' : 'false'\n","out":"false","err":""},{"code":"[ (0 == true) ? \"true\" : \"false ];\n","err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"[\"true\"]","code":"[ (0 == true) ? \"true\" : \"false\" ];\n"},{"code":"\"0\" == undef\n","out":"1","err":""},{"err":"","out":"[\"\",\"\",\"\"]","code":"[ !!0, !!\"\", !!undef ]\n"},{"out":"","err":"","code":"$_[ ~0 ] = undef\n"},{"err":"","out":"1","code":"0 == undef\n"},{"out":"[1,1,1,1]","err":"","code":"[ !0, !'', !undef, !'0' ]\n"},{"out":"ERROR: Invalid hexadecimal number in \\N{U+...} at (eval 558) line 1, within string\n","err":"","code":"'<0x000D>' =~ s/<0x(....)>/\"\\N{U+$1}\"/er\n"},{"out":"\r","err":"","code":"\"<0x000D>\" =~ s/<(0x[[:xdigit:]]{4})>/chr hex $1/ger\n"},{"out":"4","err":"","code":"\"<0x0034>\" =~ s/<(0x[[:xdigit:]]{4})>/chr hex $1/ger\n"},{"err":"","out":"255","code":"0x00FF\n"},{"out":"283","err":"","code":"0x011b;\n"},{"code":"0x03 & 0x07f\n","out":"3","err":""},{"code":"0x0x0x0\n","err":"","out":""},{"code":"\"0x10\" + 0\n","err":"","out":"0"},{"err":"","out":"[1114112,1114112]","code":"[0x110000, 2**20 + 2**16]\n"},{"out":"123","err":"","code":"0x1.23\n"},{"err":"","out":"1194684","code":"0x123abc\n"},{"code":"0x1.23p0\n","err":"","out":"1.13671875"},{"code":"0x1252\n","err":"","out":"4690"},{"code":"0x173\n","out":"371","err":""},{"code":"[0x173, unpack(\"n\", \"\\x01\\x73\"), unpack(\"v\", \"\\x73\\x01\")]\n","err":"","out":"[371,371,371]"},{"code":"[0x18, 0x12]\n","err":"","out":"[24,18]"},{"out":"26","err":"","code":"0x1a\n"},{"out":"0.0009765625","err":"","code":"0x1p-10\n"},{"out":"ERROR: Invalid hexadecimal number in \\N{U+...} at (eval 558) line 1, within string\n","err":"","code":"'<0x2004>' =~ s/<0x(....)>/\"\\N{U+$1}\"/er\n"},{"err":"","out":"51","code":"0x33 & 0x7f\n"},{"out":"945","err":"","code":"0x3b1\n"},{"out":"4","err":"","code":"0x4\n"},{"code":"0x4000\n","err":"","out":"16384"},{"err":"","out":"0x4000","code":"\"0x4000\"\n"},{"code":"0x41\n","out":"65","err":""},{"err":"","out":"","code":"0x4x0\n"},{"code":"0x61 & 0x31\n","err":"","out":"33"},{"code":"[0x7200, 0x720000]\n","out":"[29184,7471104]","err":""},{"out":"64","err":"","code":"0xC0 & 0x7f\n"},{"out":"[195,168]","err":"","code":"[0xc3, 0xa8]\n"},{"code":"0xcfedde\n","err":"","out":"13626846"},{"code":"0xCFEDDE\n","err":"","out":"13626846"},{"err":"","out":"14675422","code":"0xDFEDDE\n"},{"err":"","out":"255","code":"0xFF\n"},{"code":"0xFF & 0x07F\n","out":"127","err":""},{"out":"281462092005375","err":"","code":"0xffff**3\n"},{"code":"0 xor 0\n","err":"","out":""},{"code":"[ [0 xor 0], [1 xor 0], [0 xor 1], [1 xor 1] ]\n","err":"","out":"[[\"\"],[1],[1],[\"\"]]"},{"code":"[ 0 xor 0, 1 xor 0, 0 xor 1, 1 xor 1 ]\n","err":"","out":"[1]"},{"err":"","out":"1","code":"0 xor 1\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"0xpink_mist\n\"\n","err":"","code":"0xpink_mist\n"},{"code":"!0=~y///d\n","out":"0","err":""},{"out":"1","err":"","code":"1\n"},{"code":"~1\n","out":"18446744073709551614","err":""},{"code":"/(?(1)/\n","err":"","out":"ERROR: Switch (?(condition)... not terminated in regex; marked by <-- HERE in m/(?(1) <-- HERE / at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"'' . \\1\n","err":"","out":"SCALAR(0x5e16738)"},{"code":"\"1\"\n","out":"1","err":""},{"err":"","out":"1","code":"[] != -1\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"$ = 1\"\nsyntax error at (eval 558) line 1, at EOF\n","err":"","code":"$ = 1; ++$\n"},{"code":"$[ = 1\n","err":"","out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"1;\n","out":"1","err":""},{"err":"","out":"ERROR: Can't modify constant item in postincrement (++) at (eval 558) line 1, near \"1++\"\n","code":"1++\n"},{"code":"10\n","err":"","out":"10"},{"code":"-1%~0\n","out":"18446744073709551614","err":""},{"out":"\u0001","err":"","code":"'1' ^ '0'\n"},{"out":"ERROR: Illegal division by zero at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"1/0\n"},{"code":"[ '1' + 0 ^ '0' ]\n","out":"[1]","err":""},{"code":"100.\n","out":"100","err":""},{"code":"100/0.0000003\n","out":"333333333.333333","err":""},{"err":"","out":"1000000000","code":"100 * 10000000\n"},{"out":"0.2","err":"","code":"100./ 100./5\n"},{"code":"100. / 4\n","out":"25","err":""},{"code":"10 ** 0.5\n","out":"3.16227766016838","err":""},{"out":"[]","err":"","code":"[ \"100.5\" =~ /([-+]?\\d+)(\\.\\d+)?\\s*(g|mg)/ ]\n"},{"code":"[ \"100.5 g\" =~ /([-+]?\\d+)(\\.\\d+)?\\s*(g|mg)/ ]\n","out":"[100,\".5\",\"g\"]","err":""},{"code":"\"100.5 g\" =~ /([-+]?\\d+)(\\.\\d+)?\\s*(g|mg)/; [$1, $2, $3]\n","err":"","out":"[100,\".5\",\"g\"]"},{"code":"[ !1, !0, !1+0]\n","err":"","out":"[\"\",1,0]"},{"out":"[\"\",1]","err":"","code":"[ \"1.0\" != 1.0, \"1.0\" ne 1.0 ]\n"},{"err":"","out":"10.123","code":"10.123\n"},{"out":"ear","err":"","code":"101.97.114\n"},{"code":"102.0.114.0.111.0.109\n","err":"","out":"f\u0000r\u0000o\u0000m"},{"code":"1.0/2 + 1/4 + 1/8 + 2/16\n","out":"1","err":""},{"code":"1024 >> 6\n","err":"","out":"16"},{"code":"1.0 == 3.0/2.9999999999999999999999999999999999\n","err":"","out":"1"},{"code":"(1 == 0) + 5\n","out":"5","err":""},{"code":"10/7\n","out":"1.42857142857143","err":""},{"code":"1 - 0.99999999999903\n","err":"","out":"9.70001856614999e-13"},{"err":"","out":"1e+31","code":"10e30\n"},{"code":"10^length q|*******|\n","out":"13","err":""},{"err":"","out":"[10,11]","code":"$. = 10; my ($what_you_think, $what_it_is) = ($.++,$.); [ $what_you_think, $what_it_is ]\n"},{"err":"","out":"NaN","code":"1/(0*nan/nan)\n"},{"err":"","out":"0","code":"'10%s' % 2\n"},{"code":"'10%s' % 3\n","err":"","out":"1"},{"out":"11","err":"","code":"$. = 10; scalar($.++,$.)\n"},{"code":"$. = 10; [ [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ] ];\n","out":"[[10,\"\"],[11,\"\"],[12,\"\"],[13,\"\"],[14,\"\"],[15,\"\"]]","err":""},{"code":"$. = 10; [ [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ] ]\n","out":"[[1,10],[\"\",11],[\"\",12],[\"\",13],[\"\",14],[\"\",15]]","err":""},{"code":"$. = 10; while (10..15) { print \"$. \"; $.++ }\n","err":"","out":"10 11 12 13 14 15 "},{"out":"10 11 12 13 14 15 16 17 18 19 20 ","err":"","code":"$. = 10; while (10..20) { print \"$. \"; $.++ }\n"},{"out":"9223372036854775807","err":"","code":"-1 >> 1\n"},{"err":"","out":"[1]","code":"[ 1 == \"1\" ]\n"},{"code":"[1.1]\n","err":"","out":"[\"1.1\"]"},{"code":"$1$1\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"$1$1\n\"\n"},{"code":"1 ~~ '1'\n","err":"","out":"1"},{"code":"1+1\n","err":"","out":"2"},{"err":"","out":"2","code":"1+'1'\n"},{"out":"[1,1]","err":"","code":"[ (!!1) . '', (!!1) + 0 ]\n"},{"err":"","out":"[]","code":"[() = (1..10)]\n"},{"out":"[1,2,3,4,5,6,7,8,9,10]","err":"","code":"[1 .. 10]\n"},{"out":"0.0909090909090909","err":"","code":"1/11\n"},{"out":"[1,1,1,0]","err":"","code":"[ 1 | 1, 1 | 0, 0 | 1, 0 | 0 ]\n"},{"code":"\"111\" >> 1\n","err":"","out":"55"},{"err":"","out":"[[5,1,1],[4,2,1],[4,1,2],[3,3,1],[3,2,2],[3,1,3],[2,4,1],[2,3,2],[2,2,3],[2,1,4],[1,5,1],[1,4,2],[1,3,3],[1,2,4],[1,1,5]]","code":"1111111 =~ /^(1{1,10})(1{1,10})(1{1,10})$(?{ push @comb, [$1, $2, $3] })(?!)/; [map [map length, @$_], @comb]\n"},{"code":"\"111\" >> 2\n","out":"27","err":""},{"code":"[ (1,1,(),((1,2),,,,,,,3)) ]\n","err":"","out":"[1,1,1,2,3]"},{"err":"","out":"0.846153846153846","code":"11/13\n"},{"err":"","out":"0.733333333333333","code":"11/15;\n"},{"err":"","out":"28416","code":"\"111\" << 8\n"},{"code":"\"111\" >> 8\n","out":"0","err":""},{"code":"[ 1 << 1, 2 << 1, 3 << 1 ]\n","err":"","out":"[2,4,6]"},{"code":"\"1122\" =~ s/\\d\\d(\\d\\d)??//r #let's try\n","out":"22","err":""},{"code":"\"1122\" =~ s/\\d\\d(\\d\\d)?//r #no, it's greedy, Iota\n","out":"","err":""},{"err":"","out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 558) line 1, <STDIN> line 1.\n","code":"$[ = -1; (1, 2, 3)[-2]\n"},{"code":"-1 & 127 # piko` - at a guess you're just getting this, and perldoc -f system covers it\n","err":"","out":"127"},{"code":"{ 1+1 => 2, cats => 'dogs' }\n","err":"","out":"dogs"},{"out":"{cats => \"dogs\",2 => 2}","err":"","code":"+{ 1+1 => 2, cats => 'dogs' }\n"},{"out":"0.769230769230769","err":"","code":"1/1.3\n"},{"code":"1.139999999999999\n","out":"1.14","err":""},{"out":"16384","err":"","code":"1 << 14\n"},{"out":"1","err":"","code":"'11' lt '7'\n"},{"out":"[]","err":"","code":"[-1 .. -2]\n"},{"code":"[1,,,,,,2,,,,,,,]\n","err":"","out":"[1,2]"},{"code":"1 + 2\n","err":"","out":"3"},{"out":"3","err":"","code":"1+2\n"},{"code":"{ 1 => [21] }\n","err":"","out":"{1 => [21]}"},{"out":"1","err":"","code":"1/2 + 1/4 + 1/8 + 2/16\n"},{"err":"","out":"1","code":"1./2 + 1/4 + 1/8 + 2/16\n"},{"out":"match","err":"","code":"'12' =~ /1\\B2/ ? 'match' : 'nope'\n"},{"err":"","out":"[-1,0,1]","code":"[1<=>2, 2<=>2, 3<=>2]\n"},{"code":"[ \"1.22.333.4\" =~ /\\d+/g ]\n","out":"[1,22,333,4]","err":""},{"code":"~~1.23\n","err":"","out":"1"},{"out":"5.55111512312578e-17","err":"","code":".1 + .2 - .3\n"},{"code":".1+.2-.3\n","out":"5.55111512312578e-17","err":""},{"err":"","out":"","code":"(.1 + .2 == .3)\n"},{"code":"(1, 2, 3)\n","err":"","out":"3"},{"err":"","out":"1","code":"(1+2==3)\n"},{"code":"[ , 1 , 2 , 3 ]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"[ ,\"\n"},{"out":"[\\1,\\2,\\3]","err":"","code":"[ \\(1, 2, 3) ]\n"},{"code":"[ 1.2.3 . \"\" ]\n","out":"[\"\\1\\2\\3\"]","err":""},{"err":"","out":"123","code":"\"123\" & 0x00FF;\n"},{"err":"","out":"[1,2,2,3]","code":"[ %{[ 1, 2, 3 ]}[ 1,2 ] ]\n"},{"err":"","out":"1","code":"123 == '123abc  '\n"},{"out":"2","err":"","code":"(1,2,3)[1.5]\n"},{"err":"","out":"[\"1.2.3.19\"]","code":"[ \"1.2.3.192/26\" =~ /((?:\\d{1,3}\\.){3}\\d{1,3})(?!\\/)/ ]\n"},{"out":"ERROR: Unmatched ) in regex; marked by <-- HERE in m/((?:\\d{1,3}\\.){3}\\d{1,3})(?!/)) <-- HERE / at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"[ \"1.2.3.192/26\" =~ /((?:\\d{1,3}\\.){3}\\d{1,3})(?!\\/))/ ]\n"},{"code":"[ \"1.2.3.192/26\" =~ ((?:\\d{1,3}\\.){3}\\d{1,3})(?!\\/) ]\n","err":"","out":"ERROR: Search pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"\"@{[1 2 3 4]}\"\n","out":"ERROR: syntax error at (eval 558) line 1, near \"1 2\"\n","err":""},{"code":"\"@{[1, 2, 3, 4]}\"\n","err":"","out":"1 2 3 4"},{"code":"'12341234' =~ /.*(3.*)/; $1\n","out":"34","err":""},{"out":"123.4567","err":"","code":"\"123.45670000000\" + 0\n"},{"err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","code":"\"123.45670000000\"\" + 0\n"},{"out":"1","err":"","code":"\" 1234567 \" =~ / [0-9]{7} /;\n"},{"err":"","out":"[undef]","code":"$_ = \"1234567\"; /.{5,}/; [$1]\n"},{"code":"$_ = \"1234567\"; /(.){5,}/; [$1]\n","out":"[7]","err":""},{"code":"$_ = \"1234567\"; /(.{5,})/; [$1]\n","err":"","out":"[1234567]"},{"out":"","err":"","code":"\" 12345678 \" =~ / [0-9]{7} /;\n"},{"code":"123456789012 =~ s/(\\d\\d\\d)/$1,/gr\n","err":"","out":"123,456,789,012,"},{"code":"[ '1234567890' =~ /.{1,3}/g ]\n","err":"","out":"[123,456,789,0]"},{"out":"123,456,789,0","err":"","code":"1234567890 =~ s/(\\d\\d\\d)/$1,/gr\n"},{"code":"[ \"12345678\" =~ m/(\\d+{4})/g ]\n","out":"ERROR: Nested quantifiers in regex; marked by <-- HERE in m/(\\d+{ <-- HERE 4})/ at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"[1234,5678]","err":"","code":"[ \"1234 5678\" =~ m/(\\d+)/g ]\n"},{"out":"[12345678]","err":"","code":"[ \"12345678\" =~ m/(\\d+)/g ]\n"},{"code":"$_=\"1234567\"; s/(\\d\\d\\d)/$1,/g; $_\n","out":"123,456,7","err":""},{"code":"[(1,2), (3,4), (5,6)] # Not what you think it will be, petrutrimbitas\n","err":"","out":"[1,2,3,4,5,6]"},{"code":"\"123456\" =~ s/../reverse $&/ger\n","out":"214365","err":""},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$_ = \"123.456str789; $_++; $_\n"},{"err":"","out":"124.456","code":"$_ = \"123.456str789\"; $_++; $_\n"},{"err":"","out":"ERROR: Can't modify constant item in substitution (s///) at (eval 558) line 1, at EOF\n","code":"\"1/2/3/4/5\" =~ s{^.*/(?=[^/])}{}\n"},{"code":"1.2345 =~ /^([^.])(\\..*)?/ && sprintf( q{%03d}, $1 ). ( $2 // q{} ); ### leobut\n","out":"001.2345","err":""},{"code":"\"1/2/3/4/5/\" =~ s{^.*/(?=[^/]$)}{}r\n","err":"","out":"1/2/3/4/5/"},{"code":"\"1/2/3/4/5\" =~ s{^.*/(?=[^/])}{}r\n","err":"","out":"5"},{"err":"","out":"5","code":"\"1/2/3/4/5\" =~ s{^.*/(?=[^/]$)}{}r\n"},{"code":"\"1234abc\"+0\n","out":"1234","err":""},{"code":"'+1234' =~ m/^+/\n","out":"1","err":""},{"code":"'+1234' =~ s/^+//\n","err":"","out":"ERROR: Can't modify constant item in substitution (s///) at (eval 558) line 1, at EOF\n"},{"code":"'+1234' =~ s/^+//r\n","out":"+1234","err":""},{"out":"[\"1234x\",123]","err":"","code":"[\"1234x 123y\" =~ /\\d*(?:[02468]\\D|[13579])/g ]\n"},{"out":"[\"1234x\",\"123y\"]","err":"","code":"[\"1234x 123y\" =~ m{((?>\\d+)(?(?{$1 % 2 == 0}).))}g]\n"},{"code":"[\"1234x 123y\" =~ m{((?>(\\d+))(?(?{$2 % 2 == 0}).))}g]\n","err":"","out":"[\"1234x\",1234,123,123]"},{"out":"12351","err":"","code":"12351\n"},{"code":"[ \"123 5 12 7 \" =~ /(\\d+)\\s*/g ] # or just numbers?\n","err":"","out":"[123,5,12,7]"},{"code":"[ \"123 5 12 7 \" =~ m/(?<num>\\d+)(?<space>\\s*)/g ]; \\%+\n","err":"","out":"{}"},{"out":"{num => 7,space => \" \"}","err":"","code":"[ \"123 5 12 7 \" =~ m/(?<num>\\d+)(?<space>\\s*)/g ]; +{ %+ } # scope, I think?\n"},{"code":"\"123abc\" + 1\n","out":"124","err":""},{"code":"$_ = \"123AG3GCAT422TG3\"; [/([:alpha:]+)/]\n","out":"[]","err":""},{"code":"$_ = \"123AG3GCAT422TG3\"; [/([[:alpha:]]+)/]\n","err":"","out":"[\"AG\"]"},{"err":"","out":"[\"AG\",\"GCAT\",\"TG\"]","code":"$_ = \"123AG3GCAT422TG3\"; [/([[:alpha:]]+)/g]\n"},{"out":"[123,\"AG\",3,\"GCAT\",422,\"TG\",3]","err":"","code":"$_ = \"123AG3GCAT422TG3\"; [split /([[:alpha:]]+)/]\n"},{"code":"[ \"[123]a test\\n[345] second\\nthird\\n[456]more\\n\" =~ /(^\\[.*?(?=^\\[|$))/gsm ]\n","err":"","out":"[\"[123]a test\",\"[345] second\",\"[456]more\"]"},{"code":"[ \"[123]a test\\n[345] second\\nthird\\n[456]more\\n\" =~ /(^\\[.*?(?=^\\[|\\z))/gsm ]\n","out":"[\"[123]a test\\n\",\"[345] second\\nthird\\n\",\"[456]more\\n\"]","err":""},{"out":"","err":"","code":"1.2.3 eq \"1.2.3\"\n"},{"code":"'123' eq lc('123')\n","out":"1","err":""},{"err":"","out":"1","code":"\"123\" eq uc \"123\";\n"},{"out":"128","err":"","code":"\"123 HAI STRINGS ARE COOL\" + 5\n"},{"out":"","err":"","code":"\"1.2.3\" lt \"1.10.0\"\n"},{"err":"","out":"1","code":"1.2.3 lt 1.10.0\n"},{"out":"[\"1_2_\",\"1_\"]","err":"","code":"$_ = '1_2_3'; m/(\\w*_)/; push @arr, $1; m/(\\w*?_)/; push @arr, $1; \\@arr\n"},{"err":"","out":"123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n","code":"$_=123;print eval'$_++.$/,'x10\n"},{"out":"13","err":"","code":"\"123\" =~ s/2//gr\n"},{"out":"[1,2,3]","err":"","code":"$_ = '1 2 3'; [ split ];\n"},{"err":"","out":"124","code":"$_ = \"123str456\"; $_++; $_\n"},{"code":"*{123} = sub { \"D:\" }; &123\n","err":"","out":"D:"},{"out":"D:","err":"","code":"*{123} = sub { \"D:\" }; 123->()\n"},{"out":"ERROR: Undefined subroutine &main::D: called at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"*{123} = sub { \"D:\" }; \\&123->()  # guessing this is also wrong\n"},{"code":"*{123} = sub { \"D:\" }; (bless {})->123\n","out":"ERROR: syntax error at (eval 558) line 1, near \"->123\"\n","err":""},{"err":"","out":"5676","code":"12*473\n"},{"out":"some text","err":"","code":"\"125 some text\" =~ s/^[1-9][0-9]* //r\n"},{"code":"[ 127.0.0.1 . \"\"]\n","err":"","out":"[\"\\177\\0\\0\\1\"]"},{"out":"[127.0.0.1]","err":"","code":"[ 127.0.0.1 ]\n"},{"code":"128.129.130\n","out":"ÃÂÃÂÃÂ","err":""},{"err":"","out":"0","code":"(\"12 bananas buys you 0.1 ruby\" =~ /\\d+/g)[1]\n"},{"out":"1","err":"","code":"(\"12 bananas buys you 1 ruby\" =~ /\\d+/g)[1]\n"},{"err":"","out":"1","code":"'?=12' =~ /^\\?(?:=(\\d+))?/\n"},{"code":"$. = 12; my $x = 10..20; [ $x ]; ### I've read the link but think I'm misunderstanding something. $. appears to be within that range but it still returns false.\n","err":"","out":"[\"\"]"},{"err":"","out":"[12,13,14]","code":"[ \"12\\n13\\n14\" =~ /(\\d+)/g ]\n"},{"err":"","out":"12","code":"@; = (1, 2); print @;;\n"},{"code":"[ 1, 2 ] # these brackets?\n","err":"","out":"[1,2]"},{"out":"4","err":"","code":"\"@{[ 1+3 ]}\"\n"},{"err":"","out":"4","code":"\"${\\( 1+3 )}\"\n"},{"code":"\"1\" & \"3\"\n","err":"","out":"1"},{"code":"1 % -3\n","err":"","out":"-2"},{"err":"","out":"0.91","code":"1.3 * 0.7\n"},{"code":"[ \"1:30\" =~ /(?:(\\d*):)?(\\d+)/ ]\n","err":"","out":"[1,30]"},{"code":"[((1 << 3) - 1), 1+2+4]\n","out":"[7,7]","err":""},{"err":"","out":"4294967296","code":"1<<32\n"},{"code":"134.95 * 100\n","out":"13495","err":""},{"code":"[  '1-3,5,6-9' =~ s/(\\d+)-(\\d+)/join ',', $1..$2/ger ]\n","out":"[\"1,2,3,5,6,7,8,9\"]","err":""},{"code":"\".1.3.6.1.2.1.43.11.1.1.6.1.1\" =~ m/\\.(?!5|4|12)$/\n","err":"","out":""},{"code":"1.3e12 / 300e6\n","err":"","out":"4333.33333333333"},{"code":"[ \"13month\" =~ /(\\d+)(\\w+)/ ]\n","err":"","out":"[13,\"month\"]"},{"code":"[1..4]\n","out":"[1,2,3,4]","err":""},{"out":"3","err":"","code":"@_ = (1..4); $#_\n"},{"code":"[((1 << 4) - 1), 1+2+4+8]\n","err":"","out":"[15,15]"},{"err":"","out":"90000","code":"1414364400 - 1414274400\n"},{"out":"1.43531264539073e-10","err":"","code":"'1.43531264539073e-11' * 10\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"4 <\"\n","err":"","code":"1 < 4 < 6\n"},{"code":"14/88\n","err":"","out":"0.159090909090909"},{"code":"1.4e8\n","out":"140000000","err":""},{"code":"(14 gt 7) ? 'yes' : 'no' # maxstr just uses gt instead of >, this seems completely wrong for what you're asking\n","out":"no","err":""},{"code":"1/5\n","err":"","out":"0.2"},{"code":"\"150\" |. \"105\"\n","out":"ERROR: syntax error at (eval 558) line 1, near \"|.\"\n","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"|.\"\n","err":"","code":"[150 | 105, 150 |. 105]\n"},{"err":"","out":"1","code":"\"- 15:03:48,619  -\" =~ /- (\\d{2}:\\d{2}:\\d{2},\\d{3}).{3,}/\n"},{"code":"\"- 15:03:48,619  \" =~ /- (\\d{2}:\\d{2}:\\d{2},\\d{3}).{3,}/\n","err":"","out":""},{"code":"\"- 15:03:48,619  -\" =~ /- (\\d{2}:\\d{2}:\\d{2},\\d{3}).{4,}/\n","out":"","err":""},{"out":"","err":"","code":"\"- 15:03:48,619  -\\n\\r\" =~ /- (\\d{2}:\\d{2}:\\d{2},\\d{3}).{4,}/\n"},{"out":"51.6666666666667","err":"","code":"155.0 / 3.0\n"},{"code":"'15.8' == '15.80'\n","err":"","out":"1"},{"code":"'15.8' == undef\n","out":"","err":""},{"code":"1.5e308\n","err":"","out":"1.5e+308"},{"err":"","out":"5","code":"@_ = (1 .. 5); $single = @_; $single\n"},{"code":"16 | 0\n","err":"","out":"16"},{"err":"","out":"0","code":"16 & 0\n"},{"out":"16","err":"","code":"16 | 16\n"},{"code":"16 & 16\n","err":"","out":"16"},{"err":"","out":"18446744073709551615","code":"(1 << 63) - 1 + (1 << 63)\n"},{"out":"ÃÂ£ÃÂ£ÃÂ£","err":"","code":"163.163.163\n"},{"code":"((16385 >> 12) <<12)\n","out":"16384","err":""},{"out":"1.79e+308","err":"","code":"1.79e308\n"},{"code":"1 << 8\n","out":"256","err":""},{"code":"[ 180000000 / 57100  ]\n","err":"","out":"[\"3152.3642732049\"]"},{"code":"18446744073709551615 + 1\n","err":"","out":"1.84467440737096e+19"},{"code":"18446744073709551616  - 18446744073709551000\n","out":"0","err":""},{"out":"[0,32]","err":"","code":"[ 1890 & 8,  1890 & 32 ]\n"},{"out":"Inf","err":"","code":"1.8e308\n"},{"out":"Inf","err":"","code":"1.8e308-1\n"},{"out":"[67108864,\"1.23794003928538e+27\"]","err":"","code":"[1 << 90, 2**90]\n"},{"out":"[\"\\x{c0}\\x{a8}\\0\\0\",\"192.168.0.0\"]","err":"","code":"[ 192.168.0.0 . '', '192.168.0.0' ]\n"},{"code":"[ 192.168.0.0, '192.168.0.0' ]\n","out":"[192.168.0.0,\"192.168.0.0\"]","err":""},{"code":"[ '1990-1992-1993-2010' =~ tr/-/ /r ]\n","err":"","out":"[\"1990 1992 1993 2010\"]"},{"code":"19.99*100\n","err":"","out":"1999"},{"out":"9998","err":"","code":"1^9999\n"},{"code":"1999979/1999993\n","err":"","out":"0.9999929999755"},{"out":"1","err":"","code":"1**9999 # perl's spelling of \"^\"\n"},{"code":"-+- \"1abc\"\n","err":"","out":"1"},{"code":"-+-+-+-+-+- \"1abc\"\n","err":"","out":"1"},{"out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$[ = 1; (\"A\", \"B\", \"C\")[0]\n"},{"code":"'1e0' == 1\n","out":"1","err":""},{"err":"","out":"10034","code":"1e02.34\n"},{"err":"","out":"11","code":"$_ = '1e1'; $_++; $_\n"},{"code":"1e10\n","err":"","out":"10000000000"},{"err":"","out":"Inf","code":"1e1000\n"},{"code":"1e999\n","out":"Inf","err":""},{"out":"Inf","err":"","code":"1e9999\n"},{"out":"[\"\",1]","err":"","code":"[ 1 eq '1.0', 1 == '1.0' ]\n"},{"out":"[1,1]","err":"","code":"[ 1 eq 1.0, 1 == 1.0 ]\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"2 !=\"\n","err":"","code":"1 eq 2 != 3\n"},{"err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","code":"$1 = eval {a:}\n"},{"code":"(\"1foo\"=~/(\\d+)/)[0]\n","err":"","out":"1"},{"code":"1 for @array;\n","out":"","err":""},{"err":"","out":"1","code":"1 if scalar \\%hash\n"},{"code":"$1\\l$2\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"$1\\\"\n"},{"code":"$[ = -1; my @foo = qw/x y z/; [ $foo[-1] ]\n","err":"","out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"[ 1=>'one' ];\n","err":"","out":"[1,\"one\"]"},{"out":"[1,\"foo\"]","err":"","code":"[(1 or 0 and \"foo\"), ((1 or 0) and \"foo\")]\n"},{"code":"1p-10\n","out":"ERROR: syntax error at (eval 558) line 1, near \"1p\"\n","err":""},{"code":"$ = 1; print $++;\n","out":"ERROR: syntax error at (eval 558) line 1, near \"$ = 1\"\nsyntax error at (eval 558) line 1, at EOF\n","err":""},{"code":"1+print 4\n","err":"","out":"4"},{"code":"$! = 1; printf \"SvPV is %s but SvIV is %d\\n\", $!, $!\n","err":"","out":"SvPV is Operation not permitted but SvIV is 1\n"},{"out":"001","err":"","code":"1 =~ /^([^.])(\\..*)?/ && sprintf( q{%03d}, $1 ). ( $2 // q{} ); ### leobut\n"},{"code":"1=>undef\n","out":"","err":""},{"code":"1,undef\n","err":"","out":""},{"code":"[ -1 - ~unpack 'N', join '', map chr, '192.168.254.43' =~ /\\d+/g ]\n","err":"","out":"[\"-1.84467440704773e+19\"]"},{"code":"1x4\n","err":"","out":"1111"},{"err":"","out":"25","code":"2014-1989\n"},{"code":"2014-1997\n","out":"17","err":""},{"err":"","out":"2015-02-19","code":"$_ = \"2015021900:00:00\"; /^(....)(..)(..)/; \"$1-$2-$3\"\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"2015021900:\"\n","err":"","code":"$_ = 2015021900:00:00; /^(....)(..)(..)/; \"$1-$2-$3\"\n"},{"code":"['2.0' == 2 ? \"Y\" : \"N\"]\n","out":"[\"Y\"]","err":""},{"code":"[20 + 4]\n","out":"[24]","err":""},{"code":"[20+4]\n","out":"[24]","err":""},{"err":"","out":"0","code":"2048 & 0x00FF\n"},{"code":"\"Â²\" =~ /[â°-â¹]/\n","err":"","out":"1"},{"err":"","out":"  20:       ee110f10     11101110000100010000111100010000         mrc     15, 0, r0, cr1, cr0, {0}","code":"\"  20:       ee110f10      mrc     15, 0, r0, cr1, cr0, {0}\" =~ s/^\\s+[0-9a-f]+:\\s+([0-9a-f]+)\\K/sprintf \"     %b   \", hex $1/er #netz something like this then?\n"},{"code":"2**100\n","err":"","out":"1.26765060022823e+30"},{"code":"2**127;\n","err":"","out":"1.70141183460469e+38"},{"code":"2**1270;\n","err":"","out":"Inf"},{"out":"1","err":"","code":"\"Ù¢\" =~ /[Ù¡-Ù£]/a\n"},{"err":"","out":"[4,2]","code":"[ 2 << 1, 4 >> 1 ]\n"},{"err":"","out":"17179869184","code":"2**17 * 2**17\n"},{"code":"-2 % 1e6\n","out":"999998","err":""},{"out":"4","err":"","code":"2 + 2\n"},{"out":"4","err":"","code":"2+2\n"},{"code":"[2**2*3]\n","err":"","out":"[12]"},{"out":"4","err":"","code":"*2 = 2.5; 2 + 2\n"},{"err":"","out":"ERROR: Undefined subroutine &main::2.5 called at (eval 558) line 1, <STDIN> line 1.\n","code":"*2 = 2.5; 2 + &2\n"},{"code":"\"\\22\\a\\6\\21A\\5SK\" ^ 'foobar22'\n","err":"","out":"this way"},{"out":"[2,23]","err":"","code":"[2.3 ^ 0, 2 . 3 ^ 0]\n"},{"code":"2 * 3 + 1\n","out":"7","err":""},{"out":"2147483648","err":"","code":"2**31\n"},{"code":"[ 23 ** 11, 2 ** 32 ]\n","out":"['952809757913927',\"4294967296\"]","err":""},{"out":"34","err":"","code":"2^32\n"},{"code":"2**32\n","err":"","out":"4294967296"},{"out":"0.136192519533232","err":"","code":"(2**32)/1000/60/60/24/365\n"},{"out":"136.192519533232","err":"","code":"2**32 / 3600 / 24 / 365\n"},{"code":"[ 2.3, 2 . 3 ]  # different\n","out":"[\"2.3\",23]","err":""},{"err":"","out":"23","code":"23 % 24\n"},{"err":"","out":"49710.2696296296","code":"(2**32)/60/60/24\n"},{"out":"4,294,967,296","err":"","code":"2**32 =~ s/\\B(?=(\\d\\d\\d)+$)/,/gr\n"},{"err":"","out":"8589934592","code":"2**33\n"},{"err":"","out":"20","code":"235 ^ 255\n"},{"err":"","out":"","code":"235 xor 255\n"},{"err":"","out":"223.517417907715","code":"240*(10**9)/(2**30)\n"},{"out":"2426","err":"","code":"240*10^9/2^30\n"},{"code":"24 % 24\n","out":"0","err":""},{"out":"32","err":"","code":"2**5\n"},{"code":"2**50  # really ?\n","err":"","out":"1.12589990684262e+15"},{"code":"25 % 24\n","out":"1","err":""},{"code":"255 & 0x7f\n","out":"127","err":""},{"out":"1305","err":"","code":"25 | 6 ** 4\n"},{"err":"","out":"[1]","code":"[ 256 >> 8 ]\n"},{"code":"25**7\n","err":"","out":"6103515625"},{"out":"25","err":"","code":"25 or 6 ** 4\n"},{"code":"260 / 3600\n","err":"","out":"0.0722222222222222"},{"err":"","out":"4.61168601842739e+18","code":"2**62\n"},{"out":"1.84467440737096e+19","err":"","code":"(2**63 - 1) + 2**63\n"},{"code":"2**64\n","out":"1.84467440737096e+19","err":""},{"out":"1.84467440737096e+19","err":"","code":"2**64 - 1\n"},{"code":"265 % 2\n","out":"1","err":""},{"code":"2*710 . ' litres of beer tonight'\n","out":"1420 litres of beer tonight","err":""},{"code":"2733.754 % 60.0; ### Why exactly is it that this yields 33 instead of 33.754 ?\n","err":"","out":"33"},{"code":"2**(7*8)\n","out":"7.20575940379279e+16","err":""},{"code":"2790**2753 % 3233\n","err":"","out":"NaN"},{"err":"","out":"256","code":"2**8\n"},{"err":"","out":"3.09485009821345e+26","code":"2**88\n"},{"code":"28867 / 150000\n","err":"","out":"0.192446666666667"},{"err":"","out":"100","code":"(2903000/2903000)*100\n"},{"code":"29822 * length q|/gnu/store/d8fwypp5cnzjpc7kycmj4nj0gwn7k6lq-perl-xml-sax-0.99|\n","out":"1819142","err":""},{"code":"2 =~ /\\A(?:(?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9])\\z/\n","err":"","out":"1"},{"out":"ERROR: No such file or directory at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$! = 2; die \"$!\"\n"},{"code":"[2,grep{(1x$_)!~/^(..+)\\1+$/}3..541]\n","out":"[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541]","err":""},{"code":"$_ = 2; grep { $_ } qw(1 3 5); $_\n","err":"","out":"2"},{"code":"(2 or 3)\n","err":"","out":"2"},{"err":"","out":"4.5","code":"*2 = sub {2.5}; 2 + &2\n"},{"err":"","out":"[\"ok\"]","code":"*{\"2\"} = sub { 'ok' }; [ main->${\\2} ]\n"},{"code":"*{\"2\"} = sub { 'ok' }; [ main->2 ]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"->2\"\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, near \"$two ]\"\n","err":"","code":"*{\"2\"} = sub { 'ok' }; [ my $two = 2; main->$two ]\n"},{"out":"[\"ok\"]","err":"","code":"*{\"2\"} = sub { 'ok' }; my $two = 2; [ main->$two ]\n"},{"out":"1","err":"","code":"2 =~ /\\w/\n"},{"code":"2x4\n","out":"2222","err":""},{"code":"3\n","err":"","out":"3"},{"code":"3_000_000 / 100  # this many seconds\n","err":"","out":"30000"},{"code":"30_000 * 30_000 / 2\n","err":"","out":"450000000"},{"out":"","err":"","code":"300 x $60\n"},{"err":"","out":"ÃÂÃÂÃÂÃÂ¡r jÃÂÃÂÃÂÃÂº sÃÂÃÂÃÂÃÂºr?\n","code":"\"\\303\\203\\302\\241r j\\303\\203\\302\\272 s\\303\\203\\302\\272r?\\n\"\n"},{"err":"","out":"30","code":"-30 % 60\n"},{"out":"153500","err":"","code":"307 * 500\n"},{"out":"[\"\",30]","err":"","code":"[ \":30\" =~ /(?:(\\d*):)?(\\d+)/ ]\n"},{"out":"[undef,30]","err":"","code":"[ 30 =~ /(?:(\\d*):)?(\\d+)/ ]\n"},{"code":"3 ** 12   # Actually :)\n","out":"531441","err":""},{"out":"1594323","err":"","code":"3 ** 13\n"},{"code":"\"31323334\" =~ s/.(.)/$1/gr\n","out":"1234","err":""},{"out":"ERROR: Can't modify constant item in substitution (s///) at (eval 558) line 1, at EOF\n","err":"","code":"\"31323334\" =~ s/(..)/chr hex $1/g\n"},{"code":"\"31323334\" =~ s/(..)/chr hex $1/gr\n","err":"","out":"chr hex 31chr hex 32chr hex 33chr hex 34"},{"code":"\"31323334\" =~ s/(..)/chr hex $1/gre\n","err":"","out":"1234"},{"err":"","out":"3.14159265358979","code":"3.141592653589793238462643383279502884\n"},{"out":"1.5","err":"","code":"3 / 2\n"},{"code":"3 // 2\n","err":"","out":"3"},{"code":"\"321\" =~ /\\d+/\n","out":"1","err":""},{"code":"3/2 > 7/5\n","out":"1","err":""},{"code":"[ 3 ^ 3 ]\n","err":"","out":"[0]"},{"code":"$_ = '\"33.62\" \"114.72\" \"Blythe\"'; s/(\\S+)\\s(\\S+)\\s(.+$)/$3 $1 $2/; $_ # seems happy enough, did you try it?\n","out":"\"Blythe\" \"33.62\" \"114.72\"","err":""},{"out":"354187","err":"","code":"337 * 1051\n"},{"code":"(3 == 3) ? \"yes\" : \"no\";\n","err":"","out":"yes"},{"out":"7","err":"","code":"\"@{[ 3 + 4 ]}\"\n"},{"code":"3.4/2.31012414912481924812904128490128412\n","out":"1.47178237208077","err":""},{"err":"","out":"[\"\\x{51fa}\\x{8ca8}\\x{660e}\\x{7d30}\"]","code":"$_ = \"\\345\\207\\272\\350\\262\\250\\346\\230\\216\\347\\264\\260\"; utf8::decode $_; [$_]\n"},{"code":"@3 = 4..9; \\@3  # other global stuff :)\n","out":"[4,5,6,7,8,9]","err":""},{"out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after tures/; 3 <-- HERE near column 93 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":" 3 â 5;\n"},{"code":"3:5\n","out":"ERROR: syntax error at (eval 558) line 1, near \"3:\"\n","err":""},{"err":"","out":"8","code":"3+5\n"},{"out":"292.596817016602","err":"","code":"350*24*365.25*100/(1024*1024) # about 300TB, why do you ask?\n"},{"code":"3568 / 100\n","err":"","out":"35.68"},{"err":"","out":"15","code":"360/24\n"},{"out":"1","err":"","code":"'Ù£' =~ /./a\n"},{"err":"","out":"","code":"'Ù£' =~ /\\d/a\n"},{"code":"'Ù£' =~ /\\D/a\n","err":"","out":"1"},{"err":"","out":"[1,1,1]","code":"[ 'Ù£' =~ /\\d/a, 'Ù£' =~ /./a, \"Ù¢\" =~ /[Ù¡-Ù£]/a, 'Ù£' =~ /\\D/a ]\n"},{"code":"\"(3/(x+2)+(-1/2)/(x-3))dx \" =~ s/^\\(((?:[^()]|\\((?1)\\))*)\\)dx\\s*$/$1/r\n","err":"","out":"3/(x+2)+(-1/2)/(x-3)"},{"err":"","out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/^\\(( <-- HERE (?:[^()]|\\((?1)\\))*\\)dx\\s*$/ at (eval 558) line 1, <STDIN> line 1.\n","code":"\"(3/(x+2)+(-1/2)/(x-3))dx \" =~ s/^\\(((?:[^()]|\\((?1)\\))*\\)dx\\s*$/$1/r\n"},{"code":"404->()\n","out":"ERROR: Undefined subroutine &main::404 called at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"$_ = '4 1 4 2 3'; @a=(); $a[abs $1-$']+=1 while / (\\d+)(?= )/g; (!defined shift @a) && @a == $_ - 1 && $_ - 1 == grep($_ == 1, @a) ? 'jolly' : 'Not jolly'\n","err":"","out":"jolly"},{"code":" $_ = '4 1 4 2 3'; @deltas = 1; $deltas[abs $1 - $2] += 1 while / (\\d+)(?= (\\d+))/g;  grep($_ != 1, @deltas) ? 'Not jolly' : 'jolly'\n","err":"","out":"jolly"},{"code":"42\n","out":"42","err":""},{"code":"[ ~42 ]\n","out":"['18446744073709551573']","err":""},{"code":"[ \"\" || 42 ]\n","err":"","out":"[42]"},{"code":"[ \"\" // 42 ]\n","err":"","out":"[\"\"]"},{"err":"","out":"[\"ARRAY(0x4ee3860)\",\"ARRAY(0x4ee3860)\"]","code":"$_ = []; $_->[42] = $_; [ ''.$_, ''.$_->[42] ]\n"},{"out":"42","err":"","code":"('42 bottles of beer' =~ /(\\d+)/)[0]\n"},{"out":"[1,1,1]","err":"","code":"[ !!42, !!\"foo\", !!{baz=>quux} ]\n"},{"out":"[\\42,$VAR1->[0],$VAR1->[0]]","err":"","code":"$_ = 42; [ \\$_, \\$main::_, \\$main::main::_ ]\n"},{"code":"$_ = 42; [ map ${$_}, \\$_, \\$main::_, \\$main::main::_ ]\n","out":"[42,42,42]","err":""},{"code":"$_ = 42; print map { $_ } qw(a b c); print \"; $_\"\n","err":"","out":"abc; 42"},{"code":"[ '446744073709551615' =~ s/\\B(?=(\\d{3})+$)/,/gr ]  # fix\n","err":"","out":"[\"446,744,073,709,551,615\"]"},{"out":"[\",446,744,073,709,551,615\"]","err":"","code":"[ '446744073709551615' =~ s/(?=(\\d{3})+$)/,/gr ]\n"},{"code":"45_000_000 * 24\n","out":"1080000000","err":""},{"code":"(45/50-1)*100\n","err":"","out":"-10"},{"code":"(4,5,6)[-2..-1]\n","err":"","out":"6"},{"err":"","out":"[5,6]","code":"[(4,5,6)[-2..-1]]\n"},{"code":"47 % 24\n","err":"","out":"23"},{"code":"[ 4 .. 9 ]\n","err":"","out":"[4,5,6,7,8,9]"},{"err":"","out":"","code":"4 .. 9\n"},{"code":"49 & 97\n","out":"33","err":""},{"err":"","out":"[4,5,6,7,8,9]","code":"\"4-9\" =~ /-/ and [eval '$`..$\\'']\n"},{"err":"","out":"[]","code":"\"4-9\" =~ /-/ and [ split /,/, `perl -e'print join \",\", $\\` .. $'\\'` ]\n"},{"err":"","out":"4,5,6,7,8,9","code":"$_ = \"4-9\"; s/(\\d+)-/$1,@{[$1+1]}-/ until /(?<=,)(\\d+)-\\1/; s//$1/; $_\n"},{"err":"","out":"[4,5,6,7,8,9]","code":"$_ = \"4-9\"; s/(\\d+)-/$1,@{[$1+1]}-/ until /(?<=,)(\\d+)-\\1/; s//$1/; [ /(\\d+)/g ]  # better\n"},{"out":"[4,5,6,7,8,9]","err":"","code":"$_ = \"4-9\"; s/-/../; [ eval ]\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"4[\"\n","err":"","code":"4[$array]\n"},{"code":"4*atan2(1,1)\n","err":"","out":"3.14159265358979"},{"code":"$! = 4; die \"$!\"\n","err":"","out":"ERROR: Interrupted system call at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"$_[4] = ['foo']; $_->[4] = 'bar'; [ @{$_[4]} ];\n","out":"[\"foo\"]","err":""},{"err":"","out":"[\"bar\"]","code":"$_[4] = ['foo']; $_->[4] = 'bar'; [ @$_[4] ];\n"},{"err":"","out":"5x5x5","code":"$_ = '4x4x4'; y(4)(5); $_ # still potential for confusion though\n"},{"code":"[ .5]\n","err":"","out":"[\"0.5\"]"},{"out":"[5]","err":"","code":"[ 5. ]\n"},{"err":"","out":"[]","code":"[5 .. 0]\n"},{"out":"[0]","err":"","code":"[ \"5\" & \"000000\" ]\n"},{"err":"","out":"*main::5000","code":"*5000 = \\5;\n"},{"code":"\\*5000 = \\5;\n","err":"","out":"ERROR: Can't modify reference to ref-to-glob cast in scalar assignment at (eval 558) line 1, at EOF\n"},{"code":"\\*5000 = 5;\n","out":"ERROR: Can't modify reference to ref-to-glob cast in scalar assignment at (eval 558) line 1, at EOF\n","err":""},{"code":"*5000 = \\5; $5000\n","out":"5","err":""},{"code":"*5000 = \\5; *5000\n","out":"*main::5000","err":""},{"err":"","out":"5","code":"*5000 = sub {5}; 5 & & 5000\n"},{"err":"","out":"8","code":"*5000 = sub {\"Hello World\"}; 10 &5000\n"},{"out":"\\\"Hello World\"","err":"","code":"*5000 = sub {\"Hello World\"}; \\*5000->()\n"},{"code":"*5000 = sub {\"Hello World\"}; &5000\n","err":"","out":"Hello World"},{"out":"Hello World","err":"","code":"*5000 = sub {\"Hello World\"}; 5000->()\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"5000(\"\n","code":"*5000 = sub {\"Hello World\"}; 5000()\n"},{"out":"0","err":"","code":"*5000 = sub {\"Hello World\"}; \"Hello\" + &5000\n"},{"code":"[ 5/0.06 ]\n","out":"[\"83.3333333333333\"]","err":""},{"code":"5.013_006 # mauke typo I think\n","err":"","out":"5.013006"},{"err":"","out":"","code":"$] < 5.013006 #surely this is what he wants\n"},{"out":"[105]","err":"","code":"[5 + 100]\n"},{"err":"","out":"[5,6,7,8,9,10,11,12]","code":"[ 5 .. 12 ]\n"},{"code":"$] < 5.13.6\n","err":"","out":""},{"err":"","out":"[5.14.0]","code":"[5.14.0]\n"},{"code":"5.14.0\n","out":"\u0005\u000e\u0000","err":""},{"code":"$â = 5; $â = 2; $â + $â\n","out":"ERROR: Unrecognized character \\x9C; marked by <-- HERE after tures/; $ÃÂ¢<-- HERE near column 93 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"[1]","err":"","code":"[ \"5\" & \"3\" ]\n"},{"out":"1","err":"","code":"5<=>3\n"},{"code":"5/3\n","out":"1.66666666666667","err":""},{"code":"[ 5 5 ]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"5 5\"\n","err":""},{"code":"5*5\n","out":"25","err":""},{"code":"5+5\n","out":"10","err":""},{"out":"1","err":"","code":"5 == 5.0\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"5. 5\"\n","err":"","code":"[ 5 . 5, 5. 5, 5 .5, 5.5 ]\n"},{"code":"\"5 + 5\" =~ s/(.+)/ $1 /eer;\n","out":"10","err":""},{"out":"10","err":"","code":"\"5 + 5\" =~ s/.*/$&/eer;\n"},{"out":"10","err":"","code":"\"5 5\" =~ s/(.)\\s(.)/$1 + $2/er;\n"},{"code":"\"5 5\" =~ s/(.)\\s(.)/print $1 + $2/er;\n","err":"","out":"10"},{"code":"[5+6]\n","err":"","out":"[11]"},{"code":"5+6\n","out":"11","err":""},{"err":"","out":"0.714285714285714","code":"5/7\n"},{"out":"[\"0.000317222222222222\"]","err":"","code":"[ 57100 / 180000000 ]\n"},{"out":"99","err":"","code":"57+42  # perlbot is the most accessible calculator\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"5.'a'\"\n","code":"[ 5.'a' ]\n"},{"code":"$! = 5; say $!\n","err":"","out":"Input/output error\n"},{"out":"14776336","err":"","code":"62 ** 4\n"},{"code":"64.64.64.5000000000.64.64.64\n","err":"","out":"@@@ÃÂ¾ÃÂÃÂªÃÂÃÂÃÂÃÂ@@@"},{"err":"","out":"@ADF","code":"64.65.68.70\n"},{"err":"","out":"0","code":"65280 & 127\n"},{"code":"65280 >> 8\n","err":"","out":"255"},{"code":"65536 >> 16\n","out":"1","err":""},{"code":"65536 >> 8\n","err":"","out":"256"},{"out":"[65.66.67]","err":"","code":"[ 65.66.67 ]\n"},{"code":"[65.66.67]\n","out":"[65.66.67]","err":""},{"code":"6_5,6_6,6_7\n","out":"67","err":""},{"code":"6_5.6_6.6_7\n","out":"ABC","err":""},{"err":"","out":"ABC","code":"65.66.67\n"},{"out":"667","err":"","code":"~~667\n"},{"code":"6.6e-16 == 6.6 * 10 ** -16\n","err":"","out":"1"},{"err":"","out":"4260 militres of beer tonight","code":"6*710 . ' militres of beer tonight'\n"},{"err":"","out":"599.4","code":"6 * 99.90\n"},{"out":"1","err":"","code":"6 * 99.90 > 599.40\n"},{"code":"\"6C5775272327642A382A453C327D3A31\" =~ s/(..)/chr hex $1/gre\n","err":"","out":"lWu'#'d*8*E<2}:1"},{"code":"\"6d73616e64626f78\" =~ s/([0-9a-f]{2})/chr hex $1/eg\n","out":"ERROR: Can't modify constant item in substitution (s///) at (eval 558) line 1, at EOF\n","err":""},{"code":"70 / 4.4\n","out":"15.9090909090909","err":""},{"code":"7200 * 12\n","err":"","out":"86400"},{"err":"","out":"103","code":"7 + 32 + 64\n"},{"code":" 7 + 7 / 7 + 7 * 7 - 7\n","out":"50","err":""},{"code":" 7 + 7 / 7 + 7 x 7 - 7\n","out":"7777778","err":""},{"code":"$78_char_wide_text\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"$78_char_wide_text\n\"\n"},{"code":"[ 7 <=> \"cats\" ]\n","out":"[1]","err":""},{"err":"","out":"","code":"7 < 'D'\n"},{"code":".7E9 / 604\n","err":"","out":"1158940.39735099"},{"out":"[undef]","err":"","code":"[ 7 <=> 'nan' ]\n"},{"out":"81","err":"","code":"8181 / 101\n"},{"err":"","out":"0.818181818181818","code":"8181/9999\n"},{"code":"8192 / 1024\n","out":"8","err":""},{"err":"","out":"2","code":"8 >> 2\n"},{"err":"","out":"1234321","code":"(86274 ^ 87381) ** 2\n"},{"err":"","out":"no","code":"\"\\8\" eq \"\\9\" ? \"yes\" : \"no\"\n"},{"code":"*9001 = \\5;\n","out":"*main::9001","err":""},{"out":"0.818181818181818","err":"","code":"9/11\n"},{"err":"","out":"777","code":"953-176\n"},{"code":"97 =~ s/(\\d+)/chr $1/er\n","out":"a","err":""},{"out":"a","err":"","code":"97 =~ s/(\\d+)/${\\chr $1}/r\n"},{"err":"","out":"cafÃÂ©","code":"99.97.102.233\n"},{"code":"9999 / 101\n","err":"","out":"99"},{"out":"[[9,1]]","err":"","code":"$. = 9; [ [ $.++, scalar(10..15) ], ]\n"},{"err":"","out":"{a => 1}","code":"{a=>1}\n"},{"err":"","out":"[undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,1,2,3,4,5]","code":"@a=(1,2,3,4,5); [@a[-20..-1]]\n"},{"err":"","out":"[undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,[1,2,3,4,5]]","code":"@a=[1,2,3,4,5]; [@a[-20..-1]]\n"},{"code":"[ { a => 123 }, { b => 456 } ];\n","err":"","out":"[{a => 123},{b => 456}]"},{"out":"a12300b","err":"","code":"\"a123b\" =~ s/(\\d+)/$1*100/er\n"},{"code":"@a = (1, 2, 3); print $#a;\n","err":"","out":"2"},{"err":"","out":"[1,2,3,44]","code":"$_ = \"a1 2b 3 c 44\"; [/(\\d+)/g]\n"},{"err":"","out":"1","code":"@a = (1, 2, 'foo'); grep { $_ eq 'foo' } @a[1..$#a]\n"},{"out":"[1,3]","err":"","code":"$a = {1..4}; [keys $a]\n"},{"out":"[{1 => 2,2 => 3},{3 => 4,4 => 5}]","err":"","code":"@a=1..4; [{map{$_=>$_+1}@a[0..@a/2-1]},{map{$_=>$_+1}@a[@a/2..$#a]}]\n"},{"out":"1","err":"","code":"@a = (1,5,2,4,3); @b = (5,3,1,4,2); (() = delete @{ { map {$_,1} @a } }{ @b }) == @b\n"},{"out":"1","err":"","code":"@a = (1,5,2,4,6); @b = (5,3,1,4,2); (() = delete @{ { map {$_,1} @a } }{ @b }) == @a\n"},{"code":"@a = (1,5,2,4,6); @b = (5,3,1,4,2); \"@{[sort @a]}\" eq \"@{[sort @b]}\" ? same : different\n","err":"","out":"different"},{"out":"same","err":"","code":"@a = (1,5,2,4,6); @b = (5,6,1,4,2); \"@{[sort @a]}\" eq \"@{[sort @b]}\" ? same : different\n"},{"out":"1","err":"","code":"@a = (1,5,2,4); @b = (5,3,1,4,2); (() = delete @{ { map {$_,1} @a } }{ @b }) == @b\n"},{"out":"{a => 2}","err":"","code":"{ a => 1, a => 2 }\n"},{"code":"$a=1; $b=1; LABL: while($a--) {try {die if $b--} catch {redo LABL;}; print \"hello world\"};\n","out":"ERROR: Died at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"1","err":"","code":"$a = 1; $b = 3; ($a/$b)*$b\n"},{"err":"","out":"0","code":"@a = (1) x 1024*1024*30; $#a\n"},{"code":"@a = (1) x 1024*1024*5\n","err":"","out":"1"},{"code":"@a = 2; [ @a == 2 ]\n","out":"[\"\"]","err":""},{"code":"$a->[2]->{bar} eq 'baz'; $a\n","err":"","out":"[undef,undef,{}]"},{"err":"","out":"ERROR: Can't modify constant item in substitution (s///) at (eval 558) line 1, near \"s/\\D+//,\"\n","code":"[ 'a 42 b' =~ s/\\D+//, 'a 42 b' =~ s/\\D+//g ]\n"},{"out":"[\"42 b\",42]","err":"","code":"[ 'a 42 b' =~ s/\\D+//r, 'a 42 b' =~ s/\\D+//gr ]\n"},{"code":"@a=(4,5,6); [ map [@a[0..@a-$_]], 1..@a+1 ]\n","err":"","out":"[[4,5,6],[4,5],[4],[]]"},{"out":"1","err":"","code":"%a=(a=>1); $s=\"a\"; $s=~s/.+/$a{\\1}/eg; print $s;\n"},{"err":"","out":"1","code":"\"<a<a></a>></a>\" =~ /<a(.*)>(.*)<\\/a>/\n"},{"err":"","out":"","code":"\"<a<a></a>></a>\" !~ /<a(.*)>(.*)<\\/a>/\n"},{"code":"\"aaaaaaaanother thing\" =~ m/^(a+)/ and $+[1]\n","err":"","out":"8"},{"out":"[\"AAAAA\",\"BBBB\"]","err":"","code":"'AAAAABBBB' =~ /((.)\\2*)(.*)/ ; [ $1, $3 ]\n"},{"err":"","out":"abcddddd","code":"'aaaabbbbbccccddddd' =~ tr/abc//sr\n"},{"code":"\"aaa b ccccc abcadaba\" =~ tr/abc/abc/sr\n","out":"a b c abcadaba","err":""},{"code":"$_ = 'aaa'; my $a = 5; ++$_ for $a; [ $_, $a ];\n","err":"","out":"[\"aaa\",6]"},{"code":"$_ = 'aaa'; my $a = 5; {local *_ = \\$a; ++$_}; [ $_, $a ];\n","err":"","out":"[\"aaa\",6]"},{"out":"[\"aaa\",5]","err":"","code":"$_ = 'aaa'; my $a = 5; {local $_ = $a; ++$_}; [ $_, $a ]; # note that this, which uses 'local $_', acts differently\n"},{"code":"[ \"aabbaa\" =~ /(aab??)(b+aa)/ ]\n","err":"","out":"[\"aa\",\"bbaa\"]"},{"err":"","out":"[\"aab\",\"baa\"]","code":"[ \"aabbaa\" =~ /(aab?)(b+aa)/ ]\n"},{"code":"\"aabbcc\" =~ s/(\\w)\\1/ $& /g;\n","err":"","out":"ERROR: Can't modify constant item in substitution (s///) at (eval 558) line 1, at EOF\n"},{"err":"","out":"[\"c\",\"c\",\"c\",\"c\"]","code":"@a = (); 'abcccccdefghi' =~ / (c) (?:(\\1)(?{push @a, $1})){4} /x; \\@a # backrefs :)\n"},{"err":"","out":"[\"d\",\"e\",\"f\",\"g\"]","code":"@a = (); 'abcdefghi' =~ / c (?:(.)(?{push @a, $1})){4} /x; \\@a\n"},{"out":"[\"d\",\"e\",\"f\",\"g\"]","err":"","code":"@a = (); 'abcdefghi' =~ / c (?:(.)(?{push @a, $1})){4} (?!) /x; \\@a\n"},{"code":"@a = (); 'abcdefghi' =~ / (?:(.)(?{push @a, $1})){4} (?= $ ) /x; \\@a\n","err":"","out":"[\"a\",\"b\",\"c\",\"d\",\"b\",\"c\",\"d\",\"e\",\"c\",\"d\",\"e\",\"f\",\"d\",\"e\",\"f\",\"g\",\"e\",\"f\",\"g\",\"h\",\"f\",\"g\",\"h\",\"i\"]"},{"err":"","out":"[\"f\",\"g\",\"h\",\"i\"]","code":"@a = (); 'abcdefghi' =~ / (?:(.)(?{push @a, $1})){4} $ /x; \\@a\n"},{"code":"$_=\"aabcdef\"; print if /^a([abcd]+)ef$/ and $1 !~ /([abcd]).*\\1/\n","err":"","out":"aabcdef"},{"code":"$a=\"a.b.com\";print \"yes\" if $a=~/^a.com$/\n","err":"","out":""},{"code":"$a = 'a'; my $b = \\$a; for $$b (0..5) { print $a }\n","out":"ERROR: Not a GLOB reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"012345","code":"$a = 'a'; my $b = \\*a; for $$b (0..5) { print $a }\n"},{"code":"$a=\"asd1312321asd1212asd121212\"; print $_,\"\\n\" for $a=~/(asd\\d+)/g;\n","err":"","out":"asd1312321\nasd1212\nasd121212\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, near \")   ]\"\n","err":"","code":"[ @a=['asd qwe', 'qqq '];   /(\\w+)\\s+(\\w+?)/ , print \"$1 - $2\" for ( @a )   ]\n"},{"code":"[ 'a' ^ 'A' ] # secret - the difference between upper and lower case is a space\n","out":"[\" \"]","err":""},{"code":"\"AA\" =~ s/(.)(.)/\\l$1$2/r\n","err":"","out":"aA"},{"out":"[\"\\3\"]","err":"","code":"[ 'a' ^ 'b' ]\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"; b\"\n","code":"+{ a; b}\n"},{"err":"","out":"1","code":"\"ab12312532\" =~ /.*3.*/\n"},{"code":"-+- \"ab1c\"\n","err":"","out":"+ab1c"},{"out":"[1]","err":"","code":"[ \"a{b\" =~ /a{/ ]\n"},{"err":"","out":"01","code":"(\"AB\" ^ \"A4\") =~ tr/\\0\\1-\\377/01/r\n"},{"code":"[ \"a\" . \"b\", \"a\" . 5, 5 . \"b\", 5 . 5 ]\n","out":"[\"ab\",\"a5\",\"5b\",55]","err":""},{"code":"[ 'ababab' =~ /(ab)*/ ]\n","out":"[\"ab\"]","err":""},{"out":"[\"ab\",\"ab\",\"ab\"]","err":"","code":"[ 'ababab' =~ /(ab)/g ]\n"},{"out":"[undef]","err":"","code":"[ \"ab\" =~ /(a)x|b/ ]\n"},{"code":"'ab' & 'b'\n","err":"","out":"`"},{"err":"","out":"``","code":"'ab' & 'ba'\n"},{"code":"[\"abba\" =~ /(ab(ba))/]\n","out":"[\"abba\",\"ba\"]","err":""},{"err":"","out":"[\"abba\",\"ba\"]","code":"\"abba\" =~ /(ab(ba))/; [$1, $2]\n"},{"code":"\"ABBBBBBBABBA\" =~ s/(B+)/length $1 < 3 ? 'C' x length $1 : $1/ger\n","err":"","out":"ABBBBBBBACCA"},{"code":"'aBBBc' =~ s/[^a-z]//gr\n","err":"","out":"ac"},{"out":"Abbott and Costello","err":"","code":"$_ = 'Abbott &&& Costello'; s/\\s\\K\\W+(?=\\s)/and/; $_ # should work here though\n"},{"out":"[\"Abbott and Costello\"]","err":"","code":"[ 'Abbott &&& Costello' =~ s/(\\s*)&&&(\\s*)/$1and$2/gr ]\n"},{"out":"[\"abc\"]","err":"","code":"[~~\"abc\"]\n"},{"out":"[\"ABC\"]","err":"","code":"['ABC']\n"},{"code":"A: B: C: ;\n","err":"","out":""},{"code":"\"ABC\" & 0x00FF;\n","out":"0","err":""},{"code":"\"abc\" =~ \"(..)\"; $1\n","out":"ab","err":""},{"out":"ERROR: Can't call method \"encode_json\" on unblessed reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"{ abc => 123 }->JSON::encode_json\n"},{"err":"","out":"[\"abc123___\"]","code":"[ \"abc123___\" =~ /\\w+/g ]\n"},{"code":"[ \"abc 30 def\" =~ /abc (\\d+) def/  ]\n","err":"","out":"[30]"},{"out":"[\"No match\"]","err":"","code":"[ \"abc 30 def\" =~ /abc (\\d) def/ || \"No match\" ]\n"},{"err":"","out":"[1]","code":"[ \"abc 30 def\" =~ /abc (\\d+) def/ || \"No match\" ]\n"},{"code":"[ 'abc446744073709551615' =~ s/\\B(?=(\\d{3})+$)/,/gr ]\n","out":"[\"abc,446,744,073,709,551,615\"]","err":""},{"err":"","out":"[\"abc446,744,073,709,551,615\"]","code":"[ 'abc446744073709551615' =~ s/(?<=\\d)(?=(\\d{3})+$)/,/gr ]\n"},{"code":"@abc = (5,6,7,8); $c = @abc[1,2]\n","out":"7","err":""},{"code":"\"abc\" =~ /a/\n","out":"1","err":""},{"out":"1","err":"","code":"\"abca9\" =~ /(.)(.)(.)${3}9/\n"},{"code":"'abc' =~ /(a+)/; 'abc' =~ /(d+)/; [ 'bbaaccddee' =~ // ]\n","out":"[\"aa\"]","err":""},{"code":"$_ = 'abcabcabc'; s/b(??{ ++$idx == 2 ? '' : 'no match' })/c/; $_ # except you'd never actually write code like this of course\n","err":"","out":"abcaccabc"},{"out":"[\"CAT\",\"CATbca\"]","err":"","code":"[ \"abcabca\" =~ s/a.*a/CAT/r, \"abcabca\" =~ s/a.*?a/CAT/r ] # greedy vs not greedy\n"},{"code":"[ (\"A\",\"B\"),(\"C\",\"D\") ]\n","out":"[\"A\",\"B\",\"C\",\"D\"]","err":""},{"out":"[\"! ! \"]","err":"","code":"[ 'abcd' & '1111' ]\n"},{"code":"[ \"abcd123efg567h8i\" =~ /([a-z]+|[0-9]+)/g ];\n","err":"","out":"[\"abcd\",123,\"efg\",567,\"h\",8,\"i\"]"},{"code":"$_ = \"abcd12ABCD\"; print \"[[$_]]\" for  /(abcd|ABCD)/g\n","err":"","out":"[[abcd]][[ABCD]]"},{"out":"[1]","err":"","code":"[ \"abcd\" =~ /^ab/ ]\n"},{"out":"abcdaef","err":"","code":"$_=\"abcdaef\"; print /^(a[abcd]+ef)$/ and $1 !~ /([abcd]).*\\1/ ? \"Yes\" : \"no\";\n"},{"err":"","out":"ERROR: Unmatched ) in regex; marked by <-- HERE in m/^(a[abcd]+)ef) <-- HERE $/ at (eval 558) line 1, <STDIN> line 1.\n","code":"$_=\"abcdaef\"; print if /^(a[abcd]+)ef)$/ and $1 !~ /([abcd]).*\\1/\n"},{"out":"abcdaef","err":"","code":"$_=\"abcdaef\"; print if /^a([abcd]+)ef$/ and $1 !~ /([abcd]).*\\1/\n"},{"code":"$_=\"abcdaef\"; print if /^a([abcd]+)ef$/ and $1 !~ /([abcd]).*\\1(??{print $1})/\n","err":"","out":"abcdaef"},{"code":"$_=\"abcdaef\"; print if /^(a[abcd]+ef)$/ and $1 !~ /([abcd]).*\\1/; print \"done\"\n","err":"","out":"done"},{"err":"","out":"abcda","code":"$_=abcda; print if /^([abcd]{1})+$/ or print \"hmm\"\n"},{"err":"","out":"[\"ab\",\"cd\"]","code":"[ 'abcdcdcd' =~ /(ab)(cd)*/ ]\n"},{"out":"[\"a\"]","err":"","code":"[ \"abcdef\" =~ /^(?!.*([abcd]).*\\1)a.*ef\\z/s ]\n"},{"err":"","out":"[\"abc\"]","code":"$_ = \"abcdef\"; [ /abc(?=def)/ ? $& : 'fail' ]\n"},{"code":"\"abc def\" =~ /(?<first> \\w+ )/x; [ $+{first} ]\n","out":"[\"abc\"]","err":""},{"code":"'abcdefgh' & '11111111'\n","err":"","out":"! ! ! ! "},{"out":"[\"ab\",\"gh\"]","err":"","code":"[ 'abcdefgh' =~ /(ab)(..)*/ ]\n"},{"code":"[ \"ABCDEFGHABCD\" =~ /(?=(....))/g ]\n","out":"[\"ABCD\",\"BCDE\",\"CDEF\",\"DEFG\",\"EFGH\",\"FGHA\",\"GHAB\",\"HABC\",\"ABCD\"]","err":""},{"out":"abcdefghi","err":"","code":"abcdefghi\n"},{"code":"'abcdefghi' =~ / (?{@a=()}) (?:(.)(?{push @a, $1})){4} (?= $ ) /x; \\@a\n","err":"","out":"[\"f\",\"g\",\"h\",\"i\"]"},{"code":" \"abc,,def,ghi,,jkl\" =~ s/(?<=,)(?=,)/\\\\N/gr\n","err":"","out":"abc,\\N,def,ghi,\\N,jkl"},{"out":"ERROR: Can't modify constant item in substitution (s///) at (eval 558) line 1, at EOF\n","err":"","code":"\"abcdefg\" =~ s/ef//; [ $-[0], length $` ]\n"},{"code":"$_ = \"[a=b][c=d][e=f]\"; my @matches = /(\\[[^=]*=[^]]\\])/g; [ @matches ]\n","out":"[\"[a=b]\",\"[c=d]\",\"[e=f]\"]","err":""},{"code":"$_ = \"[a=b][c=d][e=f]\"; my @matches = split /(\\[[^\\]]*\\])/; [ @matches ]\n","err":"","out":"[\"\",\"[a=b]\",\"\",\"[c=d]\",\"\",\"[e=f]\"]"},{"code":"$_ = \"[a=b][c=d][e=f]\"; my @matches = split /\\[[^\\]]*\\]/; [ @matches ]\n","out":"[]","err":""},{"out":"[\"abXYef\"]","err":"","code":"[ 'abcdef' =~ s/cd/XY/r ];\n"},{"err":"","out":"[\"abc\",\"bcd\",\"cde\"]","code":"['abcde' =~ /(?=(...))/g]\n"},{"out":"[]","err":"","code":"$_= /a b c d/; @vars = (split)[2,3]; \\@vars\n"},{"out":"bc","err":"","code":"\"abc\" =~ /(?<gold>bc)/; $1\n"},{"code":"'aBc' =~ m{([^a-z])}; [ $1 ]\n","out":"[\"B\"]","err":""},{"out":"[\"a b c\\n\"]","err":"","code":"[\"a b c\\n\", split]\n"},{"code":"@abc = qw(a b c); [ @abc => @abc ]\n","out":"[\"a\",\"b\",\"c\",\"a\",\"b\",\"c\"]","err":""},{"err":"","out":"[[\"a\",\"b\",\"c\"],$VAR1->[0]]","code":"@abc = qw(a b c); [ \\@abc => \\@abc ]\n"},{"code":"'abc' =~ s/a//;\n","err":"","out":"ERROR: Can't modify constant item in substitution (s///) at (eval 558) line 1, at EOF\n"},{"err":"","out":" a bc","code":"$_=\"abc\"; s/a/ a /; $_\n"},{"out":"bc","err":"","code":"'abc' =~ s/a//r;\n"},{"code":"[ \" a b c \" =~ /\\s+\\S+/g ]\n","err":"","out":"[\" a\",\" b\",\" c\"]"},{"code":"[ \" a b c \" =~ /\\s*\\S+/g ]  # to keep first non-space\n","err":"","out":"[\" a\",\" b\",\" c\"]"},{"code":" 'abc,,\"this is ,, a ,, string column\",ghi,,jkl' =~ s/(?<=,)(?=,)/\\\\N/gr\n","out":"abc,\\N,\"this is ,\\N, a ,\\N, string column\",ghi,\\N,jkl","err":""},{"out":"MiescoMiesco","err":"","code":"($a, $b) = [ print(\"Miesco\"), print(\"Miesco\") ]\n"},{"code":"($a, $b) = [ print(\"Miesco\"), print(\"Miesco\") ]; print(\"$a\"), print(\"$b\")\n","err":"","out":"MiescoMiescoARRAY(0x54300d0)"},{"err":"","out":"Magic\n","code":"'Abra Kadabra'->import; say 'Magic'\n"},{"code":"'a-b' =~ s/[a\\- ]//gr\n","out":"b","err":""},{"code":"' a b ' =~ /\\s\\B\\s/\n","err":"","out":""},{"out":"ab","err":"","code":"'[a][b]' =~ s/[][]//gr\n"},{"code":"\"a()[]{}<>b\" =~ s/[][(){}<>]//gr\n","out":"ab","err":""},{"out":"ab","err":"","code":"'a-b' =~ s/[- ]//r\n"},{"out":"ab","err":"","code":"'a-b' =~ s/[\\- ]//r\n"},{"code":"['A' cmp 'a']\n","out":"[-1]","err":""},{"code":"'a.com' =~ #(\\w+\\.)com$#\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n"},{"code":"\"a.com\" =~ /(?:\\w+\\.)+com$/\n","err":"","out":"1"},{"out":"","err":"","code":"'a' .. 'd'\n"},{"code":"['a' .. 'd']\n","err":"","out":"[\"a\",\"b\",\"c\",\"d\"]"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"add 5\"\n","err":"","code":"add 5; sub add { $_[0]+1 }\n"},{"code":"$_ = '$addmodnav'; if(/^\\$addmod/i) { if(/^\\$addmod(?: )/i) { print \"some other stuff\" } else { print \"args would be printed here\" } }\n","err":"","out":"args would be printed here"},{"code":"$addr = PF_PACKET; $iface = \"eth0\"; $socket = pack(\"Sa14\", $addr, $iface);\n","out":"\u0000\u0000eth0\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000","err":""},{"code":"`adduser modulus`\n","out":"","err":""},{"out":"[\"\\303\"]","err":"","code":"['Ã¦' =~ /([[:alpha:]])/]\n"},{"code":"['Ã¦' =~ /([[:alpha:]])/a]\n","out":"[]","err":""},{"code":"$_ = \"Ã¦Ã¸Ã¥\"; s/(.)/sprintf('\\\\u%04x', ord $1)/ger\n","out":"\\u00c3\\u00a6\\u00c3\\u00b8\\u00c3\\u00a5","err":""},{"err":"","out":"ERROR: Substitution replacement not terminated at (eval 558) line 1, <STDIN> line 1.\n","code":"$_ = \"Ã¦Ã¸Ã¥\"; s/(.)sprintf('\\\\u%04x', ord $1)/ger\n"},{"out":"","err":"","code":"\"a\" eq \"b\"\n"},{"err":"","out":"[\"\"]","code":"[ \"a\" eq \"b\" ]\n"},{"code":"@_ = ('a' .. 'e'); $single = @_; $single\n","out":"5","err":""},{"out":"1","err":"","code":"@a = (foo => 1, bar => 2); print %{a}\n"},{"err":"","out":"1","code":"@a = (foo => 1, bar => 2); print ${{@a}}{\"a\"}\n"},{"code":"@a = {foo => 1, bar => 2}; print ${$a}{\"foo\"}\n","err":"","out":"1"},{"err":"","out":"baz","code":"$a=\"foo bar\"; *$a = sub {\"baz\"}; \"foo bar\"->()\n"},{"code":"[ \"a hash\" cmp \"an array\" ]\n","err":"","out":"[-1]"},{"out":"[\"o\",\"l\",\"lo\",\"l\",\"ll\",\"llo\",\"e\",\"el\",\"ell\",\"ello\",\"H\",\"He\",\"Hel\",\"Hell\",\"Hello\"]","err":"","code":"@a = (); \"Hello\" =~ /.+(??{unshift@a,$&})/; \\@a\n"},{"err":"","out":"[\"o\",\"lo\",\"llo\",\"ello\",\"Hello\"]","code":"@a = (); \"Hello\" =~ /.+$(??{unshift@a,$&})/; \\@a\n"},{"out":"ERROR: Can't modify glob in substitution (s///) at (eval 558) line 1, at EOF\n","err":"","code":" <a href=\"http://www.yahoo.com/something.php?else=AoilkOoiud.FUoiu239834&ipadd=4.2.2.2&uri=a8s98loielulius_souej.\" min=\"s987ojeouyslkje\"> =~ s/(<.*(src|href)=\"[_%&:\\/\\?=,\\.a-z0-9-]+)[\\?|#|&]ip(ad(d(r(ess?)?)?)?)?=([1-2]?[0-9]{1,2}\\.[1-2]?[0-9]{1,2}\\.[1-2]?[0-9]{1,2}\\.[1-2]?[0-9]{1,2})([_%#&=\\/\\.a-z0-9-]*\".*>)/$1$8/isg\n"},{"code":"$a = \"it works\"; print \"${chr 97}\"\n","err":"","out":"it works"},{"out":"[1,2,4,5,6,7,8]","err":"","code":"$all = [[1,2],[4,5,6],[7,8]]; push @one, @$_ for @$all; \\@one\n"},{"err":"","out":"a","code":"@_ = \"a\"; { local @_ = \"b\"; } \"@_\"\n"},{"code":"'_' =~ /[:alpha:]/\n","out":"","err":""},{"code":"$alpha{1}='1'; $alpha{'01'}='01'; $alpha{2}='2'; map { print \"$alpha{$_},\"; } sort { $a <=> $b || $alpha{$b} cmp $alpha{$a} } keys %alpha\n","out":"1,01,2,","err":""},{"err":"","out":"01,2,","code":"$alpha{1}='1'; $alpha{01}='01'; $alpha{2}='2'; map { print \"$alpha{$_},\"; } sort { $a <=> $b || $alpha{$b} cmp $alpha{$a} } keys %alpha\n"},{"code":"$alpha{a}='1'; $alpha{b}='01'; $alpha{c}='2'; map { print \"$alpha{$_},\"; } sort { $a <=> $b || $alpha{$a} cmp $alpha{$b} } keys %alpha\n","err":"","out":"01,1,2,"},{"out":"2,1,01,","err":"","code":"$alpha{a}='1'; $alpha{b}='01'; $alpha{c}='2'; map { print \"$alpha{$_},\"; } sort { $a <=> $b || $alpha{$b} cmp $alpha{$a} } keys %alpha\n"},{"err":"","out":"2,1,01,","code":"$alpha{a}='1'; $alpha{b}='01'; $alpha{c}='2'; map { print \"$alpha{$_},\"; } sort { $b <=> $a || $alpha{$b} cmp $alpha{$a} } keys %alpha\n"},{"err":"","out":"2,01,1,","code":"$alpha{a}='1'; $alpha{b}='01'; $alpha{c}='2'; map { print \"$alpha{$_},\"; } sort { $b cmp $a || $alpha{$b} <=> $alpha{$a} } keys %alpha\n"},{"err":"","out":"Also this: ÃÂ°ÃÂÃÂÃÂ©","code":"\"Also this: \\N{PILE OF POO}\"\n"},{"out":"ERROR: Can't use an undefined value as a symbol reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"*{$::{Altreus}}{SCALAR}\n"},{"code":"\"Altreus\" =~ s/^.*\\Ke/s/sr\n","out":"Altrsus","err":""},{"code":"a..'m'\n","out":"","err":""},{"code":"'a' =~ m\\a\\\n","err":"","out":"1"},{"out":"","err":"","code":"a..'m',N..Z\n"},{"err":"","out":"","code":"a..m=>N..Z\n"},{"err":"","out":"[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"]","code":"[ a..'m',N..Z ] # list context\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"; and\"\n","code":"and evaldev: or so.\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"[ ...\"\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","code":"[ ............. and in regex i have ranges []...do i parse out the [] in the regex?\n"},{"out":"[\"a\",\"a\"]","err":"","code":"[ 'a' =~ /((.))/ ] # ningu how about this?\n"},{"code":"'### An introduction to Firmware Analysis' =~ s/### (.*)/1. [$1](#\\L$1)/gr\n","out":"1. [An introduction to Firmware Analysis](#an introduction to firmware analysis)","err":""},{"out":"ERROR: Unmatched right square bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, near \"\"annoy\"]\"\n\"use\" not allowed in expression at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, near \"]}\"\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","err":"","code":"\"annoy\"] [\"meow\" is f00bot: loleval VISIBLE \"meow\"] [$@ is variable storing the latest error in eval {} block. It's usually better idea to not use it directly and leave it to modules such as Try::Tiny.] [1 is eval: \"1\"] [8-ball is {eval @t=split\"/\",{fact 8-ball replies};$t[rand@t]}] [[Sno]: eval isn't part of the construct, that's... [Output truncated. Use `more` to read more]\n"},{"code":"[ \"Another happy day\" =~ m/(.\\K..?)/gc ]\n","err":"","out":"[\"Ano\",\"the\",\"r h\",\"app\",\"y d\",\"ay\"]"},{"code":"@answer = (); ' foo= bar1,bar2,bar3  ' =~ / +foo= +.*?(\\b\\w+\\d+)(?{push @answer, $1})(*FAIL)/; \\@answer\n","err":"","out":"[\"bar1\",\"bar2\",\"bar3\"]"},{"err":"","out":"AÃÂÃÂ§","code":"\"A\\N{U+0327}\"\n"},{"code":"any {1} 1\n","out":"ERROR: Can't locate object method \"any\" via package \"1\" (perhaps you forgot to load \"1\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Can't call method \"any\" without a package or object reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"any {$_ eq 'a'}, 'b', 'c'\n"},{"code":"\"any string\" =~ /alias:any string/\n","err":"","out":""},{"code":"$a=\"one\"; $a = $b || undef; print $a;\n","out":"1","err":""},{"code":"$_=\"ÃÃ¶\"; [ s/[^Ã¤]/x/gir ]\n","out":"[\"\\303x\\303x\"]","err":""},{"code":"'a' =~ /\\P{In_Latin1}/\n","out":"1","err":""},{"code":"$a=[]; print !!@$a;\n","err":"","out":"1"},{"code":"$a=[]; print !!$a\n","err":"","out":"1"},{"out":"1","err":"","code":"$a=[]; print !!${@a}\n"},{"out":"ERROR: Not a SCALAR reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$a=[]; print !!${$a}\n"},{"code":"$a=[]; print !!$@a\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"$@a\n\"\n"},{"code":"$a = []; push $a, 1; $a  # right?\n","err":"","out":"[1]"},{"err":"","out":"a quine!: \"a quine!: @_\"","code":"\"a quine!: @_\"\n"},{"code":"@a = qw(1 2 3); [ map { $_ == shift @a } @a ]\n","out":"[1,1,1]","err":""},{"out":"0: 1 1: one 2: 2 3: two ","err":"","code":"@a = qw( 1 one 2 two ); print \"$_: $a[ $_ ] \" for keys @a;\n"},{"err":"","out":"1: one, 2: two, ","code":"%a = qw ( 1 one 2 two ); print \"$_: $a{$_}, \" for keys %a\n"},{"out":"","err":"","code":"%a = qw ( 1 one 2 two ); print \"$_: $a{$_}, \" for keys %s\n"},{"code":"%a = qw ( 1 one 2 two ); print keys %a\n","out":"21","err":""},{"out":"2/8","err":"","code":"%a = qw ( 1 one 2 two ); print scalar %a\n"},{"out":"2","err":"","code":"%a = qw ( 1 one 2 two ); print scalar keys %a\n"},{"out":"3 elems: <a><b><c>","err":"","code":"@A = qw<a b c>; sprintf \"%d elems: \" . (\"<%s>\") x @A, scalar(@A), @A;\n"},{"code":"@a = (qw/foo bar baz/); @b = map {/bar/} @a; grep !defined, @b;\n","err":"","out":"0"},{"out":"$VAR1 = [\n          1\n        ];\n","err":"","code":"@a = (qw/foo bar baz/); @b = map {/bar/} @a; print Dumper(\\@b);\n"},{"err":"","out":"[1]","code":"@a = (qw/foo bar baz/); [map {/bar/} @a]\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"qw/foo bar baz); [map {/bar\"\nUnmatched right curly bracket at (eval 558) line 1, at end of line\nUnmatched right square bracket at (eval 558) line 1, at end of line\n","err":"","code":"@a = (qw/foo bar baz); [map {/bar/} @a]\n"},{"code":"@a = (qw/foo bar baz/); [map {scalar /bar/} @a]\n","out":"[\"\",1,\"\"]","err":""},{"out":"3","err":"","code":"@a = qw(f o o); undef @a; push @a, qw( b a r );\n"},{"out":"????","err":"","code":"$a=[qw/john paul george ringo/]; $str=join(', ', '?' x scalar @$a);\n"},{"out":"????","err":"","code":"$a=[qw/john paul george ringo/]; $str=join(', ', ('?' x scalar @$a));\n"},{"out":"\u0000\u0000\u0000{","err":"","code":"@a = qw(N 123); sub f { &CORE::pack }; f(@a)\n"},{"code":"@a = qw(N 123); sub f { &CORE::pack(@_) }; f(@a)\n","err":"","out":"\u0000\u0000\u0000{"},{"out":"[]","err":"","code":"<>; \\@ARGV\n"},{"out":"0","err":"","code":"@ARGV\n"},{"out":"-1","err":"","code":"$#ARGV\n"},{"code":"*ARGV = [1]; print for <>;\n","out":"","err":""},{"code":"@ar = (); [ map { $_->{a} } @ar ]\n","err":"","out":"[]"},{"err":"","out":"[]","code":"$ar = []; [ map { $_->{a} } @$ar ]\n"},{"code":"arn\n","out":"arn","err":""},{"out":"Total:  arr","err":"","code":"@arr = ( 1, 2, 3, 4, 5 ); if ( $#arr == 4 ){ print \"Total: $# arr\" };\n"},{"err":"","out":"","code":"@arr = ( 1, 2, 3, 4, 5 ); if (!@arr) { print \"array was empty\"; }\n"},{"code":"@arr = ( '1','2','3','4' ); print @arr >>;\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":""},{"code":"@arr = 1; [exists $arr[-1], exists $arr[-2]]\n","err":"","out":"[1,\"\"]"},{"err":"","out":"[\"Arr1:\",\"a\",\"b\",\"c\",undef,\"Arr2:\",\"a\",\"b\",\"c\"]","code":"@arr1 = qw/ a b c /; @arr2 = @arr1;      ++$#arr1;     [ 'Arr1:', @arr1, 'Arr2:', @arr2 ] # modulus^ it seems you don't really understand that @arr1 *actually gets changed* when you do that ...\n"},{"code":"@arr1 = qw/ a b c /; @arr2 = @arr1;      ++$#arr1;       print '@arr1: ' . join(\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":""},{"err":"","out":"bob","code":"@arr1 = qw/bob alan/; @arr2 = (50, 100); @foo{@arr2} = @arr1; $foo{50}\n"},{"code":"@arr=(\"a\",\"b\",\"c\"); $r=rand(++$#arr); print \"$#arr \", scalar @arr, \" $arr[$r]\"\n","out":"3 4 b","err":""},{"code":"@array/1\n","out":"0","err":""},{"err":"","out":"[\"?,?,?,?,?,?,?,?,?,?\"]","code":"@array = 1..10; [ join ',', map '?', @array ]  # so would this\n"},{"err":"","out":"[\"?,?,?,?,?,?,?,?,?,?\"]","code":"@array = 1..10; [ join ',', ('?') x @array ]\n"},{"out":"[\\1,\\2,\\3]","err":"","code":"@array = (1,2,3); [ \\(@array) ]\n"},{"err":"","out":"","code":"@array = (1,2,3); return join(',', @accounts);\n"},{"out":"","err":"","code":"@array=(1..5); $array[10]\n"},{"out":"[1,2,4,8,16,32,64,128]","err":"","code":"@array = 1; for (@array) {$_ <= 100 and push @array, $_ * 2} \\@array  # hehehe  (never do this :)\n"},{"code":"@array = ( 1=>\"one\", 2=>\"two\"); %hash = @array; map { print \"k:$_ v:$hash{$_}, \" } @array;\n","out":"k:1 v:one, k:one v:, k:2 v:two, k:two v:, ","err":""},{"out":"k:1 v:onek:one v:k:2 v:twok:two v:","err":"","code":"@array = ( 1=>\"one\", 2=>\"two\"); %hash = @array; map { print \"k:$_ v:$hash{$_}\" } @array;\n"},{"code":"@array = ( 1=>\"one\", 2=>\"two\"); %hash = @array; map { print \"k:$_ v:$hash{$_}, \" } keys @array;\n","out":"k:0 v:, k:1 v:one, k:2 v:two, k:3 v:, ","err":""},{"code":"@array = ( 1=>\"one\", 2=>\"two\"); %hash = @array; map { print \"k:$_ v:$hash{$_}, \" } keys @hash;\n","err":"","out":"0"},{"code":"@array = ( 1=>\"one\", 2=>\"two\"); %hash = @array; map { print \"k:$_ v:$hash{$_}, \" } keys %hash;\n","out":"k:2 v:two, k:1 v:one, ","err":""},{"code":"$#array = -2\n","out":"-1","err":""},{"code":"@array = (45,34,67,98); @array = grep $_ != 34, @array; \\@array\n","err":"","out":"[45,67,98]"},{"err":"","out":"[45,67,98]","code":"@array = (45,34,67,98); @index{@array} = 0 .. $#array; splice @array, $index{34}, 1; \\ @array\n"},{"out":"[45,67,98]","err":"","code":"@array = (45,34,67,98); splice @array, $_, 1 for grep $array[$_] == 34, reverse 0 .. $#array; \\@array\n"},{"err":"","out":"Array:1 - 11 - a1 - b","code":"@array = ( 'a' .. 'c' ); printf \"Array:\" . ('%1$d - %s' x @array), 1, @array\n"},{"code":"@array = a..j;  [ @array[-@array .. -2] ]  # entire array except for last element (without modifying array)\n","out":"[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\"]","err":""},{"code":"@array = (('a')x55555); scalar @array\n","err":"","out":"55555"},{"err":"","out":"55","code":"@array = (('a')x55); scalar @array\n"},{"out":"[\"a\",\"a\",\"a\",\"a\",\"a\"]","err":"","code":"@array = (('a')x5); \\@array\n"},{"code":"@array = (('a')x(5x10)); scalar @array\n","out":"","err":"Out of memory!\n"},{"out":"[0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,0,2,4,6,8,10,12,14,16,18,20,0,3,6,9,12,15,18,21,24,27,30,0,4,8,12,16,20,24,28,32,36,40,0,5,10,15,20,25,30,35,40,45,50,0,6,12,18,24,30,36,42,48,54,60,0,7,14,21,28,35,42,49,56,63,70,0,8,16,24,32,40,48,56,64,72,80,0,9,18,27,36,45,54,63,72,81,90,0,10,20,30,40,50,60,70,80,90,100]","err":"","code":"@array = map { $_ % 11 * int $_ / 11 } 0..120; \\@array\n"},{"code":"@array = qw(1 2 3); print \"match\" if(any{ $_ eq '4'} @array);\n","err":"","out":"ERROR: Can't call method \"any\" without a package or object reference at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: Can't call method \"any\" without a package or object reference at (eval 558) line 1, <STDIN> line 1.\n","code":"@array = qw(1 2 3); say \"match\" if(any{ $_ eq '4'} @array);\n"},{"out":"ERROR: Can't call method \"any\" without a package or object reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"@array = qw(1,2,3); say \"match\" if(any{ $_ eq '4'} @array);\n"},{"code":"@array = qw/a b c d e f/; splice @array, -1, 0, 'x'; \\@array  # voila\n","out":"[\"a\",\"b\",\"c\",\"d\",\"e\",\"x\",\"f\"]","err":""},{"out":"[\"a\",\"b\",\"c\",\"d\",\"x\",\"e\",\"f\"]","err":"","code":"@array = qw/a b c d e f/; splice @array, -2, 0, 'x'; \\@array\n"},{"err":"","out":"[\"a\",\"b\",\"c\",\"d\",\"x\",\"e\",\"f\"]","code":"@array = qw/a b c d e f/; splice @array, -2, 0, 'x'; \\@array  # voila\n"},{"code":"@array = qw/a b c d e f/; splice @array, scalar(@array), 0, 'x'; \\@array  # voila\n","out":"[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"x\"]","err":""},{"code":"@array = qw(SHOUTY SHOUT SHOUT); $_ = lc for @array; \\@array\n","err":"","out":"[\"shouty\",\"shout\",\"shout\"]"},{"out":"ERROR: Modification of non-creatable array value attempted, subscript -2 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"@array = qw//; splice @array, -2, 0, 'x'; \\@array\n"},{"out":"b","err":"","code":"$arrayref = [\"a\",\"b\"];  \"$arrayref->[1]\"\n"},{"err":"","out":"smut","code":"$arrayref = [ { foo => bar, baz => m00 }, { lol => lulz, schweinerei => smut } ]; $arrayref->[1]{schweinerei}\n"},{"err":"","out":"","code":"$arrayref=[qw/a b c/]; scalar @{$arrayref}[1,2,3]\n"},{"code":"$arrayref=[qw/a b c]; scalar @{$arrayref}[1,2,3]\n","out":"ERROR: Can't find string terminator \"/\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Can't modify constant item in postdecrement (--) at (eval 558) line 1, near \"'a'--\"\nsyntax error at (eval 558) line 1, near \"--'z'\"\n","err":"","code":"@arr='a'--'z';\n"},{"code":"@arr = (foo => 1, bar => 2); { %{a} }\n","err":"","out":"0"},{"code":"@arr = (); if (!@arr) { print \"array was empty\"; }\n","err":"","out":"array was empty"},{"code":"$arr = []; push $arr, 1; $arr\n","out":"[1]","err":""},{"code":"@arr=qw/a b c/; $b = 3; printf \"this :\".(\"%d %s |\" x @arr), $b, @arr;\n","err":"","out":"this :3 a |0 c |0  |"},{"err":"","out":"this :1 2 |3 a |0 c |","code":"@arr=qw/a b c/; @bong = (1..@arr); printf \"this :\".(\"%d %s |\" x @arr), @bong, @arr;\n"},{"out":"this :3 a |0 c |0  |","err":"","code":"@arr=qw/a b c/; $bong = 3; printf \"this :\".(\"%d %s |\" x @arr), $bong, @arr;\n"},{"out":"0: 'a', 1: 'b', 2: 'c', ","err":"","code":"@arr=qw/a b c/; sprintf \"%d: '%s', \" x @arr, %arr[0 .. $#arr]\n"},{"code":"@arr=qw/a b c/; $x = 3; printf '%.0s' . ('%1$d %s |' x @arr), $x, @arr;\n","out":"3 a |3 b |3 c |","err":""},{"err":"","out":"3 33 a3 b","code":"@arr=qw/a b c/; $x = 3; printf '%1$d %s' x @arr, $x, @arr;\n"},{"code":"@arr = qw(one two three); sub f{print@{$_[0]}}f*{arr}{ref[]};\n","out":"onetwothree","err":""},{"code":"@arr = qw(one two three); sub f{print@{$_[0]}}f*{arr}{ref[]}; <-- *{arr}{ref[]}? o_O\n","out":"ERROR: Unterminated <> operator at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"@arr = undef; if (!@arr) { print \"array was empty\"; }\n","err":"","out":""},{"code":"@ar = (undef); [ map { $_->{a} } @ar ]\n","err":"","out":"[undef]"},{"code":"$ar = [undef]; [ map { $_->{a} } @$ar ]\n","out":"[undef]","err":""},{"out":"[\"\\$1\"]","err":"","code":"[ 'a' =~ s/(.)/('$1','$1')/re ]\n"},{"err":"","out":"[\"a\"]","code":"[ 'a' =~ s/(.)/($1,$1)/re ]\n"},{"code":"[ 'a' =~ s/(.)/($1) x 2/re ]\n","err":"","out":"[\"aa\"]"},{"code":"$a=++$$.s/../$$/;$$<<~~+$a\n","out":"14312439615783436288","err":""},{"code":"'A' =~ s/(A)/lcfirst $1/re\n","out":"a","err":""},{"out":"[\"\\303\\204\"]","err":"","code":"$_=\"Ã\"; [ s/Ã¤/x/ir ]\n"},{"err":"","out":"[\"asd1312321\",\"asd1212\",\"asd121212\"]","code":"[ \"asd1312321asd1212asd121212\" =~/(asd\\d+)/g ]\n"},{"code":"~\"asdf\"\n","err":"","out":"ÃÂÃÂÃÂÃÂ"},{"out":"0","err":"","code":"$asdf = []; 0 + !!@$blah\n"},{"err":"","out":"[\"f\"]","code":"\"asdf\" =~ /(.)+/; [ $1 ]\n"},{"code":"$asdf=[1,2]; !!@$asdf;\n","out":"1","err":""},{"code":"$asdf=[]; !!@$asdf;\n","err":"","out":""},{"out":"1","err":"","code":"\"asd.fg.foo.asd.fg\" =~ /(.*)\\.([^.]*)\\.\\1/\n"},{"code":"$asdf=[]; print !!@$asdf;\n","err":"","out":"1"},{"code":"\"        asdf    \" =~ /^([\\t ]+)/; my $indents = () = $1 =~ /(\\t| {4})/g\n","out":"2","err":""},{"code":"\"        asdf    \" =~ /^([\\t ]+)/; my $indents = () = $1 =~ /(\\t| {8})/g\n","err":"","out":"1"},{"out":"2","err":"","code":"\"        asdf    \" =~ /^([\\t\\s]+)/; my $indents = () = $1 =~ /(\\t|\\s{4})/g\n"},{"code":"\"        asdf    \" =~ /^[\\t\\s]+/; my $indents = () = $1 =~ /(\\t|\\s{4})/g\n","out":"0","err":""},{"code":"(\"asdfX\" ^ \"asdfY\") =~ /^\\0*[^\\0]\\z/ ? 'yes' : 'no'\n","out":"yes","err":""},{"err":"","out":"yes","code":"(\"asdfYt\" ^ \"asdfY\") =~ /^\\0*[^\\0]\\z/ ? 'yes' : 'no'\n"},{"code":"[ \"asd   qwe\" =~ /(\\w+)\\s(\\w+?)/ ]\n","out":"[]","err":""},{"code":"[ \"asd   qwe\" =~ /(\\w+)\\s+(\\w+?)/ ]\n","err":"","out":"[\"asd\",\"q\"]"},{"err":"","out":"a","code":"\"a\" =~ s/(.)/\\l$1/r\n"},{"out":"a","err":"","code":"\"A\" =~ s/(.)/\\l$1/r\n"},{"code":"@a = split //, 123456; join '', @a[map $_^1, 0..$#a]\n","out":"214365","err":""},{"code":"\"a string literal\" ~~ [\"a string literal\"]\n","err":"","out":"1"},{"out":"","err":"","code":"[ \"a string literal\" ] ~~ \"a string literal\"\n"},{"err":"","out":"","code":"[\"a string literal\"] ~~ [\"a string literal\", \"another string literal\"]\n"},{"err":"","out":"foo","code":"{ a => sub { print 'foo' } }->{a}()\n"},{"code":"atan(0, -1)\n","err":"","out":"ERROR: Usage: POSIX::atan(x) at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"3.14159265358979","err":"","code":"atan2(0, -1)\n"},{"code":"'atcg' ^ 'agcg'\n","err":"","out":"\u0000\u0013\u0000\u0000"},{"out":"The quIck bRowN Fox JuMPeD ovEr THE LaZy dOgS","err":"","code":"$a='the quick brown fox jumped over the lazy dogs'; $a=~s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $a;\n"},{"err":"","out":"ThE quiCk bROwn FoX jumpEd oVer the lazy dogS","code":"$a=\"the quick brown fox jumped over the lazy dogs\"; $a=~s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $a\n"},{"code":"\"Ã\\u{0086}ther\"\n","err":"","out":"ÃÂÃÂ{0086}ther"},{"code":"\"Ã\\u0086ther\"\n","err":"","out":"ÃÂÃÂ0086ther"},{"code":"$a=[]; use print !!$a\n","err":"","out":"ERROR: Can't locate print.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"(\"a\" x 20) =~ /a*b/;\n","err":"","out":""},{"code":"[ (\"a\" x 20) =~ /(a*b)/ ];\n","err":"","out":"[]"},{"out":"[\"aaaaaaaaaaaaaaaaaaaab\",\"\"]","err":"","code":"[ (\"a\" x 20 . \"b\") =~ /((a*?)*b)/ ];\n"},{"code":"[ (\"a\" x 20 . \"b\") =~ /((a*)*b)/ ];\n","out":"[\"aaaaaaaaaaaaaaaaaaaab\",\"\"]","err":""},{"out":"[\"aaaaaaaaaaaaaaaaaaaab\",\"a\"]","err":"","code":"[ (\"a\" x 20 . \"b\") =~ /((a+?)*b)/ ];\n"},{"code":"[ (\"a\" x 20 . \"b\") =~ /((a+)*b)/ ];\n","err":"","out":"[\"aaaaaaaaaaaaaaaaaaaab\",\"aaaaaaaaaaaaaaaaaaaa\"]"},{"out":"[\"aaaaaaaaaaaaaaaaaaaab\"]","err":"","code":"[ (\"a\" x 20 . \"b\") =~ /(a*?b)/ ];\n"},{"err":"","out":"aaa","code":"'a' x 3\n"},{"out":"ERROR: Can't modify constant item in postincrement (++) at (eval 558) line 1, near \"'a'++\"\n","err":"","code":"[('a'++)x3]\n"},{"out":"[\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"\"]","err":"","code":"[ (\"a\" x 30) =~ /((a|a?)+)/ ];\n"},{"code":"['a' x 4]\n","err":"","out":"[\"aaaa\"]"},{"out":"[\"a\",\"a\",\"a\",\"a\"]","err":"","code":"[('a') x 4]\n"},{"code":"('a,'x45) =~ s/(.*?,){10}\\K/\\n/gr\n","err":"","out":"a,a,a,a,a,a,a,a,a,a,\na,a,a,a,a,a,a,a,a,a,\na,a,a,a,a,a,a,a,a,a,\na,a,a,a,a,a,a,a,a,a,\na,a,a,a,a,"},{"out":"[\"\"]","err":"","code":"[ 'a' x 'b' ]\n"},{"code":"[ 'axcom' =~ /a.com/ ? 'yes' : 'no' ]\n","out":"[\"yes\"]","err":""},{"err":"","out":"[\"\"]","code":"[\"a\" xor \"a\"]\n"},{"code":"\"A-Z\" =~ /A-Z/ ? 'true' : 'false'\n","out":"true","err":""},{"code":"'_[a-z]+_(bd\\d+_[a-z0-9]{7}_\\d{6}_\\d{4}(AM|PM)_PST).tar.gz'\n","out":"_[a-z]+_(bd\\d+_[a-z0-9]{7}_\\d{6}_\\d{4}(AM|PM)_PST).tar.gz","err":""},{"err":"","out":"\\\\\\\\\\\\","code":"\"\\\\\\\\\\\\\\\\$backup_server\\\\\\\\$host\"\n"},{"code":"\"\\\\\\\\\\\\\\\\backup_server\\\\\\\\host\"\n","out":"\\\\\\\\backup_server\\\\host","err":""},{"code":"\"banana\" =~ /(a)/; [ @- ]\n","err":"","out":"[1,1]"},{"out":"[22]","err":"","code":"\"banana\" =~ /(a)/; \\@-\n"},{"out":"[20]","err":"","code":"\"banana\" =~ /a/; \\@-\n"},{"code":"[ \"banana\" =~ ?a? ]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"=~ ?\"\n"},{"code":"[ \"banana\" =~ /.a/g ]\n","err":"","out":"[\"ba\",\"na\",\"na\"]"},{"code":"() = 'banana' =~ /(?=ana)/g\n","out":"2","err":""},{"code":"\"banana\" =~ /apple/; join //, qw(foo bar baz)\n","err":"","out":"foo1bar1baz"},{"code":"\"banana\" =~ /b(a)/; [ @- ]\n","err":"","out":"[0,1]"},{"err":"","out":"[0,0]","code":"\"banana\" =~ /(b|a|n)/g; [@-]\n"},{"err":"","out":"110000","code":"('banana' ^ 'batman') =~ s/(.)/chr(ord \"0\" + !ord $1)/ger\n"},{"code":"('banana' ^ 'batman') =~ s/(.)/chr(ord \"0\" + ord $1)/ger\n","out":"002111","err":""},{"code":"('banana' ^ 'batma') =~ s/(.)/chr(ord \"0\" + !ord $1)/ger\n","out":"110000","err":""},{"err":"","out":"[undef,\"banana\"]","code":"$_ = \"banana\"; $from =~ /$_/i; [$from, $_]\n"},{"code":"$_ = \"banana\"; $from =~ /$_/i; [$from, $_, scalar /$_/i]\n","err":"","out":"[undef,\"banana\",1]"},{"code":"bananas\n","out":"bananas","err":""},{"code":"\"banana\" =~ s/a/o/gr\n","out":"bonono","err":""},{"err":"","out":"[1]","code":"$_ = \"banana\"; [ s/(ba)/bo/ ]\n"},{"code":"$_ = \"banana\"; s/./sprintf '%2x', ord $&/ge; $_\n","err":"","out":"62616e616e61"},{"code":"\"banana\" =~ s/(.)/sprintf \"\\\\x%x\", $1/gers\n","out":"\\x0\\x0\\x0\\x0\\x0\\x0","err":""},{"err":"","out":"\\x62\\x61\\x6e\\x61\\x6e\\x61","code":"\"banana\" =~ s/(.)/sprintf \"\\\\x%x\", ord $1/gers\n"},{"code":"('banan' ^ 'batman') =~ s/(.)/chr(ord \"0\" + !ord $1)/ger\n","out":"110000","err":""},{"out":"1","err":"","code":"\"banannas\" =~ /anna/\n"},{"err":"","out":"+bar","code":"-(-bar)\n"},{"code":"'bar'\n","err":"","out":"bar"},{"code":"'bar'+0\n","err":"","out":"0"},{"code":"$_ = \"barbb\"; my $count = 0 + s/b//g; [ $count, length($_), $_ ]\n","err":"","out":"[3,2,\"ar\"]"},{"code":"[ $_ = \"barbb\") =~ s/b//g ]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"\"barbb\") \"\n"},{"code":"$_ = \" bar\"; /(foo)? (bar); [$1, $2]\n","err":"","out":"ERROR: Search pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"[undef,\"bar\"]","code":"$_ = \" bar\"; /(foo)? (bar)/; [$1, $2]\n"},{"code":"-(-'bar') # lul wat?\n","err":"","out":"+bar"},{"code":"\"B\" =~ /A-Z/ ? 'true' : 'false'\n","err":"","out":"false"},{"code":"\"bead^corn\" =~ /d^/\n","err":"","out":""},{"code":"'beans [and rice]' =~ s/[]]/--> ] <--/r\n","err":"","out":"beans [and rice--> ] <--"},{"code":"\"beans\" . ' ' . \"cornbread\"\n","out":"beans cornbread","err":""},{"out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(<>\"\n","err":"","code":"BEGIN(<>)\n"},{"code":"BEGIN { *CORE::GLOBAL::defined = sub { 42 }; } defined\n","err":"","out":""},{"out":"42","err":"","code":"BEGIN { *CORE::GLOBAL::ref = sub { 42 }; }  ref 42\n"},{"code":"BEGIN { *CORE::GLOBAL::ref = sub { \"er, wait\" }; }  ref 42\n","err":"","out":"er, wait"},{"code":" BEGIN { *foo = sub (&) { shift->(\"wibble\") } } foo { [ @_ ] }\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(&)\"\nBEGIN not safe after errors--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(&)\"\nBEGIN not safe after errors--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":" BEGIN { *foo = sub (&) { shift->(\"wibble\") } foo { [ @_ ] }\n"},{"out":"[\"asdf\\n\"]","err":"","code":"BEGIN { $^H = 0 }; open $fh, \">\", \\$str; $fh->say('asdf'); [ $str ]\n"},{"code":"BEGIN { $^H = 0 }; open $fh, \">\", \\$str; say {$fh} 'asdf'; [ $str ]\n","out":"[\"asdf\\n\"]","err":""},{"out":"[\"asdf\\n\"]","err":"","code":"BEGIN { $^H = 0 }; open $fh, \">\", \\$str; say $fh 'asdf'; [ $str ]\n"},{"code":"BEGIN { $^H = 0 }; open $fh, \">\", \\$str; say {$fh} 'main'; [ $str ]\n","out":"[\"main\\n\"]","err":""},{"code":"BEGIN { $^H = 0 }; say 42;\n","out":"ERROR: syntax error at (eval 558) line 1, near \"say 42\"\n","err":""},{"code":"BEGIN { $^H = 0 }; say {$fh} 'main';\n","out":"ERROR: Can't call method \"say\" on an undefined value at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Constant(q): Call to &{$^H{q}} did not return a defined value at (eval 558) line 1, near \"defined 'foo'\"\n","err":"","code":"BEGIN { $^H{q} = sub {}; $^H |= 0x8000; } defined 'foo'\n"},{"err":"","out":"[5,3,7,1,9]","code":"BEGIN { *keyys = \\&CORE::keys; } my %foo = 1 .. 10; [ keyys %foo ]\n"},{"code":"BEGIN { *main::defined = sub { !1 } } defined(\"womble\") ? \"yes\" : \"no\"\n","err":"","out":"yes"},{"code":"BEGIN{ my $p = \\__PACKAGE__; &Internals::SvREADONLY($p, 0); $$p = 'foo'; } [ caller(0) ]\n","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"BEGIN{ my $p = \\__PACKAGE__; &Internals::SvREADONLY($p, 0); $$p = 'foo'; } [ __PACKAGE__ ]\n","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Missing $ on loop variable at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"BEGIN { no strict 'refs'; *$_ = sub () :lvalue { state $x; $x } for qw/foo bar baz/; } foo = 1; bar = 2; baz = 3; [ foo, bar, baz ] # works for whatever\n"},{"err":"","out":"surprise!\n","code":"BEGIN { overload::constant integer => sub { state $x = 5; $x++ }; } my $foo = \"5\"; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say \"surprise!\" }\n"},{"code":"BEGIN { package X; *::defined = \\&::defined; } sub defined { 42 } defined\n","err":"","out":""},{"code":"BEGIN { $SIG{__DIE__} = sub { say 42; exit  };  }  a bc\n","err":"","out":""},{"err":"","out":"42\nERROR: Can't locate object method \"a\" via package \"bc\" (perhaps you forgot to load \"bc\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"BEGIN { $SIG{__DIE__} = sub { say 42; return  };  }  a bc\n"},{"out":"[1,1,\\1,0,\"\",\\\"\",0,\"\",$VAR1->[5],1,1,$VAR1->[2]]","err":"","code":"BEGIN { $::{true} = \\!!1; $::{false} = \\!!0 }; [ map { 0+$_, ''.$_, \\$_ } true, false, !!0, !!1 ];\n"},{"err":"","out":"","code":"BEGIN{$^W=1}join+($x)x101\n"},{"code":"BEGIN { $::{wtf} = \\\"hi\"; } \"wtf\"->();\n","out":"hi","err":""},{"code":"BEGIN { $::{wtf} = \\\"hi\"; } wtf()\n","err":"","out":"hi"},{"code":"BEGIN { $::{wtf} = \\\"hi\"; } wtf( \"bleh\" )\n","out":"ERROR: Too many arguments for main::wtf at (eval 558) line 1, near \"\"bleh\" )\n\"\n","err":""},{"err":"","out":"[\"big endian: 114\",\"little endian: 1912602624\"]","code":"[\"big endian: \" . 0x0000_0072, \"little endian: \" . 0x7200_0000 ]\n"},{"err":"","out":"big fan of Barney, Frederick, and Barney.","code":"\"big fan of Fred, Frederick, and Wilma.\" =~ s/\\b(Fred|Wilma)\\b/Barney/gr\n"},{"out":"12351","err":"","code":"() = bike .. care\n"},{"code":"`/bin/ls`\n","err":"","out":""},{"code":"`/bin/ls`; $!\n","out":"Too many open files","err":""},{"code":"binmode select; print chr 8305\n","err":"","out":"ÃÂ¢ÃÂÃÂ±"},{"code":"binmode STDOUT; a^\"â¹\"^b\n","out":"Ã¡ÂÂ¹","err":""},{"err":"","out":"ÂÂÂ¡","code":"binmode STDOUT; \"â¡\"^b^u^u\n"},{"err":"","out":"Ã¢ÂÂ­CÃ¢ÂÂ® Ã¢ÂÂ­aÃ¢ÂÂ® Ã¢ÂÂ­MÃ¢ÂÂ®!Ã¢ÂÂ­eÃ¢ÂÂ®yÃ¢ÂÂ­LÃ¢ÂÂ®LÃ¢ÂÂ­ Ã¢ÂÂ®lÃ¢ÂÂ­cÃ¢ÂÂ®IÃ¢ÂÂ­AÃ¢ÂÂ®sÃ¢ÂÂ­sÃ¢ÂÂ® Ã¢ÂÂ­EÃ¢ÂÂ®SÃ¢ÂÂ­ Ã¢ÂÂ®iÃ¢ÂÂ­ Ã¢ÂÂ® ","code":"binmode STDOUT; $_ = \"CaMeL cAsE   iS sIlLy!  \"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n"},{"code":"binmode STDOUT; $_ = \"CaMeL cAsE   iS sIlLy! ?\"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n","err":"","out":"Ã¢ÂÂ­CÃ¢ÂÂ®?Ã¢ÂÂ­aÃ¢ÂÂ® Ã¢ÂÂ­MÃ¢ÂÂ®!Ã¢ÂÂ­eÃ¢ÂÂ®yÃ¢ÂÂ­LÃ¢ÂÂ®LÃ¢ÂÂ­ Ã¢ÂÂ®lÃ¢ÂÂ­cÃ¢ÂÂ®IÃ¢ÂÂ­AÃ¢ÂÂ®sÃ¢ÂÂ­sÃ¢ÂÂ® Ã¢ÂÂ­EÃ¢ÂÂ®SÃ¢ÂÂ­ Ã¢ÂÂ®iÃ¢ÂÂ­ Ã¢ÂÂ® "},{"err":"","out":"Ã¢ÂÂ­CÃ¢ÂÂ® Ã¢ÂÂ­aÃ¢ÂÂ®!Ã¢ÂÂ­MÃ¢ÂÂ®yÃ¢ÂÂ­eÃ¢ÂÂ®LÃ¢ÂÂ­LÃ¢ÂÂ®lÃ¢ÂÂ­ Ã¢ÂÂ®IÃ¢ÂÂ­cÃ¢ÂÂ®sÃ¢ÂÂ­AÃ¢ÂÂ® Ã¢ÂÂ­sÃ¢ÂÂ®SÃ¢ÂÂ­EÃ¢ÂÂ®iÃ¢ÂÂ­ Ã¢ÂÂ® ","code":"binmode STDOUT; $_ = \"CaMeL cAsE   iS sIlLy! \"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n"},{"code":"binmode STDOUT; $_ = \"CaMeL cAsE  iS sIlLy! \"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n","out":"Ã¢ÂÂ­CÃ¢ÂÂ® Ã¢ÂÂ­aÃ¢ÂÂ®!Ã¢ÂÂ­MÃ¢ÂÂ®yÃ¢ÂÂ­eÃ¢ÂÂ®LÃ¢ÂÂ­LÃ¢ÂÂ®lÃ¢ÂÂ­ Ã¢ÂÂ®IÃ¢ÂÂ­cÃ¢ÂÂ®sÃ¢ÂÂ­AÃ¢ÂÂ® Ã¢ÂÂ­sÃ¢ÂÂ®SÃ¢ÂÂ­EÃ¢ÂÂ®iÃ¢ÂÂ­ Ã¢ÂÂ® ","err":""},{"code":"binmode STDOUT; $_ = \"CaMeL cAsE iS sIlLy! \"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n","out":"Ã¢ÂÂ­CÃ¢ÂÂ® Ã¢ÂÂ­aÃ¢ÂÂ®!Ã¢ÂÂ­MÃ¢ÂÂ®yÃ¢ÂÂ­eÃ¢ÂÂ®LÃ¢ÂÂ­LÃ¢ÂÂ®lÃ¢ÂÂ­ Ã¢ÂÂ®IÃ¢ÂÂ­cÃ¢ÂÂ®sÃ¢ÂÂ­AÃ¢ÂÂ® Ã¢ÂÂ­sÃ¢ÂÂ®SÃ¢ÂÂ­EÃ¢ÂÂ®i","err":""},{"out":"Ã¢ÂÂ­CÃ¢ÂÂ®!Ã¢ÂÂ­aÃ¢ÂÂ®yÃ¢ÂÂ­MÃ¢ÂÂ®LÃ¢ÂÂ­eÃ¢ÂÂ®lÃ¢ÂÂ­LÃ¢ÂÂ®IÃ¢ÂÂ­ Ã¢ÂÂ®sÃ¢ÂÂ­cÃ¢ÂÂ® Ã¢ÂÂ­AÃ¢ÂÂ®SÃ¢ÂÂ­sÃ¢ÂÂ®iÃ¢ÂÂ­EÃ¢ÂÂ® ","err":"","code":"binmode STDOUT; $_ = \"CaMeL cAsE iS sIlLy!\"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n"},{"err":"","out":"Ã¯Â¿Â½Ã¯Â¿Â½Ã¯Â¿Â½Ã¯Â¿Â½Ã¯Â¿Â½Ã¯Â¿Â½","code":"binmode STDOUT; Encode::decode(\"utf-8\", \"\\x99\\x99\\x99\\x99\\x99\\x99\")\n"},{"code":"binmode STDOUT; $_ = \"Just another Perl/BIDI Hacker,\"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n","err":"","out":"Ã¢ÂÂ­JÃ¢ÂÂ®,Ã¢ÂÂ­uÃ¢ÂÂ®rÃ¢ÂÂ­sÃ¢ÂÂ®eÃ¢ÂÂ­tÃ¢ÂÂ®kÃ¢ÂÂ­ Ã¢ÂÂ®cÃ¢ÂÂ­aÃ¢ÂÂ®aÃ¢ÂÂ­nÃ¢ÂÂ®HÃ¢ÂÂ­oÃ¢ÂÂ® Ã¢ÂÂ­tÃ¢ÂÂ®IÃ¢ÂÂ­hÃ¢ÂÂ®DÃ¢ÂÂ­eÃ¢ÂÂ®IÃ¢ÂÂ­rÃ¢ÂÂ®BÃ¢ÂÂ­ Ã¢ÂÂ®/Ã¢ÂÂ­PÃ¢ÂÂ®lÃ¢ÂÂ­eÃ¢ÂÂ®r"},{"code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\xff00-\\xff5f]r;\n","out":"XÂÂÂÃ¿o|}ÂvsÂÃ¿c|wq}rsÃ¿voqysÂ:","err":""},{"err":"","out":"aÃ¢ÂÂ®bÃ¢ÂÂ®cÃ¢ÂÂ®dÃ¢ÂÂ®eÃ¢ÂÂ®fÃ¢ÂÂ®gÃ¢ÂÂ­hÃ¢ÂÂ­iÃ¢ÂÂ®jÃ¢ÂÂ®kÃ¢ÂÂ­lÃ¢ÂÂ­mÃ¢ÂÂ®nÃ¢ÂÂ­oÃ¢ÂÂ­pÃ¢ÂÂ­qÃ¢ÂÂ­rÃ¢ÂÂ­sÃ¢ÂÂ­tÃ¢ÂÂ­uÃ¢ÂÂ®vÃ¢ÂÂ­wÃ¢ÂÂ­xÃ¢ÂÂ­yÃ¢ÂÂ­zÃ¢ÂÂ®","code":"binmode STDOUT; my @d = qw( â­ â® ); print \"$_$d[rand 2]\" for 'a'..'z'\n"},{"err":"","out":"Ã¢ÂÂ","code":"binmode STDOUT; \"\\N{SPARKLE}\";\n"},{"code":"binmode STDOUT; print \"\\x{1f4a9}\"\n","err":"","out":"Ã°ÂÂÂ©"},{"err":"","out":"0123456789ÃÂ ÃÂ¡ÃÂ¢ÃÂ£ÃÂ¤ÃÂ¥ÃÂ¦ÃÂ§ÃÂ¨ÃÂ©ÃÂ°ÃÂ±ÃÂ²ÃÂ³ÃÂ´ÃÂµÃÂ¶ÃÂ·ÃÂ¸ÃÂ¹ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃ Â¥Â¦Ã Â¥Â§Ã Â¥Â¨Ã Â¥Â©Ã Â¥ÂªÃ Â¥Â«Ã Â¥Â¬Ã Â¥Â­Ã Â¥Â®Ã Â¥Â¯Ã Â§Â¦Ã Â§Â§Ã Â§Â¨Ã Â§Â©Ã Â§ÂªÃ Â§Â«Ã Â§Â¬Ã Â§Â­Ã Â§Â®Ã Â§Â¯Ã Â©Â¦Ã Â©Â§Ã Â©Â¨Ã Â©Â©Ã Â©ÂªÃ Â©Â«Ã Â©Â¬Ã Â©Â­Ã Â©Â®Ã Â©Â¯Ã Â«Â¦Ã Â«Â§Ã Â«Â¨Ã Â«Â©Ã Â«ÂªÃ Â«Â«Ã Â«Â¬Ã Â«Â­Ã Â«Â®Ã Â«Â¯Ã Â­Â¦Ã Â­Â§Ã Â­Â¨Ã Â­Â©Ã Â­ÂªÃ Â­Â«Ã Â­Â¬Ã Â­Â­Ã Â­Â®Ã Â­Â¯Ã Â¯Â¦Ã Â¯Â§Ã Â¯Â¨Ã Â¯Â©Ã Â¯ÂªÃ Â¯Â«Ã Â¯Â¬Ã Â¯Â­Ã Â¯Â®Ã Â¯Â¯Ã Â±Â¦Ã Â±Â§Ã Â±Â¨Ã Â±Â©Ã Â±ÂªÃ Â±Â«Ã Â±Â¬Ã Â±Â­Ã Â±Â®Ã Â±Â¯Ã Â³Â¦Ã Â³Â§Ã Â³Â¨Ã Â³Â©Ã Â³ÂªÃ Â³Â«Ã Â³Â¬Ã Â³Â­Ã Â³Â®Ã Â³Â¯Ã ÂµÂ¦Ã ÂµÂ§Ã ÂµÂ¨Ã ÂµÂ©Ã ÂµÂªÃ ÂµÂ«Ã ÂµÂ¬Ã ÂµÂ­Ã ÂµÂ®Ã ÂµÂ¯Ã Â·Â¦Ã Â·Â§Ã Â·Â¨Ã Â·Â©Ã Â·ÂªÃ Â·Â«Ã Â·Â¬Ã Â·Â­Ã Â·Â®Ã Â·Â¯Ã Â¹Â","code":"binmode STDOUT, ':raw'; print grep { /\\d/ } map { chr } 0x1..0xe50 # for pink_mist's irssi\n"},{"err":"","out":"Ã°ÂÂÂ§Ã°ÂÂÂ¨Ã°ÂÂÂ©Ã°ÂÂÂªÃ°ÂÂÂ«Ã°ÂÂÂ¬Ã°ÂÂÂ­Ã°ÂÂÂ®Ã°ÂÂÂ¯Ã°ÂÂÂ°Ã°ÂÂÂ±Ã°ÂÂÂ²Ã°ÂÂÂ³Ã°ÂÂÂ´Ã°ÂÂÂµÃ°ÂÂÂ¶Ã°ÂÂÂ·Ã°ÂÂÂ¸Ã°ÂÂÂ¹Ã°ÂÂÂ¶Ã°ÂÂÂ·Ã°ÂÂÂ¸Ã°ÂÂÂ¹Ã°ÂÂÂºÃ°ÂÂÂ»Ã°ÂÂÂ¼Ã°ÂÂÂ½Ã°ÂÂÂ¾Ã°ÂÂÂ¿Ã°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂ°Ã°ÂÂÂ±Ã°ÂÂÂ²Ã°ÂÂÂ³Ã°ÂÂÂ´Ã°ÂÂÂµÃ°ÂÂÂ¶Ã°ÂÂÂ·Ã°ÂÂÂ¸Ã°ÂÂÂ¹Ã°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂ£Â Ã°ÂÂ£Â¡Ã°ÂÂ£Â¢Ã°ÂÂ£Â£Ã°ÂÂ£Â¤Ã°ÂÂ£Â¥Ã°ÂÂ£Â¦Ã°ÂÂ£Â§Ã°ÂÂ£Â¨Ã°ÂÂ£Â©Ã°ÂÂ©Â Ã°ÂÂ©Â¡Ã°ÂÂ©Â¢Ã°ÂÂ©Â£Ã°ÂÂ©Â¤Ã°ÂÂ©Â¥Ã°ÂÂ©Â¦Ã°ÂÂ©Â§Ã°ÂÂ©Â¨Ã°ÂÂ©Â©Ã°ÂÂ­ÂÃ°ÂÂ­ÂÃ°ÂÂ­ÂÃ°ÂÂ­ÂÃ°ÂÂ­ÂÃ°ÂÂ­ÂÃ°ÂÂ­ÂÃ°ÂÂ­ÂÃ°ÂÂ­ÂÃ°ÂÂ­ÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂÃ°ÂÂÂ Ã°ÂÂÂ¡Ã°ÂÂÂ¢Ã°ÂÂÂ£Ã°ÂÂÂ¤Ã°ÂÂÂ¥Ã°ÂÂÂ¦Ã°ÂÂÂ§Ã°ÂÂÂ¨Ã°ÂÂÂ©Ã°ÂÂÂªÃ°ÂÂÂ«Ã°ÂÂÂ¬Ã°ÂÂÂ­Ã°ÂÂÂ®Ã°ÂÂÂ¯Ã°ÂÂÂ°Ã°ÂÂÂ±Ã°ÂÂÂ²Ã°ÂÂÂ³Ã°ÂÂÂ´Ã°ÂÂÂµÃ°ÂÂÂ¶Ã°ÂÂÂ·Ã°ÂÂÂ¸Ã°ÂÂÂ¹Ã°ÂÂÂºÃ°ÂÂÂ»Ã°ÂÂÂ¼Ã°ÂÂÂ½Ã°ÂÂÂ¾Ã°ÂÂÂ¿","code":"binmode STDOUT, ':raw'; print grep { /\\d/ } map { chr } 0x11067..0x10ffff # how about these fonts ;)\n"},{"code":"binmode STDOUT; srand 42; my @o = (\"\\x{202d}\", \"\\x{202e}\"); print \"$o[rand 2]$_\" for split //, \"rJust anekocath ehder oUcin\";\n","out":"Ã¢ÂÂ®rÃ¢ÂÂ­JÃ¢ÂÂ­uÃ¢ÂÂ­sÃ¢ÂÂ­tÃ¢ÂÂ® Ã¢ÂÂ­aÃ¢ÂÂ­nÃ¢ÂÂ®eÃ¢ÂÂ®kÃ¢ÂÂ­oÃ¢ÂÂ®cÃ¢ÂÂ®aÃ¢ÂÂ­tÃ¢ÂÂ®hÃ¢ÂÂ® Ã¢ÂÂ®eÃ¢ÂÂ­hÃ¢ÂÂ®dÃ¢ÂÂ­eÃ¢ÂÂ­rÃ¢ÂÂ­ Ã¢ÂÂ®oÃ¢ÂÂ­UÃ¢ÂÂ®cÃ¢ÂÂ®iÃ¢ÂÂ®n","err":""},{"code":"$bla = (12, 13); $bla\n","err":"","out":"13"},{"out":"[12,undef,undef]","err":"","code":"($bla = ($bli, $blu)) = (12, 13, 14); [$bla, $bli, $blu]\n"},{"code":"'blah blah '\\'' blah blah '\\'' blah blah'\n","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"bablah1","err":"","code":"'blah' . print \"a\" . 'blah' . print \"b\"\n"},{"code":"[ \"blah\" =~ s/bl/h/r ]\n","err":"","out":"[\"hah\"]"},{"code":"$blah = { x=>1 }; $z => { y=>$blah->{x} }; $blah->{x} = \"hello\"; $z->{y}\n","out":"","err":""},{"out":"no match","err":"","code":"\"blalapi0\" =~ /^lapi0$/ ? \"match\" : \"no match\"\n"},{"code":"\"bleep\"->bloop\n","err":"","out":"ERROR: Can't locate object method \"bloop\" via package \"bleep\" (perhaps you forgot to load \"bleep\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"[ \"blehAAtingtongtangTTthe cat\" =~ m/(AA.{1,23}TT)/ ]\n","err":"","out":"[\"AAtingtongtangTT\"]"},{"code":"$bleh = sub { print $_[0]; }; $bleh->(\"two\");\n","out":"two","err":""},{"out":"1","err":"","code":"$bleh = sub { print \"$_\" }; $bleh->(\"one\");\n"},{"code":"$bleh = sub { print \"$_\" }; $bleh->(\"two\");\n","err":"","out":"1"},{"code":"$bleh = sub { print shift }; $bleh->(\"two\");\n","err":"","out":"two"},{"code":"bless {}, \"\"\n","err":"","out":"bless( {}, 'main' )"},{"code":"\"\" . bless {}, \"0\"\n","out":"0=HASH(0x4b25398)","err":""},{"code":"bless [], \"\\0\" # or something\n","err":"","out":"bless( [], '' )"},{"err":"","out":"ARRAY=HASH(0x5ebfc10)","code":"\"\" . bless {}, \"ARRAY\"\n"},{"code":"bless \\do { my $nou = undef }, \"trolol\"\n","err":"","out":"bless( do{\\(my $o = undef)}, 'trolol' )"},{"err":"","out":"bless( {}, 'ÃÂÃÂºÃÂ­ÃÂ¾ÃÂ¯ÃÂ¾ÃÂ­ÃÂ' )","code":"bless {}, pack(\"ll\",0xFEEDFACE,0xDEADBEEF)\n"},{"out":"Some::Class=HASH(0x57d24e0)","err":"","code":"'' . bless {}, 'Some::Class'\n"},{"err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","code":"bless \\undef, \"trolol\"\n"},{"err":"","out":"ERROR: Can't bless non-reference value at (eval 558) line 1, <STDIN> line 1.\n","code":"bless you\n"},{"code":"bless \\'you', 'Altreus'\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"bless([], \"your::face\")->import(42);\n","out":"","err":""},{"code":"Blubb->new\n","err":"","out":"ERROR: Can't locate object method \"new\" via package \"Blubb\" (perhaps you forgot to load \"Blubb\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"bold test end bold","err":"","code":"\"bold test end bold\"\n"},{"err":"","out":" \u0002*bold*\u0002 \u001f_underline_\u001f /italics/ normal ","code":"\" \u0002*bold*\u0002 \u001f_underline_\u001f /italics/ normal \"\n"},{"code":"'bool' gt '_Bool'\n","out":"1","err":""},{"out":"[\"o\"]","err":"","code":"[ 'boooo' =~ /\\w*(.)\\1\\w*/g ]\n"},{"code":"\"btw, you can do the same kind of thing with trigger.pl\"\n","out":"btw, you can do the same kind of thing with trigger.pl","err":""},{"code":"\"but not this\" =~ m/^(a+)/ and $+[1]\n","out":"","err":""},{"code":"but where do i put the test?\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n"},{"err":"","out":"buu","code":"buu\n"},{"code":"\"b\"x10e10\n","err":"Out of memory!\npanic: fold_constants JMPENV_PUSH returned 2 at /home/ryan/bots/perlbuut/lib/eval.pl line 301, <STDIN> line 1.\n","out":""},{"err":"","out":"^C","code":"\"\\^C\"\n"},{"err":"","out":"0","code":"$^C\n"},{"code":"$c = 0; [ ' foo (bar (baz) quux (blop)) ' =~ s/[()]/$& eq '(' ? $c++ ? '[' : $& : --$c ? ']' : $&/ger ]\n","out":"[\" foo (bar [baz] quux [blop]) \"]","err":""},{"code":"$c = 1; while(my $e = glob \"{foo,bar}\") {print $c++, \") \", $e, \"    \"}\n","err":"","out":"1) foo    2) bar    "},{"err":"","out":"main::perl_code","code":"(caller(1))[3]\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"$(caller\"\n","err":"","code":"$(caller(1))[3]\n"},{"err":"","out":"","code":"${(caller(1))}[3]\n"},{"code":"\"\"->can(\"foo\");\n","err":"","out":"ERROR: Can't call method \"can\" without a package or object reference at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"'.canvas_container' =~ /\\b\\.canvas/\n","err":"","out":""},{"code":"($capt) = 'hello world' =~ /(hello)/\n","out":"1","err":""},{"err":"","out":"","code":"($capt) = 'hello world' =~ /(hello)/; $cap\n"},{"out":"hello","err":"","code":"($capt) = 'hello world' =~ /(hello)/; $capt\n"},{"code":"carp 'haha'; with 'use Carp' it would run\n","out":"ERROR: syntax error at (eval 558) line 1, near \"carp 'haha'\"\n","err":""},{"err":"","out":"[10]","code":"[ \"cat 10\" =~ /(?:cat|dog)\\s(\\d+)/ ]\n"},{"code":"[ \"cat 10\" =~ /(?:cat)|(?:dog)\\s(\\d+)/ ]\n","err":"","out":"[undef]"},{"code":"[ 'catdog' =~ /(?=(\\w{2}))./sg ]\n","err":"","out":"[\"ca\",\"at\",\"td\",\"do\",\"og\"]"},{"code":"[ 'catdog' =~ /(\\w\\K\\w)/g ]\n","err":"","out":"[\"ca\",\"td\",\"og\"]"},{"code":"cats\n","err":"","out":"cats"},{"code":"~'cats'\n","out":"ÃÂÃÂÃÂÃÂ","err":""},{"err":"","out":"","code":"\"@cats\"\n"},{"code":"[ \"\" || \"cats\" ]\n","err":"","out":"[\"cats\"]"},{"out":"cats","err":"","code":"+\"cats\"\n"},{"out":"1","err":"","code":"\"cats and dogs say hello world\" =~ /hello world/\n"},{"code":"$cats = \"cats\"; $cats =~ s{$cats}'$dogs'r\n","out":"$dogs","err":""},{"code":"$cats = \"meow\"; printf '\"many cats %s\"', $cats\n","err":"","out":"\"many cats meow\""},{"code":"$cats = \"meow\"; [qq(\"many cats $cats\")]\n","out":"[\"\\\"many cats meow\\\"\"]","err":""},{"code":"$cats = \"meow\"; [ sprintf '\"many cats %s\"', $cats ]\n","err":"","out":"[\"\\\"many cats meow\\\"\"]"},{"code":"\"cats\" =~ m pcatsp\n","err":"","out":"1"},{"code":"\"cats\" =~ s'cats'$dogs'r\n","err":"","out":"$dogs"},{"err":"","out":"CATS","code":"'cats' =~ s/(.)/\\U$1/gr\n"},{"code":"\"cats\"->${ \\sub {$_[0]} }\n","err":"","out":"cats"},{"code":"() = \"C++\" =~ /\\b/g\n","out":"2","err":""},{"code":"[ \"\\cC\" ]\n","out":"[\"\\3\"]","err":""},{"out":"1","err":"","code":"\"c\" == \"d\"\n"},{"out":"1","err":"","code":"\"\\cD\" eq \"\\x04\"\n"},{"code":"ceil(log(~0)/log(2))\n","out":"64","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"char 0x3b\"\n","code":"char 0x3b\n"},{"code":"char 0x7b\n","out":"ERROR: syntax error at (eval 558) line 1, near \"char 0x7b\"\n","err":""},{"code":"char(2**16)\n","out":"ERROR: Undefined subroutine &main::char called at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \")\t\t\t\t\t        [\"\n","code":"char(2*16)\t\t\t\t\t        [13:56]\n"},{"err":"","out":"ERROR: Undefined subroutine &main::char called at (eval 558) line 1, <STDIN> line 1.\n","code":"char('a')^char('A')\n"},{"code":"@charmap = qw/Botje!!!/; @charmap->[qw/Botje/]\n","err":"","out":"ERROR: Can't use an array as a reference at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"@charmap = undef; \\@charmap\n","err":"","out":"[undef]"},{"code":"charnames::viacode(0x666)\n","err":"","out":"ARABIC-INDIC DIGIT SIX"},{"out":"LATIN SMALL LETTER SHARP S","err":"","code":"charnames::viacode(0xdf)\n"},{"err":"","out":"[0]","code":"[chomp($_=\"\")]\n"},{"out":"A","err":"","code":"chr 0b01000001\n"},{"err":"","out":"[\"\\377\"]","code":"[ chr 0b1111_1111 ]\n"},{"code":"chr 0x064b\n","out":"ÃÂÃÂ","err":""},{"out":"ÃÂÃÂ","err":"","code":"chr 0x064e\n"},{"code":"[chr 0x11b, \\x{11b}]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"11b\"\n","err":""},{"out":"ÃÂ°ÃÂÃÂÃÂ¾","err":"","code":"chr 0x1F5FE\n"},{"out":"0","err":"","code":"chr(0x30)\n"},{"out":";","err":"","code":"chr 0x3b\n"},{"code":"chr 0x71\n","err":"","out":"q"},{"err":"","out":"{","code":"chr 0x7b\n"},{"code":"chr 0xe2\n","err":"","out":"ÃÂ¢"},{"out":"ÃÂ©","err":"","code":"chr 0xe9\n"},{"code":"chr 0xfb06\n","err":"","out":"ÃÂ¯ÃÂ¬ÃÂ"},{"code":"chr(171)\n","out":"ÃÂ«","err":""},{"out":"1","err":"","code":"chr(173) =~ /\\N{SOFT HYPHEN}/;\n"},{"code":"chr(173) =~ /\\N{U+AD}/;\n","err":"","out":"1"},{"err":"","out":"1","code":"chr(173) =~ /\\xad/;\n"},{"code":"chr(173) =~ /\\xAD/;\n","out":"1","err":""},{"err":"","out":"ÃÂ°ÃÂÃÂÃÂ","code":"chr(2 << 15)\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \")\t\t\t\t\t        [\"\n","err":"","code":"chr(2**16)\t\t\t\t\t        [13:56]\n"},{"code":"chr 232\n","err":"","out":"ÃÂ¨"},{"err":"","out":"\u0018","code":"${\\chr 24}\n"},{"code":"chr 24\n","out":"\u0018","err":""},{"out":"!","err":"","code":"chr 33\n"},{"err":"","out":"\"","code":"chr 34\n"},{"code":"chr 39\n","out":"'","err":""},{"code":"[chr(48) .. chr(48)]\n","out":"[0]","err":""},{"out":"[0,1,2,3,4,5,6,7,8,9]","err":"","code":"[chr(48) .. chr(58)]\n"},{"out":"[1,\"\\n\"]","err":"","code":"[chr 49, chr 10]\n"},{"out":"ÃÂ¾ÃÂÃÂªÃÂÃÂÃÂÃÂ","err":"","code":"chr 5000000000\n"},{"err":"","out":"3L","code":"chr(51) . chr(76)\n"},{"code":"[chr(60) .. chr(88)]\n","err":"","out":"[\"<\"]"},{"code":"chr 65\n","out":"A","err":""},{"code":"[chr(65) .. chr(100)]\n","out":"[\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"]","err":""},{"err":"","out":"[\"A\",\"d\"]","code":"[chr(65), chr(100)]\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"65]\"\nUnmatched right square bracket at (eval 558) line 1, at end of line\n","code":"[chr(65] .. chr(100)]\n"},{"out":"ÃÂ¢ÃÂÃÂ°","err":"","code":"chr 8304\n"},{"out":"\\\"\\x{2071}\"","err":"","code":"\\chr 8305\n"},{"out":"ÃÂ¢ÃÂÃÂ±","err":"","code":"chr 8305\n"},{"err":"","out":"V","code":"chr 86;\n"},{"out":"ÃÂ¢ÃÂÃÂ±","err":"","code":"chr 9585.5\n"},{"err":"","out":"\u0000","code":"chr('a')^chr('A')\n"},{"code":"[chr(hex \"3c\"), \"\\x3c\"]\n","err":"","out":"[\"<\",\"<\"]"},{"err":"","out":"c","code":"chr(ord('a') + 2)\n"},{"err":"","out":"","code":"close(STDIN); close(STDOUT); close(STDERR); print \"I have no mouth and I must scream\"\n"},{"code":"{ Clubs => [ { Url => 'foo.com' } ] }->{Clubs}[0]{Url}\n","out":"foo.com","err":""},{"code":"<code>\n","out":"","err":""},{"out":"[undef,\"use 5.022001; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; [\\$_, \\$code]\"]","err":"","code":"[$_, $code]\n"},{"out":"[\"use 5.022001; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; [\\$code]\"]","err":"","code":"[$code]\n"},{"err":"","out":"use 5.022001; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; $code","code":"$code\n"},{"code":"code; also pleval deparse rbeval jseval pyeval phpeval k20eval luaeval jeval.\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":""},{"code":"<code here>\n","out":"code","err":""},{"out":"eval: $code =~ s/^[^\\$]*/eval: /r","err":"","code":"$code =~ s/^[^\\$]*/eval: /r\n"},{"err":"","out":"$code =~ s/.*?\\$/\\$/r; # small quine","code":"$code =~ s/.*?\\$/\\$/r; # small quine\n"},{"out":"[1,2,3]","err":"","code":"$code = sub { return () }; @r = (1,2,3); push @r, $code->(); \\@r\n"},{"code":"$color = 'green'; $ref = \\$color; $$ref = 'blue'; $color\n","err":"","out":"blue"},{"code":"@color = qw(blue white red); print $color[$#color];\n","err":"","out":"red"},{"out":"red","err":"","code":"@color = qw(blue white red); print $color[eval($#color)];\n"},{"out":"blue","err":"","code":"@color = qw(blue white red); print $color[rand($#color)];\n"},{"out":"ERROR: Can't locate object method \"things\" via package \"properly\" (perhaps you forgot to load \"properly\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"command of perlbot, that's useful to perlbot to display things properly\n"},{"code":"COMMAND --password\n","out":"ERROR: Can't modify constant item in postdecrement (--) at (eval 558) line 1, near \"COMMAND --\"\nsyntax error at (eval 558) line 1, near \"--password\n\"\n","err":""},{"out":"","err":"","code":"\"COMPRESSION_GZIP\" eq \"COMPRESS_GZIP\" # let's ask perl\n"},{"code":"$_ = \"  Computer  \"; [ s/^ +| +$| Computer //gr, s/ Computer |^ +| +$//gr ]\n","out":"[\"Computer\",\"Computer\"]","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, near \"s/Computer//gr ]\"\n","code":"$_ = \"C omputer\"; [ s/ |Computer//gr; s/ //gr =~ s/Computer//gr ]\n"},{"out":"","err":"","code":"$Config{osname}\n"},{"out":"CONST","err":"","code":"*CONST = sub { 'haha' }; CONST\n"},{"err":"","out":"haha","code":"*CONST = sub { 'haha' }; CONST()\n"},{"err":"","out":"ERROR: Undefined subroutine &main::copy called at (eval 558) line 1, <STDIN> line 1.\n","code":"copy(\"$alt\", \"$neu\");\n"},{"out":"","err":"","code":"CORE::dump()\n"},{"code":"[CORE::fc 'â¬']\n","out":"[\"\\342\\202\\254\"]","err":""},{"code":"&CORE::for () CORE::for ();\n","err":"","out":""},{"err":"","out":"ERROR: Undefined subroutine &main::0 called at (eval 558) line 1, <STDIN> line 1.\n","code":"\\&CORE::hex->(\"0x24\")\n"},{"code":"\\&CORE::lc\n","out":"sub { \"DUMMY\" }","err":""},{"code":"(\\&CORE::lc)->('lol')\n","out":"lol","err":""},{"code":"(\\&CORE::lc)->(undef)\n","err":"","out":""},{"code":"&CORE::open()\n","out":"ERROR: Not enough arguments for open at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"(\\&CORE::print)->('a')\n","err":"","out":"ERROR: Undefined subroutine &CORE::print called at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Undefined subroutine &CORE::print called at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"\\&CORE::print->(\"foo\")\n"},{"code":"(\\&CORE::print)->('lol')\n","err":"","out":"ERROR: Undefined subroutine &CORE::print called at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"CORE::prototoype(\\&CORE::die)\n","err":"","out":"ERROR: CORE::prototoype is not a keyword at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"CORE::prototype(\\&CORE::die)\n","out":"@","err":""},{"code":"CORE::prototype(\\&CORE::prototype)\n","out":"_","err":""},{"code":"\\(&CORE::ref)->([])\n","err":"","out":"ERROR: Undefined subroutine &main:: called at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Undefined subroutine &main:: called at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"\\&CORE::ref->([])\n"},{"code":"CORE::say \"hi\"\n","out":"hi\n","err":""},{"code":"(\\&CORE::say)->(\"/layout save\")\n","out":"ERROR: Undefined subroutine &CORE::say called at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"CORE::stat('file')\n","err":"","out":""},{"err":"","out":"ERROR: &CORE::system cannot be called directly at (eval 558) line 1, <STDIN> line 1.\n","code":"&CORE::system(\"ls &\") # aw, no symmetry for me :(\n"},{"err":"","out":"ERROR: Can't locate object method \"echo\" via package \"0\" (perhaps you forgot to load \"0\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"$count = 0; do { echo $count; $count++ } while ($count le 3);\n"},{"code":"$count = 0; do { print $count; $count++ } while ($count le 3);\n","out":"0123","err":""},{"code":"$count = () = bike..care\n","err":"","out":"12351"},{"code":"++$count{$_} for split //, 'abcaba'; \\ %count\n","out":"{a => 3,b => 2,c => 1}","err":""},{"out":"{1 => 21,0 => 25,2 => 17,4 => 17,3 => 20}","err":"","code":"$counts{int rand 5}++ for 1..100; \\%counts\n"},{"code":"[ counts=>{},_keys=>() ]\n","err":"","out":"[\"counts\",{},\"_keys\"]"},{"out":"","err":"","code":"'CryptoX' != 'CryptX' # orly\n"},{"out":"bless( {version => [5,22,1],original => \"v5.22.1\",qv => 1}, 'version' )","err":"","code":"${ \"\\cV\" }\n"},{"code":"${ \"\\cV\" } . ''\n","out":"v5.22.1","err":""},{"out":"TeSt! teSt","err":"","code":"$c=v0;'test! Test'=~s/[a-z]/$&^($c^=$\")/gire\n"},{"code":"$c=v0;'test! Test'=~s/[a-z]/($c^=$\")^lc$&/gire\n","err":"","out":"TeSt! TeSt"},{"err":"","out":"X!xX!x!X!","code":"$c=v0;'x!xx!x!x!'=~s/[a-z]/$&^($c^=$\")/gire\n"},{"out":"[1]","err":"","code":"['*.c' =~ /\\*\\.\\w/]\n"},{"err":"","out":"[\"d8:50:e6:84:e6:de\"]","code":"$_ = 'd850e684e6de'; [join ':', unpack('(A2)*')]\n"},{"out":"d8:50:e6:84:e6:de","err":"","code":"'d850e684e6de' =~ s/..\\K\\B/:/gr\n"},{"out":"1","err":"","code":"\"daleks\" lt \"perl\" # but of course perl would say that\n"},{"code":"[ 'data 234 foo 456 bar' =~ /(\\d+).*bar$/ ]\n","out":"[234]","err":""},{"code":"[ 'data 234 foo 456 bar' =~ /(\\d+)(?=.*bar$)/ ]\n","out":"[234]","err":""},{"err":"","out":"[234]","code":"[ 'data 234 foo 456 bar' =~ /(\\d+)(?:.*bar$)/ ]\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"$data]\"\n","code":"@data = '25 25.175 jitter'; [split(/\\s+/, $data];\n"},{"code":"database->quick_select($Table, \\%Params, \\%Options)\n","err":"","out":"ERROR: Can't locate object method \"quick_select\" via package \"database\" (perhaps you forgot to load \"database\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"[\"02/14/2014\"]","code":"'data-date=\"02/14/2014\"' =~ m!data-date=\"(\\d\\d/\\d\\d/\\d\\d\\d\\d)\"!; [ $1 ]\n"},{"code":"$Data::Dumper::Indent = 0; $h = {'a' => {'one' => 1}, \"b\" => 2}; $i = {'a' => {'two' => 2}}; $j = {%$h, %$i}; print Dumper($j);\n","err":"","out":"$VAR1 = {'b' => 2,'a' => {'two' => 2}};"},{"err":"Can't handle 'IO' type at /home/ryan/bots/perlbuut/lib/eval.pl line 309.\n","out":"","code":"$Data::Dumper::Useperl = 1; open my $fh , '>', \\my $str; [ *$fh{IO} ]\n"},{"code":"@data = (\"foo\"); $data[0]{label} = $data[0]; [@data]\n","err":"","out":"[\"foo\"]"},{"err":"","out":"/data/install/smt/repo/$RCE/SLES11-SP3-Updates/sle-11-x86_64","code":"\"/data/install/smt/repo/\\$RCE/SLES11-SP3-Updates/sle-11-x86_64\"\n"},{"out":"qr/(?#)/","err":"","code":"Data::Munge::list2re \"\"\n"},{"out":"qr/(?!)/","err":"","code":"Data::Munge::list2re ();\n"},{"code":"Data::Munge::list2re qw(= == : --)\n","err":"","out":"qr/\\-\\-|\\=\\=|\\:|\\=/"},{"code":"Data::Munge->VERSION\n","err":"","out":"0.096"},{"code":"[`date`]\n","out":"[]","err":""},{"code":"$_=\"date\"; exec $_;\n","out":"0","err":""},{"out":"15","err":"","code":"DateTime::Duration->new( minutes => 3, seconds => 15 )->in_units('seconds')\n"},{"err":"","out":"ERROR: Can't locate object method \"noew\" via package \"DateTime\" at (eval 558) line 1, <STDIN> line 1.\n","code":"DateTime->noew\n"},{"out":"0","err":"","code":"DateTime::TimeZone->is_valid_name(\"America/New_York\");\n"},{"err":"","out":"D:/AU Files","code":"\"D:/AU\\ Files\"\n"},{"code":"debugmsg(\"Value missing at %d:%d\\n\", 1, 5);   sub debugmsg { my $msg = sprintf(shift, @_); warn $msg; print $msg; }\n","err":"Value missing at 1:5\n","out":"Value missing at 1:5\n"},{"code":"debugmsg(\"Value missing at %d:%d\\n\", 1, 5);   sub debugmsg { my $msg = sprintf(@_); warn $msg; print $msg; } #since perlbot doesn't have $dbug opened, I removed it ... let's see what happens!\n","err":"3 at (eval 558) line 1, <STDIN> line 1.\n","out":"3"},{"out":"ERROR: Undefined subroutine &main::dec called at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"dec('008') == 8\n"},{"code":"\\&decode_json\n","out":"sub { \"DUMMY\" }","err":""},{"code":"decode_json\n","err":"","out":"decode_json"},{"out":"sÃÂ¼ÃÂe","err":"","code":"decode_utf8(\"s\\x{c3}\\x{bc}\\x{c3}\\x{9f}e\")\n"},{"code":"[ defined ${bless \\do { my $nou = undef }, \"trolol\"} ];\n","out":"[\"\"]","err":""},{"code":"[defined chomp($_=\"\")]\n","out":"[1]","err":""},{"code":"defined fork\n","err":"","out":""},{"code":"defined($INC[-1]) ? \"yay\" : \"nay\"\n","out":"nay","err":""},{"out":"[\"\"]","err":"","code":"[ defined ${\\undef} ]\n"},{"code":"delete *C::foo{CODE}\n","out":"ERROR: delete argument is not a HASH or ARRAY element or slice at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"","code":"delete $undef->{foo}; print defined, ref for $foo\n"},{"err":"","out":"1HASH","code":"delete $undef->{foo}; print defined, ref for $undef\n"},{"code":"delete $undef->{key}; $undef\n","err":"","out":"{}"},{"out":"","err":"","code":"deparse: $::{true}\n"},{"code":"$deploys = [1..3]; [ @{$deploys}[-5 .. -1] ];\n","err":"","out":"[undef,undef,1,2,3]"},{"code":"$deploys = [1..3]; [ grep $_, @{$deploys}[-3 .. -1] ];\n","out":"[1,2,3]","err":""},{"code":"$deploys = [1..3]; [ grep $_, @{$deploys}[-5 .. -1] ];\n","err":"","out":"ERROR: Modification of non-creatable array value attempted, subscript -5 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"$deploys = [1..3]; push @foo, $_ for @{$deploys}[-5 .. -1]; [ @foo ]\n","err":"","out":"ERROR: Modification of non-creatable array value attempted, subscript -5 at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: Illegal declaration of subroutine DESTROY at (eval 558) line 1, <STDIN> line 1.\n","code":"DESTROY <>\n"},{"code":"die();\n","err":"","out":"ERROR: Died at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"; ?\"\n","err":"","code":"?: die 'Denied.';\n"},{"code":"()?(): die 'Denied.';\n","out":"ERROR: Denied. at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"[ \"died with signal \" . (256 & 127), 256 & 128 ? 'core dumped' : '' ]\n","err":"","out":"[\"died with signal 0\",\"\"]"},{"err":"","out":"ERROR: failed at (eval 558) line 1, <STDIN> line 1.\n","code":"die \"failed\"\n"},{"err":"","out":"ERROR: foo\n","code":"die \"foo\" . \"\\n\"\n"},{"code":"die or do\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":""},{"err":"","out":"ERROR: SCALAR(0x5be5658)","code":"die \\\"ref here\";\n"},{"out":"d41d8cd98f00b204e9800998ecf8427e","err":"","code":"Digest::MD5::md5_hex \"\"\n"},{"out":"$dirname/","err":"","code":"$dirname = \"/usr/share/local/\"; $arg = '$dirname/'\n"},{"code":"\"<div id=\\\"search-results\\\" ... >\"\n","out":"<div id=\"search-results\" ... >","err":""},{"code":"$_ = 'DoÃ'; s[(doÃ)][ $1 ^ lc $1 ^ 'cat' ]ier;\n","out":"CaT\u0000","err":""},{"out":"[31629,259104768]","err":"","code":"[ $$, do { $a=++$$.s/../$$/;$$<<~~+$a } ]\n"},{"err":"","out":"\"Doe\",\"John 'Johnny'\",\"T\",...","code":"$_ = '\"Doe\",\"John \"Johnny\"\",\"T\",...'; s/(?<=[^,])\"(?!,)/'/gr\n"},{"code":"$_ = 'Dog'; s[(dog)][ $1 ^ lc $1 ^ 'cat' ]er;\n","err":"","out":"Dog"},{"code":"$_ = 'Dog'; s[(dog)][ $1 ^ lc $1 ^ 'cat' ]ier;\n","out":"Cat","err":""},{"out":"[3]","err":"","code":"[ do { if(0) { 2 } else { 3 } } ]\n"},{"err":"","out":"[]","code":"[do { if (1) {} }]\n"},{"code":"[ do { if(1) { 2 } else { 3 } } ]\n","err":"","out":"[2]"},{"out":"doing it for cpan","err":"","code":"\"doing it for fun\" =~ s/fu/cpa/r\n"},{"code":"{ do { last } while 1 }\n","err":"","out":""},{"out":"","err":"","code":"do { last } while 1\n"},{"code":"[do { my $asdf = 9; if ($asdf==9) {} }]\n","err":"","out":"[]"},{"code":"do { my $line = $_; chomp $line; say $line } for \"asdf\",\"asdf\\n\"\n","out":"asdf\nasdf\n","err":""},{"err":"","out":"","code":"do { next }\n"},{"code":"do {} or die\n","err":"","out":"ERROR: Died at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"do or\"\n","code":"do or die\n"},{"code":"do { print q{foo}; } while 0;\n","err":"","out":"foo"},{"out":"ERROR: Can't modify do block in preincrement (++) at (eval 558) line 1, at EOF\n","err":"","code":"++do{ state $N }\n"},{"code":"do { ++state $N }\n","err":"","out":"1"},{"err":"","out":"0","code":"do { state $N++ }\n"},{"out":"3","err":"","code":"do { $x = 1; $x +=2; } if 1; $x\n"},{"code":"\"Dr doctor\" =~ s/(Dr).+/$1/r;\n","err":"","out":"Dr"},{"out":"","err":"","code":"drink_coffee() if $!{ ENOCAFFIENE };\n"},{"err":"","out":"$VAR1 = undef;\n","code":"Dumper(undef); use Data::Dumper\n"},{"err":"","out":"","code":"Dumper; use Data::Dumper\n"},{"out":"","err":"","code":"Dumper(); use Data::Dumper\n"},{"code":"Dumper([]); use Data::Dumper\n","out":"$VAR1 = [];\n","err":""},{"err":"","out":"","code":"-e\n"},{"out":"-e","err":"","code":"-'e'\n"},{"code":"-\"e\"\n","err":"","out":"-e"},{"out":"1","err":"","code":"$_ = \"Ã©\"; $_++; $_\n"},{"code":"$_ = 'e8b748680748'; [ s/..\\K\\B/:/gr ]\n","out":"[\"e8:b7:48:68:07:48\"]","err":""},{"code":"[ each @{[ qw( a b c d e ) ]} ]\n","out":"[0,\"a\"]","err":""},{"err":"","out":"ERROR: Type of argument to each on reference must be unblessed hashref or arrayref at (eval 558) line 1, <STDIN> line 1.\n","code":"each $^V\n"},{"code":"[ $!{EAGAIN} ]\n","err":"","out":"[0]"},{"err":"","out":"[0]","code":"[$!{EAGAIN}]\n"},{"out":"ERROR: Unrecognized character \\xC3; marked by <-- HERE after pha:]]/, '<-- HERE near column 116 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"['Ã¨\" =~ /[[:alpha:]]/, 'Ã¨' =~ /[[:alpha:&&\n"},{"err":"","out":"earlier","code":"earlier\n"},{"code":"$e = \"...brow,n\"; $e =~ s/^\\W*(\\w+).*/$1/; [ $e ]\n","err":"","out":"[\"brow\"]"},{"err":"","out":"[\"brow\"]","code":"$e = \"...brow,n\"; $e =~ s/^\\W*(\\w+).*/\\1/; [ $e ]\n"},{"err":"","out":"[\"...brow,n\"]","code":"$e = \"...brow,n\"; $e =~ s/^\\W*(\\w+)\\W*$/\\1/; [ $e ]\n"},{"out":"ERROR: Can't locate object method \"echo\" via package \"true\" (perhaps you forgot to load \"true\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"echo true\n"},{"out":"","err":"","code":"`echo uuoo`\n"},{"code":"$e = ' e'; @x = (qw(a b c d), $e); \\@x;   # quitte\n","out":"[\"a\",\"b\",\"c\",\"d\",\" e\"]","err":""},{"code":"$e = 'e'; @x = (qw(a b c d), $e); \\@x;   # quitte\n","out":"[\"a\",\"b\",\"c\",\"d\",\"e\"]","err":""},{"code":"$e = 'e'; @x = qw(a b c d), $e; \\@x;   # quitte\n","out":"[\"a\",\"b\",\"c\",\"d\"]","err":""},{"code":"-e \"foo\"; $!\n","out":"No such file or directory","err":""},{"out":"[0,1,2,3,4,5]","err":"","code":"@elems = (0..5);  my $ref =  \\@elems; $ref;\n"},{"code":"EmptyPkg->can(\"can\")\n","err":"","out":"sub { \"DUMMY\" }"},{"code":"EmptyPkg->can(\"DOES\")\n","err":"","out":"sub { \"DUMMY\" }"},{"code":"EmptyPkg->can(\"import\")\n","out":"","err":""},{"code":"EmptyPkg->can(\"isa\")\n","err":"","out":"sub { \"DUMMY\" }"},{"code":"Encode::decode_utf8(join \"\", map chr, qw(195 188 195 159))\n","out":"ÃÂ¼ÃÂ","err":""},{"err":"","out":"ÃÂ¯ÃÂ¿ÃÂ½ÃÂ¯ÃÂ¿ÃÂ½ÃÂ¯ÃÂ¿ÃÂ½ÃÂ¯ÃÂ¿ÃÂ½ÃÂ¯ÃÂ¿ÃÂ½ÃÂ¯ÃÂ¿ÃÂ½","code":"Encode::decode(\"utf-8\", \"\\x99\\x99\\x99\\x99\\x99\\x99\")\n"},{"out":"ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ¡r jÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂº sÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂºr?","err":"","code":"encode 'UTF-8', 'ÃÂ¡r jÃÂº sÃÂºr?'\n"},{"err":"","out":"[\"\\342\\231\\245\"]","code":"[encode_utf8(\"\\x{2665}\")] # works too, depening inthe output you want\n"},{"err":"Unimplemented at (eval 558) line 1, <STDIN> line 1.\nEND failed--call queue aborted at /home/ryan/bots/perlbuut/lib/eval.pl line 281, <STDIN> line 1.\n","out":"","code":"END { ... }\n"},{"out":"3-1-","err":"2- at (eval 558) line 1, <STDIN> line 1.\nEND failed--call queue aborted at /home/ryan/bots/perlbuut/lib/eval.pl line 281, <STDIN> line 1.\n","code":"END { print \"1-\" } END { die \"2-\" } END { print \"3-\" } # b100s\n"},{"code":"END {print \"yes\" } cvx{{Wr\n","err":"","out":"ERROR: Missing right curly or square bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, at EOF\nyes"},{"out":"-1","err":"","code":"EOF # are you a thing?\n"},{"out":"[]","err":"","code":"[ \"EOL\\r\\n\" =~ m/L$/,  \"EOL\\r\\n\" =~ m/L$/m ]\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \", =~\"\n","code":"[ \"EOL\\r\\n\" =~ m/L$/,  \"EOL\\r\\n\", =~ m/L$/m ]\n"},{"code":"[ \"EOL\\r\\n\" =~ m/L\\R\\z/ ]\n","err":"","out":"[1]"},{"err":"","out":"Episode s0105.mkv","code":"\"Episode 1x4.mkv\" =~ s{(\\d+)x(\\d+)}{ sprintf \"s%02d%02d\", $1, $2 + 1 }ger\n"},{"out":"Episode s0104.mkv","err":"","code":"\"Episode 1x4.mkv\" =~ s{(\\d+)x(\\d+)}{ sprintf \"s%02d%02d\", $1, $2 }ger\n"},{"err":"","out":"1","code":"$_ = 'episode9'; s/episode(\\d)/sprintf \"e(%d)\", $1 - 1/e\n"},{"out":"e(8)","err":"","code":"$_ = 'episode9'; s/episode(\\d)/sprintf \"e(%d)\", $1 - 1/e; $_\n"},{"code":"\"equal\" if \"aaaa\" == \"bbbb\"\n","out":"equal","err":""},{"out":"","err":"","code":"\"equal\" if \"aaaa\" eq \"bbbb\"\n"},{"err":"","out":"1","code":"'' eq undef\n"},{"err":"","out":"2","code":"Errno::ENOENT\n"},{"err":"","out":"[\"0.0002\"]","code":"[ eval \"0.00_02\" ]\n"},{"err":"","out":"","code":"eval '0;qq{@{sub{]]}}}}}'\n"},{"out":"[16,10]","err":"","code":"[ eval '0x10', eval '10' ]\n"},{"out":"['18446744073709551615','7378717377743452252']","err":"","code":"[eval \"0x\" . ('f' x 16), unpack(\"q\", '\\xff' x 8)] # hmm\n"},{"out":"[\"\"]","err":"","code":"eval {1}; [ $@ ]\n"},{"code":"eval \"12w6d17h19m58s\" =~ s/(\\d+)(\\w)/'+' . $1 * {qw(w 604800 d 86400 h 3600 m 60 s 1)}->{$2}/ger\n","err":"","out":"7838398"},{"out":"[1,2,3,5,6,7,8,9]","err":"","code":"[ eval '1-3,5,6-9' =~ s/-/../gr ]\n"},{"out":"1","err":"","code":"eval{5 / 0} // 1\n"},{"out":"","err":"","code":"eval \"\\\\\\\\\\\\\\\\backup_server\\\\\\\\host\"\n"},{"out":"","err":"","code":"eval \"\\$       \\b     leonerd = 42\";\n"},{"code":"eval \"\\$       \\b     leonerd = 42\"; $@\n","err":"","out":"syntax error at (eval 559) line 1, near \"$       \b     leonerd \"\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"} say\"\n","code":"eval { die 0; } say \"Died\" if $@;\n"},{"code":"eval { die 0; }; say \"Died $@\" if $@;\n","err":"","out":"Died 0 at (eval 558) line 1, <STDIN> line 1.\n\n"},{"code":"eval { die 0; }; say \"Died\" if $@;\n","out":"Died\n","err":""},{"code":"eval { die JSON::false; }; say \"Died $@\" if $@;\n","out":"bless( do{\\(my $o = 0)}, 'JSON::PP::Boolean' )","err":""},{"code":"eval {die \\\"ref here\";} $$@\n","out":"ERROR: syntax error at (eval 558) line 1, near \"} $$\"\n","err":""},{"code":"eval {die \\\"ref here\";}; $$@\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"$$@\n;\"\n"},{"out":"there you are at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"eval { die 'there you are' }; $@ # easily tested\n"},{"code":"eval { die undef } [ $@ ]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"} [\"\n"},{"err":"","out":"[\"Died at (eval 558) line 1, <STDIN> line 1.\\n\"]","code":"eval { die undef }; [ $@ ]\n"},{"err":"","out":"3628800","code":"eval join '*', 1..10\n"},{"err":"","out":"8.41111300774325e+21","code":"eval(join '*', 1..30) / 1000 / 3600 / 24 / 365  # after heat death of universe ?\n"},{"code":"eval: $l = \"abc\"; $r = \"ABC\"; $l =~ s/./$&.substr($r,$-[0],1)/rge\n","out":"aAbBcC","err":""},{"code":"eval \"#line 0 /dev/null\\n}\"; $@\n","out":"Unmatched right curly bracket at /dev/null line 0, at end of line\nsyntax error at /dev/null line 0, near \"#line 0 /dev/null\n}\"\n","err":""},{"err":"","out":"Unmatched right curly bracket at /dev/null line 1, at end of line\nsyntax error at /dev/null line 1, near \"#line 1 /dev/null\n}\"\n","code":"eval \"#line 1 /dev/null\\n}\"; $@\n"},{"code":"eval \"#line -42 /dev/null\\n}\"; $@\n","out":"Unmatched right curly bracket at (eval 559) line 2, at end of line\nsyntax error at (eval 559) line 2, near \"#line -42 /dev/null\n}\"\n","err":""},{"err":"","out":"","code":"eval \"\\$       \\n     leonerd = 42\"; $@\n"},{"err":"","out":"42","code":"eval \"\\$       \\n     leonerd = 42\"; $leonerd\n"},{"err":"","out":"1","code":"eval {print 1; next; print 2}\n"},{"out":"2","err":"","code":"eval { print \"2\" }\n"},{"out":"2","err":"","code":"eval \\{ print \"2\" }\n"},{"err":"","out":"2","code":"eval &{ print \"2\" }\n"},{"code":"eval print \"2\"\n","err":"","out":"2"},{"err":"","out":"20","code":"eval { print \"2\" }; print $?\n"},{"code":"eval { print \"2\" }; print $@\n","err":"","out":"2"},{"err":"","out":"nested\nlike\nthis","code":"eval \"print 'nested\\nlike\\nthis'\"\n"},{"code":"[ eval \"qw(yes yes),\\n#no\\nqw(yes yes)\" ]\n","err":"","out":"[\"yes\",\"yes\",\"yes\",\"yes\"]"},{"code":"eval { return 1; }; print \"HELLO\"\n","err":"","out":"HELLO"},{"code":"eval \"say 1; next; say 2\"\n","err":"","out":"1\n"},{"code":"eval {say 1; next; say 2}\n","out":"1\n","err":""},{"code":"eval: $str=\"network=192.168.1.1; Dummy-SIGB=10.0.2.79; testbed-oam-net=135.111.74.116; Dummy-SIGA=10.0.1.111\"; for ( split /\\;/, $str ){ if ( /(.*)\\=(.*)/ ){ print \"$1,$2\" } }\n","out":"network,192.168.1.1 Dummy-SIGB,10.0.2.79 testbed-oam-net,135.111.74.116 Dummy-SIGA,10.0.1.111","err":""},{"code":"eval {sub C::foo {}; my $o = \\&C::foo; undef &C::foo; $o->(); 1} or $@\n","err":"","out":"Undefined subroutine &C::foo called at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"eval \"\\$       \\t     leonerd = 42\"; $@\n","out":"","err":""},{"code":"eval { undef->() }; \"-> $@ <-\"\n","err":"","out":"-> Can't use an undefined value as a subroutine reference at (eval 558) line 1, <STDIN> line 1.\n <-"},{"out":"Can't use an undefined value as a subroutine reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"eval { undef->() }; $@\n"},{"err":"","out":"65535","code":"eval \"unpack 'S', \\\"\\xff\\xff\\\"\"\n"},{"code":"eval \"\\$       \\v     leonerd = 42\"; $@\n","out":"syntax error at (eval 559) line 1, near \"$       v     leonerd \"\n","err":""},{"out":"","err":"","code":"eval \"`who\".\"ami`\"\n"},{"err":"","out":"AA","code":"eval '\"'.'\\x41\\x41'.'\"'\n"},{"code":"exec '/bin/ls'\n","out":"0","err":""},{"err":"","out":"0","code":"exec 'ping', 'google.com'\n"},{"out":"0","err":"","code":"exec '/usr/bin/ping', 'google.com'\n"},{"code":"exec $^X\n","out":"0","err":""},{"code":"exists \"\"\n","out":"ERROR: exists argument is not a HASH or ARRAY element or a subroutine at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"7","err":"","code":"~~exp 2\n"},{"code":"exp(2)\n","err":"","out":"7.38905609893065"},{"err":"","out":"[[\"hello world\"],$VAR1->[0]]","code":"*EXPORT = \\@Foo::Bar::EXPORT; push @EXPORT, \"hello world\"; [ \\@EXPORT, \\@Foo::Bar::EXPORT ]\n"},{"code":"\"#\\\\E \\\\z\" =~ m{ \\Q#\\E \\z}xms ? \"wtf\" : \"k\"\n","out":"wtf","err":""},{"code":"@F=(0..9,0);sub r{my($y,@x)=@_;map{ref$_ ? (&$_) :$_}@d=(@F,($y && sub{@F[$y-1,-1-$y]=($\")x2;r(@x)}),@F%2|$y?@F:())}print r 1,1,3..@F/2-1\n","err":"","out":"ERROR: Segmentation Fault\n"},{"code":"\"f0b0\" =~ /f(.)b\\1/\n","out":"1","err":""},{"code":"fail?succeed:fail\n","out":"succeed","err":""},{"code":"FAIL x 2\n","err":"","out":"FAILFAIL"},{"code":"false ? true : file_not_found\n","err":"","out":"true"},{"code":"'false' ? \"yes it is\" : \"no, it isn't\" # place your bets!\n","out":"yes it is","err":""},{"code":"%fancylist = ( 1,\"one\",2,\"two\",3,\"three\" ); print scalar %fancylist;\n","out":"3/8","err":""},{"code":"%fancylist = ( 1,\"one\",2,\"two\",3,\"three\" ); print scalar keys %fancylist;\n","out":"3","err":""},{"err":"","out":"1","code":"fc('er') eq fc('Er')\n"},{"err":"","out":"ÃÂ£ÃÂ","code":"fc \"Ã\"\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"07F\n\"\n","code":"FF & 07F\n"},{"err":"","out":"[\"\",undef,undef]","code":"[ -f \"/\", -f \"/does-not-exist\", -f undef ]\n"},{"out":"$b$b$b","err":"","code":"$_ = '@f@f@f'; s'@f'$b'gr;\n"},{"out":"[\"file-bkp1-2014-06-08\",\"file-bkp2-2014-06-08\",\"file-bkp3-2014-06-08\",\"file-bkp4-2014-06-08\",\"file-bkp5-2014-06-08\",\"file-bkp6-2014-06-08\",\"file-bkp7-2014-06-08\",\"file-bkp8-2014-06-08\",\"file-bkp9-2014-06-08\",\"file-bkp10-2014-06-08\",\"file-bkp11-2014-06-08\",\"file-bkp12-2014-06-08\"]","err":"","code":"$_ = 'file-bkp-2014-06-08'; [ map { s/bkp\\K(\\d*)/$1+1/e; $_ } ($_) x 12 ]\n"},{"code":"[ fileno STDIN, fileno STDOUT, fileno STDERR ]\n","err":"","out":"[0,1,2]"},{"code":"@files = qw(one two three); 'there are ' . @files . ' files'\n","err":"","out":"there are 3 files"},{"out":"there are 3 files","err":"","code":"@files = qw(one two three); \"there are @{[ scalar @files ]} files\"\n"},{"err":"","out":"[]","code":"[ %{File::Stat::} ]\n"},{"out":"[\"import\",*File::Stat::import]","err":"","code":"File::Stat->import; [ %{File::Stat::} ]\n"},{"out":"F., Name, 745 45363\nS., One, 343 5454","err":"","code":" $_ = \"First Name Position first.name@somewhere.com 745 45363\\nSome One Worker some.one@somewhere.com 343 5454\\n\" =~ s/^\\s*(\\S)\\S*\\s+(\\S+).+?(\\d\\d\\d \\d\\d\\d\\d)\\s*/$1., $2, $3/gmr\n"},{"out":"[\"Bla, bla, bla. \",\"Hi.\\t\"]","err":"","code":"$_ = \"First.\\nSecond.\\nBla, bla, bla. \\nHi.\\t\\nLast line.\\n\"; [ /^.*\\h+$/gm ] # try \\h if you only want horizontal whitespace\n"},{"err":"","out":"first","code":"@_=('first','second'); print $_[0];\n"},{"err":"","out":"ERROR: Usage: POSIX::floor(x) at (eval 558) line 1, <STDIN> line 1.\n","code":"floor()\n"},{"code":"[ floor(-5/3), int(-5/3) ]\n","err":"","out":"[-2,-1]"},{"out":"85","err":"","code":"floor(85.3)\n"},{"code":"$fl = '+++????? random shit any user can send to the bot'; my @mem_list = grep { $_ =~ /^$fl/i} 42;\n","out":"ERROR: Nested quantifiers in regex; marked by <-- HERE in m/^+++ <-- HERE ????? random shit any user can send to the bot/ at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"-F\\\"m S\\\"\n"},{"err":"","out":"foo","code":"foo\n"},{"err":"","out":"foo","code":"~~\"foo\"\n"},{"out":"-foo","err":"","code":"-foo\n"},{"code":"'\\'foo\\''\n","out":"'foo'","err":""},{"out":"foo","err":"","code":"'foo'\n"},{"out":"ERROR: Not an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"\"\" . \\@{\\*foo}\n"},{"code":"\"foo\" =~ /[.]/\n","err":"","out":""},{"code":"(\\*foo)->()\n","out":"ERROR: Not a CODE reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Undefined subroutine &main::foo called at (eval 558) line 1, <STDIN> line 1.\n","code":"(\\&{ \\*foo })->()\n"},{"code":"[ \"foo\" =~ /()(.)/ ]\n","err":"","out":"[\"\",\"f\"]"},{"err":"","out":"[\"foo\"]","code":"[${\\ 'foo' }]\n"},{"err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","code":"$_=\"foo\n"},{"code":"$_ = 'foo'; $::_\n","out":"foo","err":""},{"out":"*main::foo","err":"","code":"${\\*foo}\n"},{"err":"","out":"","code":"$foo->@*\n"},{"out":"*main::foo","err":"","code":"*foo\n"},{"code":"\\\\*foo\n","err":"","out":"\\\\*::foo"},{"code":"\\&::foo\n","err":"","out":"sub { \"DUMMY\" }"},{"code":"\\&{ \\*foo }->()\n","err":"","out":"ERROR: Not a CODE reference at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"$foo++\"\n","err":"","code":"++$foo++\n"},{"out":"0","err":"","code":"'foo'+0\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"foo \\\"\n","err":"","code":"foo { $$_[0] = 1 } foo \\(my $x); $x\n"},{"err":"","out":"ERROR: Not an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n","code":"(\\@{ \\*foo })->[0]++; \\@foo;\n"},{"err":"","out":"ERROR: Not an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n","code":"(\\@{ \\*foo })->[0]++; say @foo;\n"},{"code":"$_ = [['foo']]; @$_[0] # Which is entirely different from @{$_[0]}\n","err":"","out":"[\"foo\"]"},{"out":"[1,1,2,3,4]","err":"","code":"$foo = 1; [ 0+$foo, map $foo++, 1..4 ] # if you wanted the other behaviour\n"},{"code":"$foo[-1] = 2\n","out":"ERROR: Modification of non-creatable array value attempted, subscript -1 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"[ foo => (1, 2, 3) ]\n","out":"[\"foo\",1,2,3]","err":""},{"err":"","out":"[\"foo\",[1,2,3]]","code":"[ foo => [1, 2, 3] ]\n"},{"err":"","out":"[\"foo\",1,2,3]","code":"[ foo => 1, 2, 3 ]\n"},{"err":"","out":"123","code":"{ +FOO => 123 }\n"},{"err":"","out":"[\"1, 2, 3\"]","code":"@foo = ( 1, 2, 3 ); $\" = ', '; [ \"@foo\" ]\n"},{"code":"{ foo => (1, 2, 3) } # perhaps more useful\n","err":"","out":"{2 => 3,foo => 1}"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"foo 1\"\n","err":"","code":"[foo 1, 2, 3] sub foo { { thingy => $_[0] } }\n"},{"out":"foo 12 bar 13","err":"","code":"\"@{ [ %{ {foo => 12, bar => 13} }] }\" # no hash slice involved\n"},{"out":"foo=(1,2)   bar=(3,4)","err":"","code":"\"foo=(1, 2)   bar=(3, 4)\" =~ s/(?<=\\()([^)]+)/$1=~s{\\s+}{}gr/gre\n"},{"code":"@foo = (1, 2, undef, 4); for my $foo (@foo) { print $foo }\n","err":"","out":"124"},{"code":"$foo[-1] = 42\n","err":"","out":"ERROR: Modification of non-creatable array value attempted, subscript -1 at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"[\"foo1\",\"0.8\",\"foo2\",0,\"foo3\",1]","err":"","code":"$foo1 = 4/5; $foo2 = int(4/5); $foo3 = $foo2 ? $foo2 : 1; [ foo1 => $foo1, foo2 => $foo2, foo3 => $foo3 ]\n"},{"code":"$foo = 1; $bar = *foo; $qux = \\*foo; [ $$bar, $$qux ]\n","out":"[1,*::foo]","err":""},{"err":"","out":"ERROR: Global symbol \"$bar\" requires explicit package name (did you forget to declare \"my $bar\"?) at (eval 558) line 1, <STDIN> line 1.\nGlobal symbol \"$qux\" requires explicit package name (did you forget to declare \"my $qux\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"$foo = 1; $bar = *foo; $qux = \\*foo; use strict; [ $$bar, $$qux ]\n"},{"out":"[4,42]","err":"","code":"$foo1 = $foo2 = '4 a 2'; ( $foo1 ) = $foo1 =~ /(\\d+)/; $foo2 =~ s/\\D+//g; [ $foo1, $foo2 ]\n"},{"code":"$foo = 1; $foo++; $foo\n","out":"2","err":""},{"out":"[5,1,2,3,4]","err":"","code":"$foo = 1; [$foo, map { $foo++ } 1 .. 4]; # isn't the order of evaluation from left to right?\n"},{"code":"$foo = 1; our $bar = *foo; our $qux = \\*foo; use strict; [ %$bar ]\n","err":"","out":"[]"},{"err":"","out":"[1,*::foo]","code":"$foo = 1; our $bar = *foo; our $qux = \\*foo; use strict; [ $$bar, $$qux ]\n"},{"out":"ERROR: Not a HASH reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$foo = 1; our $bar = *foo; our $qux = \\*foo; use strict; [ %$bar, %$qux ]\n"},{"out":"[]","err":"","code":"$foo = 1; our $bar = *foo; our $qux = \\*foo; use strict; [ %{*$qux} ]\n"},{"err":"","out":"2","code":"$foo ||= 2;\n"},{"code":"${{[foo=>2, bar=>3]}}{\"foo\"}\n","out":"","err":""},{"err":"","out":"3","code":"$foo=3; $foo ||= 2;\n"},{"err":"","out":"3","code":"$foo = 3; oct \"0x$foo\"\n"},{"code":"{ -foo, 42 }\n","out":"42","err":""},{"code":"{ +foo => 42 }\n","out":"42","err":""},{"code":"+{ +foo => 42 }\n","err":"","out":"{foo => 42}"},{"err":"","out":"43","code":"($foo = 42)++; $foo  # same kind of thing\n"},{"code":"$foo = 42; our $bar = *foo; our $qux = \\*foo; use strict; [ *$bar, *$qux ]\n","out":"[*::foo,*::foo]","err":""},{"err":"","out":"[\\42,$VAR1->[0]]","code":"$foo = 42; our $bar = *foo; our $qux = \\*foo; use strict; [ *{$bar}{SCALAR}, *{$qux}{SCALAR} ]\n"},{"out":"[\" \\\"42\\\" \"]","err":"","code":"$foo = 42; [ qq' \"$foo\" ' ]\n"},{"err":"","out":"42","code":"$foo = [42]; shift $foo\n"},{"code":"$foo = 5607181; substr($foo, -6, 0) = '.'; $foo # without all that FANCY COMPLICATED DIVISION\n","err":"","out":"5.607181"},{"code":"$foo=5; ${*$foo}{\"bar\"}=2; $5{bar}\n","err":"","out":"2"},{"out":"abcd","err":"","code":"$foo = 'a2b11c3d5'; $foo =~ s/[^a-z]//g; print $foo;\n"},{"out":"[\"a2b11c3d5\"]","err":"","code":"@foo = \"a2b11c3d5\" =~ /(\\w+)/g; \\@foo\n"},{"err":"","out":"1","code":"\"f o o\" =~ /[ab ]/\n"},{"out":"[4,4]","err":"","code":"$foo = \"abcdefg\"; $foo =~ s/ef//; [ $-[0], length $` ]\n"},{"code":"$foo = \"abc:def\"; {split /:/, $foo};\n","out":"2","err":""},{"code":"$foo = \"abc:def\"; sprintf(\"0x%x\", ~~{split \":\", $foo});\n","out":"0x54062f8","err":""},{"err":"","out":"","code":"$foo = '...'; \"abc\" =~ /\\Q$foo/\n"},{"code":"\"f o o\" =~ /[ab ]/x\n","out":"1","err":""},{"code":"[ \"foo a b = z\" =~ /foo((?: \\w)+)/ ]\n","out":"[\" a b\"]","err":""},{"err":"","out":"[\" b\",\"foo a b\"]","code":"\"foo a b = z\" =~ /foo( \\w)+/; [ $1, $& ]\n"},{"code":"$foo = \"AF\"; [chr oct \"0x$foo\"]\n","err":"","out":"[\"\\257\"]"},{"code":"$_ = \"foo: a\\n bar: 1\\n bar: 2\\nfoo: b\\n bar: 5\\nfoo: c\\n\"; my(%h,$last); $1 ? push @{ $h{$last} }, $2 : ($h{$last = $2} = [])   while/^( ?)\\w+: (\\w+)/gm; \\%h\n","out":"{a => [1,2],c => [],b => [5]}","err":""},{"code":"$foo = \"(A)\"; \"\\Q$foo\"\n","err":"","out":"\\(A\\)"},{"err":"","out":"f","code":"$foo = [ a..z ]; *array = $foo;  $array[5] # glob trick for programmers that don't like ->  hehehe\n"},{"code":"'foo  bang' =~ /foo (?:bar)? bang/ ? match : nomatch\n","out":"match","err":""},{"out":"nomatch","err":"","code":"'foo bang' =~ /foo (?:bar)? bang/ ? match : nomatch\n"},{"code":"[ 'foo bang' =~ /foo\\s+(?:bar\\s+)?bang/ ? 'match' : 'nomatch' ]\n","out":"[\"match\"]","err":""},{"code":"<{foo,bar}>\n","err":"","out":"foo"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"^.\"\n","err":"","code":"'foo   ' ^. '   bar'\n"},{"out":"1","err":"","code":"'foo' == 'bar'\n"},{"code":"\"foo\" =~ /bar/\n","err":"","out":""},{"code":"\"foo\" != \"bar\"\n","out":"","err":""},{"err":"","out":"foobar","code":"\"foo\" . \"bar\"\n"},{"out":"FOObar","err":"","code":"\"foobar\" ^ \"   \"\n"},{"code":"[ <{foo,bar}> ]\n","out":"[\"foo\",\"bar\"]","err":""},{"out":"[\"foo ); bar );\"]","err":"","code":"[ \"foo ); bar );\" =~ /(.* \\)\\;)/ ]\n"},{"code":"[ \"foo ); bar );\" =~ /(.*? \\)\\;)/ ]\n","out":"[\"foo );\"]","err":""},{"code":"[- -foo => 'bar']\n","out":"[\"+foo\",\"bar\"]","err":""},{"code":"[--foo => 'bar']\n","out":"ERROR: Can't modify constant item in predecrement (--) at (eval 558) line 1, near \"foo =>\"\n","err":""},{"err":"","out":"[\"+foo\",\"bar\"]","code":"[-+-+-+-+-+-+-+-+foo => 'bar']\n"},{"code":"[-+-foo => 'bar']\n","out":"[\"+foo\",\"bar\"]","err":""},{"err":"","out":"[\"-foo\",\"bar\"]","code":"[(-+foo => 'bar')]\n"},{"err":"","out":"[{foo => \"bar\"}]","code":"[{ +foo => 'bar' }]\n"},{"code":"[{-+foo => 'bar'}]\n","out":"[{\"-foo\" => \"bar\"}]","err":""},{"code":"{ +foo => 'bar' }\n","err":"","out":"bar"},{"code":"{ +foo => \"bar\" }\n","err":"","out":"bar"},{"code":"{-+foo => 'bar'}\n","out":"bar","err":""},{"code":"+{ foo => \"bar\" }\n","err":"","out":"{foo => \"bar\"}"},{"err":"","out":"Foo::bar","code":"Foo'bar\n"},{"code":"$foo = $bar = 0; $foo += $bar += 1 for 1..10; $foo  # even more fun :)\n","out":"55","err":""},{"code":"[ ' foo= bar1,bar2,bar3  ' =~ /bar\\d+/g ]\n","err":"","out":"[\"bar1\",\"bar2\",\"bar3\"]"},{"code":"$foo{'bar'} = 1; $foo{'baz'} = 1; scalar(%foo);\n","out":"1/8","err":""},{"err":"","out":"2","code":"$foo{'bar'} = 1; $foo{'baz'} = 1; scalar(keys(%foo));\n"},{"out":"34","err":"","code":"@foo = ( bar => 34, baz => 42 ); print +{@foo}->{bar};\n"},{"out":"match","err":"","code":"'foo bar bang' =~ /foo (?:bar)? bang/ ? match : nomatch\n"},{"code":"[ 'foo bar bang' =~ /foo\\s+(?:bar\\s+)?bang/ ? 'match' : 'nomatch' ]\n","out":"[\"match\"]","err":""},{"code":"[ foo => bar => baz => ]\n","err":"","out":"[\"foo\",\"bar\",\"baz\"]"},{"err":"","out":"ERROR: Can't locate object method \"foo\" via package \"bar\" (perhaps you forgot to load \"bar\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"foo bar baz\n"},{"code":"$_ = 'foo bar baz'; my %foo; @foo{qw(one two three)} = m/(\\w+)/g; \\%foo;\n","out":"{one => \"foo\",two => \"bar\",three => \"baz\"}","err":""},{"out":"quux baz","err":"","code":"$foo->{bar} = 'baz'; \"quux $foo->{bar}\"\n"},{"err":"","out":"Foo Bar Baz","code":"\"foo bar baz\" =~ s/\\b(\\w)/\\U$1/gr\n"},{"code":"[ 'foo bar baz' =~ /\\S+/g ]\n","err":"","out":"[\"foo\",\"bar\",\"baz\"]"},{"code":"\"    foo bar baz\" =~ s/(?<=\\s)foo//r\n","err":"","out":"     bar baz"},{"code":"\"foo bar baz\" =~ s/(?<=\\s)foo//r\n","err":"","out":"foo bar baz"},{"code":"\"    foo bar baz\" =~ s/\\s\\Kfoo//r\n","err":"","out":"     bar baz"},{"out":"foo bar baz","err":"","code":"\"foo bar baz\" =~ s/\\s\\Kfoo//r\n"},{"out":"ERROR: Unknown regexp modifier \"/r\" at (eval 558) line 1, at end of line\n","err":"","code":"\"foo/bar-baz&stuff/51\" =~ /(\\d+)$/r # if >5.10, I think\n"},{"err":"","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","code":"$foo = { bar => 'baz }; sub foo { $foo->{bar}{baz}{quux} }; exists foo()\n"},{"err":"","out":"1","code":"$foo = { bar => 'baz' }; sub foo { $foo->{bar}{baz}{quux} }; exists &foo;\n"},{"code":"$foo = { bar => 'baz' }; sub foo { $foo->{bar}{baz}{quux} }; exists foo()\n","err":"","out":"ERROR: exists argument is not a subroutine name at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"[ \"foo.bar.baz\" =~ s{\\.(\\w+)}{.get\\u$1()}gr ]\n","err":"","out":"[\"foo.getBar().getBaz()\"]"},{"err":"","out":"Foo Bar Baz","code":"\"foo bar baz\" =~ s/(\\w+)/\\u$1/gr #ah, this is what I was looking for\n"},{"out":"FOO BAR BAZ","err":"","code":"\"foo bar baz\" =~ s/(\\w+)/\\U$1/gr #will this work I wonder?\n"},{"out":"[\"blah\",\"blah\"]","err":"","code":"$foo = $bar = './blah'; substr($foo, 0, 2) = ''; $bar = substr($bar, 2); [ $foo, $bar ]\n"},{"err":"","out":"0","code":"%foo; @bar = ('cat', 'dog', 'bird', 'bird'); @foo{@animals} = (); %foo;\n"},{"code":"%foo; @bar = ('cat', 'dog', 'bird', 'bird'); @foo{@bar} = (); \\%foo;\n","err":"","out":"{cat => undef,bird => undef,dog => undef}"},{"code":"%foo; @bar = ('cat', 'dog', 'bird', 'bird'); @foo{@bar} = (); %foo;\n","out":"3/8","err":""},{"code":"$foo{bar} = (); \\%foo\n","out":"{bar => undef}","err":""},{"code":"$foo = 'bar'; ++$$foo; $bar\n","err":"","out":"1"},{"err":"","out":"[undef,\"bar\"]","code":"[\"foobar\" =~ /f(ooo)|(bar)/]\n"},{"code":"\"foo(bar\" =~ /oo\\(ba/ ? \"match\" : \"no match\"\n","err":"","out":"match"},{"code":"$_='FOO bar'; print if $_ !~ /FOO\\s*?(BAR|xx)/i;\n","err":"","out":""},{"out":"","err":"","code":"$_='FOObar'; print if $_ !~ /FOO\\s*?(BAR|xx)/i;\n"},{"err":"","out":"","code":"$_='FOO bar'; print \"Invalid str.  Foo is missing BAR or xx\"  if $_ =~ /FOO(?!\\s*(BAR|xx))/i;\n"},{"err":"","out":"Invalid str.  Foo is missing BAR or xx","code":"$_='FOO bar'; print \"Invalid str.  Foo is missing BAR or xx\"  if $_ =~ /FOO\\s*?(?!(BAR|xx))/i;\n"},{"err":"","out":"","code":"$_='FOObar'; print \"Invalid str.  Foo is missing BAR or xx\"  if $_ =~ /FOO(?!\\s*(BAR|xx))/i;\n"},{"out":"[\"quux\",\"quux\"]","err":"","code":"%foo = (bar => 'quux'); sub foo { +{%foo} } [ foo->{bar}, $foo{bar} ] #huf, you're wrong, foo->{bar} is $foo{bar} :P\n"},{"code":"['foobarrrrsplot' =~ /foo(bar+)splot/\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","err":""},{"err":"","out":"[\"barrrr\"]","code":"['foobarrrrsplot' =~ /foo(bar+)splot/]\n"},{"code":"['foobarrrrsplot foobarsplot' =~ /foo(bar+)splot/g]\n","out":"[\"barrrr\",\"bar\"]","err":""},{"err":"","out":"[\"barrrr\"]","code":"['foobarrrrsplot' =~ /foo(bar+)splot/g]\n"},{"code":"$foo = { bar => \"stuff\" };  $foo->{bar}->{gravy}\n","err":"","out":""},{"code":"foo 'bar'; sub foo { 1; } # you mean you want to catch things like this?\n","out":"ERROR: syntax error at (eval 558) line 1, near \"foo 'bar'\"\n","err":""},{"code":"$_ = \"Foo & Bar\"; s{(\\W)}{ sprintf rand() < 0.5 ? \"&#%d;\" : \"%%%02X\", ord $1 }ge; $_\n","out":"Foo&#32;&#38;%20Bar","err":""},{"code":"\"foo\" . \"bar\" . \"yin\" . \"yang\"\n","out":"foobaryinyang","err":""},{"out":"FOObat","err":"","code":"$_='FOObat'; print if $_ !~ /FOO\\s*?(BAR|xx)/i;\n"},{"code":"$foo = \"blah\"; ($bar = $foo) =~ s/bl/h/; [$bar]\n","err":"","out":"[\"hah\"]"},{"code":"$foo = \"blah\"; ($bar = $foo) =~ s/bl/h/r; [$bar]\n","err":"","out":"[\"blah\"]"},{"code":"[ 'fooblahblahbarfoobazbar' =~ /foo((?:(?!bar).)*)bar/ ]\n","err":"","out":"[\"blahblah\"]"},{"code":"$foo = \"blah episode9 blah\"; $foo =~ s/episode([0-9])/e($1-1)/e; $foo\n","err":"","out":"ERROR: Undefined subroutine &main::e called at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"$foo = \"blah episode9 blah\"; $foo =~ s/episode([0-9])/'e'($-1)/e; $foo\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"'e'(\"\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"$-1\"\n","err":"","code":"$foo = \"blah episode9 blah\"; $foo =~ s/episode([0-9])/e($-1)/e; $foo\n"},{"code":"$foo = \"blah episode9 blah\"; $foo =~ s/episode([0-9])/e$1/; $foo\n","err":"","out":"blah e9 blah"},{"code":"$foo = 'b(o+g[o|n(s';  [ $foo =~ /\\Q$foo\\E/, \"\\Q$foo\" ]\n","err":"","out":"[1,\"b\\\\(o\\\\+g\\\\[o\\\\|n\\\\(s\"]"},{"out":"","err":"","code":"'foo' eq 'bar'\n"},{"err":"","out":"1","code":"\"{{foo\" =~ /{{f/\n"},{"err":"","out":"1","code":"\"foo\" =~ /foo/\n"},{"code":"[ \"foo\" =~ /foo(.*)(.*?)/ ]\n","out":"[\"\",\"\"]","err":""},{"err":"","out":"","code":"%foo{'foo'};\n"},{"code":"[ \"foo\" =~ /foo(.*)(bar|)/ ]\n","err":"","out":"[\"\",\"\"]"},{"out":"[]","err":"","code":"[ \"foo\" =~ /foo(.*)(bar)/ ]\n"},{"code":"[ \"foo\" =~ /foo(bar)(baz)/ ]\n","out":"[]","err":""},{"code":"($foo) = \"foo/bar-baz&stuff/51\" =~ /(\\d+)$/;  $foo\n","err":"","out":"51"},{"code":"[ \"foo foobar foobaz rarafoo gerzson\" =~ /\\w*o\\b/g ]\n","out":"[\"foo\",\"rarafoo\"]","err":""},{"err":"","out":"[\"foo \",\"rarafoo \"]","code":"[ \"foo foobar foobaz rarafoo gerzson\" =~ /\\w*o\\W/g ]\n"},{"out":"[\"foo\",\"rarafoo\"]","err":"","code":"[ \"foo foobar foobaz rarafoo\" =~ /\\w*foo\\b/g ]\n"},{"err":"","out":"[\"foo\",\"foo\",\"foo\",\"rarafoo\"]","code":"[ \"foo foobar foobaz rarafoo\" =~ /\\w*foo/g ]\n"},{"code":"[ \"foo foobar foobaz rarafoo\" =~ /\\w*foo$/g ]\n","err":"","out":"[\"rarafoo\"]"},{"err":"","out":"[\"hallo\"]","code":"$foo[\"foo\"] = \"hallo\"; \\@foo\n"},{"err":"","out":"foo!","code":"$foo = {};  \"foo!\" if $foo;\n"},{"out":"bar","err":"","code":"'foo' =~ /.+/; 'foo' =~ s//bar/r; # yup\n"},{"out":"\u0000\u0000\u001f","err":"","code":"'foo' ^ 'fop'\n"},{"code":"[ 'foo' ^ 'fop' ]\n","err":"","out":"[\"\\0\\0\\37\"]"},{"err":"","out":"k","code":"FOO: for (0 .. 9) { last FOO; } FOO: while () { last FOO; } \"k\"\n"},{"out":"[\"o\",\"lo\",\"llo\",\"ello\",\"hello\"]","err":"","code":"$foo = 'hello'; push @bar, substr($foo, -$_) for 1 .. length $foo; \\@bar\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"foo \"HERE\"\"\n","code":"foo \"HERE\"\n"},{"code":"foo \"hi\\n\"; sub foo { print \"moo\\n\"; }\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"foo \"hi\\n\"\"\n"},{"code":"\\ @Foo::ISA\n","out":"[]","err":""},{"code":"@$foo{key} # except it isn't\n","out":"","err":""},{"out":"ERROR: Reference to nonexistent group in regex; marked by <-- HERE in m/\\1 <-- HERE / at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"\"foo\" =~ m/\\1/\n"},{"code":"\"foo\" =~ m/f/ and print \"yay\"\n","out":"yay","err":""},{"out":"foo","err":"","code":"$_ = 'foo'; my $a = 5; 1 for $a; $_\n"},{"err":"","out":"bar","code":"$_ = 'foo'; { my $_ = 'bar'; print $_; }\n"},{"out":"foo","err":"","code":"$_ = 'foo'; { my $_; print $main::_; }\n"},{"code":"$foo = 'name'; \"define('DB_NAME', 'l33t7ex7');\" =~ /^define\\('DB_\\U$foo\\E', '(.*)'\\);$/\n","err":"","out":"1"},{"err":"","out":"yes","code":"\"foo\\nbar\" =~ m/[\\n]/ and \"yes\"\n"},{"out":"[\"oo\\nar\\naz\"]","err":"","code":"[ \"foo\\nbar\\nbaz\" =~ s/^.//mgr ]\n"},{"err":"","out":"matches","code":"\"foo\\nbar\" =~ /o\\nb/ ? \"matches\" : \"doesn't match\"\n"},{"code":"$_=\"foo\\nbar\"; s/.+//; $_\n","out":"\nbar","err":""},{"out":"","err":"","code":"\"foo\\nbar\" ~~ s/\\n/<br>/gr\n"},{"code":"\"foo\\nbar\" =~ s/\\n/<br>/gr\n","out":"foo<br>bar","err":""},{"out":"foo<br>bar","err":"","code":"\"foo\\nbar\" =~ s/\\n/<br\\>/gr\n"},{"code":"\"foo\" ne \"bar\"\n","out":"1","err":""},{"err":"","out":"[\"nomatch\"]","code":"[ 'foo nobang' =~ /foo\\s+(?:bar\\s+)?bang/ ? 'match' : 'nomatch' ]\n"},{"err":"","out":"[\"foo\\n\",\"#one\\n #two \\n#three\\n\",\"ERROR\",\"four\\n\"]","code":"$_ = \"foo\\n#one\\n #two \\n#three\\n##bar\\nfour\\n\"; @parse = (); push @parse, $1 =~ /##/ ? \"ERROR\" : $1 while s/^((?:\\s*#(?!#).*\\n)+|.*\\n)//; \\@parse\n"},{"code":"[ \"foo\" =~ /o{2}/, \"foo\" =~ /\\Qo{2}/ ]\n","err":"","out":"[1]"},{"code":"$foo = 'origin/beans-and-cornbread'; substr($foo, 7)\n","err":"","out":"beans-and-cornbread"},{"code":"$_='FOO'; print if !~ /(BAR|xx)/;\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"if !~\"\n"},{"err":"","out":"FOO","code":"$_='FOO'; print if $_ !~ /(BAR|xx)/;\n"},{"err":"","out":"nothing found","code":"$foo = ''; print \"nothing found\" unless length $foo;\n"},{"err":"","out":"[1]","code":"$foo = q{$$}; [ '$$' =~ /\\Q$foo/ ]\n"},{"err":"","out":"[\"a\",\"b\",\"i\",\"d\",\"e\"]","code":"@foo = qw/a b c d e/; $x = \\$foo[2];  $$x = 'i';  [ @foo ]\n"},{"code":"@foo = qw/a b c d/; [ $#foo ]\n","out":"[3]","err":""},{"err":"","out":"[2]","code":"@foo = qw( a b c ); [$#foo]\n"},{"code":"@foo = qw( foo bar baz biz fuzz buzz wowzers ); [ @foo[ int rand @foo, -1 ] ]\n","out":"[\"baz\",\"wowzers\"]","err":""},{"code":"\"foo\\r\\n\\tbar\\n\"\n","err":"","out":"foo\r\n\tbar\n"},{"err":"","out":"9\n","code":"*foo{SCALAR}->$* = 2; my $bar; $$bar = 3; say $bar->$****foo{SCALAR}->$*;\n"},{"code":"[ (foo => scalar('bar', baz => scalar('quux', flurb => scalar('flarb')))) ]\n","err":"","out":"[\"foo\",\"flarb\"]"},{"err":"","out":"[\"foo\",\"bar\",\"baz\",\"quux\",\"flurb\",\"flarb\"]","code":"[ (foo =>scalar 'bar', baz =>scalar 'quux', flurb =>scalar 'flarb') ]\n"},{"err":"","out":"[\"bar\",\"fxx\"]","code":"[ 'foo' =~ s/foo/bar/r, 'foo' =~ tr/o/x/r ]\n"},{"err":"","out":"^{MATCH}bar","code":"\"foo\" =~ s/foo/^{MATCH}bar/pr;\n"},{"out":"bar","err":"","code":"\"foo\" =~ s/foo/$^{MATCH}bar/pr;\n"},{"code":"\"foo\" =~ s/foo/${^MATCH}bar/pr;\n","out":"foobar","err":""},{"code":"$foo = [$]]; shift $foo\n","out":"5.022001","err":""},{"out":"fee","err":"","code":"\"foo\" =~ s/o/e/gr\n"},{"code":"@foo = (\"%s %s\", 'foo', 'bar'); printf @foo;\n","out":"foo bar","err":""},{"err":"","out":"3","code":"@foo = (\"%s %s\", 'foo', 'bar'); sprintf @foo;\n"},{"code":"[ {foo => sub {1}} ]\n","err":"","out":"[{foo => sub { \"DUMMY\" }}]"},{"code":"\"Foo\"->${\\sub { \"hello\" } };\n","err":"","out":"hello"},{"err":"","out":"foo.{0}.*","code":"'foo*' =~ s{([*?]+)|(\\W)}{ $2 ? \"\\\\$2\" : '.{' . $1 =~ tr/?// . '}' . '.*' x (index($1, '*') >= 0) }egr\n"},{"code":"'foo*' =~ s{([*?]+)|(\\W)}{ $2 ? \"\\\\$2\" : '.' x $1 =~ tr/?// . '.*' x (index($1, '*') >= 0) }egr\n","out":"foo.*","err":""},{"err":"","out":"[\"foo\",\"bar\",\"baz\"]","code":"[ \" foo\\tbar  baz \" =~ /\\S+/g ]\n"},{"code":"$foo = 'this/that' =~ s/th//r; $foo\n","out":"is/that","err":""},{"code":"$_=\"foo\"; tr alaLa; print $_\n","out":"foo","err":""},{"out":"defined\n","err":"","code":"%foo = (undef, undef); say \"defined\" if (grep { defined } keys %foo);\n"},{"code":"$_='FOO v'; print if $_ !~ /FOO\\s*?(BAR|xx)/i;\n","err":"","out":"FOO v"},{"out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/FOO( <-- HERE ?!\\s*(BAR|xx)/ at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$_='FOO v'; print \"Invalid str.  Foo is missing BAR or xx\"  if $_ =~ /FOO(?!\\s*(BAR|xx)/i;\n"},{"out":"Invalid str.  Foo is missing BAR or xx","err":"","code":"$_='FOO v'; print \"Invalid str.  Foo is missing BAR or xx\"  if $_ =~ /FOO(?!\\s*(BAR|xx))/i;\n"},{"err":"","out":"ERROR: Group name must start with a non-digit word character in regex; marked by <-- HERE in m/(?<< <-- HERE <<!>&)#(\\w+)/ at (eval 558) line 1, <STDIN> line 1.\n","code":"\"foo\" =~ /(?<<<<!>&)#(\\w+)/\n"},{"code":"[ \"(foo)\" =~ /\\w+/g ]\n","out":"[\"foo\"]","err":""},{"code":"${\\*foo}->(\"why hello\")\n","err":"","out":"ERROR: Undefined subroutine &main::foo called at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"$foo","code":"$foo=\"wibble\"; q\"$foo\"\n"},{"out":"","err":"","code":"'foo' xor 'fop'\n"},{"err":"","out":"Invalid str.  Foo is missing BAR or xx","code":"$_='FOO x'; print \"Invalid str.  Foo is missing BAR or xx\"  if $_ =~ /FOO(?!\\s*(BAR|xx))/i;\n"},{"err":"","out":"ERROR: Can't modify reference to array dereference in loop entry at (eval 558) line 1, at EOF\n","code":"for \\@{[]} (()) {}\n"},{"err":"","out":"012345678910","code":"for ( 0 .. 10 ) { print; } print $_;\n"},{"err":"","out":"\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ÃÂ","code":"for (\"1\"..\"128\"){ print chr \"$_\" };\n"},{"code":"[ for (1..20){if (/^5$/ .. /^18$/){print $_;} ]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"[ for \"\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","err":""},{"code":"[ for (1..20){if (/^5$/ .. /^18$/){print $_;}} ]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"[ for \"\n"},{"out":"ERROR: Missing right curly or square bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, at EOF\n","err":"","code":"for (1..20){if (/^5$/ .. /^18$/){print $_;}\n"},{"code":"for (1..20){if (/^5$/ .. /^18$/){print $_;}}\n","out":"56789101112131415161718","err":""},{"err":"","out":"[123, ,5, ,12, ,7, ]","code":"for (\"123 5 12 7 \") { my $re = qr/(\\d+)(\\s+)/; if(/^(?:$re)+$/) { my @result = /$re/g; print \"[\" . join(\",\", @result) . \"]\" } else { print \"no match\" } } # maybe not necessarily like this, but something along these lines\n"},{"err":"","out":"ARRAY(0x4a0a950) ARRAY(0x49fe310) ARRAY(0x49fe2b0)","code":"for (1 .. 3) { my @bar; push @foo, \\@bar } \"@foo\"\n"},{"out":"234","err":"","code":"for(1..3) { print $_+1 }\n"},{"code":"for (1..5) { print; print and last if 0 }\n","err":"","out":"12345"},{"err":"","out":"ERROR: Unimplemented at (eval 558) line 1, <STDIN> line 1.\n","code":"... for \"A\" ... \"Z\"\n"},{"err":"","out":"","code":"foreach (1..4) { do { next }; print \"$_\\n\"}\n"},{"out":"[0,2,4]","err":"","code":"foreach ($i = 0; $i < 3; $i++) { push @foo, $i*2 }  \\@foo\n"},{"code":"foreach my $val (qw/entity baz /) {print +(grep /$val/,( \"foo\", \"bar\", \"foo entity bar quux\", \"foo bar\")) ? \"$val found\" : \"$val not found\" };\n","err":"","out":"entity foundbaz not found"},{"code":"foreach my $var ( 1..5 ){ print \"$var,\" }\n","out":"1,2,3,4,5,","err":""},{"code":"for ('foo', 'bar') { s/oo/ar/g } # sirkha, like this\n","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"1234512345","err":"","code":"for ( grep { print $_; 1 } 1 .. 5 ) { print $_ }\n"},{"out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"for (\"hello\") { $_ = 42 }\n"},{"err":"","out":"","code":"fork\n"},{"code":"\"fork-fork\" =~ /-/ and [eval '$`..$\\'']\n","out":"[\"fork\"]","err":""},{"code":"fork; print $!;\n","out":"Resource temporarily unavailable","err":""},{"code":"fork => until 0 => $$\n","out":"587","err":""},{"code":"fork until 0\n","err":"","out":""},{"err":"","out":"d","code":"fork => until 0 => $$, \"\\d\"\n"},{"code":"fork while fork\n","out":"","err":""},{"code":"fork while fork;\n","err":"","out":""},{"code":"fork while fork'\n","err":"","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"for (map $_, 'hello') { $_ = 42 }\n","out":"","err":""},{"code":"formatbw\\.css   # not valid\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"formatbw\\\"\n"},{"code":"for my $a(1 .. 100) { if ($a == 4) last; }\n","out":"ERROR: syntax error at (eval 558) line 1, near \") last\"\n","err":""},{"code":"for my $cat (1,2,3,4) { $cat++ }\n","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"1\n2\n","err":"","code":"for \\my %hash ({foo => 1}, {foo => 2}) { say $hash{foo}; }\n"},{"code":"for(my $i=0;$i<10;$i++) {print \"Don't spam, please!\"\\n\";}\n","err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"Don't spam, please!\nDon't spam, please!\nDon't spam, please!\nDon't spam, please!\nDon't spam, please!\nDon't spam, please!\nDon't spam, please!\nDon't spam, please!\nDon't spam, please!\nDon't spam, please!\n","code":"for(my $i=0;$i<10;$i++) {print \"Don't spam, please!\\n\";}\n"},{"out":"Hello #0 Hello #1 Hello #2 Hello #3 Hello #4 Hello #5 Hello #6 Hello #7 Hello #8 Hello #9 ","err":"","code":"for(my $i = 0; $i < 10; $i++) { print \"Hello #$i \"; }\n"},{"out":"Hello #0\nHello #1\nHello #2\nHello #3\nHello #4\nHello #5\nHello #6\nHello #7\nHello #8\nHello #9\n","err":"","code":"for(my $i = 0; $i < 10; $i++) { print \"Hello #$i\\n\"; }\n"},{"out":"","err":"","code":"for(my $i =0; $i <= $#$ref;$i++){ print @$ref[$i] , \"\\n\";}\n"},{"out":"100","err":"","code":"for my $i (1..100) {push @a, [(1) x 1024*1024]}; scalar @a\n"},{"code":"for my $i (1 .. 10) { print \"Hello #$i \"; }\n","err":"","out":"Hello #1 Hello #2 Hello #3 Hello #4 Hello #5 Hello #6 Hello #7 Hello #8 Hello #9 Hello #10 "},{"code":"for my $i (1..30) {push @a, [(1) x 1024*1024]}; scalar @a\n","out":"30","err":""},{"err":"","out":"bca","code":"for my $k (keys %{{a=>1, b=>2, c=>3}}) { print $k } # works fine with hashes only known by reference too\n"},{"out":"12345678910","err":"","code":"for my $x ( 1..10 ) { print $x }\n"},{"code":"for my $x ( 1..10 ) { say $x }\n","out":"1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n","err":""},{"err":"","out":"1\n2\n4\n8\n","code":"for (my $x = 1; $x < 10; $x += my $y) { $y=$x; say $x}\n"},{"err":"","out":"1\n2\n4\n8\nSCALAR(0x51e8ba8) SCALAR(0x55e7a80) SCALAR(0x55e7a08) SCALAR(0x55e79c0)\n","code":"for (my $x = 1; $x < 10; $x += my $y) { $y=$x; say $x; push @wtf, \\$y; } say \"@wtf\"\n"},{"err":"","out":"A B. A B. ","code":"for (my ($x, $y) = (\"A\", \"B\")) { print \"$x $y. \"; }\n"},{"code":"for (my ($x, $y) = (\"A\", \"B\")) { print \"$x $y (current value: $_). \"; }\n","err":"","out":"A B (current value: A). A B (current value: B). "},{"code":"for (()) { next }\n","err":"","out":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"$_ qw(foo bar baz)\"\n","code":"for $_ qw(foo bar baz) { print }\n"},{"code":"for ([qw/foo bar/]->${\\\\&CORE::values}) { print }\n","err":"","out":"ERROR: &CORE::values cannot be called directly at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: Undefined subroutine &main::values called at (eval 558) line 1, <STDIN> line 1.\n","code":"for ([qw/foo bar/]->${\\\\&values}) { print }\n"},{"code":"for (while 1) {}\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"(while\"\n"},{"out":"1","err":"","code":"'á¸' =~ /\\P{UpperCase}/\n"},{"err":"","out":"{fraction => \"1111111111111111111111111111111111111111011111111100\",sign => 1,exponent => \"01111011111\"}","code":"@f{qw/sign exponent fraction/} = (unpack \"b*\",(pack \"d\", 0.9999999999999926)) =~ /^(\\d)(\\d{11,11})(\\d+)$/; \\%f\n"},{"out":"23","err":"","code":"*f = sub { 23 }; no strict; &{'f'}()\n"},{"code":"\"ft\\n\" =~ m/ft$/ ? 't' : 'f'\n","out":"t","err":""},{"out":"123","err":"","code":"*fuck = sub { 123 }; fuck()\n"},{"out":"1","err":"","code":"\"FÂ­uÂ­dge\" =~ /\\N{SOFT HYPHEN}/;\n"},{"code":"Function::Parameters->VERSION\n","out":"1.0704","err":""},{"out":"1","err":"","code":"\"gammadelta\" =~ /alfa(bravo)|(gamma)delta/\n"},{"out":"","err":"","code":"getlogin()\n"},{"code":"[glob(\"../*\")]\n","out":"[]","err":""},{"code":"(glob '*')[0]\n","out":"","err":""},{"out":"[[]]","err":"","code":"[[ ((glob(\"*.*\"))[0]) ]]\n"},{"out":"[1234,1235,1236,1237]","err":"","code":"[ glob \"123{4,5,6,7}\" ]\n"},{"code":"[ glob(\"{1,2,3,4,5,6,7,8,9,10}{11,12,13,14,15,16,17,17,18,19,20}\") ]\n","out":"[111,112,113,114,115,116,117,117,118,119,120,211,212,213,214,215,216,217,217,218,219,220,311,312,313,314,315,316,317,317,318,319,320,411,412,413,414,415,416,417,417,418,419,420,511,512,513,514,515,516,517,517,518,519,520,611,612,613,614,615,616,617,617,618,619,620,711,712,713,714,715,716,717,717,718,719,720,811,812,813,814,815,816,817,817,818,819,820,911,912,913,914,915,916,917,917,918,919,920,1011,1012,1013,1014,1015,1016,1017,1017,1018,1019,1020]","err":""},{"code":"[ glob \"123[4 .. 7]\" ]\n","out":"[\"123[4\",\"..\",\"7]\"]","err":""},{"code":"[ glob \"123[4-7]\" ]\n","err":"","out":"[]"},{"code":"[ glob '\"{1,2}{ no split on space,d}\"' ]\n","out":"[\"1 no split on space\",\"1d\",\"2 no split on space\",\"2d\"]","err":""},{"code":"[glob \"[abc]\"]\n","out":"[]","err":""},{"code":"[glob \"{a,b,c}\"]\n","out":"[\"a\",\"b\",\"c\"]","err":""},{"err":"","out":"[\"abc\"]","code":"[glob \"abc\"]\n"},{"out":"[\"aa\",\"ab\",\"ba\",\"bb\"]","err":"","code":"[ glob '{a,b}' x 2 ]\n"},{"err":"","out":"[\"fooa\",\"foob\"]","code":"[glob \"foo{a,b}\"]\n"},{"code":"glob \"foo{a,b}\"\n","err":"","out":"fooa"},{"out":"[\"fooac\",\"fooad\",\"foobc\",\"foobd\"]","err":"","code":"[glob \"foo{a,b}{c,d}\"]\n"},{"code":"[ glob \"{${\\join ',', 'a' .. 'e'}}\" x 2 ]\n","out":"[\"aa\",\"ab\",\"ac\",\"ad\",\"ae\",\"ba\",\"bb\",\"bc\",\"bd\",\"be\",\"ca\",\"cb\",\"cc\",\"cd\",\"ce\",\"da\",\"db\",\"dc\",\"dd\",\"de\",\"ea\",\"eb\",\"ec\",\"ed\",\"ee\"]","err":""},{"out":"[]","err":"","code":"[ glob \"kjdasfkjdasfdas/*\" ]\n"},{"out":"Hello World","err":"","code":"*globlal = sub {\"Hello World\"}; globlal()\n"},{"out":"ERROR: Can't modify reference to ref-to-glob cast in scalar assignment at (eval 558) line 1, at EOF\n","err":"","code":"\\*globlal = sub {\"Hello World\"}; globlal()\n"},{"code":"[glob(\"/*\")] # nothing even in /?\n","err":"","out":"[]"},{"err":"","out":"[\"samuel road\",\"samuel street\",\"samuel alley\",\"sam road\",\"sam street\",\"sam alley\",\"s road\",\"s street\",\"s alley\"]","code":"[ glob '\"samuel road\"' =~ s/\\bsamuel\\b/{samuel,sam,s}/gr =~ s/\\broad\\b/{road,street,alley}/gr ]\n"},{"code":"[[ ((glob(\"*.txt\"))[0]) ]]\n","out":"[[]]","err":""},{"err":"","out":"[[]]","code":"[[ ((glob(\"*.txt\"))[0..3]) ]]\n"},{"code":"[glob \".[Zz][Ii][Pp]\"]\n","err":"","out":"[]"},{"err":"","out":"[\"HASH(0x5f12248)\"]","code":"[glob {\".[Zz][Ii][Pp]\"}]\n"},{"code":"[ \"GMT\" =~ /(?:[PMCE][SD]T|UTC)/ ? 'match' : 'nomatch' ]\n","err":"","out":"[\"nomatch\"]"},{"code":"~(\"Goat\" & \" \") ^ \"oatgma\"\n","out":"ÃÂatgma","err":""},{"code":"\"Goat\" & \" \" | \"oatgma\"\n","err":"","out":"oatgma"},{"err":"","out":"1","code":"\"Good morning! Sabah el kheer   ØµØ¨Ø§Ø­ Ø§ÙØ®ÙØ±\" =~  m{[^\\x00-\\x7f]}\n"},{"code":"goto LABEL; [do { ; LABEL: 42 }];\n","err":"","out":"[42]"},{"code":"goto LABEL; [do { ; LABEL: print 'wut' }];\n","err":"","out":"wut"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"} 1\"\n","err":"","code":"goto LABEL; [do { ; LABEL: print 'wut' } 1];\n"},{"err":"","out":"wutERROR: Segmentation Fault\n","code":"goto LABEL; [grep { ; LABEL: print 'wut' } 1];\n"},{"out":"wutERROR: Bizarre copy of HASH in freed op at /home/ryan/bots/perlbuut/lib/eval.pl line 301, <STDIN> line 1.\n","err":"","code":"goto LABEL; [map { ; LABEL: print 'wut' } 1];\n"},{"code":"[ grep /.../ ]\n","out":"[]","err":""},{"code":"[ grep $_, \"0 and false\" , 1 , \"false\", 0 ]\n","out":"[\"0 and false\",1,\"false\"]","err":""},{"code":"[ grep 1 ]\n","err":"","out":"[]"},{"err":"","out":"[0,1,2,4,8,16,32,64,128,256,512,1024]","code":"[grep { !($_ & ($_-1)) } 0 .. 1024]\n"},{"code":"[ grep !/(.).*\\1/, glob '{a,b,c,d}' x 4 ]\n","err":"","out":"[\"abcd\",\"abdc\",\"acbd\",\"acdb\",\"adbc\",\"adcb\",\"bacd\",\"badc\",\"bcad\",\"bcda\",\"bdac\",\"bdca\",\"cabd\",\"cadb\",\"cbad\",\"cbda\",\"cdab\",\"cdba\",\"dabc\",\"dacb\",\"dbac\",\"dbca\",\"dcab\",\"dcba\"]"},{"err":"","out":"[1,3,5,7,9,11,13,15,17,19]","code":"[ grep $_ % 2, 1 .. 20 ]\n"},{"code":"[ grep { $_-=2 } 1,2,3,4,5 ]\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"[-1,1,2,3]","err":"","code":"[ grep { $_-=2 } 1..5 ]\n"},{"code":"[ grep { $_+=2 } 1..5 ]\n","err":"","out":"[3,4,5,6,7]"},{"code":"[ grep { $_-=2 } 1..5 ]  # where's my error\n","out":"[-1,1,2,3]","err":""},{"out":"[5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]","err":"","code":"[ grep { ($_ >= 5) .. ($_ <= 18) } (1..20) ]\n"},{"out":"[5,6,7,8,9,10,11,12,13,14,15,16,17,18]","err":"","code":"[grep $_ == 5 .. $_ == 18, 1 ..20]\n"},{"out":"[5,4,3,2,1]","err":"","code":"[grep $_ == 5 .. $_ == 18, reverse 1 ..20]\n"},{"code":"[ grep { /a/ and /b/ } qw/abc cat bat/ ]\n","out":"[\"abc\",\"bat\"]","err":""},{"err":"","out":"[\"banana\"]","code":"[ grep /(a.a)/, qw(apple pear banana) ]\n"},{"err":"","out":"[\"abc\",\"bat\"]","code":"[ grep { /a/ && /b/ } qw/abc cat bat/ ]\n"},{"code":"[grep { $_ =~ /\\Afoobar.(?:true|false|yes|no)\\z/ms } (\"foobar=true\", \"foobar.yes\", \"foobar|no\", \"foobar.lambda\",)];\n","err":"","out":"[\"foobar=true\",\"foobar.yes\",\"foobar|no\"]"},{"code":"grep { $_ =~ /\\Afoobar.(?:true|false|yes|no)\\z/ms } (\"foobar=true\", \"foobar.yes\", \"foobar|no\", \"foobar.lambda\",);\n","out":"3","err":""},{"out":"[\"axxxyyyb\"]","err":"","code":"[ grep /a(x{0,3})(??{'y' x length $1})b/, qw( axxxyyb axxxyyyb axxxyyyyb ) ]  # Su-Shee\n"},{"out":"[\"foo.bar\",\"foo\"]","err":"","code":"[ grep /^[a-z0-9]*[a-z](\\.[a-z0-9]*[a-z])*\\z/, qw( foo.bar foo foo..bar foo0.bar foo.bar. ) ]\n"},{"code":"[grep \"cats\", qw(dogs badgers monkeys)]\n","err":"","out":"[\"dogs\",\"badgers\",\"monkeys\"]"},{"code":"grep chr() =~ /[[:space:]]/, 0 .. 0x10_ffff\n","err":"","out":"25"},{"out":"[\"a test\",\"a problem\"]","err":"","code":"[grep defined, \"this is (a test,a problem)\" =~ /.*\\(|\\).*|([^,()]+)/g ]\n"},{"code":"!grep($_ eq 'bbb', qw(aaa bbb ccc)) ? 'not present' : 'present'\n","out":"present","err":""},{"code":"!grep($_ eq 'xxx', qw(aaa bbb ccc)) ? 'not present' : 'present'\n","err":"","out":"not present"},{"err":"","out":"[\"foo\",\"foosomeba\"]","code":"[ grep /foo(?!.*bar)/, qw( foo bar foobar fooooooobar  foosomebar foosomeba ) ]\n"},{"code":"[ grep /^([^()]+|\\([^()]*\\))*$/g, \"foo\", \"foo (bar)\", \"(bar) foo\", \"foo (bar) baz\", \"foo (bar\" ]\n","out":"[\"foo\",\"foo (bar)\",\"(bar) foo\",\"foo (bar) baz\"]","err":""},{"code":"grep $_ .= '-haha', map $_, qw(a b c d e)\n","err":"","out":"5"},{"code":"grep $_ .= '-haha', qw(a b c d e)\n","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"[\"h\"]","code":"[ grep /h/, map chr, (0..0x3000) ]\n"},{"code":"[grep -iP { $_ =~ /(?:foobar)(?:\\s.\\s|.)(?:true|false|yes|no) } (\"foobar=true\", \"foobar = true\", \"FOOBAR:no\", \"barfoo=yes\",)];\n","out":"ERROR: Search pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"[ grep /json/i, keys %INC ]\n","err":"","out":"[\"Cpanel/JSON/XS.pm\",\"JSON/MaybeXS.pm\",\"JSON.pm\",\"JSON/XS.pm\"]"},{"out":"[\"JSON/MaybeXS.pm\",\"Cpanel/JSON/XS.pm\",\"JSON/XS.pm\",\"JSON.pm\"]","err":"","code":"[grep /JSON/, keys %INC ]\n"},{"code":"[ grep { length * 2 < 4 } qw/a bcd efgh i j k/ ]\n","err":"","out":"[]"},{"code":"[ grep { length <= 3 } qw/a bcd efgh i j k/ ]\n","out":"ERROR: Unterminated <> operator at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"[\"bcd\",\"efgh\"]","code":"[ grep { length >= 3 } qw/a bcd efgh i j k/ ]\n"},{"code":"[ grep /[\\[\\]]/, map chr, 0..255 ]\n","out":"[\"[\",\"]\"]","err":""},{"err":"","out":"[\"http://40.media.tumblr.com/b3e62ef833996a4ffb544ed37300807d/tumblr_nlf8czGMpJ1s61cido1_500.jpg\",\"http://40.media.tumblr.com/c0e108161497f351e40db139289b3818/tumblr_nldblnzio71s61cido1_500.jpg\"]","code":"[ grep m|^http://(?!.*avatar)|, qw( http://assets.tumblr.com/images/default_avatar/octahedron_open_48.png http://assets.tumblr.com/images/default_avatar/cube_closed_48.png http://40.media.tumblr.com/b3e62ef833996a4ffb544ed37300807d/tumblr_nlf8czGMpJ1s61cido1_500.jpg http://40.media.tumblr.com/c0e108161497f351e40db139289b3818/tumblr_nldblnzio71s61cido1_500.jpg ) ]\n"},{"code":"grep { $_->{name}[0] eq $w } @list,\n","err":"","out":"0"},{"code":"grep { $_->{name}[0] eq $w }, @list\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"},\"\n"},{"code":"[ grep { not (1../3/) } (1..10) ]\n","out":"[]","err":""},{"out":"[\"help-comment\\@example.net\",\"help\\@example.net\"]","err":"","code":"[ grep { not (1 + index $_, 'approver') and m/help.*?\\@example.net/ } qw(help-approver@example.net help-comment@example.net help@example.net) ];\n"},{"code":"[ grep { not (do{1}../3/) } (1..10) ]\n","err":"","out":"[]"},{"out":"[\"m\",\"q\",\"s\",\"y\"]","err":"","code":"[ grep { not eval } a..z ]\n"},{"out":"ERROR: Modification of non-creatable array value attempted, subscript -1 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"grep $_, @order[-1]\n"},{"err":"","out":"[\"w\",\"th\",\"f\"]","code":"[ grep { scalar(/\\Aw\\z/../\\Af\\z/) } qw/m tu w th f sa su/ ]\n"},{"err":"","out":"[12,\"20.12\"]","code":"[ grep Scalar::Util::looks_like_number $_, split ' ', \"foo 12 bar lol super-yay 13_000 20.12 baz\" ]\n"},{"code":"[ grep Scalar::Util::looks_like_number $_, split ' ', \"foo 12 bar lol super-yay 13 baz\" ]\n","err":"","out":"[12,13]"},{"code":"[ grep /^scaleaddr(\\d)=([^\\d]*)/i, qw(blahj blah blah ScaleAddr5=abc) ];\n","err":"","out":"[\"ScaleAddr5=abc\"]"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"/^scaleaddr(\\d)/i qw/scaleaddr123/\"\n","err":"","code":"[ grep /^scaleaddr(\\d)/i qw/scaleaddr123/ ];\n"},{"out":"[\"\\t\",\"\\n\",\"\\13\",\"\\f\",\"\\r\",\" \",\"\\205\",\"\\240\"]","err":"","code":"[ grep /\\s/,map chr,  0..255 ]\n"},{"err":"","out":"[\"frog\",\"\\\"jumping\",\"jack\\\"\",\"book\",\"bob\\\"\",\"elephant\"]","code":"[  grep { $_ !~ /:/ } split('\\s+', 'frog abd:def \"jumping jack\" 123:456 book jimbo:\"billy bob\" elephant') ]\n"},{"err":"","out":"6","code":"grep { $_ !~ /:/ } split('\\s+', 'frog abd:def \"jumping jack\" 123:456 book jimbo:\"billy bob\" elephant');\n"},{"code":"grep s/\\.pm\\z//, keys %INC\n","err":"","out":"484"},{"code":"[ grep tr/()//cdr!~/^\\)|\\($|\\(\\(|\\)\\)/, \"foo\", \"foo (bar)\", \"(bar) foo\", \"foo (bar) baz\", \"foo (bar\" ]\n","err":"","out":"[\"foo\",\"foo (bar)\",\"(bar) foo\",\"foo (bar) baz\"]"},{"code":"[ grep tr/()//cdr=~/^(\\(\\))*$/g, \"foo\", \"foo (bar)\", \"(bar) foo\", \"foo (bar) baz\", \"foo (bar\" ]\n","out":"[\"foo\",\"foo (bar)\",\"(bar) foo\",\"foo (bar) baz\"]","err":""},{"code":"[ grep /^uni/, keys %INC ]\n","out":"[\"unicore/lib/Perl/_PerlIDS.pl\",\"unicore/lib/Perl/_PerlIDC.pl\",\"unicore/To/Cf.pl\",\"unicore/Heavy.pl\",\"unicore/lib/Perl/_PerlCh2.pl\",\"unicore/lib/Perl/Print.pl\",\"unicore/lib/Perl/_PerlCha.pl\",\"unicore/Name.pm\",\"unicore/Name.pl\",\"unicore/To/Uc.pl\"]","err":""},{"code":"[ grep /^\\w{3,10}\\z/, qw( one jdhfkjhfkjhdlkfjgh qwe.ert abcdefghij  no abcdefghijk ) ]\n","err":"","out":"[\"one\",\"abcdefghij\"]"},{"out":"no such thing","err":"","code":"Grinnz->can('import') ? \"has import kthx\" : \"no such thing\"\n"},{"code":"Grinnz->import()\n","out":"","err":""},{"err":"","out":"k","code":"\"guess\\nwhat\" =~ /\\Aguess$/m ? \"k\" : \"wtf\"\n"},{"code":"%h = ( 1=>1, 1=>0, 0=>1, 0=>0 ); [ map { !$_ || $h{$_} ? 'T' : 'F' } keys %h ]\n","out":"[\"F\",\"T\"]","err":""},{"code":"%h = ( 1=>1, 1=>0, 0=>1, 0=>0 ); map { !$_ || $h{$_} ? 'T' : 'F' } keys %h\n","err":"","out":"2"},{"err":"","out":"[\"T\"]","code":"@h = ( 1=>1, 1=>0, 0=>1, 0=>0 ); [ map { ! $_ || shift @h ? 'T' : 'F' } shift @h ]\n"},{"out":"[\"T\"]","err":"","code":"@h = ( 1, 1, 1, 0, 0, 1, 0, 0 ); [ map { ! $_ || shift @h ? 'T' : 'F' } shift @h ]\n"},{"code":"%h = (12 => 'hip', 0x12 => 'hop'); \\%h\n","out":"{18 => \"hop\",12 => \"hip\"}","err":""},{"out":"4","err":"","code":"%h = 1..6; {%h{1,3}}\n"},{"code":"%h = 1..6; +{%h{1,3}}\n","err":"","out":"{3 => 4,1 => 2}"},{"code":"%h = 1..6; +{%h{1,3,5}} # boo\n","err":"","out":"{5 => 6,1 => 2,3 => 4}"},{"out":"{1 => 2,7 => undef,3 => 4}","err":"","code":"%h = 1..6; +{%h{1,3,7}} # boo\n"},{"err":"","out":"[{},{},{}]","code":"[\\(%h1, %h2, %h3)]\n"},{"out":"key: 2 val: twokey: 1 val: one","err":"","code":"%h = ( 1=>\"one\", 2=>\"two\" ); map { print \"key: $_ val: $h{$_}\" } keys %h\n"},{"code":"$h = { 25 => 1 }; my $idx = \"25 \"; [ $h->{$idx}, $h->{0+$idx} ]\n","out":"[undef,1]","err":""},{"out":"[1,1]","err":"","code":"$h = { 25 => 1 }; my $idx = \"25\"; [ $h->{$idx}, $h->{0+$idx} ]\n"},{"code":"$^H=256;join(($x)x101)\n","err":"","out":""},{"err":"","out":"","code":"$^H=256;join($x)x101\n"},{"code":"%h=( 'a'=>'1', 'b'=>'2' ); %h=( 'c'=>'3', 'd'=>'4' ); for ( sort keys %h ){ print \"$_ $h{$_\" };\n","out":"ERROR: Missing right curly or square bracket at (eval 558) line 1, within string\nsyntax error at (eval 558) line 1, at EOF\n","err":""},{"code":"%h=( 'a'=>'1', 'b'=>'2' ); %h=( 'c'=>'3', 'd'=>'4' ); for ( sort keys %h ){ print \"$_ $h{$_}\" };\n","out":"c 3d 4","err":""},{"out":"1/8","err":"","code":"%h = (a => 1); scalar %h\n"},{"err":"","out":"{c => 4,b => 3,a => 2}","code":"@h{'a' .. 'c'} = 1 .. 3; ++$_ for values %h; \\ %h;\n"},{"out":"halal","err":"","code":"halal\n"},{"out":"","err":"","code":"`halt`;\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"; $j \"\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","code":"$h = {'a' => {'one' => 1}, \"b\" => 2}; $i = {'a' => {'two' => 2}; $j = {%$h, %$i}; print Dumper($j);\n"},{"code":"$h = {'a' => {'one' => 1}, \"b\" => 2}; $i = {'a' => {'two' => 2}}; $j = {%$h, %$i}; print Dumper($j);\n","out":"$VAR1 = {\n          'a' => {\n                   'two' => 2\n                 },\n          'b' => 2\n        };\n","err":""},{"code":"$h = {'a' => {'one' => 1}, \"b\" => 2}}; $i = {'a' => {'two' => 2}}; $j = {%$h, %$i}; print Dumper($j);\n","out":"ERROR: Unmatched right curly bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, near \"}}\"\n","err":""},{"err":"","out":"0","code":"%hash = 1..4; delete @hash{1,3}; scalar %hash\n"},{"err":"","out":"2/8","code":"%hash = 1..4; scalar %hash\n"},{"err":"","out":"{7 => 9,3 => 5,1 => 3,5 => 7}","code":"%hash = (1..8); $_++ for %hash; \\%hash\n"},{"code":"%hash = (1..8); %hashtwo = (a..j); $_++ for %hash, %hashtwo; [ \\%hash, \\%hashtwo ]\n","err":"","out":"[{5 => 7,7 => 9,3 => 5,1 => 3},{c => \"e\",i => \"k\",g => \"i\",e => \"g\",a => \"c\"}]"},{"code":"%hash1 = ( foo => 1, bar => 2 ); %hash2 = ( baz => undef, quux => \\%hash1 );  \\%hash2\n","err":"","out":"{baz => undef,quux => {foo => 1,bar => 2}}"},{"err":"","out":"{bar => 2,foo => 1}","code":"%hash1 = ( foo => 1, bar => 2 ); %hash2 = ( baz => undef, quux => \\%hash1 );  $hash2{quux}\n"},{"code":"%hash1 = ( foo => 1, bar => 2 ); %hash2 = ( baz => undef, quux => \\%hash1 );  $hash2{quux}{bar}\n","out":"2","err":""},{"err":"","out":"12","code":"%hash=(2=>\"two\", 1=>\"one\"); print sort { $a cmp $b } keys %hash\n"},{"code":"%hash=(2=>\"two\", 1=>\"one\"); print sort keys { $a cmp $b } keys %hash\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"} keys\"\n"},{"err":"","out":"[{of => \"stuff\",a => \"list\"},[\"a\",\"list\",\"of\",\"stuff\"]]","code":"%hash = @array = qw/a list of stuff/; [ \\%hash, \\@array ]   # you have arrayrefs though. see perldoc perlreftut\n"},{"code":"$hash = { a => 'z', b => { c => 'y' } }; if(ref $hash->{a} ne ;\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n"},{"err":"","out":"scalar","code":"$hash = { a => 'z', b => { c => 'y' } }; if(ref $hash->{a} ne 'ARRAY' && ref $hash->{a} ne 'HASH') { print 'scalar' };\n"},{"code":"$hash = { a => 'z', b => { c => 'y' } }; ref $hash->{b};\n","err":"","out":"HASH"},{"out":"{b => 1,a => 2,c => 2,e => 1,d => 1,f => 2}","err":"","code":"%hash = (); @hash{a..f} = (1)x7; $_++ for @hash{a,c,f}; \\%hash  # hehehe\n"},{"code":"$hash{'key1'} = \"val1\"; print ref %hash\n","out":"1","err":""},{"out":"1","err":"","code":"$hash{'key1'} = \"val1\"; print ref $hash{'key1'}\n"},{"code":"$hash{\"key1\"}=\"val2\"; $hash{\"key2\"}=\"val1\"; for ( sort { $hash{$a} cmp $hash{$b} } keys %hash ) { print \"key: $_: val: $hash{$_}, \"; };\n","out":"key: key2: val: val1, key: key1: val: val2, ","err":""},{"code":"$hash{\"key1\"}=\"val2\"; $hash{\"key2\"}=\"val1\"; for ( sort { $hash{$a} <=> $hash{$b} } keys %hash ) { print \"key: $_: val: $hash{$_}, \"; };\n","err":"","out":"key: key2: val: val1, key: key1: val: val2, "},{"code":"$hash{\"key1\"}=\"val2\"; $hash{\"key2\"}=\"val1\"; for ( sort { $hash{$b} cmp $hash{$a} } keys %hash ) { print \"key: $_: val: $hash{$_}, \"; };\n","err":"","out":"key: key1: val: val2, key: key2: val: val1, "},{"out":"key:key2: val:val1, key:key1: val:val2, ","err":"","code":"$hash{\"key1\"}=\"val2\"; $hash{\"key2\"}=\"val1\"; for ( sort { $hash{$b} <=> $hash{$a} } keys %hash ) { print \"key:$_: val:$hash{$_}, \"; };\n"},{"out":"[{1 => 12345678,1234567 => 123,1234 => 12345,12345 => 123456,123456789 => 1,12 => 12345},\"longest key is 9\"]","err":"","code":"%hash = map { join '', 1..1+ rand 9} 1..20; $long = ''; $long |= $_ for keys %hash; [ \\%hash, \"longest key is \" . length $long ]\n"},{"err":"","out":"{\"HASH(0x5cfd250)\" => undef}","code":"%hash={ 'stuff' => 'sterf' } ; \\%hash\n"},{"code":"$h->{bar} eq 'lol'; $h->{baz}->{whiz} eq 'lol'; $h\n","out":"{baz => {}}","err":""},{"err":"","out":"{baz => {whiz => \"lol\"}}","code":"$h->{bar} eq 'lol'; $h->{baz}->{whiz} = 'lol'; $h\n"},{"out":"[\"hello\",undef]","err":"","code":"[ \"hello\" =~ /^([a-z]+)(?:\\s+(.+))?$/ ]\n"},{"err":"","out":"[undef]","code":"$_ = \"hello\"; /e/c or die; [pos]\n"},{"err":"","out":"1","code":"\"hello it is now on 8:08\" =~ m{\\A .* on (.*) }xms;\n"},{"code":"(\"hello it is now on 8:08\" =~ m{\\A .* on (.*) }xms);\n","err":"","out":"1"},{"out":"[\" 8:08\"]","err":"","code":"[\"hello it is now on 8:08\" =~ m{\\A .* on (.*) }xms];\n"},{"out":"[\"hello\\n\",\"world\",\"\"]","err":"","code":"[ \"hello\\nworld\" =~ m/(.*(?:\\n|$))/g ]\n"},{"code":"[ \"hello\\nworld\" =~ /^.*\\n?/mg ]\n","out":"[\"hello\\n\",\"world\"]","err":""},{"code":"\"Hello\" =~ /^.*(.+)$(??{print\"$1\\n\"})/\n","err":"","out":"o\nlo\nllo\nello\nHello\n"},{"code":"\"Hello\" =~ /(?!^).*(.+)$(??{print\"$1\\n\"})/    # test\n","out":"o\nlo\nllo\nello\no\nlo\nllo\no\nlo\no\n","err":""},{"err":"","out":"[\"o\",\"lo\",\"llo\",\"ello\"]","code":"\"Hello\" =~ /(?!^).+(*PRUNE)(?{push @bar, $&})(*FAIL)/; [ reverse @bar ]\n"},{"code":"\"   hello\" =~ s/^\\s*//sr\n","err":"","out":"hello"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","err":"","code":"[ \"hello there\" =~ /^([a-z]+)(?:\\s+(.+))?$/\n"},{"err":"","out":"[\"hello\",\"there\"]","code":"[ \"hello there\" =~ /^([a-z]+)(?:\\s+(.+))?$/ ]\n"},{"out":"[\"hello\",\"there\"]","err":"","code":"[ \"hello there\" =~ /^([a-z]+)\\s*(|(?<=\\s).+)$/ ]\n"},{"out":"[]","err":"","code":"[ \"hello-there\" =~ /^([a-z]+)\\s*(|(?<=\\s).+)$/ ]\n"},{"out":"[\"hellothere\",\"\"]","err":"","code":"[ \"hellothere\" =~ /^([a-z]+)\\s*(|(?<=\\s).+)$/ ]\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","err":"","code":"[\"Hello\" =~ tr/l/g/r\n"},{"err":"","out":"[\"Heggo\"]","code":"[\"Hello\" =~ tr/l/g/r]\n"},{"out":"0","err":"","code":"{%{hello=>\"world\"}}\n"},{"out":"0","err":"","code":"%{%{{hello=>\"world\"}}}\n"},{"out":"0","err":"","code":"%{%{hello=>\"world\"}}\n"},{"code":"$_ = 'hello, world, foo bar baz';  [ map tr/ /-/r, split /,\\s*/ ]\n","err":"","out":"[\"hello\",\"world\",\"foo-bar-baz\"]"},{"out":"[\"hello\",\"world\",\"foo-bar-baz\"]","err":"","code":"$_ = 'hello, world, foo bar baz';  [ map tr/ /-/r, split /,\\s*/ ] # try three :)\n"},{"code":"[ \"Hello, world!\" =~ m/(....)/g ]\n","err":"","out":"[\"Hell\",\"o, w\",\"orld\"]"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":"","code":"[ \"Hello, world!\" =~ m/(....)/g; ]\n"},{"err":"","out":"[[\"h\",\"e\"],[\"l\",\"l\"],[\"o\",\" \"],[\"w\",\"o\"],[\"r\",\"l\"]]","code":"$_ = 'hello world'; push @ar, [$1,$2] while /(.)(.)/g; \\@ar\n"},{"code":"\"Hello, world\" =~ tr/A-Za-z/N-ZA-Mn-za-m/\n","out":"ERROR: Can't modify constant item in transliteration (tr///) at (eval 558) line 1, at EOF\n","err":""},{"code":"'help-approver@example.net' =~ /^(?!help-approver).+\\@example\\.net$/\n","err":"","out":""},{"code":"'help-approver@example.net' =~ /(?<!^help-approver)\\@example\\.net$/\n","out":"","err":""},{"code":"'help-approver@example.net' =~ /(?<!help-approver)\\@example\\.net$/\n","out":"","err":""},{"err":"","out":"1","code":"'help-approver@example.net' =~ /(?!<^help-approver)\\@example\\.net$/\n"},{"err":"","out":"1","code":"'help-approver@example.net' =~ /(?!<help-approver)\\@example\\.net$/\n"},{"code":"'help-approver@example.net' =~ /(?!help-approver).+\\@example\\.net/\n","err":"","out":"1"},{"code":"'help-comment@example.net' =~ /^(?!help-approver).+\\@example\\.net$/\n","err":"","out":"1"},{"err":"","out":"1","code":"'help@example.net' =~ /(?<!help-approver)\\@example\\.net$/\n"},{"err":"","out":"here","code":"here\n"},{"err":"","out":"{\"ARRAY(0x5c39360)\" => undef}","code":"+{[ here => \"are\", my => \"values\" ]}\n"},{"code":"HERE: { print 1; HERE: { print 2; HERE: { print 3; goto HERE } } }\n","err":"","out":""},{"code":"HERE: { print 1; HERE: { print 2; HERE: { print 3; goto HERE unless $i++ > 2 } } }\n","out":"123333","err":""},{"code":" ${{here,there}}{here};\n","out":"there","err":""},{"err":"","out":"sub { \"DUMMY\" }","code":"\\&hex\n"},{"code":"hex(\"000001448e317907\") / 1000\n","out":"1393955010.823","err":""},{"code":"hex '0a'\n","out":"10","err":""},{"code":"hex '0x0a'\n","err":"","out":"10"},{"err":"","out":"20","code":"hex \"0x14\"\n"},{"out":"ERROR: Undefined subroutine &main::hex called at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"\\&hex->(\"0x24\")\n"},{"out":"43981","err":"","code":"hex \"0xabcd\"\n"},{"code":"hex $1\n","out":"0","err":""},{"code":"hex \"1e0\"\n","out":"480","err":""},{"out":"65","err":"","code":"hex 41\n"},{"code":"hex \"4155\"\n","out":"16725","err":""},{"code":"$hex = '6060FF'; [ unpack q{L>*}, pack q{H*}, '0' x (-length($hex) % 8) . $hex ]\n","out":"[6316287]","err":""},{"err":"","out":"57005","code":"hex \"dead\"\n"},{"code":"hex 'f' x 16\n","out":"18446744073709551615","err":""},{"code":"hex q{112233445566778899}\n","err":"Integer overflow in hexadecimal number at (eval 551) line 5, <STDIN> line 1.\n","out":"3.16059037807746e+20"},{"code":"\"hey, this contains A-Z somewhere\" =~ /A-Z/ ? 'true' : 'false'\n","err":"","out":"true"},{"err":"","out":"1","code":"$^H{feature_state} = 1; sub foo { state $x; }\n"},{"code":"$h = { \"foo\" => 42 } ;  push @{$h->{foo}}, 17;  say $h->{foo};  # Really?\n","out":"42\n","err":""},{"code":"$h = {foo => 5, bar => 6, baz => 2}; [@{$h}{qw(foo bar baz)}] # is that what you mean?\n","err":"","out":"[5,6,2]"},{"code":"$h = {foo => 5, bar => 6}; [$h->{foo}]\n","err":"","out":"[5]"},{"out":"[5]","err":"","code":"$h = {foo => 5, bar => 6}; [@{$h}{qw/foo/}]\n"},{"code":"$H{'foobar'}++\n","out":"0","err":""},{"out":":[9] ","err":"","code":"@h{grep !/[a-zA-Z{}]/, split //, \"MPOPCNTSF: INTEGER[9]\"} = (); join '', keys %h\n"},{"code":"$h=\"hello world!\"; $h=~ s/(.){1}(.){1}/$2,$1/eg; print $h\n","err":"","out":"hlowrd"},{"err":"","out":"hlowrd","code":"$h=\"hello world!\"; $h=~ s/(.)(.)/$2,$1/eg; print $h\n"},{"err":"","out":"ifmmp!xpsme\"","code":"$h=\"hello world!\"; $h=~ s/(.)(.)/$cipher.=chr(ord($1)+1).chr(ord($2)+1);/eg; print $cipher\n"},{"err":"","out":"ififmmifmmp!ifmmp!xpifmmp!xpsmifmmp!xpsme\" == ifmmp!xpsme\"","code":"$h=\"hello world!\"; $h=~ s/(.)(.)/$cipher.=chr(ord($1)+1).chr(ord($2)+1);/eg; print \"$h == $cipher\"\n"},{"out":"ehll oowlr!d","err":"","code":"$h=\"hello world!\"; $h=~ s/(.)(.)/$h=\"$2$1\";/eg; print $h\n"},{"err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","code":"$h=\"hello world!\"; $h=~ s/(.)(.)/$h=$2++.$1++;/eg; print $h\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"1.$1\"\n","err":"","code":"$h=\"hello world!\"; $h=~ s/(.)(.)/$h=chr(ord($1)+1.$1++;/eg; print $h\n"},{"code":"$h=\"hello world!\"; $h=~ s/(.)(.)/$h=chr(ord($1)+1).chr(ord($2)+1);/eg; print $h\n","err":"","out":"ifmmp!xpsme\""},{"out":"EhLl oOwLr!d","err":"","code":"$h=\"hello world!\"; $h=~ s/(.)(.)/$h=uc($2).\"$1\";/eg; print $h\n"},{"code":"$h=\"hello world!\"; $h=~ s/(.)(.)/$h=uc($2).$1\";/eg; print $h\n","err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"hi","err":"","code":"hi\n"},{"out":"hi","err":"","code":"\"hi\"\n"},{"code":"%h = (ichi, ni, san, shi); $h{ichi}\n","err":"","out":"ni"},{"out":"[\"Hi mace\"]","err":"","code":"[\"Hi mace\"]\n"},{"out":"hi","err":"","code":"$_=\"hi\"; print();\n"},{"err":"","out":"1","code":"$_=\"hi\"; print(undef);\n"},{"code":"'Hi these_eyes' x 3\n","err":"","out":"Hi these_eyesHi these_eyesHi these_eyes"},{"out":"hihihihi","err":"","code":"\"hi\" x 4\n"},{"code":"[(\"hi\") x 4]\n","out":"[\"hi\",\"hi\",\"hi\",\"hi\"]","err":""},{"err":"","out":"hiya","code":"'{# hiya #} {# world #}' =~ m/{#\\s?(.+?)\\s?#}/g; $1;\n"},{"code":"\"hlagh\"**0\n","err":"","out":"1"},{"out":"foo","err":"","code":"$h{'login'} = 'foo'; $h{login}\n"},{"out":"{ccc => \"test\",\"asd.fg\" => \"foo\",bbb => \"two\",aaa => \"one\"}","err":"","code":"%h = map { /^(.+)\\.(.*?)\\.\\1$/ } \"aaa.one.aaa\", \"bbb.two.bbb\", \"ccc.test.ccc\", \"asd.fg.foo.asd.fg\"; \\%h\n"},{"out":"{b => 456,a => 123}","err":"","code":"%h = map { split /:/ } qw( a:123 b:456 ); \\%h\n"},{"code":"$_ = 'hood'; s/h(.*)d/n$1k/r\n","err":"","out":"nook"},{"code":"$href = { \"foo\"=>\"bar\" }; [ %$href ]\n","err":"","out":"[\"foo\",\"bar\"]"},{"code":"$href = { \"foo\"=>\"bar\" }; lock_ref_keys($href); map { print \"\\\"$_\\\":$href->{$_}\\n\" } %{$href}\n","out":"ERROR: Undefined subroutine &main::lock_ref_keys called at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"\"foo\":bar\n\"bar\":\n","err":"","code":"$href = { \"foo\"=>\"bar\" }; map { print \"\\\"$_\\\":$href->{$_}\\n\" } %{$href}\n"},{"out":"foobar","err":"","code":"$href = { \"foo\"=>\"bar\" }; print (%{$href})\n"},{"out":"bar","err":"","code":"$href = { \"foo\"=>\"bar\" }; print $href->{\"foo\"}\n"},{"out":"foobar","err":"","code":"$href = { \"foo\"=>\"bar\" }; sub pr { print @_ }; pr( %$href );\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":"","code":"$hs1 = { _ -> {} }\n"},{"out":"qr/XabcY/u","err":"","code":"$h->{someKey}->{whatever} = 'abc'; qr/X$h->{someKey}->{whatever}Y/\n"},{"code":"%h = { stuff => 'sterf' }; \\%h\n","err":"","out":"{\"HASH(0x51a8050)\" => undef}"},{"out":"[\"/html\"]","err":"","code":"[\"<html>foo</html>\" =~ /<([^>]+)>\\s*$/m]\n"},{"out":"[\"k1\",\"v1\",\"k2\",\"v2\"]","err":"","code":"$_=\"http://a?k1=v1&k2=v2\"; $_=(split /\\?/)[-1]; [ map { split /=/ } (split /&/) ]\n"},{"code":" [ 'http://go2web4free.com:7004/img/users/1/1J2KAFHQk_.jpg' =~ m{[^/]+$}g ]\n","err":"","out":"[\"1J2KAFHQk_.jpg\"]"},{"code":"http://google.com $html->at('title')->text\n","out":"ERROR: Unknown regexp modifier \"/e\" at (eval 558) line 1, at end of line\n","err":""},{"code":"https://gist.github.com/anonymous/599c9b609f78f9b0abf4\n","out":"ERROR: Unknown regexp modifier \"/t\" at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, near \"599c9b609f78f9b0abf4\n\"\n","err":""},{"err":"","out":"ERROR: Unknown regexp modifier \"/t\" at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, near \"2ad28e7398c95bb4c92d#file-test-pl-L9\n\"\n","code":"https://gist.github.com/zoffixznet/2ad28e7398c95bb4c92d#file-test-pl-L9\n"},{"out":"ERROR: Unknown regexp modifier \"/w\" at (eval 558) line 1, at end of line\nUnknown regexp modifier \"/w\" at (eval 558) line 1, at end of line\nUnknown regexp modifier \"/w\" at (eval 558) line 1, at end of line\n","err":"","code":"http://www.google.com/ $html = lc $html; $html =~ tr/a-z/n-za-m/;\n"},{"out":"ERROR: Unknown regexp modifier \"/w\" at (eval 558) line 1, at end of line\nUnknown regexp modifier \"/w\" at (eval 558) line 1, at end of line\nUnknown regexp modifier \"/w\" at (eval 558) line 1, at end of line\n","err":"","code":"http://www.google.com/ $html = lc $html; $html =~ tr/a-z/n-za-m/; $html\n"},{"code":"http://www.google.com/ ref $html\n","out":"ERROR: Unknown regexp modifier \"/w\" at (eval 558) line 1, at end of line\nUnknown regexp modifier \"/w\" at (eval 558) line 1, at end of line\nUnknown regexp modifier \"/w\" at (eval 558) line 1, at end of line\n","err":""},{"err":"","out":"http://CLOUD_NETWORK.1.1:2144/www.google.com","code":"\"http://www.google.com\" =~ s/http:\\/\\//http:\\/\\/CLOUD_NETWORK.1.1:2144\\//r # I get www.google.com at the end\n"},{"code":"[ 'http://www.site.com/letters0241/something-in-australia-a' =~ m[/(?:[^-/]*-){2}([^-/]*)[^/]*\\z] ]\n","out":"[\"australia\"]","err":""},{"out":"[\"australia\"]","err":"","code":"[ 'http://www.site.com/letters0241/something-in-australia-a' =~ m[something-in-([^-]*)] ]\n"},{"err":"","out":"hug","code":"$_ = \"huf\"; ++$_\n"},{"code":"huf->can(\"be::sure\")\n","err":"","out":""},{"out":"sub { \"DUMMY\" }","err":"","code":"huf->can(\"can\")\n"},{"code":"huf->can(\"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")\n","out":"sub { \"DUMMY\" }","err":""},{"code":"@hyperv = qw(foo bar baz); print @hyperv . \"\\n\"\n","out":"3\n","err":""},{"code":"$i = 0; \"aaaa\" =~ s/a/(++$i == 2) ? 'b' : $&/ger #hey, you can do it in perl too! :P\n","err":"","out":"abaa"},{"out":"1 2 3 5 8 13 21 34 55 89 144 233 ","err":"","code":"$i = 1; for (1 .. 12) { print $i, \" \"; $i = int $i * (.5 + sqrt 1.25) + .5; }\n"},{"out":"14","err":"","code":"$i=5; $i = ++$i + ++$i\n"},{"code":"\"I am \"\n","out":"I am ","err":""},{"out":"I am a bot","err":"","code":"\"I am a bot\"\n"},{"out":"I am a fish \"I am a fish \".$_[0]","err":"","code":"\"I am a fish \".$_[0]\n"},{"code":"$_ = 'i am happy'; [ /(?=(....))/g ]\n","err":"","out":"[\"i am\",\" am \",\"am h\",\"m ha\",\" hap\",\"happ\",\"appy\"]"},{"out":"","err":"","code":"`id`\n"},{"out":"\r","err":"","code":"'i' ^ 'd'\n"},{"code":"[ 'i' ^ 'd' ]\n","err":"","out":"[\"\\r\"]"},{"code":"[ \"<id>textA<email1><id>textB<email2>\" =~ m!<id>([^<>]*)<email2>! ]\n","err":"","out":"[\"textB\"]"},{"err":"","out":"[\"textA\",\"textB\"]","code":"[ \"<id>textA<email1><id>textB<email2>\" =~ m!<id>([^<>]*)<email\\d>!g ]\n"},{"code":"if(0)\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":""},{"code":"if (0) { 'a block' }\n","err":"","out":"0"},{"err":"","out":"","code":"if (0) { } esle { } exit\n"},{"code":"if (1 == 1) { print 'foo'; } else;\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n"},{"code":"if ( 1 ){ do_something(); } sub  do_something { print \"heyy\"; }\n","out":"heyy","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \") {\"\n","code":"if (1) {} elseif (2) {}\n"},{"out":"","err":"","code":"if (1) {} elsif (2) {}\n"},{"code":"{ if (1 ) { last; print \"lols\"; } print \"lulz\"; } print \"lelz\";  # linagee\n","out":"lelz","err":""},{"code":"if(1) {{ print \"here\"; last; print \"not here\" }} print \" done\"\n","out":"here done","err":""},{"out":"1","err":"","code":"if ('abc' =~ /^a/) { 1 } else { 0 }\n"},{"err":"","out":"true","code":"if(\"a\" == \"b\"){print \"true\";}else{print \"false\";}\n"},{"err":"","out":"false","code":"if(\"a\" eq \"b\"){print \"true\";}else{print \"false\";}\n"},{"code":"\"if answer > 0: answer = answer + 2\" =~ /^\\s*if (.*): (.*)/\n","err":"","out":"1"},{"out":"0","err":"","code":"if (@a = sub { return }->()) { 1 }\n"},{"code":"if (@a = sub { return undef }->()) { 1 }\n","out":"1","err":""},{"code":"if('besaid' =~ m/(\\w*said)/) {print qq{matched \"$1\"\\n};}\n","out":"matched \"besaid\"\n","err":""},{"out":"","err":"","code":"`ifconfig -a | grep -i inet`\n"},{"out":"[{foo => {bar => {}}}]","err":"","code":"if (exists $x->{foo}{bar}{baz}) { } [$x]\n"},{"err":"","out":"false is true!","code":"if (false) { print \"false is true!\"; }\n"},{"code":"if...if ($x.endswith(\"ft\"))...\n","out":"ERROR: syntax error at (eval 558) line 1, near \"if...\"\n","err":""},{"err":"","out":"wrapper","code":"if (int(rand(2))) { return 'wrapper' } return 'builder'\n"},{"err":"","out":"Matches! var1: foo, var2: bar","code":"if (my ($var1, $var2) = \"foo bar\" =~ /(foo|bar)/g) { print \"Matches! var1: $var1, var2: $var2\"; }\n"},{"code":"if (my ($var1, $var2) = \"foo bar\" =~ /(foo)|(bar)/g) { print \"Matches! var1: $var1, var2: $var2\"; }\n","out":"Matches! var1: foo, var2: ","err":""},{"out":"Matches! var1: foo, var2: ","err":"","code":"if (my ($var1, $var2) = \"foo bar\" =~ /(foo|bar)/) { print \"Matches! var1: $var1, var2: $var2\"; } #I'm not quite sure it's entirely correct though\n"},{"code":"if (my ($var1, $var2) = \"foo bar\" =~ /(foo)|(bar)/) { print \"Matches! var1: $var1, var2: $var2\"; } #meant like this rather, but meh\n","err":"","out":"Matches! var1: foo, var2: "},{"code":"if ((my $var) = (\"z\" =~ //)) { print \"TRUE\" ;}\n","out":"TRUE","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \") {\"\n","code":"if (my ($x, $y) = (1, 0) { ['true']; } else { ['false'] }\n"},{"err":"","out":"[\"true\"]","code":"if (my ($x, $y) = (1, 0)) { ['true']; } else { ['false'] }\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"if  !\"\n","code":"if  !($sender =~ qr/@ArrayNickHighLight/i) {}\n"},{"code":"if (!($sender =~ qr/@ArrayNickHighLight/i))\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":""},{"code":"if (!($sender =~ qr/@ArrayNickHighLight/i)) {}\n","err":"","out":""},{"code":"if ($sender !~ qr/@ArrayNightHighLight/i) { ... }\n","err":"","out":""},{"code":"if( \"        \" =~ /^((\\t|\\s{4})+)/ ) { print length $1 }\n","out":"8","err":""},{"out":"4","err":"","code":"if( \"        \" =~ /^(\\t|\\s{4})+/ ) { print length $1 }\n"},{"err":"","out":"1","code":"\"        if (x = 2): print y;        yo\" =~ /^([\\t ]+)/; my $indents = () = $1 =~ /(\\t| {8})/g\n"},{"out":"ERROR: Can't modify not in scalar assignment at (eval 558) line 1, near \") )\n\"\nsyntax error at (eval 558) line 1, at EOF\n","err":"","code":"if (! $x = foo() )\n"},{"code":"if ($x->{foo}{bar}{baz}) { } [$x]\n","err":"","out":"[{foo => {bar => {}}}]"},{"code":"if ($x){next}\n","out":"","err":""},{"code":"$_ = \"If you can read this, you could be a programmer\"; tr/aeiou//d; $_\n","out":"If y cn rd ths, y cld b  prgrmmr","err":""},{"code":"$i = {\"h\" => 1, \"i\" => 2}; $j = \"i\"; [ ${$j}, $i->{${$j}} ]\n","out":"[{i => 2,h => 1},undef]","err":""},{"err":"","out":"I hat popl","code":"\"I hate people\" =~ s/e//gr\n"},{"code":"\"I\" + \"I\";\n","out":"0","err":""},{"code":"$i=$i++;  ++$i + $i++\n","out":"3","err":""},{"code":"$i=$i++;  ++$i + $i++  ;\n","err":"","out":"3"},{"err":"","out":"i like [my] keys [with] rings, not within [my] hammy interior","code":"\"i like my keys with rings, not within my hammy interior\" =~ s/\\b(my|with)\\b/[$1]/rg\n"},{"code":"\"i like my keys with rings, not within my hammy interior\" =~ s/\\b(my|with)\\b/[$1]/rg -- this one?\n","err":"","out":"ERROR: Can't modify substitution (s///) in postdecrement (--) at (eval 558) line 1, near \"s/\\b(my|with)\\b/[$1]/rg --\"\nsyntax error at (eval 558) line 1, near \"-- this one\"\n"},{"code":"\"img 34 32 4 3453  m agi  img 34 ag sgd dfg dfs img 54323 423 img 3sadf  asd\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"\"img 34 32 4 3453  m agi  img 34 ag sgd dfg dfs img 54323 423 img 3sadf  asd\" =~ s/img/img\\n/gr\n","out":"img\n 34 32 4 3453  m agi  img\n 34 ag sgd dfg dfs img\n 54323 423 img\n 3sadf  asd","err":""},{"err":"","out":"[123,456]","code":"$in = \"abc123def456xyz\"; (@out) = $in =~ /\\d+/g; \\@out;\n"},{"code":"$in = \"abc123def\"; ($out) = $in =~ /\\d+/g; [$out]; # for added confusion\n","out":"[123]","err":""},{"code":"$in = \"abc123def\"; ($out) = $in =~ /(\\d+)/; [$out]\n","err":"","out":"[123]"},{"out":"[1]","err":"","code":"$in = \"abc123def\"; ($out) = $in =~ /\\d+/; [$out]\n"},{"code":"[@INC]\n","out":"[]","err":""},{"code":"@INC;\n","out":"0","err":""},{"code":"\\@INC\n","err":"","out":"[]"},{"out":"333/512","err":"","code":"%INC\n"},{"code":"[ %INC/\\@INC ]; # hash/array reference\n","out":"[\"8.44985424667817e-06\"]","err":""},{"code":"$INC{'version'}\n","err":"","out":""},{"code":"$INC{'version.pm'}\n","out":"/home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/version.pm","err":""},{"code":"index('abcde', 'd')\n","err":"","out":"3"},{"err":"","out":"[0,0]","code":"[index(\"foo bar\",\"foo\"),index(\"food\",\"foo\")]\n"},{"out":"[-1,-1]","err":"","code":"[index(\"foo\", \"foo bar\"),index(\"foo\",\"food\")]\n"},{"out":"1","err":"","code":"index('test123', 'test') == 0  # I assume?\n"},{"out":"[10,9,8,7,6,5,4,3,2,1]","err":"","code":"@indices; for (1 .. 10) { push @indices, 11 - $_ }; [@indices];\n"},{"code":"'inf'\n","err":"","out":"inf"},{"code":"'inf' > ~0\n","out":"1","err":""},{"code":"'inf'/0\n","out":"ERROR: Illegal division by zero at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"NaN","err":"","code":"'inf' - 'inf'\n"},{"err":"","out":"1","code":"inf == inf\n"},{"err":"","out":"1","code":"\"inf\" == \"Inf\"\n"},{"out":"NaN","err":"","code":"'inf'/'nan'\n"},{"err":"","out":"[\"foo\",\"foo.bak\"]","code":"$in=\"foo\"; ($out = $in) .= \".bak\"; [ $in, $out ]\n"},{"out":"[\"foo.bak\",\"foo.bak\"]","err":"","code":"$in=\"foo\"; $out = $in .= \".bak\"; [ $in, $out ]\n"},{"code":"\"INGY\" ^ \"perl\"\n","err":"","out":"9+55"},{"code":"$input = \"123\\n456\"; [ $input =~ /123.*456/ ? \"yes\" : \"no\", $input =~ /123.*456/s ? \"yes\" : \"no\" ]\n","err":"","out":"[\"no\",\"yes\"]"},{"code":"$input = '       A         B        C'; [ split \" \", $input ]\n","out":"[\"A\",\"B\",\"C\"]","err":""},{"code":"$input = ideally I'd\n","err":"","out":"ERROR: Can't locate object method \"ideally\" via package \"I::d\" (perhaps you forgot to load \"I::d\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"int(11/15 * 100);\n","out":"73","err":""},{"code":"int(1.139999999999999 * 100)\n","out":"113","err":""},{"code":"int(1.14 * 100)\n","out":"114","err":""},{"code":"int(134.95 * 100)\n","out":"13494","err":""},{"err":"","out":"25","code":"int( (1414364400 - 1414274400) / 3600 )\n"},{"out":"1998","err":"","code":"int(19.99*100)\n"},{"code":"int(2.4213534531451E+30)\n","out":"2.4213534531451e+30","err":""},{"code":"int((45/50-1)*100)\n","err":"","out":"-9"},{"code":"int(5/3)\n","err":"","out":"1"},{"code":"&Internals::SvREADONLY \\!0, 0; ${\\!0} = 0; defined 'foo'\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"&Internals::SvREADONLY \\\"\n"},{"err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","code":"&Internals::SvREADONLY(\\!0, 0); ${\\!0} = 0; defined 'foo'\n"},{"code":"&Internals::SvREADONLY(\\undef, 0); undef = []; undef\n","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"int((foo); bar()\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":""},{"code":"int rand 0\n","err":"","out":"0"},{"out":"0","err":"","code":"int rand + 1;\n"},{"out":"No","err":"","code":"(int rand 2) ? \"Yes\" : \"No\"\n"},{"err":"","out":"1","code":"((int rand 5) + 22) % 24\n"},{"code":"(int(rand 5) - 2) % 24\n","err":"","out":"23"},{"err":"","out":"64","code":"$intsize = length(~1) > 10 ? 64 : 32\n"},{"out":"13495","err":"","code":"int sprintf '%.f', 134.95 * 100\n"},{"code":"\" \" == int(\" \") ? \"true\" : \"false\"\n","out":"true","err":""},{"out":"true","err":"","code":"\"\" == int(\"\") ? \"true\" : \"false\"\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":"","code":"int((x)\n"},{"out":"ERROR: Transliteration replacement not terminated at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"int((x); y()\n"},{"code":"IO::Socket::INET->new()\n","out":"ERROR: Can't locate object method \"new\" via package \"IO::Socket::INET\" (perhaps you forgot to load \"IO::Socket::INET\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"[\"11111432941656\"]","err":"","code":"[ \"<ip:11111432941656@192.168.0.230>\" =~ /:([0-9]+)/ ]\n"},{"code":"$i = [qw/5 7 8 2/]; [sum map { scalar @$_ } @i]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"sum map\"\n","err":""},{"code":"$i = [qw/5 7 8 2/]; [sum map { scalar @$_ } @list\n","out":"ERROR: syntax error at (eval 558) line 1, near \"sum map\"\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"sum map\"\n","err":"","code":"$i = [qw/5 7 8 2/]; [sum map { scalar @$_ } @list]\n"},{"code":"'irc.freenode.net' =~ /irc\\.([^.]+)/ and print $1;\n","err":"","out":"freenode"},{"code":"isa {STDOUT} 'GLOB';\n","out":"1","err":""},{"out":"","err":"","code":"isa {STDOUT} 'IO::Handle';\n"},{"out":"ERROR: Can't call method \"isa\" without a package or object reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"\"\"->isa(\"UNIVERSAL\")\n"},{"code":"$_ = \"I saw Wilma yesterday\"; [ /(\\w*)a/, /(\\w*a)(\\s+[a-zA-Z]{4})/ ]\n","out":"[\"s\",\"Wilma\",\" yest\"]","err":""},{"code":"\" is just our way of talking to the evalbot. Nothing to do wih code.\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"$_ = 'I speak Goat Latin'; my $n = 1; s/\\b([^aeiou\\W])?(\\w+)/\"$2\\L$1ma\".'a'x$n++ ^ (($&&$\")^$\")/geir\n","out":"imaa peaksmaaa Oatgmaaaa Atinlmaaaaa","err":""},{"code":"$_ = 'I speAk Goat Latin'; my $n = 1; s/\\b([^aeiou\\W])?(\\w+)/\"$2\\L$1ma\".'a'x$n++ ^ (($&&$\")^$\")/geir\n","err":"","out":"imaa peAksmaaa Oatgmaaaa Atinlmaaaaa"},{"err":"","out":"Imaa peaksmaaa Oatgmaaaa Atinlmaaaaa","code":"$_ = 'I speAk Goat Latin'; my $n = 1; s/\\b([^aeiou\\W])?(\\w+)/\"\\L$2$1ma\".'a'x$n++ ^ (($&&$\")^$\")/geir\n"},{"out":"Imaa peaksmaaa oatgmaaaa atinlmaaaaa","err":"","code":"$_ = 'I speak Goat Latin'; my $n = 1; s/\\b([^\\Waeiouy]?)(\\w+)/$2\\l$1ma/gr =~ s/\\w+\\K/'a'x$n++/ger\n"},{"out":"Imaa peAksmaaa oatgmaaaa atinlmaaaaa","err":"","code":"$_ = \"I speAk Goat Latin\"; my $n = 1; s/\\b([^\\Waeiouy]?)(\\w+)/my $z = \"$2\\l$1ma\" ; ($1=~m\"\\p{Lu}\"?\"\\u$z\":$z)/ger =~ s/\\w+\\K/\"a\"x$n++/ger\n"},{"code":"$_ = 'I speAk Goat Latin'; my $n = 1; s/\\b([^\\Waeiouy]?)(\\w+)/$\"x length$&&\"$1$2\"^\"\\U$2$1\\Ema\"/ger =~ s/\\w+\\K/'a'x$n++/ger\n","err":"","out":"Imaa peaKsmaaa Oatgmaaaa Atinlmaaaaa"},{"code":"$_ = 'I speAk Goat Latin'; my $n = 1; s/\\b([^\\Waeiouy]?)(\\w+)/$\"x length$&&$&^\"\\U$2$1\\Ema\"/ger =~ s/\\w+\\K/'a'x$n++/ger\n","out":"Imaa peaKsmaaa Oatgmaaaa Atinlmaaaaa","err":""},{"code":"$_ = 'I speak Goat Latin'; s/\\b[aeiouy]\\w+\\K/ma/gi || s/\\b(\\w)(\\w*)/$2$1ma/g; my $n = 1; s/\\w+\\K/'a'x$n++/ger # like this riceandbeans\n","out":"Imaa peaksmaaa oatGmaaaa atinLmaaaaa","err":""},{"code":"is to test things.\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":""},{"err":"","out":"italic test after italic","code":"\"italic test after italic\"\n"},{"code":"{ itemFilter => 'first value', itemFilter => 'second value' };\n","out":"{itemFilter => \"second value\"}","err":""},{"code":"( item => \"first value\", item => \"second value\" ); # That's how you fix \u0002*that*\u0002\n","err":"","out":"second value"},{"err":"","out":"[\"item\",\"first value\",\"item\",\"second value\"]","code":"[ item => \"first value\", item => \"second value\" ]; # Why did you evaluate the last one the way you did, anyway?\n"},{"err":"","out":"It puts the lotion in the basket!","code":"\"It puts the lotion in the basket!\"\n"},{"code":"'i' xor 'd'\n","out":"","err":""},{"code":"\"\\j\"\n","err":"","out":"j"},{"err":"","out":"+jesus","code":"- -'jesus'\n"},{"out":"-jesus","err":"","code":"-'jesus'\n"},{"code":"\"john@example.com\"\n","out":"john.com","err":""},{"code":"j oin\n","err":"","out":"ERROR: Can't locate object method \"j\" via package \"oin\" (perhaps you forgot to load \"oin\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"join \"\\0\", qw<a b c>\n","out":"a\u0000b\u0000c","err":""},{"err":"","out":"1:2:3:4:5:6:7:8:9:10","code":"join(':', (1..10))\n"},{"code":"join \", \", 1, 2, \"\\n\";\n","err":"","out":"1, 2, \n"},{"code":"join'','a'..'m','N'..'Z'\n","err":"","out":"abcdefghijklmNOPQRSTUVWXYZ"},{"code":"join'',a..'m',N..Z\n","out":"abcdefghijklmNOPQRSTUVWXYZ","err":""},{"code":"join'',a..m ,N..Z\n","out":"ERROR: Search pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"join'',a..m,N..Z\n","out":"ERROR: Search pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"join('', 'a'..'z') =~ s/(.{13})$/uc$1/er\n","out":"abcdefghijklmNOPQRSTUVWXYZ","err":""},{"err":"","out":"abcdefghijklmNOPQRSTUVWXYZ","code":"join('', 'a'..'z') =~ s/^(.*)\\K(??{ '.' x length $1 })$/\\U$&/r;\n"},{"out":"Buffalo","err":"","code":"join ' ', (\"Buffalo\")\n"},{"code":"join ' ', (\"Buffalo\") x8\n","out":"Buffalo Buffalo Buffalo Buffalo Buffalo Buffalo Buffalo Buffalo","err":""},{"err":"","out":"d8:50:e6:84:e6:de","code":"join ':', 'd850e684e6de' =~ /../g\n"},{"out":"yes","err":"","code":"join'e', qw(y s)\n"},{"err":"","out":"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz","code":"join \"\", grep /\\w/a, map chr, 0..999999\n"},{"code":"join \"hello\", \"a single argument\"\n","out":"a single argument","err":""},{"code":"join 'irre', qw(sq l)\n","out":"sqirrel","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"10 ]\"\n","code":"[ join('', map { +{} } 0..10 ]\n"},{"out":"[\"foo\\0bar\\0baz\\0\"]","err":"","code":"[join \"\", map \"$_\\0\", qw(foo bar baz)]\n"},{"code":"[ join ',', map '?', 1..10 ]\n","out":"[\"?,?,?,?,?,?,?,?,?,?\"]","err":""},{"out":"1:4:9:16:25:36:49:64:81:100","err":"","code":"join(':', map { $_ *= $_ } (1..10))\n"},{"code":"join ' ', map { 20 * ($_ - 1) } 1 .. 5;\n","out":"0 20 40 60 80","err":""},{"err":"","out":"ÃÂ¢ÃÂÃÂ","code":"join '', map chr, 0x2603 # works fine with >256, but they're unicode not utf-8\n"},{"code":"join '', map { chr(255 - hex) } \"9E9B929691\" =~ /([[:xdigit:]]{2})/g # Nei++\n","out":"admin","err":""},{"code":"join ' ', map chr, 97 .. 100\n","err":"","out":"a b c d"},{"code":"join('',map chr,(97, 98, 99))\n","err":"","out":"abc"},{"err":"","out":"gRINNZ","code":"join '', map chr(ord ^ 32), split '', 'Grinnz'\n"},{"out":"ÃÂ¿ÃÂÃÂÃÂÃÂÃÂµÃÂÃÂÃÂ¶ÃÂÃÂÃÂµÃÂ","err":"","code":"join '', map { chr } unpack 'H*', \"31323234\"\n"},{"code":"join \",\", map { $_ || \"\\\\N\" } split \",\", \"abc,,def,ghi,,jkl\"\n","out":"abc,\\N,def,ghi,\\N,jkl","err":""},{"code":"join ' ', map $_ . \"\\N{U+0300}\", qw(a e i o u)\n","err":"","out":"aÃÂÃÂ eÃÂÃÂ iÃÂÃÂ oÃÂÃÂ uÃÂÃÂ"},{"out":"ERROR: Unrecognized character \\xC3; marked by <-- HERE after ot> anno: <-- HERE near column 155 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"join ' ', map $_ . \"\\N{U+0300}\", qw(a e i o u)  <perlbot> anno: Ã Ã¨Ã¬Ã²\n"},{"code":"join ', ', map ord, qw(â° Â¹ Â² Â³ â´ âµ â¶ â· â¸ â¹)\n","err":"","out":"226, 194, 194, 194, 226, 226, 226, 226, 226, 226"},{"err":"","out":"h e l p","code":"join ' ', map pack('B8', $_), \"01101000 01100101 01101100 01110000\" =~ /\\d+/g;\n"},{"err":"","out":"[\"foo/bar/baz -- foo/bar/baz -- foo/bar/baz -- foo/bar/baz\"]","code":"[ join \" -- \",map { s!^/|/$!!g;$_ } @{[ qw{ /foo/bar/baz/ foo/bar/baz /foo/bar/baz foo/bar/baz/ } ]} ]\n"},{"code":"join(' ', map { sprintf(\"%02X\", ord($_)) } split('', \"bar\"))\n","out":"62 61 72","err":""},{"err":"","out":"89 50 4e 47 0d 0a 1a 0a","code":"join \" \", map sprintf(\"%02x\", $_), qw|137 80 78 71 13 10 26 10|\n"},{"out":"My Fancy Filename.txt","err":"","code":"join \" \", map {ucfirst} split(\" \", \"My fancy filename.txt\")\n"},{"out":"V:b1.03.00.00. N:00.00.03.b1.","err":"","code":"join ' ', map { \"$_:\".(unpack( \"H*\", pack $_, 945 ) =~ s/../$&./gr) } 'V', 'N'\n"},{"code":"join '-', map { \"x$_y\" } 1..3;\n","out":"x-x-x","err":""},{"err":"","out":"x1y-x2y-x3y","code":"join '-', map { \"x${_}y\" } 1..3;\n"},{"out":"[\"This\\n is\\na st\\nring\"]","err":"","code":"[ join (\"\\n\", unpack '(A4)*', 'This is a string') ]\n"},{"code":"join ('\\n', unpack '(A4)*', 'This is a string')\n","out":"This\\n is\\na st\\nring","err":""},{"out":"[\"(?^u:^[a-zA-Z]+\\$)|(?^u:^[0-9]+\\$)\"]","err":"","code":"[ join '|', qr/^[a-zA-Z]+$/, qr/^[0-9]+$/ ]\n"},{"out":"fname <<<<<<< lname <<<<<<< age","err":"","code":"join ' <<<<<<< ', qw(fname lname age)\n"},{"code":"join //, qw(foo bar baz)\n","out":"foo1bar1baz","err":""},{"out":"?,?,?,?,?,?,?,?,?,?","err":"","code":"join ',', qw(?) x 10\n"},{"code":"join '', reverse \"7c86467b\" =~ m/../g\n","err":"","out":"7b46867c"},{"code":"join '', sort { --$| * 2 - 1 } split //, 'Jurlt ,cneh eeotakrrsa Ph';\n","out":"Just another Perl hacker,","err":""},{"err":"","out":"Larry Wall is your master","code":"join '', sort { --$| * 2 - 1 } split //, 'LaeulsraWt y yarmsoir r l';\n"},{"code":"join '', sort split '', 'msixpodualngc'\n","out":"acdgilmnopsux","err":""},{"err":"","out":"[\"Just another Perl hacker,\"]","code":"[join '', sort {$|--} split //, \"tuJsa nohterP er lhakcer,\"]\n"},{"code":"(join '', (split //, 'abc'))\n","out":"abc","err":""},{"err":"","out":"cool_string","code":"+join +'_', +(+split /_/, +\"the_cool_string\")[+1,+2]\n"},{"code":"join '_', (split /_/, \"the_cool_string\")[1,2]\n","out":"cool_string","err":""},{"out":"cool_string","err":"","code":"join '_', +(split /_/, \"the_cool_string\")[1,2]\n"},{"out":"","err":"","code":"join \" \", @{ unbuu || [] }\n"},{"code":"join \" \", @{ undef || [] }\n","out":"","err":""},{"code":"join \" \", @{ undef() || [] }\n","out":"","err":""},{"err":"","out":"","code":"join \" \", @{ undef() }\n"},{"err":"","out":"[\"x\"]","code":"[ join ',', (undef // ()), 'x', (undef // ()) ]\n"},{"err":"","out":"00:02:02:05:6D:4C","code":"join \":\", unpack \"(a2)*\", \"000202056D4C\"\n"},{"code":"join \".\", unpack \"C*\", pack \"n\", 945\n","out":"3.177","err":""},{"code":"join ':', unpack('(H2)3', \"\\x12\\x34\\x56\")\n","err":"","out":"12:34:56"},{"err":"","out":"e8:b7:48:68:07:48","code":"join \":\", unpack \"(H2)*\", pack \"H*\", \"e8b748680748\"\n"},{"out":"[\"?,?,?,?\"]","err":"","code":"[ join ',', ('?')x4 ]\n"},{"err":"","out":"[\"????\"]","code":"[ join ',', ('?'x4) ]\n"},{"err":"","out":"JSON","code":"JSON\n"},{"err":"","out":"ERROR: Undefined subroutine &main::JSON called at (eval 558) line 1, <STDIN> line 1.\n","code":"JSON()\n"},{"err":"","out":"[\"1.23\",1.23]","code":"JSON::encode_json [sprintf(\"%.2f\", 1.234), sprintf(\"%.2f\", 1.234) + 0]\n"},{"code":"\\@JSON::EXPORT\n","err":"","out":"[\"from_json\",\"to_json\",\"jsonToObj\",\"objToJson\",\"encode_json\",\"decode_json\"]"},{"out":"[]","err":"","code":"\\@JSON::EXPORT_OK\n"},{"out":"{\"value\":0.086}","err":"","code":"JSON->new->encode({ value => 0+sprintf(\"%.3f\", 34.33/400) })\n"},{"code":"[JSON::true]\n","out":"[bless( do{\\(my $o = 1)}, 'JSON::PP::Boolean' )]","err":""},{"code":"\"JUNK\" =~ m/(.*)/; do { local $1; \"wibble\" =~ m/(\\d+)/; $1; }\n","err":"","out":"JUNK"},{"err":"","out":"JUNK","code":"\"JUNK\" =~ m/(.*)/; \"wibble\" =~ m/(\\d+)/; $1;\n"},{"code":"Just'another'Perl'hacker =~ s/::/ /gr\n","out":"Just another Perl hacker","err":""},{"err":"","out":"Just another silly! Perl hacker","code":"\"Just anotherÂ Perl hacker\" =~ s\u000fo?Â \u000f silly! \u000fr\n"},{"out":"","err":"","code":"$k=0; $numseg=30000; for (my $i = 0; $i < $numseg; $i++) { for (my $j = $i; $j < $numseg; $j++) {$k++}}; print $k;\n"},{"code":"$_ = \"key foo\"; push @arr, /key(.*)/; [@arr]\n","err":"","out":"[\" foo\"]"},{"out":"[9,3,7,5,1]","err":"","code":"[ keys { 1 .. 10 } ]\n"},{"err":"","out":"[3,1]","code":"[keys {1..4}]\n"},{"err":"","out":"5","code":"keys @{ [1..5] }\n"},{"code":"keys( {} ) = 42\n","err":"","out":"0"},{"code":"[ keys (%{{ 'dave' => 1, 'bob' => 2 }}) ]\n","err":"","out":"[\"bob\",\"dave\"]"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","code":"[ keys (%{{ 'dave' => 1, 'bob' => 2 }}); ]\n"},{"code":"keys (%{ 'dave' => 1, 'bob' => 2 });\n","out":"0","err":""},{"code":"keys (%{{ 'dave' => 1, 'bob' => 2 }});\n","err":"","out":"2"},{"code":"keys %hash = 200; scalar %hash\n","out":"0","err":""},{"err":"","out":"ERROR: Type of arg 1 to keys must be hash (not constant item) at (eval 558) line 1, at EOF\n","code":"keys INC\n"},{"err":"","out":"1706","code":"keys %{main::};\n"},{"err":"","out":"0","code":"keys(%order) = 2; keys(%order)\n"},{"code":"keys(%order) = 2; scalar %order\n","err":"","out":"0"},{"code":"[keys { qw(a b c d) }]\n","out":"[\"c\",\"a\"]","err":""},{"err":"","out":"2","code":"keys { qw(a b c d) }\n"},{"out":"4","err":"","code":"@keys = qw(a b c d); @hash{@keys} = @hash{@keys}\n"},{"code":"@keys = qw(a b c d); @hash{@keys} = @hash{@keys}; \\%hash\n","err":"","out":"{a => undef,c => undef,b => undef,d => undef}"},{"code":"@keys = qw(a b c); @values = qw(1 2 3 4); my %result; if (@keys < @values) { push @values, [ splice @values, $#keys ]} @results{@keys} = @values; \\%results\n","out":"{b => 2,c => [3,4],a => 1}","err":""},{"code":"@keys = qw(a b c); @values = qw(1 2 3 4); my %result; if (@keys < @values) { push @values, [ splice @values, $#keys ]} $results{@keys} = @values; \\%results\n","err":"","out":"{3 => 3}"},{"err":"","out":"[]","code":"[ keys(%^V), values(%^V) ]\n"},{"code":"[ keys(%$^V), values(%$^V) ]\n","out":"ERROR: Type of argument to keys on reference must be unblessed hashref or arrayref at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"kill $$\n","err":"","out":"0"},{"code":"kill -TERM, 0\n","err":"","out":""},{"code":"@{[\"Knark\",\". \",\"knark\",\",\"]}\n","out":"4","err":""},{"code":"\"\\\\l\\$1\"\n","err":"","out":"\\l$1"},{"err":"","out":"$1","code":"\"\\l\\$1\"\n"},{"code":"LABEL: { goto redo next last LABEL; }\n","out":"","err":""},{"code":"LABEL: { last LABEL if 1; }\n","out":"","err":""},{"code":"LABEL: sub { }\n","out":"sub { \"DUMMY\" }","err":""},{"out":"","err":"","code":"LABEL: { sub { last LABEL }->() }\n"},{"code":"LABEL: { sub { last LABEL }->(); print \"fail\" }; print \"ok\";\n","out":"ok","err":""},{"err":"","out":"ERROR: Label not found for \"last LABEL\" at (eval 558) line 1, <STDIN> line 1.\n","code":"LABEL: sub { { last LABEL } print \"hax\" }->()\n"},{"code":"\"lag\"\n","out":"lag","err":""},{"code":"'lala'->${ \\sub { 'here ' . shift } }\n","out":"here lala","err":""},{"code":"*{ 'la la'} = sub { 'la la' }; my $name = 'la la'; my $ref = \\&$name; $ref->()\n","err":"","out":"la la"},{"err":"","out":"ÃÂ¡ÃÂºÃÂ","code":"lc 'áº'\n"},{"err":"","out":"ERROR: panic: Infinite recursion in SWASHNEW for 'ToLc'\n","code":"lc chr 0xfb06\n"},{"code":"lc chr 0xfb08\n","err":"","out":"ERROR: panic: Infinite recursion in SWASHNEW for 'ToLc'\n"},{"code":"lc \"Foo\" eq lc \"foo\"\n","err":"","out":"1"},{"code":"length\n","err":"","out":""},{"err":"","out":"[undef]","code":"[length]\n"},{"err":"","out":"4","code":"length \"[^ /\"\n"},{"code":"length 0x00FF\n","out":"3","err":""},{"out":"3","err":"","code":"length 0xFF\n"},{"code":"length 100\n","out":"3","err":""},{"code":"length \"1436365603657\"\n","out":"13","err":""},{"out":"11","err":"","code":"length 1e10\n"},{"code":"length 1e1000\n","out":"3","err":""},{"out":"10","err":"","code":"length 2**32\n"},{"code":"length \"2421392269093537440547188383164\"\n","err":"","out":"31"},{"code":"length 2**64\n","err":"","out":"20"},{"out":"7","err":"","code":"length 64.64.64.5000000000.64.64.6\n"},{"code":"length \"Ìa\"\n","err":"","out":"3"},{"code":"length \"aÌ\"\n","out":"3","err":""},{"err":"","out":"2","code":"length \"Ã \"\n"},{"code":"length (\"a\"x(100*1024*1024))\n","out":"104857600","err":""},{"err":"","out":"31457280","code":"length (\"a\"x(30*1024*1024))\n"},{"code":"length \"Ã©\"\n","err":"","out":"2"},{"err":"","out":"9","code":"length 'á¹ÍÍÍ'\n"},{"out":"1","err":"","code":"length pack \"c\", 9999;\n"},{"out":"2","err":"","code":"length pack \"cc\", 9888, 9999;\n"},{"code":"length pack \"cc\", 9999;\n","out":"2","err":""},{"code":"length pack \"h\", \"41\"\n","err":"","out":"1"},{"out":"1","err":"","code":"length q(\\\\)\n"},{"out":"16","err":"","code":"length q|0.99999999999996|\n"},{"code":"length q|0.9999999999999919|\n","out":"18","err":""},{"err":"","out":"ERROR: Can't find string terminator \"q\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","code":"length q caller vec and print chr ord uc q chr lc and print chr ord q ge log and print chr ord qw q lc q and print chr ord qw q lc q and print chr ord q xor x and print chr ord qq q q and print chr ord uc qw q wait q and print chr ord q xor x and print chr ord q qr q and print chr ord qw q le q and print chr ord qw q do q and print chr hex length q q semctl setpgrp chop q and print chr length q q conti\n"},{"out":"67","err":"","code":"length q[{CRYPT}$2a$04$MjkMhQxasFQod1qq56DXCOvWu6YTWk9X.EZGnmSSIbbtyEBIAixbS]\n"},{"code":"length 'sàº²à» '\n","err":"","out":"8"},{"code":"length 'sàº²à»'\n","out":"7","err":""},{"err":"","out":"8","code":"length sprintf \"%8.2f\", 12\n"},{"code":"length sprintf \"%8f\", 12\n","out":"9","err":""},{"code":"length sprintf '%b', 2 ** 100\n","out":"64","err":""},{"code":"length sprintf '%b', 2**64\n","err":"","out":"64"},{"out":"[12]","err":"","code":"[ length unpack 'H12', 'version' ]\n"},{"err":"","out":"42","code":"$            leonerd = 42;\n"},{"code":"$ leonerd = 42;\n","out":"42","err":""},{"code":"@lettuce = ( kale => \"chrunchy\"); map { print \"yummy\" if  /kale/ } @lettuce;\n","out":"yummy","err":""},{"code":"@lettuce = ( kale => \"chrunchy\"); map { print \"yummy\" if $lettuce{$_} eq \"kale\" } @lettuce;\n","err":"","out":"2"},{"code":"'<li><a href=\"' =~ /<li><a href=/\n","out":"1","err":""},{"err":"","out":"[undef,undef,undef]","code":"'<li><a href=\"' =~ /<li><a href=/; [$1, $2, $3]\n"},{"out":"[\"*this,* *is..a* *test.*\"]","err":"","code":"$likeb = qr/(?:(?<!\\S)(?!\\s)|(?<!\\s)(?!\\S))/; [ 'this, is..a test.' =~ s/$likeb/*/gr ] # should have been qr// (was typo)\n"},{"code":"$likeb = qw/(?:(?<!\\S)(?=\\S)|(?<=\\S)(?!\\S))/; [ 'this, is..a test.' =~ s/$likeb/*/gr ]  # codydn\n","err":"","out":"[\"*this,* *is..a* *test.*\"]"},{"out":"like this","err":"","code":"'like this'\n"},{"out":"line","err":"","code":"line\n"},{"code":"__LINE__\n","err":"","out":"1"},{"err":"","out":"[\"line 2\\n\"]","code":"[ \"line 1\\nline 2\\n\\nline 4\" =~ /^.*\\s$/gm ]\n"},{"code":"@lines = <{a,b,c}>; \\@lines\n","out":"[\"a\",\"b\",\"c\"]","err":""},{"code":"@lines = <.*>; \\@lines\n","out":"[]","err":""},{"code":"$line = \"\\thello\"; [ 0+ $line =~ /^\\t(.+)/ ]\n","out":"[1]","err":""},{"out":"[\"hello\"]","err":"","code":"$line = \"\\thello\"; [ $line =~ /^\\t(.+)/ ]\n"},{"out":"3/8","err":"","code":"$list{0}=\"zero\"; $list{1}=\"one\"; $list{2}=\"two\"; $list{3}=\"three\"; print scalar %list\n"},{"out":"3","err":"","code":"$list[0]=\"zero\"; $list[1]=\"one\"; $list[2]=\"two\"; print scalar @list\n"},{"err":"","out":"3/8","code":"$list{0}=\"zero\"; $list{1}=\"one\"; $list{2}=\"two\"; print scalar %list\n"},{"out":"3","err":"","code":"$list[1]=\"one\"; $list[2]=\"two\"; print scalar @list\n"},{"code":"@list=('d', 'e', 'f', 'a', 'b', 'c'); $startindex=3; @list=@list[$startindex..$#list], @list[0..$startindex-1]; @list\n","out":"3","err":""},{"code":"@list=('d', 'e', 'f', 'a', 'b', 'c'); $startindex=3; @list=(@list[$startindex..$#list], @list[0..$startindex-1]); $text = join ' ', @list; $text;\n","out":"a b c d e f","err":""},{"code":"@list=('d', 'e', 'f', 'a', 'b', 'c'); $startindex=3; @list=@list[$startindex..$#list], @list[0..$startindex-1]; $text = join ' ', @list; $text;\n","err":"","out":"a b c"},{"err":"","out":"[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]","code":"@list = ('d' .. 'f', 'a' .. 'c'); splice @list, 0, 0, splice @list, 3; \\@list\n"},{"code":"List::MoreUtils::any { $_ eq 'a' } ('b', 'a')\n","err":"","out":"1"},{"out":"","err":"","code":"List::MoreUtils::any { $_ eq 'a' } ('b', 'c')\n"},{"err":"","out":"c","code":"List::MoreUtils::any {$_ eq 'a'}, 'b', 'c'\n"},{"code":"List::MoreUtils::any( {$_ eq 'a'} 'b', 'c' )\n","out":"ERROR: syntax error at (eval 558) line 1, near \"} 'b'\"\n","err":""},{"out":"ERROR: Type of arg 1 to List::MoreUtils::any must be block or sub {} (not anonymous hash ({})) at (eval 558) line 1, near \"'c' )\n\"\n","err":"","code":"List::MoreUtils::any( {$_ eq 'a'}, 'b', 'c' )\n"},{"code":" @list = ({name => 1, x => one}, {name => 2, x => two}, {name => 3, x => three}, {name => 4, x => four}); [map {$_->{x}} grep { $_->{name} > 2 } @list]\n","out":"[\"three\",\"four\"]","err":""},{"err":"","out":"94","code":"@listof105 = (1..105); @listof11 = (1..11); @listof105 - @listof11\n"},{"err":"","out":"[undef,\"Z\",undef,\"Z\"]","code":"@list_of_indices = ('1','3'); @array[ @list_of_indices ] = (\"Z\") x @list_of_indices;  \\@array\n"},{"out":"2","err":"","code":"@list=qw(1 2 3 4 5); print $list[rand(@list)]\n"},{"out":"44444","err":"","code":"@list=qw(1 2 3 4 5); print $list[rand(@list)] x 5\n"},{"code":"@list = qw(a b c); $search=\"x\"; [ !! grep($_ eq $search,@list) ]\n","out":"[\"\"]","err":""},{"err":"","out":"[1]","code":"@list = qw(a b c); $search=\"x\"; [ !! grep($search,@list) ]\n"},{"code":"@list = ([qw(apple banana)], [qw(apple orange)], [qw(orange banana)], [qw(beef fish)]); my %sets = (); for my $pair (@list) { my ($x, $y) = @$pair; $sets{$x}{$y} = undef; for my $el (keys %{delete($sets{$y}) // {}}) { $sets{$el} = $sets{$x}; $sets{$x}{$el} = undef } } \\%sets\n","err":"","out":"{orange => {banana => undef},apple => {banana => undef,orange => undef},beef => {fish => undef}}"},{"out":"{orange => {banana => undef},beef => {fish => undef},apple => {banana => undef,orange => undef}}","err":"","code":"@list = ([qw(apple banana)], [qw(apple orange)], [qw(orange banana)], [qw(beef fish)]); my %sets = (); for my $pair (@list) { my ($x, $y) = @$pair; $sets{$x}{$y} = undef; for my $el (keys %{$sets{$y} // {}}) { $sets{$el} = $sets{$x}; $sets{$x}{$el} = undef } } \\%sets\n"},{"err":"","out":"[\"dog\",\"cat\",\"rabbit\",\"turtle\",\"mouse\",\"wolf\"]","code":"@list = qw(dog cat turtle mouse wolf); splice @list, 2, 0, \"rabbit\"; \\@list\n"},{"out":"[30,\"30.1\",31,\"31.1\"]","err":"","code":"[List::UtilsBy::sort_by( sub { $_ }, 31, 30, 30.1, 31.1)]\n"},{"err":"","out":"[30,301,31,311]","code":"[List::UtilsBy::sort_by( sub { $_ }, 31, 30, 301, 311)]\n"},{"code":"List::UtilsBy::sort_by( sub { $_ }, 31, 30, 301, 311)\n","err":"","out":"311"},{"code":"local $[ = 1;\n","out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"local $[ = -1; my @a = (1); $#a\n","err":"","out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"local @ARGV = qw(--linkadd y file_name_here.tgz); use Getopt::Long; GetOptions(\"linkadd=s\" => \\$linkadd); { linkadd => $linkadd, ARGV => \\@ARGV }\n","err":"","out":"ERROR: Can't locate Getopt/Long.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","code":"[ \"\\local_dir\\selected\"\n"},{"out":"[\"ocal_dirselected\"]","err":"","code":"[ \"\\local_dir\\selected\" ]\n"},{"code":"{ local $@; eval { die \"foo\" } } [$@]\n","out":"[\"\"]","err":""},{"err":"","out":"","code":"{ local $@; eval { die \"foo\" } } $@\n"},{"out":"[{4 => 11},{11 => 4}]","err":"","code":"local ($_) = \"foo [aasdf] bar\"; my (%fwd,%bkd); while( s! ( \\[ [^][]* \\] ) ! '.' x length $1 !xe ) { $fwd{$-[1]} = $+[1]; $bkd{$+[1]} = $-[1] }; [ \\%fwd, \\%bkd ]\n"},{"code":"local *_ = \\\"hello\"; $_ = 42\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"My Fancy Filename.txt","err":"","code":"local $_ = \"my fancy filename.txt\";$count=0;s/(\\s*)(.)/upper($1,$2,$count++)/ge;print;sub upper { my ($s, $c, $n) = @_;return $s ? \"$s\\u$c\" : !$n ? \"\\u$c\" : $c; }\n"},{"code":"local $_ = \"my fancy filename.txt\";$count=0;s/(\\s*)(\\w+)/upper($1,$2,$count++)/ge;print;sub upper { my ($s, $c, $n) = @_;return $s ? \"$s\\u$c\" : !$n ? \"\\u$c\" : $c; }\n","out":"My Fancy Filename.txt","err":""},{"code":"local my $foo\n","err":"","out":"ERROR: Can't localize lexical variable $foo at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"local $, = ','; print 1..10\n","out":"1,2,3,4,5,6,7,8,9,10","err":""},{"code":"$^LOCALTIME\n","out":"ERROR: syntax error at (eval 558) line 1, near \"$^LOCALTIME\n\"\n","err":""},{"out":"UTF-32","err":"","code":"local $_ = \"UCS-4\"; eval q@qr/^UCS-?4-?(BE|LE)?$/i; uc(\"UTF-32$1\")@\n"},{"code":"local $var = 'local'; print \" $var \"; { $var = 'notlocal'; print $var };\n","out":" local notlocal","err":""},{"code":"local $var = 'local'; { $var = 'notlocal'; print $var }; print \" $var \"\n","err":"","out":"notlocal notlocal "},{"err":"","out":"64","code":"log(~0 +1)/log(2)\n"},{"code":"log(~0+1)/log(2)\n","out":"64","err":""},{"err":"","out":"64","code":"log(~0)/log(2)\n"},{"code":"log(13500) / log(2)\n","err":"","out":"13.7206717868256"},{"code":"$= = log(16777213) / log(2); $= # yep perfectly safe\n","out":"23","err":""},{"out":"100.9336796636","err":"","code":"log(2421392269093537440547188383164)/log(2)\n"},{"code":"[ log(2), log(10), log(exp(1)) ]\n","err":"","out":"[\"0.693147180559945\",\"2.30258509299405\",1]"},{"err":"","out":"1.58496250072116","code":"log(3) / log 2\n"},{"err":"","out":"First is bigger","code":"((log(632382) * 518061 > log(519432) * 525806) ? \"First\" : \"Second\") . \" is bigger\"\n"},{"out":"5.97727992349992","err":"","code":"log(63) / log(2) # you might want to round to nearest integer if you do\n"},{"code":"$log_content .= <<LOG;\n","out":"ERROR: Can't find string terminator \"LOG\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"[ log_file => 42, die => 9 ]\n","err":"","out":"[\"log_file\",42,\"die\",9]"},{"err":"","out":"LogÃÂ¯ÃÂ¿ÃÂ½ProcessingÃÂ¯ÃÂ¿ÃÂ½ServiceÃÂ¯ÃÂ¿ÃÂ½canÃÂ¯ÃÂ¿ÃÂ½receiveÃÂ¯ÃÂ¿ÃÂ½logÃÂ¯ÃÂ¿ÃÂ½messagesÃÂ¯ÃÂ¿ÃÂ½","code":"'Logï¿½Processingï¿½Serviceï¿½canï¿½receiveï¿½logï¿½messagesï¿½' =~ y/\\xA0/ /dr\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"'LOL' (\"\n","err":"","code":"$_ = 'LOL' (\\&CORE::lc)->()\n"},{"code":"$_ = 'LOL'; (\\&CORE::lc)->()\n","out":"lol","err":""},{"code":"$_=\"lol\"; tr alaLa; print;\n","out":"LoL","err":""},{"code":"$long_var_blah = 42;  $my_pay = $long_var_b1ah * 1000; print \"I'm fucking rich, I got $my_pay!\";\n","err":"","out":"I'm fucking rich, I got 0!"},{"out":"HASH(0x65c1ff0)","err":"","code":"{} . '' # looks something like this, numbers will vary\n"},{"code":"$l='post hoc ergo propter hoc. illigitimus non tatum carborundum.'; $l=~s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $l;\n","out":"poSt HOc erGo Propter hoc. iLlIGitImus noN TatUm caRborUndum.","err":""},{"code":"`ls`;\n","out":"","err":""},{"out":"[]","err":"","code":"[`ls`]\n"},{"out":"","err":"","code":"`ls -a`\n"},{"code":"lvfjf is a fool!\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":""},{"code":"LWP::Simple::get www.google.com\n","out":"ERROR: Can't locate object method \"get\" via package \"LWP::Simple\" (perhaps you forgot to load \"LWP::Simple\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"[m#\n","err":"","out":"ERROR: Search pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"1","err":"","code":"m?^?\n"},{"out":"1","err":"","code":"m/^+/\n"},{"code":"m/$#/\n","out":"ERROR: syntax error at (eval 558) line 1, near \"; m/$#/\"\n","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"0\\\"\nMissing right curly or square bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, at EOF\n","err":"","code":"m0{0\\my}sub H;0;sub{sub{H\n"},{"err":"","out":"1","code":"//magic\n"},{"err":"","out":"1","code":"$main::_ == $_\n"},{"out":"sub { \"DUMMY\" }","err":"","code":"main->can(\"can\")\n"},{"out":"[undef]","err":"","code":"[ main->can( sub { 'dummy' } ) ]\n"},{"code":"main->can( sub { 'dummy' } )\n","err":"","out":""},{"out":"","err":"","code":"main::for () for ();\n"},{"err":"","out":"main","code":"*main::main::main::main::X{PACKAGE}\n"},{"code":"@many = ( \"foo\", \"bar\" ); %{$href} = @many; print $href->{'foo'}.\"\\n\"\n","err":"","out":"bar\n"},{"code":"[ map { 0+!$_} 0, 1 ]\n","err":"","out":"[1,0]"},{"code":"[ map { ($_ > 0) - ($_ < 0) } qw(-5 0 10) ]\n","err":"","out":"[-1,0,1]"},{"out":"[[312,56],[326,-186]]","err":"","code":"[ map [$_->[0] + $_->[3] * 256, $_->[0] - ($_->[1] ^ $_->[2]) * 256], [0b0011_1000, 0, 0, 1], [0b0100_0110, 0, 1, 1] ]\n"},{"code":"map { $_ =~ /(?:^|[^0-9])[0-9]{7}(?:$|[^0-9])/ ? \"+ \" : \"- \"} (\"1234567 \",\" 1234567\",\" 12345678 \")\n","out":"3","err":""},{"code":"[ map { $_->[0] eq $_->[1] } [ split //, \"AB\" ], [ split //, \"A4\" ]]\n","err":"","out":"[\"\",\"\"]"},{"out":"[1,0]","err":"","code":"[ map { 0+!$_ } qw(0 1) ]\n"},{"err":"","out":"[4,1,5,2,3]","code":"[ map $_->[0], sort { $a->[1] <=> $b->[1] } map [ $_, rand ], 1..5 ]\n"},{"code":"[ map 0+sprintf('%.3f', $_), 0.7, 0.33333 ]\n","err":"","out":"[\"0.7\",\"0.333\"]"},{"code":"[ map 0+sprintf('%.3f', $_), 7, 0.33333 ]\n","out":"[7,\"0.333\"]","err":""},{"err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","code":"[ map { $_->[0] xor $_->[1] } [ split //, \"AB\" ], [ split //, \"A4 ]\n"},{"err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","code":"[ map { $_->[0] xor $_->[1] } [ split //, \"AB\" ], [ split //, \"A4 ]]\n"},{"err":"","out":"[\"\",\"\"]","code":"[ map { $_->[0] xor $_->[1] } [ split //, \"AB\" ], [ split //, \"A4\" ]]\n"},{"code":"[ map 1 ]\n","out":"[]","err":""},{"code":"[ map $_/10, 0..10 ]\n","err":"","out":"[0,\"0.1\",\"0.2\",\"0.3\",\"0.4\",\"0.5\",\"0.6\",\"0.7\",\"0.8\",\"0.9\",1]"},{"err":"","out":"10","code":"map { $_*10 } 1..10\n"},{"code":"[ map{($.||1..$.&&0)-1 .\" $_\"}split(//,japh) ]\n","out":"[\"0 j\",\"1 a\",\"2 p\",\"3 h\"]","err":""},{"err":"","out":"[0,0,0,2,0,4,4,6,0,8,8,10,8,12,12,14,0,16,16,18,16,20,20,22,16,24,24,26,24,28,28,30,0]","code":"[map { $_ & ($_-1) } 0 .. 32]\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"1 1\"\n","err":"","code":"[map 1 1]\n"},{"out":"[1]","err":"","code":"[map 1, 1]\n"},{"out":"[0,1,0,1,0,1,0,1,0,1]","err":"","code":"[ map --$|, 1..10 ] # ++ and -- in perl don't have to make sense, they just do useful stuff\n"},{"code":"[map { 1 << $_ } (1 .. 10)]\n","err":"","out":"[2,4,8,16,32,64,128,256,512,1024]"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"} 1\"\n","code":"map { \"$_\" => 1 } 1,2,3\n"},{"err":"","out":"6","code":"map { $_ => 1 } 1,2,3\n"},{"code":"map {; \"$_\" => 1 } 1,2,3\n","err":"","out":"6"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"; $_ \"\n","code":"[map +{; $_ => $_ }, 1 .. 3]\n"},{"err":"","out":"[{1 => 1},{2 => 2},{3 => 3}]","code":"[map +{ $_ => $_ }, 1 .. 3] # need + and , for that\n"},{"code":"[ map --$|, 1..5 ]\n","err":"","out":"[0,1,0,1,0]"},{"out":"[1,0,1,0,1]","err":"","code":"[ map $|--, 1 .. 5 ]\n"},{"out":"[\"jpg\",\"pdf\",\"\",\"vimrc\",\"pl\",undef]","err":"","code":"[map {/.*\\.(.*)$/;$1} \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n"},{"code":"[map {/.*\\.*(.*)$/;$1} \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n","out":"[\"\",\"\",\"\",\"\",\"\",\"\"]","err":""},{"code":"map \"$_\" => 1, qw(a b c);\n","out":"4","err":""},{"code":"map (\"$_\" => 1), qw(a b c);\n","err":"","out":"c"},{"err":"","out":"6","code":"map +(\"$_\" => 1), qw/a b c/\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"} qw/foo bar baz/\"\n","code":"map { \"$_\" => 1 } qw/foo bar baz/\n"},{"code":"map { $_ => 1 } qw/foo bar baz/\n","out":"6","err":""},{"code":"[ map (1x$_) =~ /^1?$|^(11+?)\\1+$/, '1000000000000066600000000000001' ]\n","out":"[\"1000000000000066600000000000001\"]","err":""},{"code":"map { $_* 2 } 1..10\n","err":"","out":"10"},{"code":"[ map { $_ % 2 ? \"<$_>\" : () } 2, 3, 4, 5, 6, 7 ]\n","out":"[\"<3>\",\"<5>\",\"<7>\"]","err":""},{"err":"","out":"[]","code":"[ map { $_ ** 2 } grep { $_ % 2 } (2, 4, 6, 8) ]\n"},{"out":"[0,0,1,0,2]","err":"","code":"[ map { 2 ** $i++ if $_ } reverse split //, sprintf \"%b\", 20]\n"},{"err":"","out":"[1,2]","code":"[ map { $_ ? 2 ** $i++ : ()  } reverse split //, sprintf \"%b\", 20]\n"},{"err":"","out":"[1,2,4,8,16]","code":"[ map { 2 ** $i++ } reverse split //, sprintf \"%b\", 20]\n"},{"out":"[0,0,4,0,16]","err":"","code":"[ map { 2 ** $i++ * $_ } reverse split //, sprintf \"%b\", 20]\n"},{"code":"map{@$_ == 3} \\@arr1, \\@arr2, \\@arr3\n","out":"3","err":""},{"code":"[ map { 47 - ($_ ^ 7) } 0..40 ]\n","err":"","out":"[40,41,42,43,44,45,46,47,32,33,34,35,36,37,38,39,24,25,26,27,28,29,30,31,16,17,18,19,20,21,22,23,8,9,10,11,12,13,14,15,0]"},{"out":"[-1,-1,-1,-1,0,1,1,1,1,1]","err":"","code":"[ map { $_ <=> 5 } 1 .. 10 ]\n"},{"out":"[\"0.2\",\"0.4\",\"0.6\",\"0.8\",1,\"1.2\",\"1.4\",\"1.6\",\"1.8\",2]","err":"","code":"[ map { $_ / 5 } (1..10) ]\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"},\"\n","code":"[ map { $_ / 5 }, (1..10) ]\n"},{"code":"[ map { $_ % 8 + 40 - ($_ & ~7) } 0..40 ]  # shorter :)\n","out":"[40,41,42,43,44,45,46,47,32,33,34,35,36,37,38,39,24,25,26,27,28,29,30,31,16,17,18,19,20,21,22,23,8,9,10,11,12,13,14,15,0]","err":""},{"out":"[40,41,42,43,44,45,46,47,32,33,34,35,36,37,38,39,24,25,26,27,28,29,30,31,16,17,18,19,20,21,22,23,8,9,10,11,12,13,14,15,0]","err":"","code":"[ map { $_ % 8 + 40 - (int($_ / 8) * 8) } 0..40 ]\n"},{"code":"[ map { $_->{a} } @{[ undef ]} ]\n","err":"","out":"[undef]"},{"err":"","out":"[[],[\"\"],[\"a\",\"b\"],[\"a\",\"b\"],[\"\",\"\"],[\"\",\"b\"]]","code":"[ map [/(?!\\A\\z)^.*/mg], \"\", \"\\n\", \"a\\nb\\n\", \"a\\nb\", \"\\n\\n\", \"\\nb\\n\" ]\n"},{"code":"[ map { ~~/\\b([A-Z]\\.){2,}\\b/ } qw(A.A. B.B.B.B.B.B.B.B. C.C.C.C A.M) ]\n","err":"","out":"[0,1,1,0]"},{"err":"","out":"[\"LATIN SMALL LETTER A WITH CIRCUMFLEX\",\"LATIN SMALL LETTER A WITH CIRCUMFLEX\",\"LATIN SMALL LETTER A WITH CIRCUMFLEX\"]","code":"[ map charnames::viacode(ord($_)), qw(â â â) ]\n"},{"err":"","out":"[\"LATIN SMALL LETTER A WITH CIRCUMFLEX\",\"LATIN SMALL LETTER A WITH CIRCUMFLEX\",\"LATIN SMALL LETTER A WITH CIRCUMFLEX\"]","code":"[ map charnames::viacode(ord), qw(â â â) ]\n"},{"out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"[ map{chomp} (\"foo\\n\",\"bar\\n\") ]\n"},{"err":"","out":"I H A T E P E O P L E","code":"\"@{[ map chr $_ + 64, qw/9 8 1 20 5 16 5 15 16 12 5/]}\"\n"},{"code":"\"@{[ map chr $_ + 65, qw/9 8 1 20 5 16 5 15 16 12 5/]}\"\n","err":"","out":"J I B U F Q F P Q M F"},{"code":"[ map chr hex, \"302e3f313133\" =~ /../g ] # if you don't want the extra validation\n","err":"","out":"[0,\".\",\"?\",1,1,3]"},{"code":"[ map chr(hex($_)), sprintf('%08x', 1383403352) =~ /../g ]\n","err":"","out":"[\"R\",\"u\",\"\\17\",\"X\"]"},{"code":"\"@{[ map chr, qw/9 8 1 20 5 16 5 15 16 12 5/]}\"\n","err":"","out":"\t \b \u0001 \u0014 \u0005 \u0010 \u0005 \u000f \u0010 \f \u0005"},{"code":"[ map \"$_\", \\&configure ]\n","err":"","out":"[\"CODE(0x63a3230)\"]"},{"out":"[1,1,\"\"]","err":"","code":"[ map { $_ || defined $_ } (0, 1, undef) ]\n"},{"code":"[ map defined, 1, '', undef, 42 ]\n","out":"[1,1,\"\",1]","err":""},{"out":"[\"describing\",\"description\",\"descriptive\"]","err":"","code":"[ map { \"descri$_\" } \"bing\", map { \"pti$_\" } \"on\", \"ve\" ]\n"},{"err":"","out":"[\"1990 1992 1993 2010\",\"this-is-a-string-with-9-something-3ls3\"]","code":"[ map { /[^\\d-]/ ? $_ : tr/-/ /r } '1990-1992-1993-2010', \"this-is-a-string-with-9-something-3ls3\" ]\n"},{"code":"[ map { \"duck\" =~ m/$_/ ? $_ : \"no\" } qw/du uc ck/ ]\n","err":"","out":"[\"du\",\"uc\",\"ck\"]"},{"out":"[\"foo\",\"a\",\"foo\",\"b\",\"foo\",\"c\"]","err":"","code":"[ map { ; foo => $_ } 'a'..'c' ]\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"} 'a'\"\n","code":"[ map +{ foo => $_ } 'a'..'c' ]\n"},{"out":"[{foo => \"a\"},{foo => \"b\"},{foo => \"c\"}]","err":"","code":"[ map +{ foo => $_ }, 'a'..'c' ]\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"} 'a'\"\n","err":"","code":"[ map { foo => $_ } 'a'..'c' ]; # which of the above two should this be?\n"},{"code":"[ map {; /^(?!(foobar){2}$)(?:\\1)*/ ? 1 : 0 } \"\", \"foobar\", \"foobarfoobar\", \"foobarfoobarfoobar\" ]\n","err":"","out":"[1,1,0,1]"},{"err":"","out":"[[\"bar\",123],[undef,123],[]]","code":"[ map [ /foo (bar)? (\\d+)/ ], 'foo bar 123', 'foo  123', 'no match' ]\n"},{"err":"","out":"[\"\",1]","code":"[ map !!/(?<!^)foo/, \"foo\", \"barfoo\" ]\n"},{"err":"","out":"[\"\",1]","code":"[ map !!/(?!^)foo/, \"foo\", \"barfoo\" ]\n"},{"err":"","out":"[1]","code":"[ map /(?!^)foo/, \"foo\", \"barfoo\" ]\n"},{"code":"[ map {; for (()){} } qw(A B C D) ]\n","err":"","out":"[\"\",\"\",\"\",\"\"]"},{"out":"[4,16]","err":"","code":"[ map { $i++; $_ ? 2 ** ($i - 1) : ()  } reverse split //, sprintf \"%b\", 20]\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","code":"[ map { if ($_ % 2) { \"<$_>\" } else { say \"hey!\"; () }; } (1..10); ]\n"},{"code":"[ map {; if ($_ ne 'A') { 0 } } qw(A B C D) ]\n","out":"[\"\",0,0,0]","err":""},{"out":"[0,0,0,0,1,1,1,1,1,2]","err":"","code":"[ map { int($_ / 5) } (1..10) ]\n"},{"out":"[18,31,7,27,1,3,48,45,44,37,46,15,35,36,15,1,24,25,27,16,30,45,48,12,22,28,2,22,48,5,33,21,45,21,2,12,11,7,42,26,17,2,15,19,3,41,47,16,47,13,25,48,1,6,41,3,36,9,35,4,20,7,44,3,8,22,18,29,16,12,28,1,6,39,45,0,10,25,3,10,2,36,3,13,14,24,47,7,48,41,34,32,33,16,15,12,42,41,7,31]","err":"","code":"[ map { int rand 50 } 1..100 ];\n"},{"err":"","out":"[0,1,2]","code":"[ map { $i++ } qw/foo bar baz/ ]\n"},{"code":"[  map { +{ ITEM => $_ } } qw( bla hi hue )  ]\n","out":"[{ITEM => \"bla\"},{ITEM => \"hi\"},{ITEM => \"hue\"}]","err":""},{"code":"[  map { ITEM => $_ } qw( bla hi hue )  ]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"} qw( bla hi hue )\"\n","err":""},{"code":"[  map { ITEM => $_ }, qw( bla hi hue )  ]\n","err":"","out":"[{ITEM => \"bla\"},{ITEM => \"hi\"},{ITEM => \"hue\"}]"},{"code":"[  map { +{ ITEM => $_ } } qw( bla hi hue )  ]  # see\n","out":"[{ITEM => \"bla\"},{ITEM => \"hi\"},{ITEM => \"hue\"}]","err":""},{"code":"%map{key}\n","out":"","err":""},{"code":"[ map !!/.\\Kfoo/, \"foo\", \"barfoo\" ]\n","out":"[\"\",1]","err":""},{"code":"[map { $_; last } (1,2,3)]\n","out":"","err":""},{"code":"[map length, q{$\"=\"\";@x=([],{},\" \",sub{},\\\"\");map{s/..(..).*/$1/}@x;\"@x\"}, q{print/..(..?)/ for[],{},$\"x3,\\&f,\\0}]\n","out":"[57,35]","err":""},{"code":"[ map m?^?, 1 .. 4 ]\n","err":"","out":"[1]"},{"code":"[ map [ m{\\A (.*?) - ( \\d+ (?: \\. \\d+ )* (?: -r \\d+ )? ) \\z}xa ], qw(cryptsetup-1.1.3-r3 cronbase-0.3.3 automake-wrapper-3-r1 gcc-4.5.3-r1) ]\n","out":"[[\"cryptsetup\",\"1.1.3-r3\"],[\"cronbase\",\"0.3.3\"],[\"automake-wrapper\",\"3-r1\"],[\"gcc\",\"4.5.3-r1\"]]","err":""},{"code":"[ map [ m{\\A (.*?) - ( \\d+ (?: \\. \\d+ )* (?: -r \\d+ )? ) \\z}xa ], qw(cryptsetup-1.1.3-r3 cronbase-0.3.3. automake-wrapper-3-r1 gcc-4.5.3-r1) ]\n","out":"[[\"cryptsetup\",\"1.1.3-r3\"],[],[\"automake-wrapper\",\"3-r1\"],[\"gcc\",\"4.5.3-r1\"]]","err":""},{"code":"[ map { m/^(\\d+)-(\\d+)$/ ? ( $1 .. $2 ) : ( $_ ) } split m/,/, \"1-3,5,6-9\" ]\n","err":"","out":"[1,2,3,5,6,7,8,9]"},{"code":"[ map [/^.*/mg], \"\", \"\\n\", \"a\\nb\\n\", \"a\\nb\", \"\\n\\n\", \"\\nb\\n\" ]\n","out":"[[\"\"],[\"\"],[\"a\",\"b\"],[\"a\",\"b\"],[\"\",\"\"],[\"\",\"b\"]]","err":""},{"err":"","out":"[\"a\",123,\"b\",456]","code":"[ map { my ( $a, $b ) = split /:/; { $a => $b } } qw( a:123 b:456 ) ];\n"},{"code":"[ map { my ( $a, $b ) = split /:/; +{ $a => $b } } qw( a:123 b:456 ) ];\n","out":"[{a => 123},{b => 456}]","err":""},{"code":"[ map { my $foo if 0; ++$foo } 1 .. 10 ]\n","err":"","out":"[1,2,3,4,5,6,7,8,9,10]"},{"err":"","out":"[1,2,3,4,5,6]","code":"[ map { my $foo if 0; ++$foo } 5 .. 10 ]\n"},{"err":"","out":"[\"asdf\",\"asdf\"]","code":"[ map { my $line = $_; $line =~ s/\\n+$//; $line } (\"asdf\",\"asdf\\n\") ]\n"},{"out":"[\"asdf\\n\",\"asdf\\n\"]","err":"","code":"[ map { my $line = $_; $line =~ s/\\n*$/\\n/; $line } (\"asdf\",\"asdf\\n\") ]\n"},{"err":"","out":"","code":"[map { $_; next } (1,2,3)]\n"},{"out":"[[\"\"],[\"\\n\"],[\"a\\n\",\"b\\n\"],[\"a\\n\",\"b\"],[\"\\n\",\"\\n\"],[\"\\n\",\"b\\n\"]]","err":"","code":"[ map [/^.*\\n?/mg], \"\", \"\\n\", \"a\\nb\\n\", \"a\\nb\", \"\\n\\n\", \"\\nb\\n\" ]\n"},{"out":"[\"v0.1.0\",\"v0.1.0\",\"v0.10.0\",\"v0.100.0\"]","err":"","code":"[map { $_->normal } version->parse('v0.01'), version->parse('v0.1'), version->parse('v0.10'), version->parse('0.10')]\n"},{"code":"map {; no strict qw(refs); $_; } 1..3\n","out":"3","err":""},{"err":"","out":"[1,5,21,85,341,1365,5461,21845,87381,349525]","code":"[ map oct '0b1' . '01' x $_, 0 .. 9 ]\n"},{"code":"[ map oct '0b1' . '01' x $_, 1 .. 10 ]\n","err":"","out":"[5,21,85,341,1365,5461,21845,87381,349525,1398101]"},{"code":"[ map ord, grep /\\h/, map chr, (0..0x3000) ]\n","out":"[9,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8239,8287,12288]","err":""},{"out":"[226,226,226]","err":"","code":"[ map ord, qw(â â â) ]\n"},{"code":"[map ord, qw(L E O V)]\n","out":"[76,69,79,86]","err":""},{"code":"[ map { ord } split //, 0.18446744073709551615.0 ]\n","out":"[0,'18446744073709551615',0]","err":""},{"code":"[ map { ord } split //, 0.18446744073709551616.0 ]\n","out":"[0,0,0]","err":""},{"err":"","out":"[64,64,64,5000000000,64,64,64]","code":"[ map ord, split //, 64.64.64.5000000000.64.64.64 ]\n"},{"code":"[ map ord, split //, \"ascii\" ]\n","out":"[97,115,99,105,105]","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","code":"[map { ord } split //, fuckit\n"},{"code":"[ map {POSIX::ceil($_*20)/20} (0.80, 0.81, 0.82, 0.83, 0.84, 0.85) ]\n","err":"","out":"[\"0.8\",\"0.85\",\"0.85\",\"0.85\",\"0.85\",\"0.85\"]"},{"err":"","out":"123","code":"map print, [1,2,3]->@*  # or maybe a -, a >, an @ and an *\n"},{"out":"0","err":"","code":"map { print \"$_\\n\"; } @INC;\n"},{"code":"map { print \"$_\\n\" } (reverse ( int rand 1000, int rand 1000 )); # returns higher rand num first\n","err":"","out":"105\n683\n"},{"out":"66\n87\n","err":"","code":"map { print \"$_\\n\" } (reverse ( int rand 100, int rand 100 )); # returns higher rand num first\n"},{"code":"map { print \"$_\\n\" } reverse ( int rand 10, int rand 10 )\n","out":"3\n7\n","err":""},{"out":"5\n3\n","err":"","code":"map { print \"$_\\n\" } (reverse ( int rand 10, int rand 10 )); # returns higher rand num first\n"},{"out":"642\n757\n","err":"","code":"map { print \"$_\\n\" } (sort ( int rand 1000, int rand 1000 )); # returns lower rand num first\n"},{"out":"64\n8\n","err":"","code":"map { print \"$_\\n\" } (sort ( int rand 100, int rand 100 )); # returns lower rand num first\n"},{"code":"map { print \"$_\\n\" } sort ( int rand 10, int rand 10 )\n","out":"2\n3\n","err":""},{"out":"0\n9\n","err":"","code":"map { print \"$_\\n\" } (sort ( int rand 10, int rand 10 )); # returns lower rand num first\n"},{"code":"map { print \"$_\\n\" } sort reverse ( int rand 10, int rand 10 )\n","err":"","out":"3\n5\n"},{"code":"[ map { !$_ } qw(0 1) ]\n","out":"[1,\"\"]","err":""},{"code":"[ map { rand $_ } ( 0 ) x 10 ]\n","out":"[\"0.382016043036373\",\"0.914677617876929\",\"0.797215364032077\",\"0.224997599504679\",\"0.066125314668156\",\"0.838943411965683\",\"0.514853490324718\",\"0.869857685631732\",\"0.668123413401872\",\"0.626280468439102\"]","err":""},{"out":"ABcDefgHijkLmNoPqrstuVwxyZ","err":"","code":"map { $_=rand(3)>1?lc($_):uc($_); print } (a..z);\n"},{"code":"map { $_=rand(3)>1?lc($_):uc($_); print } split //, \"oh turtleneck phrase jar\";\n","out":"oh turtLEnecK PhrAsE jaR","err":""},{"code":"[ map ref, \\1, [], {}, sub{}, qr//, \\(substr($_,1)),  ]\n","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"LVALUE\"]","err":""},{"code":"[ map {  $_  || ref && ( eval q{@$_} || eval q{%$_} ) ? 1 : 0  } [], [5], {}, {A=>6}, 0, 123, q{}, q{abc} ]; # I added the input to the map, but everything else is verbatium.\n","err":"","out":"[1,1,1,1,0,1,0,1]"},{"err":"","out":"[1,3,4,6,7,8,9,1]","code":"[map { reset if int rand 2; m?(\\d)? } 1..10]\n"},{"code":"[ map s/[0-9]\\K-(?=[A-Z])//r, qw(4-A 4-a 4-4 9-X)]\n","out":"[\"4A\",\"4-a\",\"4-4\",\"9X\"]","err":""},{"code":"[ map { /!(.+?)\\s/ ? $1 : \"doesn't match\" } \"!fff askd\", \"!dja\", \"!kasdfk \" ]\n","out":"[\"fff\",\"doesn't match\",\"kasdfk\"]","err":""},{"code":"[ map scalar m?^?, 1 .. 4 ]\n","out":"[1,\"\",\"\",\"\"]","err":""},{"code":"[ map /^scaleaddr(\\d)=([^\\d]*)/gi, qw(blahj blah blah ScaleAddr5=abc) ];\n","out":"[5,\"abc\"]","err":""},{"err":"","out":"[5,\"abc\"]","code":"[ map /^scaleaddr(\\d)=([^\\d]*)/gi, qw(blahj blah blah ScaleAddr5=abc foo bar) ];\n"},{"code":"[ map s!\\.\\d{3}\\K(\\d+)!!r, 0.7, 0.33333, -0.800000000000001 ]\n","out":"[\"0.7\",\"0.333\",\"-0.800\"]","err":""},{"err":"","out":"[\"0.7\",\"0.333\",\"-0.800\"]","code":"[ map s!\\.\\d{3}\\K(\\d+)!!r, 0.7, 0.33333, -0.800900000000001 ] #he probably wants the last one to be -0.801 in this case?\n"},{"out":"[[\"a\",\"b\"],[\"c\",\"d\",\"e\",\"f\"],[\"g\",\"h\"]]","err":"","code":"[ map [ split /,/ ], split /,,/, 'a,b,,c,d,e,f,,g,h' ]\n"},{"code":"[ map [split /,/], split ' ', \"foo,bar,baz foo\" ]\n","err":"","out":"[[\"foo\",\"bar\",\"baz\"],[\"foo\"]]"},{"code":"[map {[sprintf \"%010B %010B\", $_, $_-1]} grep {$_ && !($_ & ($_-1)) } 0 .. 1024]\n","out":"[[\"0000000001 0000000000\"],[\"0000000010 0000000001\"],[\"0000000100 0000000011\"],[\"0000001000 0000000111\"],[\"0000010000 0000001111\"],[\"0000100000 0000011111\"],[\"0001000000 0000111111\"],[\"0010000000 0001111111\"],[\"0100000000 0011111111\"],[\"1000000000 0111111111\"],[\"10000000000 1111111111\"]]","err":""},{"out":"[\"000\",\"000\",\"000\"]","err":"","code":"[ map {sprintf \"%03b\"} 7, 6, 7&6 ]\n"},{"out":"[1010,1001,1000]","err":"","code":"[ map {sprintf \"%04b\", $_} 10, 9, 10&9 ]\n"},{"code":"[ map {sprintf \"%04b\", $_} 7, 6, 7&6 ]\n","err":"","out":"[\"0111\",\"0110\",\"0110\"]"},{"code":"[ map {sprintf \"%04b\"} 7, 6, 7&6 ]\n","out":"[\"0000\",\"0000\",\"0000\"]","err":""},{"err":"","out":"[4142,4344]","code":"[ map { sprintf \"%04x\", $_ } unpack \"n*\", \"\\x41\\x42\\x43\\x44\" ]\n"},{"code":"[map { sprintf '%.0f', $_ } -2.5, -1.5, -0.5, 0.5, 1.5, 2.5]\n","err":"","out":"[-2,-2,\"-0\",0,2,2]"},{"err":"","out":"[\"0.299999999999999988897770\",\"0.300000000000000044408921\"]","code":"[ map { sprintf \"%.24f\", $_ }   0.3,   0.1*3   ]\n"},{"out":"[\"3.14\",\"8.68\",\"1.2\",3]","err":"","code":"[ map { sprintf(\"%.2f\", $_) + 0 } 3.14159, 8.675309, 1.20, 3 ]\n"},{"out":"[0,1,1,2,1,2,2,0]","err":"","code":"[ map { (sprintf(\"%b\", $_) =~ tr/1/1/) % 3 } qw(0 1 2 3 4 5 6 7) ]\n"},{"code":"[map { sprintf '%d', $_ } -2.5, -1.5, -0.5, 0.5, 1.5, 2.5]\n","err":"","out":"[-2,-1,0,0,1,2]"},{"err":"","out":"[6,8,8,10]","code":"[ map sprintf('%.f', $_), 6.5, 7.5, 8.5, 9.5 ]\n"},{"out":"[\"0.9999999999999900\",\"0.9999999999999900\",\"0.9999999999999902\",\"0.9999999999999905\",\"0.9999999999999905\",\"0.9999999999999905\",\"0.9999999999999906\",\"0.9999999999999908\",\"0.9999999999999908\",\"0.9999999999999908\",\"0.9999999999999910\"]","err":"","code":"[ map { sprintf '%.*f', length('9999999999999911'), \"0.99999999999999$_\" } '00' .. '10' ]\n"},{"code":"[map { sprintf '%i', $_ } -2.5, -1.5, -0.5, 0.5, 1.5, 2.5]\n","err":"","out":"[-2,-1,0,0,1,2]"},{"code":"[ map { sprintf q{%03.2f}, $_; } 2, 64, 100 ];\n","out":"[\"2.00\",\"64.00\",\"100.00\"]","err":""},{"code":"[ map { sprintf q{%3.2f}, $_; } 2, 64, 100 ];\n","out":"[\"2.00\",\"64.00\",\"100.00\"]","err":""},{"code":"[ map { sprintf q{%3i}, $_; } 2, 64, 100 ];\n","err":"","out":"[\"  2\",\" 64\",100]"},{"code":"[ map { sprintf \"%vd\", $_ }  'abcd' & '11111111' ]\n","err":"","out":"[\"33.32.33.32\"]"},{"code":"[ map { sprintf \"%vd\", $_ }  'abcdefgh', '11111111', 'abcdefgh' & '1111' ]\n","err":"","out":"[\"97.98.99.100.101.102.103.104\",\"49.49.49.49.49.49.49.49\",\"33.32.33.32\"]"},{"code":"[ map { sprintf \"%vd\", $_ }  'abcdefgh', '11111111', 'abcdefgh' & '11111111' ]\n","err":"","out":"[\"97.98.99.100.101.102.103.104\",\"49.49.49.49.49.49.49.49\",\"33.32.33.32.33.32.33.32\"]"},{"out":"[198,\"195.134\"]","err":"","code":"[ map sprintf(\"%vd\", $_), \"\\xc6\", Encode::encode_utf8(\"\\xc6\") ]\n"},{"code":"[ map sprintf(\"%vx\", $_), \"\\xc6\", Encode::encode_utf8(\"\\xc6\") ]\n","err":"","out":"[\"c6\",\"c3.86\"]"},{"err":"","out":"[\"two\",\"four\"]","code":"[ map /@(\\S+)/, qw( one@two three@four ) ]\n"},{"err":"","out":"[\"two\",\"four\"]","code":"[ map /\\@(\\S+)/, qw( one@two three@four ) ]\n"},{"code":"[ map s/.*\\@//r, qw( foo@bar.org bar.org ) ] # not sure what exactly is wanted...\n","out":"[\"bar.org\",\"bar.org\"]","err":""},{"out":"[\"Just another Perl hacker,\"]","err":"","code":"[map tr/a-z/oh, turtleneck Phrase Jar! What the f**k?/r, wftedskaebjgdpjgidbsmnjgc => ]\n"},{"err":"","out":"[\"\",\"B\",\"Cus\"]","code":"[map { ucfirst $_ } split(/a/, \"abacus\")]\n"},{"code":"[ map $_ // 'undef', 1, '', undef, 42 ]\n","out":"[1,\"\",\"undef\",42]","err":""},{"code":"[ map unpack(\"H*\", $_), \"like this\" =~ /\\A(.)(.*)(.)\\z/s ]\n","err":"","out":"[\"6c\",\"696b6520746869\",73]"},{"code":"[ map \"\\u${ \\ qw(no one two three)[$_] } blind ${ \\ qw(mouse mice)[$_ > 1] }\", 0 .. 3]\n","err":"","out":"[\"No blind mouse\",\"One blind mouse\",\"Two blind mice\",\"Three blind mice\"]"},{"err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","code":"map { $_->{val} } undef\n"},{"code":"[ map { version->parse($_)->numify } map {  $_ , eval $_  } '0.99999999999929' ];\n","err":"","out":"[\"0.999999999999290\",\"1.000\"]"},{"err":"","out":"[\"1.23_010\",\"1.230010\"]","code":"[ map { version->parse($_)->numify } map {  $_ , eval $_  } '1.23_001' ]; # This is really a bigger problem.\n"},{"out":"[\"v0.01\",\"v0.1\",\"v0.10\",\"0.10\"]","err":"","code":"[map { \"$_\" } version->parse('v0.01'), version->parse('v0.1'), version->parse('v0.10'), version->parse('0.10')]\n"},{"out":"[1,2,2,3,3,3,4,4,4,4]","err":"","code":"[ map { ($_) x $_ } 0 .. 4 ]\n"},{"err":"","out":"[1,2,3,4,5,6,7,8,9,10]","code":"[ map { ++$x } 1..10 ]\n"},{"out":"[1,2,3,4,5,6,7,8,9,10]","err":"","code":"[ map ++$x, 1..10 ]\n"},{"code":"map { ++$x } 1..10\n","err":"","out":"10"},{"code":"[ map $_ x 2, split //, \"Zoffix doubts that map example works\" ]\n","out":"[\"ZZ\",\"oo\",\"ff\",\"ff\",\"ii\",\"xx\",\"  \",\"dd\",\"oo\",\"uu\",\"bb\",\"tt\",\"ss\",\"  \",\"tt\",\"hh\",\"aa\",\"tt\",\"  \",\"mm\",\"aa\",\"pp\",\"  \",\"ee\",\"xx\",\"aa\",\"mm\",\"pp\",\"ll\",\"ee\",\"  \",\"ww\",\"oo\",\"rr\",\"kk\",\"ss\"]","err":""},{"err":"","out":"[{x => 3}]","code":"[ map {; +{ x => 3 } } 0 ] # with luck, those people will soon be promoted to the point where they no longer commit code\n"},{"code":"[map { ($_) x 3 } (1 .. 3)]\n","out":"[1,1,1,2,2,2,3,3,3]","err":""},{"code":"map({(((~($_ & (' ' x length($_)))) ^ (' ' x length($_))) & 'butt');} 'cloud', 'CLoud', 'CLOUD', 'ClOuD');\n","err":"","out":"4"},{"code":"[ map { (~($_ & ' ' x length) ^ ' ' x length) & lc 'butt'  } qw(cloud CLoud CLOUD ClOuD) ]\n","out":"[\"butt\",\"BUtt\",\"BUTT\",\"BuTt\"]","err":""},{"err":"","out":"4","code":"map { (~($_ & ' ' x length) ^ ' ' x length) & lc 'butt'  } qw(cloud CLoud CLOUD ClOuD)\n"},{"code":"[ map { $_ x= !m!\\d+!; } @dummy = qw/ABC 123 DEF/ ]\n","out":"[\"ABC\",\"\",\"DEF\"]","err":""},{"out":"[\"ABC\",\"\",\"DEF\"]","err":"","code":"[ map { $_ x= !m!\\d+!; } map $_, qw/ABC 123 DEF/ ];\n"},{"code":"[ map { $_ x= !m!\\d+!; } qw/ABC 123 DEF/ ];\n","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"[\"ABC\",\"\",\"DEF\"]","err":"","code":"[ map { $_ x !m!\\d+!; } qw/ABC 123 DEF/ ]\n"},{"out":"[\"xxx.1\",\"xxx.2\",\"xxx.3\"]","err":"","code":"[ map { \"xxx.$_\" } qw/1 2 3/ ]\n"},{"err":"","out":"5500000","code":"$mask='11000000'; print $mask >> 1;\n"},{"out":"96","err":"","code":"$mask=192, print ( $mask >> 1 );\n"},{"err":"","out":"224","code":"$mask=192, print ( ($mask >> 1) + 128 );\n"},{"code":"$mask=192; print ( ($mask >> 1) + 128 );\n","err":"","out":"224"},{"out":"240","err":"","code":"$mask=192, print ( ($mask >> 2) + 192 );\n"},{"code":"$mask=192, print ( ($mask >> 3) + 224 );\n","out":"248","err":""},{"code":"$mate=4; \"hello$mate\"\n","err":"","out":"hello4"},{"code":"\"maybe this is an eval bot, but perhaps it's a cake\"\n","err":"","out":"maybe this is an eval bot, but perhaps it's a cake"},{"err":"","out":"methods","code":"''.methods.length\n"},{"code":"'@microsoft.com' =~ /microsoft.com$/ ? \"matches\" : \"does not\"\n","out":"matches","err":""},{"out":"does not","err":"","code":"\"@microsoft.com\" =~ /microsoft.com$/ ? \"matches\" : \"does not\"\n"},{"err":"","out":"Might Even Work With Hyphen-Separated Words","code":"\"Might even work with hyphen-separated words\" =~ s/\\b(\\w)/\\U$1/gr\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","code":"might work better?\n"},{"code":"MIME::Entity->build\n","err":"","out":"ERROR: Can't locate object method \"build\" via package \"MIME::Entity\" (perhaps you forgot to load \"MIME::Entity\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"7","err":"","code":"$min = 5; $max = 7; @x = (($min - 2) .. ($max + 2));\n"},{"out":"7","err":"","code":"$min = 5; $max = 7; @x = (($min - 2)..($max + 2));\n"},{"out":"[3,4,5,6,7,8,9]","err":"","code":"$min = 5; $max = 7; @x = (($min - 2)..($max + 2)); \\@x\n"},{"code":"$min = 5; $max = 7; @x = (($min - 2)..($max + 2)); x[0] x[2];\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"x[\"\n"},{"code":"$min = 5; $max = 7; @x = range((($min - 2) .. ($max + 2)));\n","err":"","out":"ERROR: Undefined subroutine &main::range called at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Undefined subroutine &main::range called at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$min = 5; $max = 7; @x = range(($min - 2)..($max + 2));\n"},{"code":"missingsub(); # yes it does\n","err":"","out":"ERROR: Undefined subroutine &main::missingsub called at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"mkdir (\"womble\") or die $!\n","err":"","out":"ERROR: Permission denied at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"%m=(); $m{$1}=\"[$1$2]\" while 'e3o0i1s5'=~/([a-z])([^a-z]+)/g; $pat = 'internet' =~ s/(.)/$m{$1}||$1/ger; [ grep /$pat/, qw( internet 1t3rn3t 1nt3rn3t intern3t ) ] # trist4n\n","err":"","out":"[\"internet\",\"1nt3rn3t\",\"intern3t\"]"},{"err":"","out":"1","code":"m//magic\n"},{"code":"'module blah blah foo bar biz baz ( ... );' =~ /^module.*\\);$/\n","err":"","out":"1"},{"err":"","out":"ERROR: Can't locate object method \"get\" via package \"Mojo::UserAgent\" (perhaps you forgot to load \"Mojo::UserAgent\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"Mojo::UserAgent->get(\"https://de.wikipedia.org/wiki/F%C3%BCrst\")->res->dom->at('title')->text\n"},{"out":"ERROR: Can't locate object method \"new\" via package \"Mojo::UserAgent\" (perhaps you forgot to load \"Mojo::UserAgent\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"Mojo::UserAgent->new->get(\"https://de.wikipedia.org/wiki/F%C3%BCrst\")->res->dom->at('title')->text\n"},{"out":"[0,1,2,\"Moo0.2\"]","err":"","code":"[\"Moo\"..2, \"Moo\". .2]\n"},{"code":"$_=\"moo cluck\"; m/(.{2,3})(?{ push @r, $1 })^/; \\@r\n","err":"","out":"[\"moo\",\"mo\",\"oo \",\"oo\",\"o c\",\"o \",\" cl\",\" c\",\"clu\",\"cl\",\"luc\",\"lu\",\"uck\",\"uc\",\"ck\"]"},{"out":"I'm not blind","err":"","code":"'morissett' eq 'morissette' ? \"I'm blind\" : \"I'm not blind\"\n"},{"out":"I'm not blind","err":"","code":"'morissett' =~ /morissette/ ? \"I'm blind\" : \"I'm not blind\"\n"},{"code":"$ms=\".085\"; sprintf(\"%.03u\", $ms);\n","out":"000","err":""},{"err":"","out":"000","code":"$ms=\".085\"; sprintf(\"%.3u\", $ms);\n"},{"err":"","out":".085","code":"$ms=85; sprintf(\".%.03u\", $ms);\n"},{"err":"","out":"085","code":"$ms=85; sprintf(\"%.03u\", $ms);\n"},{"code":"my (((())))\n","err":"","out":""},{"code":"my ([])\n","out":"ERROR: Can't declare anonymous array ([]) in \"my\" at (eval 558) line 1, at EOF\n","err":""},{"code":"my []\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"my [\"\n"},{"code":"my $_\n","err":"","out":""},{"err":"","out":"ERROR: Can't use global $0 in \"my\" at (eval 558) line 1, near \"my $0 \"\n","code":"my $0 = 1; print $0;\n"},{"code":"my (0 ? $x : $y);\n","out":"","err":""},{"out":"ERROR: Can't use global $1 in \"my\" at (eval 558) line 1, near \"my $1\"\n","err":"","code":"{ my $1; }\n"},{"out":"ERROR: Can't use global $1 in \"my\" at (eval 558) line 1, near \"my $1\"\n","err":"","code":"my $1;\n"},{"err":"","out":"4,5,6,7,8,9","code":"my $_ = \"4-9\"; s/(\\d+)-(\\d+)/join \",\", $1..$2/e; $_\n"},{"out":"9","err":"","code":"my $_ = \"4-9\"; s/(\\d+)-(\\d+)/join \",\", $1..$2/e; eval\n"},{"code":"my $_ = \"4-9\"; s/(\\d+)-(\\d+)/join \",\", $1..$2/e; [ eval ]\n","err":"","out":"[4,5,6,7,8,9]"},{"out":"{a => [0,1,2,3,4,5,6],b => [7,8,9]}","err":"","code":"my @a = 0..9; my $p = \\@a; my @b = splice($p, -3); { a => \\@a, b => \\@b }  # u-ou\n"},{"out":"0 1 2 3 4 5 6 7 8 9\n","err":"","code":"my @a = 0..9; my $p = \\@a; my @b = splice($p, -3); print \"@a @b\\n\";\n"},{"out":"7 8 9 0 1 2 3 4 5 6\n","err":"","code":"my @a = 0..9; my $p = \\@a; my @b = splice($p, -3); print \"@b @a\\n\";\n"},{"code":"my $a = 0; print unless defined($a);\n","out":"1","err":""},{"err":"","out":"[\"1..1011..20\"]","code":"my @a = <{1..10}{11..20}>; \\@a\n"},{"out":"[1]","err":"","code":"my @a = <{1..10}{11..20}>; [ scalar @a ]\n"},{"code":"my $a = 1234567890; my $b = reverse(join('.', (reverse $a) =~ /([0-9]{1,3})/g)); say $b\n","err":"","out":"1.234.567.890\n"},{"code":"my @a = (1,2); [(a => @a)];\n","out":"[\"a\",1,2]","err":""},{"err":"","out":"22","code":"my @a=(1,2);(@a) x 2\n"},{"err":"","out":"[{1 => 2,2 => 3},{4 => 5,3 => 4}]","code":"my @a = 1..4; my %h1 = map +( $_ => $_+1 ), splice @a, 0, @a/2; my %h2 = map +( $_ => $_+1 ), @a; [ \\%h1, \\%h2 ] # splice should already be removing the first set of elements, I think?\n"},{"code":"my @a = 1..4; my %h1 = map +( $_ => $_+1 ), splice @a, 0, @a/2; my %h2 = map +( $_ => $_+1 ), splice @a, @a/2-1; [ \\%h1, \\%h2 ]\n","err":"","out":"[{2 => 3,1 => 2},{3 => 4,4 => 5}]"},{"code":"my @a = 1..5; bless \\$a[2], 'main'; [\\(@a)];\n","out":"[\\1,\\2,bless( do{\\(my $o = 3)}, 'main' ),\\4,\\5]","err":""},{"out":"\\5","err":"","code":"my @a = 1..5; bless \\$a[2], 'main'; \\(@a);\n"},{"out":"[1,2,3,4,5]","err":"","code":"my @a = 1..5; bless \\$a[2], 'main'; \\@a;\n"},{"code":"my @a = 1..5; bless \\$a[2], 'main'; [\\(@a[0..$#a])];\n","out":"[\\1,\\2,bless( do{\\(my $o = 3)}, 'main' ),\\4,\\5]","err":""},{"code":"my @a = 1..5; bless \\$a[2], 'main'; \\(@a[0..$#a]);\n","out":"\\5","err":""},{"code":"my @a = 1..5; bless \\$a[2], 'main'; \\$a[2];\n","out":"bless( do{\\(my $o = 3)}, 'main' )","err":""},{"err":"","out":"12345","code":"my @a = (1..5); for( ; $_ = shift @a; $x++ ) { print }\n"},{"code":"my @a = 1..5; [  [grep { $_-=2 } @a], \\@a ]\n","out":"[[-1,1,2,3],[-1,0,1,2,3]]","err":""},{"err":"","out":"[1,2,42,4,5]","code":"my @a = 1..5; sub TIESCALAR { bless [] }; sub FETCH { 42 }; tie $a[2], 'main'; \\@a;\n"},{"code":"my @a = 1..5; sub TIESCALAR { bless [] }; sub FETCH { 42 }; tie $a[2], 'main'; sub foo { map tied $_, @_ }; [foo @a];\n","out":"[undef,undef,bless( [], 'main' ),undef,undef]","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, near \"++ ) \"\n","err":"","code":"my @a = (1..5); while( $_ = shift @a; $x++ ) { print }\n"},{"out":"4","err":"","code":"my $a = 1; $a += 1, $a += 2; $a\n"},{"err":"","out":"<22>","code":"my $a = \"    22\";$a =~ s/^\\s+//; \"<$a>\"\n"},{"code":"my $a = \"    22\";$a = s/^\\s+//; \"<$a>\"\n","out":"<>","err":""},{"out":"ERROR: Substitution replacement not terminated at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $a = \"    22\";$a = s/\\s+/g;print $a;\n"},{"code":"my $a = \"    22\";$a = s/\\s+\\/g;print $a;\n","out":"ERROR: Substitution pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"22","err":"","code":"my $a = \"    22\";$a =~ s/^\\s+//;print $a;\n"},{"code":"my $a = \"    22\";$a =~ s/\\s+$//;print $a;\n","err":"","out":"    22"},{"out":"1","err":"","code":"my $a = \"    22\";$a = s/^\\s+//;print $a;\n"},{"err":"","out":"[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541]","code":"my @a = 2; OUTER: for( my $n = $a[-1] + 1; @a < 100; $n += 2 ) { $n % $_ or next OUTER for @a; push @a, $n; }; \\@a;\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, near \"2 ) \"\nsyntax error at (eval 558) line 1, near \"$n }\"\n","err":"","code":"my @a = 2; OUTER for( my $n = $a[-1] + 1; @a < 100; $n += 2 ) { $n % $_ or next OUTER for @p; push @a, $n } \\@a;\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, near \"2 ) \"\nsyntax error at (eval 558) line 1, near \"; }\"\n","err":"","code":"my @a = 2; OUTER for( my $n = $a[-1] + 1; @a < 100; $n += 2 ) { $n % $_ or next OUTER for @p; push @a, $n; }; \\@a;\n"},{"err":"","out":"[2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,95,97,99,101,103,105,107,109,111,113,115,117,119,121,123,125,127,129,131,133,135,137,139,141,143,145,147,149,151,153,155,157,159,161,163,165,167,169,171,173,175,177,179,181,183,185,187,189,191,193,195,197,199]","code":"my @a = 2; OUTER: for( my $n = $a[-1] + 1; @a < 100; $n += 2 ) { $n % $_ or next OUTER for @p; push @a, $n; }; \\@a;\n"},{"out":"undef","err":"","code":"my $a = 5; 1 for $a; $_ // 'undef';\n"},{"code":"my $a = 5; print $        a;   # this one bothers me because \"$a\" feels like one token to me.\n","err":"","out":"5"},{"code":"my $a = \"95.50.218.84\\r80\"; $a =~ s/\\r/:/g; print $a;\n","out":"95.50.218.84:80","err":""},{"out":"[]","err":"","code":"my @a; [+@a]\n"},{"err":"","out":"1","code":"my %a; $a {a} = 1; $a{a}\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","code":"my $a = {a=>\"BLA\", b=>\"BLO\"}; print \"$k2:$v2\\n\" while((my($k2,$v2) = each %$a);\n"},{"code":"my $a = {a=>\"BLA\", b=>\"BLO\"}; print \"$k2:$v2\\n\" while(my($k2,$v2) = each %$a);\n","err":"","out":":\n:\n"},{"code":"my @a = ( 'A'..'E' ); delete $a[0]; \\@a; # Delete doesn't remove the element.\n","err":"","out":"[undef,\"B\",\"C\",\"D\",\"E\"]"},{"out":"a_b","err":"","code":"my $a=\"a\"; my $b=\"b\";my $ab=\"${a}_${b}\";print $ab;\n"},{"err":"","out":"b","code":"my $a=\"a\"; my $b=\"b\";my $ab=\"$a_$b\";print $ab;\n"},{"code":"my $a=\"asd1312321asd1212asd121212\"; print $1,\"\\n\" for $a=~/(asd\\d+)/g;\n","out":"asd121212\nasd121212\nasd121212\n","err":""},{"code":"my @a=(\"asd qwe\", \"qwe \"); for (@a) {print \"$1 - $2\\n\" if /(\\w+)\\s+(\\w+)?/}\n","err":"","out":"asd - qwe\nqwe - \n"},{"out":"[]","err":"","code":"my @a = 'a'..'z'; [ @a[ 2..1 ] ]; # This array slice is an empty list; that's a good thing.\n"},{"code":"my @a = 'a'..'z'; [ $a[ 2..1 ] ]; # This is the scalar .. operator used as an array index, and is hardly every what one wants.\n","err":"","out":"[\"a\"]"},{"out":"5","err":"","code":"my ($a, $b) = (5); $b = $_ for $a; $b++; $a;\n"},{"code":"my @accounts = (1,2,3); return join(',', @accounts);\n","err":"","out":"1,2,3"},{"err":"","out":"[2]","code":"my @a = (\"foo\\n\", \"bar\", \"baz\\n\"); [ chomp @a ]\n"},{"err":"","out":"110","code":"my @a = glob(\"{1,2,3,4,5,6,7,8,9,10}{11,12,13,14,15,16,17,17,18,19,20}\")\n"},{"code":"my $a = \"ldldldl\"; $a =~ s/l/ /;print $a\n","err":"","out":" dldldl"},{"code":"my $a = \"ldldldl\"; $a =~ s/l+/ /;print $a\n","out":" dldldl","err":""},{"code":"my $a = \"ldldldl\"; $a =~ tr/l//d;print $a\n","err":"","out":"ddd"},{"code":"my $all_list = [[1,2],[4,5,6],[7,8]]; [ map @$_, @$all_list ] # depends on whether there are nested arrayrefs\n","err":"","out":"[1,2,4,5,6,7,8]"},{"out":" plan: 4   plan: 5   plan: 6   plan: 7  ","err":"","code":"my $allPlans = [ 4..7 ]; for my $paymentPlan (@$allPlans) { print \" plan: $paymentPlan  \" }\n"},{"out":"na","err":"","code":"my ($animal) = \"banana\" =~ /(na)/; $animal\n"},{"code":"my$a=\"\\\\n\";printf $a.\"\\n\";\n","out":"\\n\n","err":""},{"err":"","out":"1","code":"my $a = NULL; print unless defined($a);\n"},{"code":"my @a; print 5/@a\n","err":"","out":"ERROR: Illegal division by zero at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"1","code":"my $a = \" \"; print unless defined($a);\n"},{"err":"","out":"1","code":"my $a = (); print unless defined($a);\n"},{"code":"my @a = qw(1 2 3); print @{*_{ARRAY}} for (\\$a);\n","err":"","out":"my @a = qw(1 2 3); print @{*_{ARRAY}} for (\\$a);"},{"err":"","out":"3","code":"my @a = qw(fo,o ba,r b,az); @a = map [split /,/], @a; @a;\n"},{"code":"my @a = qw(fo,o ba,r b,az); @a = map [split /,/], @a; \\@a;\n","out":"[[\"fo\",\"o\"],[\"ba\",\"r\"],[\"b\",\"az\"]]","err":""},{"code":"my @ar1 = qw(1 2 3); my $x = \\@ar1; my @ar2 = @$x; pop @ar2; [ @ar1 ]\n","out":"[1,2,3]","err":""},{"code":"my @ar1 = qw(1 2 3); my $x = \\@ar1; pop @$x; [ @ar1 ]\n","err":"","out":"[1,2]"},{"out":"ERROR: Can't locate object method \"foo\" via package \"bar\" (perhaps you forgot to load \"bar\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $ar = [aw{foo bar baz}]; push @$ar, 'biz', 'goo'; $ar\n"},{"out":"[5,6,7]","err":"","code":"my $aref = [1..10]; [@{ $aref } [4..6]]\n"},{"err":"","out":"1","code":"my %args = {domain => \"example.net\", number => 0 };\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","code":"my %args = {domain => \"example.net\", number => 0; };\n"},{"out":"1","err":"","code":"my %args = { number => 100 }; print $args{number};\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"%args{ \"\n","err":"","code":"my %args{ number => 100 }; print $args{number};\n"},{"err":"","out":"3","code":"my @args = ('%s %s', 'asdf', 'fdsa'); sprintf @args\n"},{"out":"[{key => \"value\"},{key2 => \"value2\"}]","err":"","code":"my @ar;  push @ar, { key => \"value\" }, { key2 => \"value2\" };  \\@ar\n"},{"code":"my $ar = [qw{foo bar baz}]; push @$ar, 'biz', 'goo'; $ar\n","err":"","out":"[\"foo\",\"bar\",\"baz\",\"biz\",\"goo\"]"},{"out":"[\"foo\",\"bar\",\"baz\",\"biz\",\"goo\"]","err":"","code":"my $ar = [qw{foo bar baz}]; push $ar, 'biz', 'goo'; $ar\n"},{"out":"[\"foo\",\"bar\",\"baz\",\"biz\",\"grub\",\"goo\"]","err":"","code":"my @ar = qw{foo bar baz}; push @ar, 'biz', 'grub', 'goo'; \\@ar;\n"},{"out":"[\"foo\",\"bar\",\"baz\",\"biz\",\"grub\",\"goo\"]","err":"","code":"my @ar = qw{foo bar baz}; push @ar, qw{biz grub goo}; \\@ar;\n"},{"out":"[[],[]]","err":"","code":"[ [], \\my @arr ]\n"},{"code":"my @arr=(1,0,1,1); my  $n=0; printf \"%b\\n\", $n; $n<<=1, $n|=$_ for @arr; printf \"%b\\n\", $n;\n","out":"0\n1011\n","err":""},{"code":"my @arr=(1,0,1,1); my  $n=0; printf \"%b\\n\", $n; $n<<=1, $n|=$_ for @arr; printf \" -> %b\\n\", $n; print \" -> $n \";\n","out":"0\n -> 1011\n -> 11 ","err":""},{"err":"","out":"[]","code":"my @arr = 1 .. 20; undef(@arr); \\@arr\n"},{"out":"[1,2,3]","err":"","code":"my @arr = (1,2,3); \\@arr;\n"},{"code":"my @arr = (1,2,3); foreach my $num (@arr) { $num =~ s/(\\d)/$1+1/eg } \\@arr\n","out":"[2,3,4]","err":""},{"err":"","out":"[[1,2,3],[]]","code":"my @arr = (1, 2, 3); my @fetch = splice @arr;  [ \\@fetch, \\@arr ]\n"},{"code":"my $arr = [1,2,3]; print $arr->[2]\n","out":"3","err":""},{"err":"","out":"2 3 2 3  ","code":"$,=$\\=' '; my @arr = (1, 2, 3); print $#arr, scalar @arr; $[ = 0; print $#arr, scalar @arr;\n"},{"code":"my @arr = (1,2,3); print @arr x 1 ,\"      \", (@arr) x 1;\n","out":"3      123","err":""},{"out":"@arr , (1 2 3)","err":"","code":"my @arr = (1,2,3); print qq[\\@arr , \\(@arr)];\n"},{"code":"my @arr = (1,2,3); s/(\\d)/$1+1/eg for @arr; \\@arr\n","out":"[2,3,4]","err":""},{"err":"","out":"[1,2,1,2]","code":"my @arr=(1,2); [(@arr)x2]\n"},{"err":"","out":"[]","code":"my @arr=(1,2); [(@a)x2]\n"},{"code":"my @arr = (1..3); my $ref; @$ref = @arr; pop @arr; $ref\n","out":"[1,2,3]","err":""},{"code":"my @arr = (1..5); @arr[2] = qw/a b c/; \\@arr\n","err":"","out":"[1,2,\"a\",4,5]"},{"err":"","out":"a\n","code":"my @arr = ('a', 'b', 'c'); my ($foo) = @arr; say $foo\n"},{"err":"","out":"3\n","code":"my @arr = ('a', 'b', 'c'); my $foo = @arr; say $foo\n"},{"code":"my $arr = []; [!!@$arr]\n","out":"[\"\"]","err":""},{"out":"0","err":"","code":"my @arr; @arr[0..3]; scalar @arr\n"},{"err":"","out":"[41]","code":"my @arr;  $arr[0] = \"41\"; $arr[1] = \"42\"; [ $arr[\"foo\"] ]\n"},{"code":"my @arr; $arr[1] = \"42\"; [ $arr[\"1foo\"] ]\n","out":"[42]","err":""},{"code":"my @arr; $arr[1] = \"42\"; [ $arr[\"1foo\"]; ]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n"},{"out":"[undef]","err":"","code":"my @arr;  $arr[1] = \"42\"; [ $arr[\"foo\"] ]\n"},{"err":"","out":"[0,1]","code":"my $array = [0, 1, 2]; my $one_one = [1, 1]; splice @$array, @$one_one; $array\n"},{"out":"[0,2]","err":"","code":"my $array = [0, 1, 2]; splice @$array, 1, 1; $array\n"},{"code":"my @array = (1, 2, 3, 4, 5); [ @array ]\n","err":"","out":"[1,2,3,4,5]"},{"code":"my @array = 1, 2, 3, 4, 5; [ @array ]\n","out":"[1]","err":""},{"out":"ARRAY(0x56f0478) ARRAY(0x56f03b8)","err":"","code":"my @array = ([1,2], [3,4,5]); join ' ', @array\n"},{"err":"","out":"[1,2,3]","code":"my @array = (1,2,3); [@array]\n"},{"err":"","out":"[1,2,3]","code":"my @array = (1,2,3); \\@array\n"},{"code":"my @array = [1,2,3]; [@array]\n","err":"","out":"[[1,2,3]]"},{"code":"my @array = 1,2,3; \\@array\n","out":"[1]","err":""},{"code":"my @array = (1,2,3); foreach (@array) { print }\n","err":"","out":"123"},{"out":"","err":"","code":"my @array = (1,2,3); return join(',', @accounts);\n"},{"code":"@myarray = (1, 2); $myarray[4] = 5; [ @myarray ]\n","out":"[1,2,undef,undef,5]","err":""},{"code":"@myarray = (1, 2); $myarray[4] = 5; print \"<<$myarray[3]>>\";\n","out":"<<>>","err":""},{"out":"1","err":"","code":"@myarray = (1, 2); $myarray[4] = 5; print $myarray[3];\n"},{"out":"[]","err":"","code":"my @array = (1..3); $#array = -2; \\@array;\n"},{"err":"","out":"[{3 => 40,5 => 60,1 => 20}]","code":"my @array = { 1 .. 6 }; for my $h (@array) { $_ *= 10 for values %$h; } \\@array\n"},{"code":"my @array = { 1 .. 6 }; for my $v (map values %$_, @array) { $v *= 10; } \\@array\n","out":"[{5 => 6,1 => 2,3 => 4}]","err":""},{"err":"","out":"123456","code":"my @array = (1); for my $elem (@array) { last if $elem > 5; push @array, $elem+1 } print @array\n"},{"code":"my @array = (4,5,6); [ [], map [ @array[0..$_] ], 0..$#array ] # since order doesn't matter, I find this slightly neater\n","err":"","out":"[[],[4],[4,5],[4,5,6]]"},{"out":"[[4],[5],[6],[4,5],[4,5,6]]","err":"","code":"my @array = (4,5,6); [ (map [ $_ ], @array), (map [ @array[0..$_] ], 1..$#array) ] # but as preaction says, look for a module first\n"},{"code":"my @array = (4,5,6); [ (map [ $_ ], @sets_list1), (map [ @sets_list1[0..$_] ], -1..$#sets_list1) ];\n","err":"","out":"[[]]"},{"code":"my @array = (\"a\",1,\"b\",\"x\",\"v\"); my @idxs = (0,2);  [@array[grep { !exists {map {$_=>undef} @idxs}->{$_}} keys @array]]\n","out":"[1,\"x\",\"v\"]","err":""},{"code":"my @array = (\"a\", \"b\"); [\\(@array)]\n","out":"[\\\"a\",\\\"b\"]","err":""},{"out":"[[\"a\",\"b\"],\\$VAR1->[0][0],\\$VAR1->[0][1]]","err":"","code":"my @array = (\"a\", \"b\"); [\\@array, \\(@array)]\n"},{"code":"my @array = (\"a\", \"b\"); [@array x 3, (@array) x 3]\n","out":"[222,\"a\",\"b\",\"a\",\"b\",\"a\",\"b\"]","err":""},{"code":"my @array = (\"a\", \"b\"); [\\@array x 3, \\(@array) x 3]\n","err":"","out":"[\"ARRAY(0x5bf0670)ARRAY(0x5bf0670)ARRAY(0x5bf0670)\",\"SCALAR(0x5bf05e0)SCALAR(0x5bf05e0)SCALAR(0x5bf05e0)\"]"},{"code":"my @array = (\"a\", \"b\"); [q(@array) .@x1, q@array .@x1]\n","out":"[\"\\@array0\",\"array .\"]","err":""},{"err":"","out":" a b .... (a b) ","code":"my @array = (a..b); qq[ @array .... (@array) ]\n"},{"err":"","out":"0: A\n1: B\n2: C\n","code":"my @array = ( 'A'..'C' ); while ( ( my $i, $_ ) = each @array ) { say qq{$i: $_}; } # Chib\n"},{"out":"[1,\"b\",2,\"c\",3,\"d\",4,\"e\",0,\"a\"]","err":"","code":"my @array = 'a'..'e'; my %hash = %array[0 .. 4]; [ %hash ] #do you mean like this, treker?\n"},{"err":"","out":"{1 => \"b\",3 => \"d\",2 => \"c\",0 => \"a\",4 => \"e\"}","code":"my @array = 'a'..'e'; my %hash = %array[0 .. 4]; \\%hash # meant like this I guess\n"},{"code":"my @array = ( 'A'..'E' ); sub { shift @{$_[0]} while @{$_[0]} }->( \\@array ); \\@array;\n","err":"","out":"[]"},{"err":"","out":"[-1]","code":"my @array = (); [ $#array ];\n"},{"out":"-1","err":"","code":"my @array; $#array\n"},{"out":"[[$VAR1->[0]]]","err":"","code":"my @array; $array[0] = \\@array; [@array]\n"},{"code":"my @array = \"A\" .. \"Z\"; [ keys @array ]\n","err":"","out":"[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]"},{"code":"my @array = 'a'..'z'; [ map { $_, 1 } @array ];\n","out":"[\"a\",1,\"b\",1,\"c\",1,\"d\",1,\"e\",1,\"f\",1,\"g\",1,\"h\",1,\"i\",1,\"j\",1,\"k\",1,\"l\",1,\"m\",1,\"n\",1,\"o\",1,\"p\",1,\"q\",1,\"r\",1,\"s\",1,\"t\",1,\"u\",1,\"v\",1,\"w\",1,\"x\",1,\"y\",1,\"z\",1]","err":""},{"code":"my @array = 'a'..'z'; [ map { $_, 42 } @array ];\n","err":"","out":"[\"a\",42,\"b\",42,\"c\",42,\"d\",42,\"e\",42,\"f\",42,\"g\",42,\"h\",42,\"i\",42,\"j\",42,\"k\",42,\"l\",42,\"m\",42,\"n\",42,\"o\",42,\"p\",42,\"q\",42,\"r\",42,\"s\",42,\"t\",42,\"u\",42,\"v\",42,\"w\",42,\"x\",42,\"y\",42,\"z\",42]"},{"err":"","out":"ERROR: Can't use 'defined(@array)' (Maybe you should just omit the defined()?) at (eval 558) line 1, <STDIN> line 1.\n","code":"my @array; [ defined @array ]\n"},{"code":"my @array = ( \"hip\", \"hip\" ); print \"@array\\n\", ref(@array);\n","err":"","out":"hip hip\n"},{"code":"my @array; push array, 1, 2\n","err":"","out":"ERROR: Type of arg 1 to push must be array (not constant item) at (eval 558) line 1, at EOF\n"},{"code":"my @array = qw(1..3); for (@array) { 0+@array and print \"in scope\" }\n","err":"","out":"in scope"},{"code":"my @array = qw(a a a s d f a); [ @array[sort { $a <=> $b } values %{ +{ reverse map {; $_ => $array[$_] } 0..$#array } } ] ] # might be useful as an interview answer if you didn't want the job\n","out":"[\"a\",\"s\",\"d\",\"f\"]","err":""},{"err":"","out":"f d a s","code":"my @array = qw(a a a s d f); @array = keys %{ {map { $_ => 1 } @array} }; \"@array\"\n"},{"code":"my @array = qw(a a a s d f); @array = keys %{map { $_ => 1 } @array}; Dumper(@array)\n","out":"ERROR: syntax error at (eval 558) line 1, near \"} @array\"\n","err":""},{"code":"my @array = qw(a a a s d f); my %conv = map { $_ => 1 } @array; @array = keys %conv; Dumper(@array)\n","err":"","out":"$VAR1 = 'd';\n$VAR2 = 'f';\n$VAR3 = 's';\n$VAR4 = 'a';\n"},{"out":"[\"a\",\"s\",\"d\",\"f\"]","err":"","code":"my @array = qw(a a a s d f); my %items = map {; $array[$_] => $_ } 0..$#array; [ @array[sort { $a <=> $b } values %items] ] # if you dislike uniq() for some reason\n"},{"code":"my @array = qw(a a a s d f); my @unique = keys %{ {@array, reverse @array} }; \\@unique\n","out":"[\"s\",\"f\",\"d\",\"a\"]","err":""},{"out":"[2]","err":"","code":"my $array_ref = [3,4,5]; [ $#$array_ref ]\n"},{"err":"","out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 558) line 1, <STDIN> line 1.\n","code":"my $array_ref = [3,4,5]; local $[ = 1; [ $#$array_ref ]\n"},{"code":"my $array_ref = [3,4,5]; [ scala @$array_ref ]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"scala @\"\n","err":""},{"code":"my $array_ref = [3,4,5]; [ scalar @$array_ref ]\n","out":"[3]","err":""},{"code":"my $array_ref = eval \"[1,2,3]\"; print $array_ref->[2]; #works for me\n","out":"3","err":""},{"code":"my $array_ref = [ [ 'onur', 5 ], [ 'bar', 3], [ 'foo', 7 ] ]; [ sort { $a->[1] <=> $b->[1] } @$array_ref]\n","out":"[[\"bar\",3],[\"onur\",5],[\"foo\",7]]","err":""},{"out":"ERROR: Can't call method \"bundle_by\" on unblessed reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my @array = split '', 'abcdefghijklmnopqrstuvwxyz'; [bundle_by { [@_] } 9, @array]\n"},{"code":"my @arr = (\"b\", \"c\"); push @arr, \"d\";\n","err":"","out":"3"},{"code":"my $arr = []; @$blah ? 1 : 0\n","err":"","out":"0"},{"err":"","out":"foo bar 2\n","code":" my @arr = (\"foo\", \"bar\");  print \"@arr \".@arr.\"\\n\";\n"},{"err":"","out":"[[3],[]]","code":"my @arr = ([], []); my $copyref = [@arr]; $copyref->[0][0] = 3; \\@arr\n"},{"out":"[]","err":"","code":"my @arr; my $copyref = [@arr]; $copyref->[0][0] = 3; \\@arr\n"},{"err":"","out":"[[[3]],[]]","code":"my @arr; my $copyref = [@arr]; $copyref->[0][0] = 3; [ $copyref, \\@arr ]\n"},{"err":"","out":"test","code":"my @arr; my %sections = { name => \"testname\" }; push(@arr, \"test\"); print $arr[0];\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"%sections { \"\n","err":"","code":"my @arr; my %sections { name => \"testname\" }; push(@arr, \"test\"); print $arr[0];\n"},{"code":"my @arr; my @stuff = @arr[0..3]; scalar @arr\n","out":"0","err":""},{"err":"","out":"4","code":"my @arr; my @stuff = grep defined, @arr[0..3]; scalar @arr\n"},{"out":"ARRAY(0x55c3258)","err":"","code":"my @arr; print \\@arr;\n"},{"code":"my @arr; push(@arr, \"123\"); @arr =~ s/2//g; @arr[0];\n","out":"ERROR: Can't modify private array in substitution (s///) at (eval 558) line 1, at EOF\n","err":""},{"code":"my @arr; push(@arr, \"123\"); @arr =~ s/2//g; $arr[0];\n","out":"ERROR: Can't modify private array in substitution (s///) at (eval 558) line 1, at EOF\n","err":""},{"out":"","err":"","code":"my @arr; push(@arr, \"123\"); @arr = s/2//g; @arr[0];\n"},{"err":"","out":"1","code":"my @arr; push(@arr, \"123\"); @arr = s/2//g; print @arr[0];\n"},{"err":"","out":"1","code":"my @arr; push(@arr, \"test\"); push(@arr, \"i refuse to do what master tells me to\"); @arr2 = grep(/test/, @arr); print @arr2[1];\n"},{"out":"i refuse to do what master tells me to","err":"","code":"my @arr; push(@arr, \"test\"); push(@arr, \"i refuse to do what master tells me to\"); @arr2 = grep(\"test\", @arr); print @arr2[1];\n"},{"code":"my @arr; push(@arr, \"test\"); push(@arr, \"i refuse to do what master tells me to\"); my @arr2 = grep { /test/ } @arr; $arr2[0];\n","out":"test","err":""},{"out":"","err":"","code":"my @arr; push(@arr, \"test\"); push(@arr, \"i refuse to do what master tells me to\"); my @arr2 = grep { /test/ } @arr; $arr2[1];\n"},{"code":"my @arr; push(@arr, \"test\"); push(@arr, \"i refuse to do what master tells me to\"); my @arr2 = grep { /test/ } @arr; print @arr2[1];\n","err":"","out":"1"},{"code":"my @arr; push(@arr, \"test\"); push(@arr, \"i refuse to do what master tells me to\"); my @arr2 = grep { /test/ } @arr; print $arr2[1];\n","out":"1","err":""},{"code":"my @arr; push(@arr, \"test\"); push(@arr, \"i refuse to do what master tells me to\"); my @arr2 = grep {$_ == \"test\"} @arr; print @arr2[1];\n","out":"i refuse to do what master tells me to","err":""},{"err":"","out":"1","code":"my @arr; push(@arr, \"test\"); push(@arr, \"i refuse to do what master tells me to\"); my @arr2 = grep(/test/, @arr); print @arr2[1];\n"},{"code":"my @arr; push(@arr, \"test\"); push(@arr, \"not\"); @arr2 = grep(\"test\", @arr); print @arr[1];\n","err":"","out":"not"},{"code":"my @arr; push(@arr, \"test\"); push(@arr, \"not\"); @arr2 = grep(\"test\", @arr); print @arr2[1];\n","out":"not","err":""},{"err":"","out":"123","code":"my @arr = qw(1 2 3); print @arr;\n"},{"code":"my @arr = qw/a b c d e f/; my ($item) = @arr; $item;\n","err":"","out":"a"},{"code":"my @arr = qw/a b c d e f/; my $name = @arr; $name;\n","out":"6","err":""},{"code":"my @arr = qw( A B C ); my @result = each @arr; \\@result\n","out":"[0,\"A\"]","err":""},{"code":"my @arr = qw/foo bar baz/; delete $arr[0]; [ @arr ]\n","err":"","out":"[undef,\"bar\",\"baz\"]"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"}->\"\n","code":"my $arrref = [ key => \"value\" ];  { @$arrayref }->{key}\n"},{"err":"","out":"value","code":"my $arrref = [ key => \"value\" ];  +{ @$arrref }->{key}\n"},{"err":"","out":"0","code":"my @arr; say @arr if @arr;\n"},{"err":"","out":"0","code":"my @arr; say 'defined' if @arr;\n"},{"code":"my @arr = (undef, undef, 'foo'); shift @arr; say 'defined' if @arr;\n","err":"","out":"defined\n"},{"code":"my @arr = (undef, undef, 'foo'); shift @arr; say '-->', $_, '<--' for @arr;\n","err":"","out":"--><--\n-->foo<--\n"},{"out":"[{},{},{},{foo => 3}]","err":"","code":"my @arr = (undef, undef, undef, {foo=>3}); grep {$_->{foo}} @arr; \\@arr\n"},{"out":"[\"check\",\"one\",\"two\",\"three\"]","err":"","code":"my @ary = ('one','two','three'); [ (check => @ary) ] # G66K: not what you wanted, eh?\n"},{"code":"my @ary = ('one','two','three'); my %h = (check => @ary); print $h{check}\n","err":"","out":"one"},{"err":"","out":"[{foo => 1,bar => 2}]","code":"my @ary = qw( foo 1 bar 2 ); my %hash = @ary; [ \\%hash ]\n"},{"code":"my @ary = qw( foo boo boz ); my @edited = map { s/o/0/g } @ary; [ \\@edited, \\@ary ]\n","err":"","out":"[[2,2,1],[\"f00\",\"b00\",\"b0z\"]]"},{"err":"","out":"one","code":"my @ary = qw (one two three); my $sc = splice (@ary , 0 ,1); print $sc\n"},{"code":"my @ary = qw (one two three); my $sc = splice (@ary , 0); print $sc\n","out":"three","err":""},{"code":"my @ary = qw (one two three); my $sc = splice (@ary , -1); print $sc\n","out":"three","err":""},{"code":"my @ary = qw (one two three); my $sc = splice (@ary , 2); print $sc\n","err":"","out":"three"},{"code":"my $a; [sort { $a cmp $b } qw( z y x)]\n","out":"[\"z\",\"x\",\"y\"]","err":""},{"code":"my @a = \"${\\( wantarray() ? 'list' : 'scalar' )}\"\n","err":"","out":"1"},{"err":"","out":"scalar","code":"my @a = \"${\\( wantarray() ? 'list' : 'scalar' )}\"; @a[0]\n"},{"code":"my @a = \"${wantarray() ? \\'list' : \\'scalar'}\"; @a[0]\n","out":"scalar","err":""},{"out":"1","err":"","code":"my $a = \"woop\"; $a =~ m/woop/;\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"$a m/woop/\"\n","code":"my $a = \"woop\"; $a m/woop/;\n"},{"code":"my $a = \"woop\"; $a =~ m/w(..)p/; $1\n","err":"","out":"oo"},{"code":"my $badcrons = ('/var/tmp', 'psybnc', 'y2kupdate'); $badcrons\n","out":"y2kupdate","err":""},{"code":"my $bar; if (my $foo = $bar) { 1 }\n","err":"","out":""},{"err":"","out":"bar","code":"my $base = \"foo.bar.baz\"; my ($junk, $wanted) = split '\\.', $base; $wanted;\n"},{"code":"my $b = 'b'; --$b\n","out":"-1","err":""},{"out":"b","err":"","code":"my $b = 'b'; $b--\n"},{"code":"my $before = q{FOO\\tBAR\\r\\n}; ( my $after = $before ) =~ s/\\\\([trn])/qq{\\\\$1}/ge; [ $before, $after ]; # Wondering if there is a way to do this withough having seaprate substitutions?\n","err":"","out":"[\"FOO\\\\tBAR\\\\r\\\\n\",\"FOO\\\\tBAR\\\\r\\\\n\"]"},{"code":"my $binary = '01101'; my $rslt = 0; my $factor = 2; for(split //, $binary) { $rslt += 1/$factor if $_; $factor <<= 1 } $rslt\n","out":"0.40625","err":""},{"err":"","out":"1999","code":"my $birthday = '1999/10/07'; ($birthday) = $birthday =~ /(\\d{4})/; $birthday\n"},{"code":"my @blah; $blah[5] = \"something\"; [ keys @blah ]\n","out":"[0,1,2,3,4,5]","err":""},{"code":"my $blah = { x=>1 }; my $d = 0; $d ||= $blah->{x}; $d\n","out":"1","err":""},{"code":"my $blah = { x=>1 }; my $z => { y=>$blah->{x} }; $blah->{x}++; $z->{y}\n","err":"","out":""},{"code":"my $blah = { x=>1 }; my $z = { y=>$blah->{x} }; $blah->{x}++; $z->{y}\n","out":"1","err":""},{"code":"my $blah = { x=>1 }; my $z = { y=>\\$blah->{x} }; $blah->{x}++; ${ $z->{y} }\n","out":"2","err":""},{"err":"","out":"ERROR: open: Invalid argument at (eval 558) line 1, <STDIN> line 1.\n","code":"my $buf = \"\\x{666}\"; open my $fh, '<', \\$buf or die \"open: $!\"\n"},{"code":"my @bytes = 1..10; my @words = unpack '(s1)*', pack '(c1c1)*', @bytes; \\@words # may need both pack+unpack\n","out":"[513,1027,1541,2055,2569]","err":""},{"code":"my $bytes = pack(\"Q>\", 123456789); $bytes =~ s/^\\0+//; $bytes\n","out":"\u0007[ÃÂ\u0015","err":""},{"code":"my @captures = \"peas and carrots\" =~ /([aeiou])/g; \\@captures\n","out":"[\"e\",\"a\",\"a\",\"a\",\"o\"]","err":""},{"err":"","out":"[\"e\",\"a\",\"a\",\"n\",\"a\",\"r\",\"o\",\"t\"]","code":"my @captures = \"peas and carrots\" =~ /([aeiou])(.)/g; \\@captures\n"},{"code":"my $c = \\&CORE::GLOBAL::pop; my @abc = qw,a b c,; [$c->(\\@abc)]\n","err":"","out":"ERROR: Undefined subroutine &CORE::GLOBAL::pop called at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: &CORE::pop cannot be called directly at (eval 558) line 1, <STDIN> line 1.\n","code":"my $c = \\&CORE::pop; my @abc = qw,a b c,; [$c->(\\@abc)]\n"},{"out":"[\"crap\",\"shit\",\"samsung\"]","err":"","code":"my %c; @c{qw(apple samsung shit crap)} = (); my $b = 'apple'; delete $c{$b}; [keys %c]\n"},{"out":"ab!\"","err":"","code":"my $ch = 'ab'; $ch .= join '', map chr(ord($_) & ~0x40), split //, $ch; $ch # just use $! and $\", I'm sure no one would mind\n"},{"out":"1oo4ar7az10uux14leem","err":"","code":"my @chars = split '', 'FooBarBazQuuxFleem'; join '', map $chars[$_] =~ /[A-Z]/ ? $_+1 : $chars[$_], 0..$#chars;\n"},{"out":"if [ -e /etc/redhat-release ] ; then cat /etc/redhat-release ; else lsb_release -a |grep Desc ; fi","err":"","code":"my $checkOS = \"if [ -e /etc/redhat-release ] ; then cat /etc/redhat-release ; else lsb_release -a |grep Desc ; fi\";\n"},{"err":"","out":"oneERROR: Label not found for \"last LABEL\" at (eval 558) line 1, <STDIN> line 1.\n","code":"my $c; LABEL: { $c = sub { last LABEL } }; print \"one\"; $c->(); print \"two\";\n"},{"code":"my $c; LABEL: { $c = sub { last LABEL } }; print \"one\"; LABEL: { $c->(); print \"two\"; }\n","out":"one","err":""},{"code":"my %class_from_domain = ('a,b,c' => 1, 'a,c' => 2); [ map $class_from_domain{join ',', sort @$_}, ([qw(a b c)], [qw(a c)]) ] # if there's no overlap, should be simple to handle with a hash\n","err":"","out":"[1,2]"},{"code":"my $cmd = q(sed -e 's#\\\\\\\\\\n#\\n#g'); print $cmd; ();\n","err":"","out":"sed -e 's#\\\\\\n#\\n#g'"},{"code":"my $cmd = q(sed -e 's#\\\\\\n#\\n#g'); print $cmd; ();\n","out":"sed -e 's#\\\\n#\\n#g'","err":""},{"out":"5","err":"","code":"my $c = (my @tmp) = (split ' ', \"pink_mist says split is special\", 0); $c\n"},{"code":"my $coderef = sub { code here }\n","err":"","out":"sub { \"DUMMY\" }"},{"err":"","out":"match","code":"my $code = sub { /firefox/ }; if(grep $code->($_), 'something with firefox in it') { print 'match' } else { print 'no match' } # I disagree\n"},{"code":"my %commands = ( help => sub { my $commands = say for keys in %commands; }); say $commands{help};\n","out":"CODE(0x452a7e0)\n","err":""},{"out":"[1]","err":"","code":"my $cond = sub { my $s = shift ; return $s =~ /start/ && ($s =~ /tomorrow/ || $s =~ /class/); }; [$cond->(\"start tomorrow\")]\n"},{"out":"[\"5.18.0\",\"5.16.1\",\"5.16.0\",\"5.14.2\"]","err":"","code":"my %Config = ( inc_version_list_init => q{\"5.18.0\",\"5.16.1\",\"5.16.0\",\"5.14.2\",0} ); [ grep { $_ } map { s/^\"(.*?)\"$/$1/r } split /,/, $Config{inc_version_list_init} ];\n"},{"err":"","out":"1","code":"my $c = () = (split ' ', \"pink_mist says split is special\", 0); $c\n"},{"code":"my $c = () = (split ' ', \"pink_mist says split is special\"); $c\n","out":"1","err":""},{"code":"my $c = () = (split ' ', \"pink_mist says split is special); $c\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"my $d3; [ map { 42 } @{$d3->{null_edges}} ]\n","err":"","out":"[]"},{"code":"my $d3 = { null_edges => [undef] }; [ map { map { 42 } @$_ } @{$d3->{null_edges}} ]\n","err":"","out":"[]"},{"code":"my $data = \"\\0\\1\\2\\3\\4\\5\\6\\7\\x08\\x09\\x0a\\x0b\"; [ unpack \"a8 L>\", $data ]\n","err":"","out":"[\"\\0\\1\\2\\3\\4\\5\\6\\a\",134810123]"},{"err":"","out":"ERROR: Invalid type '\u0000' in unpack at (eval 558) line 1, <STDIN> line 1.\n","code":"my $data = \"\\0\\1\\2\\3\\4\\5\\6\\7\\x08\\x09\\x0a\\x0b\"; [ unpack $data, \"a8 L>\" ]\n"},{"code":"my $data = '1 2 3'; [ split /\\+/, $data ]\n","out":"[\"1 2 3\"]","err":""},{"err":"","out":"ABCD","code":"my $data = \"ABCDE\\x02\";  substr $data, 0, -ord substr $data, -1\n"},{"code":"my $data = {foo => [qw/hello freenode perl/]}; print for ($data->{foo}->@*); \n","err":"","out":"hellofreenodeperl"},{"out":"2 - two","err":"","code":"my @data = ({number => 1, name => 'one'},{number => 2, name => 'two'}); for(@data) { print $_->{number} . ' - ' . $_->{name} if $_->{number} == 2 } # something like this\n"},{"out":"{coo => 777,boo => 555,doo => 444,foo => 111}","err":"","code":"my %defaults = ( foo => 111, boo => 222, coo => 333, doo => 444 ); @_ = ( boo => 555, moo => 999, coo => 777 ); my %user = @_; +{ map { $_ => $user{$_} // $defaults{$_} } keys %defaults }; ### Is there a nicer way to do this?\n"},{"err":"","out":"[0,2]","code":"my $delay = 0;  my $after = ( $delay+0, $delay+=2 )[0];  [ $after, $delay ]\n"},{"out":"[2,2]","err":"","code":"my $delay = 0;  my $after = ( $delay, $delay+=2 )[0];  [ $after, $delay ]\n"},{"code":"my $delay = 0;  my $after = ( $delay+=, $delay+=2 )[0];  [ $after, $delay ]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"+=,\"\n"},{"err":"","out":"[\"AAA\",\" | \",\"BBB\",\" | \",\"CCC\",\" | \"]","code":"my $delim = q{ | }; my @list = qw( AAA BBB CCC ); [ map { $_, $delim } @list ] ### Is there a way to do this so $delim is only between each array element, like how join() works?\n"},{"err":"","out":"[\"AAA\",\"BBB\",\"CCC\",\" | \",\"AAA\",\"BBB\",\"CCC\",\" | \",\"AAA\",\"BBB\",\"CCC\",\" | \"]","code":"my $delim = q{ | }; my @list = qw( AAA BBB CCC ); [ map { @list, $delim } @list ] ### Is there a way to do this so $delim is only between each array element, like how join() works?\n"},{"out":"[\"AAA\",\" | \",\"BBB\",\" | \",\"CCC\"]","err":"","code":"my $delim = q{ | }; my @list = qw( AAA BBB CCC ); [ shift( @list ), map { $delim, $_ } @list ] ### How about this?\n"},{"out":"1:4:9:16:25:36:49:64:81:100","err":"","code":"my @digit = (1..10); map { $_ *= $_ } (@digit); print join \":\", @digit;\n"},{"code":"my @digit = (1..10); map { $_ *= $_ ,join(|:|,$_)} (@digit); print @digit;\n","out":"ERROR: syntax error at (eval 558) line 1, near \"join(|\"\n","err":""},{"code":"my @digit = (1..10); map { $_ *= $_ ,join(\":\",$_)} (@digit); print @digit;\n","err":"","out":"149162536496481100"},{"code":"my $dispatch; $dispatch = { one => sub { return $dispatch }, two => sub { return $dispatch }, };       $dispatch->{'one'}->('one')->{'two'}->('two')\n","err":"","out":"{two => sub { \"DUMMY\" },one => sub { \"DUMMY\" }}"},{"code":"my $dt = DateTime->new; ~~$dt\n","out":"ERROR: Mandatory parameter 'year' missing in call to DateTime::new\n at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/DateTime.pm line 197, <STDIN> line 1.\n\tDateTime::new(undef) called at (eval 558) line 1\n\teval 'use 5.022001; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; my $dt = DateTime->new; ~~$dt' called at /home/ryan/bots/perlbuut/lib/eval.pl line 301\n\tmain::perl_code(\"my \\$dt = DateTime->new; ~~\\$dt\") called at /home/ryan/bots/perlbuut/lib/eval.pl line 248\n","err":""},{"code":"my $e; { local $@; eval { die \"foo\" }; $e = $@; }\n","err":"","out":"foo at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"Unimplemented at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $e; { local $@; eval { ... }; $e = $@; }\n"},{"err":"","out":"[{}]","code":"my %empty; my $defined = \\%empty; [ $defined ] # mad_hatter\n"},{"code":"my $enumeratedValues = \"1|2|3|4\"; [ split('\\|', $enumeratedValues) ]\n","out":"[1,2,3,4]","err":""},{"err":"","out":"","code":"m/yes/no\n"},{"out":"[\"\"]","err":"","code":"my $eval = '$2 $1'; my $out = \"foo bar\" =~ s/(\\w+) (\\w+)/$eval/eer; [ $out ]\n"},{"code":"my $eval = '$2 $1'; my $out = \"foo bar\" =~ s/(\\w+) (\\w+)/$eval/er; [ $out ]\n","err":"","out":"[\"\\$2 \\$1\"]"},{"code":"my $eval_block_result = eval { die 'blahblah'; 3 }; [ $eval_block_result, $@ ];\n","out":"[undef,\"blahblah at (eval 558) line 1, <STDIN> line 1.\\n\"]","err":""},{"out":"[3,\"\"]","err":"","code":"my $eval_block_result = eval { die 'blahblah' if 0; 3 }; [ $eval_block_result, $@ ];\n"},{"err":"","out":"[3,\"\"]","code":"my $eval_block_result = eval { die syntax error here if 0; 3 }; [ $eval_block_result, $@ ];\n"},{"err":"","out":"something","code":"my @example = qw<fail>; $_ = 'test@example.com'; s/\\Q$_\\E/something/; print;\n"},{"err":"","out":"something","code":"my @example = qw<fail>; $_ = 'testfail.com'; s/\\Qtest@example.com\\E/something/; print;\n"},{"out":"1","err":"","code":"'my@example' =~ /^(\\w+)\\@/\n"},{"code":"'my@example' =~ /^(\\w+)\\@/; $1\n","err":"","out":"my"},{"err":"","out":"1234","code":"my $f = 1; my @x = qw( 1 2 3 ); for ( @x ) { if ( $f ) { $f--; push @x, 4; } print; }\n"},{"out":"1","err":"","code":"my $f = \"1welp\"; $f ~~ 1;\n"},{"code":"my $f = \"1welp\"; my $d = \"1\"; my $before = $f ~~ $d; my $c = $d + 0; my $after = $f ~~ $d; [$before, $after];\n","err":"","out":"[\"\",1]"},{"code":"my $fac = 1; $fac *= $_ for (2 .. 10); $fac;\n","err":"","out":"3628800"},{"err":"","out":"my fancy filename.txt","code":"$_ = \"my fancy filename.txt\"; s/(?<!\\.)\\b/\\U/gr\n"},{"out":"My Fancy Filename.txt","err":"","code":"$_ = \"my fancy filename.txt\"; s/(?<!\\.)\\b(\\w)/\\U$1/gr\n"},{"err":"","out":">implying","code":"my $fh = *STDOUT; print $fh \">implying\"; ()\n"},{"err":"","out":"[\"baz\",undef]","code":"my $field = 'foo'; sub bar { (my $param, $field) = @_; [ $param, $field ] } bar('baz');\n"},{"out":"1","err":"","code":"my $field = 'foo'; sub bar { (my $param, $field) = @_; print $field } bar('baz');\n"},{"out":"2,6,7,9,10","err":"","code":"my @fields = (1..10); my @bits = reverse split //, sprintf '%b', 1890; join ',', map $bits[$_] ? $fields[$_] : (), 0..$#fields\n"},{"code":"my $file = \"blah.pl\"; return \"Yep\" if ($file =~ m#\\.pl$#);\n","out":"Yep","err":""},{"out":"jpg","err":"","code":"my $filename = \"foo.jpg.\"; my @chunks = split /\\./, $filename; (@chunks > 1 ? $chunks[-1] : die 'funny shit')\n"},{"code":"my $filename = \"foo\\nbar.jpg\"; my @chunks = split /\\./, $filename; (@chunks > 1 ? $chunks[-1] : die 'funny shit')\n","out":"jpg","err":""},{"code":"my $filename = \".vimrc\"; my @chunks = split /\\./, $filename; (@chunks > 1 ? $chunks[-1] : die 'funny shit')\n","out":"vimrc","err":""},{"out":"_ _ _ _ _","err":"","code":"my @fill = (\"_\") x 5; \"@fill\"\n"},{"err":"","out":"h _ _ _ _","code":"my @fill = (\"_\") x 5; $fill[0] = 'h'; \"@fill\"\n"},{"code":"my @fill = (\"_\") x 5; $fill[0] = 'h'; $fill[2] = 'l'; $fill[3] = 'l'; \"@fill\"\n","out":"h _ l l _","err":""},{"code":"my @fill = (\"_\") x 5; $fill[1] = 'h'; \"@fill\"\n","out":"_ h _ _ _","err":""},{"out":"context","err":"","code":"my $final = qw( these comma operators are in scalar context ); $final\n"},{"code":"my $ foo;\n","err":"","out":""},{"code":"my $foo = 0; [~-$foo, -~$foo]\n","err":"","out":"['18446744073709551615',\"-1.84467440737096e+19\"]"},{"out":"1","err":"","code":"my $foo = 0; sub test { $_[0]++ } test $foo; $foo\n"},{"code":"my $foo = 0; sub test { my $bar = $_[0]; $$bar = $$bar + 1 } test \\$foo; $foo\n","out":"1","err":""},{"out":"[]","err":"","code":"my $foo = '[1.1.1.1]'; [$foo =~ /\\[(\\d{1-3}\\.\\d{1-3}\\.\\d{1-3}\\.\\d{1-3})\\]/]\n"},{"code":"my $foo = '[1.1.1.1]'; [$foo =~ /\\[(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\\]/]\n","out":"[\"1.1.1.1\"]","err":""},{"out":"[]","err":"","code":"my $foo = '1.1.1.1'; [$foo =~ /\\[(\\d{1-3}\\.\\d{1-3}\\.\\d{1-3}\\.\\d{1-3})\\]/]\n"},{"out":"[]","err":"","code":"my $foo = '1.1.1.1'; [$foo =~ /\\[(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\\]/]\n"},{"err":"","out":"[1,2,3,4,5,6,7,8,9,10,\"a\",11,12,13,14,15,16,17,18,19,20]","code":"my @foo = 1 .. 20; my @bar = (@foo[0..$#foo/2], \"a\", @foo[10..$#foo]); [@bar]\n"},{"code":"my @foo = (1,2,3); \\@foo\n","err":"","out":"[1,2,3]"},{"code":"my @foo = (1,2,3); $_++ for @foo; \\@foo\n","err":"","out":"[2,3,4]"},{"err":"","out":">123<","code":"my $foo = 123; package Y { print \">$foo<\" }\n"},{"code":"my $foo = \\1; my $bar = $$foo; $foo++; $bar;\n","out":"1","err":""},{"err":"","out":"1_bar","code":"my $foo = 1; my $foo_bar = 2; \"$foo\\_bar\"\n"},{"err":"","out":"[2]","code":"my $foo = 1; sub change_foo { $foo = 2 }; change_foo(); [ $foo ]\n"},{"code":"my @foo = [1, sub { code; }]; \\@foo\n","out":"[[1,sub { \"DUMMY\" }]]","err":""},{"err":"","out":"[[1,sub { \"DUMMY\" }]]","code":"my @foo = [1, sub { ... }]; \\@foo\n"},{"code":"my $foo = 1; sub get_foo { return $foo }; [ get_foo() ]\n","err":"","out":"[1]"},{"code":"my $foo = 2 ** 20; $foo;\n","out":"1048576","err":""},{"code":"my $foo = 2**32; [~-$foo, -~$foo]\n","err":"","out":"[4294967295,\"-1.84467440694146e+19\"]"},{"err":"","out":"\\\"hi\"","code":"my $foo = 42; my $bar = \\$foo; $foo = \"hi\"; $bar\n"},{"code":"my $foo = 42; my $bar = \\$foo; $foo = \"hi\"; $$bar\n","out":"hi","err":""},{"out":"5","err":"","code":"my $foo = + + + + + + + 5;\n"},{"out":"[4,\"-1.84467440737096e+19\"]","err":"","code":"my $foo = 5.0; [~-$foo, -~$foo]\n"},{"code":"my $foo = 5 + do { 5 }; [$foo]\n","err":"","out":"[10]"},{"err":"","out":"5","code":"my $foo = 5; $ foo;\n"},{"code":"my $foo = 5; [~-$foo, -~$foo]\n","err":"","out":"[4,\"-1.84467440737096e+19\"]"},{"code":"my $foo = 5; my $bar = sub { $foo }; $bar->()\n","out":"5","err":""},{"err":"","out":"5","code":"my $foo = 5; sub bar { $foo } bar\n"},{"code":"my $foo = 5; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say 3 }\n","err":"","out":"2\n"},{"code":"my $foo = 5; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say 3 } else { say 4 }\n","out":"ERROR: syntax error at (eval 558) line 1, near \"} else\"\n","err":""},{"code":"my $foo = 7; my $bar = 1; say \"blah\" if (($foo or $bar) == 1);\n","err":"","out":""},{"err":"","out":"","code":"my $foo = 7; my $bar = 1; say \"blah\" if ($foo or $bar) == 1;\n"},{"code":"my %foo = (a,1,b,2,c,3); join(', ', keys %foo); #for PSGroup53\n","out":"a, b, c","err":""},{"out":"1, 3, 2","err":"","code":"my %foo = (a,1,b,2,c,3); join(', ', values %foo); #for PSGroup53\n"},{"err":"","out":"3","code":"my %foo = (a,1,b,2,c,3); keys %foo; #for PSGroup53\n"},{"code":"my $foo = {a => bar, b => baz}; $moo = \"lucky:luke\"; $foo = {split \":\", $moo}; $foo;\n","out":"{lucky => \"luke\"}","err":""},{"code":"my $foo = 'a b c d'; $foo =~ s/ /\\\\s+/g; 'a    b    c     d' =~ s/$foo/bar/r\n","out":"bar","err":""},{"code":"my $foo = 'a b c d'; $foo =~ s/ /\\\\s+/g; 'a    b    c     d' =~ s/$foo//r\n","out":"","err":""},{"err":"","out":"2","code":"my @foo = ([\"A\",\"B\",\"C\"],[\"E\",\"F\"],[\"G\",\"H\",\"I\",\"J\",\"K\"],[\"L\"]); $#{$foo[0]}\n"},{"out":"c\n","err":"","code":"my $foo = ('a', 'b', 'c'); say $foo #this though...\n"},{"code":"my $foo = \"asdf\"; open my $fh, '<', \\$foo; [<$fh>]\n","out":"[\"asdf\"]","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"$foo{bar\"\n","err":"","code":"my $foo{bar} = 1\n"},{"err":"","out":"[2]","code":"[ my ($foo, $bar) //= (1,2) ]\n"},{"out":"","err":"","code":"my $foo = 'bar' and $foo\n"},{"code":"my($foo,$bar)=('bar','bra ann');$foo x= 5;print $foo.$bar;\n","out":"barbarbarbarbarbra ann","err":""},{"out":"[\"bar\",\"baz\"]","err":"","code":"my %foo = (bar => 'baz'); my @refs = \\(%foo); ${$refs[0]} = 'quux'; [%foo]\n"},{"err":"","out":"[\"bar\",\"quux\"]","code":"my %foo = (bar => 'baz'); my @refs = \\(%foo); ${$refs[1]} = 'quux'; [%foo]\n"},{"err":"","out":"[\"quux\",\"quux\",\"quux\"]","code":"[ my ($foo, $bar, $baz) = ('quux') x 3 ]\n"},{"out":"[\"foo 'ba'r'\"]","err":"","code":"my $foo = 'ba\\'r'; [ \"foo '$foo'\" ]\n"},{"err":"","out":"bar","code":"my $foo=\"bar\"; for $foo (1..4) {}; $foo\n"},{"err":"","out":"bar","code":"my $foo=\"bar\"; for $foo (1..4) {last}; $foo\n"},{"code":"my $foo = \"bar\"; my $baz = sub {$foo; ${\"foo\"}}; $baz->();\n","out":"","err":""},{"out":"1","err":"","code":"my $foo = \"bar\"; my $baz = sub {${\"foo\"}}; print $baz->();\n"},{"err":"","out":"bar","code":"my $foo = \"bar\"; print $                 foo;\n"},{"code":"my @foo; defined @foo\n","out":"ERROR: Can't use 'defined(@array)' (Maybe you should just omit the defined()?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"[[undef,undef,undef,undef,undef,[undef,undef,undef,[]]]]","code":"my @foo; exists $foo[5][3][7]; [ \\@foo ]; ### It also works with arrays.\n"},{"code":"my @foo; exists $foo[5]{bar}[7]; [ \\@foo ]; ### Or a mix of the two.\n","err":"","out":"[[undef,undef,undef,undef,undef,{bar => []}]]"},{"err":"","out":"[{bar => {baz => {quux => {}}}}]","code":"my %foo; exists $foo{bar}{baz}{quux}{floop}; [ \\%foo ]\n"},{"err":"","out":"[1]","code":"my @foo; [ $foo[1] != 1 ]\n"},{"err":"","out":"foo foo ","code":"my %foo = foo => 1, bar => 1; sub foo { print join \" \", %foo }; foo; { delete local $foo{foo}; foo }; foo;\n"},{"code":"my %foo = foo => 1; sub foo { print join \" \", %foo }; foo; delete local $foo{foo}; foo;\n","err":"","out":"foo "},{"out":"foo 2 bar 2bar 2bar 2 foo 2","err":"","code":"my %foo = (foo => 2, bar => 2); sub foo { print join \" \", %foo }; foo; { delete local $foo{foo}; foo }; foo;\n"},{"out":"[\"foo bar=baz big=\\\"some \\\\\\\"other\\\\\\\" thing\\\"\",\"dumb=today\"]","err":"","code":"my $foo = 'foo bar=baz big=\"some \\\"other\\\" thing\" dumb=today'; [split / (?![^\"]*?\")/, $foo]\n"},{"out":"[\"foo bar=baz big=\\\"some thing\\\"\",\"dumb=today\"]","err":"","code":"my $foo = 'foo bar=baz big=\"some thing\" dumb=today'; [split / (?![^\"]*?\")/, $foo]\n"},{"out":"[\"foo bar=baz big=\\\"some thing\\\"\",\"dumb=today\"]","err":"","code":"my $foo = 'foo bar=baz big=\"some thing\" dumb=today'; [split / (?![^\"]*\")/, $foo]\n"},{"code":"my $foo =()= 'foo bar who owl scoop' =~ /oo/g; [ $foo ];\n","err":"","out":"[2]"},{"out":"0 1 2\n3\n","err":"","code":"my @foo; @foo = @foo || (0..2); say \"@foo\"; @foo = @foo || (5..7); say \"@foo\"\n"},{"out":"quux","err":"","code":"my $foo = 'foo'; package Bar { my $foo = 'quux'; print $foo; }\n"},{"code":"my $foo = []; [ \"$foo\", sprintf('ARRAY(0x%x)', $foo) ]\n","out":"[\"ARRAY(0x490c568)\",\"ARRAY(0x490c568)\"]","err":""},{"out":"[\"ARRAY(0x493e800)\",\"ARRAY(0x493e800)\"]","err":"","code":"my $foo = []; [ \"$foo\", sprintf('ARRAY(%#x)', $foo) ]\n"},{"code":"my %foo; $foo{zot}=\"asdf\\n\"; chomp $foo{zot}; \\%foo;\n","out":"{zot => \"asdf\"}","err":""},{"code":"my $foo = \"hello\"; print \"haha \" . $foo . \" hihi\";\n","err":"","out":"haha hello hihi"},{"out":"[4,\"-1.84467440737096e+19\"]","err":"","code":"my $foo = int 5; [~-$foo, -~$foo]\n"},{"code":"my $foo = { key => [ 2, 3, 4] }; print @$foo{key}[1]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"}[\"\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"}[\"\n","code":"my $foo = { key => [ 2, 3, 4] }; say @$foo{key}[1]\n"},{"code":"my $foo = map { 0, 0, 0 } \"A\", \"B\", \"C\", \"D\"\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"} \"A\"\"\n"},{"code":"my $foo = map {; 0, 0, 0 } \"A\", \"B\", \"C\", \"D\"\n","err":"","out":"12"},{"out":"4","err":"","code":"my $foo = map { 42 } \"A\", \"B\", \"C\", \"D\"\n"},{"code":"my $foo = map { for (()) { } } qw(A B C) if 0;\n","err":"","out":"0"},{"code":"my $foo = map { if ($_ ne \"A\") return 0 } \"A\", \"B\", \"C\", \"D\"\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \") return\"\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"$_ neq \"\n","err":"","code":"my $foo = map { if ($_ neq \"A\") 0 } \"A\", \"B\", \"C\", \"D\"\n"},{"err":"","out":"3","code":"my $foo = map { $_ ne \"A\" ? 0 : () } \"A\", \"B\", \"C\", \"D\"\n"},{"code":"my $foo; my $bar;  (1 ? $foo : $bar) = \"let's see\"; [ $foo, $bar ]\n","out":"[\"let's see\",undef]","err":""},{"err":"","out":"[undef,[]]","code":"my $foo; my $bar = []; [$foo, $bar]\n"},{"code":"my $foo = []; my $base = 0x400_0000; $base += 8 while $base < $foo; sprintf '%s %#x', $foo, $base\n","out":"ARRAY(0x561bef0) 0x561bef0","err":""},{"code":"my $foo = []; my %hash = ($foo => 1); my $base = 0x400_0000; $base += 8 until $hash{sprintf 'ARRAY(%#x)', $base}; sprintf \"found %#x in %s\", $base, join(\" \", keys %hash)\n","out":"found 0x55f61e0 in ARRAY(0x55f61e0)","err":""},{"out":"{dev => {database => {url => 42}}}","err":"","code":"my $foo = {}; my $k = \"dev/database/url\"; my $p = \\$foo; for my $n (split m{/}, $k) { $p = \\$$p->{$n}; } $$p = 42; $foo\n"},{"code":"my $foo; my $ref = \\$foo; $$ref = 'bar'; [ $foo ]\n","out":"[\"bar\"]","err":""},{"out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $foo; my $ref = \\$foo; $ref++; $$ref = '\n"},{"out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $foo; my $ref = \\$foo; $ref++; $$ref = 'bar'; [ $foo ]\n"},{"code":"my ($foo) = \"onetwothree\" =~ s/(tw.)//g; $foo\n","out":"ERROR: Can't modify constant item in substitution (s///) at (eval 558) line 1, at EOF\n","err":""},{"err":"","out":"2","code":"my %foo = ('â¥' => 'perllove');\n"},{"err":"","out":"perllove\n","code":"my %foo = ('â¥' => 'perllove'); say $foo{'â¥'};\n"},{"code":"my $foo; push @{$foo->{bar}{baz}}, 123; $foo\n","err":"","out":"{bar => {baz => [123]}}"},{"err":"","out":"","code":"my $foo; push @{$foo{bar}{baz}}, 123; $foo\n"},{"err":"","out":"qr/^(?^u:bananas!)/u","code":"my $foo = qr/bananas!/; qr/^$foo/\n"},{"out":"[3,4,1,2]","err":"","code":"my @foo = qw(1 2 3 4); push(@foo, splice(@foo, 0, 2)); [@foo]\n"},{"code":"my @foo = qw(1 2 3 4); [ unshift(@foo, splice(@foo, 2, 2)); ]\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":""},{"code":"my @foo = qw(1 2 3 4); unshift(@foo, splice(@foo, 2, 2)); [ @foo ]\n","out":"[3,4,1,2]","err":""},{"code":"my @foo = qw(1 2 3 4); unshift(@foo, splice(@foo, -2)); [ @foo ]\n","err":"","out":"[3,4,1,2]"},{"out":"[\"a1b2c3\",\"a 1 b 2 c 3\"]","err":"","code":"my @foo = qw(a 1 b 2 c 3); open my $printer, '>', \\my $buffer; print $printer @foo; [$buffer, \"@foo\"]\n"},{"out":"[5]","err":"","code":"my $foo = [qw/a b c d e/]; [ scalar @$foo ]\n"},{"out":"azertyuiopqsdfghjklmwxcvbn","err":"","code":"my $foo = qw/azertyuiopqsdfghjklmwxcvbn/; $foo =~ s/(.{8})\\s.+?/$1/; $foo;\n"},{"err":"","out":"{bar => undef,baz => undef,foo => undef}","code":"my %foo = qw(foo 1 bar 2 baz 3); @foo{keys %foo} = (); \\%foo;\n"},{"code":"my @foo = qw(foo bar baz); [ \\(@foo) ]\n","err":"","out":"[\\\"foo\",\\\"bar\",\\\"baz\"]"},{"code":"my @foo = qw(foo bar baz); [ \\@foo ]\n","out":"[[\"foo\",\"bar\",\"baz\"]]","err":""},{"err":"","out":"\\\"baz\"","code":"my @foo = qw(foo bar baz); \\(@foo)\n"},{"code":"my @foo = qw(foo bar baz); [ \\(@foo, 42) ]\n","out":"[[\"foo\",\"bar\",\"baz\"],\\42]","err":""},{"code":"my @foo = qw(foo bar baz); (@foo) = (@foo) x 5;\n","err":"","out":"15"},{"out":"ERROR: Can't modify private array in repeat (x) at (eval 558) line 1, at EOF\n","err":"","code":"my @foo = qw(foo bar baz); (@foo) x= 5;\n"},{"err":"","out":"ERROR: Can't modify private array in repeat (x) at (eval 558) line 1, near \"5]\"\n","code":"my @foo = qw(foo bar baz); [(@foo) x= 5];\n"},{"code":"my @foo = qw(foo bar baz); [(@foo) x 5];\n","err":"","out":"[\"foo\",\"bar\",\"baz\",\"foo\",\"bar\",\"baz\",\"foo\",\"bar\",\"baz\",\"foo\",\"bar\",\"baz\",\"foo\",\"bar\",\"baz\"]"},{"err":"","out":"{}","code":"my %foo = qw(foo bar baz qux kitties nip); my $ref = \\%foo; undef %foo; $ref\n"},{"code":"my @foo = qw(milk nip kitties meow); my @slice = @foo[2,3,2,1]; \\@slice\n","out":"[\"kitties\",\"meow\",\"kitties\",\"nip\"]","err":""},{"err":"","out":"[[\"foo\",\"foo\"],[\"foo\",\"bar\"],[\"bar\",\"bar\"]]","code":"my @foo = split /\\s+/, \"foo bar\"; [ [ @foo[0,0] ], [ @foo[0,1] ], [ @foo[1,1] ] ]\n"},{"code":"my $foo; sub bar { print \"[$foo]\"; } for $foo (\"hello\") { bar; }\n","out":"[]","err":""},{"err":"","out":"foo 1","code":"my %foo; sub foo { print join \" \", %foo }; foo; local $foo{foo} = foo; foo;\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":"","code":"my %foo; sub foo { print join(\" \", %foo }; foo; local $foo{foo} = foo; foo;\n"},{"code":"{ my $foo; sub plusfoo { $foo++ } sub getfoo { $foo } } plusfoo(); getfoo()\n","out":"1","err":""},{"code":"my $foo = sub { return $foo };\n","err":"","out":"sub { \"DUMMY\" }"},{"out":"[1,2,3]","err":"","code":"my $foo = sub { shift }; [ map $foo->($_), 1, 2, 3 ]\n"},{"err":"","out":"[sub { \"DUMMY\" },$VAR1->[0],$VAR1->[0]]","code":"my $foo = sub { shift }; [ map $foo, 1, 2, 3 ]\n"},{"code":"my $foo = sub { shift }; [ map &$foo, 1, 2, 3 ]\n","err":"","out":"[\"my \\$foo = sub { shift }; [ map &\\$foo, 1, 2, 3 ]\",undef,undef]"},{"err":"","out":"[\"test\\x{326}\"]","code":"my $foo = \"test\\x{327}\"; $foo =~ tr/\\x{327}/\\x{326}/; [$foo]\n"},{"code":"(my $foo:)//= undef\n","out":"","err":""},{"code":"my $foo ://= undef;\n","out":"ERROR: syntax error at (eval 558) line 1, near \"$foo :\"\n","err":""},{"out":"","err":"","code":"my $foo //= undef;\n"},{"out":"[]","err":"","code":"my $foo = undef; [ @$foo ]\n"},{"code":"my $foo = undef // say \"it broke!\"; [ $foo ]\n","out":"it broke!\n","err":""},{"out":"0","err":"","code":"my $found = 0; 0+($found == 7) # you pass a zero to exit, it will happily use that value\n"},{"err":"","out":"yx\n","code":"my $f = \"s/l/y/g;s/k/x/g\"; my $s = \"lk\\n\"; $s = do { local $_ = $s; eval($f); $_ }; printf(\"%s\", $s)\n"},{"code":"my $f = sub { [] }; @a = map { 0+ $f->($_) } 1..10;\n","err":"","out":"10"},{"err":"","out":"[105874320,105874320,105874344,105874440,105874320,105874344,105874440,105874320,105874344,105874440]","code":"my $f = sub { [] }; @a = map { 0+ $f->($_) } 1..10; \\@a\n"},{"code":"my $f = sub { [] }; @a = map { refaddr $f->($_) } 1..10;\n","out":"ERROR: Can't call method \"refaddr\" on unblessed reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"my $f = sub { SUB: my ($n) = @_; print \"$n \"; $n or return; @_ = $n - 1; goto SUB; }; $f->(5);\n","out":"5 4 3 2 1 0 ","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","err":"","code":"$_ = \"my.funny-str is a string\"; [ [split /(?=[. -])/], [split /[. -]/]\n"},{"code":"$_ = \"my.funny-str is a string\"; [ [split /(?=[. -])/], [split /[. -]/]]\n","out":"[[\"my\",\".funny\",\"-str\",\" is\",\" a\",\" string\"],[\"my\",\"funny\",\"str\",\"is\",\"a\",\"string\"]]","err":""},{"err":"","out":"2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50","code":"my $gf = sub { (1..50) }; my $ev = sub { $_ % 2 == 0 }; print join \",\", grep { $ev->($_) }  $gf->()\n"},{"code":"(my $good_stuff, my $throw_away) = split(â=â, $stuff);  # for comparison\n","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after ) = split(<-- HERE near column 132 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"my @groups; my $chunk = []; for my $x (\"foo\", \"bar\", \"baz\\n\", \"x\", \"y\", \"z\") { push @$chunk, $x; if ($x =~ /\\R\\z/) { push @groups, $chunk; $chunk = []; } } push @$groups, $chunk if @$chunk; [ @groups ]\n","err":"","out":"[[\"foo\",\"bar\",\"baz\\n\"]]"},{"out":"ERROR: Search pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my @groups; my $chunk = []; for my $x (\"foo\", \"bar\", \"baz\\n\", \"x\", \"y\", \"z\") { push @$chunk, $x; if ($x =~ /\\R\\z) { push @groups, $chunk; $chunk = []; } } push @$groups, $chunk if @$chunk; [ @groups ]\n"},{"code":"my $h = {}; [ {}, {} ]\n","out":"[{},{}]","err":""},{"err":"","out":"9:12:34","code":"my $h = '09:12:34'; $h =~ s/0(\\d)(?=(?::\\d\\d){2})/$1/r;\n"},{"code":"my $h = '09'; [ $h, 0+$h ];\n","out":"[\"09\",9]","err":""},{"out":"","err":"","code":"my %h = (a => 1); ++$_ for keys %h;\n"},{"code":"my %h = (a = 1); ++$_ for keys %h;\n","err":"","out":"ERROR: Can't modify constant item in scalar assignment at (eval 558) line 1, near \"1)\"\n"},{"code":"my %h = (a => 1); ++$_ for keys %h; \\%h;\n","out":"{a => 1}","err":""},{"code":"my %h = (a => 1); ++$_ for values %h; \\%h;\n","out":"{a => 2}","err":""},{"out":"{2 => \"\",1 => \"\"}","err":"","code":"my %hash = ( 1 => '', 2 => '', 1 => '');  \\%hash\n"},{"code":"my %hash = (1 => 2, 3 => 4); my $out=''; while (my ($key, $val) = each %hash) { $out .= join ' ', keys %hash } $out\n","out":"","err":""},{"code":"my $hash = { a=>1, b=>2 }; delete $hash->{(keys %{$hash})[0]}\n","out":"1","err":""},{"code":"my $hash = { a=>1, b=>2 }; delete $hash{(keys %{$hash})[0]}\n","err":"","out":""},{"code":"my %hash = (a => 1, b => 2); mySub(%hash); sub mySub { my (%hash) = @_; warn join ', ', %hash }\n","out":"1","err":"a, 1, b, 2 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"my %hash = (a => 1, b => 2); mySub(%hash); sub mySub { my (%h) = @_; warn $h{a} }\n","out":"1","err":"1 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"my %hash = ( abc => 'def', asdf => 'jkl;' ); print join ' ', @hash{abc,asdf}\n","out":"def jkl;","err":""},{"err":"","out":"def ","code":"my %hash = ( abc => 'def', asdf => 'jkl;' ); print join ' ', @hash{abc,def}\n"},{"code":"my %hash; bless \\%hash, \"SomeClass\";  ref \\%hash;   # <== tm604: \u0002*technically*\u0002 it's the referrant itself, and not the reference\n","out":"SomeClass","err":""},{"code":"my %hash; bless \\%hash, \"SomeClass\";  ref \\%somehash;   # <== tm604: \u0002*technically*\u0002 it's the referrant itself, and not the reference\n","err":"","out":"HASH"},{"err":"","out":"1","code":"my %hash = (foo => !!1); $hash{foo} = 1\n"},{"code":"my %hash = (foo => [ 4 ]); $ hash { 'foo' } [ 0 ]\n","err":"","out":"4"},{"code":"my %hash = (foo => \"bar\", baz => \"bra\"); use JSON::XS; encode_json \\%hash\n","out":"{\"baz\":\"bra\",\"foo\":\"bar\"}","err":""},{"out":"bar","err":"","code":"my %hash = (foo => 'bar'); (%hash)[1]\n"},{"err":"","out":"bar","code":"my %hash = (foo => 'bar'); (values %hash)[0];\n"},{"code":"my @hash = %hash; print @hash\n","err":"","out":"1"},{"out":"OMG","err":"","code":"my %hash; if ($hash{foo} eq $hash{bar}) { print \"OMG\" }\n"},{"code":"my %hash; keys %hash = 200; $hash{abc} = 1; [scalar %hash]\n","out":"[\"1/256\"]","err":""},{"out":"[1,2,3,4,5]","err":"","code":"my %hash; my @array1 = qw/ 1 2 3 4 /; my @array2 = qw/ 3 4 5 /;    @hash{@array1,@array2} = ();   my @combined = sort keys %hash;    [ @combined ]\n"},{"code":"my %hash; my %dash = (qw/a 1 b 2/); [ scalar %hash, scalar %dash ]\n","out":"[0,\"1/8\"]","err":""},{"code":"my %hash; my $str = \"foo:12 bar:34 baz:45\"; @hash{'foo', 'bar', 'baz'} = $str =~ /foo:(\\d+) bar:(\\d+) baz:(\\d+)/; \\%hash\n","err":"","out":"{baz => 45,bar => 34,foo => 12}"},{"code":"my %hash; my $val1 = $hash{a}; my $val2 = $hash{b} if exists $hash{b}; [keys %hash]\n","err":"","out":"[]"},{"err":"","out":"2","code":"my %hash = (one => [1, 2, 4]);\n"},{"out":"4","err":"","code":"my %hash = (one => [1, 2, 4]); sub bar { \tmy $href = shift @_; \tpush @{$href->{one}}, 5; } bar(\\%hash); @{$hash{one}};\n"},{"code":"my %hash = (one => [1, 2, 4]); sub bar { \tmy $href = shift @_; \tpush @{$href->{one}}, 5; } bar(\\%hash); print @{$hash{one}};\n","err":"","out":"1245"},{"code":"my $hash = {one=>1,two=>2,three=>2}; [ grep $_ == 2, values %$hash ]\n","out":"[2,2]","err":""},{"code":"my $hash = {one=>1,two=>2,three=>2};[  %{$hash}{ grep $hash->{$_} == 2, keys %$hash } ] # mauke's version is much neater unless you really wanted this\n","err":"","out":"[\"three\",2,\"two\",2]"},{"out":"[2,2]","err":"","code":"my $hash = {one=>1,two=>2,three=>2};[  @{$hash}{ grep $hash->{$_} == 2, keys %$hash } ] # then as huf said, use something like this. seems a bit pointless though\n"},{"err":"","out":"[\"one\",1,\"two\",2]","code":"my %hash = ( one => 1, two => 2, three => 3 );  [ %hash{qw(one two)} ]\n"},{"out":"[\"one,\",undef,\"two\",2]","err":"","code":"my %hash = ( one => 1, two => 2, three => 3 );  [ %hash{qw(one, two)} ]\n"},{"err":"","out":"[\"one\",\"baz\"]","code":"my %hash = (one => 'foo'); sub bar { my ($href) = @_; $href->{one} = 'baz'; } bar(\\%hash);  [ %hash ]\n"},{"code":"my %hash = (one => 'foo'); sub bar { my $href = @_; $href->{one} = 'baz'; } bar(\\%hash);  [ %hash ]\n","out":"[\"one\",\"foo\"]","err":""},{"code":"my %hash = (one => two, three => four); say for keys %hash;\n","err":"","out":"three\none\n"},{"out":"one\n","err":"","code":"my %hash = one => two, three => four; say for keys %hash;\n"},{"err":"","out":"{foo => [3]}","code":"my %hash; push @{$hash{foo}}, 3; \\%hash\n"},{"out":"{}","err":"","code":"@{\\my %hash}{qw(a b)} = (1, 2); \\%hash\n"},{"code":"my $hash = {ref => [1, 2, 3]}; while(my $num = $hash->{ref}->CORE::each) {print $num, \" => \";}\n","err":"","out":"ERROR: Can't call method \"each\" on unblessed reference at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"20001","code":"my $hashref = { 20001 => {} }; my ($key) = %$hashref; $key\n"},{"code":"my $hashref = { 20001 => {} }; my ($key) = %$hr; $key\n","err":"","out":""},{"code":"my $hash_ref = { 'foo' => 'bar' }; $hash_ref{'foo'};\n","out":"","err":""},{"code":"my $hashref = { foo => 'bar' }; my $doesntwork = $#$hashref;\n","err":"","out":"ERROR: Not an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"[{three => \"Isaac Newton\",two => \"rindolf\",one => \"falcom\"}]","code":"my $hash_ref = {'one' => 'falcom', 'two' => 'rindolf'}; my $d = { %$hash_ref, 'three' => \"Isaac Newton\"}; [$d]\n"},{"code":"my %hash; scalar %hash\n","out":"0","err":""},{"code":"my %hash = (thing => SOME_CONSTANT() ); sub SOME_CONSTANT { 5 }; $hash{thing}\n","err":"","out":"5"},{"out":"SOME_CONSTANT","err":"","code":"my %hash = (thing => SOME_CONSTANT); sub SOME_CONSTANT { 5 }; $hash{thing}\n"},{"out":"{}","err":"","code":"my %hash = (x=>123); %hash = (); \\%hash\n"},{"code":"my %h = (a..z); ${%h}{\"how strange\"} = \"is this, anyway?\"; \\%{%h};\n","out":"{\"how strange\" => \"is this, anyway?\"}","err":""},{"err":"","out":"10/1628/64","code":"my %h = (a..z); ${%h}{\"ignore the man\"} = \"behind the curtain\"; print scalar %h; undef $h{$_} for 1..20; print scalar %h;\n"},{"code":"my %h = (a..z); ${%h}{\"ignore the man\"} = \"behind the curtain\"; undef $h{$_} for 1..20; \\%{%h};\n","out":"{}","err":""},{"code":"my %hb = (a => 'bleh', b => 'bluh'); my %ha = (a => 'woo', x => 'y', %hb); \\%ha;\n","out":"{x => \"y\",b => \"bluh\",a => \"bleh\"}","err":""},{"err":"","out":"4","code":"my @headers = qw(foo bar ibytes pickles);\n"},{"out":"5","err":"","code":"my @headers = qw(hits bytes ihits ibytes ips);\n"},{"code":"my %h = (); exists $h{foo}->{bar}; print exists $h{foo}\n","out":"1","err":""},{"code":"my $hex = q{6060FF}; [ hex($hex), [ unpack q{L>*}, pack q{H*}, map { sprintf q{%08s}, $_; } ( $hex =~ s!^0x!!r) =~ m!(^.{2,6}|.{2,8})!g ] ]; ### How to do what hex() does with pack/unpack. Is there a cleaner / less-hackier way?\n","out":"[6316287,[6316287]]","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"what hex\"\n","err":"","code":"my $hex = q{6060FF}; [ hex($hex), [ unpack q{L>*}, pack q{H*}, map { sprintf q{%08s}, $_; } ( $hex =~ s!^0x!!r) =~ m!(^.{2,6}|.{2,8})!g ] ]; How to do what hex() does with pack/unpack. Is there a cleaner / less-hackier way?\n"},{"out":"[6316287,[101121792]]","err":"","code":"my $hex = q{6060FF}; [ hex($hex), [ unpack q{N*}, pack q{(h8)*}, $hex ] ];\n"},{"err":"","out":"[6316287,[1616969472]]","code":"my $hex = q{6060FF}; [ hex($hex), [ unpack q{N*}, pack q{(H8)*}, $hex ] ];\n"},{"err":"","out":"[6316287,[1616969472]]","code":"my $hex = q{6060FF}; [ hex($hex), [ unpack q{N}, pack q{H8}, q{6060FF} ] ] # How to do the equivilent of hex() with pack/unpack functions?\n"},{"out":"[6316287,[]]","err":"","code":"my $hex = q{6060FF}; [ hex($hex), [ unpack q{N}, pack q{H*}, q{6060FF} ] ] # with H* it is only three bytes and apparently rejected by V/N/I/L\n"},{"code":"my $hex = q{6060FF}; [ hex($hex), [ unpack q{V*}, pack q{(h8)*}, $hex ] ];\n","out":"[6316287,[16713222]]","err":""},{"out":"[6316287,[16736352]]","err":"","code":"my $hex = q{6060FF}; [ hex($hex), [ unpack q{V*}, pack q{(H8)*}, $hex ] ];\n"},{"out":"6ÃÂÃÂ4F\u0013xaC0","err":"","code":"my $hex = unpack(\"H*\", pack(\"Q<\", 1397463445)); my $td = pack(\"H*\", unpack(\"Q<\",$hex)); $td;\n"},{"err":"","out":"1","code":"my $h = { foo => 42 }; $h == \\%{$h}\n"},{"code":"my %h = ( foo => { bar => {ber => [boor] } } ); my $ar = $h{foo}{bar}{ber}; push @$ar, 'foor';  \\%h\n","out":"{foo => {bar => {ber => [\"boor\",\"foor\"]}}}","err":""},{"code":"my $h = {}; [ \"$h\" ]\n","err":"","out":"[\"HASH(0x64957b8)\"]"},{"code":"my %h = +{}; \\%h\n","err":"","out":"{\"HASH(0x472f288)\" => undef}"},{"code":" my %h; @h{(20..34)} = (); [(sort keys %h)[0..10]];\n","err":"","out":"[20,21,22,23,24,25,26,27,28,29,30]"},{"out":"c 3d 4","err":"","code":"my %h=(); %h=( 'a'=>'1', 'b'=>'2' ); %h=( 'c'=>'3', 'd'=>'4' ); for ( sort keys %h ){ print \"$_ $h{$_}\" };\n"},{"err":"","out":"{a => {b => [\"c\",\"d\",\"e\"]}}","code":"my %h; @{ $h{a}{b} } = qw/c d e/; \\%h\n"},{"code":"my $h = \"Hello world!\"; $h =~ s/(.)(.)/$2$1/g; $h\n","out":"eHll oowlr!d","err":""},{"out":"EHLl oOwLr!d","err":"","code":"my $h = \"Hello world!\"; $h =~ s/(.)(.)/\\U$2\\E$1/g; $h\n"},{"code":"my %h=(); %h=getone(); sub getone {return ('a'=>'1','b'=>'2')}; %h=gettwo(); sub gettwo { return('c'=>'3','d'=>'4')}; for ( sort keys %h ){ print \"$_ $h{$_}\" };\n","err":"","out":"c 3d 4"},{"err":"","out":"[] ","code":"my %h=(); %h=getone(); sub getone {return ('a'=>'1','b'=>'2')}; %h=gettwo(); sub gettwo { return undef}; for ( sort keys %h ){ print \"[$_] $h{$_}\" }\n"},{"code":"my %h=(); %h=getone(); sub getone {return ('a'=>'1','b'=>'2')}; %h=gettwo(); sub gettwo { return undef}; for ( sort keys %h ){ print \"$_ $h{$_}\" }\n","err":"","out":" "},{"out":" ","err":"","code":"my %h=(); %h=getone(); sub getone {return ('a'=>'1','b'=>'2')}; %h=gettwo(); sub gettwo { return undef}; for ( sort keys %h ){ print \"$_ $h{$_}\" };\n"},{"code":"my $h = {}; [ $h, $h ]\n","err":"","out":"[{},$VAR1->[0]]"},{"code":"my %h=(); %h=(%h, 'a'=>'1', 'b'=>'2' ); %h=(%h, 'c'=>'3', 'd'=>'4' ); for ( sort keys %h ){ print \"$_ $h{$_}\" };\n","out":"a 1b 2c 3d 4","err":""},{"code":"my $h; $h->{key}[2]{anotherkey} = \"hello\"; $h\n","err":"","out":"{key => [undef,undef,{anotherkey => \"hello\"}]}"},{"err":"","out":"2","code":"my %h=(); %h={return ('a'=>'1','b'=>'2')}; %h={ return('c'=>'3','d'=>'4')}; for ( sort keys %h ){ print \"$_ $h{$_}\" };\n"},{"code":"my %h; $h{two} = sub { \\%h }; $h{two}->()->{two}->()\n","out":"{two => sub { \"DUMMY\" }}","err":""},{"code":"my %h; $h{x}{y}{z} = 123; \\%h # sure\n","out":"{x => {y => {z => 123}}}","err":""},{"code":"my %h = (map { $_ => 2*$_ } 1 .. 10); [ %h{3,5,8} ]\n","err":"","out":"[3,6,5,10,8,16]"},{"code":"my %h = (map { $_ => 3*$_  } 1.. 10); { %h{(1,4,6)} }\n","err":"","out":"18"},{"err":"","out":"{4 => 12,6 => 18,1 => 3}","code":"my %h = (map { $_ => 3*$_  } 1.. 10); +{ %h{(1,4,6)} }\n"},{"err":"","out":"[{foo => {bar => {bizbaz => {cats => 1}}}}]","code":"my %h; my $p = \\%h; $p = $p->{$_} //= {} for qw/foo bar bizbaz/; $p->{cats} = 1; [ \\%h ]\n"},{"out":"ERROR: Not a SCALAR reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my %h = (one => [1,2,4]); sub bar { my ($href) = @_; push ${$href->{one}}, 5; } bar(\\%h); @{$h{one}}\n"},{"code":"my %h = ( one => 1, two => 2 ); [ %h{qw( one three )} ]\n","err":"","out":"[\"one\",1,\"three\",undef]"},{"err":"","out":"bar\nber\n","code":"my %h = qw/foo bar baz ber/; say $h{foo}; my $x = 'baz'; say $h{$x}\n"},{"out":"[\"must\",\"must\",\"must\",\"should\",\"should\",\"could\",\"could\",\"could\"]","err":"","code":"my %h = qw(must 1 should 2 could 3); [ sort {$h{$a} <=> $h{$b}} qw(must should could could must could should must) ]\n"},{"out":"{a => 5}","err":"","code":"my $hr = {a => 5}; my @arr; push @arr, %$hr; my %hash = @arr; \\%hash\n"},{"code":"my $hr = {a => 5}; my %hash; $hash{hashref}=$hr; $hash{hashref}{a}\n","err":"","out":"5"},{"code":"my $hr = { asdf => 5 }; (%$hr)[1]\n","err":"","out":"5"},{"err":"","out":"5","code":"my $hr = { asdf => 5 }; (values %$hr)[0]\n"},{"out":"ERROR: Type of argument to keys on reference must be unblessed hashref or arrayref at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $href = { foo => 42, bar => 37 }; keys %$href - 3\n"},{"code":"my $href = { foo => 42, bar => 37 }; keys(%$href) - 3\n","out":"-1","err":""},{"err":"","out":"","code":"my $href; %$href\n"},{"out":"{key => {bar => 1}}","err":"","code":"my $href; $href->{key} = {}; my $other = $href->{key}; $other->{bar} = 1; $href\n"},{"code":"my $href; my $other = $href->{key} ||= {}; $other->{bar} = 1; $href\n","err":"","out":"{key => {bar => 1}}"},{"out":"not empty","err":"","code":"my $hr = {searchable => {phones => \"bullshit\"}}; unless ($hr->{searchable}->%*) { \"Empty\" } else { \"not empty\" };\n"},{"out":"Empty","err":"","code":"my $hr = {searchable => {}}; unless ($hr->{searchable}->%*) { \"Empty\" } else { \"not empty\" };\n"},{"out":"ERROR: Can't locate object method \"find\" via package \"<html><body><div>and stuff</div></body></html>\" (perhaps you forgot to load \"<html><body><div>and stuff</div></body></html>\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $html = \"<html><body><div>and stuff</div></body></html>\"; $html->find\n"},{"code":"my $hw = \"Hello World!\\n\"; print $hw;\n","err":"","out":"Hello World!\n"},{"out":"{x => \"abc\",y => \"def\"}","err":"","code":"my %h = (x => \"abc123\", y => \"def456\"); map { tr/a-z//dc } values %h; \\%h\n"},{"code":"my %h = (x => \"abc123\", y => \"def456\"); tr/a-z//dc for values %h; \\%h # are you trying to do something like this\n","out":"{x => \"abc\",y => \"def\"}","err":""},{"out":"5","err":"","code":"my $i = 0; HERE: { HERE: { HERE: { HERE: goto HERE unless $i++ > 3 } } }  print $i\n"},{"out":"1","err":"","code":"my $i = 0; while ( $i <= 10) { print; $i++; } print $_;\n"},{"code":"my $i = 0; while ( $i <= 10) { print; } print $_;\n","err":"","out":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"$i++\"\n","err":"","code":"my $i = 5; ++$i++\n"},{"code":"my @ids = $page_content =~ m!http://www\\.liveleak\\.com/view\\?i=(\\w{14})!g;\n","out":"0","err":""},{"code":"my $idx = 0; my @group; push @{$group[/\\R$/ ? $idx++ : $idx]}, $_ for  \"foo\", \"bar\", \"baz\\n\", \"x\", \"y\", \"z\"; \\@group # something like that?\n","out":"[[\"foo\",\"bar\",\"baz\\n\"],[\"x\",\"y\",\"z\"]]","err":""},{"out":"%01","err":"","code":"my $imagecount = \"\"; my $foo = \"%0\" . length $imagecount . \"d\";\n"},{"code":"my $i; { my $foo; sub get_foo { $foo //= $i++ } } [get_foo, get_foo, get_foo]\n","out":"[0,0,0]","err":""},{"code":"my @in = 1..3; my @out = grep { $_++ } @in; [ \\@in, \\@out ] # far as I recall, List::UtilsBy has an explicit local $_ = $_; to avoid this sort of behaviour, so presumably ::XS doesn't have an equivalent\n","out":"[[2,3,4],[2,3,4]]","err":""},{"out":"2","err":"","code":"my $indents = () = \"        \" =~ /(\\t|\\s{4})/g\n"},{"out":"[3,5,10,12,13]","err":"","code":"my @index; $_ = \"  * *    * ** \"; while(/\\G[^*]*\\*/gc) { push @index, pos } \\@index\n"},{"code":"my $ind = index(fc 'test string', fc 'STRING'); $ind;\n","out":"5","err":""},{"out":"-1","err":"","code":"my $ind = index('test string', 'STRING'); $ind;\n"},{"err":"","out":"42\n","code":"my $input = 'Ù£'; say $input + 42;\n"},{"code":"my @input = map pack('H2', $_), qw(02 02 01 11 48 85 03 86 11 FB FF 42 01 00 00 08 00 00 00 00 00 00 00 86); [ join ' ', map sprintf(\"%08x\", unpack('N1', $_)), join('', @input) =~ /..../g ] # you're asking for this?\n","out":"[\"02020111 48850386 11fbff42 01000008 00000000 00000086\"]","err":""},{"out":"666","err":"","code":"my $input = \"Number 123 here won't be matched, but <number 666, the number of the beast> will.\"; my $match_mode = 0; while ($input =~ /(\\d+)|(<)|(>)/g) { if ($1 and $match_mode) { print $1; } if ($2) { $match_mode = 1; } if ($3) { $match_mode = 0; }}\n"},{"code":"my $input = \"Number 666 will match, but not <number 123 here>, ok?\"; my $match_mode = 1; while ($input =~ /(\\d+)|(<)|(>)/g) { if ($1 and $match_mode) { print $1; } if ($2) { $match_mode = 0; } if ($3) { $match_mode = 1; }}\n","err":"","out":"666"},{"code":"my $ip = '127.0.0.1'; $ip =~ s#(\\d+)#unpack( \"H*\", pack( \"V1\",$1))#ge; $ip\n","out":"7f000000.00000000.00000000.01000000","err":""},{"code":"my $ip = '127.0.0.1'; $ip =~ s#(\\d+)#unpack( \"H*\", pack( \"V1\",$1))#ge; $ip =~ s#.##g; $ip\n","err":"","out":""},{"code":"my $ip = '127.0.0.1'; $ip =~ s#(\\d+)#unpack( \"H*\", pack( \"V1\",$1))#ge; $ip =~ s#.#g; $ip\n","out":"ERROR: Substitution replacement not terminated at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"7f00000000000100","code":"my $ip = '127.0.0.1'; $ip =~ s#(\\d+).?#unpack( \"H*\", pack( \"v\",$1))#ge; $ip\n"},{"err":"","out":"[0,0,0]","code":"my $i; sub get_foo { state $foo = $i++ } [get_foo, get_foo, get_foo]\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \":(\"\n","code":"my $karma = 27; sub mst :() :lvalue { $karma } mst++; $karma\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":"","code":"my $karma = 27; sub mst :lvalue { $karma } mst++; $karma\n"},{"code":"my $karma = 27; sub mst() :lvalue { $karma } mst++; $karma\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n"},{"code":"my $karma = 27; sub mst :lvalue { $karma } mst()++; $karma # actually, might just be this?\n","out":"28","err":""},{"err":"","out":"foo","code":"my $key = 'a'; $hash{$key} = 'foo'; print $hash{$key};\n"},{"code":"my @keys = (1..10); ++$_ for @keys; \\@keys\n","err":"","out":"[2,3,4,5,6,7,8,9,10,11]"},{"code":"my $L = 2**32; join \"\", reverse split //, ((reverse $L) =~ s/(\\d{3})/$1,/rg);\n","out":"4,294,967,296","err":""},{"code":"my $L = 2**32; local $\\ = ','; print for reverse unpack '(A3)*', scalar reverse $L\n","out":"4,492,769,692,","err":""},{"err":"","out":"4492769692,","code":"my $L = 2**32; local $\\ = ','; print reverse unpack '(A3)*', scalar reverse $L\n"},{"code":"my $L = 2**32; $L =~ s/(?<=\\d)(?=(?:\\d{3})+(?!\\d))/,/rg\n","out":"4,294,967,296","err":""},{"err":"","out":"4,294,967,296","code":"my $L = 2**32; $L =~ s/\\d\\K(?=(?:\\d{3})+(?!\\d))/,/rg\n"},{"code":"my $l = 2**32; my $s = join \"\", reverse split //, $l; $s =~ s/(\\d{3})/$1,/g; join \"\", reverse split //, $s\n","out":"4,294,967,296","err":""},{"err":"","out":"4,294,967,296","code":"my $L = 2**32; reverse reverse($L) =~ s/(\\d{3})/$1,/rg\n"},{"err":"","out":"4,294,967,296","code":"my $L = 2**32; scalar reverse join ',', unpack '(A3)*', scalar reverse $L\n"},{"code":"my $l = 4; \"stuff\" . ( $l + 1 );\n","err":"","out":"stuff5"},{"err":"","out":"1","code":"my $l = 4; \"stuff\" . $l + 1;\n"},{"out":"[{2 => 3,1 => 2},{3 => 4,4 => 5}]","err":"","code":"my $lambda = sub { shift()+1 }; @a=1..4; [{map{$_=>$lambda->($_)}@a[0..@a/2-1]},{map{$_=>$lambda->($_)}@a[@a/2..$#a]}]\n"},{"code":"my $last; [ map { $last = $_ // $last } ( 123, 456, undef, undef, undef ) ]\n","out":"[123,456,456,456,456]","err":""},{"out":"[\"123,\",\"456,\",\"undef,\",\"undef,\",\"undef\"]","err":"","code":"my $last; [ map { $last = $_ // $last } qw[ 123, 456, undef, undef, undef ] ]\n"},{"err":"","out":"%-5s","code":"my $lengths = { mach => 5 }; \"%-$lengths->{mach}s\" # you want this, right?\n"},{"code":"my $line = \"COMP2711|3713452|Warren, Ahmad|3645/2|M\"; $line =~ s/\\|(.+), (.+)\\|/$2$1/; print $line;\n","out":"COMP2711Ahmad|3645/23713452|WarrenM","err":""},{"err":"","out":"COMP2711|3713452|Warren, Ahmad|3645/2|M","code":"my $line = \"COMP2711|3713452|Warren, Ahmad|3645/2|M\"; print $line;\n"},{"out":"1 => answer > 0, 2 => answer = answer + 2","err":"","code":"my $line = \"if answer > 0: answer = answer + 2\"; if(0) { } elsif($line =~ /^\\s*if (.*): (.*)/) { print \"1 => $1, 2 => $2\" }\n"},{"out":"The verb is <take> and the other arguments are <cat>","err":"","code":"my $line = \"take cat\";  my ( $verb, @others ) = split m/\\s+/, $line;  \"The verb is <$verb> and the other arguments are <@others>\"\n"},{"err":"","out":"9","code":"my @list = qw(foo bar foo baz kitties meow); 3 + @list\n"},{"code":"my @list = qw(foo bar foo baz kitties meow); my %hash = @list; \\%hash\n","err":"","out":"{kitties => \"meow\",foo => \"baz\"}"},{"code":"my @l = qw/2 4 6/; my @f; for ( my $i=0; $i<@l; $i++ ) { my $x = $l[$i]; push @f, sub { 3 * $x; }; } [ map { $_->(); } @f ];\n","out":"[6,12,18]","err":""},{"code":"my @l = qw/2 4 6/; my @f; for ( my $i=0; $i<@l; $i++ ) { push @f, sub { 3 * $l[$i]; }; } [ map { $_->(); } @f ];\n","out":"[0,0,0]","err":""},{"out":"[\"some foo1 string\",\"foo2\",\"foo3\"]","err":"","code":"my @l = qw(foo1 foo2 foo3); my $foo1 = \\ $l[0]; $$foo1 = 'some foo1 string'; \\@l\n"},{"out":"foocats                             bar","err":"","code":"my %map = (param1 => 'cats', param2 => 'botje'); my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \\{ ([^{]+) \\}/push @params, $2; $1 . 's'/gex; printf $str, map {$map{$_}} @params\n"},{"code":"my ($mapped, $grepped); map { $mapped = wantarray } 1; grep { $grepped = wantarray } 1; [$mapped, $grepped]\n","out":"[\"\",\"\"]","err":""},{"out":"[\"FOO\\\\tBAR\\\\r\\\\n\",\"\"]","err":"","code":"my %map = ('\\t' => \"\\t\", '\\r' => \"\\r\", '\\n' => \"\\n\"); my $x = q{FOO\\tBAR\\r\\n}; my $y = s/(\\\\[trn])/$map{$1}/ge; [$x, $y]\n"},{"code":"my %map = ('\\t' => \"\\t\", '\\r' => \"\\r\", '\\n' => \"\\n\"); my $x = q{FOO\\tBAR\\r\\n}; my $y = s/(\\\\[trn])/$map{$1}/gre; [$x, $y]\n","err":"","out":"[\"FOO\\\\tBAR\\\\r\\\\n\",undef]"},{"out":"[\"FOO\\\\tBAR\\\\r\\\\n\",\"FOO\\tBAR\\r\\n\"]","err":"","code":"my %map = ('\\t' => \"\\t\", '\\r' => \"\\r\", '\\n' => \"\\n\"); my $x = q{FOO\\tBAR\\r\\n}; my $y = $x =~ s/(\\\\[trn])/$map{$1}/gre; [$x, $y]\n"},{"out":"[\"bar\",\"baz\"]","err":"","code":"my @matches = \"foobarbaz\" =~ /(ba.)/g; \\@matches\n"},{"err":"","out":"here","code":"my $meth = sub { 'here' }; main->$meth\n"},{"code":"my $meth = sub { 'here' }; notmain->$meth\n","out":"here","err":""},{"code":"my $meth = sub { 'here' }; undef->$meth\n","out":"here","err":""},{"err":"","out":"[[\"space\",\" \"],[\"digit\",3],[\"space\",\" \"],[\"digit\",5],[\"space\",\" \"],[\"digit\",1],[\"space\",\" \"],[\"digit\",7],[\"space\",\" \"]]","code":"my @m; push @m, $1 ? [ digit => $1 ] : [ space => $2 ] while \"foo 3 5 1 7 bar\" =~ m/(\\d+)|(\\s+)/g; \\@m\n"},{"err":"","out":"","code":"my $my->{my}\n"},{"code":"my (my (my $delilah))\n","out":"","err":""},{"out":"ERROR: No such class My at (eval 558) line 1, near \"; my My\"\nsyntax error at (eval 558) line 1, near \"$my :\"\n","err":"","code":"my My $my :Delilah;\n"},{"out":"","err":"","code":"my (my $x)\n"},{"err":"Out of memory!\n","out":"","code":"my $n = 0; while(1){print $n.\" \"; $n = $n+1;}\n"},{"code":"my $n = 20; my $t = 0; my @c; while ($n) { push @c, 1 << $t if $n & 1; $n >>= 1; $t++; } \\@c\n","out":"[4,16]","err":""},{"out":"[\"|1|2a|3abc\"]","err":"","code":"my $n = 3; my $str = q(|1|2a|3abc|4abcd|5abcde); [join q(|), (split /\\|/, $str)[0..$n]];\n"},{"out":"[\"Hello nonconvergent - what's up?\"]","err":"","code":"my $name = \"nonconvergent\"; my $s = \"Hello $name - what's up?\"; [$s]\n"},{"out":"2 - two","err":"","code":"my @names = qw(one two three); my @numbers = qw(1 2 3); for(0..$#numbers) { print $numbers[$_] . ' - ' . $names[$_] if $numbers[$_] == 2} # one option is to iterate by index rather than element\n"},{"code":"my $name = 'xx.xx.xx.xx'; $name =~ s/\\./_/g; $name\n","err":"","out":"xx_xx_xx_xx"},{"err":"","out":"[\"C\",\"D\"]","code":"my %notes = qw/0 C 2 D/; [ @notes{0,2} ]\n"},{"code":"my $not_really_an_array = (\"a\", \"b\"); $not_really_an_array # no arrays here\n","err":"","out":"b"},{"code":"my $n=split(/\\|/,\"one|two|three|four\");\n","err":"","out":"4"},{"code":"'my $num = 10; my  $res = ($num > 15 and $num < 30) ? \"Num is out of range\" : \"Num is in range\"; print $res .\"\\n\";'\n","err":"","out":"my $num = 10; my  $res = ($num > 15 and $num < 30) ? \"Num is out of range\" : \"Num is in range\"; print $res .\"\\n\";"},{"code":"my $num = 10; my  $res = ($num > 15 and $num < 30) ? \"Num is out of range\" : \"Num is in range\"; print $res .\"\\n\";\n","out":"Num is in range\n","err":""},{"code":"my $num = 42; my @array = (1, 2, qr/2$/); $num ~~ @array\n","out":"1","err":""},{"err":"","out":"ERROR: wat at (eval 558) line 1, <STDIN> line 1.\n","code":"my $num = 42; my @array = (1, 2, sub { die \"wat\" }); $num ~~ @array\n"},{"err":"","out":"1010110000001100","code":"my $num = 50; my $bitstring = unpack 'b*', $num;\n"},{"err":"","out":"0011010100110000","code":"my $num = 50; my $bitstring = unpack 'B*', $num;\n"},{"code":"my $num = \"99839489327429485246\"; $num =~ tr/89/01/; oct $num\n","out":"163026885721590438","err":""},{"code":"my $number = grep { $_ == 2 } (1, 2, 2, 2, 3); $number\n","out":"3","err":""},{"err":"","out":"azertyu iopqsdfghjklmwxcvbn","code":"my $obj = \"azertyu iopqsdfghjklmwxcvbn\"; $obj =~ s/(.{8})\\s.+?/$1/; $obj;\n"},{"out":"azertyuipqsdfghjklmwxcvbn","err":"","code":"my $obj = \"azertyui opqsdfghjklmwxcvbn\"; $obj =~ s/(.{8})\\s.+?/$1/; $obj;\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":"","code":"my $obj = \"azertyui opqsdfghjklmwxcvbn\"; $obj =~ s/(.{8})\\s[^\\n]+/$1/; [$obj;]\n"},{"code":"my $obj = \"azertyui opqsdfghjklmwxcvbn\"; $obj =~ s/(.{8})\\s[^\\n]+/$1/; [$obj]\n","out":"[\"azertyui\"]","err":""},{"code":"my $obj = bless {};  ($a, $b, $c) = ($obj) x 3; [$a, $b, $c]\n","err":"","out":"[bless( {}, 'main' ),$VAR1->[0],$VAR1->[0]]"},{"err":"","out":"{5 => 6,7 => 8,1 => 2}","code":"my %old = (1..10); +{ %old{1,5,7} }\n"},{"code":"my %old_hash = (1 => 2, 3 => undef); my %new_hash = reverse %old_hash; \\%new_hash\n","out":"{\"\" => 3,2 => 1}","err":""},{"code":"my %old_hash = (1 => 2, 3 => undef); my %new_hash = reverse %old_hash; %new_hash\n","err":"","out":"2/8"},{"out":"[0]","err":"","code":"my $one = \"1\"; my $two = $one + \"0 but true\"; [ $one ^ $one ];\n"},{"code":"my $one = 1; my $two = $one . \" used as a string?\"; [ $one ^ $one ];\n","out":"[0]","err":""},{"err":"","out":"[\"\\0\"]","code":"my $one = \"1\"; [ $one ^ $one ];\n"},{"err":"","out":"[0]","code":"my $one = 1; [ $one ^ $one ];\n"},{"code":"my @one = qw(1 2 3); @one = (); my @two; @two = (); [ (defined(@one) ? 'defined' : 'undef'), (defined(@two) ? 'defined' : 'undef') ]\n","out":"ERROR: Can't use 'defined(@array)' (Maybe you should just omit the defined()?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"my $optional = 1; my $alternative = 1; print ([\"\", \"Optional.\", \"Alternative.\", \"Optional and alternative.\"]->[($alternative ? 2 : 0) + ($optional ? 1 : 0)])\n","out":"Optional and alternative.","err":""},{"code":"my $orig = 'abcdef'; my $str = $orig =~ s/(cde)//r; my $removed = $1; [$orig, $str, $removed]\n","out":"[\"abcdef\",\"abf\",\"cde\"]","err":""},{"err":"lemmings!!!(eval 558) line 1, <STDIN> line 1.\n","out":"1","code":"my $orig = $SIG{__WARN__}; local $SIG{__WARN__} = sub { my $warn = shift; $warn =~ s/ at /!!!/g; local $SIG{__WARN__} = $orig; warn $warn }; warn 'lemmings' # could just double-local it\n"},{"code":"my (our $x);\n","err":"","out":""},{"code":"my @out; { local our @tmp; 'abcdefghi' =~ /c(?:(.)(?{ local @tmp = (@tmp, $^N) })){4}(?{ @out = @tmp })/ or die } \\@out\n","err":"","out":"[\"d\",\"e\",\"f\",\"g\"]"},{"code":"my @out; { local our @tmp; 'abcdefghi' =~ / (?:(.)(?{ local @tmp = (@tmp, $^N) })){4}(?{ @out = @tmp }) (?= $ ) /x or die } \\@out\n","err":"","out":"[\"f\",\"g\",\"h\",\"i\"]"},{"err":"","out":"ERROR: Can't localize through a reference at (eval 558) line 1, <STDIN> line 1.\n","code":"my @out; { my $tmp = []; 'abcdefghi' =~ /c(?:(.)(?{ local @$tmp = (@$tmp, $^N) })){4}(?{ @out = @$tmp })/ or die } \\@out\n"},{"out":"[\"d\",\"e\",\"f\",\"g\"]","err":"","code":"my @out; { our @tmp; 'abcdefghi' =~ /c(?:(.)(?{ local @tmp = (@tmp, $^N) })){4}(?{ @out = @tmp })/ or die } \\@out\n"},{"out":"[\"foo\",\"bar\",\"baz\",\"quux\",\"teeen\"]","err":"","code":"my @packets = qw(foo=ba r=baz= quux =teeen); my @chunks; my $prev = ''; for my $part (@packets) { my @pieces = split /=/, $part, -1; $pieces[0] = $prev . $pieces[0]; $prev = pop @pieces; push @chunks, @pieces; } push @chunks, $prev; \\@chunks\n"},{"err":"","out":"ERROR: Undefined subroutine &CORE::print called at (eval 558) line 1, <STDIN> line 1.\n","code":"my $p = \\&CORE::print; $p->(\"foo\")\n"},{"code":"my $pi = atan2(0, -1); my $x = $pi; [ $pi, map { $x *= 1e10; ($x - int $x)*1e10;  } 1..10 ]\n","err":"","out":"[\"3.14159265358979\",\"8979301452.63672\",0,0,0,0,0,0,0,0,0]"},{"err":"","out":"['31415926535',\"0.897930145263672\"]","code":"my $pi = atan2(0, -1); $pi *= 1e10; [ int $pi, $pi - int $pi ]\n"},{"err":"","out":"[\"3.14159265358979e+20\",0]","code":"my $pi = atan2(0, -1); $pi *= 1e20; [ int $pi, $pi - int $pi ]\n"},{"out":"[\"b\",\"a\"]","err":"","code":"my %pool = (param0 => 'a', param1 => 'b'); [ map { $pool{$_} } 'param1', 'param0' ]\n"},{"code":"my %pool = (param0 => 'a', param1 => 'b'); [ @pool{'param1', 'param0'} ]\n","err":"","out":"[\"b\",\"a\"]"},{"code":"my %pool = qw(param0 altreus param1 cats); my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \\{ ([^{]+) \\}/push @params, $pool{$2}; $1 . 's'/gex; printf $str, @params\n","out":"foocats                             baraltreus","err":""},{"code":"my %pool = qw(param0 altreus param1 cats); my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \\{ ([^{]+) \\}/push @params, $pool{\"param$2\"}; $1 . 's'/gex; printf $str, @params\n","out":"foo                                 bar","err":""},{"code":"my $pos = 3; my $ref = '1'; my $seq = [qw(a b c d e f g h i j)]; join '', @{$seq}[($pos - 1)..(($pos-2) + length($ref))] # off by 2, I think?\n","err":"","out":"c"},{"code":"my $p = \"(part1).*(part2)\"; \"foopart1barpart2\" =~ /$p/; print \"$1 $2\";\n","err":"","out":"part1 part2"},{"code":"my $prev; for my $cur (\"A\" .. \"D\") { print \"($prev $cur) \"; } continue { $prev = $cur; }\n","err":"","out":"( A) (A B) (B C) (C D) "},{"code":"my $_ = q,asdf \"foo\"='bar baz',; my $h = 0x20000; my %h; s/(([\"'])(?:[^\"']+|\\\\.|(?!\\2).)*\\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split ' '; $h = chr($h-1); s/([\\x{20000}-$h])/$h{$1}/g for @words; \\@words;\n","err":"","out":"[\"asdf\",\"\\\"foo\\\"='bar baz'\"]"},{"code":"my $_ = q, echo foo bar=baz hmm=\"1 2 3\" nn='aa bb',; my $h = 0x20000; my %h; s/(([\"'])(?:[^\"']+|\\\\.|(?!\\2).)*\\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split /\\s+/; $h = chr($h-1); s/([\\x{20000}-$h])/$h{$1}/g for @words; \\@words;\n","out":"[\"\",\"echo\",\"foo\",\"bar=baz\",\"hmm=\\\"1 2 3\\\"\",\"nn='aa bb'\"]","err":""},{"code":"my qw( $foo ); $foo = 123; $foo; ### Why does this not work?\n","out":"ERROR: No such class qw at (eval 558) line 1, near \"; my qw\"\n","err":""},{"out":"HASH","err":"","code":"my $r = bless [], \"HASH\";  ref $r\n"},{"err":"","out":"[\"a\"]","code":"my @rc; my @vals = ('a','b','c'); (0 ? @rc : $rc[0]) = @vals; \\@rc\n"},{"code":"my @rc; my @vals = ('a','b','c'); 0 ? @rc : $rc[0] = @vals; \\@rc\n","out":"[3]","err":""},{"out":"[\"a\",\"b\",\"c\"]","err":"","code":"my @rc; my @vals = ('a','b','c'); (1 ? @rc : $rc[0]) = @vals; \\@rc\n"},{"out":"2","err":"","code":"my @rcolors = (\"red\", \"orange\", \"color green\"); my $count = 0; for (@rcolors) { last if /color green/; } continue { $count++; } $count; # seems unlikely\n"},{"out":"ARRAY","err":"","code":"my $r = \\&CORE::ref; $r->([])\n"},{"err":"","out":"ERROR: failed at (eval 558) line 1, <STDIN> line 1.\n","code":"my $readfromfile = '[x'; my $re = eval { qr/$readfromfile/; 1 } or die 'failed'; [ $re ]\n"},{"err":"","out":"[1]","code":"my $re = 'asdf'; ['asdfasdf' =~ /^\\Q$re\\E.*$/]\n"},{"code":"my $re = 'asdf\\E.*'; ['asdfasdf' =~ /^\\Q$re$/]\n","err":"","out":"[]"},{"out":"{foo => \"moomoomoo\",baz => \"moomoomoomoo\"}","err":"","code":"my $records = { foo => \"bar\", baz => \"quux\" }; s/./moo/g for values %$records; $records\n"},{"err":"","out":"123\na\nb\nc\n","code":"my $recurse = sub { ref ? __SUB__->($_) : say for values $_[0] }; $recurse->({x => 123, y => [qw(a b c)]}) # this\n"},{"code":"my ($red, $green, $blue) = (100, 100, 100); sprintf '#%02x%02x%02x', $red, $green, $blue;\n","err":"","out":"#646464"},{"out":"1\n2\n3\n4\n","err":"","code":"my $ref = [1,2,3,4]; for my $item (@$ref) { print $item, \"\\n\" }\n"},{"code":"my $ref = [1,2,3]; push @{$ref}, \"hi\"; $ref\n","err":"","out":"[1,2,3,\"hi\"]"},{"out":"{4 => \"quux\",3 => \"baz\",5 => \"floop\"}","err":"","code":"my $ref = { 1 => foo => 2 => bar => 3 => baz => 4 => quux => 5 => 'floop' }; %{ $ref } = %{ $ref }{ (reverse sort keys %$ref)[0 .. 2] }; $ref # joobie\n"},{"err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","code":"my $ref = \\42; ${$ref} = \"hi\";\n"},{"code":"my $ref = [[8],[9],[10]]; @{$ref}[0,1,2]->[0]\n","err":"","out":"10"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"][\"\n","code":"my $ref = [[8],[9],[10]]; @{$ref}[0,1,2][0]\n"},{"code":"my $ref = do { \\ my $foo; }; ref $ref\n","out":"SCALAR","err":""},{"out":"42","err":"","code":"my $ref = \\&foo; $ref->(21);  sub foo { $_[0] * 2 }\n"},{"code":"my $refName = [ 'one', 'two', 'three', 'four', 'five' ];  my @slice = (1,3);  my @values = @{$refName}[@slice];  \\@values\n","out":"[\"two\",\"four\"]","err":""},{"code":"my $refName = [ 'one', 'two', 'three', 'four', 'five' ];  my @values = @{$refName}[1,3];  \\@values\n","out":"[\"two\",\"four\"]","err":""},{"out":"[\"b\",\"c\"]","err":"","code":"my $ref = [ qw/ a b c / ]; [ @{ $ref }[1,2] ]\n"},{"err":"","out":"0 1 2 ","code":"my $ref = [qw/foo bar baz/]; for $i (keys $ref) { print \"$i \"; }\n"},{"code":"my $re = \"motd \\\\^(.*)\"; [ map /$re/, 'motd ^something' ] # vs. /motd \\^/\n","out":"[\"something\"]","err":""},{"err":"","out":"foo","code":"my @replacements = (['foo', 'bar', 'baz'], ['quux']); $replacements[0][0]\n"},{"err":"","out":"[\"vkAuth?code=edb31139a2f04d22a8\"]","code":"my $re = '/projects/test/(.*)'; [ \"/projects/test/vkAuth?code=edb31139a2f04d22a8\" =~ $re ]\n"},{"code":"my $re = '/projects/(\\w+)/(.*)'; [ \"/projects/test/vkAuth?code=edb31139a2f04d22a8\" =~ $re ]\n","err":"","out":"[\"test\",\"vkAuth?code=edb31139a2f04d22a8\"]"},{"out":"[]","err":"","code":"my $re = '/projects/(\\w+)/test/(.*)'; [ \"projects/test/vkAuth?code=edb31139a2f04d22a8\" =~ $re ]\n"},{"out":"qr/[[]/u","err":"","code":"my $re = qr/[[]/\n"},{"code":"my $re = qr/ blah \\n | \\n blah1 \\n | \\n yada/x; print \"Failed\\n\" if 'testing' =~ $re\n","out":"","err":""},{"out":"Match","err":"","code":"my $re = qr/^To: .*helpme\\@mydomain.com/; 'To: Some person<helpme@mydomain.com> lalala' =~ $re ? \"Match\" : \"No match\"\n"},{"code":"my $re = qr/(?<!x)(x+)(??{ my $len = length $1; \"y{$len}\" })(?!y)/; [ map { scalar $_ =~ $re } qw(xxyy xxy xyy) ]\n","out":"[1,\"\",\"\"]","err":""},{"err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","code":"my @res = map { chomp; $_ if (-f $_) } qw(dupes.txt allfiles.bak.txt hahaha.setnhue); print join(' ', @res) . \"\\n\";\n"},{"code":"my ($result) = \"a numeric example: 42\" =~ /(\\d+)/; $result # note the lack of \\\n","err":"","out":"42"},{"err":"","out":"[\"\"]","code":"my $result = do { \"my string\" for 1 .. 8 };  [$result]\n"},{"out":"","err":"","code":"my $result = do { \"my string\" for 1 .. 8 };  $result\n"},{"code":"my $result; if (0) { $result = \"if\"; } elsif (1) { $result = \"elsif\"; } else { $result = \"else\"; } [$result]\n","err":"","out":"[\"elsif\"]"},{"code":"my $result = sprintf '%.28f', '1.43531262539073e-11'; { local $/ = '0'; 1 while chomp($result) } $result # let perl work it out\n","out":"0.0000000000143531262539072984","err":""},{"out":"{whatevs => 78}","err":"","code":" my $result = sub { my $str = \"foo:12 bar:34 baz:45\"; $str =~ /foo:(?<foo>\\d+) bar:(?<bar>\\d+) baz:(?<baz>\\d+)/; return \\%+ }->(); 'x: 78' =~ /\\w+: (?<whatevs>\\d+)/; +{ %$result } # yeah, you'll just get the results from whichever regex is in the current scope\n"},{"err":"","out":"[10,1,2]","code":"my $ret = my ($x, $y) = 1..10; [ $ret, $x, $y ];\n"},{"err":"","out":"[11,9,10]","code":"my $ret = my ($x, $y) = 9..19; [ $ret, $x, $y ];\n"},{"code":"my $ret = my ($x, $y, @z) = 9..19; [ $ret, $x, $y, \\@z ]; # For those wondering, the right way to grab the rest of the elements.\n","out":"[11,9,10,[11,12,13,14,15,16,17,18,19]]","err":""},{"out":"[2,9,10,[9,10]]","err":"","code":"my $ret = my @z = my ($x, $y) = 9..19; [ $ret, $x, $y, \\@z ];\n"},{"code":"my $return = print \"hello, here is my message\";   $return\n","out":"hello, here is my message","err":""},{"code":"my @rocks = qw (granite rubble lava slate); [ grep { $rocks[$_] =~ /a/ } 0..$#rocks ]\n","err":"","out":"[0,2,3]"},{"code":"my %roman; sub r :lvalue { $roman{$_[0]} }  ( r(\"I\"), r(\"II\"), r(\"III\"), r(\"IV\"), r(\"V\") ) = 1..5;  \\%roman\n","err":"","out":"{I => 1,V => 5,II => 2,IV => 4,III => 3}"},{"code":"my %s = (1,2,3,4,5,6); my $pre = %s; delete @s{keys %s}; [$pre, scalar %s]\n","err":"","out":"[\"3/8\",0]"},{"code":"my %s = (1,2,3,4,5,6); %s+1\n","err":"","out":"4"},{"out":"3","err":"","code":"my %s = (1,2,3,4,5,6); scalar keys %s\n"},{"out":"[\"3/8\",3,3]","err":"","code":"my %s = (1,2,3,4,5,6); [ scalar %s, 0+%s, 0+keys %s ]\n"},{"out":"[\"3/8\",4,3]","err":"","code":"my %s = (1,2,3,4,5,6); [ scalar %s, 1+%s, 0+keys %s ]\n"},{"err":"","out":"1-2-3,4,5","code":"my $s = \"1,2,3,4,5\"; join \"-\", split \",\", $s, 3;\n"},{"out":"[\"HELLO\",\"hi\"]","err":"","code":"my $s1 = q#([A-Z]+)# ; my $s2 = q#([a-z]+)#; my @foo = (\"HELLO-hi\" =~ /$s1-$s2/); [@foo]\n"},{"out":"ab","err":"","code":"my ($s1, $s2) = qw/abc abx/; my $prefix = ($s1 ^ $s2) =~ /\\A(\\0*)/ ? substr($s1, 0, length $1) : ''; $prefix\n"},{"out":"[7,\" \"]","err":"","code":"my $s = \"3 5 1 7 \";  my @m = $s =~ /^(?:(\\d)(\\s))+$/g; \\@m;\n"},{"code":"my $s = \"3 5 1 7 \";  my @m = $s =~ /^(?:(\\d)(\\s))+$/; \\@m;\n","out":"[7,\" \"]","err":""},{"code":"my $s = \"aabaaaaaaaaaaaab\"; @x = /(a++b)/; [@x]\n","err":"","out":"[]"},{"code":"my $s = \"abcdefghijklmnopqrstuvwxyz\"; $s =~ tr/a-e/A-E/; [$s]\n","err":"","out":"[\"ABCDEfghijklmnopqrstuvwxyz\"]"},{"err":"","out":"abc","code":"my $s = 'ABC'; $s =~ s/([A-Za-z])/join '', map chr(ord ^ 32), split '', $1/ge; $s   # pretty, portable, uses s//, what's not to like?\n"},{"out":"[\"AB\"]","err":"","code":"my $s = \"A#B\"; $s =~ s/[#]//; [ $s ]\n"},{"code":"my $scalar = [1,2,3]; \"$scalar\"\n","out":"ARRAY(0x5c4ad28)","err":""},{"out":"[1,2,3]","err":"","code":"my $scalar = [1,2,3]; $scalar\n"},{"code":"my $scalar_ref = \\\\\\1; $$$$scalar_ref\n","out":"1","err":""},{"code":"my $search = \"hot chicks\"; $search =~ tr/ /%20/; print $search\n","out":"hot%chicks","err":""},{"code":"my $search = \"hot chicks\"; $search =~ tr/hot/123/; print $search\n","err":"","out":"123 c1icks"},{"err":"","out":"hot+chicks","code":"my $search = \"hot chicks\"; $search =~ tr/ /+/; print $search\n"},{"out":"[\"ILMT::HIN::PAN::UTF2WX\"]","err":"","code":"my $search_path = \"ILMT::HIN::PAN\"; [ grep /^${search_path}::[^:]+$/, \"ILMT::HIN::PAN::UTF2WX\" ]\n"},{"out":"[]","err":"","code":"my $search_path = \"ILMT::HIN::PAN\"; [ grep /^${search_path}::[^:]+$/, \"ILMT::HIN::PAN::UTF2WX::UTF2WX\" ]\n"},{"code":"my %seen; my $i = 0; $seen{$_} = ++$i for 'one','two','three'; \\%seen\n","err":"","out":"{one => 1,three => 3,two => 2}"},{"out":"{\"\" => 1}","err":"","code":"my %seen; my $i = 0; $seen{''} = ++$i; \\%seen\n"},{"code":"my %seen; $seen{''} = 123; print $seen{''};\n","err":"","out":"123"},{"err":"","out":"{}","code":"my %seen; $seen{foo} // 1; \\%seen\n"},{"code":"my %seen; $seen{foo}; $seen{bar}; \\%seen\n","err":"","out":"{}"},{"out":"2\n","err":"","code":"my %seen; $seen{''} //= keys(%seen)+1; print $seen{''}.\"\\n\";\n"},{"out":"2","err":"","code":"my %seen; $test=\"one\"; $seen{$test} //= keys(%seen)+1; print $seen{$test};\n"},{"code":"my %seen; $test=\"one\"; $seen{$test} //= keys(%seen); print $seen{$test};\n","err":"","out":"1"},{"code":"my %seen; $test=\"one\"; $seen{$test} = [keys(%seen)]; \\%seen\n","out":"{one => []}","err":""},{"err":"","out":"{one => [\"one\"]}","code":"my %seen; $test=\"one\"; $seen{$test} //= [keys(%seen)]; \\%seen\n"},{"code":"my ( $self ) = @_;\n","out":"1","err":""},{"err":"","out":"1","code":"my ( $self ) = $_;\n"},{"code":"my $self = bless {}; $self->goats();\n","err":"","out":"ERROR: Can't locate object method \"goats\" via package \"main\" at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"my $self = +{}; $self->{messages} = [1,2,3]; $self->{messages}->[0] = \"a\"; $self->{messages}\n","err":"","out":"[\"a\",2,3]"},{"code":"my $sentence = \" I saw the the router.\"; [$sentence =~ /([a-zA-Z]+)\\s+\\1/]\n","err":"","out":"[\"the\"]"},{"code":"my @sets_list1 = (4,5,6); [ (map [ $_ ], @sets_list1), (map [ @sets_list1[0..$_] ], -1..$#sets_list1) ];\n","err":"","out":"[[4],[5],[6],[],[4],[4,5],[4,5,6]]"},{"code":"my $s = \"foo 3 5 1 7 bar\";  my @m = $s =~ /(?:(\\d)(\\s))/g; \\@m;\n","err":"","out":"[3,\" \",5,\" \",1,\" \",7,\" \"]"},{"err":"","out":"[3,\" \",5,\" \",1,\" \",7,\" \"]","code":"my $s = \"foo 3 5 1 7 bar\";  my @m = $s =~ /(\\d)(\\s)/g; \\@m;\n"},{"code":"my $s = \"foo 3 5 1 7 bar\";  my @m = $s =~ /(?:(\\d)(\\s))/g; \\@m;  # JQKP\n","err":"","out":"[3,\" \",5,\" \",1,\" \",7,\" \"]"},{"code":"my $s = \"foo 3 5 1 7 bar\";  my @m = $s =~ /(?:(\\d)(\\s))/g; \\@m; # wasn't your earlier example already capturing what you wanted?\n","out":"[3,\" \",5,\" \",1,\" \",7,\" \"]","err":""},{"code":"my $s = \"foo 3 5 1 7 bar\";  my @m = $s =~ /(?:(\\d)(\\s))/g; say join \"|\", @m;  # JQKP\n","out":"3| |5| |1| |7| \n","err":""},{"out":"[\"foobarbaz\\r\\n\"]","err":"","code":"my $s = \"foo\\r\\nbar\\r\\nbaz\\r\\n\"; $s =~ s/\\R(?=.)//g; [ $s ];\n"},{"err":"","out":"0","code":" my ($sha) = split(' ', readpipe(\"sha1sum\", $filename));\n"},{"err":"","out":"[\"Hello  My name is .\"]","code":"my $s = \"Hello (hey) My name is (rindolf).\"; $s =~ s/\\([^)]*\\)//g; [$s]\n"},{"code":"my $s = \"Hello.label\"; if (my ($m) = $s =~ /^(.*)\\.label$/) { print \"Matched <$m>\\n\"; }\n","err":"","out":"Matched <Hello>\n"},{"code":"my $s = \"Hello\" [ref($s)]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"\"Hello\" [\"\n"},{"out":"[\"\"]","err":"","code":"my $s = \"Hello\"; [ref($s)]\n"},{"code":"my $s = \"Hello\"; [($s eq \"Good\" or \"Way\")]\n","out":"[\"Way\"]","err":""},{"code":"my $s = \"Hello\"; $s .= \" rrman!\"; [$s]\n","err":"","out":"[\"Hello rrman!\"]"},{"code":"my $s = \"      Hello\"; $s =~ s/^\\s//; [$s]\n","err":"","out":"[\"     Hello\"]"},{"out":"[\"Hello\"]","err":"","code":"my $s = \"      Hello\"; $s =~ s/^\\s+//; [$s]\n"},{"code":"my $s = \"hello world <120423424> one two three\"; $s =~ s/\\A((?:\\S+\\s+){2})<([0-9]+)>/$1$2/; [$s]\n","err":"","out":"[\"hello world 120423424 one two three\"]"},{"code":"my $s = \"hello world <120423424> one two three\"; $s =~ s/\\A(?:\\S+\\s+){2}\\K<([0-9]+)>/$1/; [$s]\n","err":"","out":"[\"hello world 120423424 one two three\"]"},{"out":"[\"Hello \"]","err":"","code":"my $s = \"Hello World\"; $s=~ /Wor/; [$`]\n"},{"code":"my %sieve; my @primes = (2,3); my ($p_i, $p, $q, $n)=(1,3,9,3); push @primes, do { { $n += 2; if ( my $s = delete $sieve{$n} ) { push @{$sieve{$n + $_}}, $_ for @$s; redo } elsif ( $n < $q ) { $n } else { push @{$sieve{$q + $p*2}}, $p * 2; $p = $primes[++$p_i]; $q = $p*$p; redo } } } until @primes >= 1000; \\%sieve;\n","err":"","out":"{7995 => [82],7923 => [38,6],7973 => [134],8023 => [142],7939 => [34],7979 => [158],7935 => [46],7943 => [94,26],7931 => [22,14],7967 => [62],7925 => [10],8003 => [106],7965 => [118],7991 => [122],7955 => [86,74],7957 => [146],7975 => [58],8051 => [166]}"},{"out":"[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541]","err":"","code":"my %sieve; my @primes = (2,3); my ($p_i, $p, $q, $n)=(1,3,9,3); push @primes, do { { $n += 2; if ( my $s = delete $sieve{$n} ) { push @{$sieve{$n + $_}}, $_ for @$s; redo } elsif ( $n < $q ) { $n } else { push @{$sieve{$q + $p*2}}, $p * 2; $p = $primes[++$p_i]; $q = $p*$p; redo } } } until @primes >= 100; \\@primes;\n"},{"err":"","out":"{553 => [14],543 => [6],561 => [34,22],551 => [38],559 => [26],575 => [46],545 => [10]}","code":"my %sieve; my @primes = (2,3); my ($p_i, $p, $q, $n)=(1,3,9,3); push @primes, do { { $n += 2; if ( my $s = delete $sieve{$n} ) { push @{$sieve{$n + $_}}, $_ for @$s; redo } elsif ( $n < $q ) { $n } else { push @{$sieve{$q + $p*2}}, $p * 2; $p = $primes[++$p_i]; $q = $p*$p; redo } } } until @primes >= 100; \\%sieve;\n"},{"out":"[\"llama\",\"lamal\",\"amall\",\"malla\",\"allam\"]","err":"","code":"my $s = \"llama\"; [ map { substr($s, $_).substr($s, 0, $_) } 0..4 ]\n"},{"code":"my $s; my $c = sub { warn $s }; for $s (1,2,3) { $c->(); }\n","out":"","err":"Warning: something's wrong at (eval 558) line 1, <STDIN> line 1.\nWarning: something's wrong at (eval 558) line 1, <STDIN> line 1.\nWarning: something's wrong at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"my @some_array = qw/0 1 2 3 4 5 6 7 8 9 10/; my (@primes, $zero) = @some_array[2,3,5,7,0]; print \"@primes%\"; print !defined $zero;\n","out":"2 3 5 7 0%1","err":""},{"code":"my $s = \"<One> Two <Three> Four <Five>\"; [$s =~ /<([^>]+)>/g]\n","out":"[\"One\",\"Three\",\"Five\"]","err":""},{"err":"","out":"[2]","code":"my $s = \"one.two.three\"; my $count = $s =~ tr/././; [$count]\n"},{"out":"... foo             => bar","err":"","code":"my $space = 15; printf(\"... %-${space}s => %s\", \"foo\", \"bar\");\n"},{"out":"...             foo => bar","err":"","code":"my $space = 15; printf(\"... %${space}s => %s\", \"foo\", \"bar\");\n"},{"err":"","out":"... foo                => bar","code":"my $space = 15; printf(\"... %s%${space}s => %s\", \"foo\", \"\", \"bar\");\n"},{"code":"my $s = q{abc}; [ $s =~ /(?:abc(foo|bar|baz)|)/ ]; # anno, seems it does returns undef.\n","err":"","out":"[undef]"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","err":"","code":"my $s = q{abc}; [ $s =~ /(?:abc(foo|bar|baz)|)/ # anno, seems it does returns undef.\n"},{"code":"my $s = q{foo=bar=baz}; my $p = qr/=(.*?)=/; my $r = q{,$1,}; $s =~ s/$p/$r/re;\n","err":"","out":"foo,$1,baz"},{"out":"foobaz","err":"","code":"my $s = q{foo=bar=baz}; my $p = qr/=(.*?)=/; my $r = q{,$1,}; $s =~ s/$p/$r/ree;\n"},{"out":"foo,bar,baz","err":"","code":"my $s = q{foo=bar=baz}; my $p = qr/=(.*?)=/; my $r = q{\",$1,\"}; $s =~ s/$p/$r/ree\n"},{"code":"my $s = q{foo=bar=baz}; my $p = qr/=/; my $r = ','; $s = s/$p/$r/;\n","out":"","err":""},{"out":"","err":"","code":"my $s = q{foo=bar=baz}; my $p = qr/=/; my $r = ','; $s = s/$p/$r/r;\n"},{"err":"","out":"foo,bar,baz","code":"my $s = q{foo=bar=baz}; my $p = qr/=/; my $r = ','; $s =~ s/$p/$r/rg;\n"},{"code":"my sql $db: cool cool\n","err":"","out":"ERROR: No such class sql at (eval 558) line 1, near \"; my sql\"\nsyntax error at (eval 558) line 1, near \"$db:\"\n"},{"code":"my $s = qq{ 0xFF }; [ 0+$s ];\n","out":"[0]","err":""},{"out":"[\"1234.5\"]","err":"","code":"my $s = qq{ 1234.5 }; [ 0+$s ];\n"},{"out":"[\"Hello \\\"World\\\"!\"]","err":"","code":"my $s = qq{Hello \"World\"!}; [$s]\n"},{"err":"","out":"same test","code":"my $s = 'some text'; my $f = 's/x/s/g; s/o/a/g;'; eval $f for $s; $s # if you want to limit the scope... why is there a string eval involved anyway\n"},{"code":"my $_ = \"â\"; s/(.)/sprintf('\\\\u%04x', ord \"$1\")/ger\n","out":"\\u00e2\\u0098\\u0083","err":""},{"code":"my $s = sub { \"x${_}y\" }; join '-', map $s->(), 1..3;\n","out":"x1y-x2y-x3y","err":""},{"code":"my (state $foo)\n","out":"","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"$state_var sub function_that_uses_state_var \"\nsyntax error at (eval 558) line 1, near \"} }\"\n","code":"{ my $state_var sub function_that_uses_state_var { ... } }\n"},{"code":"{ my $state_var; sub function_that_uses_state_var { ...; } }\n","out":"","err":""},{"code":"my $str = \"001.html\"; my @pats = (qr/^\\d\\d\\d\\.html/); print \"fail\" unless $str ~~ @pats;\n","err":"","out":"1"},{"out":"1","err":"","code":"my $str = \"001.html\"; my @pats = (qr/\\d\\d\\d\\.html/); print \"fail\" unless $str ~~ @pats;\n"},{"code":"my $str = \"001.html\"; my @pats = (qr/\\d\\d\\d\\.html); print \"fail\" unless $str ~~ @pats;\n","out":"ERROR: Search pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"my $str = \"001.html\"; my $re = qr/^\\d\\d\\d\\.html/;  $str =~ /$re/ ? \"ok\" : \"fail\"\n","err":"","out":"ok"},{"err":"","out":"[\"\\0\"]","code":"my $str = \"\\0\"; [ $str ]\n"},{"code":"my $str = '123456'; substr $str, -2, 0, ','; $str\n","out":"1234,56","err":""},{"err":"","out":"[123,\"AG\",3,\"GC\",\"AT\",422,\"TG\",3]","code":"my $str = \"123AG3GCAT422TG3\"; my @groups = $str =~ m/(\\d+|[[:alpha:]]{2})/g; \\@groups\n"},{"code":"my $str = \"13month\"; my ($N, $dep) = $str =~ m/(\\d+)(\\w+)/; print \"$N; $dep\"\n","out":"13; month","err":""},{"err":"","out":"[\"#\",18,0,18,0,\"Chunk\",\"17:25:25\",\"17:25:25\",2,\"arabidopsis_thaliana_core_28_81_10.analysis_description\"]","code":"my $str = \"#     18       0     18      0 Chunk     17:25:25 17:25:25 2    arabidopsis_thaliana_core_28_81_10.analysis_description\"; [split /\\s+/, $str]\n"},{"err":"","out":"\u0013+*","code":"my $str = \"\\23\\53\\52\"; $str # Grinnz_\n"},{"code":"my $str = \"\\\\23\\\\53\\\\52\"; $str =~ s/\\\\(\\d\\d)/chr $1/eg; $str\n","err":"","out":"\u001754"},{"code":"my $str = \"\\23\\53\\52\"; $str =~ s/\\\\(\\d\\d)/chr $1/eg; $str\n","err":"","out":"\u0013+*"},{"out":"\u0013+*","err":"","code":"my $str = \"\\\\23\\\\53\\\\52\"; $str =~ s/\\\\(\\d\\d)/chr oct $1/eg; $str\n"},{"code":"my $str = '2 4 8 16'; my $match = '(\\d+)'; my $subst = '$1 / 2'; $str =~ s/$match/$subst/ge; $str\n","err":"","out":"$1 / 2 $1 / 2 $1 / 2 $1 / 2"},{"code":"my $str = \"4 8 16 7\"; $str =~ s{(\\d+)}{$1 / 2}ge; print $str\n","out":"2 4 8 3.5","err":""},{"code":"my $str = \"aabbcc\"; $str =~ s/((\\w)\\1)/ $1 /g; $str\n","err":"","out":"aabbcc"},{"code":"my $str = \"aabbcc\"; $str =~ s/(\\w)\\1/ $& /g;\n","out":"3","err":""},{"code":"my $str = \"aabbcc\"; $str =~ s/(\\w)\\1/ $& /g; $str\n","err":"","out":" aa  bb  cc "},{"code":"my $str = \"aabbcc\"; $str =~ s/((\\w)\\2)/ $1 /g; $str\n","out":" aa  bb  cc ","err":""},{"code":"my $str = \"a b c d e f g h i j h k l\"; [ (split \" \", $str)[2,5-8,10] ]\n","out":"[\"c\",\"h\",\"h\"]","err":""},{"code":"my $str = \"a b c d e f g h i j h k l\"; [ (split \" \", $str)[2,5..8,10] ]\n","err":"","out":"[\"c\",\"f\",\"g\",\"h\",\"i\",\"h\"]"},{"err":"","out":"[\"adgjmpsvyz\"]","code":"my $str = 'abcdefghijklmnopqrstuvwxyz'; [ join '', split /(.)../, $str ] # depends on how you define 'easiest'\n"},{"code":"my $str = 'abcdefghijklmnopqrstuvwxyz'; join '', $str =~ /..(.)/g\n","err":"","out":"cfilorux"},{"code":"my $str = 'abcdefghijklmnopqrstuvwxyz'; $str =~ s/..(.)/$1/gr\n","out":"cfiloruxyz","err":""},{"err":"","out":"[\"abc\"]","code":"my $str = 'abc def'; [ $str =~ m/^(\\w*)/ ]\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":"","code":"my $str = 'abc def'; [ $str =~ m/^(\\w*)/; ]\n"},{"err":"","out":"cde","code":"my $str = 'abcdef'; $str =~ s/(cde)//; my $removed = $1; $removed\n"},{"code":"my $str = 'abcdef'; $str =~ s/(cde)//; my $removed = $1; [$str, $removed]\n","err":"","out":"[\"abf\",\"cde\"]"},{"code":"my $str = 'abc def'; [ $str =~ /^(\\w*)/; ]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":"","code":"my $str = 'abc def'; [ $_ =~ /^(\\w*)/; ]\n"},{"out":"a_b_c_da_b_c","err":"","code":"my $str = \"a_b_c_d\"; my $newstr = $str =~ s/_[^_]*$//r; print $str, $newstr\n"},{"code":"my $str = 'abcd'; substr($str, 2, 2).substr($str, 0, 2)\n","out":"cdab","err":""},{"code":"my $str = \"abc\"; my $len = length $str; my $copy = $str; my @rslt; for(1..2**$len-1) { my $idx = 0; do { substr($copy, $idx, 1) ^= \" \" } until substr($copy, $idx, 1) eq uc substr($str, $idx++, 1); push @rslt, $copy } \\@rslt\n","err":"","out":"[\"Abc\",\"aBc\",\"ABc\",\"abC\",\"AbC\",\"aBC\",\"ABC\"]"},{"out":"[\"Anna\",\"barbara\",\"cindy\",\"deborah\",\"ellen\",\"fiona\",\"greta\"]","err":"","code":"my $str = \"Anna: barbara (>= 0.6.16), cindy (>= 0.6.16), deborah (>= 2.7), ellen (= 1.5.3-5+deb7u1), fiona (>= 1.4.2), greta (>= 1.4.0)\"; my @girls = $str =~ /\\b([a-z]+)\\b/ig; [@girls]\n"},{"code":"my $str = \"ÃÃ¶\"; [ $str =~ /([[:upper:]])/ ]\n","out":"[\"\\303\"]","err":""},{"out":"woot","err":"","code":"my $str = '{ awf wv qwea vwev eaga }END'; return \"woot\" if ($str =~ m#^{.*}END$#);\n"},{"err":"","out":"[\"vivek\",\"jena\"]","code":"my $str = \"Buyer information:vivek jena\"; my ($first, $second) = $str =~ /:(\\w+)\\s+(\\w+)/; [$first, $second]\n"},{"code":"my $str = '{f.43.fq34.gf.34gfeg.ea.greags sdfasfd sd {} s{S}D F{SA}D{ FSA}D{ }},'; my ($return) = $str =~ m#^({.*?}).*#; $return\n","out":"{f.43.fq34.gf.34gfeg.ea.greags sdfasfd sd {}","err":""},{"out":"{}","err":"","code":"my $str = \"foo:12 bar:34 baz:45\"; $str =~ /foo:(?<foo>\\d+) bar:(?<bar>\\d+) baz:(?<baz>\\d+)/; \\%+\n"},{"err":"","out":"{baz => 45,foo => 12,bar => 34}","code":"my $str = \"foo:12 bar:34 baz:45\"; $str =~ /foo:(?<foo>\\d+) bar:(?<bar>\\d+) baz:(?<baz>\\d+)/; +{ %+ }\n"},{"out":"12","err":"","code":"my $str = \"foo:12 bar:34 baz:45\"; $str =~ /foo:(?<foo>\\d+) bar:(?<bar>\\d+) baz:(?<baz>\\d+)/; $+{foo}\n"},{"code":"my $str = \"foo:12 bar:34 baz:45\"; $str =~ /foo:(?<foo>\\d+) bar:(?<bar>\\d+) baz:(?<baz>\\d+)/; [ keys %+ ]\n","out":"[\"bar\",\"foo\",\"baz\"]","err":""},{"code":"my $str = \"foo:12 bar:34 baz:45\"; $str =~ /foo:(?<foo>\\d+) bar:(?<bar>\\d+) baz:(?<baz>\\d+)/; { %+{keys %+} }\n","err":"","out":"45"},{"code":"my $str = \"foo:12 bar:34 baz:45\"; $str =~ /foo:(?<foo>\\d+) bar:(?<bar>\\d+) baz:(?<baz>\\d+)/; +{ %+{keys %+} }\n","err":"","out":"{bar => 34,baz => 45,foo => 12}"},{"err":"","out":"{str => \"foo%-331bar%2\",params => [\"param1\",\"param0\"]}","code":"my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \\{ ([^{]+) \\}/push @params, $2; $1 . @params/gex; { str => $str, params => \\@params }\n"},{"code":"my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \\{ ([^{]+) \\}/push @params, $2; $1 . 's'/gex; printf $str, @params\n","err":"","out":"fooparam1                           barparam0"},{"err":"","out":"{params => [\"param1\",\"param0\"],str => \"foo%-33sbar%s\"}","code":"my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \\{ ([^{]+) \\}/push @params, $2; $1 . 's'/gex; { str => $str, params => \\@params }\n"},{"err":"","out":"[[\"foo\",\"bar\",\"baz\",\"foo\"]]","code":"my $str = \"foo,bar,baz foo\"; my $arr = [map {split(\",\", $_)} split(\" \", $str)]; [$arr]\n"},{"err":"","out":"[[]]","code":"my $str = \"foo,bar,baz foo\"; my $arr = [map {split(\",\", $_)} split($str)]; [$arr]\n"},{"code":"my $str = \"foo bar baz\"; open(my $fh, '<', \\$str); print <$fh>;\n","err":"","out":"foo bar baz"},{"code":"my $str = \"foobar\"; my $new = $str ^ \"   \"; $new\n","out":"FOObar","err":""},{"out":"STR is now 'foo bar'","err":"","code":"my $str='   foo bar   '; $str =~ s/^\\s+|\\s+$//gie; print \"STR is now '$str'\";\n"},{"err":"","out":"STR is now 'foo bar'","code":"my $str='   foo bar   '; $str =~ s/^\\s+|\\s+$//gi; print \"STR is now '$str'\";\n"},{"err":"","out":"STR is now '   foo bar   '","code":"my $str='   foo bar   '; $str =~ s/^\\s+|\\s+$//grie; print \"STR is now '$str'\";\n"},{"code":"my $str = \"foo\\nbar\\nbaz\\n\"; my @lines; while ($str =~ m/([^\\n]+\\n)/gc) { my $line = $1; push @lines, $line } \\@lines\n","err":"","out":"[\"foo\\n\",\"bar\\n\",\"baz\\n\"]"},{"code":"my $str = \"foo\\nbar\\nbaz\\n\"; [ split /(?<=\\n)/ $str ]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"/(?<=\\n)/ $str \"\n","err":""},{"out":"[\"foo\\n\",\"bar\\n\",\"baz\\n\"]","err":"","code":"my $str = \"foo\\nbar\\nbaz\\n\"; [ split /(?<=\\n)/, $str ]\n"},{"out":"ERROR: Group name must start with a non-digit word character in regex; marked by <-- HERE in m/(?<\\ <-- HERE n)/ at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $str = \"foo\\nbar\\nbaz\\n\"; [ split /(?<\\n)/ $str ]\n"},{"out":"ERROR: Group name must start with a non-digit word character in regex; marked by <-- HERE in m/(?<\n <-- HERE )/ at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $str = \"foo\\nbar\\nbaz\\n\"; [ split \"(?<\\n)\" $str ]\n"},{"code":"my $str = \"fooo.bar/blah,+bar\"; $str =~ s/,[+]/%2C+/g\n","out":"1","err":""},{"out":"fooo.bar/blah%2C+bar","err":"","code":"my $str = \"fooo.bar/blah,+bar\"; $str =~ s/,[+]/%2C+/g; $str\n"},{"out":"fooo.bar/blah%2C+bar","err":"","code":"my $str = \"fooo.bar/blah,+bar\"; $str =~ s/,\\+/%2C+/g; $str\n"},{"code":"my $str = \"foo\"; open( my ($fh), \">\", \\$str ); print $fh \"bar\"; [ $str ];\n","err":"","out":"[\"bar\"]"},{"err":"","out":"ERROR: Unknown open() mode '>+' at (eval 558) line 1, <STDIN> line 1.\n","code":"my $str = \"foo\"; open( my ($fh), \">+\", \\$str ); print $fh \"bar\"; [ $str ];\n"},{"err":"","out":"[\"bar\"]","code":"my $str = \"foo\"; open( my ($fh), \"+>\", \\$str ); print $fh \"bar\"; [ $str ];\n"},{"err":"","out":"GLOB(0x4ff5e40)","code":"my $str = \"foo\"; open( my ($fh), \">\", \\$str ); print $fh; [ $str ];\n"},{"out":"oo","err":"","code":"my $str = \"foo\"; substr $str, 0, 1, ''; $str\n"},{"out":"0.252","err":"","code":"my $str = '( G1 Z0.252 F7200.000 )'; my ($int) = $str =~ m#^.*?Z([0-9.]+)#; $int\n"},{"out":"0.252000","err":"","code":"my $str = '( G1 Z0.252 F7200.000 )'; my ($value) = $str =~ m#Z([0-9.]+)#; printf(\"%f\",$value);\n"},{"code":"my $str = '( G1 Z0.252 F7200.000 )'; my ($value) = $str =~ m#Z([0-9.]+)#; printf(\"%s\",$value);\n","out":"0.252","err":""},{"code":"my $str = \"Hello\"; $str = $str =~ tr/l/m/r =~ tr/m/l/r; # b100s is this what you mean?\n","out":"Hello","err":""},{"code":"my $string = 'danny larry monica'; my @names = split /\\s/, $string; print $names[0];\n","out":"danny","err":""},{"code":"my $string = \"it's great fun\"; $string =~ s/[aeiou]/$string/g; $string\n","out":"it's great funt's grit's great funit's great funt fit's great funn","err":""},{"code":"my @_STRING_; my $_INDEX_ = 0; while($_STRING_[$_INDEX_] ne '=') { $_INDEX_++ } print \"finished\" # basically there's no protection against this\n","out":"","err":""},{"code":"my $string = \"Number of Users: 3 Active: 3 Neighbor: 0 Parent: \"; my ($number_of_users) = $string =~ /Number of Users: (\\d+)/; $number_of_users\n","err":"","out":"3"},{"code":"my $string = \"parachutes are good\"; $string =~ /chute/; pos($string) = $-[0]; $string =~ /\\G.*//;\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":""},{"code":"my $str = join '', a..z; [map substr($str, 2 + $_ * 3, 1), 0 .. length($str)/3 ]\n","err":"","out":"[\"c\",\"f\",\"i\",\"l\",\"o\",\"r\",\"u\",\"x\",\"\"]"},{"out":"[\"a\",\"f\",\"k\",\"p\",\"u\",\"z\"]","err":"","code":"my $str = join '', a..z; [map substr($str, $_ * 5, 1), 0 .. length($str)/5 ]\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"; >\"\n\"use\" not allowed in expression at (eval 558) line 1, at end of line\n","code":"my $str = $LastZvalue; my ($int) = $str =~ m#^.*?Z([0-9.]+)#; $int; > and when I use the variable in < printf $fhS \"; Last Z value = %d\\n\", $int; > it is showing me '; Last Z value = 0'\n"},{"err":"","out":"d","code":"my $str = \"longword\"; substr $str, (int rand length $str), 1\n"},{"code":"my $str = \"mello\"; $str = $str =~ tr/l/m/r =~ tr/m/l/r; # this might illustrate it better?\n","out":"lello","err":""},{"code":"my $str = \"nickserv!nickserv@blah\"; return 1 if ($str =~ m#^nickserv!nickserv\\@#);\n","out":"","err":""},{"code":"my $str = \"nickserv!nickserv\\@blah\"; return 1 if ($str =~ m#^nickserv!nickserv\\@#);\n","err":"","out":"1"},{"out":"ERROR: Can't find string terminator \"}\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $str = q{blah blah\n"},{"out":"[\"Site oficial\"]","err":"","code":"my @str = ('Site oficial', 'Site nÃ£o oficial'); my @results = grep { /(?<!nÃ£o )oficial/i } @str; [@results]\n"},{"err":"","out":"[\"we had 'text' and 'here'\"]","code":"my $str = \"some text here\"; $str =~ / (\\S+) (\\S+)/  or die; my $tmpl = \"we had '[1]' and '[2]'\"; my @matches = map substr($str, $-[$_], $+[$_] - $-[$_]), 0..$#+; [ $tmpl =~ s/\\[(\\d+)\\]/$matches[$1]/ger ] # and it tends to obscure the important parts of the code\n"},{"code":"my $str = ''; $str .= chr int rand 1000000 for 1..10; $str\n","out":"ÃÂ³ÃÂ±ÃÂÃÂÃÂ°ÃÂÃÂÃÂÃÂ³ÃÂÃÂÃÂÃÂ³ÃÂ±ÃÂ¨ÃÂÃÂ±ÃÂ°ÃÂ¹ÃÂÃÂ³ÃÂ ÃÂÃÂ¶ÃÂ±ÃÂ±ÃÂÃÂ¬ÃÂ²ÃÂ´ÃÂÃÂ©ÃÂ±ÃÂ¼ÃÂÃÂÃÂ°ÃÂ©ÃÂÃÂ","err":""},{"code":"my $str = ''; $str .= chr rand 1000000 for 1..10; $str\n","out":"ÃÂ²ÃÂ¾ÃÂ¿ÃÂÃÂ±ÃÂ´ÃÂ®ÃÂÃÂ±ÃÂªÃÂ¾ÃÂÃÂ²ÃÂÃÂ¾ÃÂ¡ÃÂ±ÃÂ³ÃÂ¬ÃÂ¶ÃÂ¦ÃÂÃÂ¡ÃÂ³ÃÂÃÂÃÂ¼ÃÂ°ÃÂ¨ÃÂ±ÃÂ¦ÃÂ²ÃÂÃÂ°ÃÂ¿ÃÂ±ÃÂ¸ÃÂÃÂ","err":""},{"code":"my $str = \"--\"; $str =~ tr/-/-1/; $str\n","err":"","out":"--"},{"out":"[\"take\",\" cat\"]","err":"","code":"my $str = \"take cat\"; open my $fh, '<', \\$str; $/ = \\4; [ readline($fh) ]\n"},{"code":"my $str = 'te'; return substr($str,0,3);\n","err":"","out":"te"},{"code":"my $str = \"test\"; my $len = length $str; my $mask = \"\\0\" x $len; my @rslt; for(1..2**$len-1) { my $idx = 0; do { substr($mask, $idx, 1) ^= \" \" } until substr($mask, $idx++, 1) eq \" \"; push @rslt, $str ^ $mask } \\@rslt\n","err":"","out":"[\"Test\",\"tEst\",\"TEst\",\"teSt\",\"TeSt\",\"tESt\",\"TESt\",\"tesT\",\"TesT\",\"tEsT\",\"TEsT\",\"teST\",\"TeST\",\"tEST\",\"TEST\"]"},{"code":"my $str = \"test test, test\"; substr($str, (rindex $str, ','), 1, ''); $str;\n","out":"test test test","err":""},{"code":"my $struct = { things => [1, 2, 3] };  push @{ $struct->{things} }, \"more\", \"things\";  $struct->{things}\n","err":"","out":"[1,2,3,\"more\",\"things\"]"},{"code":"my $structure = {}; push @{$structure->{test}}, \"hello\";  $structure\n","err":"","out":"{test => [\"hello\"]}"},{"err":"","out":"{test => [\"hello\"]}","code":"my $structure; push @{$structure->{test}}, \"hello\";  $structure\n"},{"code":"my $struct = { x => { y => { z => 1, a => 2, b => 3 }, c => 5 } }; my $code; $code = sub { my $ptr = shift; my $count = 0; for(values %$ptr) { if(ref($_) && ref($_) eq 'HASH') { $count += $code->($_) } else { ++$count } } return $count }; $code->($struct)\n","out":"4","err":""},{"code":"my $str = '[word1] word2 [word3] word4'; 1 while $str =~ s/(\\[.*?\\])/\\N{U+FFFC}/; [ $str =~ /(\\w+)/g ];\n","out":"[\"word2\",\"word4\"]","err":""},{"err":"","out":"words only like this phrase","code":"my $str = \"words, only like this phrase!\"; $str =~ tr/ a-z//cd; $str; # doesn't need regex, if you mean remove non-alpha characters\n"},{"err":"","out":"402","code":"my $str = \"\\x01\\x92\"; my $v = 0; $v = ($v << 8) | $_ for map ord, split //, $str; $v\n"},{"err":"","out":"402","code":"my $str = \"\\x01\\x92\"; my $v = 0; $v = $v << 8 | $_ for unpack 'C*', $str; $v\n"},{"code":"my $str = \"\\x01\\x92\"; unpack 'N', substr(\"\\0\" x 4 . $str, -4)\n","err":"","out":"402"},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $str = \"\\xff\\xff\\xff\\xff; my $v = 0; $v = $v << 8 | $_ for unpack 'C*', $str; $v\n"},{"code":"my $str = \"\\xff\\xff\\xff\\xff\"; my $v = 0; $v = $v << 8 | $_ for unpack 'C*', $str; $v\n","out":"4294967295","err":""},{"err":"","out":"4294967295","code":"my $str = \"\\xff\\xff\\xff\\xff\"; unpack 'N', substr(\"\\0\" x 4 . $str, -4)\n"},{"err":"","out":"[3,4,1,2]","code":"my @stuff = ( 1..4 ); my ( $x, $y, @output ) = @stuff; [ @output, $x, $y ];\n"},{"code":"my $stuff = {a => 1, b => 2}; [@$stuff{'a','b'}]\n","out":"[1,2]","err":""},{"err":"","out":"[1,2]","code":"my $stuff = {a => 1, b => 2}; [$stuff->@{'a','b'}] # might work on new perls?\n"},{"out":"{abc => 1}","err":"","code":"my %stuff = (abc => 1); { local $stuff{abc} = 2; delete $stuff{abc} } \\%stuff\n"},{"err":"","out":"[\"foorlp\"]","code":"my ($stuff) = grep { /foo/ } qw/acme beta foorlp/; [ $stuff ]\n"},{"err":"","out":"42ERROR: Undefined subroutine &main::foo called at (eval 558) line 1, <STDIN> line 1.\n","code":"{ my sub foo { 42 } print foo(); } foo()\n"},{"code":"{ my $_; sub foo { say } } foo for 123\n","err":"","out":"\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","err":"","code":"my @subs; for (1 .. 5) { { push @subs, sub { $_ + 1 } } }; [ map { $_->\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"->>\"\n","code":"my @subs; for (1 .. 5) { { push @subs, sub { $_ + 1 } } }; [ map { $_->>() } @subs ]\n"},{"err":"","out":"[79489745,79489745,79489745,79489745,79489745]","code":"my @subs; for (1 .. 5) { push @subs, sub { $_ + 1 } }; [ map { $_->() } @subs ]\n"},{"out":"[80697913,80697913,80697913,80697913,80697913]","err":"","code":"my @subs; for (1 .. 5) { { push @subs, sub { $_ + 1 } } }; [ map { $_->() } @subs ]; # stupid fingers.\n"},{"code":"my @subs; for my $_ (1 .. 5) { { push @subs, sub { $_ + 1 } } }; [ map { $_->() } @subs ]; # stupid fingers.\n","err":"","out":"[2,3,4,5,6]"},{"code":"my @subs; for my $n (1 .. 5) { push @subs, sub { $n + 1 } }; [ map { $_->() } @subs ]\n","out":"[2,3,4,5,6]","err":""},{"code":"my $subs = [ sub { print 'foo'; }, sub { print 'bar'; } ]; &{$subs->[0]};\n","err":"","out":"foo"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"} sub foo \"\n","err":"","code":"my $sub = sub { say shift // 'no args' } sub foo { &$sub } foo('one arg')\n"},{"err":"","out":"one arg\n","code":"my $sub = sub { say shift // 'no args' }; sub foo { &$sub } foo('one arg')\n"},{"err":"","out":"ERROR: Can't declare single ref constructor in \"my\" at (eval 558) line 1, at EOF\n","code":"my (sub { $x })\n"},{"code":"my @super = qw/foo bar baz aaa bbb/; my @unordered = qw/aaa foo baz/; my %order; $order{$super[$_]} = $_ for 0 .. $#super; [ sort { $order{$a} <=> $order{$b} } @unordered ]\n","out":"[\"foo\",\"baz\",\"aaa\"]","err":""},{"code":"my @t=(3,5,7); print shift(@t)*100\n","err":"","out":"300"},{"code":"my $tdata = { }; push @{ $data }, $tdata;\n","out":"1","err":""},{"err":"","out":"ERROR: delete argument is not a HASH or ARRAY element or slice at (eval 558) line 1, <STDIN> line 1.\n","code":"my $test = 1; my $something = delete $test;\n"},{"out":"1","err":"","code":"my $test = `echo \"here\" >> /tmp/tactical`; print $test;\n"},{"err":"","out":"SCALAR","code":"my $test = ('hello'); ref(\\$test)\n"},{"code":"my @test = qw(dword 42 imixed42); my $pat = join '|', qr/(.).{3,}\\1/, qr/(.).{0,1}\\1/; [ grep { m/(?|$pat)/ } @test ]\n","err":"","out":"[\"dword\",\"imixed42\"]"},{"err":"","out":"[\"dword\",42,\"imixed42\"]","code":"my @test = qw(dword 42 imixed42); my $pat = join '|', qr/(.).{3,}\\1/, qr/(.).{0,1}\\1/; [ grep { m/$pat/ } @test ]\n"},{"code":"my @test = qw(test ing foobar thab); my $pat = join '|', map { quotemeta } qw(e a t); [ grep { m/$pat/ } @test ]\n","err":"","out":"[\"test\",\"foobar\",\"thab\"]"},{"code":"my @test = qw(word 42 mixed42); my $pat = join '|', qr/^[a-zA-Z]+$/, qr/^[0-9]+$/; [ grep { m/$pat/ } @test ]\n","out":"[\"word\",42]","err":""},{"out":"[undef]","err":"","code":"my $test = sub { \"don't do this\" }; [ $test { 'main' } ]\n"},{"err":"","out":"[\"\\$test is not a string\"]","code":"my $test = sub { '$test is not a string' }; my $class = 'main'; [ $class->$test() ]\n"},{"code":" my $text = 'M\\xf6glich'\n","out":"M\\xf6glich","err":""},{"code":" my $text = \"M\\xf6glich\"\n","err":"","out":"MÃÂ¶glich"},{"code":"my $text = \"onetwothree\"; my ($foo) = $text =~ s/(tw.)//g; $foo\n","out":"1","err":""},{"out":"text","err":"","code":"my $text = 'some text to match'; my ($captured) = $text =~ /\\b(t[^ ]+)/; $captured\n"},{"out":" <== There. I broke the cycle so now all is fine ","err":"","code":"my $thing = {};  $thing->{cycle} = $thing;  q( <== Here I have created a cycle. IT IS NOT YET A LEAK BECAUSE $thing STILL HOLDS IT );   undef $thing->{cycle};   q( <== There. I broke the cycle so now all is fine )\n"},{"code":"my $title = (sub (_) { defined ? $_ : '' })->($big_long_var_name)\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(_\"\n","err":""},{"code":"my $title = (sub :prototype(_) { defined ? $_ : '' })->($big_long_var_name)\n","err":"","out":""},{"err":"","out":"ERROR: Can't declare array dereference in \"my\" at (eval 558) line 1, at EOF\n","code":"my @$tmp;\n"},{"code":"my @tmp = (1..3); my @tmp; \\@tmp\n","out":"[]","err":""},{"out":"10","err":"","code":"( my $tmp = \"Hello, world\" ) =~ tr/A-Za-z/N-ZA-Mn-za-m/\n"},{"code":"( my $tmp = \"Hello, world\" ) =~ tr/A-Za-z/N-ZA-Mn-za-m/; $tmp\n","err":"","out":"Uryyb, jbeyq"},{"out":"[\"gi|300707803|ref|XP_002996096.1|hypothetical protein NCER_100860 \",\"Nosema ceranae BRL01] >gi|239605364|gb|EEQ82425.1| hypothetical protein NCER_100860 \"]","err":"","code":"my @tmp; $tmp[3] = \"gi|300707803|ref|XP_002996096.1|hypothetical protein NCER_100860 [Nosema ceranae BRL01] >gi|239605364|gb|EEQ82425.1| hypothetical protein NCER_100860 [Nosema ceranae BRL01]\"; my($ia,$ib) = split(/\\[/,$tmp[3]); [ $ia, $ib]\n"},{"code":"my $two = \"two\"; [ \"two\\n\" =~ /^\\Q$two\\E$/, \"two\\n\" =~ /\\A\\Q$two\\E\\z/, \"two\\n\" eq $two ]\n","err":"","out":"[1,\"\"]"},{"out":"[1,\"\"]","err":"","code":"my $two = \"two\"; [ \"two\\n\" =~ /^\\Q$two\\E$/, \"two\\n\" eq $two ]\n"},{"code":"my $txt = \"T\\x0A\\x0B\"; s{([^[:print:]])}{sprintf '\\\\%02x', ord $1}ge for $txt; [ $txt ] # or this. or Data::Dumper\n","err":"","out":"[\"T\\\\0a\\\\0b\"]"},{"code":"[ my $tz ]\n","err":"","out":"[undef]"},{"out":"2","err":"","code":"my (undef, $b) = (1,2)\n"},{"out":" ","err":"","code":"my $undef = \" \"; print $undef\n"},{"code":"my $undef = \"\"; print $undef\n","out":"1","err":""},{"code":"my (undef, undef);\n","err":"","out":""},{"code":"my $undef = undef; print $undef\n","err":"","out":"1"},{"out":"2","err":"","code":"my (undef, $y) = (\"a\", \"b\");\n"},{"code":"my @under = ( \"_\" );   [ ( @under )x 5 ]\n","err":"","out":"[\"_\",\"_\",\"_\",\"_\",\"_\"]"},{"code":"my @under = ( \"_\" );   [ @under x 5 ]\n","out":"[11111]","err":""},{"code":"my $url = 'http://something'; my @cmd = (qw(youtube-dl -f 17 ...), $url); \\@cmd # I'd write it more like this\n","err":"","out":"[\"youtube-dl\",\"-f\",17,\"...\",\"http://something\"]"},{"err":"","out":"[undef]","code":"my $USA; my $x = 'USA'; ${$x} = 42; [ $USA ]\n"},{"code":"my $username_ = 'xyz'; \"$username_%\" # ${...} might look better\n","err":"","out":"xyz%"},{"err":"","out":"pwned\n","code":"my ( $user, $nick ) = ( 'root', 'ro.+' ); if($user =~ /^$nick$/){ say 'pwned' } else { say 'you are not root' }\n"},{"code":"my $users = 1;say \"damn them\" if $users;\n","out":"damn them\n","err":""},{"err":"","out":"[\"0.2\",\"0.25\"]","code":"my $v = 0.223; die \"out of range\" if $v > 1; my $w = 0.05; my $start = $w * int($v / 0.05); [ $start, $start + $w ]\n"},{"code":"my $v = '0.9'; $v .= '9' until $v . '9' == $v; length $v\n","out":"18","err":""},{"out":"18","err":"","code":"my $v = 0.9; $v .= '9' until $v == $v.'9'; length $v;\n"},{"err":"","out":"[5]","code":"my $v = 0; $v ||= 5; [$v]\n"},{"out":"[[255,11111111]]","err":"","code":"my $v = -1; my @x; for( my $i = 0, my $r = 0; $r = ($v/256**$i)%256; $i++ ) { push @x, pack q{C}, $r; } [ map { [ unpack( q{C} ), unpack( q{B8} ) ]; } @x ]\n"},{"out":"[1]","err":"","code":"my $v = 1; $v ||= 5; [$v]\n"},{"out":"[\"00100011\",11000010,\"00000011\"]","err":"","code":"my $v = 246307; my @x; for( my $i = 0, my $r = 0; $r = ($v/256**$i)%256; $i++ ) { push @x, pack q{C}, $r; } [ map { unpack q{B8}; } @x ]\n"},{"code":"my $v = 261; my @x; for( my $i = 0, my $r = 0; $r = ($v/256**$i)%256; $i++ ) { push @x, pack q{C}, $r; } [ map { unpack q{B8}; } @x ] ## Use 'reverse @x' for opposite endian, big endian in this case.\n","out":"[\"00000101\",\"00000001\"]","err":""},{"out":"[\"a\",\"a\",\"a\"]","err":"","code":"my $val = 'a'; [($val++)x3]\n"},{"code":"my @vals = (1,2,3); sub do_stuff { undef $_ } [ map { do_stuff(); $_ } (@vals) ]\n","err":"","out":"[undef,undef,undef]"},{"code":"my @values = (1, 0, 1, 1);  my $n = 0; ($n >>= 2) |= $_ for reverse @values; [ $n, sprintf '%b', $n ];\n","out":"[1,1]","err":""},{"err":"","out":"[81,1010001]","code":"my @values = (1, 0, 1, 1);  my $n = 0; ($n <<= 2) |= $_ for reverse @values; [ $n, sprintf '%b', $n ]; # d'oh\n"},{"err":"","out":"127","code":"my @values = ((1)x 7, 0);  my $n = 0; ($n *= 2) += $_ for reverse @values; $n;\n"},{"out":"","err":"","code":"my @values = ((1)x 7, 0);  my $n = 0; ($n *= 2) += $_ for @values;\n"},{"out":"254","err":"","code":"my @values = ((1)x 7, 0);  my $n = 0; ($n *= 2) += $_ for @values; $n;\n"},{"out":"16843009","err":"","code":"my @values = ((1)x 7, 0); unpack 'I<', pack(('b' x @values), @values);\n"},{"err":"","out":"16843009","code":"my @values = ((1)x 7, 0); unpack 'I>', pack(('b' x @values), @values);\n"},{"err":"","out":"2155905152","code":"my @values = ((1)x 7, 0); unpack 'I<', pack(('B' x @values), @values);\n"},{"err":"","out":"2155905152","code":"my @values = ((1)x 7, 0); unpack 'I>', pack(('B' x @values), @values);\n"},{"code":"my @values = ((1)x 7, 0); unpack 'n', pack(('b' x @values), @values);\n","err":"","out":"257"},{"err":"","out":"32896","code":"my @values = ((1)x 7, 0); unpack 'n', pack(('B' x @values), @values);\n"},{"err":"","out":"ERROR: '<' allowed only after types sSiIlLqQjJfFdDpP( in unpack at (eval 558) line 1, <STDIN> line 1.\n","code":"my @values = ((1)x 7, 0); unpack 'N<', pack(('b' x @values), @values);\n"},{"code":"my @values = ((1)x 7, 0); unpack 'N', pack(('b' x @values), @values);\n","out":"16843009","err":""},{"code":"my @values = ((1)x 7, 0); unpack 'N', pack(('B' x @values), @values);\n","err":"","out":"2155905152"},{"out":"","err":"","code":"my $value = undef;  undef == 2\n"},{"err":"","out":"1","code":"my $var = 0 || 1;\n"},{"err":"","out":"[1]","code":"my $var = 0; [ defined $var ]\n"},{"code":"my $var = (1-1) || (2-2);\n","err":"","out":"0"},{"code":"my $var1 = 3; my $var2 = 7888; ($var1, $var2) = ($var2, $var1); print \"var1: $var1. var2: $var2\"; #hudo\n","out":"var1: 7888. var2: 3","err":""},{"code":"my $var = \"1k10k1l11dld1\";  $var =~ /(\\d+)/; print $var;\n","out":"1k10k1l11dld1","err":""},{"code":"my $var = \"1k10k1l11dld1\";  $var = tr/(d+)//d; print $var;\n","err":"","out":"01"},{"err":"","out":"you = me","code":"my ($var1, $var2) = split(/\\=/, \"you=me\"); print $var1 . \" = \" . $var2\n"},{"code":"my $var = 2 || 3;\n","out":"2","err":""},{"out":"2","err":"","code":"my $var = 42; my $ref = \\$var; Internals::SvREFCNT $var\n"},{"code":"my $var = 42; sub xxx { my ($stuff) = @_; return $stuff + $var } xxx(5)\n","err":"","out":"47"},{"out":"[5]","err":"","code":"my(@var) = 5; [ @var ]\n"},{"code":"my@var = 5; [ @var ]\n","out":"[5]","err":""},{"code":"my $var = \"6d73616e64626f78\"; $var =~ s/([0-9a-f]{2})/chr hex $1/eg\n","err":"","out":"8"},{"code":"my $var = \"6d73616e64626f78\"; $var =~ s/([0-9a-f]{2})/chr hex $1/eg; $var\n","err":"","out":"msandbox"},{"out":"(9)","err":"","code":"my $var = (7,8,9); print \"($var)\";\n"},{"err":"","out":"no match","code":"my $var='/.a./.a./.a./.a./'; $var =~ /(\\.\\.)/ ? print \"match two dots in a row\" : \"no match\";\n"},{"out":"catiable","err":"","code":"my $var = \"cat\"; \"${var}iable\"\n"},{"err":"","out":"Three","code":"my $var = ( 'One', 'Two', 'Three');\n"},{"out":"Three","err":"","code":"my $var = ( 'One', 'Two', 'Three'); $var\n"},{"code":"my $var='\\/print \"OK\" if\n","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"my $var = qw/ One Two Three /; $var\n","err":"","out":"Three"},{"code":"my $var = \"something\"; \"$var\" # this?\n","out":"something","err":""},{"code":"my $var = \"this\"; my $ref = \\$var; my $copy = $$ref; $var = \"that\"; $copy\n","err":"","out":"this"},{"out":"that","err":"","code":"my $var = \"this\"; my $ref = \\$var; my $copy = $ref; $var = \"that\"; print($$copy);\n"},{"code":"my $var='/../../../../'; $var =~ /(\\.\\.)/ ? print \"match two dots in a row\" : \"no match\";\n","out":"match two dots in a row","err":""},{"err":"","out":"[\"1.41_02\",\"1.4102\"]","code":"my $v = q{1.41_02}; [ $v, eval $v ];\n"},{"err":"Out of memory!\n","out":"","code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { 1 } @$v[ $i, $i + 1 ]; print qq{($a,$n)}; } ### This results in an infinate loop some how...\n"},{"code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { 1 } @$v; print qq{($a,$n)}; } ### Oddly though, changing @$v[ $i, $i + 1 ]; to just @$v makes the loop finite again...\n","out":"(1,1)(1,1)(1,1)","err":""},{"code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } do { @$v[ $i, $i + 1 ] }; print qq{($a,$n)}; } ### Another way, a little cleaner and without an explicit array being declared.\n","err":"","out":"(A,B)(B,C)(C,)"},{"err":"","out":"(A,B)(B,C)(C,)","code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } (my @x) = @$v[ $i, $i + 1 ]; print qq{($a,$n)}; } ### Slightly hackish but works.\n"},{"out":"","err":"Out of memory!\n","code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } splice @$v, $i, -2, 2; print qq{($a,$n)}; }\n"},{"code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } () = @$v[ $i, $i + 1 ]; print qq{($a,$n)}; }\n","out":"(,)(,)(,)","err":""},{"out":"","err":"Out of memory!\n","code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } @$v[ $i, $i + 1 ]; print qq{($a,$n)}; } ### This results in an infinate loop some how...\n"},{"code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } @$v[ $i, $i < $#$v ? $i + 1 : () ]; print qq{($a,$n)}; } ### This solution is rather ugly as sin, but it works. Is there another way?\n","err":"","out":"(A,B)(B,C)(C,)"},{"code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } $v->[$i], $v->[$i+1]; print qq{($a,$n)}; }\n","out":"","err":"Out of memory!\n"},{"code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } $v[$i], $v[$i+1]; print qq{($a,$n)}; }\n","out":"(,)(,)(,)","err":""},{"code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } $v->[ $i ], $v->[ $i + 1 ]; print qq{($a,$n)}; } ### Why does this still loop infinately when $v->[ $i ], $v->[ $i + 1 ]; on two seaprate lines does not?\n","err":"Out of memory!\n","out":""},{"err":"Out of memory!\n","out":"","code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ } @$v[ $i, $i + 1 ]; print qq{($a,$n)}; } ### This results in an infinate loop some how...\n"},{"err":"","out":"(A,B)(B,C)(C,)","code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = @$v[ $i, $i + 1 ]; print qq{($a,$n)}; }\n"},{"out":"(A,B)(B,C)(C,)","err":"","code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = ($v->[$i], $v->[$i+1]); print qq{($a,$n)}; }\n"},{"err":"","out":"(A,B)(B,C)(C,)","code":"my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my $a = $v->[ $i ] // q{}; my $n = $v->[ $i + 1 ] // q{}; print qq{($a,$n)}; } ### This works as expected.\n"},{"out":"[0,undef]","err":"","code":"my %v = %$^V; [ keys %v, values %v ]\n"},{"out":"[\"asdf at (eval 558) line 1, <STDIN> line 1.\\n\"]","err":"","code":"my $warning; $SIG{__WARN__} = sub { $warning = shift }; warn 'asdf'; [$warning]\n"},{"code":"my @warnings; sub foo { local $SIG{__WARN__} = sub { push @warnings, @_ }; goto &bar } sub bar { warn \"blah\" } foo(); \\@warnings\n","out":"[]","err":"blah at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"yes","code":"my $wat = \"\\\\Q\"; \"Q\" =~ /$wat/ ? \"yes\" : \"no\"\n"},{"out":"ERROR: delete argument is not a HASH or ARRAY element or slice at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $what = \"cats\"; [ delete $cats ]\n"},{"err":"","out":"ERROR: delete argument is not a HASH or ARRAY element or slice at (eval 558) line 1, <STDIN> line 1.\n","code":"my $what = \"cats\"; [ delete $what ]\n"},{"out":"[\"state\",\"alive\"]","err":"","code":"my @whatever = ( my %being = qw(state alive) ); \\@whatever\n"},{"out":"[\"the\",\"b\",\"brown\",\"dog\",\"the\",\"b\",\"brown\"]","err":"","code":"my @whitelist = qw(the b brown dog); [ map { my $word = $_; grep { index($word, $_) >= 0 } @whitelist } \"the brown dog jumps over the brown fox\" =~ /\\w+/g ] # apart from the illegibility, of course\n"},{"out":"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000","err":"","code":"my $_ = \"wibble\"; s/(.)/sprintf('\\\\u%04x', \"$1\")/ger\n"},{"err":"","out":"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000","code":"my $_ = \"wibble\"; s/(.)/sprintf('\\\\u%04x', $1)/ger\n"},{"code":"my $_ = \"wibble\"; s/(.)/sprintf('\\\\u%04x', ord \"$1\")/ger\n","err":"","out":"\\u0077\\u0069\\u0062\\u0062\\u006c\\u0065"},{"code":"my @w = map { $_ =~ /\\s+/ ? $_ =~ s/\\s|\\s+/-/g : trim($_) } split ',', ('hello, world, foo bar baz');\n","err":"","out":"3"},{"code":"my @words = split /\\W/, \"a.b!c?d e\"; for my $i (0..$#words - 1) { push @word_pairs [ $words[$i], $words[$i+1 ]; }; \\@word_pairs\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n"},{"code":"my @words = split /\\W/, \"a.b!c?d e\"; for my $i (0..$#words - 1) { push @word_pairs, [ $words[$i], $words[$i+1] ]; }; \\@word_pairs\n","err":"","out":"[[\"a\",\"b\"],[\"b\",\"c\"],[\"c\",\"d\"],[\"d\",\"e\"]]"},{"err":"","out":"{wrong => [[]],right => []}","code":"my @wrong = [] ; my @right = (); { wrong => \\@wrong, right => \\@right }\n"},{"out":"[\\undef]","err":"","code":"[\\my $x]\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":"","code":"my @x = ;\n"},{"out":"2","err":"","code":"my @x = ( [ 0, 1, 2 ] ); $#{$x[0]}\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"$x[\"\n","code":"my @x = ( [ 0, 1, 2 ] ); $#$x[0]\n"},{"out":"-1","err":"","code":"my $x = [ [ 0, 1, 2 ] ]; $#{$x[0]}\n"},{"code":"my $x = 0.21875; my $out = ''; while(int($x) != $x) { $x *= 2; $out .= ($x & 1) ? 1 : 0; }; $out\n","err":"","out":"00111"},{"code":"my $x = 0.3; my $out = ''; while(int($x) != $x) { $x *= 2; $out .= ($x & 1) ? 1 : 0; }; $out\n","out":"010011001100110011001100110011001100110011001100110011","err":""},{"code":"my $x = 0.40625; my $out = ''; while(int($x) != $x) { $x *= 2; $out .= ($x & 1) ? 1 : 0; }; $out\n","out":"01101","err":""},{"err":"","out":"1","code":"my $x = 0.5; my $out = ''; while(int($x) != $x) { $x *= 2; $out .= ($x & 1) ? 1 : 0; }; $out\n"},{"err":"","out":"9","code":"my $x = [0..9];  $#$x # is this the right way to get the last index of @$x?\n"},{"code":"my $x = 0; eval 'print ++$x;'x10  # \"power of looping\"\n","out":"12345678910","err":""},{"out":"[1,0,1,0,1]","err":"","code":"my $x = 0; [ map { $x = int !!--$x } 1..5 ]\n"},{"code":"my $x = 0; [ map { $x = int !!++$x } 1..5 ]\n","out":"[1,1,1,1,1]","err":""},{"err":"","out":"01","code":"my $x = 0; print \"$x\" if $x == 0;\n"},{"out":"01","err":"","code":"my $x = 0; print $x if $x == 0;\n"},{"out":"0,  return value:","err":"","code":"my $x = 0; print \"$x,  return value:\" if $x == 0;\n"},{"code":"my $x = 0; $x += $_ + ($_*$_ < 2119) * $_ * $_ for 1 .. 2118; $x\n","err":"","out":"2277532"},{"err":"","out":"ERROR: Use of := for an empty attribute list is not allowed at (eval 558) line 1, <STDIN> line 1.\n","code":"my $x := 1;\n"},{"out":"0.00999999999999979","err":"","code":"my $x = 10.01; $x -= 10; print $x\n"},{"code":"my $x = 10,25;\n","err":"","out":"25"},{"code":"my $x = 10,25; [$x]\n","err":"","out":"[10]"},{"err":"","out":"10 is less-than 20","code":"my $x = 10; my $y = 20; sprintf \"%d is %s %d\", $x, [qw( equal-to greater-than less-than )]->[ $x <=> $y ], $y\n"},{"code":"my %x = 1 .. 100; eval scalar %x\n","out":"0.484375","err":""},{"out":"30","err":"","code":"my %x = 1..100; int %x\n"},{"out":"50","err":"","code":"my %x = 1..100; scalar keys %x\n"},{"code":"my %x = 1..100; scalar %x\n","out":"33/64","err":""},{"code":"my %x = 1..10; $_ += 100 for keys %x; \\%x\n","out":"{7 => 8,9 => 10,3 => 4,5 => 6,1 => 2}","err":""},{"err":"","out":"{3 => 104,1 => 102,7 => 108,5 => 106,9 => 110}","code":"my %x = 1..10; $_ += 100 for values %x; \\%x\n"},{"out":"[]","err":"","code":"my @x = 1..10; [ @x[0 .. -1] ]\n"},{"code":"my @x = 1..10; [ $x[0 .. -1] ]\n","out":"[1]","err":""},{"out":"yes","err":"","code":"my $x = \"123\"; 0+$x; \"123 \" ~~ $x ? 'yes' : 'no'\n"},{"err":"","out":"yes","code":"my $x = \"123\"; 0+$x; print \"123 \" ~~ $x ? \"yes\" : \"no\"\n"},{"code":"my $x = \"123\"; \"123 \" ~~ $x ? 'yes' : 'no'\n","err":"","out":"no"},{"code":"my $x = '1.2345' + '10000000000'; $x =~ /([0-9]{3}\\.[0-9]+)$/; print $1;\n","out":"001.2345","err":""},{"out":"ARRAY(0x65f5510)","err":"","code":"my @x = [1,2,3]; for my $v (@x) { print \"$v\" } # are you doing something like this\n"},{"code":"my $x = \"123\"; print \"123 \" ~~ $x ? \"yes\" : \"no\"\n","err":"","out":"no"},{"err":"","out":"closure","code":"{ my $x =123; sub cloure { $x } } closure\n"},{"code":"{ my $x =123; sub clousre { $x } } closure\n","out":"closure","err":""},{"err":"","out":"[[1],[3]]","code":"my $x = [[1],[2],[3]]; [ @$x[0, 2] ]\n"},{"code":"my $x = [[1],[2],[3]]; @x->[0,2]\n","out":"ERROR: Can't use an array as a reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"[[1,2,3],\\$VAR1->[0][0],\\$VAR1->[0][1],\\$VAR1->[0][2]]","err":"","code":"my @x = (1,2,3); [\\@x, \\(@x)]\n"},{"err":"","out":"","code":"my $x = [[1],[2]]; my $y = $x->[1]; 42 if \\$x->[1] == $y\n"},{"out":"","err":"","code":"my $x = [[1],[2]]; my $y = $x->[1]; 42 if \\$x->[1] == \\$y\n"},{"code":"my $x = [[1],[2]]; my $y = \\$x->[1]; [grep { $y == \\$_ } @$x];\n","err":"","out":"[[2]]"},{"err":"","out":"1","code":"my $x = [ 1, 2 ]; $x->[0] # or these?\n"},{"err":"","out":"5","code":"my @x = (1..5); @x[0..2] = (1..3); scalar @x;\n"},{"code":"my @x = (1..5); @x = (1..3); scalar @x;\n","out":"3","err":""},{"code":"my %x = (1, 'a'); my @x = ('c', 'd'); [ %x{1} ]\n","err":"","out":"[1,\"a\"]"},{"code":"my $x = 1e-100; print $x\n","err":"","out":"1e-100"},{"code":"my @x1 = 'FOO'; my @array = (\"a\", \"b\"); [q(@array) .@x1, q@array .@x1]\n","out":"[\"\\@array1\",\"array .\"]","err":""},{"err":"","out":"1255","code":"my $x = 1; print $x++, $x++, ++$x, ++$x;\n"},{"code":"my $x = 1; print $x++, $x++, \"\" . ++$x, \"\" . ++$x, $x++, \"\" . ++$x;\n","err":"","out":"124557"},{"err":"","out":"127757","code":"my $x = 1; print $x++, $x++, ++$x, ++$x, $x++, ++$x;\n"},{"err":"","out":"[undef]","code":"my $x = 1; sub foo :lvalue { $x }  undef foo; [$x]\n"},{"out":"","err":"","code":"my $x = 1; sub foo :lvalue { $x }  undef foo; $x\n"},{"code":"my $x = 1; $x+2\n","err":"","out":"3"},{"err":"","out":"ERROR: Can't modify preincrement (++) in substitution (s///) at (eval 558) line 1, at EOF\n","code":"my $x = 1; ( ++$x ) =~ s/2/TWO/;  $x\n"},{"code":"my $x = 1; ${\\$x++} =~ s/2/TWO/; $x\n","out":"2","err":""},{"err":"","out":"TWO","code":"my $x = 1; ${\\++$x} =~ s/2/TWO/; $x\n"},{"code":"my $x = 2118 * 2119 / 2; $x += $_ * $_ for 1 .. sqrt 2118; $x\n","out":"2277532","err":""},{"code":"my $x = (3,2,1); $x\n","err":"","out":"1"},{"code":"my $x = '3 + 4 eq \"7\"; my @n = $x =~ /(\\d+)g/; [ @n ]\n","err":"","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"[3,4,7]","code":"my $x = '3 + 4 eq \"7\"'; my @n = $x =~ /(\\d+)/g; [ @n ]\n"},{"err":"","out":"[]","code":"my $x = '3 + 4 eq \"7\"'; my @n = $x =~ /(\\d+)g/; [ @n ]\n"},{"code":"my $x = '3 + 4 eq \"7\"'; my @n = $x =~ /\\d+/g; [ @n ]\n","out":"[3,4,7]","err":""},{"out":"1","err":"","code":"my $x = 3; $x /= 3; $x\n"},{"err":"","out":"[42,42,42,42]","code":"my $x = 42; [  map { state $y = $x++; $y } 0..3 ];\n"},{"code":"my $x = 42; sub { $x++ }->(); $x\n","out":"43","err":""},{"out":"42","err":"","code":"my $x = \\42; $x->$*\n"},{"err":"","out":"[]","code":"my $x = ~42; [ $x =~ 42 ]\n"},{"err":"","out":"['18446744073709551573']","code":"my $x = ~42; [ $x = ~42 ]\n"},{"err":"","out":"x = ","code":"{ my $x = 42; } \"x = $x\"\n"},{"out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $x = 43; Internals::SvREADONLY $x, 1; $x = 23; $x\n"},{"code":"my $x = ( 4, 5, 6 ); $x; ### Gives last value from comma list (comma operator.)\n","err":"","out":"6"},{"out":"4-9","err":"","code":"my $x = \"4-9\"; s/(\\d+)-(\\d+)/join \",\", $1..$2/e; $x\n"},{"out":"[55]","err":"","code":"my $x = 55; sub foo { unless ($x) { return 'foo' } } [foo()]\n"},{"err":"","out":"Hello3\n","code":"my @x = (5,6,7); print \"Hello\", scalar(@x), \"\\n\";\n"},{"code":"my @x = (5,6,7); print \"Hello\", @x, \"\\n\";\n","err":"","out":"Hello567\n"},{"err":"","out":"[5,6,7]","code":"my @x = (5,6,7); \\@x\n"},{"code":"my @x = [5,6,7]; \\@x\n","out":"[[5,6,7]]","err":""},{"code":"my @x = 7 .. 9; please, print @x;\n","out":"789","err":""},{"err":"","out":"789","code":"my @x = 7..9; print @x;\n"},{"err":"","out":"[\"true\",\"false\"]","code":"my %x = (a => 0); [ (exists $x{a} ? 'true' : 'false'), ($x{a} ? 'true' : 'false') ]\n"},{"out":"[\"REF\",123]","err":"","code":"my $x = \\{ a => 123 }; [ ref $x, $$x->{a} ]\n"},{"err":"","out":"{a => 1}","code":"my %x = (a => 1); my $y = { %x }; delete $y->{a}; \\%x\n"},{"code":"my %x = (a => 1); my $y = \\%x; delete $y->{a}; \\%x\n","out":"{}","err":""},{"err":"","out":"[\"bbb\"]","code":"my $x = 'aaa'; sub f { $_[0] = 'bbb';}; f($x); [$x]\n"},{"code":"my $x = 'aaa'; sub f { \\@_ }; my $y = f($x); $y->[0] = 'bbb'; $x\n","err":"","out":"bbb"},{"err":"","out":"xbxbxbaba","code":"my $x=\"ababababa\"; $x=~s/a/x/ for 1..3; $x\n"},{"code":"my $x = \"a b a c a d a e\"; [$x =~ s/a/t/g]\n","out":"[4]","err":""},{"code":"my $x = \"a b a c a d a e\"; [$x !~ s/a/t/g]\n","err":"","out":"[\"\"]"},{"code":"my $x = 'abcd'; substr $x, 2 # but more importantly it'd make the code almost readable\n","out":"cd","err":""},{"err":"","out":"a","code":"my $x = \"a\"; ${\\my $x} = \"b\"; $x\n"},{"out":"2;","err":"","code":"my $x = \"asdf\"; pos($x) = 1; { local pos($x) = 2; print pos $x, \";\";} pos $x\n"},{"err":"","out":"4;4","code":"my $x = \"asdf\"; pos($x) = 2; { local pos($x) = 4; print pos $x, \";\";} print pos $x\n"},{"code":"my $x = \"asdf\"; pos($x) = 666; pos $x\n","err":"","out":"4"},{"code":"my $x = \"asdfX\"; my $y = \"asdfY\"; $x =~ /\\A\\Q$y\\E{0}.\\z/s ? \"yes\" : \"no\"\n","out":"yes","err":""},{"err":"","out":"yes","code":"my $x = \"asdfX\"; my $y = \"asdfY\"; $x =~ /\\A(?>\\Q$y\\E??).\\z/s ? \"yes\" : \"no\"\n"},{"err":"","out":"no","code":"my $x = \"asdfY\"; my $y = \"asdfYt\"; $x =~ /\\A(?>\\Q$y\\E??).\\z/s ? \"yes\" : \"no\"\n"},{"err":"","out":"no","code":"my $x = \"asdfYt\"; my $y = \"asdfY\"; $x =~ /\\A(?>\\Q$y\\E??).\\z/s ? \"yes\" : \"no\"\n"},{"code":"my $x; BEGIN { $x = 'x' } our $$x = 123; # basically this - the 'our' isn't doing anything useful so it can be left out entirely\n","err":"","out":"ERROR: Can't declare scalar dereference in \"our\" at (eval 558) line 1, near \"$x =\"\n"},{"out":"(0, 7)(1, 8)(2, 9)","err":"","code":"my $x = bless [7,8,9], q{FOO}; print qq{($a, $b)} while ($a, $b) = each @$x; ### What I don't quite understand is that @$x to such a function works, so it wouldn't make sense for keys or so to do something similar, if UNIVERSAL::isa( $arg, q{ARRAY} ) @$arg or something like that? Or would overloading still muck with that?\n"},{"code":"my $x = bless [7,8,9], q{FOO}; UNIVERSAL::isa( $x, q{ARRAY} )\n","out":"1","err":""},{"err":"","out":"Foo=HASH(0x4b25938)","code":"my $x = bless {}, q{Foo}; \"$x\";\n"},{"code":"my @x = ('c', 'd'); [ %x[1] ]\n","out":"[1,\"d\"]","err":""},{"err":"","out":"[1,undef]","code":"my @x = ('c', 'd'); [ %x{1} ]\n"},{"code":"my $x = 'code'; print $$x;\n","out":"1","err":""},{"err":"","out":"","code":"my $x = 'code'; $$x;\n"},{"code":"my $x = \"Data::Dumper\"; use $x;\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"use $x\"\n"},{"out":"[\\42]","err":"","code":"my $x = \\do {42}; [ $x ]\n"},{"code":"my $x = \\do {42}; [ ++$$x ]\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"my $x = \\do {my $o = 42}; [ ++$$x ]\n","out":"[43]","err":""},{"err":"","out":"foo","code":"my $x = do { my $tmp; \\$tmp }; my $y = $x; $$y = 'foo'; print $$x; # porton is this what you want?\n"},{"err":"","out":"-1","code":"{ my $x = \"e\"; $x--; print $x }\n"},{"err":"","out":"{second => \"great success\"}","code":"my $x = { first => 'some error here', second => 'great success' }; my %h = map { ($x->{$_} !~ /error/) ? ($_ => $x->{$_}) : () } keys %$x; \\%h # like this, you mean?\n"},{"code":"my $x = { foo => 1 }; my \\%y = $x; $y{bar} = 2; $x;\n","out":"ERROR: syntax error at (eval 558) line 1, near \"my \\\"\n","err":""},{"out":"1oo4ar7az10uux14leem","err":"","code":"my $x = 'FooBarBazQuuxFleem'; my $off = 1; join '', map { (my $str = $_) =~ s/^./$off/; $off += length($_); $str } split /(?=[A-Z])/, $x;\n"},{"out":"Foo1Bar4Baz7Quux10Fleem14","err":"","code":"my $x = 'FooBarBazQuuxFleem'; my $off = 1; join '', map { (my $str = $_) =~ s/$/$off/; $off += length($_); $str } split /(?=[A-Z])/, $x;\n"},{"code":"my $x = 'FooBarBazQuuxFleem'; $x =~ s/[A-Z]/$+[0]/g; $x\n","err":"","out":"1oo4ar7az10uux14leem"},{"code":"my $x = 'FooBarBazQuuxFleem'; $x =~ s/B/$+[0]/g; $x\n","err":"","out":"Foo4ar7azQuuxFleem"},{"code":"my $x = 'FooBarBazQuuxFleem'; $x =~ s/B/$+[0]/g; $x =~ s/Q/$+[0]/g; $x\n","out":"Foo4ar7az10uuxFleem","err":""},{"code":"my $x = 'FooBarBazQuuxFleem'; $x =~ s/B/$+[0]/g; x =~ s/Q/$+[0]/g; $x\n","err":"","out":"ERROR: Can't modify constant item in substitution (s///) at (eval 558) line 1, at EOF\n"},{"out":"[\"foo\",\"bar:baz\"]","err":"","code":"my $x = \"foo:bar:baz\"; [ $x =~ /\\A(.*?)(?:=|==|:|--)(.*)\\z/s ]\n"},{"code":"my $x = \"foo:bar:baz\"; $x =~ /=|==|:|--/ or die; [ substr($x, 0, $-[0]), substr($x, $+[0]) ]\n","out":"[\"foo\",\"bar:baz\"]","err":""},{"err":"","out":"foobar","code":"my $x = \"foo\"; my $f = sub { print $x }; $f->(); $x = \"bar\"; $f->();\n"},{"code":"my @x = (\"foo\\n\", \"bar\", \"baz\\n\"); chomp @x; \\@x\n","err":"","out":"[\"foo\",\"bar\",\"baz\"]"},{"code":"my $x = 'foo'; $x ||= do { print 'bar'; 'baz' }; [ $x ];\n","err":"","out":"[\"foo\"]"},{"err":"","out":"bar","code":"my $x = 'foo'; $x &&= do { print 'bar'; 'baz' }; [ $x ];\n"},{"code":"my @x; for (@x) { print \"entered\" } # unless you mean something other than running code inside the foreach loop?\n","err":"","out":""},{"out":"3","err":"","code":"my $x; $_++ for ($x)x3; $x # two more examples\n"},{"code":"my $x = 'Friseure'; [ map { $x =~ /e$/g; pos($x) } 1..10 ] # does this make it any clearer?\n","out":"[8,undef,8,undef,8,undef,8,undef,8,undef]","err":""},{"out":"[\"nm37.bullet.mail.ir2.yahoo.com\",\"212.82.96.62\"]","err":"","code":"my $x=\"from nm37.bullet.mail.ir2.yahoo.com (nm37.bullet.mail.ir2.yahoo.com [212.82.96.62])\"; [ ($x =~ /[\\w.]+/g)[-2, -1] ] # tharkun\n"},{"code":"my $x = \"Hello a and b\"; $x =~ s/\\b([ab])\\b/$1 eq 'a' ? \"l3u\" : \"rindolf\"/ge; [$x]\n","out":"[\"Hello l3u and rindolf\"]","err":""},{"code":"my $x = \"Hello anna!\" [($x eq \"anna\" ? \"T\" : \"F\"), ($x =~ /anna/ ? \"T\" : \"F\")]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"\"Hello anna!\" [\"\n"},{"code":"my $x = \"Hello anna!\"; [($x eq \"anna\" ? \"T\" : \"F\"), ($x =~ /anna/ ? \"T\" : \"F\")]\n","out":"[\"F\",\"T\"]","err":""},{"code":"my $x = \"Hello \"; $x .= \"KNERD\"; [$x]\n","out":"[\"Hello KNERD\"]","err":""},{"out":"[\"hmm\"]","err":"","code":"my $x = \"hmm\"; [ (my $tmp = $x, undef $x)[0] ]\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, near \"$x)\"\n","err":"","code":"my $x = \"hmm\"; [ (my $tmp = $x; undef $x)[0] ]\n"},{"out":"[\"hmm\",undef]","err":"","code":"my $x = 'hmm'; [ ([$x]->[0], undef $x) ]\n"},{"err":"","out":"[\"hmm\"]","code":"my $x = 'hmm'; [ ([$x]->[0], undef $x)[0] ]\n"},{"code":"my $x = 'hmm'; [ (\"$x\", undef $x)[0] ]\n","err":"","out":"[\"hmm\"]"},{"code":"my $x = 'hmm'; [ ($x, undef $x)[0] ]\n","err":"","out":"[undef]"},{"code":"my $x = 'hmm'; [ [$x, undef $x]->[0] ]\n","out":"[undef]","err":""},{"out":"","err":"","code":"my $x = \"Host: myHost\\n\";  my ($targetHost) = $heap->{buffer} =~ m#Host: (.*?)#; return $targetHost;\n"},{"code":"my $x = []; if ($x) { print \"a ref is true even when it refers to empty\" }\n","out":"a ref is true even when it refers to empty","err":""},{"err":"","out":"interpolates?","code":"my $x = 'interpolates?'; qq'$x';\n"},{"out":"$x","err":"","code":"my $x = 'interpolates?'; q\"$x\";\n"},{"code":"my %x; local keys %x;\n","out":"ERROR: Can't modify keys in local at (eval 558) line 1, at EOF\n","err":""},{"out":"ERROR: Can't modify keys in local at (eval 558) line 1, near \"%x =\"\n","err":"","code":"my %x; local keys %x = \"hi\";\n"},{"err":"","out":"42","code":"my @x; local $x[0] = 42; \"@x\";\n"},{"out":"1","err":"","code":"my @x; local $x[0] = 42; @x;\n"},{"out":"[]","err":"","code":"my @x; local $x[0] = 42; \\@x;\n"},{"code":"my @x = (map { $_ * 10 } 0 .. 9); [%x[3,6]]\n","err":"","out":"[3,30,6,60]"},{"err":"","out":"3","code":"my @x = map { no strict qw(refs); $_; } 1..3; ### Why does this generate an error regarding the use of `no` ?\n"},{"code":"my @x = map { qq{$_\\n} } qw/ABC DEF 123 GHI/; join q{}, map { $_ x= !m!\\d+!; } @x ;\n","err":"","out":"ABC\nDEF\nGHI\n"},{"out":"[2,4,4,2,1,2,1,4,3,3]","err":"","code":"my @x = map rand(5), 1..10; [ map int(.5+$_), @x ]\n"},{"out":"[0,5,2,4,1,2,4,4,1,4,1,2,2,5,4,3,2,1,1,2,3,2,4,1,1,2,5,1,1,2,1,3,2,3,2,2,4,0,3,3]","err":"","code":"my @x = map rand(5), 1..40; [ map int(.5+$_), @x ]\n"},{"err":"","out":"[\"some\"]","code":"my @x = map /^(\\w+)/g, \"some test line\"; \\@x; # This is what I meant.\n"},{"code":"my @x = map /^(\\w+)/m, \"some test line\"; \\@x; # Passing flags can be useful.\n","out":"[\"some\"]","err":""},{"code":"my @x = map /^(\\w+)/, \"some test line\"; \\@x; # yet another way to do it.\n","err":"","out":"[\"some\"]"},{"out":"some","err":"","code":"my @x; my $line = \"some test line\"; push @x, $line =~ /^(\\w+)/; print for @x; # another way to write the same thing\n"},{"code":"[\\(my $x, my $y)]\n","err":"","out":"[\\undef,\\undef]"},{"code":"my $x; my $y = 1..1; [ $x, $y ]; ### Why exactly does assigning a range in scalar context result in the lhs being an empty string (not undef) ?\n","err":"","out":"[undef,\"1E0\"]"},{"code":"my $x = \"\" ; my $y; [ ($x // '') eq ($y // '') ]\n","out":"[1]","err":""},{"code":"my $x = \"\\n\"; [ $_ = chomp $x ]\n","err":"","out":"[1]"},{"code":"my $x = \"\\n\"; [chomp($x);]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n"},{"out":"[1]","err":"","code":"my $x = \"\\n\"; [chomp($x)]\n"},{"code":"my $x = \"\\n\"; chomp($x); print $x;\n","out":"1","err":""},{"code":"my $x = \"\\n\"; [ $x = chomp $x ]\n","out":"[1]","err":""},{"out":"[1,1]","err":"","code":"my $x = \"\\n\"; [$x = chomp $x, $x]\n"},{"out":"1","err":"","code":"my $x = \"\\n\"; $x = chomp $x; $x\n"},{"err":"","out":"1","code":"my $x = \"\\n\"; $x = chomp($x); $x\n"},{"err":"","out":"[\"One Two Three\"]","code":"my @x = (\"One\", \"Two\", \"Three\"); [join(\" \", @x)]\n"},{"code":"my @x; push @x, foo(), foo(); { my $var = 0; sub foo { $var++ } } push @x, foo(), foo(); \\@x\n","out":"[0,1,0,1]","err":""},{"code":"my @x; push @x, qw( A B C ); unshift @x, qw( X Y Z ); \\@x;\n","out":"[\"X\",\"Y\",\"Z\",\"A\",\"B\",\"C\"]","err":""},{"err":"","out":"[\"test\"]","code":"my @x; push @x, /^(\\w+)/ for 'test something'; \\@x;\n"},{"code":"my $x = q{abc}; !!$x;\n","out":"1","err":""},{"out":"[\"FOO\\\\tBAR\\\\r\\\\n\",\"FOO\\tBAR\\r\\n\"]","err":"","code":"my $x = q{FOO\\tBAR\\r\\n}; ( my $y = $x ) =~ s/\\\\t/\\t/g; $y =~ s/\\\\r/\\r/g; $y =~ s/\\\\n/\\n/g; [ $x, $y ];\n"},{"out":"0","err":"","code":"my $x = q{}; int !!$x;\n"},{"code":"my $x = qr/bar/; no overloading; \"$x\";\n","out":"Regexp=REGEXP(0x5ccedd0)","err":""},{"code":"my $x = qr/bar/; \"$x\"; # vs.\n","out":"(?^u:bar)","err":""},{"out":"(?^ux:what does this do)","err":"","code":"my $x = qr/what does this do/x; \"$x\"\n"},{"err":"","out":"[qr/\\w+/u,qr/\\w+/u]","code":"my $x = qr/\\w+/; [ $x, qr/$x/ ]; # Why can't dclone just handle Regexp objects like this?\n"},{"out":"[qr/x/u,$VAR1->[0]]","err":"","code":"my $x = qr/x/; my $y = $x; [ $x, $y ];\n"},{"code":"my @x = qw/1 2 3/; $_+=3 for @x; \\@x\n","err":"","out":"[4,5,6]"},{"code":"my @x = qw/1 2 3 4/; delete $x[-1]; print $_ // '!' for @x;\n","out":"123","err":""},{"code":"my @x = qw/1 2 3 4/; $x[-1] = undef; print $_ // '!' for @x;\n","out":"123!","err":""},{"out":"A => 1 | 1 => B | B => 2 | 2 => C | C => 3 | 3 =>  | ","err":"","code":"my @x = qw( @ A 1 B 2 C 3 ); foreach my $i ( 1 .. $#x ) { my ( $k, $v ) = ( $x[ $i ], $x[ $i++ + 1 ] ); print qq{$k => $v | }; }\n"},{"code":"my @x = qw( @ A 1 B 2 C 3 ); for ( my $i = 1; $i < @x; $i++ ) { my ( $k, $v ) = ( $x[ $i ], $x[ $i++ + 1 ] ); print qq{$k => $v | }; }\n","out":"A => 1 | B => 2 | C => 3 | ","err":""},{"err":"","out":"[\"a\",\"b\",\"c\",\"d\",\"d_aa\",\"a_aa\",\"b_aa\",\"a_ab\",\"c_aa\",\"a_ac\",\"c_ab\",\"c_ac\",\"c_ad\",\"d_ab\",\"e\",\"f\",\"g\",\"h\"]","code":"my @x = qw(a b c d d a b a c a c c c d e f g h); for(@x) { if($seen{$_}) { $_ = $_ . \"_\" . $seen{$_}++ } else { $seen{$_} = \"aa\" } } \\@x # like this, or something else?\n"},{"code":"my @x = qw(a b c d); delete $x[1]; print $_ // '!' for @x;\n","out":"a!cd","err":""},{"code":"my %x = qw(a b c d e f g h); [ @x{a, g} ]\n","out":"[\"b\",\"h\"]","err":""},{"err":"","out":"{a => \"b\",g => \"h\"}","code":"my %x = qw(a b c d e f g h); @y{a, g} = @x{a, g}; \\%y\n"},{"code":"my $x = [qw(a b c d e f g)]; [ keys @$x ] # it's available in both perl versions - 5.20 and 5.22\n","out":"[0,1,2,3,4,5,6]","err":""},{"code":"my @x = ( qw( A B C ) ); { exists => [ map { exists $x[ $_ ] } 0..5 ], x => \\@x };\n","out":"{exists => [1,1,1,\"\",\"\",\"\"],x => [\"A\",\"B\",\"C\"]}","err":""},{"err":"","out":"[\"a\",\"c\"]","code":"my @x = qw(a b c); splice @x, 1, 1; \\@x # if you want to remove an element from the array, use splice, pop or shift\n"},{"code":"my @x = qw(a b c); undef $x[1]; \\@x # if you want to set a specific element to undef, use undef\n","err":"","out":"[\"a\",undef,\"c\"]"},{"out":"c","err":"","code":"my $x = qw(a b c); $x # it's the list/scalar context that determines what you get\n"},{"code":"my @x = qw(foo bar baz); my @y = 1..3; [ \\(map {$_} @x, @y, 42) ]\n","out":"[\\\"foo\",\\\"bar\",\\\"baz\",\\1,\\2,\\3,\\42]","err":""},{"code":"my @x = qw(foo bar baz); my @y = 1..3; [ \\((@x, @y, 42)) ]\n","err":"","out":"[[\"foo\",\"bar\",\"baz\"],[1,2,3],\\42]"},{"out":"[[\"foo\",\"bar\",\"baz\"],[1,2,3],\\42]","err":"","code":"my @x = qw(foo bar baz); my @y = 1..3; [ \\(@x, @y, 42) ]\n"},{"out":"3","err":"","code":"my $x = () = qw(foo bar baz); $x\n"},{"code":"my @x = qw/foo bar/; my $y = (123 => @x); $y # or the usual fun\n","err":"","out":"2"},{"out":"[[\"x\",\"y\",\"z\",\"hi\"],[\"hi\"]]","err":"","code":"my @x = qw(x y z); my @y = do { push @x, my @x = q chic; @x }; [ \\@x, \\@y ]\n"},{"code":"my @x = qw(zero one two); my ($idx) = grep $x[$_] eq 'two', 0 .. $#x; $idx\n","out":"2","err":""},{"out":"","err":"","code":"my $x = q{}; !!$x;\n"},{"out":"[\"HASH(0x62bd670)\",103536240]","err":"","code":"my $x = {}; [ q{}. $x, int $x ]\n"},{"code":"my $x = []; ref \\$x\n","out":"REF","err":""},{"code":"my @xs; bless \\@xs, \"hello world\"; ref \\@xs\n","out":"hello world","err":""},{"code":"my $x :shared;\n","out":"","err":""},{"code":"my $x = '/somepath/subdir'; $y = '/newpath/newdir'; my $data = '/somepath/subdir/whatever.txt'; $data =~ s/\\Q$x/$y/g; [ $data ]\n","out":"[\"/newpath/newdir/whatever.txt\"]","err":""},{"code":"my $x = 'some test'; my $y = \\substr($x, 5, 4); $$y = 'data'; $x\n","err":"","out":"some data"},{"code":"my $x = \"something\"; qq/'\" foo bar baz '\" $x/\n","err":"","out":"'\" foo bar baz '\" something"},{"err":"","out":"[\"some var\",\"some thing\"]","code":"my $x = 'some var'; my $y = $x =~ s/var/thing/r; [ $x, $y ]\n"},{"out":"[\"b\",\"d\",\"o\",\"p\",\"z\",\"l\",\"a\"]","err":"","code":"my @xs = qw/a b d z o l p a l/; [ keys %{{ @xs, reverse @xs }} ]\n"},{"err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(\\\"\n","code":"my $x = sub (\\@) { \"$_[0]\" }; my @a = (3, 4); print &$x(@a); ()\n"},{"err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(\\\"\n","code":"my $x = sub (\\@) { \"$_[0]\" }; my @a = (3, 4); $x->(@a)\n"},{"code":"my $x; sub foo:lvalue { return $x } foo() = 123; $x;\n","err":"","out":"123"},{"err":"","out":"[\\undef,$VAR1->[0]]","code":"my $x; sub lala { \\$x } [\\$x, lala()] # identical\n"},{"code":"my $x = sub ($) { @_ }; *x = $x; [ join ' ', $x->('a'..'c'), '|', x('a'..'c') ]\n","out":"ERROR: Too many arguments for subroutine at (eval 558) line 1.\n","err":""},{"code":"my $x = 'test$blah'; $x =~ s#[^a-zA-Z0-9 ]##g; $x\n","out":"testblah","err":""},{"code":"my $x = \"test$blah\"; $x =~ s#[^a-zA-Z0-9 ]##g; $x\n","out":"test","err":""},{"out":"...","err":"","code":"my $x = 'testing'; for ($x) { (sub { $_ = shift; return /firefox/ })->('...') } $x # no, probably not okay\n"},{"code":"my $x = \\undef; &Internals::SvREADONLY($x, 0); $$x = 3; [ undef ]\n","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"my $x = \\undef; &Internals::SvREADONLY($x, 0); $$x = Scalar::Util::dualvar 0, \"lemons\"; [ undef, defined undef ]\n","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","code":"my $x = \\undef; &Internals::SvREADONLY($x, 0); $$x = Scalar::Util::dualvar 0, \"lemons\"; [ undef ] # maybe?\n"},{"code":"my $x = unpack \"b*\", \"this is a test\"; $c\n","err":"","out":""},{"code":"my $x = unpack \"b*\", \"this is a test\"; $x\n","out":"0010111000010110100101101100111000000100100101101100111000000100100001100000010000101110101001101100111000101110","err":""},{"err":"","out":"[undef,undef,undef,undef]","code":"my @x; [ @x[0..3] ]\n"},{"code":"my $x = []; [\"$x\", 0+$x]\n","err":"","out":"[\"ARRAY(0x5073460)\",84358240]"},{"err":"","out":"1","code":"my %x; $x[1] = 1;\n"},{"out":"ERROR: Can't modify index/value array slice in list assignment at (eval 558) line 1, at EOF\n","err":"","code":"my %x; %x[1] = 1; # gives a syntax error\n"},{"code":"my ($x, $x) = (1, 2); $x\n","err":"","out":"2"},{"code":"my %x; $x{a} = 4; @x{a} = (5); print $x{a}\n","err":"","out":"5"},{"code":"my %x; $x{a} = 4; @x{'a','b'} = (5); print $x{a}\n","out":"5","err":""},{"out":"","err":"","code":"my $x; $x{abc} = 123; $x\n"},{"code":"my $x; $x ||= do { print 'bar'; 'baz' }; [ $x ];\n","out":"bar","err":""},{"out":"[undef]","err":"","code":"my $x; $x &&= do { print 'bar'; 'baz' }; [ $x ];\n"},{"code":"my $x = \"X\\n\"; $x = chomp($x); [ \"$^V : x=$x\" ]\n","out":"[\"v5.22.1 : x=1\"]","err":""},{"code":"my $x; $x->what_did_you_expect\n","out":"ERROR: Can't call method \"what_did_you_expect\" on an undefined value at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"my @x; { ++$#x } \\@x\n","out":"[undef]","err":""},{"code":"my $x; $x++; $x\n","out":"1","err":""},{"code":"my $x = []; $x == \\@$xs ? \"yes\" : \"no\"\n","err":"","out":"no"},{"code":"my $x; $x ? $x++ : ( $x = 1 ); $x;\n","err":"","out":"1"},{"code":"my $x = {}; $x->{x} = $x; $x\n","out":"{x => $VAR1}","err":""},{"out":"yes","err":"","code":"my $x = []; $x == \\@$x ? \"yes\" : \"no\"\n"},{"err":"","out":"10","code":"my ($x, $y) = 1..10;\n"},{"code":"my ( $x, $y ) = ( 2733.754, 60 ); sprintf q{%.3f}, $x - int( $x/$y ) * $y;\n","err":"","out":"33.754"},{"code":"my ( $x, $y ) = ( 2733.754, 60 ); ( ( $x * 10000 ) - ( int($x/$y) * $y * 10000) ) / 10000; ### :)\n","out":"33.754","err":""},{"code":"my ( $x, $y ) = ( 2733.754, 60 ); $x - int( $x/$y ) * $y; ### :)\n","out":"33.7539999999999","err":""},{"code":"my ($x, $y) = 9..19;\n","out":"11","err":""},{"code":"my $x->{y} = $x;\n","err":"","out":""},{"code":"my ($x, $y); ${'x'} = 123; ${'y'} = 456;  [ $x, $y ] # even typo fixes I can't see how that would ever work\n","err":"","out":"[undef,undef]"},{"out":"Zoooooofix","err":"","code":"my $x = 'Zoffix'; substr($x, 2, 1) = 'ooooo'; $x\n"},{"code":"my @y = 1..9; my $x = (map { $y[$_-1] += $y[$_] } reverse 1..$#y)[-1]; $x # death.\n","out":"45","err":""},{"code":"my $y=1; my $x=\\$y; ++$x; [$x, $y]\n","err":"","out":"[83310969,1]"},{"err":"","out":"6","code":"my @y = ( 4, 5, 6 ); my $x = ( 0, @y[0 .. $#y] ); $x\n"},{"code":"my @y = ( 4, 5, 6 ); my $x = ( 0, @y ); ### I thought that would work, but I see it interprets @y in ( 0, @y ) in scalar context, effectively being ( 0, 3 ) rather than ( 0, 4, 5, 6 )\n","out":"3","err":""},{"out":"3","err":"","code":"my @y = ( 4, 5, 6 ); my $x = @y; $x; ### Gives size of list instead, as expected here. Is there a way to get the last item in the list, similar to how the comma operator would, like above?\n"},{"code":"my %y; my $x; \\$x = \\$y{x}; $x = 42; [ $x, \\%y ]\n","out":"[42,{x => 42}]","err":""},{"code":"my %y; our $x; *x = \\$y{x}; $x = 42; [ $x, \\%y ]\n","err":"","out":"[42,{x => 42}]"},{"err":"","out":"A\nB \"foo bar baz\" C\nD\n","code":"my $y = q{bar}; my @x = <A \"B \\\\\"foo $y baz\\\\\" C\" D>; print qq{$_\\n} for @x; # Seems to do everything I've seen people over and over ask if qw() could do.\n"},{"err":"","out":"[\"foox\",\"fooy\",\"fooz\"]","code":"my $y = q|foo{x,y,z}|; my @x = < $y >; \\@x;\n"},{"code":"my $y = q{x y z}; my @x = <A \"B foo\" C $y D \"$y\" E>; \\@x; # Feels a little like bash.\n","out":"[\"A\",\"B foo\",\"C\",\"x\",\"y\",\"z\",\"D\",\"x y z\",\"E\"]","err":""},{"err":"","out":"[11,9,10,[11]]","code":"my @z = my $ret = my ($x, $y) = 9..19; [ $ret, $x, $y, \\@z ]; # Basically just assigning $ret to @z, a la @z = $ret;\n"},{"err":"","out":"ERROR: Unrecognized character \\xC2; marked by <-- HERE after tures/; my<-- HERE near column 93 at (eval 558) line 1, <STDIN> line 1.\n","code":"myÂ %argsÂ =Â {domainÂ =>Â \"example.net\", numberÂ =>Â 0;};\n"},{"err":"","out":"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000","code":"my $_ = \"åå\"; s/(.)/sprintf('\\\\u%04x', $1)/ger\n"},{"err":"","out":"1","code":"\"\\n\" =~ /^$/\n"},{"out":"[\"\\\\n\"]","err":"","code":"['\\n']\n"},{"out":"[\"\\n\"]","err":"","code":"[\"\\n\"]\n"},{"out":"5","err":"","code":"$n = 0; 5 / ($n || 1)\n"},{"out":"1 1 2 3 5 8 13 21 34 55 ","err":"","code":"$n=10;$==0,(1x$_)=~/^(1|11(??{}))*$(?{$=++})^/,print\"$= \"for 0..$n-1\n"},{"out":"1 1 2 2 2 2 2 2 2 2 ","err":"","code":"$n=10;$==0,(1x$_)=~/^(1|11(?{}))*$(?{$=++})^/,print\"$= \"for 0..$n-1\n"},{"err":"","out":"1 1 2 2 2 2 2 2 2 2 ","code":"$n=10;$==0,(1x$_)=~/^(1|11)*$(?{$=++})^/,print\"$= \"for 0..$n-1\n"},{"err":"","out":"9a3298b0341b92a0\n","code":"$n = 11111111113232323232 ; $d = $n << 32 >> 32 ; $d1 = ($n - $d) >> 32 ;  $r = pack(\"N\",$d1) . pack(\"N\",$d) ; print unpack(\"H*\",$r) .\"\\n\"\n"},{"out":"00000000000000e8\n","err":"","code":"$n = 232 ; $d = $n << 32 >> 32 ; $d1 = ($n - $d) >> 32 ;  $r = pack(\"N\",$d1) . pack(\"N\",$d) ; print unpack(\"H*\",$r) .\"\\n\"\n"},{"out":"ffffffffffffffff\n","err":"","code":"$n = 23342342342342342342 ; $d = $n << 32 >> 32 ; $d1 = ($n - $d) >> 32 ;  $r = pack(\"N\",$d1) . pack(\"N\",$d) ; print unpack(\"H*\",$r) .\"\\n\"\n"},{"out":"46 46 46 46","err":"","code":"$n = 42; $, = ' '; print ++$n, ++$n, ++$n, ++$n  # oh, really\n"},{"err":"","out":"[\"d\",\"e\",\"f\",\"g\"]","code":"$n = 4; [ 'abcdefghi' =~ /c@{['(.)'x$n]}/ ]\n"},{"out":"5","err":"","code":"$n = 5; $n = $n++; $n\n"},{"code":"$n = 5; $n = ++$n; $n\n","out":"6","err":""},{"err":"","out":"ab\nac\nac\n1\n\n","code":"$\\=\"\\n\"; $_ = \"ab\"; print; $_++; print; $_+0; print; $_++; print\n"},{"code":"$\\=\"\\n\"; $_ = \"ab\"; print; $_++; print; $_+0; print; $_++; print; ()\n","err":"","out":"ab\nac\nac\n1\n\n"},{"out":"No such file or directory","err":"","code":"$! = 'NaN'; $!\n"},{"out":"ERROR: Illegal division by zero at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"'nan'/0\n"},{"code":"NaN/0\n","err":"","out":"bless( {sign => \"NaN\",value => [0]}, 'Math::BigInt' )"},{"code":"!!( \"nan\" <= 1.0 )\n","out":"","err":""},{"code":"\"NaN\" <=> \"NaN\"\n","out":"","err":""},{"err":"","out":"0","code":"(\"NaN\" <=> \"NaN\") + 0\n"},{"code":"'na'x3^\"\\f\"\n","err":"","out":"banana"},{"out":"","err":"","code":"\"\\n\" =~ /\\A\\z/\n"},{"code":"\"\\N{BEER MUG}\"\n","err":"","out":"ÃÂ°ÃÂÃÂÃÂº"},{"code":"\"\\nD\" =~ /^D/m\n","out":"1","err":""},{"out":"needs more :","err":"","code":"'needs more :'\n"},{"code":"$new = true; [$new, true]\n","out":"[\"true\",\"true\"]","err":""},{"out":"","err":"","code":"{ next }\n"},{"err":"","out":"[{a => {}}]","code":"{ next if $x->{a}{b}; } [ $x ]\n"},{"code":"\"nickserv!nickserv@blah\"\n","err":"","out":"nickserv!nickserv"},{"out":"ÃÂ¢ÃÂÃÂ½ÃÂ¢ÃÂÃÂ½ÃÂ¢ÃÂÃÂ½HELLOÃÂ¢ÃÂÃÂ½ÃÂ¢ÃÂÃÂ½ÃÂ¢ÃÂÃÂ½","err":"","code":"\"\\N{INTERROBANG}\" x 3 . \"HELLO\" . \"\\N{INTERROBANG}\" x 3\n"},{"err":"","out":"1","code":"\"\\n\" =~ /\\n/\n"},{"out":"[\"   hello\\n\"]","err":"","code":"[ \"  \\n   \\n  \\n   hello\\n\" =~ s/^\\s*\\n//r ]\n"},{"code":"\"  \\n   \\n  \\nhello\\n\" =~ s/^\\s*//sr\n","err":"","out":"hello\n"},{"code":"$_ = \"\\n\\nTAG\\n\\n\\n\"; s/\\A\\n+//; s/\\n+\\z/\\n/; [ $_ ]\n","err":"","out":"[\"TAG\\n\"]"},{"code":"no arybase;\n","err":"","out":""},{"out":"ERROR: Can't locate autovivification.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"no autovivification 'delete'; delete $undef->{key}; $undef\n"},{"code":"$nodes[5] = 1; \\@nodes\n","out":"[undef,undef,undef,undef,undef,1]","err":""},{"err":"","out":"[0]","code":"@nodeStatus = (0) * 150; \\@nodeStatus\n"},{"err":"","out":"[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]","code":"@nodeStatus = (0) x 150; \\@nodeStatus\n"},{"code":"no feature ':all'; sub foo (;$) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \\%h\n","err":"","out":"{bar => [42],meow => \"moo\"}"},{"out":"ERROR: Too many arguments for main::foo at (eval 558) line 1, near \"'moo' )\"\n","err":"","code":"no feature ':all'; sub foo (;$$) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \\%h\n"},{"code":"no feature; no indirect 'fatal'; sub new { bless [] }; [ new {main} 1,2 ]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"} 1\"\n","err":""},{"code":"no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new { bless [] }; [ new {main} ]\n","out":"[bless( [], 'foo' )]","err":""},{"code":"no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new { bless [] }; [ new main ]\n","err":"","out":"ERROR: Indirect call of method \"new\" on object \"main\" at (eval 558) line 1.\n"},{"code":"no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new(*) { bless [] }; [ new main ]\n","out":"[bless( [], 'foo' )]","err":""},{"code":"no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new { die @_ }; [ new {main} ]\n","err":"","out":"ERROR: HASH(0x506c248)"},{"code":"no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new { die @_ }; [ new {main} 1,2 ]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"} 1\"\n","err":""},{"code":"no feature; no indirect; sub new { bless [] }; package foo; sub new(*) { bless [] }; [ new main ]\n","err":"","out":"[bless( [], 'foo' )]"},{"err":"","out":"[\"foo\\nbar\\nbaz\\n\"]","code":"no feature 'say'; open $fh, \">\", \\$str; say $fh $_ for qw,foo bar baz,; [ $str ]\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"$fh $_\"\n","code":"no feature 'say'; open $fh, \">\", \\$str; say($fh $_) for qw,foo bar baz,; [ $str ]\n"},{"code":"no feature 'signatures'; sub foo (&@) { my ($code, @args) = @_; $code->(@args) } my $res = foo { [@_] } 1, 2, 3; $res\n","err":"","out":"[1,2,3]"},{"code":"no feature 'signatures'; sub foo (\\@) { say @_ };  foo +(split //, \"foobar\")\n","err":"","out":"ERROR: Type of arg 1 to main::foo must be array (not split) at (eval 558) line 1, at EOF\n"},{"code":"no feature 'signatures'; sub foo { [@_] } sub bar (\\@) { [@_] } [foo(1,2,3), bar(1,2,3)]\n","out":"ERROR: Type of arg 1 to main::bar must be array (not constant item) at (eval 558) line 1, near \"3)\"\nToo many arguments for main::bar at (eval 558) line 1, near \"3)\"\n","err":""},{"err":"","out":"[{thingy => 1},2,3]","code":"no feature 'signatures'; sub foo ($) { {thingy => $_[0]} } [foo 1, 2, 3]\n"},{"err":"","out":"[4,3,2]","code":"no feature 'signatures'; sub sort_subset_by (\\@@) { my ($expected, @stuff) = @_; my %in = map { ($_ => 1) } @stuff; return grep { $in{$_} } @$expected; } my @exp = (5,4,3,2,1); my @arr = (2,3,4); [sort_subset_by @exp, @arr]\n"},{"out":"[bless( [], 'foo' )]","err":"","code":"no feature; sub new { bless [] }; package foo; sub new(*) { bless [] }; [ new main ]\n"},{"out":"[]","err":"","code":"no feature 'unicode_strings'; my $d = my $u; utf8::upgrade($u); utf8::downgrade($d); [ map /\\w/, $u, $d ]\n"},{"code":"no feature 'unicode_strings'; my $d = my $u = \"\\x{df}\"; utf8::upgrade($u); utf8::downgrade($d); [ map 0+/\\w/, $u, $d ]\n","out":"[1,0]","err":""},{"code":"no feature 'unicode_strings'; my $d = my $u = \"\\x{df}\"; utf8::upgrade($u); utf8::downgrade($d); [ map /\\w/, $u, $d ]\n","err":"","out":"[1]"},{"code":"no feature 'unicode_strings'; \"\\N{U+666}\" =~ /\\d/\n","err":"","out":"1"},{"out":"ERROR: Can't locate object method \"parse\" via package \"backwards\" (perhaps you forgot to load \"backwards\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"Indirect call of method \"parse\" on object \"backwards\" at (eval 558) line 1.\n","code":"no indirect; parse backwards;\n"},{"code":"no indirect; sub main { bless [] }; [ new main ]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"new main \"\n","err":""},{"err":"","out":"No output.","code":"\"No output.\"\n"},{"code":"no overloading; '' . *STDOUT{IO};\n","err":"","out":"IO::File=IO(0x1d61e40)"},{"code":"no 'strict'\n","out":"ERROR: syntax error at (eval 558) line 1, near \"no 'strict'\"\n","err":""},{"code":"no strict; [ Foo ]\n","err":"","out":"[\"Foo\"]"},{"err":"","out":"","code":"no strict 'refs';  my $lexicalvar = \"hello\";  ${\"lexicalvar\"}\n"},{"err":"","out":"hello","code":"no strict 'refs';  our $packagevar = \"hello\";  ${\"packagevar\"}\n"},{"code":"no strict; sub Foo { \"Bar\" }; [ Foo ]\n","err":"","out":"[\"Bar\"]"},{"err":"","out":"{one => [[\"a\",0,\"F\"],[\"b\",1,\"N\"],[\"c\",2,\"N\"]],two => [[\"x\",0,\"F\"],[\"y\",1,\"N\"],[\"z\",2,\"N\"]]}","code":"no strict 'vars'; sub foo { local $n = $n//0; my @p = (shift, $n, $n ? 'N' : 'F'); ++$n; @_ ? (\\@p, &foo) : \\@p }; { 'one' => [foo('a'..'c')], 'two' => [foo('x'..'z')] };\n"},{"out":"{one => [[\"a\",0,\"F\"],[[\"b\",1,\"N\"],[[\"c\",2,\"N\"]]]],two => [[\"x\",0,\"F\"],[[\"y\",1,\"N\"],[[\"z\",2,\"N\"]]]]}","err":"","code":"no strict 'vars'; sub foo { local $n = $n//0; my @p = [ shift, $n, $n ? 'N' : 'F' ]; ++$n; @_ ? [ @p, foo( @_ ) ] : \\@p }; { 'one' => foo('a'..'c'), 'two' => foo('x'..'z') };\n"},{"code":"no strict 'vars'; sub foo { local $n = $n//0; my @p = (shift, $n, $n ? 'N' : 'F'); @_ ? (@p, &foo) : @p }; { 'one' => [foo('a'..'c')], 'two' => [foo('x'..'z')] };\n","err":"","out":"{two => [\"x\",0,\"F\",\"y\",0,\"F\",\"z\",0,\"F\"],one => [\"a\",0,\"F\",\"b\",0,\"F\",\"c\",0,\"F\"]}"},{"err":"","out":"{two => [[\"x\",0,\"F\"],[\"y\",0,\"F\"],[\"z\",0,\"F\"]],one => [[\"a\",0,\"F\"],[\"b\",0,\"F\"],[\"c\",0,\"F\"]]}","code":"no strict 'vars'; sub foo { local $n = $n//0; my @p = (shift, $n, $n ? 'N' : 'F'); @_ ? (\\@p, &foo) : \\@p }; { 'one' => [foo('a'..'c')], 'two' => [foo('x'..'z')] };\n"},{"out":"[]","err":"","code":"[ No::Such::Class->import() ]\n"},{"code":"{ not => 'a block' }\n","out":"{not => \"a block\"}","err":""},{"code":"$nothing=\"a\"; print \"Nothing found\\n\" if $nothing !~ /^\\w+/;\n","err":"","out":""},{"out":"Nothing found\n","err":"","code":"$nothing=\"\"; if ($nothing !~ /./) { print \"Nothing found\\n\" }\n"},{"out":"Nothing found\n","err":"","code":"$nothing=\"\"; print \"Nothing found\\n\" if $nothing eq \"\";\n"},{"code":"$nothing=\"\"; print \"Nothing found\\n\" if $nothing !~ /^\\w+/;\n","err":"","out":"Nothing found\n"},{"err":"","out":"ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ¡r jÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂº sÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂºr?","code":"no utf8; encode 'UTF-8', 'ÃÂ¡r jÃÂº sÃÂºr?'\n"},{"err":"","out":"195.188","code":"no utf8; printf \"%vd\", \"Ã¼\"  # does this even work\n"},{"out":"ÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂ","err":"","code":"{no utf8; $x=\"âââ\" }; $x\n"},{"err":"","out":"","code":"\"no\" while \"no\"\n"},{"out":"ÃÂ°ÃÂÃÂÃÂ©","err":"","code":"\"\\N{PILE OF POO}\"\n"},{"code":"[ $., $NR ]\n","err":"","out":"[1,undef]"},{"err":"","out":"ÃÂ°ÃÂÃÂÃÂ¿ÃÂ°ÃÂÃÂÃÂ¦","code":"\"\\N{REGIONAL INDICATOR SYMBOL LETTER Z}\\N{REGIONAL INDICATOR SYMBOL LETTER A}\"\n"},{"out":"\n\r\n","err":"","code":"\"\\n\\r\\n\"\n"},{"code":"\"\\n\" =~ /\\s/\n","out":"1","err":""},{"code":"\"\\n\" =~ /(?[ \\s - [\\n] ])/ ? \"match\" : \"no match\"\n","out":"no match","err":""},{"code":"\"\\n\" =~ (?[ \\s - [\\n] ]) ? \"match\" : \"no match\"\n","err":"","out":"ERROR: Substitution pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"\"\\N{SNOWMAN}\"\n","err":"","out":"ÃÂ¢ÃÂÃÂ"},{"err":"","out":"ÃÂ¢ÃÂÃÂ","code":"\"\\N{SPARKLE}\"\n"},{"code":"\"\\N{SPARKLE}\";\n","err":"","out":"ÃÂ¢ÃÂÃÂ"},{"err":"","out":"[\"\\x{2747}\"]","code":"[ \"\\N{SPARKLE}\" ]\n"},{"code":"[ \"\\N{test}\" ]\n","out":"ERROR: Unknown charname 'test' at (eval 558) line 1, within string\n","err":""},{"code":"\"\\N{U+00A2}\"\n","err":"","out":"ÃÂ¢"},{"code":"\"\\N{U+0B}\" =~ /(?[ \\s - [\\n] ])/ ? \"match\" : \"no match\"\n","out":"match","err":""},{"code":"\"\\N{U+1f52b}\"\n","out":"ÃÂ°ÃÂÃÂÃÂ«","err":""},{"err":"","out":"1","code":"\"\\N{U+666}\" =~ /\\d/\n"},{"out":"ERROR: Illegal number of bits in vec at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$num = 0b00000011111111111111111111111111; [vec($num, 0, 26), vec($num, 26, 6)]\n"},{"out":"-2","err":"","code":"$num = -1.67; int($num + $num / abs($num * 2));\n"},{"out":"b1n2n3","err":"","code":"$num = 1; \"banana\" =~ s/a/$num++/ger\n"},{"err":"","out":"btest: 1ntest: 2ntest: 3","code":"$num = 1; \"banana\" =~ s/a/\"test: ${\\$num++}\"/ger\n"},{"err":"","out":"btest: 1++ntest: 1++ntest: 1++","code":"$num = 1; \"banana\" =~ s/a/\"test: $num++\"/ger\n"},{"err":"","out":"b1n2n3","code":"$num = 1; \"banana\" =~ s/a/test: $num++/ger\n"},{"err":"","out":"4,294,967,296","code":"$num=2**32; $digits=reverse $num; $digits =~ s/(\\d\\d\\d)(?=\\d)(?!\\d*\\.)/$1,/g; $num=reverse $digits; print $num\n"},{"code":"$num=2**32; $digits=reverse $num; $digits =~ s/(\\d\\d\\d)(?=\\d)(?!\\d*\\.)/$1,/g; print $digits;\n","err":"","out":"692,769,492,4"},{"out":"1","err":"","code":"$num='2**32'; $digits=reverse $num; $digits =~ s/(\\d\\d\\d)(?=\\d)(?!\\d*\\.)/$1,/g; print reverse $digist;\n"},{"out":"23**2","err":"","code":"$num='2**32'; $digits=reverse $num; $digits =~ s/(\\d\\d\\d)(?=\\d)(?!\\d*\\.)/$1,/g; print reverse $digits;\n"},{"err":"","out":"692,769,492,4","code":"$num=2**32; $digits=reverse $num; $digits =~ s/(\\d\\d\\d)(?=\\d)(?!\\d*\\.)/$1,/g; print reverse $digits;\n"},{"out":"02","err":"","code":"$num=\"2\"; $num = sprintf(\"%02d\", $num); print $num\n"},{"err":"","out":" 2","code":"$num=\"2\"; $num = sprintf(\"%2d\", $num); print $num\n"},{"err":"","out":"[[1000,200,30,40,5,7],[5,7,30,40,200,1000]]","code":"@nums = (30, 7, 200, 40, 5, 1000); [ [ sort @nums ], [ sort { $a <=> $b } @nums ] ] # string-sort using default cmp vs numeric <=>\n"},{"code":"\"\\N{VERTICAL TAB}\" =~ /(?[ \\s - [\\n] ])/ ? \"match\" : \"no match\"\n","out":"ERROR: Unknown charname 'VERTICAL TAB' at (eval 558) line 1, within string\n","err":""},{"out":"match","err":"","code":"\"\\N{VT}\" =~ /(?[ \\s - [\\n] ])/ ? \"match\" : \"no match\"\n"},{"code":"\"\\n\" =~ /^/ ? 'y' : 'n'\n","err":"","out":"y"},{"code":"\"\\n\" =~ /^$/ ? 'y' : 'n'\n","out":"y","err":""},{"code":"\"\\n\" =~ /^\\z/ ? 'y' : 'n'\n","out":"n","err":""},{"code":"$^O\n","out":"sco_sv","err":""},{"err":"","out":"ERROR: Can't call method \"generic_method\" on an undefined value at (eval 558) line 1, <STDIN> line 1.\n","code":"$obj->generic_method();\n"},{"code":"@occ = 'xxx hihi.so yyy hoho.so' =~ /\\w+\\.so/g; \\@occ\n","err":"","out":"[\"hihi.so\",\"hoho.so\"]"},{"out":"[0]","err":"","code":"[ oct \"0.00_02\" ]\n"},{"out":"509","err":"","code":"oct '0775'\n"},{"out":"0","err":"","code":"oct '0a'\n"},{"err":"","out":"36","code":"oct \"0b0100100\"\n"},{"err":"","out":"[2,2,2]","code":"[ oct(0b10),oct(0x2),hex(0b10) ]\n"},{"err":"","out":"25","code":"oct(0b11111);\n"},{"err":"","out":"255","code":"oct '0b' . '11111111'\n"},{"code":"oct '0b' . ('1' x 64)\n","err":"","out":"18446744073709551615"},{"err":"","out":"16","code":"oct \"0x10\"\n"},{"code":"[ oct \"0x10\", hex \"010\" ]\n","out":"[16,16]","err":""},{"out":"[10]","err":"","code":"[ oct \"0xa\" ]\n"},{"code":"oct \"10\"\n","out":"8","err":""},{"code":"[ oct \"10_00\" ]\n","err":"","out":"[512]"},{"code":"oct \"1_2\"\n","err":"","out":"10"},{"code":"oct \"1.2e3\"\n","out":"1","err":""},{"code":"oct(\"420)\"\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":""},{"err":"","out":"4","code":"oct \"4e3\"\n"},{"code":"$_='oh turtleneck\n","err":"","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"oh turtleneck","err":"","code":"$_='oh turtleneck phrase jar!'; s/.{13}\\K.*//s; print;\n"},{"err":"","out":"oh turtleneck","code":"$_='oh turtleneck phrase jar!'; s/(?<=.{13}).*//; print\n"},{"code":"$_='oh turtleneck phrase jar!'; s/(?<=.{13}).*//s; print\n","err":"","out":"oh turtleneck"},{"out":"oh turtleneck","err":"","code":"$_='oh turtleneck phrase jar!'; s/(?<=.{13}).*//s; print;\n"},{"code":"$_ = \"Oh Turtleneck Phrase Jar\";  s/(.)/rand(3)>1?lc($1):uc($1)/ge; $_\n","out":"OH TURTleNecK phraSE Jar","err":""},{"err":"","out":"oh turtleneck phrase jar","code":"$_ = \"Oh Turtleneck Phrase Jar\";  s/(.)/rand(3)?lc($1):uc($1)/ge; $_\n"},{"code":"$_='oh turtleneck phrase jar!'; s/(?<=\\w{13}).*//s; print;\n","out":"oh turtleneck phrase jar!","err":""},{"code":"$old = 'abc'; $new = substr($old, 0) = ''; [$old, $new]\n","out":"[\"\",\"\"]","err":""},{"code":"$old = 'abc'; $new = substr($old) = ''; [$old, $new]\n","out":"ERROR: Not enough arguments for substr at (eval 558) line 1, near \"$old) \"\n","err":""},{"err":"","out":"[]","code":"\\@ONC\n"},{"out":"[\"one\",1,\"two\",2,\"three\",3]","err":"","code":"$_ = \"one=1 two=2 three=3\"; [ m/(\\w+)=(\\d+)/gc ]\n"},{"code":"$_ = \"one=1 two=2 three=3\"; print $1 while m/(\\w+)=(\\d+)/gc\n","err":"","out":"onetwothree"},{"err":"","out":"1","code":"$one = 'foobar'; $two = \"foobazquux\"; $count = () = $one.$two =~ /[$one$two]/g\n"},{"err":"","out":"16","code":"$one = 'foobar'; $two = \"foobazquux\"; $count = () = ($one.$two) =~ /[\\Q$one$two\\E]/g\n"},{"code":"$one = 'foobar'; $two = \"foobazquux\"; $count = () = $one.$two =~ /[\\Q$one$two\\E]/g\n","err":"","out":"1"},{"code":"$one = 'foobar'; $two = \"foobazquux\"; $count = () = $two =~ /[$one]/g\n","out":"5","err":""},{"code":"$one = \"foobar\"; $two = \"foobazquux\"; $i++ while substr($one, $i, 1) eq substr($two, $i, 1); $i\n","err":"","out":"5"},{"out":"[\"three some text four\"]","err":"","code":"$_ = \"one\\ntwo\\nthree some text four\\nfive\\n\"; [ /(.*some text.*)/ ]\n"},{"code":"[\"one two \" =~ /(one (two)) (three)?/]\n","err":"","out":"[\"one two\",\"two\",undef]"},{"err":"","out":"[\"one.two\"]","code":"$_ = 'one.two.three'; [ /(.*)\\./ ]\n"},{"err":"","out":"one two three","code":"$_ = \"one two three\"; %h = ( one => 1, two => 2 ); s/$_/$h{$_}/ for keys %h; $_\n"},{"code":"$_ = \"one two three\"; %h = ( one => 1, two => 2 ); s/$_/$h{$_}/ for keys %h; $_\"\n","err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"[\"one two three\" =~ /(one (two)) (three)/]\n","out":"[\"one two\",\"two\",\"three\"]","err":""},{"err":"","out":" two three","code":"$_ = 'one two two three'; $_ =~ s/^.*?two//; $_\n"},{"code":"'one two two three' =~ 's/^.*?two//r\n","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":" two three","code":"'one two two three' =~ s/^.*?two//r\n"},{"code":"[ $^O ] # of course perlbot runs on a massively-distributed network with lots of nodes so the result here may vary\n","err":"","out":"[\"sunos\"]"},{"err":"","out":"O_O","code":"\"O.O\" =~ s/\\./_/r\n"},{"code":"[ ${^OPEN} ]\n","err":"","out":"[undef]"},{"code":"open(2, \"|df -h\")\n","err":"","out":""},{"out":"[]","err":"","code":"[ 'openerp-server' =~ m{/([^/]+)$} ]\n"},{"out":"[\"asdf\\n\"]","err":"","code":"open $fh, \">\", \\$str; say($fh 'asdf'); [ $str ]\n"},{"out":"[\"foo\\nbar\\nbaz\\n\"]","err":"","code":"open $fh, \">\", \\$str; say($fh $_) for qw,foo bar baz,; [ $str ]\n"},{"code":"open FILE, \"<\", \"/etc/passwdoeuoe\"; print <FILE>\n","err":"","out":"1"},{"out":"1","err":"","code":"open FILE, \"<\", \"/etc/passwd\"; print <FILE>\n"},{"code":"open $f, \"<\", \"/proc/self/mountinfo\"; fileno($f)\n","err":"","out":""},{"err":"","out":"-0.386878535474779","code":"open(F,\"/usr/share/dict/words\");@w=<F>;close(F); $r=rand($#w++); print $r\n"},{"out":"1","err":"","code":"open(F,\"/usr/share/dict/words\");@w=<F>;close(F); $r=rand($#w++); print $w[$r]\n"},{"code":"open(F,\"/usr/share/dict/words\");@w=<F>;close(F); $r=rand($#w++); $w[$r]\n","err":"","out":""},{"out":"","err":"","code":"open my $fh, \\$altreus; print $fh \"I hate you\";\n"},{"code":"open my @fh, '<', '/dev/zero' or die $!; \\@fh\n","err":"","out":"ERROR: Too many open files at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"GLOB","code":"open my $fh, '>', \\my $buffer; ref $fh\n"},{"code":"open my $fh, '>', \\my $foo or die $!; [$fh, $fh->isa(\"GLOB\"), ref $fh]\n","out":"[\\*{'::$fh'},1,\"GLOB\"]","err":""},{"code":"open my $fh, '>', \\my $foo or die $!; [$fh, $fh->isa(\"GLOB\"), ref $fh, \\@GLOB::ISA]\n","out":"[\\*{'::$fh'},1,\"GLOB\",[]]","err":""},{"out":"GLOB","err":"","code":"open my $fh, '>', \\my $foo or die $!; print ref $fh;\n"},{"out":"[\"IO::File=IO(0x60a2030)\"]","err":"","code":"open my $fh , '>', \\my $str; [ '' . *$fh{IO} ]\n"},{"code":"open my $fh , '>', \\my $str; [ *$fh{IO} ]\n","out":"[bless( , 'IO::File' )]","err":"cannot handle ref type 15 at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/Data/Dumper.pm line 231, <STDIN> line 1.\n"},{"code":"open my $fh , '>', \\my $str; [ ref *$fh{IO} ]\n","err":"","out":"[\"IO::File\"]"},{"err":"","out":"[\"GLOB\"]","code":"open my $fh , q{>}, \\(my $str); say $fh q{foo}; [ ref $fh ];\n"},{"code":"open my($fh), \"<\", \"some file which doesn't exist\"; [ $! + 0, \"\" . $! ]\n","out":"[24,\"Too many open files\"]","err":""},{"code":"open my($fh), \"<\", \"some file which doesn't exist\"; [ 0 + $!, \"\" . $! ]\n","out":"[24,\"Too many open files\"]","err":""},{"err":"","out":"abcxyzw","code":"open my $fh, '<', \\\"xyzwtu\"; my $s = \"abc\"; read $fh, $s, 4, 3; $s\n"},{"code":"open my $lol, '<', 'lol'; <$lol>\n","out":"","err":""},{"code":"open my $lol, '>', 'lol'; $lol->print(\"lol\");\n","err":"","out":""},{"code":"open( my $ofh, q{>}, q{/tmp/abc.txt} ) or die qq{write: $!}; print $ofh q{abcdefghijklmnopqrstuvwxyz}; close $ofh; open( my $ifh, q{<}, q{/tmp/abc.txt} ) or die qq{read: $!}; my $count = read $ifh, my $chunk, 10, 5; close $ifh; [ $count, $chunk ];\n","err":"","out":"ERROR: write: Too many open files at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"GLOB(0x5255738)","err":"","code":"open $out2, '>&=', 2 or warn \">$!<\"; $out2->autoflush(1); \"\".$out2\n"},{"code":"open undef\n","out":"ERROR: Can't use an undefined value as filehandle reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"[ $^O ] # perldoc -v '$^O' for details\n","out":"[\"svr4\"]","err":""},{"code":"ord 'Â«'\n","err":"","out":"194"},{"out":"194","err":"","code":"ord 'Â£'\n"},{"err":"","out":"42","code":"ord '*'\n"},{"err":"","out":"226","code":"ord 'â'\n"},{"code":"ord \"'\"\n","err":"","out":"39"},{"code":"ord('/')\n","out":"47","err":""},{"out":"46","err":"","code":"ord(\".\")\n"},{"code":"[ ord \"â°\", ord \"â¹\" ]\n","err":"","out":"[226,226]"},{"out":"[194]","err":"","code":"[ord \"Â²\"]\n"},{"code":"ord 'a'\n","out":"97","err":""},{"out":"65","err":"","code":"ord 'A'\n"},{"err":"","out":"32","code":"ord('a')^ord('A')\n"},{"out":"233","err":"","code":"ord chr 0xe9\n"},{"code":"(ord chr 0xe9) == 0xe9\n","err":"","out":"1"},{"code":"ord chr 0xe9 == 0xe9\n","out":"1","err":""},{"code":"or deparse:?\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"; or\"\n"},{"err":"","out":"2","code":"$#order = 2; $#order\n"},{"code":"@order = 2; @order and @order = grep $_, @order[-2, -1]\n","out":"ERROR: Modification of non-creatable array value attempted, subscript -2 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"0","err":"","code":"$#order = 2; @order and @order = grep $_, @order[-2,-1]\n"},{"err":"","out":"ERROR: Can't modify constant item in scalar assignment at (eval 558) line 1, at EOF\n","code":"$#order = 2; @order and order = grep $_, @order[-2,-1];\n"},{"code":"@order and @order = grep $_, @order[-2, -1]\n","out":"0","err":""},{"code":"... or die\n","out":"ERROR: Unimplemented at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"10","code":"ord \"\\n\"\n"},{"code":"[ord '~', ord ' ']\n","err":"","out":"[126,32]"},{"code":"[ord '.', ord '[']\n","err":"","out":"[46,91]"},{"code":"ord('/') - ord('+')\n","out":"4","err":""},{"err":"","out":"51","code":"ord pack 'A', 32\n"},{"code":"ord pack \"B8\", \"11111110\"\n","out":"254","err":""},{"code":"ord(split '',a..m=>N..Z)-7\n","out":"41","err":""},{"code":"[ord 'Ã']\n","out":"[195]","err":""},{"code":"ord unpack 'A', 32\n","err":"","out":"51"},{"out":"254","err":"","code":"ord \"\\xFE\"\n"},{"err":"","out":"208","code":"ord 'Ð¹'\n"},{"code":"or evaljs:\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"; or\"\n"},{"err":"","out":"[\"YT]]^\",\"hello\"]","code":"$original = \"hello\"; [ $coded = $original ^ '1' x length $original, $coded ^ '1' x length $coded ]\n"},{"code":"$_=\"otmat\"; /(?{$name=\"foo\"})re[x]ma|(?{$name=\"bar\"})o[ther]matc/; $name\n","out":"bar","err":""},{"err":"","out":"ERROR: Undefined subroutine &main::notlol called at (eval 558) line 1, <STDIN> line 1.\n","code":"our $AUTOLOAD = 'cats'; sub cats { \"lol\" } notlol()\n"},{"code":"our $baz = 'abc'; package foo; sub bar { our $baz; return ++$baz }; package main; [ foo::bar(), foo::bar(), $foo::baz, $baz ]\n","out":"[1,2,2,\"abc\"]","err":""},{"code":"{ our $baz = 'abc'; package foo; sub bar { our $baz; return ++$baz }; }; package thisfails; [ foo::bar(), foo::bar(), $foo::baz, $baz ]\n","err":"","out":"[1,2,2,undef]"},{"out":"[1,2,2,\"abc\"]","err":"","code":"our $baz = 'abc'; package foo; sub bar { our $baz; return ++$baz }; package thisfails; [ foo::bar(), foo::bar(), $foo::baz, $baz ]\n"},{"err":"","out":"0","code":"our $descriptivism++;\n"},{"code":"our $DIR; BEGIN { $DIR = 'BAR' } say $DIR;\n","out":"BAR\n","err":""},{"code":"our %foo = 1 .. 2; *foo->{1}\n","out":"2","err":""},{"err":"","out":"ERROR: Not a HASH reference at (eval 558) line 1, <STDIN> line 1.\n","code":"our %foo = 1, 2; (\\*foo)->{HASH}\n"},{"err":"","out":"{1 => undef}","code":"our %foo = 1, 2; *foo{HASH}\n"},{"code":"{ our $foo = 5;} eval { $foo }; { our $foo . $@ }\n","err":"","out":"5"},{"out":"{one => [\"a\",\"F\"],\"ARRAY(0x6000fa8)\" => [[\"z\",\"N\"]],two => [\"x\",\"F\"],\"ARRAY(0x6000c78)\" => [[\"c\",\"N\"]]}","err":"","code":"our $n = 0; sub foo { local $n = $n; my @p = [ shift, $n ? 'N' : 'F' ]; ++$n; @_ ? do { @p, foo( @_ ) } : \\@p }; { 'one' => foo('a'..'c'), 'two' => foo('x'..'z') };\n"},{"out":"{\"ARRAY(0x44f5868)\" => [[\"c\",\"N\"]],one => [\"a\",\"F\"],\"ARRAY(0x482b748)\" => [[\"z\",\"N\"]],two => [\"x\",\"F\"]}","err":"","code":"our $n = 0; sub foo { local $n = $n; my @p = [ shift, $n ? 'N' : 'F' ]; ++$n; @_ ? do { @p, foo( @_ ) } : \\@p }; { one => foo('a'..'c'), two => foo('x'..'z') };\n"},{"err":"","out":"{two => [[\"x\",\"F\"],[[\"y\",\"N\"],[[\"z\",\"N\"]]]],one => [[\"a\",\"F\"],[[\"b\",\"N\"],[[\"c\",\"N\"]]]]}","code":"our $n = 0; sub foo { local $n = $n; my @p = [ shift, $n ? 'N' : 'F' ]; ++$n; @_ ? [ @p, foo( @_ ) ] : \\@p }; { 'one' => foo('a'..'c'), 'two' => foo('x'..'z') };\n"},{"code":"our $n = 0; sub foo { local $n = $n; my @p = [ shift, $n, $n ? 'N' : 'F' ]; ++$n; @_ ? [ @p, foo( @_ ) ] : \\@p }; { 'one' => foo('a'..'c'), 'two' => foo('x'..'z') };\n","err":"","out":"{two => [[\"x\",0,\"F\"],[[\"y\",1,\"N\"],[[\"z\",2,\"N\"]]]],one => [[\"a\",0,\"F\"],[[\"b\",1,\"N\"],[[\"c\",2,\"N\"]]]]}"},{"code":"our sub Bulgaria { print caller; } package Wimbledon; Bulgaria()\n","err":"","out":"Wimbledon(eval 558)1"},{"err":"","out":"Uncle Bulgaria","code":"our $varname = \"womble\"; ${$varname} = \"Bulgaria\"; print \"Uncle $womble\"\n"},{"code":"our $x = \"\\\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"dogs","err":"","code":"{ our $x = \"dogs\" } { our $x; print $x }\n"},{"code":"our $x=\"\\n\"; $x = chomp $x; $x\n","err":"","out":"1"},{"out":"package","err":"","code":"our $x = 'package'; my $x = 'lexical'; { our $x; print $x }\n"},{"code":"our $x; sub lala { \\$x } [\\$x, lala()] # also identical\n","err":"","out":"[\\undef,$VAR1->[0]]"},{"err":"","out":"ERROR: Can't modify glob elem in scalar assignment at (eval 558) line 1, at EOF\n","code":"our %y; our $x = 5; *{y{x}} = *x; $y = 3; [ $x, \\%y ]; ### I saw this in some code I was reviewing, which I think was someone trying to alias a hash key to a variable, similar to *x = *y, but it doesn't seem t owork (maybe for an old Perl?)\n"},{"code":"@output=`df -h`; for my $line (@output){ print $line if $line =~ /procfs/ }\n","err":"","out":""},{"code":"[ overload::Overloaded( 'Regexp' ) ]\n","err":"","out":"[undef]"},{"out":"[undef]","err":"","code":"[ overload::Overloaded( v1.2.3 ) ]\n"},{"code":"[ overload::Overloaded( 'version' ) ]\n","err":"","out":"[\\*{'version::()'}]"},{"err":"","out":"Whatevs=HASH(0x5c55658)","code":"overload::StrVal bless {}, \"Whatevs\"\n"},{"err":"","out":"{1 => 2}","code":"%p = (1,2); @array = values %p; s/\\d// for @array; \\%p\n"},{"code":"%p = (1,2); s/\\d// for keys %p\n","out":"","err":""},{"code":"%p = (1,2); s/\\d// for keys %p; \\%p\n","out":"{1 => 2}","err":""},{"code":"%p = (1,2); s/\\d// for values %p; \\%p\n","err":"","out":"{1 => \"\"}"},{"err":"","out":"P1","code":"$P2::x = \"P2\"; package P1; our $x = \"P1\"; package P2; $x\n"},{"code":"$P2::x = \"P2\"; package P1; $x = \"P1\"; package P2; $x\n","out":"P2","err":""},{"err":"","out":"5","code":"pack \"a\", 0x32;\n"},{"code":"pack \"a\", 0x33;\n","err":"","out":"5"},{"code":"pack '(a)*', 123456 =~ /.(.)(?<=(.).)/g\n","err":"","out":"214365"},{"out":"3","err":"","code":"pack 'a', 32\n"},{"code":"pack 'A', 32\n","out":"3","err":""},{"out":"4","err":"","code":"pack 'a', 48\n"},{"code":"__PACKAGE__\n","err":"","out":"main"},{"code":"[ __PACKAGE__ ]\n","err":"","out":"[\"main\"]"},{"code":"package A; sub new { bless {}, ref $_[0] || $_[0]; } sub foo { [ $_[0], q{A:111} ]; } package B; our @ISA = qw(A); package C; our @ISA = qw(A); package D; our @ISA = qw(B C); package main; my $d = D->new; [ $d->foo, $d->B::foo, $d->C::foo, $d->A::foo ];\n","err":"","out":"[[bless( {}, 'D' ),\"A:111\"],[$VAR1->[0][0],\"A:111\"],[$VAR1->[0][0],\"A:111\"],[$VAR1->[0][0],\"A:111\"]]"},{"code":"package A; sub new { bless {}, ref $_[0] || $_[0]; } sub foo { [ $_[0], q{A:111} ]; } package B; our @ISA = qw(A); sub foo { [ $_[0], q{B:222} ]; } package C; our @ISA = qw(A); sub foo { [ $_[0], q{C:333} ]; } package D; our @ISA = qw(B C); package main; my $d = D->new; [ $d->foo, $d->B::foo, $d->C::foo, $d->A::foo ];\n","out":"[[bless( {}, 'D' ),\"B:222\"],[$VAR1->[0][0],\"B:222\"],[$VAR1->[0][0],\"C:333\"],[$VAR1->[0][0],\"A:111\"]]","err":""},{"err":"","out":"[\"A::x\",\"B::x\",\"C::x\"]","code":"package A; sub x { q{A::x}; } package B; sub x { q{B::x}; } package C; sub x { q{C::x}; } package main; [ map { $_->can( q{x} )->() } qw(A B C) ]; ### litewait\n"},{"out":"eh","err":"","code":"package Blah { sub foo { print \"eh\" } } Blah::foo()\n"},{"code":"package Blah { sub foo { print \"eh\" } } foo()\n","err":"","out":"ERROR: Undefined subroutine &main::foo called at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"{meow => *Cats::meow,mewl => *Cats::mewl}","err":"","code":"package Cats; our $meow; our $mewl = '>:('; package main; \\%Cats::\n"},{"code":"package Cats; our $meow; package main; \\%Cats::\n","out":"{meow => *Cats::meow}","err":""},{"out":"[bless( {}, 'C' ),1,2,3]","err":"","code":"package C; sub new { bless {}, ref $_[0] || $_[0] } package main; my $foo = sub { [ @_ ] }; my $c = C->new; $c->$foo( 1..3 );\n"},{"code":"package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; \\&foo;\n","err":"","out":"sub { \"DUMMY\" }"},{"err":"","out":"ERROR: Not a CODE reference at (eval 558) line 1, <STDIN> line 1.\n","code":"package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; $c->(\\&foo)->( 1..3 );\n"},{"code":"package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; $c->(\\&foo)( 1..3 );\n","out":"ERROR: Not a CODE reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"[bless( {}, 'C' ),1,2,3]","code":"package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; $c->${\\\\&foo}( 1..3 );\n"},{"code":"package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; $c->\\&foo( 1..3 );\n","out":"ERROR: syntax error at (eval 558) line 1, near \"->\\\"\n","err":""},{"code":"package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; my $name = \"foo\"; $c->$name( 1..3 );\n","err":"","out":"ERROR: Can't locate object method \"foo\" via package \"C\" at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; my $ref = \\&foo; $c->$ref( 1..3 );\n","out":"[bless( {}, 'C' ),1,2,3]","err":""},{"out":"[\"CODE(0x5fbf598)\",\"CODE(0x5fbf6e8)\",222,111]","err":"","code":"package C; sub new { bless {}, ref $_[0] || $_[0] } sub foo { 111 }; package main; my $o = \\&C::foo; { no warnings qw/redefine/; *C::foo = sub { 222 }; } my $c = C->new; [ qq{$o}, q{}.\\&C::foo, $c->foo, $c->$o ];\n"},{"out":"[\"CODE(0x4a68908)\",\"CODE(0x4727e90)\",222,222]","err":"","code":"package C; sub new { bless {}, ref $_[0] || $_[0] } sub foo { 111 }; package main; my $o = \\&C::foo; undef &C::foo; *C::foo = sub { 222 }; my $c = C->new; [ qq{$o}, q{}.\\&C::foo, $c->foo, $c->$o ];\n"},{"out":"","err":"","code":"{ package damnit; sub a { \"\" } } tr/// for a damnit\n"},{"code":"package dedicated::dedicated.fr {}\n","out":"ERROR: Invalid version format (0 before decimal required) at (eval 558) line 1, near \"; package dedicated::dedicated\"\nsyntax error at (eval 558) line 1, near \"package dedicated::dedicated.\"\n","err":""},{"out":"cats","err":"","code":"package Don; sub t { 'cats' } package main; Don't;\n"},{"out":"blah","err":"","code":"package DudeUseMoo { sub moot { bless {} } } $m = DudeUseMoo->moot; $m->{asdf} = 'blah'; $m->{asdf}\n"},{"code":"package DudeUseMoo { sub moot { bless {} } sub whurble { my $self=shift; $self->{asdf} } } $m = DudeUseMoo->moot; $m->{asdf} = 'blah'; $m->whurble\n","err":"","out":"blah"},{"err":"","out":"[15,15]","code":"{ package FF; sub TIESCALAR { my ($c, $v) = @_; bless \\$v, $c } sub FETCH { my $v = ${$_[0]}; ${$_[0]} = -${$_[0]}; $v } } sub frob :lvalue { my ($v) = @_; tie $v, \"FF\", $v; $v } sub List::Util::0sum {my ($a, $b)=(0,0); $a+=$_, $b-=$_ for @_; ($a, $b)}; [List::Util::0sum(map frob($_), 1,2,3,4,5)]\n"},{"err":"","out":"how long has that <-- with the version, worked?","code":"package Foo 1.0; 'how long has that <-- with the version, worked?'\n"},{"err":"","out":"1","code":"package foo; $bar = 1; package quux; print $main::foo::bar;\n"},{"err":"","out":"The method called was: foo::gooblegobble","code":"package foo; our $AUTOLOAD; sub AUTOLOAD {print \"The method called was: $AUTOLOAD\"}; package main; foo->gooblegobble();\n"},{"code":"package foo { our $bar = 'baz' } [\"blah $foo::bar\"]\n","err":"","out":"[\"blah baz\"]"},{"code":"package Foo; our $foo = 42; package main; my $z = 'Foo';  \\%{$x}::\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"}::\n\"\n"},{"err":"","out":"ERROR: Invalid version format (non-numeric data) at (eval 558) line 1, near \"; package Foo\"\nsyntax error at (eval 558) line 1, near \"package Foo:\"\nNo package name allowed for variable $Foo::var in \"our\" at (eval 558) line 1, near \"print $Foo::var\"\n","code":"package Foo: our $var;  package Splot; $var = 3; print $Foo::var;\n"},{"out":"[\"bar\",undef]","err":"","code":"{ package Foo; our $x = \"foo\"; package Bar; $x = \"bar\"; } [ $Foo::x, $Bar::x ]\n"},{"code":"package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );  $x->can($foo{bar})->()\n","err":"","out":"42"},{"code":"package foo; sub bar { 'ok' }; package main; use base 'foo'; [ main->SUPER::bar ];\n","out":"ERROR: Can't locate foo.pm:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/base.pm line 99, <STDIN> line 1.\n\t...propagated at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/base.pm line 108, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"package foo; sub bar { 'ok' }; package main; use base 'foo'; package other; [ main->SUPER::bar ];\n","out":"ERROR: Can't locate foo.pm:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/base.pm line 99, <STDIN> line 1.\n\t...propagated at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/base.pm line 108, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"[\"[1]\",\"[2]\",2]","code":"package foo; sub bar { our $baz; \"[\". ++$baz . \"]\" }; [ bar(), bar(), $baz ]\n"},{"code":"package foo; sub bar { our $baz; \"[\". ++$baz . \"]\" }; [ bar(), bar(), $foo::baz ]\n","out":"[\"[1]\",\"[2]\",2]","err":""},{"err":"","out":"[\"[1]\",\"[2]\",2]","code":"package foo; sub bar { our $baz; package fizzbuz; \"[\". ++$baz . \"]\" }; [ bar(), bar(), $baz ]\n"},{"err":"","out":"12","code":"package foo; sub bar { our $baz; print ++$baz }; [ bar(), bar(), $foo::baz ]\n"},{"err":"","out":"11212","code":"package foo; sub bar { our $baz; print ++$baz }; print bar(); print bar(); print $foo::baz;\n"},{"code":"package foo; sub bar { our $baz; return ++$baz }; [ bar(), bar(), $foo::baz ]\n","out":"[1,2,2]","err":""},{"out":"ERROR: Can't locate object method \"bar\" via package \"Foo\" at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"{ package Foo; sub DESTROY {} } sub bar; bar Foo;\n"},{"out":"ERROR: Can't locate object method \"bar\" via package \"Foo\" at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"{ package Foo; sub DESTROY {} } sub bar; bar Foo 1;\n"},{"code":"package Foo; sub d { return \"lala\" } package main; my $c = bless {}, 'Foo'; $c->d()\n","out":"lala","err":""},{"err":"","out":"[1]","code":"package foo; sub new {[1]} package bar; foo->new\n"},{"code":"package Foo; sub new { bless [], shift } package main; my $sub = sub { my $self = shift; \"$self\" }; my $obj = Foo->new; $obj->$sub  # lawrence_\n","err":"","out":"Foo=ARRAY(0x54dd558)"},{"code":"package Foo { sub new { bless {}, shift } sub bar { [@_] } } [Foo::bar(1,2,3), Foo->bar(1,2,3), Foo->new->bar(1,2,3)]\n","out":"[[1,2,3],[\"Foo\",1,2,3],[bless( {}, 'Foo' ),1,2,3]]","err":""},{"code":"package Foo { sub new { my $self = shift; bless {@_}, $self } } my $foo = Foo->new(key => 'value'); $foo->{key};\n","out":"value","err":""},{"code":"package Foo { sub new { my $self = shift; bless {@_}, $self } sub get_key { my $self = shift; return $self->{+shift} } } my $foo = Foo->new(key => 'value'); $foo->get_key('key'); # with an accessor method\n","err":"","out":"value"},{"out":"[\"A\",\"B\",\"C\"]","err":"","code":"package Foo; sub x { \\@ARGV; } package main; @ARGV = qw( A B C ); Foo::x;\n"},{"err":"","out":"[\"A\",\"B\",\"C\"]","code":"package Foo; sub x { \\@main::ARGV; } package main; @ARGV = qw( A B C ); Foo::x;\n"},{"err":"","out":"f","code":"package Foo; use overload 'bool' => sub { 0 }; sub new { bless {}, shift }; package main; Foo->new() ? 't' : 'f'\n"},{"code":"package Foo; use overload q{\"\"} => sub {42 }; package main; my $x = bless {}, 'Foo'; 'foo'->$x\n","err":"","out":"ERROR: Can't locate object method \"42\" via package \"foo\" (perhaps you forgot to load \"foo\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"[45,42]","err":"","code":"package Foo; use overload q{\"\"} => sub {42 }; package main; my $x = bless sub{ 45 }, 'Foo'; [ 'foo'->$x // 'z', \"$x\" //'z' ]\n"},{"code":"package Foo; use warnings; sub foo { undef()+0 }; package main; ${Foo::^WARNING_BITS}=0; Foo::foo();\n","err":"Use of uninitialized value in addition (+) at (eval 558) line 1, <STDIN> line 1.\n","out":"0"},{"code":"package Foo; use warnings; sub foo { undef()+0 }; package main; $Foo::{^WARNING_BITS}=0; Foo::foo();\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"{^\"\n"},{"err":"Use of uninitialized value in addition (+) at (eval 558) line 1, <STDIN> line 1.\n","out":"0","code":"package Foo; use warnings; sub foo { undef()+0 }; package main; no warnings; Foo::foo();\n"},{"err":"Use of uninitialized value in addition (+) at (eval 558) line 1, <STDIN> line 1.\n","out":"0","code":"package Foo; use warnings; sub foo { undef()+0 }; package main; { package Foo; no warnings; Foo::foo(); use warnings; }\n"},{"code":"package Foo; use warnings; sub foo { undef()+0 }; package main; $SIG{__WARN__}=sub{}; Foo::foo();\n","out":"0","err":""},{"out":"[\"foo\",\"bar\"]","err":"","code":"{ package Foo; $x = \"foo\"; package Bar; $x = \"bar\"; } [ $Foo::x, $Bar::x ]\n"},{"out":"[\"main\",\"__FUNCTION__\"]","err":"","code":"[ __PACKAGE__, __FUNCTION__ ]\n"},{"code":"package ImARegex; sub match { $_[1] =~ $_[0] ? 1 : 0 } package main; my $re = qr/hai/; bless $re, 'ImARegex'; $re->match('chair')\n","err":"","out":"1"},{"code":"package ImARegex; sub match { $_[1] =~ $_[0] ? 1 : 0 } package main; my $re = qr/hai/; bless $re, 'ImARegex'; $re->match('char')\n","err":"","out":"0"},{"err":"","out":"123","code":"package lala; my $x = 123; package lulu; $x\n"},{"err":"","out":"ceca","code":"package mac { sub ska { 'ca' } } \"ce${\\mac->ska}\"\n"},{"out":"ERROR: Can't locate object method \"method\" via package \"Package\" at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"Package->method\n"},{"err":"","out":"ERROR: Invalid SCALAR attribute: Delilah at (eval 558) line 1.\n","code":"package My; my My $my :Delilah;\n"},{"code":"package mypackage.pm; # although I'd guess perl should already be complaining about it\n","err":"","out":"ERROR: Invalid version format (0 before decimal required) at (eval 558) line 1, near \"; package mypackage\"\nsyntax error at (eval 558) line 1, near \"package mypackage.\"\n"},{"code":"{ package MyProject::whatever; sub doSomething { print 'test' } } my $class = 'whatever'; *{\"MyProject::${class}::doSomething\"}{CODE}() # but really don't do this\n","err":"","out":"test"},{"code":"package My::Thing { sub validate_rules { { cat => qr/meow/, cow => qr/moo/ } } } my $klass = \"My::Thing\"; $klass->validate_rules\n","err":"","out":"{cow => qr/moo/u,cat => qr/meow/u}"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"around speak\"\n","code":"package Object; sub speak { print \"Hello\" };    sub before { my ( $name, $code ) = @_; my $orig = Object->can( $name ); *$name = sub { $code->(); $orig->() }; }   around speak => sub { print \"But first...\" }     Object->speak\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"}     Object\"\n","err":"","code":"package Object; sub speak { print \"Hello\" };    sub before { my ( $name, $code ) = @_; my $orig = Object->can( $name ); *$name = sub { $code->(); $orig->() }; }   before speak => sub { print \"But first...\" }     Object->speak\n"},{"err":"","out":"But first...Hello","code":"package Object; sub speak { print \"Hello\" };    sub before { my ( $name, $code ) = @_; my $orig = Object->can( $name ); *$name = sub { $code->(); $orig->() }; }   before speak => sub { print \"But first...\" };     Object->speak\n"},{"out":"plup plop","err":"","code":"{ package Plip; use overload '\"\"' => sub { 'plop' } } $x = bless [], 'Plip'; \"plup $x\"\n"},{"code":"package P; sub new { my $class = @_ && ( $_[0]->isa( __PACKAGE__ ) || $_[0] eq __PACKAGE__ ) ? shift : __PACKAGE__; bless +{ @_ }, ( ref $class or $class ); } package main; P->new( foo => 123, bar => 456 );\n","err":"","out":"bless( {bar => 456,foo => 123}, 'P' )"},{"code":"package P; sub new { my $class = @_ && ( $_[0]->isa( __PACKAGE__ ) || $_[0] eq __PACKAGE__ ) ? shift : __PACKAGE__; bless +{ @_ }, ( ref $class or $class ); } package main; P::new( foo => 123, bar => 456 );\n","out":"bless( {bar => 456,foo => 123}, 'P' )","err":""},{"out":"bless( {123 => \"bar\",456 => undef}, 'P' )","err":"","code":"package P; sub new { my $class = @_ && ( $_[0]->isa( __PACKAGE__ ) || $_[0] eq __PACKAGE__ ) ? shift : __PACKAGE__; bless +{ @_ }, ( ref $class or $class ); } package main; P::new( P => 123, bar => 456 );\n"},{"err":"","out":"ERROR: Operation \"+\": no method found,\n\tleft argument in overloaded package P,\n\tright argument in overloaded package P at (eval 558) line 1, <STDIN> line 1.\n","code":"package P { use overload '\"\"' => sub { \"07\" }, '0+' => sub { \"01\" } } (bless {}, \"P\") + (bless {}, \"P\")\n"},{"err":"","out":"7","code":"package P { use overload '\"\"' => sub { \"07\" }, '0+' => sub { \"01\" } } oct(bless {}, 'P')\n"},{"err":"","out":"7","code":"package P { use overload '\"\"' => sub { \"07\" } } oct(bless {}, 'P')\n"},{"err":"","out":"[\"qqq\"]","code":"package q; sub qq {\"qqq\"};package main; *main::notq = \\&q::qq; [notq()]\n"},{"code":"package q; sub qq {\"qqq\"};package main; my $code = \\&q::qq; [$code->()]\n","err":"","out":"[\"qqq\"]"},{"out":"[\"overload\",\"loves\",\"u\"]","err":"","code":"{ package Regexp; use overload '\"\"' => sub { 'overload' }, fallback => 1 } my $x = bless qr/loves/, 'Regexp'; [ \"$x\", re::regexp_pattern($x) ] # then there are those who just like to watch the world burn\n"},{"code":"package Some::Class; sub class_method { my $class = shift; print \"in class method\" }  package main; Some::Class->class_method;\n","err":"","out":"in class method"},{"code":"package ã; sub foo {3} package main; ã::foo()\n","err":"","out":"ERROR: Unrecognized character \\xE3; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"package TerribleThing { sub new { bless {}, shift } sub DESTROY { undef $@ } } eval { die TerribleThing->new }; [$@]\n","out":"[bless( {}, 'TerribleThing' )]","err":""},{"err":"","out":"[\"1 at (eval 558) line 1, <STDIN> line 1.\\n\"]","code":"package TerribleThing { sub new { bless {}, shift } sub DESTROY { undef $@ } } eval { my $foo = TerribleThing->new; die 1 }; [$@]\n"},{"code":"package test; sub new { my $class = shift; my $props = { property => shift }; bless $props, $class; return $props; } 1; my $tester = new test(\"thisproperty\"); my $longstring = << 'EOF'; long long string\\n\\n$test->property\\n\\nEOF; print $tester;\n","out":"ERROR: Can't find string terminator \"EOF\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"package tm406; sub is_gandalf { 1 }; return \"TRUE\" if(tm406->is_gandalf());\n","err":"","out":"TRUE"},{"code":"{ package Try; use Function::Parameters qw(:strict); method stuff($class: $x) { $x + 1 } } Try->stuff\n","err":"","out":"ERROR: Too few arguments for method stuff (expected 2, got 1) at (eval 558) line 1.\n"},{"err":"","out":"<>\nmain\nok","code":"{ package X; sub DESTROY { print \"<>\\n\"; } } my $sub = sub { my $x = bless [], \"X\"; sub { \"ok\" } }->(); print \"main\\n\"; print $sub->()\n"},{"err":"","out":"bless( [[\"X::CLEAR\"],[\"X::STORE\",\"A\",\"B\"],[\"X::STORE\",\"C\",\"D\"]], 'X' )","code":"{ package X; sub TIEHASH { bless [], $_[0] } sub AUTOLOAD { my $r = shift; push @$r, [our $AUTOLOAD, @_] } } tie my %x, 'X'; %x = \"A\" .. \"D\"; tied %x\n"},{"out":"bless( [\"X::CLEAR\",\"X::STORE\",\"X::STORE\"], 'X' )","err":"","code":"{ package X; sub TIEHASH { bless [], $_[0] } sub AUTOLOAD { push @{$_[0]}, our $AUTOLOAD } } tie my %x, 'X'; %x = \"A\" .. \"D\"; tied %x\n"},{"out":"ERROR: Can't locate object method \"STORE\" via package \"X\" at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"{ package X; sub TIEHASH { bless [], $_[0] } sub CLEAR {} } tie my %x, 'X'; %x = (1, 2);\n"},{"code":"{ package X; sub TIEHASH { bless [], $_[0] } } tie my %x, 'X'; %x = ();\n","out":"ERROR: Can't locate object method \"CLEAR\" via package \"X\" at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"{ package X; sub TIEHASH { bless [], $_[0] } } tie my %x, 'X'; %x = (1, 2);\n","err":"","out":"ERROR: Can't locate object method \"CLEAR\" via package \"X\" at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"{ package X; sub TIESCALAR { bless [] } sub FETCH { state $x = 5; $x++ } } tie my $foo, X::; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say \"surprise!\" }\n","out":"surprise!\n","err":""},{"code":"{ package X; } tie my %x, 'X'; %x = ();\n","out":"ERROR: Can't locate object method \"TIEHASH\" via package \"X\" at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"surprise!\n","code":"{ package X; use overload fallback => 1, '0+' => sub { state $x = 5; $x++ }; } my $foo = bless [], X::; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say \"surprise!\" }\n"},{"code":"package X; use overload '\"\"' => sub { print \"string\"; \"x\" }, '.' => sub { print \"concat\"; \"x\" }; sprintf '%s', (bless {}, 'X');\n","err":"","out":"string"},{"err":"","out":"X","code":"package X; use overload '+' => sub { print \"X\"; }; package Y; use overload '+' => sub { print \"Y\" }; [ (bless {}, 'X') + (bless {}, 'Y') ]\n"},{"err":"","out":"Y","code":"package X; use overload '+' => sub { print \"X\"; }; package Y; use overload '+' => sub { print \"Y\" }; [ (bless {}, 'Y') + (bless {}, 'X') ]\n"},{"out":"[1,5]","err":"","code":"package XYZ; my @FIELDS = qw(one two); for my $field (@FIELDS) { *$field = sub { shift->{$field} }; } my $obj = bless {one => 1, two => 2, five => 5}, 'XYZ'; $FIELDS[1] = 'five'; [ map $obj->$_, qw(one two) ]\n"},{"code":"package XYZ; sub somesub { \"called with @_\" } [ XYZ::somesub('x', 'y'), XYZ->somesub('x', 'y') ] # they don't have to be class methods, you can use the package namespace without importing it into the current scope\n","out":"[\"called with x y\",\"called with XYZ x y\"]","err":""},{"err":"","out":"246135","code":"pack '(a)*', map +(/.(.)/g,/(.)./g), \"123456\"\n"},{"code":"pack '(a)*', sort {$|--} \"tuJsa nohterP er lhakcer,\" =~ /./g\n","out":"Just another Perl hacker,","err":""},{"err":"","out":"ÃÂwÃÂ°","code":"pack 'B*', ~0\n"},{"code":"pack \"b*\", \"00101010000101101001011011001110\"\n","out":"This","err":""},{"err":"","out":"Tith4cokei\n","code":"pack 'B*', '0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010'\n"},{"err":"","out":"\u0003","code":"pack \"b*\", 0b010101010;\n"},{"err":"","out":"This","code":"pack \"(b8)*\", \"00101010\",\"00010110\",10010110,11001110\n"},{"err":"","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","code":"pack \"(b8)*\", \"00101010\",\"00010110\",10010110,11001110'\n"},{"err":"","out":"\u0003\u0002is","code":"pack \"(b8)*\", 00101010,00010110,10010110,11001110\n"},{"out":"*","err":"","code":"pack('b8','01010100')\n"},{"code":"pack('B8','01010100')\n","err":"","out":"T"},{"code":"pack('(b8)*',\"0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010\" =~ /.{8}/g);\n","err":"","out":"*ÃÂ.\u0016,ÃÂÃÂ¶ÃÂÃÂ¦ÃÂP"},{"code":"pack \"B8\", \"11111110\"\n","out":"ÃÂ¾","err":""},{"code":"pack \"(b8)*\", split ' ', \"00101010 00010110 10010110 11001110\"\n","out":"This","err":""},{"out":"\u0000T\u0000h\u0000i\u0000s","err":"","code":"pack \"(b8)*\", split/(.{8})/, \"00101010000101101001011011001110\"\n"},{"code":"pack('b8'x11,\"0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010\");\n","err":"","out":"*\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"},{"code":"[ pack \"B*\", pack \"C*\", (1) x 7, 0 ]\n","err":"","out":"[\"\\376\"]"},{"err":"","out":"","code":"pack \"c\", 127;\n"},{"err":"","out":"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000ÃÂ¿ÃÂ¿ÃÂÃÂ¨\u0000\u0001","code":"pack \"C16\", (0)x10, (0xff)x2, split /[.]/, \"192.168.0.1\"\n"},{"code":"[ pack 'c', 48 ]\n","out":"[0]","err":""},{"out":"c","err":"","code":"pack \"c\", 99;\n"},{"out":"\u000f","err":"","code":"pack \"c\", 9999;\n"},{"code":"pack \"cc\", 9888, 9999;\n","err":"","out":"ÃÂ \u000f"},{"code":"pack \"cc\", 98, 99;\n","out":"bc","err":""},{"code":"[ pack '%c', map { $_ & 1 } unpack '%c', 'asdf1111' ]\n","err":"","out":"ERROR: '%' may not be used in pack at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"0113","err":"","code":"pack \"c*\", map { hex } \"30313133\" =~ /([[:xdigit:]]{2})/g\n"},{"err":"","out":"ÃÂPNG\r\n\u001a\n","code":"pack \"C*\", qw|137 80 78 71 13 10 26 10|\n"},{"code":"[ pack \"C*\", qw|137 80 78 71 13 10 26 10| ] # throw Data::Dumper at it\n","err":"","out":"[\"\\211PNG\\r\\n\\32\\n\"]"},{"code":"packege Whatever; # looks like an error to me, man\n","out":"ERROR: Can't locate object method \"packege\" via package \"Whatever\" (perhaps you forgot to load \"Whatever\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"\u0000\u0000ÃÂ?\u0000\u0000\u0000@\u0000\u0000@@","code":"pack \"f*\", 1,2,3;\n"},{"out":"[\"\\377\\377\\377\\377\\377\\377#\\300\"]","err":"","code":"[ pack 'F', (9/10-1)*100 ]\n"},{"err":"","out":"\u0000\u0000\u001c\u0000","code":"pack 'H*', '00001c00';\n"},{"out":"\u0012ÃÂ","err":"","code":"pack(\"H*\", 0x80 + 1)\n"},{"code":"pack '(H2)*', split /\\./, sprintf '%vx', 'one way to do it'\n","out":"one way to do it","err":""},{"code":"pack \"h\", \"41\"\n","out":"\u0004","err":""},{"code":"pack 'H*', '41'\n","err":"","out":"A"},{"code":"pack(\"H*\", 41)\n","err":"","out":"A"},{"err":"","out":"[\"A B C\",\"A B C\"]","code":"[ pack(\"H*\", 4120422043), pack(\"h*\", 1402240234) ]\n"},{"err":"","out":"[\"A B C\",\"4120422043\"]","code":"[ pack(\"H*\", 4120422043), unpack(\"H*\", \"A B C\") ]\n"},{"code":"pack \"H*\", \"42424242\"\n","out":"BBBB","err":""},{"code":"[ pack \"H*\", \"49440953\" ]\n","out":"[\"ID\\tS\"]","err":""},{"err":"","out":"667ÃÂµ'6","code":"pack 'h*', '6363735f7263'\n"},{"code":"pack 'H*', '6363735f7263'\n","out":"ccs_rc","err":""},{"out":"example hex data","err":"","code":"pack 'H*', \"6578616d706c65206865782064617461\"\n"},{"err":"","out":"[\"msandbox\"]","code":"[ pack \"H*\", \"6d73616e64626f78\" ]\n"},{"err":"","out":"paul","code":"pack \"H*\", '7061756c'\n"},{"code":"pack \"H*\", \"7468697320697320612074657374\"\n","out":"this is a test","err":""},{"out":"admin","err":"","code":"~pack \"H*\", '9e9b929691'\n"},{"code":"pack \"H*\", '9e9b929691'\n","out":"ÃÂÃÂÃÂÃÂÃÂ","err":""},{"code":"pack \"H*\", ${\\chr 24}\n","out":"ÃÂ","err":""},{"err":"","out":"AA","code":"pack 'H*', '\\x41\\x41' =~ tr/\\\\x//dr\n"},{"err":"","out":"[\"\\0\\0\\0*\"]","code":"[ pack 'N', 42 ]\n"},{"code":"pack 'N/a*', { cool => 'story, bro' }\n","out":"\u0000\u0000\u0000\u000fHASH(0x5123248)","err":""},{"out":"214365","err":"","code":"pack 'n*', unpack 'v*', \"123456\"\n"},{"err":"","out":"\\xff\\xff","code":"pack 'q', 7378717377743452252\n"},{"code":"pack \"s>\", 25\n","err":"","out":"\u0000\u0019"},{"code":"pack('V' . 0xfffffff)\n","out":"","err":"Out of memory!\npanic: fold_constants JMPENV_PUSH returned 2 at /home/ryan/bots/perlbuut/lib/eval.pl line 301, <STDIN> line 1.\n"},{"err":"Out of memory!\npanic: fold_constants JMPENV_PUSH returned 2 at /home/ryan/bots/perlbuut/lib/eval.pl line 301, <STDIN> line 1.\n","out":"","code":"pack('V' . 0xfffffff);\n"},{"out":"","err":"Out of memory!\n","code":"pack('V31337000');\n"},{"out":"[\"U\\0\\0\\0\"]","err":"","code":"[pack 'V', 85]\n"},{"code":"pack('V' . 99999990);\n","out":"","err":"Out of memory!\npanic: fold_constants JMPENV_PUSH returned 2 at /home/ryan/bots/perlbuut/lib/eval.pl line 301, <STDIN> line 1.\n"},{"code":"[pack \"(Z*)*\", qw(foo bar baz)]\n","err":"","out":"[\"foo\\0bar\\0baz\\0\"]"},{"err":"","out":"abcd","code":"$page_content=\"http://www.liveleak.com/view?i=abcd\"; if ( $page_content =~ /http\\:\\/\\/www\\.liveleak\\.com\\/view\\?i\\=(\\w+)/ ){ $ids = $1 }; print $ids;\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":"","code":"$page_content='http://www.liveleak.com/view?i=abcd'; if ( $page_content =~ m!http://www\\.liveleak\\.com/view\\?i=(\\w{14})!g; ){ $ids = $1 }; print $ids;\n"},{"code":"$page_content='http://www.liveleak.com/view?i=abcd'; my @ids = $page_content =~ m!http://www\\.liveleak\\.com/view\\?i=(\\w{14})!g; print @ids;\n","out":"1","err":""},{"err":"","out":"abcd","code":"$page_content=\"http://www.liveleak.com/view?i=abcd\"; $page_content =~ s/http\\:\\/\\/www\\.liveleak\\.com\\/view\\?i\\=(\\w+)/$1/g; print $page_content;\n"},{"out":"c77_1406577312","err":"","code":"$page_content=\"http://www.liveleak.com/view?i=c77_1406577312\"; $page_content =~ s/http\\:\\/\\/www\\.liveleak\\.com\\/view\\?i\\=(\\w+)/$1/g; print $page_content;\n"},{"err":"","out":"qwerty","code":"$page_content=\"http://www.liveleak.com/view?i=qwerty\"; if ( $page_content =~ /http\\:\\/\\/www\\.liveleak\\.com\\/view\\?i\\=(\\w+)/ ){ push (@ids,$1); }; print @ids;\n"},{"out":"match","err":"","code":"\"/page/save/2202440;294ac50e,315fb991\" =~ m{page/} ? 'match' : 'nope'\n"},{"code":"\"/page/show/2202440\" =~ m{page/} ? 'match' : 'nope'\n","out":"match","err":""},{"code":"\"/page/show/2202440\" =~ {page/} ? 'match' : 'nope'\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":""},{"code":"[ \"parachute! ahh I'm falling!\" =~ s/(?<=chute).*//r ]\n","out":"[\"parachute\"]","err":""},{"err":"","out":"[\"parachute\"]","code":"[ \"parachute!\" =~ s/(?<=chute).*//r ]\n"},{"out":"[\"parachute\"]","err":"","code":"[ \"parachute\" =~ s/(?<=chute).*//r ]\n"},{"code":"parse backwards\n","out":"ERROR: Can't locate object method \"parse\" via package \"backwards\" (perhaps you forgot to load \"backwards\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"\" part isn't necessary in your actual code; it's just for interacting with the IRC bot\n","err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"$pattern = \"oo\"; return [ \"foo\" =~ /$pattern/, \"bar\" =~ /$pattern/ ];\n","err":"","out":"[1]"},{"code":"$pattern = \"oo\"; return [ \"foo\" =~ /$re/, \"bar\" =~ /$re/ ]; # voila!\n","err":"","out":"[1,1]"},{"code":"#!perl\n","out":"","err":""},{"out":"2","err":"","code":"\"Perl\"^2\n"},{"err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","code":"perl -e \"my @res = map { substr($_, 0, length($_)-1) if (-f substr($_, 0, length($_)-1) } qw(dupes.txt allfiles.bak.txt hahaha.setnhue); print join(' ', @res) . \"\\n\";\n"},{"code":"`perl -e 'print \"$]\"'`\n","err":"","out":""},{"code":"perl -e 'print \"$]\"'\n","out":"ERROR: syntax error at (eval 558) line 1, near \"perl -e \"\n","err":""},{"code":"perl -E 'say for @INC'\n","out":"ERROR: syntax error at (eval 558) line 1, near \"E 'say for @INC'\"\n","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"perlev ' [ unpack q{N}, pack q{H8}, q{6060FF} ] '\"\n","code":"perlev ' [ unpack q{N}, pack q{H8}, q{6060FF} ] ' # alanjf\n"},{"code":"[ PerlIO::get_layers(*STDIN) ]\n","err":"","out":"[\"unix\",\"perlio\"]"},{"out":"ERROR: Can't find string terminator \"\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"perl -p -e \"s/\\/\\/a\\[contains\\(text\\(\\),'(\\w+)'\\)\\]/$1/g\" <<< //a[contains(text(),'Korel&nbsp;&nbsp;GÃ¶ymen')]\n"},{"code":"`perl -v`\n","out":"","err":""},{"code":"perl -v\n","err":"","out":"0"},{"out":"PermitRootLogin no way man","err":"","code":"\"#########PermitRootLogin no way man\" =~ s/#*(PermitRootLogin\\sno)/$1/r\n"},{"code":"'phd defense' gt 'php defense'\n","err":"","out":""},{"code":"@phone =~ /^0$/\n","err":"","out":"1"},{"code":"@phone = 0; @phone =~ /^1$/\n","err":"","out":"1"},{"err":"","out":"1","code":"@phone = 1; @phone =~ /^1$/\n"},{"err":"","out":"","code":"\"pobox\" eq \"pÐ¾box\"\n"},{"err":"","out":"","code":"pop @{politics}\n"},{"out":"-1.84515451462286","err":"","code":"POSIX::fmod(-10, exp 1)\n"},{"out":"[2,6]","err":"","code":"@pos = (); push @pos, @- while 'hangman' =~ /n/g; \\@pos\n"},{"err":"","out":"pOST hoc ErgO ProptER HoC","code":"$_='post hoc ergo propter hoc'; s/./rand(3)>1?lc($&):uc($&)/egr;\n"},{"out":"[2,6]","err":"","code":"@pos = (); $word = 'hangman'; $guess = 'n'; push @pos, @- while $word =~ /$guess/g; \\@pos  # vaskozl\n"},{"err":"","out":"ERROR: exists argument is not a HASH or ARRAY element or a subroutine at (eval 558) line 1, <STDIN> line 1.\n","code":"$predicate = 1; $true = {foo => 2}; $false = {}; [exists($predicate ? $true->{foo} : $false->{foo}) ? \"Y\" : \"N\"]\n"},{"err":"","out":"ERROR: Search pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n","code":"$price = '16.60'; ($dollar,$cents)=$price=~/(\\d+)\\.(\\d+); $dollar++ if $cents > 0; print $dollar\n"},{"code":"$price = '16.60'; ($dollar,$cents)=$price=~/(\\d+)\\.(\\d+)/; $dollar++ if $cents > 0; print $dollar\n","err":"","out":"17"},{"code":"print\n","err":"","out":"1"},{"code":"\\&print\n","err":"","out":"sub { \"DUMMY\" }"},{"code":"print ''\n","err":"","out":"1"},{"code":"print '$]'\n","err":"","out":"$]"},{"code":"print '\\\\'\n","err":"","out":"\\"},{"code":"print \"`*`\";\n","out":"`*`","err":""},{"err":"","out":"-","code":"print \"-\"\n"},{"code":"print \"\"\n","err":"","out":"1"},{"err":"","out":"[print \"[@_]\";]","code":"print \"[@_]\";\n"},{"out":"1","err":"","code":"print \"$,\"\n"},{"out":"\u001c","err":"","code":"print \"$;\"\n"},{"err":"","out":"5.022001","code":"print \"$]\"\n"},{"err":"","out":"ÃÂ¢ÃÂÃÂ","code":"print \"â\"\n"},{"code":"print @_;\n","out":"print @_;","err":""},{"code":"print $/\n","out":"\n","err":""},{"code":"print $]\n","err":"","out":"5.022001"},{"code":"print $];\n","err":"","out":"5.022001"},{"err":"","out":"1","code":"print $@\n"},{"out":"10347","err":"","code":"print $$\n"},{"err":"","out":"1","code":"print;\n"},{"code":"print \"0\"\n","out":"01","err":""},{"code":"print \"01\"\n","err":"","out":"01"},{"code":"print(0.3 + 0.3 + 0.3 - 0.9);\n","out":"-1.11022302462516e-16","err":""},{"code":"print \"0\"; '' # and it's gone\n","out":"0","err":""},{"err":"","out":"09","code":"print '0' x 1 . '9'\n"},{"code":"print 1\n","out":"1","err":""},{"code":"print 1;\n","out":"1","err":""},{"code":"print 1 + 1;\n","err":"","out":"2"},{"code":"print(1+2)/2\n","out":"3","err":""},{"code":"print 123\n","out":"123","err":""},{"code":"print (.1 + .2 == .3)\n","out":"1","err":""},{"out":"1","err":"","code":"print \" 1234567 \" =~ /[0-9]{7} /;\n"},{"code":"print \" 12345678 \" =~ / [0-9]{7} /;\n","err":"","out":"1"},{"err":"","out":"1","code":"print \" 12345678 \" =~ /[0-9]{7} /;\n"},{"out":"51.6666666666667","err":"","code":"print 155.0 / 3.0\n"},{"err":"","out":"0.001001001001001","code":"print (1/999)*999\n"},{"code":"[print 2]\n","out":"2","err":""},{"code":"print \"2\"\n","out":"2","err":""},{"code":"print \"2\" && print @+\n","err":"","out":"221"},{"out":"Too many open files1","err":"","code":"print \"2\" && print $!\n"},{"out":"01","err":"","code":"print \"2\" && print $?\n"},{"err":"","out":"3","code":"print (3+undef)/2\n"},{"code":"print4\n","out":"print4","err":""},{"err":"","out":"12","code":"print (7 + 5) * 13, \"\\n\";\n"},{"code":"(\\&print)->('a')\n","out":"ERROR: Undefined subroutine &main::print called at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"print \"\\a\"\n","err":"","out":"\u0007"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"}->\"\n","err":"","code":"print {@a}->{a}\n"},{"out":"1","err":"","code":"print +{@a}->{a}\n"},{"out":"a!bc","err":"","code":"$, = '!'; print 'a', 'b'.'c';\n"},{"code":"$, = '!'; print 'a'.'b','c';\n","out":"ab!c","err":""},{"err":"","out":"ac","code":"$, = '!'; print 'a'.('b','c');\n"},{"err":"","out":"abc","code":"print 'a', 'b'.'c';\n"},{"code":"print \"abc$^Hdef\"\n","out":"abc256def","err":""},{"out":"aERROR: an error at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"print \"a\"; die \"an error\"\n"},{"code":"print 'alive'; eval q![ 'a' x 1e12 ]!\n","err":"Out of memory!\npanic: fold_constants JMPENV_PUSH returned 2 at /home/ryan/bots/perlbuut/lib/eval.pl line 301, <STDIN> line 1.\n","out":""},{"err":"","out":"[[ \"pos\" ], /\"(/d+)\"/]\nERROR: Unmatched ( in regex; marked by <-- HERE in m/\"( <-- HERE / at (eval 559) line 1, <STDIN> line 1.\n","code":"print $a=\"[[ \\\"pos\\\" ], /\\\"(/d+)\\\"/]\", \"\\n\"; my $result = eval($a) or die $@;\n"},{"code":"print $a=\"[[ \\\"pos\\\" ], /\\\"(/d+)\\\"/]\", \"\\n\"; print ref(eval($a)),\"\\n\";\n","err":"","out":"[[ \"pos\" ], /\"(/d+)\"/]\n\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","code":"print \"as a brit i prefer\" . ( rand() < 0.1 ? \"spicey foods\" : \"boiled cabbage\"\n"},{"code":"print \"as a brit i prefer\" . ( rand() < 0.1 ? \"spicey foods\" : \"boiled cabbage\" )\n","out":"as a brit i preferboiled cabbage","err":""},{"err":"","out":"1","code":"print \"a\" x \"b\";\n"},{"code":"print \"bottle\\n\" x 2;\n","err":"","out":"bottle\nbottle\n"},{"code":"print \"bottle\" x 2;\n","out":"bottlebottle","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \")[\"\n","err":"","code":"print (caller(0))[8]\n"},{"code":"print `cat /dev/urandom`\n","err":"","out":"1"},{"err":"","out":"cats","code":"print 'cats'\n"},{"code":"print \"cats\"\n","out":"cats","err":""},{"code":"print \"${chr(24)}\"\n","out":"/home/ryan/perl5/perlbrew/perls/perl-5.22.1/bin/perl","err":""},{"code":"print chr 8305\n","err":"","out":"ÃÂ¢ÃÂÃÂ±"},{"out":"\n","err":"","code":"print chr length q q continue q\n"},{"code":"print chr ord for qw q hasdfsadfsadf aasdfdsafasdf chasdfadsfadsf kasdfadfasdf easdfsfdsdf refwefsadfsadfa q\n","out":"hacker","err":""},{"code":"print $code\n","out":"use 5.022001; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; print $code","err":""},{"out":"Considered harmful by some, for this reason.","err":"","code":"{ print 'Considered'; last; print \"fun\"; } print ' harmful by some, for this reason.'\n"},{"err":"","out":"1","code":"print crypt('Gil*321T','$');\n"},{"code":"print cwd();\n","out":"ERROR: Undefined subroutine &main::cwd called at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"Debug\n","err":"","code":"print(\"Debug\\n\"), return 1 if (1);\n"},{"code":"print do { if (0) { 1 } else { 2 } }\n","err":"","out":"2"},{"code":"print do { if (1) { 1 } else { 2 } }\n","err":"","out":"1"},{"code":"print Dumper @_\n","out":"$VAR1 = 'print Dumper @_';\n","err":""},{"out":"1","err":"","code":"print `echo 1`\n"},{"err":"","out":"Enter number 1: ","code":"print \"Enter number 1: \", $a1 = <STDIN>;\n"},{"code":"print eval +{print \"2\"}\n","out":"2","err":""},{"out":"01","err":"","code":"print exec(\"dir\")\n"},{"out":"01","err":"","code":"print exec(\"ls\")\n"},{"err":"","out":"0777\n","code":"printf \"%04o\\n\",0777;\n"},{"out":"7777\n","err":"","code":"printf \"%04o\\n\",07777;\n"},{"out":"ERROR: Can't call method \"mode\" on an undefined value at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"printf \"%04o\\n\",$mode->mode & 07777;\n"},{"code":"printf \"%08b\\n%08b\\n%08b\\n\", 0xff, 0x7f, 0xff & 0x7f\n","err":"","out":"11111111\n01111111\n01111111\n"},{"out":" 01100001 ","err":"","code":"printf \" %08b \", ord \"a\"\n"},{"out":"b a","err":"","code":"printf '%2$-2s%1$s', qw(a b) # you're trying to write a script to do this, or is there more to it?\n"},{"err":"","out":"%-2$p","code":"printf '%-2$p', sub {}\n"},{"err":"","out":"3.1415926535897931159979634685441851615906\n","code":"printf \"%.40f\\n\", 3.141592653589793238462643383279502884;\n"},{"code":"printf \"%.6f\", 6.437370834e-01\n","err":"","out":"0.643737"},{"code":"printf \"%.6f\", 6.437370834e+01\n","err":"","out":"64.373708"},{"out":"0.000006","err":"","code":"printf \"%.6f\", 6.437370834e-06\n"},{"code":"printf \"%.6f\", 6.437370834e+06\n","err":"","out":"6437370.834000"},{"out":"100000","err":"","code":"printf '%b', ord ' '\n"},{"out":"1","err":"","code":"print fc(\"Å\") cmp fc(\"z\")\n"},{"err":"","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after /; printf(<-- HERE near column 98 at (eval 558) line 1, <STDIN> line 1.\n","code":"printf(â%dâ, 1.9)\n"},{"out":"-9%","err":"","code":"printf('%d%%', (45/50-1)*100)\n"},{"err":"","out":"-9%","code":"printf('%d%%', (9/10-1)*100)\n"},{"code":"print \"floo\"\n","out":"floo","err":""},{"code":"\\&print->(\"foo\")\n","out":"ERROR: Undefined subroutine &main::print called at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"print \"foo\"\n","out":"foo","err":""},{"code":"print \"foo\" if (\"/page/show/1234\" =~ m{page/});\n","err":"","out":"foo"},{"code":"print foo(); my $x = 213; sub foo { $x }\n","out":"213","err":""},{"out":"1234","err":"","code":"print for 1..4\n"},{"code":"print for aaaa.zzzz\n","out":"aaaazzzz","err":""},{"out":"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ","err":"","code":"print for (a..z, 0..9, A..Z);\n"},{"err":"","out":"12345","code":"print foreach 1..5\n"},{"err":"","out":"","code":"print $_, $/ for @INC\n"},{"err":"","out":"","code":"print for @INC\n"},{"err":"","out":"111,99,","code":"print \"$_,\" for sort ( 99, 111 )\n"},{"err":"","out":"<<thi>><<s i>><<s a>><< te>>","code":"print \"<<$_>>\" for 'this is a test' =~ /.../g;  # hehehe\n"},{"code":"print/..(..?)/ for[],{},$\"x3,\\&f,\\0\n","err":"","out":"RASH DEAL"},{"err":"","out":"51.66666667","code":"printf q{%.8f}, 155.0 / 3.0\n"},{"err":"","out":"51.666667.8","code":"printf q{%f.8}, 155.0 / 3.0\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","code":"printf ?say\\n?\n"},{"err":"","out":"I'm so unruly bot ...\n","code":"printf(\"%s\\n\", \"I'm so unruly bot ...\");\n"},{"out":"01101000 01100101 01101100 01101100 01101111","err":"","code":"printf \"%*v08b\", \" \", \"hello\"\n"},{"err":"","out":"9829 ÃÂ¢ÃÂÃÂ¥","code":"printf \"%vd %s\", chr hex \"2665\", chr hex \"2665\"\n"},{"err":"","out":"195.188","code":"printf \"%vd\", \"Ã¼\"\n"},{"code":"printf '%x' ord ':'\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"'%x' ord\"\n"},{"code":"printf '%x', ord ':'\n","err":"","out":"3a"},{"code":"print 'Good night';\n","err":"","out":"Good night"},{"code":"print \"hello\"\n","err":"","out":"hello"},{"err":"","out":"Hello","code":"print \"Hello\";\n"},{"out":"hello","err":"","code":"print \"hello\"; 2+2\n"},{"code":"print \"hello\\n\";\n","err":"","out":"hello\n"},{"out":"hello\nworld","err":"","code":"print \"hello\\nworld\"\n"},{"err":"","out":"hello world","code":"@{ print \"hello\"; print \" world\"; [] }\n"},{"out":"hello world","err":"","code":"print \"hello world\";\n"},{"code":"print \"Hello world!\";\n","out":"Hello world!","err":""},{"code":"print \"Hello, world!\";\n","out":"Hello, world!","err":""},{"err":"","out":"hello world\n","code":"print \"hello world\\n\"\n"},{"out":"hi","err":"","code":"print \"hi\";\n"},{"out":"hi\tsir\n","err":"","code":"print \"hi\\tsir\\n\"\n"},{"code":"print \"hi\".(\" \" x 4).\"there\\n\";\n","err":"","out":"hi    there\n"},{"err":"","out":"i bought a ","code":"print \"i bought a \"; rand()<0.5 ? 'coke' : 'root beer'\n"},{"code":"print \"i bougth a \" . (rand()<0.5 ? \"coke\" : \"root beer\" )\n","out":"i bougth a root beer","err":""},{"code":"print \"I'm a Perl \", 5 + !!\"0\", \" program.\"\n","out":"I'm a Perl 5 program.","err":""},{"out":"1","err":"","code":"print @INC;\n"},{"err":"","out":"is about to flood the channel","code":"print \"is about to flood the channel\"\n"},{"code":"print join \",\",  grep { $_ % 2 == 0 } (1..50)\n","err":"","out":"2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50"},{"err":"","out":"1","code":"print join(\", \", @INC);\n"},{"out":"abc","err":"","code":"print join('',map {chr $_} (97, 98, 99))\n"},{"code":"print join ('x', \"a\",\"b\",\"c\",\"d\");\n","err":"","out":"axbxcxd"},{"code":"print join x => a => b => c => d =>\n","err":"","out":"axbxcxd"},{"code":"print \"Å\" cmp \"z\"\n","err":"","out":"1"},{"err":"","out":"1","code":"print `ls`;\n"},{"err":"","out":"1","code":"print `ls /tmp`\n"},{"code":"print map { \"(\".$_.\")\" } \"a:1 b:2 a:3 b:4 \" =~ m/^((a:\\d+ )(b:\\d+ ))*/\n","out":"(a:3 b:4 )(a:3 )(b:4 )","err":""},{"code":" print map (lc,('ABC','DEF','GHI'));\n","err":"","out":"abcdefghi"},{"out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after  map (lc,(<-- HERE near column 106 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":" print map (lc,(âABCâ,âDEFâ,âGHIâ));\n"},{"code":" print map { lc } qw/ ABC DEF GHI /;\n","err":"","out":"abcdefghi"},{"err":"","out":"0123456789","code":"print map { $x++ } 1..10\n"},{"code":"[ print \"Miesco\", print \"Miesco\" ]\n","err":"","out":"MiescoMiesco1"},{"code":"print \"Miesco\", print \"Miesco\"\n","out":"MiescoMiesco1","err":""},{"err":"","out":"MiescoMiesco","code":"print(\"Miesco\"), print(\"Miesco\")\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"@arr[\"\n","code":"print my @arr[2];\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"$arr[\"\n","err":"","code":"print my $arr[2];\n"},{"err":"","out":"\n","code":"print \"\\n\"\n"},{"err":"","out":"thi\ns i\ns a\n te\n","code":"print \"$_\\n\" for 'this is a test' =~ /.../g;  # hehehe\n"},{"code":"print \"No output.\"\n","err":"","out":"No output."},{"out":"amigaos","err":"","code":"print \"$^O\";\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":"","code":"print oct(\"420)\"\n"},{"code":"print(\"oh yes, entire nothings\")\n","err":"","out":"oh yes, entire nothings"},{"err":"","out":"ok","code":"print \"ok\" if \"Ã¥\" =~ /[[:alpha:]_]/\n"},{"out":"","err":"","code":"print \"ok\" if \"Ã¥\" =~ /[[:alpha:]_]/a\n"},{"err":"","out":"ok","code":"print \"ok\" if \"_\" =~ /[[:alpha:]_]/\n"},{"code":"print \"ok\" if \"_\" =~ /[[:alpha:]]/\n","out":"","err":""},{"out":"194","err":"","code":"print ord \"Â¢\"\n"},{"err":"","out":"97 208","code":"print ord('a'), \" \", ord('Ð°');\n"},{"err":"","out":"97208","code":"print ord('a'), ord('Ð°');\n"},{"err":"","out":"15","code":"print ord pack \"cc\", 9999\n"},{"err":"","out":"194","code":"print ord \"Â \"\n"},{"code":"print \"Perl is easy\";\n","err":"","out":"Perl is easy"},{"out":"foobar","err":"","code":"print ${ print 'foo'; \\'bar' };\n"},{"out":"1111","err":"","code":"print print print print print\n"},{"out":"PRIVMSG ##microsoft hello","err":"","code":"print \"PRIVMSG ##microsoft hello\";\n"},{"err":"","out":"$@","code":"print prototype('CORE::sprintf')\n"},{"code":"print q/foo/\n","out":"foo","err":""},{"err":"","out":"0","code":"print q{foo} while 0;\n"},{"err":"","out":"[\\/:\\\\\\/][/:\\/]","code":"print '[', $_, ':', quotemeta($_), ']' for q{\\/}, qq{\\/};\n"},{"code":"print quotemeta 'test@example.com'\n","err":"","out":"test\\@example\\.com"},{"code":"print { (rand() < .5) ? STDOUT : STDERR } 'foo'\n","err":"","out":"foo1"},{"code":"print { rand < .5 ? STDOUT : STDERR } 'foo'\n","out":"ERROR: Unterminated <> operator at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"print\"RASH DEAL\"\n","out":"RASH DEAL","err":""},{"err":"","out":"7c86467b","code":"print reverse (\"7c86467b\");\n"},{"code":"print ( reverse sort ( 1..9 ));\n","err":"","out":"987654321"},{"code":"print round(0.5)\n","out":"ERROR: Undefined subroutine &main::round called at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"print s/..(..).*/$1/r for[],{},$\",\\&f,\\0\n","out":"RASH DEAL","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"(...\"\n","err":"","code":"print s/..(..).*/$1/r for(...there you go\n"},{"err":"","out":"1","code":"print scalar \"321\" =~ /\\d+/;\n"},{"out":"1","err":"","code":"print scalar (a..b)\n"},{"code":"print scalar a..b\n","out":"ab","err":""},{"code":"print scalar \"abc\" =~ /\\d+/;\n","err":"","out":"1"},{"code":"print scalar reverse \"my string\"\n","err":"","out":"gnirts ym"},{"err":"","out":"1460499709","code":"print scalar $^T\n"},{"out":"1","err":"","code":"print $self\n"},{"out":"123456789","err":"","code":"print ( sort ( 1..9 ));\n"},{"err":"","out":"100101102979899","code":"print sort 97..102\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"\"$_,\" sort \"\n","code":"print \"$_,\" sort ( 99, 111 );\n"},{"err":"","out":"11199","code":"print sort ( 99, 111 );\n"},{"out":"96011","err":"","code":"print sort ( printf(\"%d\", rand(100)), printf(\"%d\", rand()) )\n"},{"code":"print sort qw( 1 5 2 3 7 4 6 9 8 0);\n","err":"","out":"0123456789"},{"code":"print sort { (rand()) <=> (rand()) }\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n"},{"err":"","out":"abcd","code":"print sort { (rand()) <=> (rand()) } qw(a b c d);\n"},{"code":"print sort { rand <=> rand } qw(a b c d);\n","out":"ERROR: syntax error at (eval 558) line 1, near \"<=> rand\"\n","err":""},{"err":"","out":"adcb","code":"print sort { rand() <=> rand } qw(a b c d);\n"},{"err":"","out":"Just another Perl hacker,","code":"print sort {$|--} \"tuJsa nohterP er lhakcer,\" =~ /./g\n"},{"out":"Hello CORIN!","err":"","code":"print sprintf(\"Hello %s!\", uc \"Corin\");\n"},{"code":"print sqrt length \"zomg\"\n","out":"2","err":""},{"code":"print {STDOUT} 1,2;\n","err":"","out":"121"},{"code":"print STDOUT chr 8305\n","err":"","out":"Ã¢ÂÂ±1"},{"err":"","out":"1","code":"print $t\n"},{"err":"","out":"1460499913","code":"print $^T\n"},{"out":"","err":"","code":"print test\n"},{"err":"","out":"test","code":"print 'test'\n"},{"err":"","out":"test","code":"print \"test\"\n"},{"out":"1","err":"","code":"print $this_variable_does_not_exist;\n"},{"err":"","out":"","code":"print \"Time for coffee\" if $!{ENOCAFFIENE}\n"},{"out":"","err":"","code":"print true\n"},{"err":"","out":"HELLO CORIN!","code":"print uc sprintf(\"Hello %s!\", \"Corin\");\n"},{"out":"[\"print\",undef]","err":"","code":"[ print => undef ]\n"},{"err":"","out":"undef1","code":"print undef => 1\n"},{"err":"","out":"01","code":"print ${^UNICODE}\n"},{"code":"print unpack(\"b8\", \"a\")\n","err":"","out":"10000110"},{"out":"v5.22.1","err":"","code":"print $^V\n"},{"err":"","out":"ÃÂ°ÃÂÃÂÃÂ©","code":"print v128169\n"},{"code":"print v3232.95.3232\n","err":"","out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ "},{"err":"","out":"ÃÂ¢ÃÂÃÂ¡","code":"print v9825\n"},{"err":"","out":"$variable","code":"print '$variable'\n"},{"out":"very well","err":"","code":"print \"very well\"\n"},{"out":"test tesT teSt teST tEst tEsT tESt tEST Test TesT TeSt TeST TEst TEsT TESt TEST ","err":"","code":"print \"$_ \" while $_ = glob 'test' =~ s/([a-z])/{\\l$1,\\u$1}/gir  # what was wrong with this ?\n"},{"out":"ÃÂÃÂ¢","err":"","code":"print \"\\x{0622}\"\n"},{"err":"","out":"55555","code":"print $x=1, $x=2, $x=3, $x=4, $x=5;\n"},{"code":"print '-' x 35 . \"\\n\";\n","err":"","out":"-----------------------------------\n"},{"code":"print '-' x 35.\"\\n\";\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"35.\"\\n\"\"\n"},{"err":"","out":"ÃÂ¯ÃÂ¿ÃÂ¿","code":"print \"\\x{ffff}\"\n"},{"out":"ÃÂ¿ff","err":"","code":"print \"\\xffff\"\n"},{"err":"","out":"SCALAR(0x4b38288)","code":"print \\xffff\n"},{"err":"","out":"xxx","code":"print \"x\" for qw(1 2 3);\n"},{"code":"print \"Yes we do\";\n","err":"","out":"Yes we do"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"product 1\"\n","code":"product 1..10\n"},{"code":"prototype \\&CORE::bless\n","err":"","out":"$;$"},{"out":"yes","err":"","code":"prototype 'CORE::bless' ? 'yes' : 'no'\n"},{"code":"prototype \"CORE::glob\"\n","err":"","out":"_;"},{"out":"$@","err":"","code":"prototype \\&CORE::join\n"},{"code":"prototype \\&CORE::lc\n","out":"_","err":""},{"code":"prototype 'CORE::open'\n","out":"*;$@","err":""},{"err":"","out":"*;$@","code":"prototype \"CORE::open\"\n"},{"out":"$@","err":"","code":"prototype \"CORE::pack\"\n"},{"code":"prototype \\&CORE::print\n","out":"","err":""},{"err":"","out":"_","code":"prototype \\&CORE::prototype\n"},{"out":"+@","err":"","code":"prototype 'CORE::push'\n"},{"code":"prototype \"CORE::push\"\n","err":"","out":"+@"},{"out":"+@","err":"","code":"prototype(\\&CORE::push)\n"},{"code":"prototype 'CORE::ref'\n","err":"","out":"_"},{"code":"prototype \\&CORE::ref\n","err":"","out":"_"},{"err":"","out":";$","code":"prototype \\&CORE::sleep\n"},{"out":"","err":"","code":"prototype 'CORE::sort'\n"},{"err":"","out":"+;$$@","code":"prototype 'CORE::splice'\n"},{"err":"","out":"","code":"prototype(\\&CORE::split)\n"},{"code":"prototype \\&CORE::substr\n","out":"$$;$$","err":""},{"err":"","out":";\\[$@%&*]","code":"prototype 'CORE::undef'\n"},{"code":"prototype \"CORE::warn\"\n","out":"@","err":""},{"err":"","out":";*","code":"prototype \"CORE::write\"\n"},{"err":"","out":"ERROR: Invalid CODE attribute: proto($$) at (eval 558) line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"prototype sub :proto($$) {}\n"},{"code":"provides scalar context\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"provides scalar\"\n"},{"code":"prtin 1\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"prtin 1\"\n"},{"err":"","out":"J","code":"@P=split//,\".URRUU\\c8R\";@d=split//,\"\\nrekcah xinU / lreP rehtona tsuJ\";sub p{ @p{\"r$p\",\"u$p\"}=(P,P);pipe\"r$p\",\"u$p\";++$p;($q*=2)+=$f=!fork;map{$P=$P[$f^ord ($p{$_})&6];$p{$_}=/ ^$P/ix?$P:close$_}keys%p}p;p;p;p;p;map{$p{$_}=~/^[P.]/&& close$_}%p;wait until$?;map{/^r/&&<$_>}%p;$_=$d[$q];sleep rand(2)if/\\S/;print\n"},{"out":"1","err":"","code":"$_=\"psychology\"; print reverse;\n"},{"out":"ERROR: Invalid range \"z-a\" in transliteration operator at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$_=\"psychology\"; tr/a-z/z-a/g; print;\n"},{"out":"khbxsloltb","err":"","code":"$_ = 'psychology'; $za = join('', reverse 'a' .. 'z'); eval \"tr/a-z/$za/\"; $_\n"},{"err":"","out":"psychology","code":"$_ = 'psychology'; $za = join('', reverse 'a' .. 'z'); eval \"tr/a-z/$za\"; $_\n"},{"err":"","out":"psychology","code":"$_ = 'psychology'; $za = join('', 'z' .. 'a'); eval \"tr/a-z/$za\"; $_\n"},{"err":"","out":"othr bits","code":"'pthr bots' =~ tr/op/io/r\n"},{"out":"1","err":"","code":"'Â·' =~ /[[:punct:]]/\n"},{"out":"1","err":"","code":"'Â§' =~ /[[:punct:]]/\n"},{"code":"push @_, !\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n"},{"code":"[push [], 1]\n","err":"","out":"[1]"},{"out":"Grinnz_ is the push (@_,\"alpha\"); push (@_,\"omega\"); print \"Grinnz_ is the $_[0] and the $_[$#_]\\n\" and the omega\n","err":"","code":"push (@_,\"alpha\"); push (@_,\"omega\"); print \"Grinnz_ is the $_[0] and the $_[$#_]\\n\"\n"},{"code":"$|++; push @a, $|; $|--; push @a, $|; $|--; push @a,  $|; \\@a\n","err":"","out":"[1,0,1]"},{"err":"","out":"[1]","code":"[ push [], 'a' ]  # thus\n"},{"err":"","out":"ERROR: Type of arg 1 to push must be array (not constant item) at (eval 558) line 1, at EOF\n","code":"push foo, 1, 2\n"},{"out":"2,3,4,5,6,7,8,9,10,11","err":"","code":"(++$_ && push(@foo, $_)) for 1..10; join ',',@foo;\n"},{"code":"push @foo, glob \"/\" for (1..10); \\@foo\n","err":"","out":"[\"/\",\"/\",\"/\",\"/\",\"/\",\"/\",\"/\",\"/\",\"/\",\"/\"]"},{"out":"ERROR: Not an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"push $hash{foo}, 'something'; \\%hash\n"},{"out":"{foo => [\"wibble\"]}","err":"","code":"push $hash->{foo}->@*, \"wibble\"; $hash\n"},{"code":"push @{ $href->{key} }, qw(a b c); $href\n","err":"","out":"{key => [\"a\",\"b\",\"c\"]}"},{"err":"","out":"[0,1,2,3,4,5]","code":"push @l, $-[0] while \"banana\" =~ /b|a|n/g; [@l]\n"},{"code":"push @players, [ \"Dealer\", \"\", \"\" ]; push @players, [ \"AcidRain\", \"50\", \"\" ];     [ @players ]\n","out":"[[\"Dealer\",\"\",\"\"],[\"AcidRain\",50,\"\"]]","err":""},{"code":"push @strings, $_ =~ m/^\\w*/\n","out":"1","err":""},{"out":"1","err":"","code":"push @strings, [$_ =~ /^\\w+/];\n"},{"out":"{foo => [\"bar\",\"baz\"]}","err":"","code":"push @{$x->{foo}}, 'bar'; push @{$x->{foo}}, 'baz'; $x  # or with $x not even hodling anything to begin with\n"},{"code":"`pwd`;\n","out":"","err":""},{"err":"","out":"ERROR: Unrecognized character \\x9F; marked by <-- HERE after  ÃÂ°ÃÂÃÂÃÂ :) ÃÂ°<-- HERE near column 102 at (eval 558) line 1, <STDIN> line 1.\n","code":"q ð :) ð\n"},{"err":"","out":"","code":"q{}\n"},{"code":"q{\\}\n","out":"ERROR: Can't find string terminator \"}\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"","err":"","code":"/\\Q[/\n"},{"code":"\"\\Q!\"\n","err":"","out":"\\!"},{"code":"$_ = q(\"...); /()(.)/; [$2]\n","err":"","out":"[\"\\\"\"]"},{"out":"q522","err":"","code":"q5.22.0\n"},{"code":"q{\"90020\",33.786594,\"-118.298662\",\"Los Angeles\",\"CA\",\"Los Angeles\"} =~ s/^(\".+\").+$/$1/r\n","out":"\"90020\",33.786594,\"-118.298662\",\"Los Angeles\",\"CA\",\"","err":""},{"code":"q \\ a\\ b\\ c ;\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"q \\ a\\ b\"\n"},{"err":"","out":"[\"abc\",\"def\",\"ghi\"]","code":"[ q{abc def 123 ghi} =~ m/\\b([A-Za-z]+)\\b/g ]; # Where as this matches all three.\n"},{"code":"[ q{abc def 123 ghi} =~ m/(?:^|\\s)([A-Za-z]+)(?=\\s|$)/g ]\n","out":"[\"abc\",\"def\",\"ghi\"]","err":""},{"code":"[ q{abc def 123 ghi} =~ m/(?:^|\\s)([A-Za-z]+)(?:\\s|$)/g ]; # Why doesn't 'def' get matched?\n","err":"","out":"[\"abc\",\"ghi\"]"},{"code":"$_= q/a b c d e f g/; @vars = (split)[2]; \\@vars\n","err":"","out":"[\"c\"]"},{"code":"$_= q/a b c d/; @vars = (split)[2,3]; \\@vars\n","out":"[\"c\",\"d\"]","err":""},{"out":"even this","err":"","code":"q aeven thisa\n"},{"code":"$_=q{an if1 \" some if2 \" then \"if3\" not if4!!};  [ /(if\\d)(?=(?:[^\"]|\"[^\"]*\")*$)/g ]\n","out":"[\"if1\",\"if4\"]","err":""},{"code":"$_=q{an if1 \" some if2 \" then \"if3\" not if4!!};  [ /\"[^\"]*\"(*SKIP)(*F)|if\\d/g ]\n","out":"[\"if1\",\"if4\"]","err":""},{"code":"q caller vec\n","out":"aller ve","err":""},{"out":"[\"use\\\\ 5\\\\.022001\\\\;\\\\ use\\\\ feature\\\\ qw\\\\/postderef\\\\ refaliasing\\\\ lexical_subs\\\\ postderef_qq\\\\ signatures\\\\/\\\\;\\\\ \\\\[\\\\\\\"\\\\\\\\Q\\\\\\$code\\\\\\\"\\\\]\"]","err":"","code":"[\"\\Q$code\"]\n"},{"code":"$_ = q,echo foo bar=baz hmm=\"1 2 3\" nn='aa bb',; my @h; s/(([\"'])(?:[^\"']+|\\\\.|(?!\\2).)*\\2)/push @h, $1;\"\\xFFFD\"/ge; my @words = split ' '; s/\\xFFFD/shift @h/ge for @words; \\@words;\n","out":"[\"echo\",\"foo\",\"bar=baz\",\"hmm=\\\"1 2 3\\\"\",\"nn='aa bb'\"]","err":""},{"out":"foo","err":"","code":"q\\foo\\\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"q\\foo\\\\\"\n","code":"q\\foo\\\\bar\\\n"},{"out":"f\\(o\\+o\\*\\)bar","err":"","code":"\"\\Qf(o+o*)\\Ebar\"\n"},{"out":"foobar","err":"","code":"\"\\Qfoo\\Ebar\"\n"},{"code":"q\\foo\\ =~ m\\foo\\\n","out":"1","err":""},{"code":"q\\foo\\ =~ s\\foo\\bar\\r\n","err":"","out":"bar"},{"err":"","out":"foofoo","code":"q{foo} x 2.5 # Would be interesting if this coudl actually produce a sub string.\n"},{"err":"","out":"ERROR: Unrecognized character \\x88; marked by <-- HERE after q ÃÂÃÂhelloÃÂ<-- HERE near column 101 at (eval 558) line 1, <STDIN> line 1.\n","code":"q ÌhelloÌ\n"},{"code":"qÌhelloÌ\n","out":"ERROR: Unrecognized character \\x88; marked by <-- HERE after  qÃÂÃÂhelloÃÂ<-- HERE near column 100 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"qÌhelloÌ . \"\"\n","err":"","out":"ERROR: Unrecognized character \\x88; marked by <-- HERE after  qÃÂÃÂhelloÃÂ<-- HERE near column 100 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"q{I think perl bot is down?}\n","out":"I think perl bot is down?","err":""},{"err":"","out":"\"\"","code":"qq(\"\")\n"},{"code":"qq(\"\\\")\n","out":"\"\"","err":""},{"code":"qq(\\)\n","err":"","out":"ERROR: Can't find string terminator \")\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"a b c ' d","code":"q qa b c ' dq # great idea\n"},{"err":"","out":"1","code":"q qaq =~ m\\a\\\n"},{"out":"","err":"","code":"qq'$bar'\n"},{"out":"foo\tbar","err":"","code":"qq(foo\\tbar)\n"},{"err":"","out":"[undef,\"hello\",undef,\"there\",\"test test\",undef,undef,\"more\",undef,\"testing\"]","code":"[ qq(hello there \"test test\" more testing) =~ /\"([^\"]+)\"|(\\S+)/g ]\n"},{"code":"[ qq(    \"  some extra spaces \" hello there \"test test\" more testing) =~ /\"([^\"]+)\"|(\\S+)/g ]\n","err":"","out":"[\"  some extra spaces \",undef,undef,\"hello\",undef,\"there\",\"test test\",undef,undef,\"more\",undef,\"testing\"]"},{"err":"","out":"[\"space1   \",undef,undef,\"space2\"]","code":"[ qq(  \"space1   \"   space2 ) =~ /\"([^\"]+)\"|(\\S+)/g ]\n"},{"out":"[\"\\\"foo\\\\\\r\\\\\\n\\\\\\tbar\\\\\\n\\\"\"]","err":"","code":"[q{\"}.quotemeta(\"foo\\r\\n\\tbar\\n\").q{\"}]\n"},{"code":"[ qr/[ @_ ]/ ]\n","out":"[qr/[ [ qr\\/[ @_ ]\\/ ] ]/u]","err":""},{"code":"qr/ @_ /\n","out":"qr/ qr\\/ @_ \\/ /u","err":""},{"err":"","out":"ERROR: Incomplete expression within '(?[ ])' in regex; marked by <-- HERE in m/(?[ ()  <-- HERE ])/ at (eval 558) line 1, <STDIN> line 1.\n","code":"qr/(?[ () ])/\n"},{"code":"qr/[[]/\n","err":"","out":"qr/[[]/u"},{"out":"(?^u:^cats$)","err":"","code":"qr/^cats$/ . \"\"\n"},{"err":"","out":"ERROR: Switch (?(condition)... not terminated in regex; marked by <-- HERE in m/(?(DEFINE) <-- HERE / at (eval 558) line 1, <STDIN> line 1.\n","code":"qr{(?(DEFINE)};\n"},{"err":"","out":"qr/e/u","code":"qr/e$d/\n"},{"out":"regexp_substr(fn.stringvalue, '\\w+\\s\\w+') user_full_name","err":"","code":"q{regexp_substr(fn.stringvalue, '\\w+\\s\\w+') user_full_name}\n"},{"code":"qr/*.*/ # not with that first * in there, no\n","err":"","out":"ERROR: Quantifier follows nothing in regex; marked by <-- HERE in m/* <-- HERE .*/ at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"qr//u","err":"","code":"qr/\\Q$foo/\n"},{"out":"[qr/foo/u,qr/\\Qfoo/u]","err":"","code":"[qr/\\Qfoo/, qr'\\Qfoo']\n"},{"code":"qr/(?^:\\Q(s))/\n","out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/( <-- HERE ?^:\\(s\\)\\)/ at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"qr/\\(s\\)/u","err":"","code":"qr/\\Q(s)/\n"},{"err":"","out":"qr/\\Q\\/s./u","code":"qr'\\Q/s.'\n"},{"err":"","out":"qr/\\Q(s)/u","code":"qr'\\Q(s)'\n"},{"code":"qr/(?^:\\Q(s)\\E)/\n","err":"","out":"qr/(?^:\\(s\\))/u"},{"code":"qr/\\Q$x/\n","err":"","out":"qr//u"},{"out":"qr/(s)/u","err":"","code":"qr'(s)'\n"},{"code":"'' . qr/something/msx\n","err":"","out":"(?^umsx:something)"},{"out":"[qr/\\s+:SerialNumber\\s+/u,\"s+:SerialNumbers+\"]","err":"","code":"[ qr/\\s+:SerialNumber\\s+/, \"\\s+:SerialNumber\\s+\" ]\n"},{"code":" qr/(?s)<tr/ . ''\n","out":"(?^u:(?s)<tr)","err":""},{"out":"(?^us:<tr)","err":"","code":"qr/<tr/s . ''\n"},{"code":"qr/what does this do/x\n","out":"qr/what does this do/ux","err":""},{"out":"qr/(\\.xls$|\\.xlsx$)/u","err":"","code":"qr/(\\.xls$|\\.xlsx$)/\n"},{"err":"","out":"qr/(?=.|\\z)*.*/u","code":"qr/(?=.|\\z)*.*/\n"},{"out":"","err":"","code":"quotemeta <>\n"},{"out":"\\<\\>","err":"","code":"quotemeta <\\<\\>>\n"},{"code":"quotemeta '~!@#$%^&*()_\\\\{}.,+?'\n","err":"","out":"\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)_\\\\\\{\\}\\.\\,\\+\\?"},{"err":"","out":"\\<\\>","code":"quotemeta '<>'\n"},{"code":"quotemeta '!'\n","out":"\\!","err":""},{"code":"quotemeta \"_\"\n","out":"_","err":""},{"out":"\\:","err":"","code":"quotemeta \":\"\n"},{"code":"quotemeta 'abcdefg[\\]$%^&*()'\n","err":"","out":"abcdefg\\[\\\\\\]\\$\\%\\^\\&\\*\\(\\)"},{"err":"","out":"hello\\ world","code":"quotemeta 'hello world'\n"},{"code":"quotemeta 'hello:world'\n","out":"hello\\:world","err":""},{"err":"","out":"\\<\\>","code":"quotemeta q<<>>\n"},{"err":"","out":"\\\\\\/","code":"quotemeta(q{\\/})\n"},{"out":"\\/","err":"","code":"quotemeta(qq{\\/})\n"},{"code":"[ quotemeta(q{\\/}), quotemeta(qq{\\/}) ]\n","out":"[\"\\\\\\\\\\\\/\",\"\\\\/\"]","err":""},{"code":"[ quotemeta 'test@example.com' ]\n","err":"","out":"[\"test\\\\\\@example\\\\.com\"]"},{"out":"ÃÂ­ÃÂÃÂ","err":"","code":"quotemeta \"\\x{D000}\"\n"},{"code":"quoutemeta <>\n","out":"ERROR: syntax error at (eval 558) line 1, near \"<>\"\n","err":""},{"code":"quoutemeta( <> )\n","out":"ERROR: Undefined subroutine &main::quoutemeta called at (eval 558) line 1.\n","err":""},{"out":"ERROR: Bad name after qv' at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"qv'5.22.0'\n"},{"code":"qv5.22.0\n","out":"qv522","err":""},{"out":"[]","err":"","code":"[qw()]\n"},{"code":"qw()\n","err":"","out":""},{"code":"[ qw( a b c ) x 3 ]\n","out":"[\"a\",\"b\",\"c\",\"a\",\"b\",\"c\",\"a\",\"b\",\"c\"]","err":""},{"out":"ccc","err":"","code":"qw( a b c ) x 3\n"},{"code":"[qw(Attachment) x 3]\n","err":"","out":"[\"Attachment\",\"Attachment\",\"Attachment\"]"},{"code":"qw/Attachment/ x 3\n","out":"AttachmentAttachmentAttachment","err":""},{"out":"[\"email\\@one.com\",\"email\\@two.com\"]","err":"","code":"[qw(email@one.com email@two.com)]\n"},{"code":"\"@{ [ %{ [qw/foo bar baz/] } ] }\"\n","err":"","out":"ERROR: Not a HASH reference at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"%{ [qw/foo bar baz/] }","code":"\"%{ [qw/foo bar baz/] }\"\n"},{"out":"[\"foo\",\"bar\",\"baz\"]","err":"","code":"[ qw(foo bar baz) ]\n"},{"code":"qw/foo bar baz/\n","out":"baz","err":""},{"err":"","out":"baz","code":"qw(foo bar baz)\n"},{"code":"qw(foo bar baz)[2]\n","out":"baz","err":""},{"code":"qw/foo bar baz quux/[1]\n","err":"","out":"bar"},{"err":"","out":"[\"&my_function\"]","code":"[ qw ( &my_function) ] # Prostetnic\n"},{"code":"[ qw(#no) ]\n","err":"","out":"[\"#no\"]"},{"code":"$qwqwerqwe = 1;\n","out":"1","err":""},{"code":"+{ qw/you can dump a hashref directly/ }\n","out":"{hashref => \"directly\",dump => \"a\",you => \"can\"}","err":""},{"code":"qx(id);\n","out":"","err":""},{"code":"qx(ls /);\n","err":"","out":""},{"code":"qx(whoami)\n","out":"","err":""},{"out":"ERROR: Unrecognized character \\xA0; marked by <-- HERE after llo worldÃÂ<-- HERE near column 107 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"q Â hello worldÂ ;\n"},{"code":"q Â hello\\ worldÂ ;\n","err":"","out":"ERROR: Unrecognized character \\xA0; marked by <-- HERE after lo\\ worldÃÂ<-- HERE near column 108 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"rand() < 0.5 ? 'vending machine works' : 'vending machine refuses to give you anything'\n","err":"","out":"vending machine works"},{"out":"0.8783848319176","err":"","code":"rand * 3\n"},{"err":"","out":"0.288398966749327","code":"rand +   *    34\n"},{"code":"[rand() * 5000, rand * 5000]\n","out":"[\"2579.48293861531\",\"0.545190152750489\"]","err":""},{"code":"rand * 5000 # unary * is a useful feature too\n","out":"0.739384780029894","err":""},{"code":"random(100)\n","out":"ERROR: Undefined subroutine &main::random called at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"[ \"  random\\t\\nwhitespace\\r\" =~ /\\S+/g ]\n","out":"[\"random\",\"whitespace\"]","err":""},{"code":"\"RASH DEAL\"\n","out":"RASH DEAL","err":""},{"err":"","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after res/; RASH<-- HERE near column 95 at (eval 558) line 1, <STDIN> line 1.\n","code":"RASHâDEAL\n"},{"code":"$re0 = \"x?y+\"; $re1 = qr/$re0/; $re2 = qr/$re1/; [ $re0, $re1, $re2 ]\n","out":"[\"x?y+\",qr/x?y+/u,qr/x?y+/u]","err":""},{"err":"","out":"[qr/x?y+/u,qr/x?y+/u]","code":"$re1 = qr/x?y+/; $re2 = qr/$re1/; [ $re1, $re2 ]\n"},{"out":"","err":"","code":"readline \"{a,b,c}\"\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"reduce 1\"\n","code":"reduce 1\n"},{"code":"reduce {$a + $b} 1\n","err":"","out":"ERROR: Can't locate object method \"reduce\" via package \"0\" (perhaps you forgot to load \"0\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"ref [];\n","out":"ARRAY","err":""},{"code":"ref \\[1]\n","out":"REF","err":""},{"code":"ref \\\\1\n","out":"REF","err":""},{"out":"SCALAR","err":"","code":"ref \\ []->[3]\n"},{"code":"ref \\$a\n","err":"","out":"SCALAR"},{"code":"ref \\\\\\\\\\\\$a\n","out":"REF","err":""},{"out":"ARRAY","err":"","code":"ref bless {}, 'ARRAY'\n"},{"code":"ref( bless {}, \"Here is a lovely long string that I invented one summer's day\" )\n","out":"Here is a lovely long string that I invented one summer's day","err":""},{"code":"ref [\"item1\",\"item2\"]\n","err":"","out":"ARRAY"},{"code":"ref main::\n","out":"","err":""},{"out":"Regexp","err":"","code":"ref qr//\n"},{"code":"ref qr//;\n","err":"","out":"Regexp"},{"err":"","out":"[\"IO::File\"]","code":"[ ref *STDOUT{IO} ]\n"},{"code":"ref \\(substr \"aliens\", 0, 2)\n","err":"","out":"LVALUE"},{"err":"","out":"VSTRING","code":"ref \\v1.2.3\n"},{"code":"ref v1.2.3\n","out":"","err":""},{"code":"ref([v1.2.3]->[0])\n","err":"","out":""},{"code":"ref( $x = wantarray ); [$x]\n","out":"[\"\"]","err":""},{"code":"$regex = \"*meow*\"; \"banana\" =~ /$regex/;\n","err":"","out":"ERROR: Quantifier follows nothing in regex; marked by <-- HERE in m/* <-- HERE meow*/ at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"[ 'Regexp'->can('(\"\"') ]\n","err":"","out":"[undef]"},{"code":"[ 'Regexp'->can('(+0') ]\n","err":"","out":"[undef]"},{"err":"","out":"ERROR: No such file or directory at (eval 558) line 1, <STDIN> line 1.\n","code":"rename(\"/opt/google/chrome\", \"/opt/google/egacs\") or die \"$!\"\n"},{"code":"$re=qr/(\\d{7})/; [ \"12345678\" =~ $re, \"1234567\" =~ $re ]\n","out":"[1234567,1234567]","err":""},{"err":"","out":"[1234567,1234567]","code":"$re=qr/(?<!\\D)(\\d{7})(?!\\D)/; [ \"12345678\" =~ $re, \"1234567\" =~ $re ]\n"},{"code":"$re = '['; /\\Q$re/\n","out":"","err":""},{"code":"require(0 + \"inf\")\n","err":"","out":"ERROR: Invalid version format (non-numeric data) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"require 5\n","err":"","out":"1"},{"code":"require 5.0.6;\n","out":"1","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"require 5\"\n","code":"require 5blah\n"},{"code":"require 'App::Pluggable';\n","out":"ERROR: Can't locate App::Pluggable:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"64","code":"require bigint; bigint->import; 1<<70\n"},{"code":"require JSON::XS; JSON::XS::encode_json {hi => 123};\n","out":"{\"hi\":123}","err":""},{"out":"ERROR: Can't locate Some::Module:__XYZ:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"require 'Some::Module:__XYZ'\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"require Some::Module:\"\n","err":"","code":"require Some::Module:__XYZ\n"},{"code":"$re = '['; /$re/\n","out":"ERROR: Unmatched [ in regex; marked by <-- HERE in m/[ <-- HERE / at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"return join(',', @accounts);\n","out":"","err":""},{"out":"","err":"","code":"return or die;\n"},{"code":"\"Return value\"; \"Miesco\";\n","err":"","out":"Miesco"},{"code":"[ reverse(\"6.4.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.1.0.0.0.0.1.1.8.2.a.1.0.0.b.3\" =~ tr/.//dr) =~ /.{4}/g ]\n","err":"","out":"[\"3b00\",\"1a28\",1100,\"0012\",\"0000\",\"0000\",\"0000\",\"0046\"]"},{"err":"","out":"b76468c7","code":"reverse \"7c86467b\"\n"},{"out":"reenigne","err":"","code":"reverse 'engineer'\n"},{"out":"yxorp","err":"","code":"reverse proxy\n"},{"code":"[ reverse \"psychology\" ]\n","err":"","out":"[\"psychology\"]"},{"out":",140,266,132,492,008","err":"","code":"reverse((reverse 0x7f9241004ee8) =~ s/(...)/$1,/gr)\n"},{"code":"reverse \"string\"\n","out":"gnirts","err":""},{"code":"reverse (\"string\")\n","out":"gnirts","err":""},{"out":"[\"string\",\"string\"]","err":"","code":"[ (reverse \"string\"), (reverse (\"string\")) ]\n"},{"out":"gnirtsgnirts","err":"","code":"reverse (\"string\", \"string\")  # :s\n"},{"code":"[reverse(\"string\",\"strong\"), scalar reverse(\"string\", \"strong\")]\n","err":"","out":"[\"strong\",\"string\",\"gnortsgnirts\"]"},{"out":"foo","err":"","code":"$_=\"rexma\"; /(?{$name=\"foo\"})re[x]ma|(?{$name=\"bar\"})o[ther]matc/; $name\n"},{"out":"","err":"","code":"@r = (foo => 1, bar => 2); ${{@r}}{\"a\"}\n"},{"err":"","out":"6","code":"rindex \"1234abc\", \"c\"\n"},{"code":"rindex $_, \"c\" == length $_ - 1 for \"1234abc\"\n","err":"","out":""},{"out":"Device or resource busy","err":"","code":"rmdir '/' or $!\n"},{"code":"\"\\r\\n\" =~ /^\\R$/\n","err":"","out":"1"},{"out":"[\"hi\",\"hi\",\"one\",\"two\"]","err":"","code":"$row = [qw(hi one two)]; unshift(@$row, substr($row->[0],-10)); $row\n"},{"code":"\"\\s\"\n","err":"","out":"s"},{"err":"","out":"s+","code":"\"\\s+\"\n"},{"out":"","err":"","code":"s =~ =///=\n"},{"code":"/@(\\S+)/\n","out":"","err":""},{"out":"","err":"","code":"/\\s{0,}(#{0,})SANITY01/\n"},{"out":"","err":"","code":"/\\s{0,}(\\#{0,})SANITY01/x\n"},{"err":"","out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/\\s{0,}(#{0,})SANITY01 <-- HERE / at (eval 558) line 1, <STDIN> line 1.\n","code":"/\\s{0,}(#{0,})SANITY01/x\n"},{"out":"S01E0","err":"","code":"\"S01E\" . $1 * 2\n"},{"code":"S01E($1*2)\n","err":"","out":"ERROR: Undefined subroutine &main::S01E called at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"RASH DEAL","code":"s/..(..).*/$1/ for@x=([],{},$\",\\&f,\\0);print@x\n"},{"code":"s/..(..).*/$1/ for@x=([],{},$\",\\&f,\\0);$\"=\"\";\"@x\"\n","err":"","out":"RASH DEAL"},{"code":"s/..(..).*/$1/,print for@x=([],{},$\",\\&f,\\0)\n","out":"RASH DEAL","err":""},{"code":"$s1 = ''; $s2 = 'foo'; $s3 = $s1 || $s2; [$s3]\n","out":"[\"foo\"]","err":""},{"out":"/","err":"","code":"\"////\" =~ s{/{2,}}{/}gr\n"},{"err":"","out":"1.5","code":"$s=(3+undef)/2;print $s\n"},{"out":"1","err":"","code":"@s=[4,5,6];print join \" \",@s[-1..-2];\n"},{"err":"","out":"1","code":"@s=[4,5,6];print @s[-1..-2];#since no one's talking in here anyway, may as well use the bot\n"},{"err":"","out":"e is 'd,e,has,commas'","code":"$s = \"a,b also has, commas,c,d,e,has,commas,f,g\"; $s =~ s/(,[^,]+){2}$//;  \"e is '\" . (split \",\", $s, 5)[4] . \"'\"\n"},{"out":"e is 'e,has,commas'","err":"","code":"$s = \"a,b,c,d,e,has,commas,f,g\"; $s =~ s/(,[^,]+){2}$//;  \"e is '\" . (split \",\", $s, 5)[4] . \"'\"\n"},{"code":"$s=\"a.b.c.d\"; $h{a}{b}{c}{d}=123;  $r=\\%h; $r=$r->{$_} for split/\\./,$s; $r\n","err":"","out":"123"},{"err":"","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","code":"$s=\"a.b.c.d\"; $h{a}{b}{c}{d}=123;  $r=\\%h; $r=$r->{$_} for split/\\./,$s; $r'\n"},{"code":"$s=\"a.b.c.d\"; my %h; @h{ split(/\\./, $s) } = (1, 2, 3, 4); print keys %h, print values %h;\n","err":"","out":"4213dbac1"},{"out":"Match","err":"","code":"$s = '*';  \"a*b*c\" =~ /\\Q$s/ ? \"Match\" : \"No match\"\n"},{"code":"$s = '*';  \"a*b*c\" =~ /$s/ ? \"Match\" : \"No match\"\n","err":"","out":"ERROR: Quantifier follows nothing in regex; marked by <-- HERE in m/* <-- HERE / at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"","code":"\"s\" =~ /^((?:a|b|c)s?)?$/ # whatever dude\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"\"{a}b}\" $s \"\n","err":"","code":"$s = \"{a}b}\" $s =~ /\\{(.*?)\\}/; [$1]\n"},{"code":"$s = \"{a}b}\"; $s =~ /\\{(.*?)\\}/; [$1]\n","out":"[\"a\"]","err":""},{"out":"","err":"","code":"s/(A)/eval(lcfirst $1)/gee\n"},{"out":"","err":"","code":"s/(A)/lcfirst $1/e\n"},{"code":"s/(A)/lcfirst $1/re\n","err":"","out":""},{"code":"$_=\"&&&\"; s/&/&amp;/g; [$_]\n","out":"[\"&amp;&amp;&amp;\"]","err":""},{"err":"","out":"ERROR: Regexp modifiers \"/a\" and \"/l\" are mutually exclusive at (eval 558) line 1, near \"; \"\n","code":"s///apple\n"},{"out":"ERROR: Regexp modifiers \"/a\" and \"/l\" are mutually exclusive at (eval 558) line 1, near \"; \"\nRegexp modifiers \"/a\" and \"/l\" are mutually exclusive at (eval 558) line 1, near \"; \"\n","err":"","code":"s///asmallregex\n"},{"code":"${ \\ 'save' }\n","err":"","out":"save"},{"code":"say $[\n","out":"0\n","err":""},{"code":"say ~0;\n","err":"","out":"18446744073709551615\n"},{"out":"2\n4\n6\n8\n10\n12\n14\n16\n18\n20\n","err":"","code":"say$_*2for 1..10\n"},{"out":"Yes\n","err":"","code":"say((\"a\" x 10000) =~ /^(ab?)*$/ ? \"Yes\" : \"No\");\n"},{"code":"say blahblah q|0.000.000_YYMMDDhhmm|\n","err":"","out":""},{"out":"damn them all to hell\n","err":"","code":"say \"damn them all to hell\";\n"},{"code":"say Encode::encode(\"ISO-8859-1\", Encode::decode(\"UTF-8\", \"ÃÂ¡r jÃÂº sÃÂºr?\"));\n","out":"ÃÂÃÂ¡r jÃÂÃÂº sÃÂÃÂºr?\n","err":""},{"code":"say \"foo\" if (\"/page/show/1234\" =~ m{page/});\n","err":"","out":"foo\n"},{"code":"say for @INC\n","out":"","err":""},{"err":"","out":"","code":"say for keys %hash;\n"},{"code":"say 'hello'\n","err":"","out":"hello\n"},{"code":"say hi\n","err":"","out":""},{"err":"","out":"hi\n","code":"say 'hi'\n"},{"err":"","out":"hi\n","code":"say \"hi\"\n"},{"code":"say length \"0.99999999999991\"\n","err":"","out":"16\n"},{"code":"say length q|0.000.000_YYMMDDhhmm|\n","err":"","out":"20\n"},{"code":"say lenqth q|0.000.000_YYMMDDhhmm|\n","err":"","out":""},{"err":"","out":"ERROR: Can't find string terminator \"h\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","code":"say q  hello\\ world ;\n"},{"code":"say q Â hello\\ worldÂ ;\n","err":"","out":"ERROR: Unrecognized character \\xA0; marked by <-- HERE after lo\\ worldÃÂ<-- HERE near column 112 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"say\"RASH DEAL\"\n","out":"RASH DEAL\n","err":""},{"out":"","err":"","code":"say something\n"},{"out":"var  is better than var \n","err":"","code":"say \"var $rindolf is better than var $generic_var\"\n"},{"err":"","out":"ERROR: Can't locate object method \"what\" via package \"again\" (perhaps you forgot to load \"again\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"say what again\n"},{"err":"","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after res/; say <-- HERE near column 95 at (eval 558) line 1, <STDIN> line 1.\n","code":"say âwhateverâ\n"},{"err":"","out":"wotcher\n","code":"say \"wotcher\"\n"},{"code":"say ( [\"wotcher\"] )\n","out":"ARRAY(0x5c84028)\n","err":""},{"code":"say (\"wotcher\")\n","out":"wotcher\n","err":""},{"out":"banAPPLEana","err":"","code":"$s = \"banana\"; substr($s, 3,0) = \"APPLE\"; $s\n"},{"code":"/(?<!S)\\b/i\n","err":"","out":""},{"code":"'   ' =~ /\\s\\B\\s/\n","err":"","out":"1"},{"code":"s/(?<\\b!STYLESY0B\\$\\$)\\b$k\\b/<span class=\"kw1\">$k<\\/span>/igs\n","err":"","out":"ERROR: Group name must start with a non-digit word character in regex; marked by <-- HERE in m/(?<\\ <-- HERE b!STYLESY0B\\$\\$)\\b\\b/ at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"[1]","err":"","code":"[ *_{SCALAR} == \\$_ ]\n"},{"out":"scalar @_[0]","err":"","code":"scalar @_[0]\n"},{"err":"","out":"[\"00000\"]","code":"[scalar( (0) x 5 )]\n"},{"out":"10","err":"","code":"scalar (() = (1..10))\n"},{"err":"","out":"ERROR: Not enough arguments for scalar at (eval 558) line 1, near \"scalar () \"\n","code":"scalar () = (1..10)\n"},{"code":"[ scalar('Ù£' =~ /^\\d$/a), scalar('Ù£' =~ /^.$/a), scalar(\"Ù¢\" =~ /^[Ù¡-Ù£]$/a), scalar('Ù£' =~ /^\\D$/a) ]\n","err":"","out":"[\"\",\"\",\"\",\"\"]"},{"out":"","err":"","code":"scalar @{$arrayref}[1,2,3]\n"},{"err":"","out":"1","code":"scalar \"asd1312321asd1212asd121212\" =~/(asd\\d+)/g;\n"},{"code":"scalar  ( \"A\" ) x 3\n","out":"AAA","err":""},{"err":"","out":"AAA","code":"scalar  +( \"A\" ) x 3\n"},{"code":"scalar @{ $foo{bar}{baz} // [] }\n","err":"","out":"0"},{"code":"scalar(()=glob('*'))  # probably 0\n","out":"0","err":""},{"code":"scalar grep /isnt/, qw/list of words/\n","out":"0","err":""},{"code":"scalar grep /is/, qw/list of words/\n","out":"1","err":""},{"err":"","out":"{}","code":"scalar \\%hash\n"},{"code":"scalar %hash\n","err":"","out":"0"},{"err":"","out":"ERROR: Can't modify scalar in scalar assignment at (eval 558) line 1, at EOF\n","code":"scalar(@order) = 2; @order and @order = grep $_, @order[-2, -1]\n"},{"code":"scalar qw/1 2 3/;   # this should be more confusing :p\n","out":"3","err":""},{"err":"","out":"[\"AttachmentAttachmentAttachment\"]","code":"[scalar qw(Attachment) x 3]\n"},{"err":"","out":"cba","code":"scalar reverse 'abc'\n"},{"code":"\"${\\scalar reverse 'foo'}\"\n","out":"oof","err":""},{"code":"[ scalar reverse \"psychology\" ]\n","err":"","out":"[\"ygolohcysp\"]"},{"out":"[1,\"\"]","err":"","code":"[ scalar '' =~ /^$/, scalar 'a' =~ /^$/]\n"},{"out":"[1,3,5]","err":"","code":"scalar scalar scalar [1, 3, 5]\n"},{"code":"\"${\\scalar sub { wantarray() ? 'list' : 'scalar' }->()}\"\n","err":"","out":"scalar"},{"code":"scalar $^T\n","out":"1460500293","err":""},{"err":"","out":"[1]","code":"[ Scalar::Util::looks_like_number '1 ' ]\n"},{"code":"Scalar::Util::looks_like_number(\"4\")\n","err":"","out":"1"},{"err":"","out":"1","code":"Scalar::Util::looks_like_number( 'inf')\n"},{"code":"Scalar::Util::looks_like_number('-INF')\n","err":"","out":"1"},{"code":"Scalar::Util::looks_like_number('INF')\n","out":"1","err":""},{"err":"","out":"","code":"Scalar::Util::looks_like_number( 'inferior')\n"},{"out":"1","err":"","code":"Scalar::Util::looks_like_number \"nan\"\n"},{"code":"Scalar::Util::looks_like_number 'NaN'\n","out":"1","err":""},{"code":"Scalar::Util::looks_like_number( 'NaN')\n","out":"1","err":""},{"code":"Scalar::Util->VERSION\n","err":"","out":"1.41"},{"err":"","out":"[\"??????????\"]","code":"[scalar  ('?') x 10 ] # lol?\n"},{"err":"","out":"{scalar => \"???\",list => [\"?\",\"?\",\"?\"]}","code":"{ scalar => ('?' x 3), list => [ ('?') x 3 ] }\n"},{"code":"!!\"scotsmen\"\n","out":"1","err":""},{"out":"","err":"","code":"s///course\n"},{"out":"script/@id=cats","err":"","code":"$script = \"cats\"; \"script/\\@id=$script\"\n"},{"err":"","out":"[\"foobar\"]","code":"$_ = 'sdfaosdkf!foobar!pokasdf!'; [ m/!(.+?)!/ ];\n"},{"out":"1","err":"","code":"s///eeeeeeeeeeeeeee\n"},{"err":"","out":"0","code":"s/^/\"-\"/ee if 0;\n"},{"code":"see your paste\n","err":"","out":"ERROR: Can't locate object method \"see\" via package \"your\" (perhaps you forgot to load \"your\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"1","err":"","code":"s///eieio\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","code":"s/^/-/e if 0;\n"},{"code":"s/$/$/$///$//e # $ in regex makes perl uneasy too\n","out":"ERROR: Final $ should be \\$ or $name at (eval 558) line 1, within string\nsyntax error at (eval 558) line 1, near \"; s/$/$/\"\n","err":""},{"code":"select\n","out":"\\*{'::$stdh'}","err":""},{"code":"[select]\n","out":"[\\*{'::$stdh'}]","err":""},{"code":"\"SELECT id, name, unidade_id, pcu, regexp_replace(barcode, '\\\\s+', '', 'g') as barcode from articles;\"\n","out":"SELECT id, name, unidade_id, pcu, regexp_replace(barcode, '\\s+', '', 'g') as barcode from articles;","err":""},{"err":"","out":"hmm","code":"select->print(\"hmm\")\n"},{"code":"[ \"SELECT \\@rownum:=0\", 'SELECT @rownum:=0' ]\n","out":"[\"SELECT \\@rownum:=0\",\"SELECT \\@rownum:=0\"]","err":""},{"err":"","out":"","code":"\"$self\"\n"},{"out":"","err":"","code":"$self\n"},{"err":"","out":"[\"example\\@domain.com\"]","code":"[ \"    Sender:example\\@domain.com\\n\" =~ qr/(?|from=<([^>]+)>,src=|^\\s+Sender:(.*?)$)/ ]\n"},{"err":"","out":"[undef,\"example\\@domain.com\"]","code":"[ \"    Sender:example\\@domain.com\\n\" =~ qr/from=<([^>]+)>,src=|^\\s+Sender:(.*?)$/ ]\n"},{"code":"[ '    Sender:example@domain.com' =~ qr/from=<([^>]+)>,src=|^\\s+Sender:(.*?)$/ ]\n","err":"","out":"[undef,\"example\\@domain.com\"]"},{"code":"[ \"    Sender:example@domain.com\" =~ qr/from=<([^>]+)>,src=|^\\s+Sender:(.*?)$/ ]\n","out":"[undef,\"example.com\"]","err":""},{"err":"","out":"1","code":"s***exmag\n"},{"code":"$s = 'foo'; undef $s; $s .= 'bar';\n","err":"","out":"bar"},{"err":"","out":"","code":"sftp> ls\n"},{"err":"","out":"ERROR: Unmatched ) in regex; marked by <-- HERE in m/(...)...) <-- HERE ?/ at (eval 558) line 1, <STDIN> line 1.\n","code":"s/(...)...)?//g\n"},{"code":"s/\\+\\/g\n","err":"","out":"ERROR: Substitution pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"\"////\" =~ s{//}{/}gr\n","out":"//","err":""},{"code":"\"////\" =~ s{/+}{/}gr\n","out":"/","err":""},{"code":"\"+-\" =~ s/[+-]/!/gr\n","err":"","out":"!!"},{"code":"shift @_\n","out":"shift @_","err":""},{"code":"shift $foo;\n","out":"ERROR: Not an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"shift; # fully optimized\n","err":"","out":""},{"code":"\"shop_image/importer/1000003/00_1000003.jpg\" =~ /(\\d\\d_\\d{7,7})\\.jpg/; $1\n","out":"00_1000003","err":""},{"code":"$s=\"http://a?k1=v1&k2=v2\"; [$s=~/.*?\\?(?:([^=]+)=([^&]+)&?)+/g]\n","err":"","out":"[\"k2\",\"v2\"]"},{"code":"$s = \"http://a?k1=v1&k2=v2\"; [ $s =~ /[?&]([^=]+)=([^&]+)/g ]\n","err":"","out":"[\"k1\",\"v1\",\"k2\",\"v2\"]"},{"err":"","out":"","code":"$SIG{CHLD}\n"},{"code":"$SIG{__DIE__} = sub { print \"don't do this: @_\" }; eval { die \"you didn't see me, right\" };\n","out":"don't do this: you didn't see me, right at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"dead!ERROR: Unimplemented at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$SIG{__DIE__} = sub { print q(dead!)}; ...;\n"},{"code":"$SIG{__DIE__} = sub { $|++; say 42; exit }; a bc\n","out":"","err":""},{"out":"dead!\nERROR: Unimplemented at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$SIG{__DIE__} = sub { say q(dead!) }; ...;\n"},{"code":"\"SIMCOP48.856934\"^2\n","err":"","out":"2"},{"err":"","out":"NaN","code":"sin 9**9**9\n"},{"err":"","out":"size=1182","code":"\"size=473\" =~ s/size=\\K(\\d+)/int($1*2.5)/er\n"},{"err":"","out":"4345332","code":"$_ = \"sj4jdj345k3dasssdf32\"; tr/0-9//cd; print $_;\n"},{"code":"sleep 5; print \"hello\"\n","err":"","out":"hello"},{"err":"","out":"","code":"sleep( 60 * 60 * 8 ) if $!{EINSUFFICIENTCAFFIENE}; # g'night folks.\n"},{"code":"s///mansex\n","err":"","out":"1"},{"err":"","out":"ERROR: Regexp modifiers \"/u\" and \"/l\" are mutually exclusive at (eval 558) line 1, near \"; \"\nRegexp modifiers \"/u\" and \"/d\" are mutually exclusive at (eval 558) line 1, near \"; \"\n","code":"s///mulder\n"},{"out":"yes","err":"","code":"$s = '\\\\n'; \"\\n\" =~ /$s/ ? \"yes\" : \"no\"\n"},{"err":"","out":"","code":"s///nordic\n"},{"code":"snork gorble pow fwee\n","err":"","out":"ERROR: Usage: POSIX::pow(x, exponent) at (eval 558) line 1.\n"},{"out":"ERROR: Can't locate object method \"poww\" via package \"fwee\" (perhaps you forgot to load \"fwee\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"snork gorble poww fwee\n"},{"code":"socket(my $fh, 6, 2, 17) or die \"can't - $!\";\n","err":"","out":"ERROR: can't - Bad file descriptor at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"'some-help-approver@example.net' =~ /(?<!^help-approver)\\@example\\.net$/\n","out":"1","err":""},{"err":"","out":"some text \n[3] some more text \n[4] even more text","code":"\"some text [3] some more text [4] even more text\" =~ s/(?=\\[\\d+\\])/\\n/gr # or rather this, I guess\n"},{"code":"\"some text [3] some more text [4] even more text\" =~ s/(?=\\[)/â¤/gr # tlhiv_laptop\n","out":"some text ÃÂ¢ÃÂÃÂ¤[3] some more text ÃÂ¢ÃÂÃÂ¤[4] even more text","err":""},{"out":"[\"some text\",\"some\",\"text\",\"some text\"]","err":"","code":"[ \"some text here\" =~ /((some) (text))/p, ${^MATCH} ] # no, preferably not $&\n"},{"code":"[ \"some text\" =~ m/o|t/ ]\n","err":"","out":"[1]"},{"err":"","out":"[\"o\",\"t\",\"t\"]","code":"[ \"some text\" =~ m/o|t/g ]\n"},{"code":"$_ = 'something123.pl'; s/\\w.*?\\K(\\d\\.pl)/0$1/; $_ # why .*-like-things may not work as you wanted\n","err":"","out":"something1203.pl"},{"err":"","out":"sprintf \"%x \", ord ssprintf \"%x \", ord osprintf \"%x \", ord msprintf \"%x \", ord esprintf \"%x \", ord tsprintf \"%x \", ord hsprintf \"%x \", ord isprintf \"%x \", ord nsprintf \"%x \", ord gsprintf \"%x \", ord  sprintf \"%x \", ord lsprintf \"%x \", ord isprintf \"%x \", ord ksprintf \"%x \", ord esprintf \"%x \", ord  sprintf \"%x \", ord tsprintf \"%x \", ord hsprintf \"%x \", ord isprintf \"%x \", ord ssprintf \"%x \", ord ?","code":"\"something like this?\" =~ s/(.)/sprintf \"%x \", ord $1/gr\n"},{"out":"73 6f 6d 65 74 68 69 6e 67 20 6c 69 6b 65 20 74 68 69 73 3f ","err":"","code":"\"something like this?\" =~ s/(.)/sprintf \"%x \", ord $1/gre\n"},{"code":"$_ = \"something like this? x x\"; my $state = 0; s/(\\w)/++$state % 2 ? (uc $1) : (lc $1)/ge; $_\n","err":"","out":"SoMeThInG lIkE tHiS? x X"},{"out":"1 2 three","err":"","code":"$s = \"one two three\"; %h = ( one => 1, two => 2 ); $s =~ s/$_/$h{$_}/ for keys %h; $s\n"},{"err":"","out":"[5,2,3]","code":"[sort { 0 } 5, 2, 3]\n"},{"err":"","out":"[1,101,102,12,13,2]","code":"[sort 1, 2, 12, 13, 101, 102]\n"},{"code":"( sort ( 1..9 ));\n","out":"","err":""},{"code":"sort ( [8,6,7,4,2,3,9] )\n","err":"","out":""},{"out":"","err":"","code":"sort (8, 6, 7, 5, 2, 3, 9)\n"},{"out":"","err":"","code":"sort(99, 111)\n"},{"out":"[[3,\"c\"],[1,\"d\"],[2,\"d\"]]","err":"","code":"[ sort { $a->[1] cmp $b->[1] || $a->[0] <=> $b->[0] } [2, 'd'], [3, 'c'], [1, 'd'] ]\n"},{"err":"","out":"[1386778075,1386778719]","code":"[ sort { $a <=> $b } 1386778719, 1386778075 ]\n"},{"err":"","out":"[8,3,2,1,8,0,8]","code":"[ sort { $a < $b } 2, 3, 1, 8, 0, 8, 8 ] # like, really easy\n"},{"code":"[ sort { $a <=> $b } 4, 15, 11, \"NaN\", 11, 2, 1, 4, 3, \"nan\", 8 ]\n","err":"","out":"[1,2,3,4,4,11,11,15,\"NaN\",\"nan\",8]"},{"err":"","out":"[0,7,\"nan\",3]","code":"[ sort { $a <=> $b } 7, 0, \"nan\", 3 ]\n"},{"code":"[ sort { $a <=> $b } 7, \"nan\", 3 ]\n","out":"[3,7,\"nan\"]","err":""},{"err":"","out":"[0,3,5,6,7,8,9]","code":"[ sort { $a <=> $b } 8, 6, 7, 5, 3, 0, 9 ] # tell sort to compare $a and $b numerically instead of as strings\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","code":"[sort { $a cmp $b } qw/w x/\n"},{"err":"","out":"[\"w\",\"x\"]","code":"[sort { $a cmp $b } qw/w x/]\n"},{"code":"[ sort { length $a <=> length $b || $a cmp $b } qw(this is a sentence with a few random words in it) ]\n","err":"","out":"[\"a\",\"a\",\"in\",\"is\",\"it\",\"few\",\"this\",\"with\",\"words\",\"random\",\"sentence\"]"},{"code":"[ sort { length $a <=> length $b } sort { $a cmp $b } qw(this is a sentence with a few random words in it) ]\n","err":"","out":"[\"a\",\"a\",\"in\",\"is\",\"it\",\"few\",\"this\",\"with\",\"words\",\"random\",\"sentence\"]"},{"code":"sort ( qw(8,6,7,4,2,3,9) )\n","err":"","out":""},{"code":"sort ( qw[8,6,7,4,2,3,9] )\n","err":"","out":""},{"code":"[sort qw(9 3 4 5 6 3 4 1)] #thats how it works\n","out":"[1,3,3,4,4,5,6,9]","err":""},{"code":"[ sort qw/ 9 39 5 38 4 5 381 29 0 1 2 3 / ]\n","err":"","out":"[0,1,2,29,3,38,381,39,4,5,5,9]"},{"code":"[ sort qw/a fan of w k r p in Cincinnati/ ]\n","out":"[\"Cincinnati\",\"a\",\"fan\",\"in\",\"k\",\"of\",\"p\",\"r\",\"w\"]","err":""},{"code":"[sort qw/Compnent Component::A Component::B Your::Mother/]\n","err":"","out":"[\"Compnent\",\"Component::A\",\"Component::B\",\"Your::Mother\"]"},{"err":"","out":"[\"could\",\"could\",\"could\",\"must\",\"must\",\"must\",\"should\",\"should\"]","code":"[ sort qw(must should could could must could should must) ]\n"},{"out":"[\"i\",\"h\"]","err":"","code":"[ sort { return 42 } \"h\", \"i\" ]\n"},{"err":"","out":"[\"hi\"]","code":"[ sort { return 42 } \"hi\" ]\n"},{"code":"[sort &{sub {$_[0] <=> $_[1]}}, qw,1 3 2 772 9,]\n","out":"[0,1,2,3,772,9]","err":""},{"out":"match","err":"","code":"('so this should match,even,though,,it,seems,very,different,from,requirements?' =~ m/\\w+,\\w+,,\\w+,\\w+/) ? 'match' : 'no match'\n"},{"code":"so we don't get double action once perlbot is back in commission\n","out":"ERROR: Can't locate object method \"in\" via package \"commission\" (perhaps you forgot to load \"commission\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"${\"so what\"} = 123; \"see? ${so what}\"\n","out":"ERROR: Can't locate object method \"so\" via package \"what\" (perhaps you forgot to load \"what\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"${\"so what\"} = 123; \"see? ${'so what'}. fu\"\n","out":"see? 123. fu","err":""},{"code":"! ! ! ! ! ! \"spaces\"\n","out":"1","err":""},{"code":"@spec = ('abcd', 1, 2); say &CORE::substr(@spec)\n","out":"bc\n","err":""},{"code":"@spec = ('abcd', 1, 2); say substr(@spec)\n","err":"","out":"ERROR: Not enough arguments for substr at (eval 558) line 1, near \"@spec)\n\"\n"},{"out":"","err":"","code":"s/perl/python/;\n"},{"code":"splice((0..9),3,5)\n","err":"","out":"ERROR: Not an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"splice([0..9],3,5)\n","err":"","out":"7"},{"err":"","out":"[\"foo\",\"bar\"]","code":"splice @a, 2, 2, qw/foo bar/; \\@a\n"},{"code":"splice @test, 2; \\@test\n","out":"[]","err":""},{"code":"[ split /(?<!^),/, '\n","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"[3,18,50,33]","code":"[ split /[^0-9]+/, \"3 day 18 hr 50 min 33 sec\" ]\n"},{"out":"[\"1.1.1\",\"POWER\",\"SUPPLY\",\"DEFECT\"]","err":"","code":"[ split \" \", \"1.1.1 POWER SUPPLY DEFECT\" ]\n"},{"err":"","out":"[\"1.1.1 POWER SUPPLY DEFECT\"]","code":"[ split /\\./, \"1.1.1 POWER SUPPLY DEFECT\", 1 ]\n"},{"code":"[ split \" \", \"1.1.1 POWER SUPPLY DEFECT\", 1 ]\n","out":"[\"1.1.1 POWER SUPPLY DEFECT\"]","err":""},{"code":"[ split \" \", \"1.1.1 POWER SUPPLY DEFECT\", 2 ]  # ?\n","err":"","out":"[\"1.1.1\",\"POWER SUPPLY DEFECT\"]"},{"code":"[ split \"/\", \"12/33.\",2]\n","out":"[12,\"33.\"]","err":""},{"code":"[ split \"/\", \"12/33\", 2 ]\n","out":"[12,33]","err":""},{"out":"[]","err":"","code":"[ split \".\", \"12.33\" ]  # because this\n"},{"out":"[\"-\",\"14:56:45,344\",\"-\"]","err":"","code":"[ split \" \", \"- 14:56:45,344 -\", 4 ]\n"},{"out":"[\"-\",\"14:56:45,484\",\"Info\",\": Trying to load VINGCARD_VISION.dll\"]","err":"","code":"[ split \" \", \"- 14:56:45,484 Info  : Trying to load VINGCARD_VISION.dll\", 4 ]\n"},{"code":"[ split ' ', '25 25.175 jitter' ]\n","out":"[25,\"25.175\",\"jitter\"]","err":""},{"code":"split[4]\n","out":"0","err":""},{"out":"[\"\",\"a\",\"\",\"b\\tc\"]","err":"","code":"[ split /\\40/, \" a  b\\tc \", 0 ]\n"},{"err":"","out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/( <-- HERE .{4}/ at (eval 558) line 1, <STDIN> line 1.\n","code":"[split /(.{4}/, \"thisisatest\"]\n"},{"code":"[split /(.{4})/, \"thisisatest\"]\n","out":"[\"\",\"this\",\"\",\"isat\",\"est\"]","err":""},{"out":"[7,3,5,5,6,0,8]","err":"","code":"[ split //, 7355608 ]\n"},{"err":"","out":"[]","code":"[ split(/aaa/, '') ]\n"},{"out":"[\"a\"]","err":"","code":"[ split(/aaa/, 'a') ]\n"},{"out":"[]","err":"","code":"[ split(/aaa/, 'aaa') ]\n"},{"out":"[\"\",\"aa\"]","err":"","code":"[ split(/aaa/, 'aaaaa') ]\n"},{"out":"[\"\",\"\",\"bc\",\"de\"]","err":"","code":"[ split /a/, 'aabcadeaa' ] # derp\n"},{"code":"[split(/a/, \"abacus\")]\n","out":"[\"\",\"b\",\"cus\"]","err":""},{"code":"split(/a/, \"abacus\")\n","err":"","out":"3"},{"err":"","out":"[\"a\",\"\",\"\",\"b\"]","code":"[split / /, 'a   b']\n"},{"err":"","out":"[\"a\",\"b\"]","code":"[split ' ', 'a   b']\n"},{"err":"","out":"[\"a\",\"b\",undef,undef]","code":"[ (split /:/, \"a:b\")[0..3] ]\n"},{"code":"[ split //, \" a b c \" ]\n","out":"[\" \",\"a\",\" \",\"b\",\" \",\"c\",\" \"]","err":""},{"code":"[split //, 'abc']\n","out":"[\"a\",\"b\",\"c\"]","err":""},{"code":"(split /,/, \"a,b,c\")[1]\n","err":"","out":"b"},{"code":"(split \",\", \"a,b,c\")[1]\n","err":"","out":"b"},{"code":"[ split ' ', \"a b c\", 1 ]\n","err":"","out":"[\"a b c\"]"},{"code":"[split /(?<=-)\\+(?=-)/, \"a+b+cc-+-d-e-f\"]\n","out":"[\"a+b+cc-\",\"-d-e-f\"]","err":""},{"err":"","out":"[\"a+b+cc-+-d-e-f\"]","code":"[split /(?<=-)+(?=-)/, \"a+b+cc-+-d-e-f\"]\n"},{"out":"[\"ab\",\"cd\"]","err":"","code":"[split /\\./,\"ab.cd.\"]\n"},{"code":"[split /\\./,\"ab.cd.\",-1]\n","err":"","out":"[\"ab\",\"cd\",\"\"]"},{"code":"[split /\\./,\"ab.cd.\",2]\n","out":"[\"ab\",\"cd.\"]","err":""},{"code":"[split /\\./,\"ab.cd.df.\",2]\n","out":"[\"ab\",\"cd.df.\"]","err":""},{"code":"[split /\\./,\"ab.cd.df\",2]\n","out":"[\"ab\",\"cd.df\"]","err":""},{"out":"[\"a\",\"b\",\"c\",\"d\",\"e\"]","err":"","code":"[ split //, \"abcde\" ]\n"},{"code":"split(//, \"abcde\")\n","out":"5","err":""},{"out":"5","err":"","code":"split(//, \"abcde\") . \"\"\n"},{"err":"","out":"[\"a\",\"b\",\"c\"]","code":"[split \" \",\"a b c\\n\"]\n"},{"err":"","out":"[\"a\",\"b\",\"c\"]","code":"[ split \" \", \" a  b\\tc \" ]\n"},{"err":"","out":"[\"amarok\"]","code":"[ split \" \", \"  amarok\" ]\n"},{"code":"[ split ' ', \" a real split \" ]\n","out":"[\"a\",\"real\",\"split\"]","err":""},{"code":"[ split /\\A/, \"where\\nis\\nyour\\ngod\\nnow?\" ]\n","err":"","out":"[\"where\\nis\\nyour\\ngod\\nnow?\"]"},{"out":"[123,\" \",5,\" \",12,\" \",7,\" \"]","err":"","code":"[split /\\b/, \"123 5 12 7 \"]\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"/\\b/ \"123 5 12 7 \"\"\n","code":"split /\\b/ \"123 5 12 7 \"\n"},{"err":"","out":"[\"b\",\"a\",\"n\",\"a\",\"n\",\"a\"]","code":"[ split //, \"banana\" ]\n"},{"out":"[\"foo_bar\"]","err":"","code":"[split /\\b/, \"foo_bar\"]\n"},{"code":"[ split /\\D/, \"1k10k1|11dld1\" ]\n","out":"[1,10,1,11,\"\",\"\",1]","err":""},{"out":"[1,10,1,11,1]","err":"","code":"[ split /\\D+/, \"1k10k1|11dld1\" ]\n"},{"out":"[\"foo\",\"bar\",\"baz\"]","err":"","code":"[ split ' ', 'foo bar baz' ]\n"},{"out":"[\"foo\\\\,bar\",\"baz\"]","err":"","code":"[split /(?<!\\\\),/, \"foo\\\\,bar,baz\"]\n"},{"code":"[split \",\", \"foo bar baz\"]\n","out":"[\"foo bar baz\"]","err":""},{"code":"[split \",\", \"foo, bar, baz\"]\n","out":"[\"foo\",\" bar\",\" baz\"]","err":""},{"err":"","out":"bar","code":"(split /\\./, 'foo.bar.baz')[1]\n"},{"code":"[ split /=|==|:|--/, \"foo:bar:baz\", 2 ]\n","out":"[\"foo\",\"bar:baz\"]","err":""},{"err":"","out":"[[\"foo\",\"\",\"\",\"\",\"\",\"bar\"],[\"foo\",\"bar\"]]","code":"[[ split / /, \"foo     bar\" ], [ split ' ', \"foo     bar\" ]]\n"},{"out":"[\"\",\"foo\\tbar\",\"\",\"baz\"]","err":"","code":"[ split / /, \" foo\\tbar  baz \" ]\n"},{"out":"[\"foo\",\"bar\",\"baz\"]","err":"","code":"[ split \" \", \" foo\\tbar  baz \" ]\n"},{"err":"","out":"[\"example.fr\",\"example2.fr\"]","code":"[ split /(?<=@free.fr)/, \"example@free.frexample2@free.fr\" ] #hmm, why doesn't this keep the @free.fr part in the results?\n"},{"err":"","out":"[\"example\\@free.fr\",\"example2\\@free.fr\"]","code":"[ split /(?<=@free\\.fr)/, 'example@free.frexample2@free.fr' ] #right\n"},{"code":"[split \" \", \"Fri Dec  4 18:54:59 EST 2015\"]\n","err":"","out":"[\"Fri\",\"Dec\",4,\"18:54:59\",\"EST\",2015]"},{"code":"[ split //, \"FÂ­uÂ­dge\" ]\n","err":"","out":"[\"F\",\"\\302\",\"\\255\",\"u\",\"\\302\",\"\\255\",\"d\",\"g\",\"e\"]"},{"code":"[split//,\"Hello\"]\n","err":"","out":"[\"H\",\"e\",\"l\",\"l\",\"o\"]"},{"out":"[]","err":"","code":"[ split '.', 'horsey.surprise' ]\n"},{"code":"[ split '\\\\.', 'horsey.surprise' ]\n","err":"","out":"[\"horsey\",\"surprise\"]"},{"code":"[ split /[&=]/, \"http://a?k1=v1&k2=v2\" ]\n","out":"[\"http://a?k1\",\"v1\",\"k2\",\"v2\"]","err":""},{"code":"[ split m{/}, \"12/33.\" ]\n","err":"","out":"[12,\"33.\"]"},{"err":"","out":"[\"hello\\n\",\"world\"]","code":"[ split /^/m, \"hello\\nworld\" ]\n"},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"[ split m!/|\\.html!, \"dirs/123/abc.def/ghi999.html ]\n"},{"out":"[\"dirs\",123,\"abc.def\",\"ghi999\"]","err":"","code":"[ split m!/|\\.html!, \"dirs/123/abc.def/ghi999.html\" ]\n"},{"code":"[ split m{/}, '/just/a/demo/' ]\n","out":"[\"\",\"just\",\"a\",\"demo\"]","err":""},{"code":"[ split ',', 'money.perl.com,money.python.com,money.nei.com' ]\n","err":"","out":"[\"money.perl.com\",\"money.python.com\",\"money.nei.com\"]"},{"code":"[ split /(?<!^),/, ',one,two,three' ]\n","out":"[\",one\",\"two\",\"three\"]","err":""},{"code":"[split //, \"perl\"]\n","out":"[\"p\",\"e\",\"r\",\"l\"]","err":""},{"code":"[ split qr'(?<=@free\\.fr)', 'example@free.frexample2@free.fr' ] #look ma! no han^Wescapes! (except that . one)\n","err":"","out":"[\"example\\@free.fr\",\"example2\\@free.fr\"]"},{"err":"","out":"[\"something\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]","code":"[ split qr{[\\[\\]=]+}, \"something[a=b][c=d][e=f]\" ]\n"},{"err":"","out":"[\"abxxcdex+fg\"]","code":"[split('\\Qx+', \"abxxcdex+fg\")]\n"},{"out":"[\"abxxcde\",\"fg\"]","err":"","code":"[split(\"\\Qx+\", \"abxxcdex+fg\")]\n"},{"code":"[ split ' ', \"  random\\t\\nwhitespace\\r\" ]\n","err":"","out":"[\"random\",\"whitespace\"]"},{"out":"[]","err":"","code":"[split /\\s+/, \" \"]\n"},{"code":"[split /\\s+/, \" \", -1]\n","out":"[\"\",\"\"]","err":""},{"err":"","out":"[\"a\",\"\"]","code":"[split /\\s+/, \"a \", -1]\n"},{"out":"[\"a\",\"\",\"\",\"\",\"\",\"b\"]","err":"","code":"[ split /\\s/, \"a     b\" ]\n"},{"err":"","out":"[\"\",\"a\"]","code":"[split /\\s+/, \" a\"] # but this one doesn't need the limit\n"},{"code":"[ split /\\s+/, \"  amarok\" ]\n","err":"","out":"[\"\",\"amarok\"]"},{"code":"[ split \"\\s+\", \"  amarok\" ]\n","out":"[\"  amarok\"]","err":""},{"code":"[ split /\\s+/, \" a real split \", -1 ]\n","err":"","out":"[\"\",\"a\",\"real\",\"split\",\"\"]"},{"err":"","out":"[\"foo\",\"baz\"]","code":"[ split /[@\\s]/, \"foo@bar baz\" ]\n"},{"code":"[ split /[\\@\\s]/, 'foo@bar baz' ]\n","err":"","out":"[\"foo\",\"bar\",\"baz\"]"},{"code":"[ split /[\\@\\s]/, \"foo@bar baz\" ]\n","out":"[\"foo\",\"baz\"]","err":""},{"code":"[ split /[\\@\\s]/, \"foo\\@bar baz\" ]\n","out":"[\"foo\",\"bar\",\"baz\"]","err":""},{"code":"[split /(,\\s*)/, \"foo, bar, baz\"]\n","out":"[\"foo\",\", \",\"bar\",\", \",\"baz\"]","err":""},{"code":"split /(,\\s*)/, \"foo, bar, baz\"\n","err":"","out":"5"},{"code":"[ split /\\s+/, grep /x/, qw(abc def kzx lol) ]\n","out":"[1]","err":""},{"err":"","out":"australia","code":"(split /-/, (split /\\//, \"http://www.site.com/letters0241/something-in-australia-a-h\")[-1])[2]\n"},{"code":"[split //, sprintf \"%b\", 20]\n","out":"[1,0,1,0,0]","err":""},{"err":"","out":"[\"Knark\",\". \",\"knark\",\",\"]","code":"[ split /([\\s[:punct:]]+)/, \"Knark. knark,\" ]\n"},{"code":"[ split /(\\s+|[[:punct:]])/, \"Knark. knark,\" ] # or ask perlbot\n","out":"[\"Knark\",\".\",\"\",\" \",\"knark\",\",\"]","err":""},{"code":"[split /\\s*=\\s*/, 'name=val=ue', 2]\n","out":"[\"name\",\"val=ue\"]","err":""},{"code":"[ split(/\\s+/, 'split th\\is line') ]\n","out":"[\"split\",\"th\\\\is\",\"line\"]","err":""},{"out":"[\"\",\"word\"]","err":"","code":"[ split /\\s+/, \" word \" ]\n"},{"code":"[split /\\t/, \"\"]\n","err":"","out":"[]"},{"err":"","out":"[\"\\\\\",\"t\"]","code":"[split '', '\\t']\n"},{"err":"","out":"[\"\\t\"]","code":"[split '', \"\\t\"]\n"},{"err":"","out":"[\"test\",\"'string=ignore this symbol'\"]","code":"[ split /=/, \"test='string=ignore this symbol'\", 2 ] # presumably you want key + value\n"},{"err":"","out":"[\"this\",\"is\",\" a test\",\" with\\\\; escaped delimiters\"]","code":"[ split /(?<!\\\\);/, \"this;is; a test; with\\\\; escaped delimiters;;\" ]\n"},{"out":"[\"this\",\"is\",\" a test\",\" with\\\\\\\\; escaped delimiters\"]","err":"","code":"[split /(?<!\\\\);/, 'this;is; a test; with\\\\\\; escaped delimiters;;']\n"},{"code":"[split /\\t/, \"sajkhsdahkj\"]\n","out":"[\"sajkhsdahkj\"]","err":""},{"out":"[\"a\",\".\",\"b\",\"!\",\"c\",\"?\",\"d\",\" \",\"e\"]","err":"","code":"[split /(\\W)/, \"a.b!c?d e\"]\n"},{"out":"[\"\",\"foo\"]","err":"","code":"[ split /\\W+/, \"(foo)\" ]\n"},{"out":"[\"foo\",\" \",\"bar\",\".\",\"baz\",\" \",\"quux\",\"?\",\"derp\",\" \",\"ermintrude\"]","err":"","code":"[split /(\\W)/, \"foo bar.baz quux?derp ermintrude\"]\n"},{"out":"[\"what\",\"are you on about\"]","err":"","code":"[ split \" \", \"what are you on about\", 2 ] # wodim?\n"},{"out":"[\"where\",\"is\",\"\\\"your\",\"god\\\"\",\"now\"]","err":"","code":"[ split /,/, 'where,is,\"your,god\",now' ]\n"},{"code":"[ split \",\", \"worker1,\" ]\n","out":"[\"worker1\"]","err":""},{"code":"[ split \",\", \"worker1,\", -1 ]\n","out":"[\"worker1\",\"\"]","err":""},{"code":"[ split /,/, ',x,', -1 ]\n","out":"[\"\",\"x\",\"\"]","err":""},{"code":"[split('x+', \"abxxcdex+fg\")]\n","err":"","out":"[\"ab\",\"cde\",\"+fg\"]"},{"code":"[split /x/, 'axb', 'yxz']\n","out":"[\"a\",\"b\"]","err":""},{"code":"sprintf '%012x', 0xff\n","out":"0000000000ff","err":""},{"code":"sprintf '%012x', 0xffff\n","out":"00000000ffff","err":""},{"out":"09","err":"","code":"sprintf('%02d', 9)\n"},{"code":"sprintf('%02x%02x%02x', 192, 255, 63)\n","out":"c0ff3f","err":""},{"code":"sprintf \"%*02X\", \" \", \"bar\"\n","out":"%*02X","err":""},{"code":"sprintf \"%02*X\", \" \", \"bar\"\n","out":"%02*X","err":""},{"code":"sprintf(\".%03u\", 85)\n","err":"","out":".085"},{"out":".850","err":"","code":"sprintf(\".%03u\", 850)\n"},{"out":".8500","err":"","code":"sprintf(\".%03u\", 8500)\n"},{"code":"sprintf '%04d', 1\n","out":"0001","err":""},{"code":"[ sprintf \"%04o\", 0755 ]\n","out":"[\"0755\"]","err":""},{"code":"sprintf '%04o', 0777\n","err":"","out":"0777"},{"code":"sprintf '%04x', hex 'dead'\n","err":"","out":"dead"},{"out":"01.67","err":"","code":"sprintf '%05.2f', 5/3\n"},{"out":"00009","err":"","code":"sprintf('%0.5d',9)\n"},{"code":"sprintf('%0.5f', 7.15255737304688e-06)\n","err":"","out":"0.00001"},{"code":"sprintf \"%08b\", 1 | 15\n","out":"00001111","err":""},{"code":"[sprintf \"%08x\", int( rand(1000))]\n","out":"[\"000002d2\"]","err":""},{"code":"sprintf '%.0f', 1.139999999999999 * 100\n","out":"114","err":""},{"out":"3","err":"","code":"sprintf \"%.0f\", 2.6\n"},{"code":"sprintf \"%.0f\", 6 * 99.90 * 100\n","err":"","out":"59940"},{"err":"","out":"64","code":"sprintf'%.0f',log(~0)/log(2)\n"},{"out":"0.000000","err":"","code":"sprintf '%' . 0xfffffff . '$f'\n"},{"err":"","out":"[123       ]","code":"sprintf \"[%-10d]\", 123\n"},{"out":"0.0000007625","err":"","code":"sprintf \"%.10f\", 942993 / 1236732346368\n"},{"out":"0.0000762488% ram used","err":"","code":"sprintf \"%.10f%% ram used\", 942993 / 1236732346368 * 100\n"},{"out":"       599.4","err":"","code":"sprintf(\"%12.6g\", 6 * 99.90)\n"},{"err":"","out":"[\"0.00000000001435\"]","code":"[ sprintf '%.14f', '1.43531262539073e-11' ] # or sprintf, if you want to do something other than display the result\n"},{"err":"","out":"0.000000762487536","code":"sprintf \"%.15f\", 942993 / 1236732346368\n"},{"err":"","out":"9","code":"sprintf('%1d',9)\n"},{"code":"sprintf \"%.20f %.20f\", 0.1, 0.3\n","out":"0.10000000000000000555 0.29999999999999998890","err":""},{"code":"sprintf \"%.20f\", 6 * 99.90\n","err":"","out":"599.40000000000009094947"},{"code":"sprintf \"%2.2e\", 1234.567\n","err":"","out":"1.23e+03"},{"err":"","out":"[\"0.0000000000143531262539072984\"]","code":"[ sprintf '%.28f', '1.43531262539073e-11' ]\n"},{"out":"[\"0.75\"]","err":"","code":"[sprintf \"%.2f\", 3/4]\n"},{"out":"second then first","err":"","code":"sprintf '%2$s then %1$s', 'first', 'second';\n"},{"err":"","out":"134.949999999999988631316227838397","code":"sprintf \"%.30f\", \"134.95\"\n"},{"err":"","out":"134.949999999999988631316227838397","code":"sprintf \"%.30f\", 134.95\n"},{"code":"sprintf \"%.30f\", \"134.95\" * 100\n","out":"13494.999999999998181010596454143524","err":""},{"err":"","out":"13494.999999999998181010596454143524","code":"sprintf \"%.30f\", 134.95 * 100\n"},{"err":"","out":"0.000","code":"sprintf \"%.3f\", ((10/1*225)/(18))-125\n"},{"err":"","out":"2.345","code":"sprintf \"%.3f\", 2.34525\n"},{"out":"[\" 644\"]","err":"","code":"[ sprintf \"%4o\", 0644 ]\n"},{"err":"","out":"corn flakes","code":"sprintf('%5s', 'corn flakes');\n"},{"code":"sprintf \"%.70f\", 1/3\n","err":"","out":"0.3333333333333333148296162562473909929394721984863281250000000000000000"},{"code":"[sprintf \"%8.8x\", int( rand(1000))]\n","err":"","out":"[\"0000035e\"]"},{"out":"    1111","err":"","code":"sprintf \"%8b\", 1 | 15\n"},{"out":"[\"1.000000\",\"15.000000\"]","err":"","code":"[  (sprintf \"%8f\", 1) , (sprintf \"%8f\", 15) ]\n"},{"code":"sprintf \"%b\", 0.1\n","err":"","out":"0"},{"code":"sprintf \"%b\", 0.21875\n","err":"","out":"0"},{"code":"sprintf \"%b\", 0376\n","err":"","out":"11111110"},{"out":"1111","err":"","code":"sprintf \"%b\", 1 | 15\n"},{"out":"100101101010110010001","err":"","code":"sprintf \"%b\", 1234321\n"},{"code":"sprintf \"%b\", 152944\n","err":"","out":"100101010101110000"},{"code":"sprintf \"%b\", 21845\n","out":"101010101010101","err":""},{"out":"101010101","err":"","code":"sprintf \"%b\", 341\n"},{"code":"sprintf '%b', 50\n","out":"110010","err":""},{"code":"sprintf '%b', 82\n","err":"","out":"1010010"},{"out":"10101000100000001","err":"","code":"sprintf \"%b\", 86273\n"},{"code":"sprintf \"%b\", 87381\n","out":"10101010101010101","err":""},{"err":"","out":"1100000","code":"sprintf \"%b\", 96\n"},{"err":"","out":"10111011100000000","code":"sprintf '%b', 96000\n"},{"code":"[ sprintf \"%b & %b -> %b\", 2048, 0xFF, 2048 & 0xFF ]\n","err":"","out":"[\"100000000000 & 11111111 -> 0\"]"},{"out":"0.1","err":"","code":"sprintf \"%b.%b\", split /\\./, 0.1\n"},{"code":"sprintf \"%b.%b\", split /\\./, 0.21875\n","err":"","out":"0.101010101110011"},{"err":"","out":"[\"A\"]","code":"[sprintf\"%c\", 65]\n"},{"err":"","out":"[\"\\0\"]","code":"[sprintf\"%c\", 'a']\n"},{"err":"","out":"999","code":"sprintf \"%c%c%c\", map ord,(97,98,99)\n"},{"out":"abc","err":"","code":"sprintf \"%c%c%c\", map ord,('a','b','c')\n"},{"err":"","out":"0","code":"sprintf '%d', -0.5\n"},{"code":"sprintf \"%,d\", 12345678;\n","out":"%,d","err":""},{"err":"","out":"1","code":"sprintf '%d', 1.7\n"},{"err":"","out":"2","code":"sprintf(\"%d\", 2.6)\n"},{"code":"sprintf \"%d %s\", 1, 2\n","err":"","out":"1 2"},{"code":"sprintf '%.f', 0.49999999999999994\n","out":"0","err":""},{"code":"sprintf '%.*f', 1, 2\n","out":"2.0","err":""},{"err":"","out":"2.000000","code":"sprintf '%*f', '.1', 2\n"},{"out":"13495","err":"","code":"sprintf '%.f', 134.95 * 100\n"},{"code":"sprintf '%.f', 1.7\n","out":"2","err":""},{"code":"sprintf '%.*f', length('9999999999999911'), 0.9999999999999911\n","out":"0.9999999999999912","err":""},{"code":"sprintf \"%f\", rand(1e100)\n","err":"","out":"8989307795158939016935340648547805505885971406334412549642968818994012502105163425454481951871205376.000000"},{"out":"1341015082000","err":"","code":"sprintf '%lu', 1341015082000\n"},{"code":"sprintf \"%#o\", 0\n","out":"0","err":""},{"code":"[sprintf '%o', '16877']\n","out":"[40755]","err":""},{"err":"","out":"02","code":"sprintf \"%#o\", 2\n"},{"out":"420","err":"","code":"sprintf \"%o\", 272\n"},{"code":"sprintf \"%o\", 292\n","out":"444","err":""},{"out":"47","err":"","code":"sprintf \"%o\", 39\n"},{"err":"","out":"[00x0000] ","code":"sprintf(         q{[%02dx%02d}. ($3 ? q{-} : q{}). q{%02d] %s},          $1, $2, ($3 // q{}), $4      )\n"},{"err":"","out":"001.2345","code":"sprintf q{%03d.%d}, split /\\./, 1.2345; # leobut\n"},{"err":"","out":"2048.000","code":"sprintf q{%.3f}, 2047.99999952316 ### Is there a way to do this but truncate instead of rounding, so the result is 2047.999 instead of 2048.000 ?\n"},{"code":"sprintf q{%.3f}, (int (2047.99999952316 * 1000))/1000;\n","err":"","out":"2047.999"},{"out":"eval: sprintf $_ = q{eval: sprintf $_ = q{%s}, $_}, $_","err":"","code":"sprintf $_ = q{eval: sprintf $_ = q{%s}, $_}, $_\n"},{"code":"sprintf \"the cluster is using %.10f%% of available ram\", 942993 / 1236732346368 * 100\n","out":"the cluster is using 0.0000762488% of available ram","err":""},{"err":"","out":"the cluster is using 79.9526130995% of available ram","code":"sprintf \"the cluster is using %.10f%% of available ram\", (942993 * 2**20) / 1236732346368 * 100\n"},{"code":"sprintf \"%*v02X\", \" \", \"bar\"\n","out":"62 61 72","err":""},{"code":"sprintf \"%v*02X\", \" \", \"bar\"\n","err":"","out":"%v*02X"},{"code":"sprintf \"%*v02x\", \" \", Encode::encode_utf8(\"much \\x{2665}\")\n","err":"","out":"6d 75 63 68 20 e2 99 a5"},{"out":"68.65.6C.6C.6F","err":"","code":"sprintf \"%v02X\", \"hello\"\n"},{"out":"ERROR: Can't modify constant item in substitution (s///) at (eval 558) line 1, at EOF\n","err":"","code":"(sprintf \"%v02X\", \"hello\") =~ s/\\./ /g\n"},{"code":"(sprintf \"%v02X\", \"hello\") =~ s/\\./ /gr\n","err":"","out":"68 65 6C 6C 6F"},{"out":"89 50 4e 47 0d 0a 1a 0a","err":"","code":"sprintf \"%*v02x\", \" \", pack \"C*\", qw|137 80 78 71 13 10 26 10|\n"},{"out":"00.00.03.b1","err":"","code":"sprintf \"%v02x\", pack \"N\", 945\n"},{"out":"b1.03.00.00","err":"","code":"sprintf \"%v02x\", pack \"V\", 945\n"},{"code":"sprintf \"%*v04X\", \"U+\", \"hello\"\n","out":"0068U+0065U+006CU+006CU+006F","err":""},{"code":"sprintf '%vb', 'foo' # something like this, majuscule?\n","out":"1100110.1101111.1101111","err":""},{"out":"101","err":"","code":"sprintf '%vb', \"\\x05\" # binary string, then?\n"},{"err":"","out":"80.72.0","code":"sprintf \"%vd\", \"123\" ^ \"az3\"\n"},{"code":"sprintf \"%vd\", \"3\" ^ \"3\"\n","out":"0","err":""},{"out":"97","err":"","code":"sprintf \"%vd\", 'a'\n"},{"code":"sprintf \"%,vd\", 'abc'\n","out":"%,vd","err":""},{"code":"sprintf \"%*vd\", ',', 'abc'\n","out":"97,98,99","err":""},{"out":"97.98.99","err":"","code":"sprintf \"%vd\", 'abc'\n"},{"err":"","out":"102.111.111.10.13.98.97.114","code":"sprintf \"%vd\", \"foo\\n\\rbar\"\n"},{"out":"28.27.5.0.6.28.1.7.9.103","err":"","code":"sprintf \"%vd\", \"something\" ^ \"otherthing\"  # or this...\n"},{"code":"sprintf '%vd', \"string\"\n","out":"115.116.114.105.110.103","err":""},{"code":"sprintf \"%vd\", $^V\n","out":"5.22.1","err":""},{"code":"sprintf('%v', v1.2.3)\n","err":"","out":"%v"},{"code":"[ sprintf \"%x\", 127.0.0.1 ]\n","err":"","out":"[0]"},{"code":"sprintf \"%x\", 14644\n","out":"3934","err":""},{"err":"","out":"122c","code":"sprintf '%x', 18*256+44;\n"},{"err":"","out":"ffffffffffffffff","code":"sprintf \"%x\", 18446744073709551615\n"},{"code":"sprintf '%x', 3 * 256 + 17\n","err":"","out":"311"},{"code":"sprintf '%x', 44*256+18;\n","err":"","out":"2c12"},{"code":"sprintf \"%x\", 5 * 60 * 10e6\n","out":"b2d05e00","err":""},{"code":"sprintf \"%x\", 65280\n","out":"ff00","err":""},{"code":"sprintf \"%x\", oct \"0b011000111100\"\n","err":"","out":"63c"},{"code":"sprintf \"%X\", oct \"0b011000111100\"\n","err":"","out":"63C"},{"code":"sprintf '%x', ord '*';\n","err":"","out":"2a"},{"out":"30","err":"","code":"sprintf \"%x\", ord '0'\n"},{"out":"63","err":"","code":"sprintf '%x', ord 'c'\n"},{"out":"43","err":"","code":"sprintf '%x', ord 'C'\n"},{"code":"sprintf \"%x\", ord \"\\n\"\n","out":"a","err":""},{"err":"","out":"1234","code":"sprintf \"%x\", ord \"\\x{1234}\"\n"},{"out":"[0]","err":"","code":"[ sprintf \"%x\", v127.0.0.1 ]\n"},{"code":"sprintf \"%x %x\", 015, 012\n","out":"d a","err":""},{"err":"","out":"d83d de07","code":"sprintf \"%x %x\", 55357, 56839\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"sprint \"%x\"\"\n","code":"sprint \"%x\", ord '0'\n"},{"code":"$sql =~ s/constraint \\K`(\\w+)`/$1/gi; maybe?\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n"},{"out":"","err":"","code":"\"(s)\" =~ qr'\\Q(s)'\n"},{"code":"$s = quotemeta('*');  \"a*b*c\" =~ /$s/ ? \"Match\" : \"No match\"\n","err":"","out":"Match"},{"err":"","out":"!","code":"'!' =~ s/~//r\n"},{"err":"","out":"","code":"'!' =~ s/!//r\n"},{"out":"18446744073709551615","err":"","code":"srand(()) # Came up in p5p recently\n"},{"code":"@src=qw(a b c); @dst=grep defined, @src[2..5]; print join(\",\", @src);\n","err":"","out":"a,b,c,,,"},{"code":"@src=qw(a b c); @dst=@src[2..5]; print join(\",\", @dst);\n","out":"c,,,","err":""},{"err":"","out":"a,b,c","code":"@src=qw(a b c); @w=grep defined, @{ [@src[2..5]] }; print join(\",\", @src); #rmah, how about this?\n"},{"code":"@src=qw(a b c); @w=@src[2..5]; print join(\",\", @src);\n","err":"","out":"a,b,c"},{"code":"s///regexp\n","err":"","out":""},{"code":"sretrun\n","out":"sretrun","err":""},{"code":"sretrun join(',', @accounts);\n","out":"ERROR: syntax error at (eval 558) line 1, near \"sretrun join\"\n","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"sreturn join\"\n","code":"sreturn join(',', @accounts);\n"},{"err":"","out":"[\"\\303\\237\"]","code":"['Ã']\n"},{"err":"","out":"ERROR: Regexp modifiers \"/u\" and \"/l\" are mutually exclusive at (eval 558) line 1, near \"; \"\nRegexp modifiers \"/u\" and \"/l\" are mutually exclusive at (eval 558) line 1, near \"; \"\nUnknown regexp modifier \"/y\" at (eval 558) line 1, near \"; \"\n","code":"s///scully\n"},{"code":"'Ã' =~ m/^\\Qss\\E\\z/i ? 'True' : 'False';\n","out":"False","err":""},{"err":"","out":"[\"False\"]","code":"[ 'Ã' =~ m/^\\Qss\\E\\z/i ? 'True' : 'False' ];\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"q{})\"\n","code":"s/ / sprintf(         q{[%02dx%02d}. ($3 ? q{-} : q{}). q{%02d] %s},          $1, $2, ($3 // q{}), $4      )  /ex;\n"},{"code":"'Ã' =~ /\\Ã{UpperCase}/\n","err":"","out":""},{"code":"s/(?<!STYLESY0B\\$\\$)\\b$k\\b/<span class=\"kw1\">$k<\\/span>/igs;\n","err":"","out":"ERROR: Variable length lookbehind not implemented in regex m/(?<!STYLESY0B\\$\\$)\\b\\b/ at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"","code":"s///supernice\n"},{"code":"s///susanne\n","err":"","out":"ERROR: Regexp modifiers \"/u\" and \"/a\" are mutually exclusive at (eval 558) line 1, near \"; \"\n"},{"code":"s///susi\n","out":"1","err":""},{"code":"$_ = \"stackoverflow\"; $_ = reverse for substr $_, 0, 5; s/.//r\n","err":"","out":"catsoverflow"},{"code":"$_ = \"stackoverflow\"; substr($_,0,5,substr(reverse(substr$_,0,5),1,4)); $_\n","err":"","out":"catsoverflow"},{"code":"$_ = \"stackoverflow\"; substr($_,0,5,substr(~~reverse(substr($_,0,5)),1,4)); $_  # fixed\n","err":"","out":"catsoverflow"},{"code":"state $x = 4; $x\n","err":"","out":"4"},{"err":"","out":"y","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?=.*(?!STDERR output success))/ ? 'y' : 'n'\n"},{"code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?!.*STDERR output success)/ ? 'y' : 'n'\n","out":"y","err":""},{"err":"","out":"","code":"<stdin>\n"},{"out":"STDIN","err":"","code":"STDIN\n"},{"out":"[*::STDIN]","err":"","code":"[*STDIN]\n"},{"code":"*STDIN{IO}\n","out":"bless( , 'IO::File' )","err":"cannot handle ref type 15 at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/Data/Dumper.pm line 231, <STDIN> line 1.\n"},{"out":"0","err":"","code":"STDOUT->autoflush(1)\n"},{"code":"[ *STDOUT{IO} ]\n","err":"cannot handle ref type 15 at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/Data/Dumper.pm line 231, <STDIN> line 1.\n","out":"[bless( , 'IO::File' )]"},{"code":"*{ *STDOUT{IO} }\n","out":"*__ANON__::__ANONIO__","err":""},{"code":"'' . *{ *STDOUT{IO} }{IO}\n","err":"","out":"IO::File=IO(0x2177e40)"},{"err":"cannot handle ref type 15 at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/Data/Dumper.pm line 231, <STDIN> line 1.\n","out":"bless( , 'IO::File' )","code":"*{ *STDOUT{IO} }{IO}\n"},{"err":"","out":"[\"IO::File=IO(0x25d3e40)\",\"IO::File=IO(0x25d3e40)\"]","code":"[ ''.*STDOUT{IO}, '' . *{ *STDOUT{IO} }{IO} ]\n"},{"code":"STDOUT->print(\"oh no, entire classes\")\n","err":"","out":"oh no, entire classes1"},{"code":"/(?<!ST)/i\n","out":"ERROR: Variable length lookbehind not implemented in regex m/(?<!ST)/ at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"Storable::store \"hallo\"\n","out":"ERROR: not a reference at (eval 558) line 1.\n","err":""},{"code":"$str = '00 00 1c 00'; $num = unpack(\"V\", pack(\"(H2)4\", split / /, $str)); [ $num ]\n","out":"[1835008]","err":""},{"code":"$str = '00 00 1c 00'; $num = unpack(\"V\", pack(\"H8\", $str =~ tr/ //dr)); [ $num ]\n","err":"","out":"[1835008]"},{"code":"$str = '00 00 1c 00'; $str = join '', reverse split ' ', $str; $num = hex $str; [ $num ]\n","err":"","out":"[1835008]"},{"code":"$str = '00 00 1c 00'; $str =~ tr/ //d; $num = hex $str; [ $num ]\n","err":"","out":"[7168]"},{"code":"$str = '001122334455'; @m = ($str =~ m/(\\d{2})/g); \"@m\"\n","out":"00 11 22 33 44 55","err":""},{"err":"","out":"[1835008]","code":"$str = '00 1c 00 00'; $str =~ tr/ //d; $num = hex $str; [ $num ]\n"},{"code":"$str = 0b10000000 ^ 0b00000100; print unpack q/B8/, $str;\n","out":"00110001","err":""},{"err":"","out":"10000100","code":"$str = 0b10000000 ^ 0b00000100; sprintf \"%b\", $str\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"$str2(\"\n","code":"$str1=\"1\"; $str2=\"2\"; print ($str1,$str2(; print ($str1.$str2);\n"},{"code":"$str1=\"1\"; $str2=\"2\"; print ($str1,$str2); print ($str1.$str2);\n","out":"1212","err":""},{"out":"1212","err":"","code":"$str1=\"1\"; $str2=\"2\"; print $str1,$str2; print $str1.$str2;\n"},{"code":"$str = \"123456\"; for($i = 0; $i < length($str)-1; $i+=2) { (substr($str, $i, 1), substr($str, $i+1, 1)) = (substr($str, $i+1, 1), substr($str, $i, 1)); } $str;\n","out":"214365","err":""},{"code":"$str = \"123456\"; $str += 90909\n","out":"214365","err":""},{"code":"$str = \"123456\"; $str += join $., (3 * 3) x 3\n","err":"","out":"215375"},{"err":"","out":"123abc","code":"$str='123abc'; $str =~ +'xyz'; print $str;\n"},{"err":"","out":"[\"|1\",\"|1|2a\",\"|1|2a|3abc\",\"|1|2a|3abc|4abcd\",\"|1|2a|3abc|4abcd|5abcde\"]","code":"$str = '|1|2a|3abc|4abcd|5abcde'; [ map { $str =~ /((?:\\|[^\\|]*){$_})/  } 1..5 ]\n"},{"err":"","out":"1a\n1a\n2s","code":"$str=\"1a2s\"; ($s1, $s3)=$str=~m/\\d\\w/g;  print $s1.\"\\n\"; ($s2)=$str=~m//g;  print $s2.\"\\n\".$s3;\n"},{"out":"1a\n1a\n","err":"","code":"$str=\"1a2s\"; ($s1)=$str=~m/\\d\\w/g;  print $s1.\"\\n\"; ($s2)=$str=~m//g;  print $s2.\"\\n\";\n"},{"code":"$str=\"1a2s\"; $str=~m/(\\d\\w)/g; $s1=$1; print $s1.\"\\n\"; $str=~m//g; $s2=$1; print $s2.\"\\n\";\n","err":"","out":"1a\n2s\n"},{"err":"","out":"ab","code":"$str1=\"a\"; $str2=\"b\"; print $str1=>$str2;\n"},{"out":"4","err":"","code":"$str1 = 'foobar'; $str2 = 'foobiz'; ($str1 ^ $str2) =~ /(^\\0*)/; length $1\n"},{"code":"$str1 = 'foÃ¶bar'; $str2 = 'foobiz'; ($str1 ^ $str2) =~ /(^\\0*)/; length $1\n","err":"","out":"2"},{"out":"5","err":"","code":"$str1 = 'foÃ¶bar'; $str2 = 'foÃ¶biz'; ($str1 ^ $str2) =~ /(^\\0*)/; length $1\n"},{"code":"$str1 = 'foÃ¶obar'; $str2 = 'foÃ¶obiz'; ($str1 ^ $str2) =~ /(^\\0*)/; length $1\n","err":"","out":"6"},{"code":"$str1 = 'foÃ¶obar'; $str2 = 'foÃ¶'; ($str1 ^ $str2) =~ /(^\\0*)/; length $1\n","err":"","out":"4"},{"code":"$str1=\"one\"; $str2=\"two\"; print ($str1,$str1.$str2);\n","err":"","out":"oneonetwo"},{"code":"$str1=\"one\"; $str2=\"two\"; print ($str2.$str1,$str1.$str2);\n","err":"","out":"twooneonetwo"},{"code":"$str=1; printf (\"%.3f\", $str/3);\n","out":"0.333","err":""},{"code":"$str = 'a a a a a a'; /a/g for ($str) x 3; $str =~ s/a\\G/x/; $str\n","err":"","out":"a a x a a a"},{"out":"baaaa","err":"","code":"$str = 'aaaaa'; $str =~ /a/gc for 1,2,3; $str =~ s/a/b/c; $str\n"},{"out":"aaaba","err":"","code":"$str = 'aaaaa'; $str =~ /a/g for 1 .. 3; $str =~ s/\\Ga/b/; $str\n"},{"code":"$str='abc123'; map { s/abc/xyz/g; print } $str;\n","err":"","out":"xyz123"},{"err":"","out":"badcfe","code":"$str = \"abcdef\"; for($i = 0; $i < length($str)-1; $i+=2) { (substr($str, $i, 1), substr($str, $i+1, 1)) = (substr($str, $i+1, 1), substr($str, $i, 1)); } $str;\n"},{"code":"$str=\"abcdefghijklmnopqrstuvwxyz\"; $str=~s/(?<=.{13}).*//; print $str;\n","out":"abcdefghijklm","err":""},{"code":"$str=\"abcdefghijklmnopqrstuvwxyz\"; $str=~s/(?<=.{13}).*/$x=rand(3); $x>1?uc($&):lc($&)/ge; print $str;\n","err":"","out":"abcdefghijklmNOPQRSTUVWXYZ"},{"err":"","out":"\"abc\"\n","code":"$str=\"abcXYZ 123 pdq\"; $str=~s/(?<=.{3}).*//; print \"\\\"$str\\\"\\n\"\n"},{"err":"","out":"ARRAY","code":"$str = [\"a\"..\"m\"]; print ref $str\n"},{"out":"1","err":"","code":"$str.='a'..'m'; print ref $str;\n"},{"code":"$str = [\"a\"..\"m\"]; print scalar $str\n","err":"","out":"ARRAY(0x62a3378)"},{"code":"$str = 'a'..'m'; print $str;\n","err":"","out":"1"},{"code":"$str = [\"a\"..\"m\"]; print @$str\n","err":"","out":"abcdefghijklm"},{"err":"","out":"ARRAY(0x53fa188)","code":"$str = [\"a\"..\"m\"]; print $str\n"},{"err":"","out":"1","code":"$str.='a'..'m'; print $str;\n"},{"code":"$str = 'barfoo'; $str =~ /(?(?{$_=index($str,'foo');$_>0})foo|(*FAIL))/ or 1;\n","out":"1","err":""},{"out":"bleh","err":"","code":"$str=\"bleh\"; $str=~s/(?:test)/$1/; print $str;\n"},{"code":"$str=\"bleh\"; $str=~s/(?test)/$1/; print $str;\n","err":"","out":"ERROR: Sequence (?t...) not recognized in regex; marked by <-- HERE in m/(?t <-- HERE est)/ at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"test","err":"","code":"$str=\"blehtest\"; $str=~s/(?:bleh)/$1/; print $str;\n"},{"code":"$str=\"blehtest\"; $str=~s/(?:test)/$1/; print $str;\n","out":"bleh","err":""},{"code":"$str = \"foo a b = z\"; @a = $str =~ m/( \\w)+/g; \\@a\n","err":"","out":"[\" b\",\" z\"]"},{"out":"[foo]","err":"","code":"$str = '   foo'; $str =~ s/\\A\\s+//; \"[$str]\";\n"},{"code":"$str = '   foo'; $str =~ s/\\A\\s+//; $str;\n","err":"","out":"foo"},{"code":"$str=\"ft\\n\"; chomp $str; $str =~ /ft$/ ? 't' : 'f'\n","out":"t","err":""},{"out":"t","err":"","code":"$str=\"ft\\n\"; $str =~ /ft\\b/ ? 't' : 'f'\n"},{"code":"$str=\"ft\\n\"; $str =~ /ft$/ ? 't' : 'f'\n","out":"t","err":""},{"out":"f","err":"","code":"$str=\"ft\\n\"; $str =~ /ft\\z/ ? 't' : 'f'\n"},{"out":"qr/blabla \\/hallo\\/ xxx/u","err":"","code":"$str = \"/hallo/\"; qr{blabla $str xxx}\n"},{"code":"$str = \"Hey $1.140 $20.568 16.9kg 12.3 2342342.9 Hey\"; $str =~ s/(\\d+\\.\\d+)/sprintf(\"%0.f\")/eg; print $str;\n","out":"Hey .140 .568 0kg 0 0 Hey","err":""},{"code":"$str = \"Hey $1.140 $20.568 16.9kg 12.3 2342342.9 Hey\"; $str =~ s/(\\d+\\.\\d+)/sprintf(\"%0.f\")/g; print $str;\n","err":"","out":"Hey .140 .568 sprintf(\"%0.f\")kg sprintf(\"%0.f\") sprintf(\"%0.f\") Hey"},{"err":"","out":"Hey .140 .568 17kg 12 2342343 Hey","code":"$str = \"Hey $1.140 $20.568 16.9kg 12.3 2342342.9 Hey\"; $str =~ s/(\\d+\\.\\d+)/sprintf(\"%.f\",$1)/eg; print $str;\n"},{"err":"","out":"I am 2000 years old","code":" $str = \"I am 2000 years old\"; $str =~ s/(\\d+(?:\\.\\d+)?)/sprintf('%.f',$1)/er;\n"},{"out":"I bought .4954 worth of oregano","err":"","code":" $str = \"I bought $155.4954 worth of oregano\"; $str =~ s/(\\d+(?:\\.\\d+)?)/sprintf('%.f',$1)/er;\n"},{"out":"matches","err":"","code":"'strike' =~ /(?:anywhere)?/ ? 'matches' : 'bad joke';\n"},{"code":"'strike' =~ /(?anywhere)/ ? 'matches' : 'bad joke';\n","out":"ERROR: Sequence (?any...) not recognized in regex; marked by <-- HERE in m/(?any <-- HERE where)/ at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"string'","err":"","code":"\"string\\'\"\n"},{"code":"$string=\"hello world\"; ($capture) = $string =~ /\\bhello\\b/; print $capture;\n","err":"","out":"1"},{"code":"$string=\"hello world\"; $capture = $string; $capture =~ /hello/; print $capture;\n","out":"hello world","err":""},{"code":"$string=\"hello world\"; $capture = $string; $capture =~ s/.*(hello).*/$1/; print $capture;\n","err":"","out":"hello"},{"code":"$string=\"hello world\"; ($capture) = $string =~ /hello/; print $capture;\n","out":"1","err":""},{"out":"1","err":"","code":"$string=\"hello world\"; $capture = $string =~ /hello/; print $capture;\n"},{"out":"1","err":"","code":"$string=\"hello world\"; ($capture) = $string =~ s/.*(hello).*/$1/; print $capture;\n"},{"code":"$string = \"nah, i don't will hack you. you guys are cool.\"; $string =~ s/\"don't will\"/\"won't\"/g; print $string;\n","err":"","out":"nah, i don't will hack you. you guys are cool."},{"code":"$string = \"nah, i don't will hack you. you guys are cool.\"; $string =~ s/don't will/won't/g; print $string;\n","err":"","out":"nah, i won't hack you. you guys are cool."},{"err":"","out":"bleh","code":"$string = qq/bleh/; print $string;\n"},{"code":"$string = qq/bleh/; print $string => $string;\n","out":"blehbleh","err":""},{"code":"$string=\"xyz357pdq\"; $string=~s/.*357.*/357/g; print $string\n","out":"357","err":""},{"code":"$_ = \"stringy stringy string\"; $f = ~m/ingy/; print $f\n","err":"","out":"18446744073709551614"},{"err":"","out":"I weight 16kg","code":" $str = \"I weight 15.6kg\"; $str =~ s/(\\d+(?:\\.\\d+)?)/sprintf('%.f',$1)/er;\n"},{"err":"","out":"llam","code":"$str = \"llama\"; print substr($str, 0, -1);\n"},{"code":"$str = \"llama\"; print substr($str, -1, 0);\n","out":"1","err":""},{"code":"$str = \"llama\"; print substr($str, 1, -1);\n","out":"lam","err":""},{"code":"$str = \"llama\"; print substr($str, 1, 1);\n","err":"","out":"l"},{"code":"$str = \"llama\"; print substr($str, 1, 2);\n","err":"","out":"la"},{"code":"$str = \"llama\"; print substr($str, 1, 3);\n","out":"lam","err":""},{"code":"$str = 'P98 3G\\xE5\\x85\\xAB\\xE6\\xA0\\xB8(A3HY) Build/KOT49H)'; $str =~ s/\\\\x(..)/chr hex $1/ge; Encode::decode_utf8($str)\n","out":"P98 3GÃÂ¥ÃÂÃÂ«ÃÂ¦ÃÂ ÃÂ¸(A3HY) Build/KOT49H)","err":""},{"out":"P98 3GÃÂ¥ÃÂÃÂ«ÃÂ¦ÃÂ ÃÂ¸(A3HY) Build/KOT49H)","err":"","code":"$str = 'P98 3G\\xE5\\x85\\xAB\\xE6\\xA0\\xB8(A3HY) Build/KOT49H)'; $str =~ s/\\\\x(..)/chr hex $1/ge; $str\n"},{"out":"post Hoc erGo ProptEr Hoc","err":"","code":"$str='post hoc ergo propter hoc'; $str=~s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $str;\n"},{"out":"ok","err":"","code":"$str = \"_\"; print \"ok\" if ($str =~ /\\w/)\n"},{"code":"$str = scalar [\"a\"..\"m\"]; print $str\n","out":"ARRAY(0x4798368)","err":""},{"code":"$str=sprintf(\"%.3f\", 1/3); print $str;\n","out":"0.333","err":""},{"code":"$str=sprintf(%.3f, 1/3); print $str;\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"%.3\"\n"},{"err":"","out":" active/standby","code":"$str=\"status is: active/standby\"; $str =~ s/.*\\://; print $str;\n"},{"err":"","out":"active/standby","code":"$str=\"status is: active/standby\"; $str =~ s/.*\\:\\s+?//; print $str;\n"},{"err":"","out":"stringxyz","code":"$str=\"stringAtostringBxyz\"; $str=~s/A.*B//g; print $str;\n"},{"out":"'","err":"","code":"$str = \"''\"; $str=~ s/\\'\\'/\\'/g; print $str;\n"},{"out":"match","err":"","code":"$str = 'str with [ bracket'; $str =~ /[][]/ ? 'match' : 'no match';\n"},{"out":"[\"s\\303\\203\\302\\274\\303\\203\\302\\237e\",\"s\\x{c3}\\x{bc}\\x{c3}\\x{9f}e\",\"s\\x{fc}\\x{df}e\"]","err":"","code":"$str = \"s\\xc3\\x83\\xc2\\xbc\\xc3\\x83\\xc2\\x9fe\"; [ $str, decode_utf8($str), decode_utf8(decode_utf8($str)) ]\n"},{"err":"","out":"test Test tEst TEst teSt TeSt tESt TESt tesT TesT tEsT TEsT teST TeST tEST TEST ","code":"$str = 'test'; for my $n (0..2**length($str)-1) { $bit = 0; print $str =~ s/([a-z])/$n & 1<<$bit++ ? uc$1 : lc$1/ger, ' ' } # << may be faster\n"},{"code":"$str = 'test'; for my $n (0..2**length($str)-1) { $bit = 0; print $str =~ s/([a-z])/$n & 2**$bit++ ? uc$1 : lc$1/ger, ' ' } # another idea\n","out":"test Test tEst TEst teSt TeSt tESt TESt tesT TesT tEsT TEsT teST TeST tEST TEST ","err":""},{"out":"test Test tEst TEst teSt TeSt tESt TESt tesT TesT tEsT TEsT teST TeST tEST TEST ","err":"","code":"$str = 'test'; for my $n (0..2**length($str)-1) { $bit = 0; print $str =~ s/([a-z])/$n & 2**$bit++ ? uc$1 : lc$1/gier, ' ' } # needs /i (maybe?)\n"},{"code":" $str = âthe 15.7 romulansâ; $str =~ s/((\\d+)(\\.\\d+)?)/int(\\1)/e;\n","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after /; $str = <-- HERE near column 98 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":"","code":" $str = \"the 15.7 romulans\"; $str =~ s/((\\d+)(\\.\\d+)?)/sprintf(\"%.f\",(\\1)/e;\n"},{"out":"1","err":"","code":" $str = \"the 15.7 romulans\"; $str =~ s/((\\d+)(\\.\\d+)?)/sprintf(\"%.f\",\\1)/e;\n"},{"code":" $str = \"the 15.7 romulans\"; $str =~ s/(\\d+(?:\\.\\d+)?)/sprintf('%.f',$1)/er;\n","out":"the 16 romulans","err":""},{"out":"the 93283656 romulans","err":"","code":" $str = \"the 15.7 romulans\"; $str =~ s/(\\d+(?:\\.\\d+)?)/sprintf(\"%.f\",\\1)/er;\n"},{"code":"$str='the quick brown fox jumped over the lazy dogs'; $str=~s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $str;\n","out":"the quiCk brown FOx JumPed ovEr thE lAzy dogS","err":""},{"err":"","out":"(?^ui:brown f) the quick Brown Fox","code":"$str='the quick Brown Fox'; $rex = qr/brown f/i; print $rex; $str =~ $rex; print \" $str\";\n"},{"err":"","out":"(?^ui:brown f) the quick ox","code":"$str='the quick Brown Fox'; $rex = qr/brown f/i; print $rex; $str =~ s/$rex//; print \" $str\";\n"},{"err":"","out":"1","code":"$str='the rain in spain is not a dancer'; print s/e//g;\n"},{"err":"","out":"this iS my leeTsPEaK rEgex","code":"$str='this is my leetspeak regex'; $str=~ s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $str\n"},{"code":"$str='  trim this  '; $str=~s/^\\s+//g; $str=~s/\\s+$//g; print $str;\n","out":"trim this","err":""},{"out":"BAR","err":"","code":"$str = uc(\"foobar\") =~ s/FOO//r; $str\n"},{"code":"$str = undef; print ref $str;\n","out":"1","err":""},{"out":"1","err":"","code":"$str = undef; print $str;\n"},{"out":"[w][i][l][d][c][a][r][d][ ][p][o][r][t][i][o][n]","err":"","code":"$str=\"wildcard portion\"; $str=~s/(.)/\\[$&\\]/g; print $str;\n"},{"out":"[wildcard portion]","err":"","code":"$str=\"wildcard portion\"; $str=~s/wildcar(d.+)tion/\\[$&\\]/g; print $str;\n"},{"code":"$str=\"wildcard portion\"; $str=~s/wildcar(d*+)tion/\\[$&\\]/g; print $str;\n","out":"wildcard portion","err":""},{"code":"$str=\"wildcard portion\"; $str=~s/wildcar(.*)tion/\\[$&\\]/g; print $str;\n","out":"[wildcard portion]","err":""},{"out":"wildcard portion","err":"","code":"$str=\"wildcard portion\"; $str=~s/.*(wild).*/$&/g; print $str;\n"},{"code":"$str=\"wildcard portion\"; $str=~s/(wild)/\\[$&\\]/g; print $str;\n","out":"[wild]card portion","err":""},{"code":"s TT$ Donald Trump\n","out":" ","err":""},{"out":"3","err":"","code":"\"stuff\" . 1 + 3\n"},{"err":"","out":"[1]","code":"['stuff' =~ /(?:(?!stuff).)*/]\n"},{"err":"","out":"1","code":"/(?<!STYLESY0B\\$\\$)/\n"},{"code":"/(?<!STYLESY0B\\$\\$)\\b/\n","out":"","err":""},{"code":"/(?<!STYLESY0B\\$\\$)\\b/i\n","out":"ERROR: Variable length lookbehind not implemented in regex m/(?<!STYLESY0B\\$\\$)\\b/ at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"/(?<!STYLESY0B\\$\\$)/i\n","err":"","out":"ERROR: Variable length lookbehind not implemented in regex m/(?<!STYLESY0B\\$\\$)/ at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: Variable length lookbehind not implemented in regex m/(?<!STYLESY0B\\$\\$)/ at (eval 558) line 1, <STDIN> line 1.\n","code":"/(?<!STYLESY0B\\$\\$)/ia\n"},{"err":"","out":"1","code":"/(?<!STYLESY0B\\$\\$)/iaa\n"},{"code":"(sub ($$) { $$ })->()\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$$) \"\n","err":""},{"out":"","err":"","code":"(sub {}) -> ()\n"},{"code":"[ [ sub {} ] ]\n","out":"[[sub { \"DUMMY\" }]]","err":""},{"err":"","out":"[sub { \"DUMMY\" }]","code":"[ sub {} ]\n"},{"code":"sub ã¨ {}\n","err":"","out":"ERROR: Illegal declaration of anonymous subroutine at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"(sub { ($_[0] = $_), shift for \"another perl Just hacker,\\n\" =~ /\\S+\\s/g })->(qw,s o r t,); print @a;\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"(sub { ($_[0] = $_), shift for \"another perl Just hacker,\\n\" =~ /\\S+\\s/g })->(sort my @a = qw,s o r t,); print @a;\n","out":"Just another perl hacker,\n","err":""},{"out":"","err":"Out of memory!\n","code":"sub { &{$_[0]} }->( sub { &{$_[0]} } )\n"},{"code":"(sub { 1 }) -> ()\n","err":"","out":"1"},{"out":"Just another Perl hacker,","err":"","code":"sub _{@_<2&&return@_;push@{$|--},$_ for@_;map _(@$_),map[splice@$_],0,1}print _ split//,\"huroP cels,tetah Jen akrr\";\n"},{"code":"sub _{@_<2&&return@_;push@{$|--},$_ for@_;map _(@$_),map[splice@$_],0,1}print _ split//,\"Just another Perl hacker,\";\n","out":" uhPakatrrorc  ,tlJenehse","err":""},{"err":"","out":"lur keePr,tsnacert  ahJho","code":"sub _{@_<2&&return@_;push@{$|--},$_ for@_;map _(@$_),map[splice@$_],0,1}print _ split//,\" uhPakatrrorc  ,tlJenehse\";\n"},{"code":"[ sub {42} ]->[0]()  # hehehe\n","out":"42","err":""},{"err":"","out":"42","code":"sub {42}->()  # hehehe\n"},{"code":"[ sub { 55 if 0 }->() ]\n","err":"","out":"[0]"},{"code":"sub { 55 if 0 }->()\n","err":"","out":"0"},{"code":"sub a { (5,7) }; a()->[1]\n","out":"","err":""},{"out":"7","err":"","code":"sub a { (5,7) }; a[1]\n"},{"err":"","out":"7","code":"sub a { (5,7); }  (a(3,1))[1];\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \")[\"\n","code":"sub a { (5,7); }  die (a(3))[1];\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \")[\"\n","err":"","code":"sub a { (5,7); }  die (a(3,1))[1];\n"},{"out":"ERROR: 7 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"sub a { (5,7); }  die +(a(3,1))[1];\n"},{"out":"ERROR: Too many arguments for subroutine at (eval 558) line 1.\n","err":"","code":"sub a () { (5, 7) } print a[1];\n"},{"err":"","out":"2","code":"sub a { @_ } (a 3,2)[1]\n"},{"out":"2","err":"","code":"sub a { @_ }; (a(3,2))[1]\n"},{"code":"sub aãb { \"hi\" } aãb\n","err":"","out":"ERROR: Illegal declaration of subroutine main::a at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \")(\"\n","err":"","code":"sub a { b() } sub b { goto (caller(1))(3) } a()\n"},{"out":"ERROR: Can't find label main::a at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"sub a { b() } sub b { goto (caller(1))[3] } a()\n"},{"err":"Out of memory!\nOut of memory!\n","out":"","code":"sub a { b() } sub b { goto *{+(caller(1))[3]}{CODE} } a()\n"},{"code":"sub accessor { my $self = shift; unless($self->{whatever}) { $self->{whatever} = 'stuff' } } accessor({whatever => 'previous value'}) # obviously no one would write code like that unless they hated the rest of their team, but, y'know. real example, sadly\n","out":"previous value","err":""},{"err":"","out":"6","code":"sub add { $_[0]+1 } add 5\n"},{"out":"4\n","err":"","code":"sub add { $_[0]+$_[1] } say add 2 => 2\n"},{"err":"","out":"3","code":"sub add { my $x = shift; sub { $_[0] + $x } } add(1)->(2)\n"},{"out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$$) \"\n","err":"","code":"sub add ($$) { return $_[0] + $_[1] } my @stuff_from_the_user = (2, 2); add @stuff_from_the_user;\n"},{"out":"Just another Perl hacker,","err":"","code":"sub another'Just { \"Just @_,\" } sub hacker'Perl { \"Perl @_\" }  Just another Perl hacker,\n"},{"out":"[\"xxx\"]","err":"","code":"sub { $anyothername = 'xxx' }->(); [ $anyothername ]\n"},{"code":"sub a { @_ } print a(5,7)[1];\n","out":"ERROR: syntax error at (eval 558) line 1, near \")[\"\n","err":""},{"code":"sub a { return (5, 7); } print (a())[1];\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \")[\"\n"},{"out":"cats","err":"","code":"sub AUTOLOAD { $AUTOLOAD = 'cats' } sub lol { \"lol\" } notlol()\n"},{"out":"lol","err":"","code":"sub AUTOLOAD { $AUTOLOAD = 'lol' } sub lol { \"lol\" } notlol()\n"},{"code":"sub AUTOLOAD { $AUTOLOAD = 'lol' } sub lol { \"verylol\" } notlol()\n","out":"lol","err":""},{"out":"main::hello kitty","err":"","code":"sub AUTOLOAD{ our $AUTOLOAD; my ( $a ) = @_; print \"$AUTOLOAD $a\"; } hello( 'kitty' );\n"},{"code":"sub AUTOLOAD { print \"hi\" } &foo\n","out":"hi","err":""},{"code":"sub AUTOLOAD { print \"hi\" } &{\"foo\"}\n","out":"hi","err":""},{"code":"sub AUTOLOAD { print \"hi\" } foo;\n","out":"foo","err":""},{"err":"","out":"ERROR: Not a CODE reference at (eval 558) line 1, <STDIN> line 1.\n","code":"sub AUTOLOAD { print \"hi\" } $x=\\*foo{CODE}; &$x;\n"},{"code":"sub AUTOLOAD { print \"hi\" } $x=\\*foo; &$x;\n","err":"","out":"ERROR: Not a CODE reference at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"sub AUTOLOAD { say 'test' }; [ 'main'->can('AUTOLOAD') ? 'yes' : 'no' ];\n","err":"","out":"[\"yes\"]"},{"code":"sub bar { $_[0]( $_[1] ) }; bar(sub { $_[0] * 2}, 5)\n","err":"","out":"10"},{"out":"ERROR: Died at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"sub bar { $foo = 0; return $foo || die; } bar();\n"},{"code":"sub bar { $foo = 0; return $foo or die; } bar();\n","err":"","out":"0"},{"code":"sub base { my ($d, $n) = @_; my $r = ''; { my $c = $n % $d; if ($c >= 10) { $c = chr($c - 10 + ord 'a'); } $r .= $c; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 16, 0\n","out":"0","err":""},{"err":"","out":"ff","code":"sub base { my ($d, $n) = @_; my $r = ''; { my $c = $n % $d; if ($c >= 10) { $c = chr($c - 10 + ord 'a'); } $r .= $c; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 16, 255\n"},{"code":"sub base { my ($d, $n) = @_; my $r = ''; { $r .= $n % $d; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 10, 5\n","err":"","out":"5"},{"err":"","out":"ERROR: Illegal modulus zero at (eval 558) line 1, <STDIN> line 1.\n","code":"sub base { my ($d, $n) = @_; my $r = ''; { $r .= $n % d; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 10, 5\n"},{"code":"sub base { my ($d, $n) = @_; my $r = ''; { $r .= $n % $d; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 2, 10\n","out":"1010","err":""},{"code":"sub base { my ($d, $n) = @_; my $r = ''; { $r .= $n % $d; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 2, 5\n","out":"101","err":""},{"err":"","out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/( <-- HERE .{8}/ at (eval 558) line 1, <STDIN> line 1.\n","code":"sub bin2chr { pack 'b8', $_ }   join \"\", map { bin2chr $_ } \"0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010\" =~ m/(.{8}/g;\n"},{"out":"*ÃÂ.\u0016,ÃÂÃÂ¶ÃÂÃÂ¦ÃÂP","err":"","code":"sub bin2chr { pack 'b8', $_ }   join \"\", map { bin2chr $_ } \"0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010\" =~ m/(.{8})/g;\n"},{"code":"sub bin2chr { pack 'B8', $_ }   join \"\", map { bin2chr $_ } \"0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010\" =~ m/(.{8})/g;\n","out":"Tith4cokei\n","err":""},{"code":"sub blah { $_[0]++ } blah(my $val); ++$val\n","err":"","out":"2"},{"code":"sub blah { my @args = @_; return @args[-1]; } blah(0,1,2,3,4,5,6);\n","err":"","out":"6"},{"err":"","out":"3","code":"sub blah { return $_[3] } blah(0,1,2,3,4,5,6);\n"},{"code":"sub blah { \"value\" } blah()\n","err":"","out":"value"},{"err":"","out":"ERROR: Undefined subroutine &WWW::Mechanize called at (eval 558) line 1, <STDIN> line 1.\n","code":"sub buildMech { return WWW::Mechanize->(); } sub zeroMech {my $mech = $_[0]; $$mech->clear_credentials(); } my $mech = zeroMech \\buildMech();\n"},{"err":"","out":"ERROR: Undefined subroutine &WWW::Mechanize called at (eval 558) line 1, <STDIN> line 1.\n","code":"sub buildMech { return WWW::Mechanize->(); } sub zeroMech {my $mech = $_[0]; $$mech->clear_credentials(); } my $mech = zeroMech buildMech();\n"},{"err":"","out":"Bulgaria","code":"sub Bulgaria { print caller; } package Wimbledon; Bulgaria\n"},{"code":"sub Bulgaria { print caller; } package Wimbledon; Bulgaria()\n","out":"ERROR: Undefined subroutine &Wimbledon::Bulgaria called at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"sub c {$_[0]=~/.*\\.(.*)$/;$1} [map c($_), \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\"]\n","err":"","out":"[\"jpg\",\"pdf\",\"\",\"vimrc\",\"pl\"]"},{"out":"[\"jpg\",\"pdf\",\"\",\"vimrc\",\"pl\",undef]","err":"","code":"sub c {$_[0]=~/.*\\.(.*)$/;$1} [map c($_), \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n"},{"out":"[\"cats\"]","err":"","code":"sub catify { $_[0] = \"cats\" } my $x = \"dogs\"; catify $x; [$x]\n"},{"err":"","out":"[0]","code":"sub chomp { \"blah\" }; [ chomp ] # Perl will warn about this with warnings on though\n"},{"code":"sub closure { my $foo; sub { $foo ++ } }; my $sub = closure(); my $other = closure() ; [ $sub->(), $sub->() , $other->(), $other->(), $other->() ] # note that the $foo that belongs to $sub is different from the $foo that $other has... and that they both continue to exist due to there being a reference to a sub in the scope they reside within. see also: coping with scoping\n","err":"","out":"[0,1,0,1,2]"},{"out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$$) \"\n","err":"","code":"sub compare ($$) { $_[1] - $_[0] } [ sort compare -2, 5, 710, 9, 1 ]\n"},{"code":"sub config { my %x = (a => \"b\"); \\%x }; config\n","out":"{a => \"b\"}","err":""},{"code":"sub CONSTANTPLS { 5 } my %stuff = ( +CONSTANTPLS => 7 ); $stuff{+CONSTANTPLS}\n","err":"","out":""},{"code":"sub CONSTANTPLS { 5 } my %stuff = ( CONSTANTPLS() => 7 ); $stuff{CONSTANTPLS()}\n","err":"","out":"7"},{"code":"sub ctx { say wantarray } \\ctx;\n","out":"1\n","err":""},{"err":"","out":"\\1","code":"sub ctx { wantarray // 'undef' } \\ctx;\n"},{"code":"sub curry { my ($f) = @_; sub { my ($x) = @_; sub { my ($y) = @_; $f->($x, $y) } } } sub base { my ($d, $n) = @_; my $r = ''; { my $c = $n % $d; if ($c >= 10) { $c = chr($c - 10 + ord 'a'); } $r .= $c; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } curry(\\&base)->(16)->(255)\n","out":"ff","err":""},{"err":"","out":"[{name => \"x\"},{name => \"y\"},{name => \"z\"}]","code":"sub custom { my ($k) = @_; $a->{$k} cmp $b->{$k} } [ sort { custom('name') } { name => 'x' }, { name => 'y' }, { name => 'z' } ]\n"},{"err":"","out":"d3d12120","code":"sub d { $_[0] < 10 ? $_[0] : (rand >= 0.5 ? 'a' .. 'z' : 'A' .. 'Z')[$_[0] - 10] } sub b { $_ && b($_[0], $_) for int $_[1] / $_[0]; print d $_[1] % $_[0]; } b 14, 1.4e9\n"},{"out":"d3d12120","err":"","code":"sub d { (0 .. 9, 'a' .. 'z')[$_[0]] } sub b { $_ && b($_[0], $_) for int $_[1] / $_[0]; print d $_[1] % $_[0]; } b 14, 1.4e9\n"},{"code":"sub d { (0 .. 9, 'a' .. 'z')[$_[0]] } sub b { $_ && b($_[0], $_) for int $_[1] / $_[0]; print d $_[1] % $_[0]; } b 16, 255\n","out":"ff","err":""},{"code":"sub d { (0 .. 9, 'a' .. 'z')[$_[0]] } sub b { $_ && b($_) for int $_[1] / $_[0]; print d $_[1] % $_[0]; } b 14, 1.4e9\n","err":"","out":"00"},{"code":"sub dieonAg{ $string = shift; if ($string =~ /A[^ab]/) die \"A and not Aa or Ab\"; return $string};   print dieonAg(\"Hi A.\");\n","out":"ERROR: syntax error at (eval 558) line 1, near \") die\"\n","err":""},{"err":"","out":"ERROR: A and not Aa or Ab at (eval 558) line 1, <STDIN> line 1.\n","code":"sub dieonAg{ $string = shift; if( $string =~ /A[^ab]/) {die \"A and not Aa or Ab\"}; return $string};   print dieonAg(\"Hi A.\");\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \") die\"\n","code":"sub dieonAg{ $string = shift; if ($string =~ /A[^ab]/) die \"A and not Aa or Ab\"; return $string};   print dieonAg(\"Hi Ab.\");\n"},{"code":"sub dieonAg{ $string = shift; if( $string =~ /A[^ab]/) {die \"A and not Aa or Ab\"}; return $string};   print dieonAg(\"Hi Ab.\");\n","err":"","out":"Hi Ab."},{"err":"","out":"1","code":"sub do_stuff { my ($thing, @morestuff) = @_; return $thing, @morestuff; } do_stuff(0, 'asdf') ? 1 : 0\n"},{"code":"sub do_stuff { undef $_ } [ map { do_stuff(); $_ } (1,2,3) ]\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"[[312,56],[326,-186]]","code":"sub du { my ($x, $N, $V, $C) = @_; unpack('C', $x) + $C * 256 } sub ds { my ($x, $N, $V, $C) = @_; unpack('C', $x) - ($N ^ $V) * 256 } sub p { pack \"B*\", $_[0] } [ map [du(@$_), ds(@$_)], [p('00111000'), 0, 0, 1], [p('01000110'), 0, 1, 1] ]\n"},{"out":"[[312,56],[326,-186]]","err":"","code":"sub du { my ($x, $N, $V, $C) = @_; $x + $C * 256 } sub ds { my ($x, $N, $V, $C) = @_; $x - ($N ^ $V) * 256 } [ map [du(@$_), ds(@$_)], [0b0011_1000, 0, 0, 1], [0b0100_0110, 0, 1, 1] ]\n"},{"code":"sub eh { print \">\", wantarray, \"<\" } ref(eh)\n","out":"><","err":""},{"out":"2","err":"","code":"sub { eval { return 1 }; return 2 }->()\n"},{"code":"sub f { 1 }; main -> f;\n","err":"","out":"1"},{"err":"","out":"f2f1","code":"sub f1 { print 'f1' } sub f2 { print 'f2' } eval \"f1\\n&f2\"\n"},{"code":"sub f1 { \\@_ } sub f2 { \"f2\" } eval \"f1;\\n&f2\"\n","err":"","out":"f2"},{"code":"sub f1 { \\@_ } sub f2 { \"f2\" } eval \"f1\\n&f2\"\n","err":"","out":"[\"f2\"]"},{"code":"sub f { a => 123 } +{ f() }->{a}\n","out":"123","err":""},{"code":"sub f { (a => 1, b => 2) } my $value = { f() }->{a};\n","out":"1","err":""},{"code":"sub f { my @array = 1..3; return @array } \\f()\n","out":"\\3","err":""},{"code":"sub foo { ${$_[0]} = 123 } foo \\(my $x); $x\n","err":"","out":"123"},{"out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"sub foo { ${$_[0]} = 123 } foo \\undef; $x\n"},{"out":"","err":"","code":"sub foo { $$_[0] = 1 } foo \\(my $x); $x\n"},{"err":"","out":"[0,1,2,3,772,9]","code":"sub foo{$_[0]<=>$_[1]} [sort &foo, qw,1 3 2 772 9,]\n"},{"out":"10","err":"","code":"sub foo { $_[0] * 2 } sub bar { $_[0]( $_[1] ) }; bar(\\&foo, 5)\n"},{"code":"sub foo { $_[0] } \"cats\"->${ \\\\&foo }\n","out":"cats","err":""},{"code":"sub foo { $_[0] } \"cats\"->${ \\&foo }\n","out":"ERROR: Not a SCALAR reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"sub foo {$_[0]=\"cats\"}; foo \"dogs\";  # don't cripple your API for no reason\n","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"sub foo (&) { $_[0]() } foo \\sub {};\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(&)\"\n","err":""},{"out":"[\"Hello Hi\"]","err":"","code":"sub foo { $_[0] .= \"Hi\" } my $x = \"Hello \"; foo($x); [$x]\n"},{"err":"","out":"hi","code":"sub foo { $_[0] = \"hi\"; } sub r_u_kiddin_me { \\@_ } sub bar { local *copy = r_u_kiddin_me @_; foo(@copy); \"@_\" }  $x = \"foo\"; bar $x\n"},{"code":"sub foo { $_[0]++ } my $x = 1; foo($x); $x\n","err":"","out":"2"},{"code":"sub foo { $_[0]++ } my $x = 3; foo($x); [$x] #anno, you were saying?\n","out":"[4]","err":""},{"out":"[\"A\",\"B\",\"C\"]","err":"","code":"sub foo { @{$_[0]}=qw( A B C ); } foo (\\my @y); \\@y;\n"},{"out":"[]","err":"","code":"sub foo { @{$_[0]}=qw( A B C ); } foo [my @y]; \\@y;\n"},{"out":"[]","err":"","code":"sub foo { @{$_[0]}=qw( A B C ); } foo \\(my @y); \\@y;\n"},{"out":"foo","err":"","code":"sub foo { $_[0] =~ s/foo/bar/ } sub bar { foo(@copy = @_); \"@_\" } $x = \"foo\"; bar($x)  # how about this\n"},{"code":"sub foo { $_[0] =~ s/foo/bar/ } sub bar { foo(@_); \"@_\" } $x = \"foo\"; bar($x)\n","err":"","out":"bar"},{"code":"sub foo { 1..10 }; \\foo;\n","err":"","out":"\\10"},{"code":"sub foo { 1, 2, 3 } [ \\foo ]\n","err":"","out":"[\\1,\\2,\\3]"},{"code":"sub foo { 1, 2, 3 } \\foo\n","out":"\\3","err":""},{"err":"","out":"123","code":"sub foo { [1, 2, 3] } { my $arr_ref = foo(); if (@$arr_ref) { print @$arr_ref } }\n"},{"code":"sub foo { 2 } $foo=1; [$foo,foo]\n","err":"","out":"[1,2]"},{"code":"sub foo { 2 }; $foo=1; [$foo,foo]\n","out":"[1,2]","err":""},{"err":"","out":"42","code":"sub foo { 42 } *bar = \\&foo; bar()\n"},{"out":"[sub { \"DUMMY\" }]","err":"","code":"sub FOO () { 42 } [ $::{FOO} ]\n"},{"code":"sub foo { 42 }  *{$main::{foo}}{CODE}\n","out":"ERROR: Not a GLOB reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"sub { \"DUMMY\" }","err":"","code":"sub foo { 42 } our $foo = 2; *{$main::{foo}}{CODE}\n"},{"code":"sub foo { [ @_ ] }; @a = (1,2,3,4); foo(@a)\n","err":"","out":"[1,2,3,4]"},{"code":"sub foo { [ @_ ] }; @a = 1,2,3,4; foo(@a)\n","out":"[1]","err":""},{"code":"sub foo{$a<=>$b} [sort &foo, qw(1 3 2 772 9)]\n","err":"","out":"[0,1,2,3,772,9]"},{"out":"[\\\"a\",\\\"b\",\\\"c\",\\\"d\",\\\"e\",\\\"f\",\\\"g\",\\\"h\",\\\"i\",\\\"j\",\\\"k\",\\\"l\",\\\"m\",\\\"n\",\\\"o\",\\\"p\",\\\"q\",\\\"r\",\\\"s\",\\\"t\",\\\"u\",\\\"v\",\\\"w\",\\\"x\",\\\"y\",\\\"z\"]","err":"","code":"sub foo { 'a'..'z' }; [\\(foo)];\n"},{"code":"sub foo { 'a'..'z' }; [\\foo];\n","out":"[\\\"a\",\\\"b\",\\\"c\",\\\"d\",\\\"e\",\\\"f\",\\\"g\",\\\"h\",\\\"i\",\\\"j\",\\\"k\",\\\"l\",\\\"m\",\\\"n\",\\\"o\",\\\"p\",\\\"q\",\\\"r\",\\\"s\",\\\"t\",\\\"u\",\\\"v\",\\\"w\",\\\"x\",\\\"y\",\\\"z\"]","err":""},{"code":"sub foo { 'a'..'z' }; \\(foo);\n","err":"","out":"\\\"z\""},{"err":"","out":"\\\"z\"","code":"sub foo { 'a'..'z' }; \\foo;\n"},{"code":"sub foo { 'a'..'z' }; \\( (foo)[0..26] );\n","err":"","out":"\\undef"},{"code":"sub Foo::Bar::blah { 'hi' } 'Foo::Bar'->blah\n","out":"hi","err":""},{"code":"sub foo { BLAH: { sub { last BLAH }->(); print \"cats\\n\" } } foo()\n","out":"","err":""},{"code":"sub foo { (caller 0)[3] } foo\n","err":"","out":"main::foo"},{"code":"sub foo {(caller(0))[3]}  foo()\n","out":"main::foo","err":""},{"out":"1","err":"","code":"sub foo { $count++; (1,2,3) } foreach my $x (foo()) { } $count\n"},{"code":"sub Foo { die 'here' } 'Foo'->new\n","err":"","out":"ERROR: Can't locate object method \"new\" via package \"Foo\" (perhaps you forgot to load \"Foo\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"[-1]","code":"sub foo { $#$_; }; [ foo(1 .. 4) ]\n"},{"err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$$) \"\n","code":"sub foo ($$) { [@_] } [ foo 'a', 'b', foo 'c', 'd' ]  # should be [ [ 'a' => 'b' ], [ 'c', 'd' ] ]\n"},{"out":"moo\n","err":"","code":"sub foo; foo \"hi\\n\"; sub foo { print \"moo\\n\"; }\n"},{"out":"foo!","err":"","code":"sub foo { \"foo!\" }; push @x, \\&foo; $x[0]->()\n"},{"err":"","out":"foo!","code":"sub foo { \"foo!\" }; push @x, \\&foo; $x[0]() # I thought the -> was always needed before () - guess not\n"},{"err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, at EOF\n","code":"sub foo (;*); foo($x, $y, length $y);\n"},{"out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(\\\"\n","err":"","code":"sub foo (\\&);  # good luck, what does this even mean\n"},{"code":"sub foo {\" Hello\"}; undef &foo; foo()\n","err":"","out":"ERROR: Undefined subroutine &main::foo called at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"sub foo { \"hi\" } my @x; bless \\@x; (\\@x)->foo\n","out":"hi","err":""},{"code":"sub foo{if (0) {} else {\"nothing\"}} [foo]\n","out":"[\"nothing\"]","err":""},{"out":"[]","err":"","code":"sub foo{if (1) {} else {\"nothing\"}} [foo]\n"},{"code":"sub foo ($is_it) { $is_it } foo \"cats\"\n","out":"cats","err":""},{"code":"sub foo { join '-', @_ } foo 1, 2, 3, \"dogs\"\n","err":"","out":"1-2-3-dogs"},{"err":"","out":"CODE(0x4986790),CODE(0x4986790)","code":"sub foo{}  join \",\", (\\&foo, \\&foo)\n"},{"err":"","out":"CODE(0x6195ab8),CODE(0x6195ab8)","code":"sub foo{}  join \",\", (\\&foo)x2\n"},{"out":"[\"key1\",\"value1\",\"key2\",\"value2\"]","err":"","code":"sub foo { key1 => value1, key2 => value2 } [foo()]\n"},{"out":"ERROR: Can't return array to lvalue scalar context at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"sub foo :lvalue { @foo };  foo() = qw/ One Two Three /;\n"},{"out":"Three","err":"","code":"sub foo :lvalue { $foo };  foo() = qw/ One Two Three /; $foo\n"},{"err":"","out":"ERROR: Undefined subroutine &main::foo called at (eval 558) line 1, <STDIN> line 1.\n","code":"sub foo :lvalue { print \"FOO!\" }  undef &foo; foo()\n"},{"code":"sub foo :lvalue { say wantarray } foo = \"cats\"\n","err":"","out":"\nERROR: Can't return a readonly value from lvalue subroutine at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"sub foo :lvalue { say wantarray; our $foo } foo = \"cats\"\n","out":"\n","err":""},{"err":"","out":"cats","code":"sub foo :lvalue { [wantarray] } foo = \"cats\"\n"},{"code":"sub foo { \\@_ };  [ main::foo(\"bar\"), main->foo(\"bar\") ]\n","err":"","out":"[[\"bar\"],[\"main\",\"bar\"]]"},{"out":"[1,2,3,4,5,6,7,8,9,10]","err":"","code":"sub foo { map { $_ } 1..10; } my $x = [ foo ]; $x;\n"},{"code":"sub foo { map { $_ } 1..10; } my $x = foo; $x;\n","out":"10","err":""},{"out":"\\10","err":"","code":"sub foo { map { $_ } 1..10; } my $x = \\foo; $x; ### Why is this produce a different result?\n"},{"code":"sub foo { map { $_ } qw/a b c/; } my $x = \\foo; $x;\n","out":"\\\"c\"","err":""},{"out":"3","err":"","code":"sub foo { map { $_ } qw/a b c/; } my $x = foo; $x;\n"},{"err":"","out":"[\"the\",\"method\",\"parameters\",\"the\",\"method\",\"parameters\",\"the\",\"method\",\"parameters\"]","code":"sub foo {  map { @_ }  qw/the futures returned/  }     [ foo(qw/the method parameters/) ]\n"},{"err":"","out":"ERROR: Too many arguments for subroutine at (eval 558) line 1.\n","code":"sub foo() { my ($arg1, $arg2) = @_ } foo(1,2)\n"},{"err":"","out":"35","code":"sub foo { my ($arg1, $hashref) = @_; $hashref->{asdf} = 35 } my %hash = (asdf => 55); foo('25', \\%hash); $hash{asdf}\n"},{"err":"","out":"55","code":"sub foo { my ($arg1, $hashref) = @_; $hashref->{asdf} } my %hash = (asdf => 55); foo('25', \\%hash)\n"},{"err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(&@\"\nCan't use global @_ in \"my\" at (eval 558) line 1, near \"= @_\"\nsyntax error at (eval 558) line 1, near \") }\"\nCan't use global @_ in \"my\" at (eval 558) line 1, near \"[@_\"\n","code":"sub foo (&@) { my ($code, @args) = @_; $code->(@args) } my $res = foo { [@_] } 1, 2, 3; $res\n"},{"code":"sub foo { my $c = wantarray; !defined $c ? \"void\" : $c ? \"list\" : \"scalar\" } (foo) x 4\n","err":"","out":"scalarscalarscalarscalar"},{"err":"","out":"[\"list\",\"list\",\"list\",\"list\"]","code":"sub foo { my $c = wantarray; !defined $c ? \"void\" : $c ? \"list\" : \"scalar\" } [(foo) x 4 ]\n"},{"out":"1 1; 1 2; 1 3; 2 1; 2 2; 2 3; 3 1; 3 2; 3 3; ","err":"","code":"sub foo { my ($d, @r) = @_; if ($d < 1) { print \"@r; \"; return; } for my $i (1 .. 3) { foo($d - 1, @r, $i); } } foo 2;\n"},{"code":"sub foo { my $_ = \\@_; $#$_ } [ foo(1..4) ]\n","err":"","out":"[3]"},{"err":"","out":"[\"\"]","code":"sub foo { } my $foo = \\&foo; my $bar = \\&bar; [ $foo eq $bar ]\n"},{"err":"","out":"[1]","code":"sub foo { } my $foo = \\&foo; my $bar = \\&foo; [ $foo == $bar ]\n"},{"err":"","out":"6","code":"sub foo { my ($num, @els) = @_; $num + @els } foo( 3, 1, 2, 3)\n"},{"code":"sub foo { my ($one, $two, $three) = @_; return defined($two) ? \"two is defined\" : \"two is undef\"; } [foo('hello',undef(),'three')]\n","err":"","out":"[\"two is undef\"]"},{"err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$$) \"\n","code":"sub foo ($$) { \\@_ } my @stuff = (1,2,3); foo @stuff\n"},{"code":"sub foo ($$) { \\@_ } my @stuff = (1,2,3); foo @stuff, 5\n","err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$$) \"\n"},{"err":"","out":"foo","code":"sub foo { my $x = $_[0]; $x =~ s/foo/bar/ } sub bar { foo(@_); \"@_\" } $x = \"foo\"; bar($x)\n"},{"code":"sub foo { my $x = 42; sub { eval shift } } foo()->('$x')\n","err":"","out":""},{"code":"sub foo { my $x = 42; sub { $x; eval shift } } foo()->('$x')\n","out":"42","err":""},{"err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$$$\"\n","code":"sub foo($$$) { \"@_\" } my @x = 9..13; foo(@x)\n"},{"code":"sub foo { my $x = do { return 1 }; $x + 1 } foo\n","err":"","out":"1"},{"err":"","out":"[77,\"b\",456,\"a\",123]","code":"sub foo { my ($x, $y, $z, @rest) = @_; bar( $x, @rest ); } sub bar { [ @_ ]; } my %h = ( a => 123, b => 456 ); foo 77, 88, 99, %h;\n"},{"err":"","out":"{RUN1 => [[\"A\",0,\"First\"],[\"B\",1,\"Nested\"],[\"C\",2,\"Nested\"]],RUN2 => [[\"X\",0,\"First\"],[\"Y\",1,\"Nested\"],[\"Z\",2,\"Nested\"]]}","code":"sub Foo { our $nested; local $nested unless $nested; my @p = ( [ shift, $nested // 0, $nested ? q{Nested} : q{First} ] ); {  if ( @_ ) { $nested++; push @p, Foo( @_ ); }  }; if ( $nested ) { $nested--; @p; } else { [ @p ]; } }   { RUN1 => Foo(qw(A B C)), RUN2 => Foo(qw(X Y Z)) };\n"},{"code":"sub Foo { our $nested; local $nested unless $nested; my @p = ( [ shift, $nested ? q{Nested} : q{First} ] ); {  if ( @_ ) { $nested++; push @p, Foo( @_ ); }  }; if ( $nested ) { $nested--; @p; } else { [ @p ]; } }   { RUN1 => Foo(qw(A B C)), RUN2 => Foo(qw(X Y Z)) };\n","err":"","out":"{RUN1 => [[\"A\",\"First\"],[\"B\",\"Nested\"],[\"C\",\"Nested\"]],RUN2 => [[\"X\",\"First\"],[\"Y\",\"Nested\"],[\"Z\",\"Nested\"]]}"},{"code":"sub Foo { our $nested; local $nested unless $nested; my @p = ( [ shift, $nested ? q{Nested} : q{First} ] ); { $nested++; push @p, Foo( @_ ) if @_ }; if ( $nested ) { $nested--; @p; } else { [ @p ]; } } [ Foo( qw( A B C ) ), Foo( qw( X Y Z ) ) ];\n","out":"[[\"A\",\"First\"],[\"B\",\"Nested\"],[\"C\",\"Nested\"],[\"X\",\"First\"],[\"Y\",\"Nested\"],[\"Z\",\"Nested\"]]","err":""},{"err":"","out":"[[\"A\",\"First call\"],[\"B\",\"Nested\"],[\"C\",\"Nested\"],[\"X\",\"First call\"],[\"Y\",\"Nested\"],[\"Z\",\"Nested\"]]","code":"sub Foo { our $p; $p = [ ] unless defined $p; push @$p, [ shift, ( (caller(0))[3] eq (caller(1))[3] ? q{Nested} : q{First call} ) ]; Foo( @_ ) if @_; my $x = $p; $x; } Foo qw( A B C ); Foo qw( X Y Z );\n"},{"code":"sub foo { print \"bar\" }; use constant { baz => *foo }; print $::{baz};\n","err":"","out":"GLOB(0x4cd6b40)"},{"code":"sub foo { print \"bar\" }; use constant { baz => *foo }; print $::{baz}, *foo;\n","err":"","out":"GLOB(0x53f1c98)*main::foo"},{"out":"*main::foo","err":"","code":"sub foo { print \"bar\" }; use constant { baz => *foo }; print main->baz;\n"},{"out":"\n","err":"","code":"sub foo::print { CORE::print \"bar\" }; print foo::; print \"\\n\";\n"},{"out":"1","err":"","code":"sub foo { print \"Debug\\n\", return 1 if (1); } foo();\n"},{"code":"sub foo { print (\"Debug\\n\"), return 1 if (1); } foo();\n","err":"","out":"Debug\n"},{"err":"","out":"Debug\n","code":"sub foo { print(\"Debug\\n\"), return 1 if (1); } foo();\n"},{"code":"sub foo () { print \"-> @_ <-\" } do foo(42);\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"do foo(\"\n"},{"err":"","out":"eh","code":"sub foo { print \"eh\" } foo()\n"},{"out":"foo","err":"","code":"sub foo () { print \"foo\"; };   foo;\n"},{"err":"","out":"quuxbazquux","code":"sub foo { print $foo } sub bar { local $foo = 'baz'; foo }        $foo = 'quux';          foo(); bar(); foo()\n"},{"out":"ERROR: Undefined subroutine &main::foo called at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"sub foo { print \"FOO!\" }  undef &foo; foo()\n"},{"out":"*main::foo","err":"","code":"sub foo { print \"foo\" }; use constant FOO => *foo; print FOO();\n"},{"err":"","out":"*main::foo","code":"sub foo { print \"foo\" }; use constant FOO => *foo; print main->FOO;\n"},{"err":"","out":"SCALAR(0x6646e98): 1 SCALAR(0x6646da8): 2 SCALAR(0x6646eb0): 7 SCALAR(0x6646eb0): 7 SCALAR(0x6646dc0): 5 SCALAR(0x6646eb0): 7 ","code":"sub foo { print \\$_ . \": $_ \" for @_ }; my $x = 1; foo( $x++, $x++, ++$x, ++$x, $x++, ++$x );\n"},{"out":"my arguments are [1 2 3]","err":"","code":"sub foo { print \"my arguments are [@_]\"; } foo(1, 2, 3);\n"},{"out":"my arguments are [42]","err":"","code":"sub foo { print \"my arguments are [@_]\"; } sub { foo(42) }->()\n"},{"err":"","out":"my arguments are [42 1 2 3]","code":"sub foo { print \"my arguments are [@_]\"; } sub { foo(42, @_) }->(1, 2, 3)\n"},{"err":"","out":"my arguments are [42]","code":"sub foo { print \"my arguments are [@_]\"; } sub { foo(42) }->(1, 2, 3)\n"},{"out":"1","err":"Debug\n","code":"sub foo { print (STDERR \"Debug\\n\"), return 1 if (1); } foo();\n"},{"out":"1","err":"Debug\n","code":"sub foo { print (STDERR \"Debug\\n\"); return 1 if (1); } foo();\n"},{"code":"sub foo { print STDERR (\"Debug\\n\"), return 1 if (1); } foo();\n","err":"","out":"1"},{"code":"sub foo { print(STDERR \"Debug\\n\"), return 1 if (1); } foo();\n","out":"1","err":"Debug\n"},{"out":"1","err":"","code":"sub foo { print STDOUT (\"Debug\\n\"), return 1 if (1); } foo();\n"},{"code":"sub foo { print STDOUT (\"Debug\\n\"); return 1 if (1); } foo();\n","err":"","out":"Debug\n1"},{"code":"sub foo :prototype(&@) { my ($code, @args) = @_; $code->(@args) } my $res = foo { [@_] } 1, 2, 3; $res\n","err":"","out":"[1,2,3]"},{"code":"sub foo :prototype($$) { \\@_ } my @stuff = (1,2,3); foo @stuff, 5\n","err":"","out":"[3,5]"},{"out":"8","err":"","code":"sub foo($q) {$q + 3}; foo(5);\n"},{"code":"sub foo { @_ = qw(hello world); } sub bar { &foo; \"@_\" }  bar\n","err":"","out":"hello world"},{"code":"sub foo { @_ = qw(hello world); } sub bar { foo(@_); \"@_\" }  bar\n","out":"","err":""},{"err":"","out":"1","code":"sub foo { return [1, 2, 3] } if (@{(my $arr_ref = foo())}) { print @$arr_ref }\n"},{"err":"","out":"42","code":"sub foo { return(40) + 2 } foo()\n"},{"err":"","out":"[42,42]","code":"sub foo { return 42; }  [ foo(), foo() ]\n"},{"out":"$VAR1 = 'main';\n$VAR2 = '(eval 558)';\n$VAR3 = 1;\n","err":"","code":"sub foo {return caller()} print Dumper(foo());\n"},{"code":"sub foo { return 'foo', 'bar' } sub bar { return map uc, @_ } print bar foo\n","out":"FOOBAR","err":""},{"err":"","out":"bar","code":"sub foo { s/a// }; { my $_ = 'bar'; foo(); print $_ }\n"},{"code":"sub foo { s/a// }; { my $_ = 'bar'; our $_ = 'baz'; foo(); print $_ }\n","out":"bz","err":""},{"code":"sub foo { s/a// }; { my $_ = 'bar'; our $_ = 'baz'; s/a//; print $_ }\n","err":"","out":"bz"},{"code":"sub foo { s/a// }; { my $_ = 'bar'; s/a//; print $_ }\n","out":"br","err":""},{"err":"","out":"123\n","code":"{ sub foo { say } } foo for 123\n"},{"err":"","out":"1\n","code":"sub foo { say wantarray() } \\foo();\n"},{"code":"sub foo { shift()*2 } sub bar :prototype() { shift()*2 } [(foo + 5), (bar + 5)]\n","out":"[10,5]","err":""},{"err":"","out":"[8,8]","code":"sub foo { shift()+3 } sub bar :prototype() { shift()+3 } [(foo + 5), (bar + 5)]\n"},{"code":"sub foo { shift()+3 } sub bar :prototype() { shift()+3 } [foo + 5, bar + 5]\n","out":"[8]","err":""},{"code":"sub foo { shift()+3 } sub bar () { shift()+3 } [foo + 5, bar + 5]\n","err":"","out":"ERROR: Too many arguments for subroutine at (eval 558) line 1.\n"},{"err":"","out":"ERROR: Type of arg 1 to shift must be array (not constant item) at (eval 558) line 1, at EOF\nType of arg 1 to shift must be array (not constant item) at (eval 558) line 1, at EOF\n","code":"sub foo { shift+3 } sub bar () { shift+3 } [foo + 5, bar + 5]\n"},{"out":"{foo => \"bar\"}","err":"","code":"sub foo {shift} { foo => 'bar' }->${ \\\\&foo }\n"},{"out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(\\\"\n","err":"","code":"sub foo (\\&) { shift->() } sub myfunc { say +(caller 0)[3] } foo &myfunc;\n"},{"err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(\\\"\n","code":"sub foo (\\&) { shift->() } sub myfunc { say +(caller 0)[3] } foo myfunc;\n"},{"code":"sub foo; sub AUTOLOAD { print 'hi' } foo;\n","err":"","out":"hi"},{"err":"","out":"","code":"sub foo { sub bar { } }\n"},{"err":"","out":"sub { \"DUMMY\" }","code":"sub foo { __SUB__ } foo\n"},{"out":"[{thingy => 1}]","err":"","code":"sub foo { {thingy => $_[0]} } [foo 1, 2, 3]\n"},{"out":"lol","err":"","code":"sub foo { undef; } my $x = foo() or print \"lol\"\n"},{"code":"sub foo () { wantarray ? \"list\" : \"scalar\" } [ foo x 4 ]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"x 4\"\n"},{"code":"sub foo { wantarray ? \"list\" : \"scalar\" } [ foo x 4 ]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"x 4\"\n","err":""},{"out":"1","err":"had 0 items\n","code":"sub foo { warn \"had \" . @_ . \" items\\n\" } foo(\\(my @x)); # foo is given a list of refs to everything in the list returned by (my @x), i.e. empty list\n"},{"code":"sub foo ($y) { $y++ } my $x = 1; foo($x); $x\n","err":"","out":"1"},{"code":"sub f { return; } @a = f();  print $a[1];\n","err":"","out":"1"},{"code":"sub f{return} for (f) {print 'a' if defined $_}\n","out":"","err":""},{"out":"1","err":"","code":"sub f { return (undef,undef); } @a = f();  print $a[1];\n"},{"err":"","out":"ERROR: Can't localize lexical variable $x at (eval 558) line 1, <STDIN> line 1.\n","code":"sub f { state $x; if ($x) { print \"rec\\n\"; return } local $x = 1; f() }\n"},{"err":"","out":"ERROR: Can't localize through a reference at (eval 558) line 1, <STDIN> line 1.\n","code":"sub f{ state $x; if ($$x) { print \"rec\\n\"; return } local $$x = 1; f() } f()\n"},{"code":"sub f{ state %x; if ($x{rec}) { print \"rec\\n\"; return -3 } local $x{rec} = 1; f() }\n","out":"","err":""},{"code":"sub f{ state %x; if ($x{rec}) { print \"rec\\n\"; return } local $x{rec} = 1; f() }\n","out":"","err":""},{"code":"sub f{ state %x; if ($x{rec}) { print \"rec\\n\"; return } local $x{rec} = 1; f() } f()\n","err":"","out":"rec\n"},{"out":"","err":"","code":"sub f { state %x; print \">$x{rec}<\"; if ($x{rec}) { print \"rec\\n\"; return -3 } local $x{rec} = 1; f() }\n"},{"out":"","err":"","code":"sub f{ statse %x; if ($x{rec}) { print \"rec\\n\"; return } local $x{rec} = 1; f() }\n"},{"code":"sub fwee::poww { 42 } sub gorble::snork { 2 * pop }  snork gorble poww fwee  # it can be made valid perl :)\n","err":"","out":"84"},{"err":"","out":"1","code":"sub get_var { warn \"GET VAR\\n\"; return \\my $var }   ${ get_var } += 1\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"[ sub glob \"\nCan't use global @_ in \"my\" at (eval 558) line 1, near \"return $_\"\nsyntax error at (eval 558) line 1, near \";}\"\n","code":"[ sub glob { my %hash = ( \"*.txt\" => [qw/ 1.txt 2.txt/], \"*.pl\" => [qw/ 1.pl 2.pl/ ], ); return $_[0] ? $hash{$_[0]} || [ \"a.txt\" ] : [ \"a.txt\" ];}@{ &glob($_) }[0] for (qw/ *.pl *.rb /); ]\n"},{"err":"","out":"","code":"sub glob { my %hash = ( \"*.txt\" => [qw/ 1.txt 2.txt/], \"*.pl\" => [qw/ 1.pl 2.pl/ ], ); return $_[0] ? $hash{$_[0]} || [ \"a.txt\" ] : [ \"a.txt\" ];}@{ &glob($_) }[0] for (qw/ *.pl *.rb /);\n"},{"code":"sub greet { my ($name) = @_; print \"hello, $name!\"; } greet(\"lalupa\");\n","err":"","out":"hello, lalupa!"},{"err":"","out":"[1]","code":"(sub { ${^HasBeen} = 1 })->(); [ ${^HasBeen} ]\n"},{"code":"sub hi { print \"hi\" }; $::{wtf} = \\*hi; wft();\n","err":"","out":"ERROR: Undefined subroutine &main::wft called at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"hi","code":"sub hi { print \"hi\" }; $::{wtf} = \\*hi; wtf();\n"},{"err":"","out":"cats","code":"sub href { $_[0]->{Val} = 'cats' } href\n"},{"err":"","out":"ERROR: Illegal declaration of anonymous subroutine at (eval 558) line 1, <STDIN> line 1.\n","code":"sub Ä§ { say \"42\"; } Ä§\n"},{"code":"sub huf { \\1 } ${;huf}\n","err":"","out":"1"},{"out":"72951","err":"","code":"sub hx { sprintf \"%x\", $_[0] } join '0x', hx(0x23267) + hx(0x49684)\n"},{"out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"sub inc { $_+=1 for @_} inc(1,2,3)\n"},{"err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","code":"sub inc { $_+=1 for @_}; inc(1,2,3)\n"},{"code":"sub inc { $_+=1 for @_} my @x = (1,2,3); inc(@x); \\@x\n","err":"","out":"[2,3,4]"},{"code":"sub inc {my ($intref) = @_; ${ $intref }++;} my $i = 0; inc(\\$i); $i\n","err":"","out":"1"},{"code":"sub inner { \"blah\" } sub outer { my $inner = shift; $inner->() } outer \\&inner;\n","err":"","out":"blah"},{"code":"sub ip2num { my @f = split /\\./, shift; $f[0] << 24 | $f[1] << 16 | $f[2] << 8 | $f[3] } [ map { ip2num($_) } (\"2.0.163.49\", \"2.0.168.7\") ]\n","out":"[33596209,33597447]","err":""},{"code":"sub kv(\\%@){my $h = shift; map { $_ => $h->{$_} } @_ }; my %options = (light => 'on', color => 'red', height => 3); my @subset = qw(light color refraction); [\\%options, kv(%options, @subset)]\n","err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(\\\"\nCan't use global @_ in \"my\" at (eval 558) line 1, near \"} @_ \"\nsyntax error at (eval 558) line 1, near \"@_ }\"\n"},{"out":"lala","err":"","code":"sub lala { 'lala' } my $name = 'lala'; my $cref = __PACKAGE__->can('lala'); $cref->()\n"},{"err":"","out":"2","code":"sub lala {my @x = qw(a b c), my @y = qw(d e); (@x, @y)} lala();\n"},{"out":"12345","err":"","code":"sub learn_list_context { my($first,@rest) = (1,2,3,4,5); print $first,@rest; }; learn_list_context\n"},{"out":"[\"a1\",\"b1\",\"b2\",\"a4\",\"c3\",\"d11\",\"d12\",\"a12\",\"c3\"]","err":"","code":"sub letters_from ($) { $_[0] =~ /(\\D+)/; $1 } sub numbers_from ($) { $_[0] =~ /(\\d+)/; $1 } [sort { letters_from $a cmp letters_from $b || numbers_from $a <=> numbers_from $b } qw/a1 b1 b2 a4 c3 d11 d12 a12 c3/]\n"},{"out":"[15,-15]","err":"","code":"sub List::Util::0sum {my ($a, $b)=(0,0); $a+=$_, $b-=$_ for @_; ($a, $b)}; [List::Util::0sum(1,2,3,4,5)]\n"},{"code":"sub local {}  local(-1)\n","out":"ERROR: Can't modify constant item in local at (eval 558) line 1, at EOF\n","err":""},{"err":"","out":"","code":"sub { ${^Local} = 'xxx' }->() [ ${^Local} ]\n"},{"err":"","out":"[\"xxx\"]","code":"sub { ${^Local} = 'xxx' }->(); [ ${^Local} ]\n"},{"code":"sub lol (\\@) { \"$_[0]\" } lol([])\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(\\\"\n","err":""},{"code":"sub lol (\\@) { \"$_[0]\" } my @arr = 1..3; lol(@arr)\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(\\\"\n","err":""},{"code":"sub lol (\\@\\@) { \"$_[0]\" } my @arr = 1..3; lol(@arr, @arr)\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(\\\"\n","err":""},{"err":"","out":"[1]","code":"sub lol { return 0 || 1 } [ lol ]\n"},{"err":"","out":"[0]","code":"sub lol { return 0 or 1 } [ lol ]\n"},{"code":"sub main { bless [] }; [ new main ]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"new main \"\n"},{"out":"sub { \"DUMMY\" }","err":"","code":"sub meow { print @_ } \\&meow\n"},{"err":"","out":"[\"main\",\"lala\"]","code":"sub meth { [@_] } __PACKAGE__->meth('lala')\n"},{"err":"","out":"A:M","code":"sub M::foo { print \"A:@_\" }; sub foo { print \"B:@_\" }; foo M:: , ;\n"},{"out":"A:M","err":"","code":"sub M::foo { print \"A:@_\" }; sub foo { print \"B:@_\" }; foo M:: ;\n"},{"err":"","out":"B:M","code":"sub M::foo { print \"A:@_\" }; sub foo { print \"B:@_\" }; foo( M:: );\n"},{"code":"sub M::foo { print \"A:@_\" }; sub foo { print \"B:@_\" }; foo M:: , 2;\n","err":"","out":"A:M"},{"out":"[\"foo\"]","err":"","code":"sub m() { 'foo' }; sub i() { 'bar' }; [ &m() // i() ]\n"},{"code":"sub m() { 'foo' }; sub i() { 'bar' }; [ m // i ]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"m // i \"\n","err":""},{"err":"","out":"[1]","code":"sub m() { 'foo' }; sub i() { 'bar' }; [ m() || i() ]\n"},{"code":"sub m() { 'foo' }; sub i() { 'bar' }; [ m() // i ]\n","err":"","out":"[1]"},{"code":"sub m() { 'foo' }; sub i() { 'bar' }; [ m() // i() ]\n","out":"[1]","err":""},{"code":"sub MODIFY_SCALAR_ATTRIBUTES { grep $_ ne \"SupposedToBeUndef\", @_[2 .. $#_] } my $foo :SupposedToBeUndef;\n","err":"","out":""},{"err":"","out":"","code":"sub M::TIEARRAY { shift } sub M::FETCH { print \"Element $_[1]\" }  tie my @arr, \"M\";   $arr[123]\n"},{"code":"[ sub { my %a = @_; $a{-something} }->(-something => 'blah') ]\n","out":"[\"blah\"]","err":""},{"code":"{ sub { my %a = @_; $a{-something} }->(-something => 'blah') ]\n","out":"ERROR: syntax error at (eval 558) line 1, near \") ]\"\n","err":""},{"err":"","out":"1","code":"sub mychomp { chomp $_[0] } my $x = \"\\n\"; $x = mychomp($x); $x\n"},{"out":"bless( {foo => \"bar\"}, 'my_class' )","err":"","code":"sub my_class::new { sub { bless { @_ }, 'my_class' } } my_class::new->(foo => 'bar') # you could do that, but it doesn't seem all that useful\n"},{"code":"sub mysort($$) { $_[0] = 'lol'; $_[1] = 'hax' }; @arr = qw(x y z); my @copy = sort mysort @arr; \\@arr\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$$) \"\nsyntax error at (eval 558) line 1, near \"'hax' }\"\n","err":""},{"code":"sub mysort($$) { $_[0] = 'lol'; $_[1] = 'hax' }; @arr = qw(x y z); sort mysort @arr; \\@arr\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$$) \"\nsyntax error at (eval 558) line 1, near \"'hax' }\"\n","err":""},{"out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$$) \"\nsyntax error at (eval 558) line 1, near \"'hax' }\"\n","err":"","code":"sub mysort($$) { $_[0] = 'lol'; $_[1] = 'hax' }; [ sort mysort qw(x y z) ]  # read-only constant\n"},{"code":"sub mysort { warn \"passed as @_,a=$a,b=$b\\n\" } [ sort mysort qw(x y z) ]\n","out":"[\"z\",\"y\",\"x\"]","err":"passed as sub mysort { warn \"passed as @_,a=$a,b=$b\\n\" } [ sort mysort qw(x y z) ],a=x,b=y\npassed as sub mysort { warn \"passed as @_,a=$a,b=$b\\n\" } [ sort mysort qw(x y z) ],a=y,b=z\n"},{"err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$$) \"\n","code":"sub mysort($$) { warn \"passed as @_,a=$a,b=$b\\n\" } [ sort mysort qw(x y z) ] # but passing by reference doesn't sound right\n"},{"out":"1","err":"1, 2, 3 at (eval 558) line 1, <STDIN> line 1.\n","code":"sub my_sub { warn join ', ', @_ } my_sub(1, 2, 3)\n"},{"code":"[sub { my ($x, $y) = @_; ($x*10+$y)}->(5,6)]\n","err":"","out":"[56]"},{"code":"sub new { bless [] }; [ new main ]\n","err":"","out":"[bless( [], 'main' )]"},{"err":"","out":"[bless( [], 'main' )]","code":"sub new { bless [] }; package foo; [ new main ]\n"},{"code":"sub new { bless [] }; package foo; sub new { bless [] }; [ new main ]\n","out":"[bless( [], 'main' )]","err":""},{"code":"sub new { bless [] }; package foo; sub new { bless [] }; [ new(main) ]\n","err":"","out":"[bless( [], 'foo' )]"},{"code":"sub new { bless [] }; package foo; sub new(*) { bless [] }; [ new main ]\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(*)\"\n","err":""},{"code":"sub nextPoT { my %hash; keys %hash = shift; $hash{x} = 1; [split(\"/\", scalar %hash)]->[1] } [ map { nextPoT($_) } (1..20) ]\n","err":"","out":"[8,8,8,8,8,8,8,8,16,16,16,16,16,16,16,16,32,32,32,32]"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \")[\"\n","code":"sub nextPoT { my %hash; keys %hash = shift; $hash{x} = 1; split(\"/\", scalar %hash)[1] } [ map { nextPoT($_) } (1..20) ]\n"},{"code":"sub oldy { return 'goody' }; print &oldy;\n","out":"goody","err":""},{"err":"","out":"[\"obfuscated\",\"is\",\"not\",\"a\",\"goal\"]","code":"sub oldy { return \\@_ } sub goody { &oldy } goody 'obfuscated', 'is', 'not', 'a', 'goal'\n"},{"err":"","out":"[]","code":"sub oldy { return \\@_ } sub goody { oldy } goody 'obfuscated', 'is', 'not', 'a', 'goal'\n"},{"err":"","out":"ERROR: Can't locate object method \"new\" via package \"lowercase sub names are more common in perl\" (perhaps you forgot to load \"lowercase sub names are more common in perl\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"sub Open_Logfile { 'lowercase sub names are more common in perl' } Open_Logfile->new\n"},{"out":"onetwo","err":"","code":"sub outer { my $var if 0; $var = shift; sub inner { print $var||'three' } }   outer(\"one\"); inner(); outer(\"two\"); inner()\n"},{"code":"sub outer { my ($var) = @_; sub inner { print $var } }   outer(\"one\"); inner(); outer(\"two\"); inner()\n","out":"oneone","err":""},{"code":"sub outer { my ($var) = @_; sub inner { print $var||'three' } }    inner(); outer(\"two\"); inner()\n","out":"threetwo","err":""},{"err":"","out":"oneone","code":"sub outer { my ($var) = @_; sub inner { print $var||'three' } }   outer(\"one\"); inner(); outer(\"two\"); inner()\n"},{"out":"oneone","err":"","code":"sub outer { my ($var) = @_; sub inner { print $var//'three' } }   outer(\"one\"); inner(); outer(\"two\"); inner()\n"},{"out":"Just another Perl hacker, ","err":"","code":"sub _ { print /::(.*)/, ' ' }; *AUTOLOAD = *_; Just(), another(), Perl(), &{\"hacker,\"};\n"},{"err":"","out":"scalar","code":"sub { print qw(scalar list void)[wantarray // 2] }->()\n"},{"out":"void","err":"","code":"sub { print qw(scalar list void)[wantarray // 2] }->(); ()\n"},{"code":"() = (sub { print qw(scalar list void)[wantarray // 2] }->()) x 4; ()\n","out":"list","err":""},{"err":"","out":"scalar","code":"(sub { print qw(scalar list void)[wantarray // 2] }->()) x 4; ()\n"},{"out":"scalar","err":"","code":"sub { print qw(scalar list void)[wantarray // 2] }->() x 4; ()\n"},{"out":"","err":"","code":"sub printSvPVIV { printf \"SvPV is %s but SvIV is %d\\n\", $_[0], $_[0] }    $! = 1; print SvPVIV $!\n"},{"err":"","out":"SvPV is Operation not permitted but SvIV is 1\n","code":"sub printSvPVIV { printf \"SvPV is %s but SvIV is %d\\n\", $_[0], $_[0] }    $! = 1; printSvPVIV $!\n"},{"code":"sub :prototype(/user/:user_id) {}\n","out":"ERROR: syntax error at (eval 558) line 1, near \"/user/:\"\n","err":""},{"out":"scalar","err":"","code":"sub { qw(scalar list void)[wantarray // 2] }->()\n"},{"code":"(sub { qw(scalar list)[wantarray] }->()) x 4\n","err":"","out":"scalarscalarscalarscalar"},{"err":"","out":"[\"list\",\"list\",\"list\",\"list\"]","code":"[ (sub { qw(scalar list)[wantarray] }->()) x 4 ]\n"},{"code":"sub { qw(scalar list)[wantarray] }->() x 4\n","err":"","out":"scalarscalarscalarscalar"},{"out":"scalar","err":"","code":"sub { qw(void scalar list)[wantarray + defined wantarray] }->()\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","code":"sub { qw(void scalar list)[wantarray + defined wantarray}->()\n"},{"code":"sub random { (values %{ +{ map { $_,$_ } 1 .. shift }})[0]}\n","out":"","err":""},{"code":"sub random { (values %{ +{ map { $_,$_ } 1 .. shift }})[0]}; random(100);\n","err":"","out":"30"},{"code":"sub range { $_[0] .. $_[1] } $_ = \"4-9\"; [ range /(\\d+)-(\\d+)/ ]\n","out":"[4,5,6,7,8,9]","err":""},{"code":"sub range { $_[0] .. $_[1] } [ range \"4-9\" =~ /(\\d+)-(\\d+)/ ]\n","err":"","out":"[4,5,6,7,8,9]"},{"out":"","err":"","code":"sub { redo }->();\n"},{"out":"","err":"","code":"sub {{redo}}->()\n"},{"code":"sub remove_nth { my ($string, $substring, $n) = @_; my $pos = 0; while ($n > 0) { $pos = index($string, $substring, $pos); $n-- } substr($string, $pos, length($substring), \"\"); return $string }; remove_nth(\"a b c a b\", \"b\", 1)\n","err":"","out":"a  c a b"},{"code":"sub replace_nth { my ($n, $pattern, $replacement, $str) = @_; $str =~ /$pattern/g or return $str for 1 .. $n; substr $str, $-[0], $+[0] - $-[0], $replacement; $str } replace_nth 3, qr/\\w/, 'X', 'hello'\n","out":"ERROR: substr outside of string at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"heXlo","err":"","code":"sub replace_nth { my ($n, $pattern, $replacement, $str) = @_; while ($n > 0) { $str =~ /$pattern/g or last; $n--; if ($n == 0) { substr $str, $-[0], $+[0] - $-[0], $replacement; } } $str } replace_nth 3, qr/\\w/, 'X', 'hello'\n"},{"err":"","out":"heLlo","code":"sub replace_nth { my ($n, $pattern, $repl, $str) = @_; while ($n > 0) { $str =~ /$pattern/g or last; $n--; if ($n == 0) { substr $str, $-[0], $+[0] - $-[0], ref($repl) ? $repl->() : $repl; } } $str } replace_nth 3, qr/(\\w)/, sub { uc $1 }, 'hello'\n"},{"err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","code":" sub replace { s/A/b/ for shift }; replace \"Abc\"\n"},{"err":"","out":"","code":"sub replace{ s/A/b/; return $_}  replace(\"Abc\")\n"},{"err":"","out":"","code":" sub replace { s/A/b/r for shift }; replace \"Abc\"\n"},{"out":"2","err":"","code":"sub ret { eval 1+1; }; print &ret();\n"},{"code":"sub ret { $str=\"some string\"; }; print &ret();\n","out":"some string","err":""},{"code":"sub ret { $str=\"some string\"; }; print &ret; print ret();\n","err":"","out":"some stringsome string"},{"out":"0","err":"","code":"sub return_false { 0 }  my $msg = \"pizza\";   if ( ($msg =~ m/pizza/i) and ( return_false() ) ) { print \"Are we really here?\" } # I can't reproduce from your problem description so far\n"},{"out":"1/8","err":"","code":"(%{sub{ return {hello=>'World'}}->()})\n"},{"code":"[%{sub{ return {hello=>'World'}}->()}]\n","err":"","out":"[\"hello\",\"World\"]"},{"code":"{%{sub{ return {hello=>'World'}}->()}}\n","out":"1/8","err":""},{"err":"","out":"1/8","code":"%{sub{ return {hello=>'World'}}->()}\n"},{"code":"sub{ return {hello=>'World'}}->()\n","out":"{hello => \"World\"}","err":""},{"out":"Just Another Perl Hacker,\n","err":"","code":"sub r{srand$^T; @_}sub b{do{@b=map.5<rand,@_}until grep($_,@b)&&grep(!$_,@b);@b}sub _{print(@_),return if@_<2;my(@L,@R);push@{$_?\\@L:\\@R},shift for&b;_(@L);_(@R)};sub __{1<@_ or return@_;my@b=&b;my$c=grep$_,@b;my@L=__(@_[0..$c-1]);my@R=__(@_[$c..$#_]);map shift@{$_?\\@L:\\@R},@b}_ r __ r split//,\"Just Another Perl Hacker,\\n\";\n"},{"out":"13","err":"","code":"sub r{srand$^T; @_}sub b{do{@b=map.5<rand,@_}until grep($_,@b)&&grep(!$_,@b);@b}sub _{print(@_),return if@_<2;my(@L,@R);push@{$_?\\@L:\\@R},shift for&b;_(@L);_(@R)};sub __{1<@_ or return@_;my@b=&b;my$c=grep$_,@b}_ r __ r split//,\"Just Another Perl Hacker,\\n\";\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"'*' from\"\n","err":"","code":"sub select {} sub from {}; select '*' from;\n"},{"err":"","out":"ERROR: Not enough arguments for select system call at (eval 558) line 1, at EOF\n","code":"sub select {} sub from {}; select '*', from;\n"},{"code":"sub set { [ @_ ] }; set virtualization => \"VBox\";\n","out":"[\"virtualization\",\"VBox\"]","err":""},{"code":"sub set { } set virtualization => \"VBox\";\n","out":"","err":""},{"code":"sub show_args { print join \" \", @{$_[0]} } my @array1 = qw/a b c d/; my @array2 = qw/1 a 3 3 x/; show_args (\\@array1, \\@array2)\n","out":"a b c d","err":""},{"err":"","out":"ARRAY(0x66afa80) ARRAY(0x63ab8e8)","code":"sub show_args { print join \" \", @_ } my @array1 = qw/a b c d/; my @array2 = qw/1 a 3 3 x/; show_args (\\@array1, \\@array2)\n"},{"err":"","out":"a b c d 1 a 3 3 x","code":"sub show_args { print join \" \", @_ } my @array1 = qw/a b c d/; my @array2 = qw/1 a 3 3 x/; show_args (@array1, @array2)  # KURT__\n"},{"out":"[\"before\",\"about to skip\",\"after block\"]","err":"","code":"sub skip { last SOMEBLOCK } my @x = 'before'; SOMEBLOCK: { push @x, 'about to skip'; skip; push @x, 'after skip' } push @x, 'after block'; \\@x\n"},{"code":"sub sneakysub { my %foo; while (each %foo) {} } local $_ = 25; sneakysub(); [$_]\n","err":"","out":"[undef]"},{"out":"5","err":"","code":"sub SOME_CONSTANT { 5 } my %hash = (thing => SOME_CONSTANT); $hash{thing}\n"},{"code":"sub sort { die \"DIE DIE DIE\"; } [ ::sort( 1,2,3 ) ]\n","out":"ERROR: DIE DIE DIE at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"[1,2,3]","err":"","code":"sub sort { die \"DIE DIE DIE\"; } [ sort 1,2,3 ]\n"},{"out":"[1,2,3]","err":"","code":"sub sort { die \"DIE DIE DIE\"; } [ sort( 1,2,3 ) ]\n"},{"out":"","err":"","code":"sub sreturn{} sreturn join(',', @accounts);\n"},{"code":"sub STDOUT::autoflush { die \"Ohnoes!\" }   STDOUT->autoflush(1)\n","err":"","out":"0"},{"err":"","out":"trolled\nERROR: Can't locate object method \"print\" via package \"1\" (perhaps you forgot to load \"1\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"sub STDOUT() {say \"trolled\"} STDOUT->print(123)\n"},{"code":"sub STDOUT () { \\*STDOUT } STDOUT->print(123)\n","err":"","out":"1231"},{"out":"ÃÂÃÂÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂ","err":"","code":"$_=\"ââââ\"; substr($_,0,1,''); $_\n"},{"code":"$_=\"ââââ\"; substr($_,0,1,''); length $_\n","err":"","out":"11"},{"err":"","out":"9","code":"substr 193, 1, 1\n"},{"err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","code":"substr \"4-9\", 1, 1, \"..\" and eval\n"},{"code":"substr \"4-9\", 1, 1, \"..\" && eval\n","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"[\"b\"]","code":"[substr 'abc', 1, -1 ]\n"},{"code":"substr \"abcde\", -1\n","err":"","out":"e"},{"code":"sub strange { \\@_ }; my $foo = strange(my ($bar, $baz, $quux)); for my $i ( 0 .. $#$foo ) { $foo->[$i] = rand }; [ $bar, $baz, $quux ];\n","err":"","out":"[\"0.234415075832175\",\"0.804550846145627\",\"0.903040108593764\"]"},{"err":"","out":" refaliasing lexical_subs postderef_qq signatures/; substr $code, 38","code":"substr $code, 38\n"},{"code":"[ substr \"four\", 0, 6 ]\n","out":"[\"four\"]","err":""},{"code":"substr \"four\", 0, 6\n","out":"four","err":""},{"out":"hell","err":"","code":"substr(\"hello\", 0, -1)\n"},{"err":"","out":"Hello w","code":"substr \"Hello world\", 0, -4\n"},{"err":"","out":"[\"Keihanaikukauakahihu\"]","code":"[ substr \"Keihanaikukauakahihulihe'ekahaunaele\", 0, 20 ] # or Hawaiian names\n"},{"code":"substr(my $F = \"four\",1,0,\"l\"); [$F]\n","err":"","out":"[\"flour\"]"},{"out":"[\"Z\"]","err":"","code":"[substr(\"qqz\", 2) =~ y/z/Z/r]\n"},{"code":"substr \"the_cool_string\", 5\n","out":"ool_string","err":""},{"code":"[ substr unpack(\"b*\", pack \"H*\", \"AB12C0\"), 7, 6 ]\n","out":"[101001]","err":""},{"code":"substr(v1.2.3, 1)\n","out":"\u0002\u0003","err":""},{"code":"$subst = \"s\\xc3\\xbc\\xc3\\x0fe\"; [ $subst, decode_utf8 $subst ]\n","out":"[\"s\\303\\274\\303\\17e\",\"s\\x{fc}\\x{fffd}\\17e\"]","err":""},{"code":"$subst = \"s\\xc3\\xbc\\xc3\\x9fe\"; [ $subst, decode_utf8 $subst ]\n","err":"","out":"[\"s\\303\\274\\303\\237e\",\"s\\x{fc}\\x{df}e\"]"},{"out":"sub { \"DUMMY\" }","err":"","code":"sub { __SUB__ }\n"},{"code":"sub { __SUB__ }->()\n","err":"","out":"sub { \"DUMMY\" }"},{"err":"","out":"[\"oof\"]","code":"sub swap { @_[0,1] = @_[1,0] } my $x = 'foo'; swap(substr($x, 2, 1), substr($x, 0, 1)); [ $x ]\n"},{"err":"","out":"[\"bar\",\"foo\"]","code":"sub swap { @_[0,1] = @_[1,0] } my ($x, $y) = qw(foo bar); swap($x, $y); [ $x, $y ]\n"},{"err":"","out":"3","code":"sub t { 1, 2, 3 } t[0]\n"},{"code":"sub t { 1, 2, 3 } tâ¦0â¦\n","err":"","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after , 2, 3 } t<-- HERE near column 110 at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"42","code":"sub t { 1, 2, 42 } t[0]\n"},{"code":"sub t { 1, 2, 42 } t->[0][1]\n","err":"","out":""},{"code":"sub t { 1, 2, 42 } t[0][1]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"][\"\n","err":""},{"code":"sub take { my ($n, @arr) = @_; @arr[ 0 .. $n - 1 ]} [take 3, 1 .. 20]\n","err":"","out":"[1,2,3]"},{"err":"","out":"[\"don't do this\"]","code":"sub test { \"don't do this\" }; [ test { 'main' } ]\n"},{"out":"{bar => \"foo\"}","err":"","code":"sub test { \"foo\" } my %hash = (bar => test()); \\%hash\n"},{"out":"ERROR: Undefined subroutine &main::foo called at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"sub test { print \"foo\" } my %hash = (bar => foo());\n"},{"code":"sub test { print \"foo\" } my %hash = (bar => test());\n","out":"foo","err":""},{"out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$$) \"\n","err":"","code":"sub thing($$) { }\n"},{"code":"sub tle <>\n","out":"ERROR: Illegal declaration of subroutine main::tle at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"compliant","code":"sub t { \"non-compliant\", \"compliant\" } t[BS-6008]\n"},{"code":"sub t { \"non-compliant\", \"compliant\" } t[ISO-3103]\n","out":"compliant","err":""},{"code":"sub to_cases { map scalar /[[:upper:]]/, split //, shift }; sub caseify { my ($string, $re, $repl) = @_; $string =~ s[($re)][caseify( $repl, to_cases($1) )]ire }; caseify( \"DoÃ\" qr(doÃ), \"cat\" );\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"\"DoÃÂÃÂ\" qr(doÃÂÃÂ)\"\n"},{"code":"sub to_cases { map scalar /[[:upper:]]/, split //, shift }; sub caseify { my ($string, $re, $repl) = @_; $string =~ s[($re)][caseify( $repl, to_cases($1) )]ire }; caseify( \"DoÃ\", qr(doÃ), \"cat\" );\n","err":"","out":"DoÃÂÃÂ"},{"code":"sub to_cases { map scalar /[[:upper:]]/, split //, shift }; sub caseify { my ($string, $re, $repl) = @_; $string =~ s[($re)][caseify( $repl, to_cases($1) )]ire }; caseify( \"DoÃ\", qr(doÃ)i, \"cat\" );\n","out":"cat","err":""},{"code":"sub trololo::b { \"lala\" }; $a = bless {}, \"trololo\"; $a->b\n","err":"","out":"lala"},{"code":"sub trololo::b { \"lala\" }; $a = bless {}, \"trololo\"; say $a->b\n","out":"lala\n","err":""},{"out":"true","err":"","code":"sub true { \"true\" }       my $requesturl = \"/register/?123\"; if($requesturl =~ m!register!io){ return true; }\n"},{"code":"sub unhexstr { (my $ret = shift) =~ s/\\\\x([0-9a-fA-F]{2})/chr hex $1/eg } my $str = q{blah blah \"\\x65\\x66\\x67\" blah blah}; $str =~ s/\"((?:\\\\x[0-9a-fA-F]{2})+)\"/'\"'.unhexstr($1).'\"'/eg; [$str]\n","err":"","out":"[\"blah blah \\\"3\\\" blah blah\"]"},{"err":"","out":"[\"blah blah \\\"\\\\x65\\\\x66\\\\x67\\\" blah blah\"]","code":"sub unhexstr { (my $ret = shift) =~ s/\\x([0-9a-fA-F]{2})/chr hex $1/eg } my $str = q{blah blah \"\\x65\\x66\\x67\" blah blah}; $str =~ s/\"((?:\\x[0-9a-fA-F]{2})+)\"/'\"'.unhexstr($1).'\"'/eg; [$str]\n"},{"err":"","out":"[\"blah blah \\\"\\\\x65\\\\x66\\\\x67\\\" blah blah\"]","code":"sub unhexstr { (my $ret = shift) =~ s/\\x([0-9a-fA-F]{2})/chr hex $1/eg } my $str = q{blah blah \"\\x65\\x66\\x67\" blah blah}; $str =~ s/\"(\\x[0-9a-fA-F]{2}+)\"/'\"'.unhexstr($1).'\"'/eg; [$str]\n"},{"out":"[\"blah blah \\\"efg\\\" blah blah\"]","err":"","code":"sub unhexstr { (my $ret = shift) =~ s/\\\\x([0-9a-fA-F]{2})/chr hex $1/eg; $ret } my $str = q{blah blah \"\\x65\\x66\\x67\" blah blah}; $str =~ s/\"((?:\\\\x[0-9a-fA-F]{2})+)\"/'\"'.unhexstr($1).'\"'/eg; [$str]\n"},{"code":"sub UNIVERSAL::maybe {$class=shift; rand() > 0.5 ? $class->new() : undef}; package bar { sub new {\"Hello World\"};}; bar->maybe()\n","err":"","out":"Hello World"},{"err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(/user/\"\n","code":"sub (/user/:user_id) { $_{user_id} };\n"},{"code":"Sub::Util::prototoype(\\&CORE::die)\n","err":"","out":"ERROR: Undefined subroutine &Sub::Util::prototoype called at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"_","err":"","code":"Sub::Util::prototype(\\&CORE::prototype)\n"},{"out":"list","err":"","code":"\"${\\sub { wantarray() ? 'list' : 'scalar' }->()}\"\n"},{"code":"sub { wantarray ? \"list\" : \"scalar\" }\n","out":"sub { \"DUMMY\" }","err":""},{"err":"","out":"[[]]","code":"sub wa { print '[[' . wantarray . ']]' } split /x/, wa\n"},{"out":"ERROR: the fuck at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"sub what { } what / 25 ; # / ; die \"the fuck\";\n"},{"code":"sub x (\\@) { \"$_[0]\" }; my @a = (3, 4); print x(@a); ()\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(\\\"\n","err":""},{"err":"","out":"2","code":"sub x { (1..3) } (x)[1]\n"},{"out":"ERROR: Too many arguments for subroutine at (eval 558) line 1.\n","err":"","code":" sub x (){1}; x x x x x;\n"},{"code":"sub x (_) { \\@_ } $_ = 'a'; x\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(_\"\n","err":""},{"err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(_\"\n","code":"sub x (_) { \\@_ } $_ = 'a'; $_ x x\n"},{"code":"sub x (_) { \\@_ } $_ = 'a'; x x x\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(_\"\n","err":""},{"out":"ERROR: Too many arguments for subroutine at (eval 558) line 1.\n","err":"","code":"sub x ($) { @_ }; my $x = \\&x; [ join ' ', $x->('a'..'c'), '|', x('a'..'c') ]\n"},{"code":"sub x{my $y=$_; sub { $y++ } } $foo=x(2); [$foo->(),$foo->()]\n","err":"","out":"[0,1]"},{"out":"12\n","err":"","code":"sub x { return [[12, 13]]; } say +(@{x()}[0])[0][0];\n"},{"code":"sub x { return [[12, 13]]; }@{x()}[0]\n","out":"[12,13]","err":""},{"code":"sub x { return [[12, 13]]; } @{x()}[0]->[0]\n","err":"","out":"12"},{"err":"","out":"3","code":"sub x { return (1,2,3) } print( $x = x() );\n"},{"code":"sub x { return (1,2,3) } print( $x = x() ); print 7;\n","err":"","out":"37"},{"out":"2","err":"","code":"sub x { return 2 if (defined shift); return 1 }; x(\"\\0\");\n"},{"code":"sub x { return 2 if (defined shift) }; x(\\0);\n","out":"2","err":""},{"code":"sub x { return (7,8,9) } print( ($x) = x() );\n","out":"7","err":""},{"code":"sub x { return (7,8,9) } print( $x = x() );\n","err":"","out":"9"},{"err":"","out":"main::x","code":"sub x {} Sub::Util::subname(\\&x)\n"},{"err":"","out":"ERROR: Transliteration replacement not terminated at (eval 558) line 1, <STDIN> line 1.\n","code":"sub x { sub y { \"1\" } } y()\n"},{"code":"sub x { sub Y { \"1\" } } Y()\n","out":"1","err":""},{"out":"ERROR: poop at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"sub x {} x || die \"poop\"\n"},{"err":"","out":"2","code":"sub xyz { my @foo = (10, 11); return @foo } $x = xyz(); $x\n"},{"err":"","out":"","code":"sub yz { my $x = @_; return ref($x->[0]) }; return yz({blah=>1},'d');\n"},{"err":"","out":"ERROR: Can't locate object method \"new\" via package \"WWW::Mechanize\" (perhaps you forgot to load \"WWW::Mechanize\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"sub zeroMech { my $mech = shift; $mech->clear_credentials(); } sub buildMech { return zeroMech ( WWW::Mechanize->new() ); } my $mech = buildMech();\n"},{"out":"","err":"","code":"`sudo cpan -i Diagnostics`\n"},{"err":"","out":"ERROR: Regexp modifiers \"/u\" and \"/a\" are mutually exclusive at (eval 558) line 1, near \"; \"\n","code":"s///ugar\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"sum grep\"\n","err":"","code":"sum grep { ($_ % 2) == 0 } @vals;\n"},{"code":"sum map { 1 / $_ } ( 1,3,5,7,9,11,13,15,17 )\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"sum map\"\n"},{"out":"Su-Shee: I've never actually gotten a memo from memoserv so I don't know","err":"","code":"\"Su-Shee: I've never actually gotten a memo from memoserv so I don't know\"\n"},{"out":"0","err":"","code":"@s/ // # whatever\n"},{"out":"1","err":"","code":"/(?<!SX)/i\n"},{"code":"system \"echo\" \"list\";\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"\"echo\" \"list\"\"\n"},{"code":"system(âls /â);\n","err":"","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after /; system(<-- HERE near column 98 at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"; ^\"\n","code":"^T\n"},{"code":"$^T\n","out":"1460502196","err":""},{"code":"@t = (1,2,3,4); splice @t, 0,2, 'a','b'; print @t\n","out":"ab34","err":""},{"out":"[\"a\",\"b\",3,4]","err":"","code":"@t = 1 .. 4; splice @t, 0, 2, qw(a b); \\@t\n"},{"err":"","out":"tacos","code":"\"tacos\"\n"},{"code":"\"\\t\" =~ /[[:cntrl:]]/\n","err":"","out":"1"},{"code":"\"test123Wow\" =~ /^.*(\\d+).*$/g; $1\n","err":"","out":"3"},{"code":"test\" (1 line) at http://fpaste.scsys.co.uk/498962\n","err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"$_ = \"Test4\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"; $_ =~ s/\\0+$//;  $_\n","out":"Test4","err":""},{"err":"","out":"54.65.73.74.34","code":"$_ = \"Test4\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"; $_ =~ s/\\0+$//;  sprintf \"%v.02x\", $_\n"},{"out":"[\"test.,best.\"]","err":"","code":"[ \"(test.,best.)\" =~ /\\(([\\w\\s,\\.]+)\\)/g ]\n"},{"out":"","err":"","code":"\"testfile.csv\" =~ m/(\\.xls$|\\.xlsx$)/\n"},{"code":"\"testfile.csv\" =~ m/(\\.xls$|\\.xlsx$)/ ? \"matches\" : \"doesn't match\"\n","err":"","out":"doesn't match"},{"code":"\"test\" =~ /foo || bar/\n","err":"","out":"1"},{"err":"","out":"[\"test\"]","code":"[ \"test\\n\" =~ m/(.*?)$/s ]\n"},{"out":"[\"testlala lulu\",\"test\\@test\"]","err":"","code":"@test = qw(lala lulu); [\"test@test\", \"test\\@test\"]\n"},{"code":"\"test\" =~ s`e`true`r\n","err":"","out":"ttruest"},{"err":"","out":"1","code":"@test = \"test\"; @_[0] =~ /test/ ? 1 : 0\n"},{"code":"[ 'test' ] == [ 'test' ] ? \"equal\" : \"not equal\"\n","out":"not equal","err":""},{"out":"{Val => \"cats\"}","err":"","code":"$test->{Val} = 'cats'; $test\n"},{"code":"\"test\\x{327}\"\n","err":"","out":"testÃÂÃÂ§"},{"out":"tesÃÂÃÂ","err":"","code":"\"tes\\x{21b}\"\n"},{"err":"","out":"","code":"<text>\n"},{"err":"","out":"[1]","code":"[ 'text text blah text 123 ahoy there' =~ /blah.*\\Kahoy .*/ ]\n"},{"code":"$_ = \"text with-hypenated word-like-things\"; s/(\\w+(?:-\\w+))/lc join \"\", map ucfirst, split \"-\", $1/ge; $_\n","err":"","out":"text withhypenated wordlike-things"},{"code":"$_ = \"text with-hypenated word-like-things\"; s/(\\w+(?:-\\w+)+)/lc join \"\", map ucfirst, split \"-\", $1/ge; $_\n","out":"text withhypenated wordlikethings","err":""},{"code":"thanks\n","err":"","out":"thanks"},{"code":"[ \"the brown dog jumps over the brown fox\" =~ /the|brown|fox/g ]\n","err":"","out":"[\"the\",\"brown\",\"the\",\"brown\",\"fox\"]"},{"code":"[\"the brown fox jumps over the brown dog\" =~ m/brown|dog|the|b/g];\n","err":"","out":"[\"the\",\"brown\",\"the\",\"brown\",\"dog\"]"},{"code":"[\"the brown fox jumps over the lazy dog\" =~ m/brown|dog|the|b/g]\n","err":"","out":"[\"the\",\"brown\",\"the\",\"dog\"]"},{"code":"[\"the brown fox jumps over the lazy dog\" =~ m/b|the|brown|dog/g]\n","err":"","out":"[\"the\",\"b\",\"the\",\"dog\"]"},{"code":"[\"the brown fox jumps over the lazy dog\" =~ m/b|the|dog|brown/g]\n","err":"","out":"[\"the\",\"b\",\"the\",\"dog\"]"},{"out":"[\"cool_string\"]","err":"","code":"[ 'the_cool_string' =~ m[_(.*)] ]\n"},{"code":"\"the_cool_string =~ s/^[^_]+_//;\n","err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","code":"\"the_cool_string =~ s/^[^_]+_//r;\n"},{"err":"","out":"cool_string","code":"\"the_cool_string\" =~ s/^[^_]*_//r\n"},{"code":"\"the_cool_string\" =~ s/^[^_]+_//r;\n","err":"","out":"cool_string"},{"code":"[ 'the_cool_string' =~ s/.*?_//r ]\n","err":"","out":"[\"cool_string\"]"},{"err":"","out":"[\"cool_string\"]","code":"[ 'the_cool_string' =~ s/the_//r ]\n"},{"code":"\"the cow says hello\" =~ /^(the cow says) (moo )+$/\n","err":"","out":""},{"code":"\"the cow says hello\" =~ /^(the cow says) (moo )+$/ ? \"Matches\" : \"Doesn't\"\n","out":"Doesn't","err":""},{"err":"","out":"ERROR: Unknown regexp modifier \"/r\" at (eval 558) line 1, at end of line\nUnknown regexp modifier \"/e\" at (eval 558) line 1, at end of line\n","code":"/the/mreason\n"},{"code":"'the quick brown fox jumped over the lazy dogs' =~ s/(.)/$1^' 'x rand 2/ger\n","out":"The\u0000QUiCk\u0000brOwn fOX jUMPeD\u0000oveR THE\u0000LAZY\u0000dOgs","err":""},{"code":"'the quick brown fox jumped over the lazy dogs' =~ s/([a-z])/$1^' 'x rand 2/ger\n","out":"tHe qUIck bRoWn fOx jumpED OvER THE LAzY dOGs","err":""},{"out":"[\"\",\"\",\"\",\" \",\"\",\"\",\"\",\"\",\"\",\" \",\"\",\"dog\",\" \",\"\",\"\",\"\",\"\",\"\",\"\"]","err":"","code":"[ \"the quick dog jumps\" =~ /\\s*|dog/g ]\n"},{"err":"","out":"just fantasy","code":"(\"the real life\", \"just fantasy\")[!!\"is this\"]\n"},{"err":"","out":"the real life","code":"(\"the real life\", \"just fantasy\")[!\"is this\"]\n"},{"err":"","out":"the real life","code":"(\"the real life\", \"just fantasy\")[(\"is this\",0)[rand 2]]\n"},{"code":"@thingies = split //, 'taco night'; [ @thingies ]\n","out":"[\"t\",\"a\",\"c\",\"o\",\" \",\"n\",\"i\",\"g\",\"h\",\"t\"]","err":""},{"code":"\"@things\"\n","err":"","out":""},{"out":" and that but not ","err":"","code":"\"<this> and that but not <other thing>\" =~ /<this>((?:(?!<other thing>).)*)/; $1\n"},{"err":"","out":"ERROR: Can't call method \"isa\" on an undefined value at (eval 558) line 1, <STDIN> line 1.\n","code":" $this->isa('#perl');\n"},{"err":"","out":"This is a string","code":"\"This is a string\"\n"},{"err":"","out":"[\"this is a string\",\" another string \"]","code":"['{%this is a string%} and this is {% another string %}' =~ m/{%(.+?)%}/g];\n"},{"err":"","out":"[{},{lala => \"is\"}]","code":"'this is a string' =~ /(?<lala>is)/; [\\ %+, {%+}] # funny behavior of %+\n"},{"out":"this is a string","err":"","code":"'{%this is a string%}' =~ m/{%(.+?)%}/; $1;\n"},{"code":"'{%this is\\%} a string%}' =~ m/{%(.+?)%}/; $1;\n","out":"this is\\","err":""},{"code":"[ 'this is a string' =~ s/.{4}\\K/\\n/gr ]\n","out":"[\"this\\n is \\na st\\nring\\n\"]","err":""},{"code":"[ 'this-is-a-string-with-9-something-3ls3' ]\n","out":"[\"this-is-a-string-with-9-something-3ls3\"]","err":""},{"out":"[\"this is a string with 9 something 3ls3\"]","err":"","code":"[ 'this-is-a-string-with-9-something-3ls3' =~ tr/-/ /r ]\n"},{"code":"[ \"this is (a test,a problem)\" =~ /(?:.*\\()?([^,()]+)(?:\\).*)?/g ]\n","err":"","out":"[\"a test\",\"a problem\"]"},{"err":"","out":"[\"a test\",\"a problem\"]","code":"[ \"this is (a test,a problem)\" =~ s/.*\\(|\\).*//gr =~ /[^,]+/g ]\n"},{"code":"[ \"this is (a test,a problem)\" =~ /(?:.*\\()?([\\w ]+)(?:\\).*)?/g ]\n","out":"[\"a test\",\"a problem\"]","err":""},{"code":"[ \"this is (a test,a problem)\" =~ /(?:.*\\()?([\\w ]+)(?:\\).*)?/g ] # in one regex and nothing extra :)\n","out":"[\"a test\",\"a problem\"]","err":""},{"err":"","out":"[\"this is \"]","code":"[ \"this is a test foo\" =~ /((?:(?!test|a)[\\w ])+)/ ] #does this work?\n"},{"code":"[ \"this is a test foo\" =~ /((?:(?!test)[\\w ])+)/ ] # if you want the space after the a\n","out":"[\"this is a \"]","err":""},{"err":"","out":"[\"this is a\"]","code":"[ \"this is a test foo\" =~ /((?:(?! test)[\\w ])+)/ ] #well you can just do this then\n"},{"code":"[ \"this is a test foo\" =~ /([\\w ]+?)(?: test)?/ ]\n","out":"[\"t\"]","err":""},{"err":"","out":"[\"this is a test\"]","code":"[ \"this is a test foo\" =~ /([\\w ]+) (?:test)?/ ]\n"},{"code":"[ \"this is a test foo\" =~ /([\\w ]+)( ?:test)?/ ]\n","err":"","out":"[\"this is a test foo\",undef]"},{"code":"[ \"this is a test foo\" =~ /([\\w ]+)(?: test)?/ ]\n","err":"","out":"[\"this is a test foo\"]"},{"code":"[ \"this is a test foo\" =~ /(\\w+) (?:test)?/ ]\n","out":"[\"this\"]","err":""},{"out":"[1]","err":"","code":"[ \"this is a test foo\" =~ /\\w+ (?:test)?/ ]\n"},{"code":"\"this is a test foo\" =~ /([\\w ]+) (?:test)?/; $1\n","out":"this is a test","err":""},{"code":"[ \"this is a test foo\" =~ /((?:[\\w ](?!test))+)/ ] # is this the kind of thing you're looking for ?\n","out":"[\"this is a\"]","err":""},{"code":"[ \"this is a test foo\" =~ /((?:[\\w ](?!test|yutz|butz))+)/ ]\n","out":"[\"this is a\"]","err":""},{"code":"[ 'this is a test of a few words off the front with trailing text.' =~ /((?:\\s*\\w+){0,5})(.*)/s ]\n","out":"[\"this is a test of\",\" a few words off the front with trailing text.\"]","err":""},{"out":"[\"this is a test of\",\" a few words off the front with trailing text.\"]","err":"","code":"[ 'this is a test of a few words off the front with trailing text.' =~ /((?:\\W*\\w+){0,5})(.*)/s ]  # s/s/W/ better\n"},{"err":"","out":"","code":"$this =~ /is/; $perl;\n"},{"code":"\"this is what I wanted, without the outer @ { } bit:  @{ [ %{ [qw/ foo bar baz /] }[2,1,0] ] }\"\n","out":"this is what I wanted, without the outer @ { } bit:  2 baz 1 bar 0 foo","err":""},{"code":"[ 'this' =~ m|this\\|that|m ];\n","err":"","out":"[1]"},{"err":"","out":"[]","code":"[ 'this' =~ m,this\\|that,m ];\n"},{"out":"[\"is repeated \",\"word \",\"d again\"]","err":"","code":"$_ = 'this repeated word is repeated again along with the word again'; [ /(.{3,})(?=.*?\\1)/g ] # buu  :)\n"},{"out":"1010100 1101000 1101001 1110011 ","err":"","code":"\"This\" =~ s/(.)/sprintf \"%b \", ord $1/gre\n"},{"code":"\\&this_sub_doesnt_exist\n","err":"","out":"sub { \"DUMMY\" }"},{"out":"ERROR: Can't locate object method \"TIEHANDLE\" via package \"foo\" at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"tie *STDOUT, 'foo'; sub foo::new { return bless {} } sub foo::print { print \"TEST\" } print \"hello\"\n"},{"err":"","out":"","code":"tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {},'foo' } sub foo::PRINT { return 42 } print \"hello\"\n"},{"code":"tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {},'foo' } sub foo::PRINT { warn 42 } print \"\"\n","err":"42 at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"out":"","err":"42 at (eval 558) line 1, <STDIN> line 1.\n","code":"tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {},'foo' } sub foo::PRINT { warn 42 } print \"hello\"\n"},{"out":"","err":"","code":"tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {},shift } sub foo::PRINT { print \"TEST\" } print \"hello\"\n"},{"err":"Can't locate object method \"PRINT\" via package \"main\" at /home/ryan/bots/perlbuut/lib/eval.pl line 279, <STDIN> line 1.\n","out":"","code":"tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {} } sub foo::print { print \"TEST\" } print \"hello\"\n"},{"code":"tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {} } sub foo::PRINT { print \"TEST\" } print \"hello\"\n","out":"","err":"Can't locate object method \"PRINT\" via package \"main\" at /home/ryan/bots/perlbuut/lib/eval.pl line 279, <STDIN> line 1.\n"},{"out":"tm605","err":"","code":"$_ = \"tm604\"; $_++; $_\n"},{"code":"\"tm604\" + 1\n","out":"1","err":""},{"out":"I am a link","err":"","code":"$toolType = 'foo'; $fooLink = 'I am a link'; ${$toolType . 'Link'}\n"},{"code":"@topics = qw/alias:topic topic2 topic/; [ map { (/^alias:/ ? $_ : \"alias:$_\") => $_ } @topics ]\n","out":"[\"alias:topic\",\"alias:topic\",\"alias:topic2\",\"topic2\",\"alias:topic\",\"topic\"]","err":""},{"code":"@topics = qw/alias:topic topic2 topic/; %t = map { (/^alias:/ ? $_ : \"alias:$_\") => $_ } @topics; \\%t\n","err":"","out":"{\"alias:topic\" => \"topic\",\"alias:topic2\" => \"topic2\"}"},{"out":"{\"alias:topic\" => \"alias:topic\",\"alias:topic2\" => \"topic2\"}","err":"","code":"@topics = qw/topic topic2 alias:topic/; %t = map { (/^alias:/ ? $_ : \"alias:$_\") => $_ } @topics; \\%t\n"},{"err":"","out":"2","code":"\"--\" =~ tr/-/-/\n"},{"out":"ERROR: Can't modify constant item in transliteration (tr///) at (eval 558) line 1, at EOF\n","err":"","code":"\"--\" =~ tr/-/-1/\n"},{"code":"tree == stone? yes : no\n","out":"ERROR: \"no\" not allowed in expression at (eval 558) line 1, near \": \"\nsyntax error at (eval 558) line 1, near \": no\n\"\n","err":""},{"code":"\"////\" =~ tr!/!!sr\n","out":"/","err":""},{"code":"`true`\n","out":"","err":""},{"err":"","out":"1","code":"'true' == 0 #dbolser, here's something to illustrate your error\n"},{"code":"' ' ? 'true' : 'false'\n","out":"true","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","code":"' ' ? 'true' ? 'false'\n"},{"code":"[ '' ? 'true' : 'false' ]\n","out":"[\"false\"]","err":""},{"code":"[ true == false ]\n","out":"[1]","err":""},{"err":"","out":"true","code":"{} ? \"true\" : \"false\"\n"},{"code":"&({})? \"true\" : \"false\"\n","out":"ERROR: syntax error at (eval 558) line 1, near \"&({\"\n","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"&{\"\n","err":"","code":"&{}? \"true\" : \"false\"\n"},{"err":"","out":"TRUE","code":"\"TRUE\" if \"\\0\\0\"\n"},{"out":"1","err":"","code":"\"\\t\" =~ /\\s/\n"},{"out":"1","err":"","code":"'tshaper.3.input.rate' =~ /(tshaper\\.\\d\\.(?:input|output)\\.rate)/\n"},{"code":"'tshaper.3.output.rate' =~ /(tshaper\\.\\d\\.(?:input|output)\\.rate)/\n","err":"","out":"1"},{"code":"[ -t \\*STDERR ]\n","err":"","out":"[\"\"]"},{"code":"[ -t \\*STDOUT ]\n","err":"","out":"[\"\"]"},{"code":"$t = \"test\"\n","out":"test","err":""},{"err":"","out":"banana","code":"$t = \"This string is multi-line\\nLine 2\\n Last word is banana\"; $t =~ s/.*(?=\\b\\w+\\Z)//s; $t\n"},{"err":"","out":"banana","code":"$t = \"This string is multi-line\\nLine 2\\n Last word is banana\"; $t =~ s/(?s:.*)(?=\\b\\w+\\Z)//; $t # if you can't put a /s modifier\n"},{"code":"$t = \"This string is multi-line\\nLine 2\\n Last word is banana\"; ($t) = $t =~ /(\\S+)\\Z/; $t\n","out":"banana","err":""},{"out":"Two plus Two is 4","err":"","code":"\"Two plus Two is \" . ( 2 + 2 )\n"},{"code":"two + two == five ? \"true\" : \"false\"\n","out":"true","err":""},{"err":"","out":"[\"abc\",\"bat\"]","code":"$type=\"a\"; $stationId=\"b\"; [ grep { /$type/ && /$stationId/ } qw/abc cat bat/ ]\n"},{"out":"","err":"","code":"$^U\n"},{"code":"[ \"Ã¼\" ]\n","err":"","out":"[\"\\303\\274\"]"},{"code":"\"\\u0265\\u01DD\\u028E\"\n","out":"026501DD028E","err":""},{"code":"\"\\UaÃ¤\" # looks right to me, lustiger_seth\n","out":"AÃÂÃÂ¤","err":""},{"out":"Strstr","err":"","code":"ucfirst 'str_str' =~ tr/_//dr;\n"},{"err":"","out":"Str str","code":"ucfirst 'str_str' =~ tr/_/ /r;\n"},{"out":"[\"HELLO CORIN\"]","err":"","code":"[uc \"hello corin\"]\n"},{"code":"\"\\U$code\"\n","out":"USE 5.022001; USE FEATURE QW/POSTDEREF REFALIASING LEXICAL_SUBS POSTDEREF_QQ SIGNATURES/; \"\\U$CODE\"","err":""},{"code":"\"UCS-4\" =~ s/^UCS-?4-?(BE|LE|)?$/UTF-32\\U$1/ir\n","out":"UTF-32","err":""},{"code":"uc 'Ã'\n","out":"ÃÂÃÂ","err":""},{"err":"","out":"ÃÂÃÂ","code":"uc \"Ã\"\n"},{"err":"","out":"","code":"u eq n\n"},{"err":"","out":"[\"FOO\",\"Foo\"]","code":"[\"\\Ufoo\", \"\\ufoo\"]\n"},{"code":"\"\\uhello\"\n","out":"Hello","err":""},{"code":"`uname -a`\n","out":"","err":""},{"err":"","out":"","code":"undef\n"},{"code":"''.undef\n","out":"","err":""},{"out":"\\undef","err":"","code":"'\\undef'\n"},{"err":"","out":"[]","code":"undef // []\n"},{"code":"[ undef == 0]\n","out":"[1]","err":""},{"code":"[ undef => 1 ]\n","err":"","out":"[\"undef\",1]"},{"code":"[ undef != 1 ]\n","out":"[1]","err":""},{"err":"","out":"[1]","code":"[(undef) + 1]\n"},{"code":"undef=>1\n","out":"1","err":""},{"err":"","out":"ERROR: Can't modify constant item in undef operator at (eval 558) line 1, at EOF\n","code":"undef + 1\n"},{"err":"","out":"2","code":"undef // 2\n"},{"out":"ERROR: Can't locate object method \"undefined\" via package \"function\" (perhaps you forgot to load \"function\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"undefined function these\n"},{"code":"$undefined =~ s//bar/;\n","err":"","out":"1"},{"out":"","err":"","code":"undef my $x;\n"},{"code":"[ undef | 'n', 0 | 'n', \"0\" | 'n' ]\n","err":"","out":"[\"n\",0,\"~\"]"},{"code":"undef->${\\rand}\n","out":"ERROR: Can't call method \"0.671273386429192\" on an undefined value at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"(\\undef)->${ +sub { 'here' } }\n","out":"ERROR: Not a SCALAR reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"here","code":"undef->${ \\sub { 'here' } }\n"},{"out":"ERROR: Not a SCALAR reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"undef->${ +sub { 'here' } }\n"},{"err":"","out":"false","code":"undef ? true : false\n"},{"out":"[undef,\"\"]","err":"","code":"[undef, ''.undef]\n"},{"err":"","out":"","code":"undef $_ = undef\n"},{"out":"undef","err":"","code":"$undef=undef; print $undef ? 'true' : 'undef';\n"},{"code":"$undef=undef; print $undef ? 'true' : 'undef'; print \"ERROR: $!\";\n","out":"undefERROR: Too many open files","err":""},{"out":"true","err":"","code":"$undef=undef; print $undef ? 'undef' : 'true';\n"},{"code":"[undef undef undef]\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"undef->{Val} = 'cats'; $test\n","out":"ERROR: Can't use an undefined value as a HASH reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Undefined subroutine &Unicode::UCD::charinfo called at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"Unicode::UCD::charinfo('x')\n"},{"err":"","out":"[undef]","code":"[ UNIVERSAL->can(\"import\") ]\n"},{"code":"[ \"Ã¼nix\", glob \"Ã¼nix\" ] # an amusingly-useful one, pls to not be killing it\n","err":"","out":"[\"\\303\\274nix\",\"\\303\\274nix\"]"},{"code":"unlink '/'\n","err":"","out":"0"},{"code":"unlink \"Jello\"\n","err":"","out":"0"},{"code":"unlink '/' or $!\n","err":"","out":"Is a directory"},{"out":"[\"00\",\"02\",\"02\",\"05\",\"6D\",\"4C\"]","err":"","code":"[ unpack \"(a2)*\", \"000202056D4C\" ]\n"},{"code":"[ unpack \"(a2)8\", \"here is a very long string that is too long for a mere sixteen characters\" ]\n","out":"[\"he\",\"re\",\" i\",\"s \",\"a \",\"ve\",\"ry\",\" l\"]","err":""},{"out":"[\"fo\",\"o \",\"ba\",\"r\"]","err":"","code":"[ unpack '(a2)*', 'foo bar' ]\n"},{"code":"[ unpack '(a3)*', '1234567890' ]\n","err":"","out":"[123,456,789,0]"},{"err":"","out":"[\"abc\",\"def\",\"ghi\"]","code":"[ unpack '(A3)*', 'abcdefghi' ] # liujingtu this is the unpack version\n"},{"code":"[ unpack \"(A4)*\", \"Hello, world!\" ]\n","out":"[\"Hell\",\"o, w\",\"orld\",\"!\"]","err":""},{"out":"[\"3b00\",\"1a28\",1100,\"0012\",\"0000\",\"0000\",\"0000\",\"0046\"]","err":"","code":"[ unpack \"(a4)*\", reverse \"6.4.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.1.0.0.0.0.1.1.8.2.a.1.0.0.b.3\" =~ tr/.//dr ]\n"},{"err":"","out":"[\"this\",\"isat\",\"est\"]","code":"[ unpack \"(a4)*\", \"thisisatest\" ]\n"},{"err":"","out":"[\"ABCD\"]","code":"[ unpack \"a8\", \"ABCD\" ]\n"},{"code":"[unpack(\"b*\",\"01010\")]\n","out":"[\"0000110010001100000011001000110000001100\"]","err":""},{"err":"","out":"[\"0011000000110001001100000011000100110000\"]","code":"[unpack(\"B*\",\"01010\")]\n"},{"err":"","out":"0","code":"unpack \"b\", 0.21875\n"},{"err":"","out":"00001100011101000100110010001100000111001110110010101100","code":"unpack \"b*\", 0.21875\n"},{"code":"unpack 'B*', ~0 # maybe?\n","out":"0011000100111000001101000011010000110110001101110011010000110100001100000011011100110011001101110011000000111001001101010011010100110001001101100011000100110101","err":""},{"code":"[ unpack 'B8', 0x5A ] # see perldoc perlpacktut\n","err":"","out":"[\"00111001\"]"},{"err":"","out":"0","code":"unpack \"b\",87381\n"},{"code":"unpack \"(b8)*\", split ' ', \"text\"\n","out":"10001100","err":""},{"out":"[\"00101010\",\"00010110\",10010110,11001110]","err":"","code":"[ unpack '(b8)*', 'This' ]\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"$entry )\n\"\n","err":"","code":"unpack \"b*\", $entry )\n"},{"code":"unpack \"b*\",(pack \"d\", 0.9999999999999926)\n","err":"","out":"1011110111111111111111111111111111111111111111111111011111111100"},{"code":"[ unpack \"b*\", pack \"H*\", \"AB12C0\" ]\n","err":"","out":"[\"110101010100100000000011\"]"},{"code":"unpack \"b*\",\"$phrase\"\"\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"unpack \"b*\",\"$phrase\" into a variable\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"\"$phrase\" into a \"\n"},{"out":"01010100011010000110100101110011","err":"","code":"unpack \"B*\", \"This\"\n"},{"out":"0010101000010110100101101100111000000100100101101100111000000100100001100000010000101110101001101100111000101110","err":"","code":"unpack \"b*\", \"This is a test\"\n"},{"err":"","out":"[0]","code":"[ unpack 'B', 'wibble' ]\n"},{"code":"[ unpack 'B*', 'wibble' ]\n","out":"[\"011101110110100101100010011000100110110001100101\"]","err":""},{"code":"unpack \"%c\", '1'\n","out":"49","err":""},{"code":"[ unpack \"(C2)*\", \"hello\" ]\n","err":"","out":"[104,101,108,108,111]"},{"err":"","out":"97","code":"unpack \"%c\", 'a'\n"},{"err":"","out":"[97,98,99,100]","code":"[unpack \"C*\", \"abcd\"]\n"},{"code":"[ unpack \"C*\", \"ascii\" ]\n","err":"","out":"[97,115,99,105,105]"},{"err":"","out":"[104,101,108,108,111]","code":"[ unpack \"C*\", \"hello\" ]\n"},{"code":"unpack \"C*\", pack \"n\", 945\n","err":"","out":"3"},{"out":"-128","err":"","code":"unpack('C', \"\\x80\") - 256\n"},{"out":"3030303031633030","err":"","code":"unpack 'H*', '00001c00';\n"},{"code":"unpack(\"H*\", 0x81)\n","out":"313239","err":""},{"out":"01020304","err":"","code":"unpack 'H*', \"\\1\\2\\3\\4\"\n"},{"err":"","out":"[\"76657273696f\"]","code":"[ unpack 'H12', 'version' ]\n"},{"out":"a3","err":"","code":"unpack \"h2\", \":\"\n"},{"code":"unpack \"H2\", \":\"\n","err":"","out":"3a"},{"out":"00","err":"","code":"unpack '(H2)4', pack 'V', 1835008\n"},{"code":"[ unpack \"H2H*\", \"like this\" ]\n","out":"[\"6c\",\"696b652074686973\"]","err":""},{"err":"","out":"3c","code":"unpack \"h2\", \"Ã¶\"\n"},{"code":"unpack '(H2)*', pack 'V', 1835008\n","out":"00","err":""},{"out":"[70,72,65,61,63,74,69,\"6f\",\"6e\"]","err":"","code":"[ unpack \"(H2)*\", \"preaction\" ]\n"},{"err":"","out":"70","code":"unpack \"(H2)*\", \"preaction\"\n"},{"out":"[\"194609193239\"]","err":"","code":"[ unpack \"H*\", \"\\31F\\t\\03129\" ]\n"},{"err":"","out":"4313","code":"unpack 'h*', '41'\n"},{"code":"unpack 'H*', '41'\n","err":"","out":"3431"},{"out":"55000000","err":"","code":"unpack(\"H8\", pack(\"V8\",85))\n"},{"out":"39653962393239363931","err":"","code":"unpack \"H*\", '9e9b929691'\n"},{"code":"unpack 'H*', 'aÌ'\n","err":"","out":"61cc80"},{"out":"c3a0","err":"","code":"unpack 'H*', 'Ã '\n"},{"code":"unpack(\"H*\", chr(1446686042));\n","out":"5a","err":""},{"err":"","out":"122c","code":"unpack 'H*', chr(18).chr(44)\n"},{"out":"0","err":"","code":"unpack '(HH)*', pack 'V', 1835008\n"},{"code":"unpack \"H*\", (\"kitties\" ^ \"nipnips\")\n","err":"","out":"0500041a001500"},{"err":"","out":"[\"ffffffffffff23c0\"]","code":"[ unpack 'H*', pack 'F', (9/10-1)*100 ]\n"},{"out":"214365","err":"","code":"unpack 'H*', pack 'h*', 123456\n"},{"err":"","out":"000003b1b1030000","code":"unpack \"H*\", pack \"NV\", 945, 945\n"},{"err":"","out":"7f000001","code":"unpack \"H*\", v127.0.0.1\n"},{"out":"2231","err":"","code":"unpack \"H*\", \"\\x{22}\\x{31}\"\n"},{"out":"[5,4,3]","err":"","code":"[ unpack \"i<3\", \"\\x05\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x3\\x00\\x00\\x00\" ]\n"},{"code":"[ unpack \"i<\", \"\\x05\\x00\\x00\\x00\" ]\n","out":"[5]","err":""},{"code":"[ unpack \"i>\", \"\\x05\\x00\\x00\\x00\" ]\n","out":"[83886080]","err":""},{"code":"[ unpack \"l>\", \"\\0\\0\\0\\cQ\" ]\n","out":"[17]","err":""},{"out":"825307184","err":"","code":"unpack \"l<\", 0x00.0x00.0x72.0x00\n"},{"code":"unpack \"l\", 0x00.0x00.0x72.0x00\n","err":"","out":"825307184"},{"code":"[ unpack \"(L)4\", \"here is a very long string that is too long for a mere sixteen characters\" ]\n","out":"[1701995880,544434464,1702240353,1814067570]","err":""},{"out":"7471104","err":"","code":"unpack \"l<\", \"\\x00\\x00\\x72\\x00\"\n"},{"code":"unpack \"l>\", \"\\x00\\x00\\x72\\x00\"\n","out":"29184","err":""},{"code":"unpack \"l\", \"\\x00\\x00\\x72\\x00\"\n","err":"","out":"7471104"},{"out":"6","err":"","code":"unpack \"l<\", \"\\x06\\x00\\x00\\x00\";\n"},{"code":"unpack \"n\", 945\n","err":"","out":"14644"},{"err":"","out":"16725","code":"unpack \"n\", \"AU\"\n"},{"code":"[ -~unpack 'N', join '', map chr, '192.168.254.43' =~ /\\d+/g ]\n","out":"[\"-1.84467440704773e+19\"]","err":""},{"err":"","out":"['-1062666709']","code":"[ unpack 'N!', join '', map chr, '192.168.254.43' =~ /\\d+/g ]\n"},{"code":"[ unpack 'N!', pack 'C4', split /\\./, '192.168.254.43' ]\n","err":"","out":"['-1062666709']"},{"err":"","out":"49408","code":"unpack 'N', pack 'h*', '00001c00';\n"},{"out":"7168","err":"","code":"unpack 'N', pack 'H*', '00001c00';\n"},{"out":"[16706,17220]","err":"","code":"[ unpack \"n*\", \"\\x41\\x42\\x43\\x44\" ]\n"},{"err":"","out":"['2338328219397285224','7791360887586431073','7598263559141158511','2338601207764903790']","code":"[ unpack \"(Q)4\", \"here is a very long string that is too long for a mere sixteen characters\" ]\n"},{"code":"[ unpack q{(B8)*}, pack q{C*}, 260 ] ### Why is this only printing one byte when 260 consumes two (8-bit) bytes ?\n","err":"","out":"[\"00000100\"]"},{"code":"[ unpack q{(h4)*}, pack q{(h2)*}, split /\\./, reverse q{6.4.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.1.0.0.0.0.1.1.8.2.a.1.0.0.b.3} ]\n","out":"[\"30b0\",\"0000\",\"10a0\",2080,1010,\"0000\",\"0000\",1020,\"0000\",\"0000\",\"0000\",\"0000\",\"0000\",\"0000\",\"0000\",4060]","err":""},{"code":"[ unpack q{N}, pack q{H8}, q{6060FF} ] # alanjf\n","err":"","out":"[1616969472]"},{"err":"","out":"[]","code":"[ unpack q{N*}, pack q{H*}, q{6060FF} ];\n"},{"code":"unpack( \"q>\", pack \"H*\", \"000001448e317907\" ) / 1000\n","out":"1393955010.823","err":""},{"code":"[ unpack 'q', \"\\xff\" x 8 ]\n","out":"[-1]","err":""},{"err":"","out":"[25960,25970,26912,8307]","code":"[ unpack \"(S)4\", \"here is a very long string that is too long for a mere sixteen characters\" ]\n"},{"out":"858797873","err":"","code":"unpack \"V\", \"1703\"\n"},{"code":"unpack 'V', pack 'h*', '00001c00';\n","err":"","out":"12648448"},{"err":"","out":"1835008","code":"unpack 'V', pack 'H*', '00001c00';\n"},{"code":"unpack \"V\", \"\\x17\\x03\\x01\\x00\"\n","out":"66327","err":""},{"err":"","out":"4690","code":"unpack \"v\", \"\\x52\\x12\"\n"},{"out":"[216]","err":"","code":"[ unpack \"v\", \"\\xd8\\x00\" ]\n"},{"err":"","out":"127.0.0.1","code":"$_=\"us 127.0.0.1 8000\"; (split)[1]\n"},{"code":"usa {STDOUT} 'IO::Handle';\n","out":"ERROR: Can't locate object method \"usa\" via package \"IO::File\" at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use $];\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"use $]\"\n"},{"code":"use 0 warnings;\n","err":"","out":""},{"out":"ERROR: Perl v10.0.0 required--this is only v5.22.1, stopped at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use 10;\n"},{"code":"use 1 strict;\n","out":"","err":""},{"code":"use 2 Moose;\n","err":"","out":""},{"code":"use 2 threads;\n","err":"","out":"ERROR: Can't locate threads.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate strictures.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use 3 strictures;\n"},{"out":"","err":"","code":" use 5.006_001;\n"},{"err":"","out":"","code":"use 5.010;\n"},{"err":"","out":"{}","code":"use 5.010; my $str = \"foo:12 bar:34 baz:45\"; $str =~ /foo:(?<foo>\\d+) bar:(?<bar>\\d+) baz:(?<baz>\\d+)/; \\%+\n"},{"code":"use 5.010; my $x = 42; [  map { my $y = $x++; $y } 0..3 ];\n","out":"[42,43,44,45]","err":""},{"code":"use 5.010; my $x = 42; [  map { state $y = $x++; $y } 0..3 ];\n","err":"","out":"[42,42,42,42]"},{"code":"use 5.010; say((\"a\" x 100000) =~ /^(ab?)*$/ ? \"Yes\" : \"No\");\n","err":"","out":"No\n"},{"out":"Yes\n","err":"","code":"use 5.010; say((\"a\" x 10000) =~ /^(ab?)*$/ ? \"Yes\" : \"No\");\n"},{"code":"use 5.010; say `ls -a`;\n","out":"\n","err":""},{"code":"use 5.010; say \"one\"; say \"two\"\n","err":"","out":"one\ntwo\n"},{"out":"[41,41,1,1,1,1,75,75,\"zof!\",\"zof!\",\"zof!\"]","err":"","code":"use 5.010; sub foo { state $foo = 123; @_ and $foo = shift; $foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo(\"zof!\"), foo, foo]\n"},{"out":"[123,41,41,1,1,1,1,75,75,\"zof!\",\"zof!\",\"zof!\"]","err":"","code":"use 5.010; sub foo { state $foo = 123; @_ and $foo = shift; $foo }; [ foo, foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo(\"zof!\"), foo, foo]\n"},{"err":"","out":"[41,41,1,1,1,1,75,75,\"zof!\",\"zof!\",\"zof!\"]","code":"use 5.010; sub foo { state $foo = shift; @_ and $foo = shift;$foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo(\"zof!\"), foo, foo]\n"},{"out":"[41,41,1,1,1,1,75,75,\"zof!\",\"zof!\",\"zof!\"]","err":"","code":"use 5.010; sub foo { state $foo = shift; if ( @_ ) { $foo = shift; } $foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo(\"zof!\"), foo, foo]\n"},{"code":"use 5.010; sub x :lvalue {state $x; $x} x = 1; { local x = 3; print $x } $x\n","out":"","err":""},{"code":"use 5.010; sub x :lvalue { $x; $x} x = 1; { local x = 3; print $x } $x\n","err":"","out":"3"},{"err":"","out":"1","code":"use 5.012; $foo = 'bar'; ++$$foo; $bar\n"},{"err":"","out":"1","code":"use 5.012; ++$x\n"},{"err":"","out":"foo","code":"use 5.014; $foo = 'foo'\n"},{"code":"use 5.014; state $x = 4; $x\n","out":"4","err":""},{"out":"5","err":"","code":"use 5.014; $x = 5\n"},{"out":"[\"main\",undef]","err":"","code":"use 5.01600; [__PACKAGE__, __SUB__]\n"},{"code":"use 5.016; ++$x\n","out":"1","err":""},{"out":"ERROR: Not an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use 5.018; my %hash;  push $hash{key}, \"more\";  \\%hash\n"},{"code":"use 5.018; print fc(\"Å\") cmp fc(\"z\")\n","err":"","out":"1"},{"err":"error message\n","out":"1","code":"use 5.01; say STDERR \"error message\";\n"},{"code":"use 5.020; fc('er') eq fc('3r')\n","err":"","out":""},{"out":"1","err":"","code":"use 5.020; fc('er') eq fc('er')\n"},{"code":"use 5.020; fc('er') eq fc('Er')\n","err":"","out":"1"},{"err":"","out":"[\"foo\"]","code":"use 5.020; [ fc 'foo' ]; # how do I do this on an older perl?\n"},{"err":"","out":"[\"\\343\\237\"]","code":"use 5.020; [ fc 'Ã' ];\n"},{"out":"[\"\\343\\237\"]","err":"","code":"use 5.020; [ fc 'Ã' ]; # <BenGoldberg>\n"},{"code":"use 5.020; [ fc('Ã') eq fc('ss') ];\n","err":"","out":"[\"\"]"},{"code":"use 5.020; [ fc \"\\xdf\" ]\n","out":"[\"ss\"]","err":""},{"out":"1","err":"","code":"use 5.020; $foo = 'bar'; ++$$foo; $bar\n"},{"out":"foo","err":"","code":"use 5.020; $foo = 'foo'\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"->@* \"\n","err":"","code":"use 5.020; for ( [qw/foo bar/]->@* ) { print}\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"->@*\n\"\n","code":"use 5.020; map print, [1,2,3]->@*\n"},{"code":"use 5.020; my @a = 'a'..'c'; [ %a[0..2] ]\n","err":"","out":"[0,\"a\",1,\"b\",2,\"c\"]"},{"code":"use 5.020; my @a = 'a'..'c'; forhash my ($x, $y) (%a[0..2]) { say \"$x: $y\" }\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"forhash my \"\n"},{"code":"use 5.020; my @a = 'a'..'z'; [ %a[0..20] ]\n","out":"[0,\"a\",1,\"b\",2,\"c\",3,\"d\",4,\"e\",5,\"f\",6,\"g\",7,\"h\",8,\"i\",9,\"j\",10,\"k\",11,\"l\",12,\"m\",13,\"n\",14,\"o\",15,\"p\",16,\"q\",17,\"r\",18,\"s\",19,\"t\",20,\"u\"]","err":""},{"code":"use 5.020; my @a = 'a'..'z'; { %a[0..20] }; # not in order\n","err":"","out":"u"},{"err":"","out":"{18 => \"s\",3 => \"d\",15 => \"p\",19 => \"t\",2 => \"c\",12 => \"m\",14 => \"o\",8 => \"i\",9 => \"j\",13 => \"n\",1 => \"b\",10 => \"k\",20 => \"u\",7 => \"h\",17 => \"r\",5 => \"f\",6 => \"g\",11 => \"l\",4 => \"e\",0 => \"a\",16 => \"q\"}","code":"use 5.020; my @a = 'a'..'z'; +{ %a[0..20] }; # not in order\n"},{"code":"use 5.020; open 'file'\n","out":"","err":""},{"err":"","out":"ERROR: Malformed prototype for main::add: $x = return 0, $y = return $x at (eval 558) line 1, <STDIN> line 1.\n","code":"use 5.020; sub add ($x = return 0, $y = return $x) { return $x + $y }   [ add(), add(2), add(2,3)  ]\n"},{"out":"foobar","err":"","code":"use 5.020; use feature 'postderef'; no warnings 'experimental::postderef'; for ( [qw/foo bar/]->@* ) { print}\n"},{"out":"","err":"Use of uninitialized value in open at (eval 558) line 1, <STDIN> line 1.\n","code":"use 5.020; use warnings; open 'file'\n"},{"code":"use 5.021011; say \"hi\"\n","err":"","out":"hi\n"},{"code":"use 5.022; $foo = 'foo'\n","err":"","out":"foo"},{"err":"","out":"ERROR: Perl v5.100.0 required (did you mean v5.10.0?)--this is only v5.22.1, stopped at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use 5.10;\n"},{"out":"ERROR: Perl v5.140.0 required (did you mean v5.14.0?)--this is only v5.22.1, stopped at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use 5.14; state $x = 4; $x\n"},{"err":"","out":"boo lol baz","code":"use 5.18.0; use experimental 'signatures'; sub foo($bar) {$bar =~ s/baz/boo/r}; print foo(\"baz lol baz\");\n"},{"out":"ERROR: Perl v5.180.0 required (did you mean v5.18.0?)--this is only v5.22.1, stopped at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use 5.18; use experimental 'signatures'; sub foo($bar) {$bar =~ s/baz/boo/r}; print foo(\"baz lol baz\");\n"},{"code":"use 5.20; map print, [1,2,3]->@*\n","err":"","out":"ERROR: Perl v5.200.0 required (did you mean v5.20.0?)--this is only v5.22.1, stopped at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: strict version 6 required--this is only version 1.09 at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use 6 strict;\n"},{"out":"ERROR: Perl v9.0.0 required--this is only v5.22.1, stopped at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use 9;\n"},{"out":"ERROR: Can't locate Acme/Everything.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use Acme::Everything;\n"},{"code":"use Acme::Lvalue;\n","err":"","out":"ERROR: Can't locate Acme/Lvalue.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate Acme/MetaSyntactic.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use Acme::MetaSyntactic; print metaname();\n"},{"code":"use ath; sqrt -1;\n","out":"ERROR: Can't locate ath.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use autodie; my $str = \"foo\"; open( my ($fh), \">\", \\$str ); print $fh; [ $str ];\n","err":"","out":"ERROR: Can't locate autodie.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use base \"Tie::StdHash\";\n","err":"","out":"ERROR: Can't locate Tie/StdHash.pm:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/base.pm line 99, <STDIN> line 1.\n\t...propagated at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/base.pm line 108, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: Can't locate bigfloat.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use bigfloat;\n"},{"err":"","out":"ERROR: Can't locate bigfloat.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use bigfloat;  my $now = 1407974704.32323;  my $Last_Reload_Command = 1407974704.32322; $now - $Last_Reload_Command;\n"},{"code":"use bigint;\n","out":"","err":""},{"code":"use bigint; 100 * 1000\n","out":"bless( {sign => \"+\",value => [100000]}, 'Math::BigInt' )","err":""},{"err":"","out":"bless( {value => [65],sign => \"+\"}, 'Math::BigInt' )","code":"use bigint; 2790**2753 % 3233\n"},{"out":"Altreus","err":"","code":"use bigint; \"Altreus\"\n"},{"code":"use bigint; inf * 3\n","err":"","out":"bless( {_p => undef,value => [0],sign => \"+inf\",_a => undef}, 'Math::BigInt' )"},{"code":"use bignum;\n","out":"ERROR: Can't locate bignum.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Can't locate bignum.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use bignum; 0.1 + 0.2 - 0.3\n"},{"code":"use bignum; 2**88\n","out":"ERROR: Can't locate bignum.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use bignum;  my $now = 1407974704.32323;  my $Last_Reload_Command = 1407974704.32322; $now - $Last_Reload_Command;\n","err":"","out":"ERROR: Can't locate bignum.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: Can't locate bigrat.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use bigrat;\n"},{"out":"[\"\\\"foo\\\\r\\\\n\\\\tbar\\\\n\\\"\"]","err":"","code":"use B 'perlstring'; [perlstring \"foo\\r\\n\\tbar\\n\"]\n"},{"code":"use B 'perlstring'; perlstring \"foo\\r\\n\\tbar\\n\";\n","out":"\"foo\\r\\n\\tbar\\n\"","err":""},{"err":"","out":"\"foo\\r\\n\\tbar\\n\"","code":"use B 'perlstring'; print perlstring \"foo\\r\\n\\tbar\\n\";\n"},{"err":"","out":"[bless( do{\\(my $o = 46841528)}, 'B::GV' )]","code":"use B qw( svref_2object ); [ svref_2object(\\&svref_2object)->GV ]\n"},{"code":"use B $^W++;join(($x)x101)\n","err":"","out":""},{"code":"use bytes; length  pack \"d*\", 1,2,3;\n","err":"","out":"24"},{"code":"use bytes; length  pack \"f*\", 1,2,3;\n","err":"","out":"12"},{"code":"use bytes; length 'sàº²à»'\n","err":"","out":"7"},{"code":"use bytes; $l = \"fooso\"; [ $l & chr(0x80)x(length $l) ] # everything can be turned broken if you want to\n","err":"","out":"[\"\\0\\0\\0\\0\\0\"]"},{"code":"use bytes; $_=\"ââââ\"; substr($_,0,1,''); length $_\n","err":"","out":"11"},{"code":"use Carp; \\ %Carp::CarpInternal\n","out":"{warnings => 1,Carp => 1}","err":""},{"code":"use charnames; charnames::viacode 0x92\n","out":"PRIVATE USE TWO","err":"'use charnames' needs explicit imports list at (eval 558) line 1.\n"},{"code":"use charnames; [ map charnames::viacode(ord), qw(â â â) ]\n","err":"'use charnames' needs explicit imports list at (eval 558) line 1.\n","out":"[\"LATIN SMALL LETTER A WITH CIRCUMFLEX\",\"LATIN SMALL LETTER A WITH CIRCUMFLEX\",\"LATIN SMALL LETTER A WITH CIRCUMFLEX\"]"},{"out":"","err":"Can't locate Config_heavy.pl:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/Config.pm line 80, <STDIN> line 1.\n","code":"use Config; \\%Config\n"},{"err":"","out":"x86_64-linux","code":"use Config; $Config{archname}\n"},{"code":"use Config; $Config{longdouble}\n","err":"","out":"ERROR: Can't locate Config_heavy.pl:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/Config.pm line 80, <STDIN> line 1.\n"},{"err":"","out":"ERROR: Can't locate Config_heavy.pl:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/Config.pm line 80, <STDIN> line 1.\n","code":"use Config; $Config{myuname}\n"},{"code":"use Config; $Config{nvsize}\n","err":"","out":"ERROR: Can't locate Config_heavy.pl:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/Config.pm line 80, <STDIN> line 1.\n"},{"err":"","out":"linux","code":"use Config; $Config{osname}\n"},{"code":"use Config; $Config{uname}\n","out":"ERROR: Can't locate Config_heavy.pl:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/Config.pm line 80, <STDIN> line 1.\n","err":""},{"out":"ERROR: Can't locate Config_heavy.pl:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/Config.pm line 80, <STDIN> line 1.\n","err":"","code":"use Config; $Config{use64bitint};\n"},{"err":"","out":"ERROR: Can't locate Config_heavy.pl:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/Config.pm line 80, <STDIN> line 1.\n","code":"use Config; [ grep { $_ } map { s/^\"(.*?)\"$/$1/r } split /,/, $Config{inc_version_list_init} ]\n"},{"out":"x86_64-linux","err":"","code":"use Config; print $Config{archname}\n"},{"code":"use constant '4' => 'ok'; &{4};\n","err":"","out":"ERROR: Constant name '4' has invalid characters at (eval 558) line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"use constant 4 =>\"\n","err":"","code":"use constant 4 => 'ok'; &{4};\n"},{"code":"use constant A => [1..5]; sub TIESCALAR { bless [] }; sub FETCH { 42 }; tie ${\\(A->[2])}, 'main'; A;\n","err":"","out":"[1,2,42,4,5]"},{"out":"sub { \"DUMMY\" }","err":"","code":"use constant A => [1..5]; sub TIESCALAR { bless [] }; sub FETCH { 42 }; tie ${\\(A->[2])}, 'main'; sub { A };\n"},{"err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","code":"use constant A => \"constant?\"; sub TIESCALAR { bless [] }; sub FETCH { \"mutable!\" }; tie ${\\(A)}, 'main'; A;\n"},{"code":"use constant cat => 1; cat while $x++<1\n","err":"","out":""},{"out":"1","err":"","code":"use constant; constant::_CAN_PCS();\n"},{"code":"use constant C => 'XXX'; 'foobarbaz' =~ s/bar/C/er\n","out":"fooXXXbaz","err":""},{"err":"","out":"fooXXXbaz","code":"use constant C => 'XXX'; 'foobarbaz' =~ s/bar/${\\C}/r\n"},{"err":"","out":"[\\42]","code":"use constant FOO => 42; [ $::{FOO} ]\n"},{"out":"*main::FOO","err":"","code":"use constant FOO => 42; $FOO = 43; $::{FOO}\n"},{"err":"","out":"[sub { \"DUMMY\" }]","code":"use constant FOO => 42; [ *FOO{CODE} ]\n"},{"code":"use constant { FOO => 42 }; +{ +FOO => \"test\" }\n","err":"","out":"{FOO => \"test\"}"},{"code":"use constant { FOO => 42 }; +{ FOO => \"test\" }\n","out":"{FOO => \"test\"}","err":""},{"code":"use constant { FOO => 42 }; +{ FOO() => \"test\" }\n","err":"","out":"{42 => \"test\"}"},{"code":"use constant FOO => 42; { local *FOO = sub () { \"k\" }; &FOO() }\n","out":"k","err":""},{"code":"use constant FOO => 42; [ main->FOO ]\n","out":"[42]","err":""},{"out":"BAR!\n","err":"","code":"use constant FOO => 'BAR!'; BEGIN { say FOO }\n"},{"out":"bar","err":"","code":"use constant FOO => \"bar\"; \"${\\FOO}\"\n"},{"code":"use constant FOO => 'bar'; [&FOO => 'bar']\n","out":"[\"bar\",\"bar\"]","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"){\"\n","err":"","code":"use constant FOO => 'bar'; (FOO() => 'baz'){+FOO}\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"}->\"\n","code":"use constant FOO => 'bar'; {FOO() => 'baz'}->{+FOO}\n"},{"err":"","out":"baz","code":"use constant FOO => 'bar'; +{FOO() => 'baz'}->{+FOO}\n"},{"err":"","out":"BAR!\nMoar BAR!!\n","code":"use constant FOO => 'BAR!'; our $dir = FOO; BEGIN { say FOO } say \"Moar $dir!\"\n"},{"out":"{FOO => 2,dogs => 1}","err":"","code":"use constant FOO => \"dogs\"; +{ FOO => 213, FOO() => 1, +FOO => 2 }\n"},{"out":"-Inf","err":"","code":"use constant { Inf => 0 + 'inf', NaN => 0 + 'nan' }; Inf * -1\n"},{"err":"","out":"qr/\\p{IsProhibited}/u","code":"use constant IsProhibited => ''; qr/\\p{IsProhibited}/\n"},{"code":"use constant list => qw(a b c); [list]\n","out":"[\"a\",\"b\",\"c\"]","err":""},{"code":"use constant PARENT_CLASS => 'Legacy'; BEGIN { package Legacy; $INC{\"Legacy.pm\"} = 1} { package Shim; use parent main::PARENT_CLASS; } Shim->isa('Legacy') ? 'true' : 'false'\n","err":"","out":"true"},{"out":"Pi equals 3.14159265358979...\n","err":"","code":"use constant PI    => 4 * atan2(1, 1); print \"Pi equals \", PI, \"...\\n\";\n"},{"err":"","out":"1","code":"use constant; print constant::_CAN_PCS;\n"},{"err":"","out":"[1,\"TEST1\",1]","code":"use constant TEST2 => TEST1; use constant TEST1 => 1; use constant TEST3 => TEST1; [TEST1, TEST2, TEST3]\n"},{"code":"use constant XXX => 'test'; \"@{[ XXX ]} or ${\\XXX} or \" . XXX\n","out":"test or test or test","err":""},{"code":"use CPAN; install(\"Time::Moment\")\n","out":"ERROR: Can't locate CPAN.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use Cwd; print cwd();\n","out":"1","err":""},{"err":"","out":"1","code":"use Cwd qw(); print Cwd::cwd();\n"},{"out":"ERROR: Can't locate Data/Dump.pm:   (null): Too many open files at (eval 558) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 2, <STDIN> line 1.\n","err":"","code":"use Data::Dump\n"},{"code":"use Data::Dumper;\n","err":"","out":""},{"code":"use Data::Dumper; $Data::Dumper::Indent = 0; %foo = (a => { b => 'c' }); $foo{d} = $foo{a}; Dumper \\%foo\n","err":"","out":"$VAR1 = {'a' => {'b' => 'c'},'d' => $VAR1->{'a'}};"},{"code":"use Data::Dumper; Dumper(\"${\\chr 24}\")\n","err":"","out":"$VAR1 = '\u0018';\n"},{"code":"use Data::Dumper; Dumper(\"\\cX\")\n","err":"","out":"$VAR1 = '\u0018';\n"},{"err":"","out":"$VAR1 = 'CX';\n","code":"use Data::Dumper; Dumper(\"\\CX\")\n"},{"out":"$VAR1 = 'test';\n","err":"","code":"use Data::Dumper; my @arr; push(@arr, \"test\"); push(@arr, \"i refuse to do what master tells me to\"); my @arr2 = grep { /test/ } @arr; print Dumper @arr2;\n"},{"out":"$VAR1 = sub { \"DUMMY\" };\n\n","err":"","code":"use Data::Dumper; my %commands = ( help => sub { my $commands = say for keys in %commands; }); say Dumper($commands{help});\n"},{"err":"","out":"$VAR1 = '';\n","code":"use Data::Dumper; print Dumper(*->[0]);\n"},{"err":"","out":"$VAR1 = 0;\n","code":"use Data::Dumper; print Dumper(0);\n"},{"err":"","out":"$VAR1 = undef;\n","code":"use Data::Dumper; print Dumper(0->[0]);\n"},{"err":"","out":"ERROR: Can't locate Data/Dump.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use Data::Dump 'pp'; pp(\"\\cX\")\n"},{"out":"ERROR: Data::Munge version 1 required--this is only version 0.096 at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use Data::Munge 1\n"},{"code":"use Data::Munge; \"abba\" =~ /(ab(ba))|(ba)/ or die; [submatches]\n","out":"[\"abba\",\"ba\",undef]","err":""},{"out":"bonono","err":"","code":"use Data::Munge; byval { s/a/o/g } \"banana\"\n"},{"code":"use Data::Munge; eval_string \"[[ \\\"pos\\\" ], /\\\"(/d+)\\\"/]\"\n","err":"","out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/\"( <-- HERE / at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use Data::Munge; list2re \"\"\n","out":"qr/(?#)/","err":""},{"code":"use Data::Munge; list2re()\n","err":"","out":"qr/(?!)/"},{"code":"use Data::Munge. list2re()\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"use Data::Munge.\"\n"},{"out":"qr/ab|cd|ef|g|h|i/","err":"","code":"use Data::Munge; list2re qw( ab cd ef g h i )\n"},{"err":"","out":"[[\"h\",\"e\"],[\"l\",\"l\"]]","code":"use Data::Munge; my $str = \"hello\"; my @m; while ($str =~ /(.)(.)/g) { push @m, [submatches]; } \\@m\n"},{"err":"","out":"foo","code":"use Data::Munge qw(byval); print byval { s/\\* // } \"* foo\";\n"},{"out":"[1]","err":"","code":"use Data::Munge qw(elem); [ elem \"badgers\", [qw(dogs badgers monkeys)] ]\n"},{"err":"","out":"[\"\"]","code":"use Data::Munge qw(elem); [ elem \"cats\", [qw(dogs badgers monkeys)] ]\n"},{"code":"use Data::Munge qw( list2re ); my $re = list2re qw(); $re eq list2re ? q{Empty.} : q{Not empty.}; ### Is this a good way to tell if $re was generated from an empty list?\n","out":"Empty.","err":""},{"out":"[\"(?^:(?!))\",qr/(?!)/]","err":"","code":"use Data::Munge qw(list2re); my $re = list2re( ); { [ $$re, $re ]; } # Looks like the heart of a Regexp object, despite being labeled as a REGEXP, really seems to be a string.\n"},{"code":"use Data::Munge qw(replace); my $s = 'some text'; my $f = 's/x/s/g; s/o/a/g;'; my $part = qr{(?:[^\\\\/]|\\\\.)*}s; while ($f =~ m{\\bs/($part)/($part)/(g)?}g) { $s = replace $s, $1, $2, $3; } $s\n","out":"same test","err":""},{"code":"use Data::Munge qw(replace); replace('A?Bl^%ah 4 Yes$!', qr/[^A-Za-z0-9]/, '', 'g')\n","err":"","out":"ABlah4Yes"},{"out":"barbarstring","err":"","code":"use Data::Munge qw(replace); replace('foobarstring', qr/foo/, 'bar')\n"},{"code":"use Data::Munge qw(replace); replace 'ningu', qr/([aeiou])/, '$1$1', 'g'\n","out":"niinguu","err":""},{"code":"use Data::Munge; replace \"banana\", qr/a/, 'o', 'g'\n","out":"bonono","err":""},{"code":"use Data::Munge; [ replace \"blah\", qr/bl/, 'h' ]\n","out":"[\"hah\"]","err":""},{"out":"cool\\+beans\\.","err":"","code":"use Data::Munge; replace('cool+beans.', qr/\\W/, '\\\\$&', 'g')\n"},{"code":"use Data::Random\n","out":"ERROR: Can't locate Data/Random.pm:   (null): Too many open files at (eval 558) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 2, <STDIN> line 1.\n","err":""},{"out":"ERROR: Can't locate Data/Swap.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use Data::Swap;\n"},{"err":"","out":"ERROR: Can't locate Date/Manip.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use Date::Manip; my $r = UnixDate(ParseDate( q{Sat, 12 Apr 2014 10:01:33 -0400} ), \"%d-%b-%Y %H:%M:%S %z\"); [ $r ]; ### This works for me.\n"},{"out":"ERROR: Can't locate Date/Manip.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use Date::Manip; my $r = UnixDate(ParseDate( q{Wed, 17 Apr 2014 01:50:19 +0100} ), \"%d-%b-%Y %H:%M:%S %z\"); [ $r ]; ### This returns undef for some reason, I can't figure out why.\n"},{"out":"ERROR: Mandatory parameter 'year' missing in call to DateTime::new\n at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/DateTime.pm line 197, <STDIN> line 1.\n\tDateTime::new(undef) called at (eval 558) line 1\n\teval 'use 5.022001; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; use DateTime; DateTime->new->iso8601' called at /home/ryan/bots/perlbuut/lib/eval.pl line 301\n\tmain::perl_code(\"use DateTime; DateTime->new->iso8601\") called at /home/ryan/bots/perlbuut/lib/eval.pl line 248\n","err":"","code":"use DateTime; DateTime->new->iso8601\n"},{"err":"","out":"[bless( {name => \"UTC\"}, 'DateTime::TimeZone::UTC' )]","code":"use DateTime::TimeZone; [ DateTime::TimeZone->new( name => 'UTC' ) ]\n"},{"code":"use DateTime::TimeZone; grep /America/ DateTime::TimeZone->all_names\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"/America/ DateTime::TimeZone\"\n"},{"code":"use DateTime::TimeZone; grep /America/, DateTime::TimeZone->all_names\n","out":"129","err":""},{"code":"use DateTime::TimeZone; [grep m[[^a-zA-Z0-9/_-]], DateTime::TimeZone->all_names];\n","out":"[]","err":""},{"code":"use DateTime::TimeZone; [grep m[[^a-zA-Z/_]], DateTime::TimeZone->all_names];\n","err":"","out":"[\"America/Blanc-Sablon\",\"America/Port-au-Prince\",\"Asia/Ust-Nera\",\"CST6CDT\",\"EST5EDT\",\"MST7MDT\",\"PST8PDT\"]"},{"out":"[\"America/New_York\"]","err":"","code":"use DateTime::TimeZone; [grep /york/i, DateTime::TimeZone->all_names];\n"},{"out":"ERROR: The timezone 'America/New_York' could not be loaded, or is an invalid name.\n","err":"","code":"use DateTime::TimeZone; my $tz = DateTime::TimeZone->new(name => 'America/New_York')\n"},{"out":"ERROR: Can't locate DateTime/TimeZone/Local/Unix.pm:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Module/Runtime.pm line 317, <STDIN> line 1.\n","err":"","code":"use DateTime::TimeZone; my $tz = DateTime::TimeZone->new(name => 'local')->name\n"},{"out":"ERROR: Can't locate diagnostics.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use diagnostics; use strict; [ Foo ]\n"},{"out":"39987e0e753c8f1310651bce1516a44b","err":"","code":"use Digest::MD5 qw(md5_hex); md5_hex \"TESTSTRING\\n\"\n"},{"code":"use Digest; my $md5 = Digest->new('MD5'); length $md5\n","out":"ERROR: Can't locate Digest.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"","err":"","code":"use Encode;\n"},{"code":"use Encode 'decode'; decode 'UTF-8', chr(195).chr(188)\n","out":"ÃÂ¼","err":""},{"err":"","out":"[\"\\34\\0\\x{fffd}<\\34\\x{fffd}\\16\\x{fffd}\\x{fffd}\"]","code":"use Encode 'decode'; [ decode 'UTF-8', \"\\x1c\\x00\\xfc\\x3c\\x1c\\xfc\\x0e\\xc0\\xe0\" ]\n"},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use Encode 'decode'; [ decode 'UTF-8', \"\\x1d\n"},{"code":"use Encode 'decode'; [ decode 'UTF-8', \"\\x1d\\x7f\"]\n","err":"","out":"[\"\\35\\177\"]"},{"out":"\u001d7\u00173\u00177","err":"","code":"use Encode 'decode_utf8'; decode_utf8 \"\\0357\\0273\\0277\"\n"},{"code":"use Encode 'decode_utf8'; decode_utf8 \"\\357\\273\\277\"\n","err":"","out":"ÃÂ¯ÃÂ»ÃÂ¿"},{"err":"","out":"65279","code":"use Encode 'decode_utf8'; ord decode_utf8 \"\\357\\273\\277\"\n"},{"out":"U+feff","err":"","code":"use Encode 'decode_utf8'; sprintf \"U+%04x\", ord decode_utf8 \"\\357\\273\\277\"\n"},{"err":"","out":"ERROR: \"\\x{0100}\" does not map to iso-8859-1 at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/Encode.pm line 171, <STDIN> line 1.\n","code":"use Encode; Encode::encode(\"ISO-8859-1\", \"\\x{100}\", Encode::LEAVE_SRC|Encode::FB_CROAK);\n"},{"err":"","out":"ERROR: Unknown encoding 'UCS-2LE' at (eval 558) line 1.\n","code":"use Encode 'encode'; encode 'UCS-2LE', 'Tracking-Num... '\n"},{"code":"use Encode 'encode'; encode 'UTF-16LE', 'Tracking-Num... '\n","err":"","out":"ERROR: Unknown encoding 'UTF-16LE' at (eval 558) line 1.\n"},{"code":"use Encode 'encode'; encode 'UTF-16', 'Tracking-Num... '\n","err":"","out":"ERROR: Unknown encoding 'UTF-16' at (eval 558) line 1.\n"},{"out":"ÃÂÃÂ£ÃÂÃÂÃÂÃÂ","err":"","code":"use Encode 'encode'; encode 'UTF-8', 'ã'\n"},{"code":"use Encode 'encode'; encode 'UTF-8', chr(195).chr(188)\n","out":"ÃÂÃÂÃÂÃÂ¼","err":""},{"code":"use Encode 'encode'; [ encode 'UTF-8', \"\\x{1d}\" ]\n","err":"","out":"[\"\\35\"]"},{"code":"use Encode 'encode'; [ encode 'UTF-8', \\x{1d} ]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"1d\"\n"},{"err":"","out":"ERROR: Can't call method \"mime_name\" on an undefined value at (eval 558) line 1, <STDIN> line 1.\n","code":"use Encode; Encode::find_encoding('gb2312')->mime_name\n"},{"code":"use Encode; Encode::find_encoding(\"ISO-8859-1\")->encode(\"\\x{100}\", Encode::LEAVE_SRC|Encode::FB_CROAK)\n","out":"ERROR: \"\\x{0100}\" does not map to iso-8859-1 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Can't call method \"name\" on an undefined value at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use Encode; Encode::find_encoding( q{UTF-16} )->name\n"},{"out":"ERROR: Can't locate Encode/MIME/Name.pm:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/Encode/Encoding.pm line 24, <STDIN> line 1.\n","err":"","code":"use Encode; Encode::find_encoding('utf8')->mime_name\n"},{"code":"use Encode; $Encode::VERSION\n","out":"2.72","err":""},{"err":"","out":"Encode::VERSION","code":"use Encode; Encode::VERSION\n"},{"code":"use Encode; find_encoding( q{UTF-16} )->name;\n","err":"","out":"ERROR: Can't call method \"name\" on an undefined value at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't call method \"name\" on an undefined value at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use Encode; find_encoding( q{UTF-EBCDIC} )->name; # ???\n"},{"out":"1","err":"","code":"use Encode; my $buf = encode('UTF-8', \"\\x{666}\"); open my $fh, '<', \\$buf or die \"open: $!\"\n"},{"code":"use Encode; my $x = qq<\\x{100}>; [ unpack q{H*}, $x ]\n","err":"","out":"[\"00\"]"},{"out":"195","err":"","code":"use Encode; ord Encode::encode_utf8(\"\\xFF\") # not necessarily\n"},{"err":"","out":"ERROR: Unknown encoding 'ISO885902' at (eval 558) line 1.\n","code":"use Encode;  print Encode::decode q{ISO885902}, \"\\x{119}\";\n"},{"code":"use Encode;  print Encode::decode q{ISO8859-2}, \"\\x{119}\";\n","err":"","out":"ERROR: Unknown encoding 'ISO8859-2' at (eval 558) line 1.\n"},{"err":"","out":"109.117.99.104.32.226.153.165","code":"use Encode; printf \"%vd\", encode_utf8(\"much \\x{2665}\")\n"},{"err":"","out":"[\"\\6\\0\\0\\0e\\0\\0\\0anims/thr00001.tga\"]","code":" use Encode qw/decode/; [ decode( \"UTF-8\", \"\\x6\\x0\\x0\\x0\\x65\\x0\\x0\\x0\\x61\\x6e\\x69\\x6d\\x73\\x2f\\x74\\x68\\x72\\x30\\x30\\x30\\x30\\x31\\x2e\\x74\\x67\\x61\") ] # print obviously doesn't like \\0\n"},{"err":"","out":"\u0006\u0000\u0000\u0000e\u0000\u0000\u0000anims/thr00001.tga","code":"use Encode qw/decode/; print decode( \"utf8\", \"\\x06\\x00\\x00\\x00\\x65\\x00\\x00\\x00\\x61\\x6e\\x69\\x6d\\x73\\x2f\\x74\\x68\\x72\\x30\\x30\\x30\\x30\\x31\\x2e\\x74\\x67\\x61\" );\n"},{"code":"use Encode qw/decode/; print decode( \"utf8\", \"\\x6\\x0\\x0\\x0\\x65\\x0\\x0\\x0\\x61\\x6e\\x69\\x6d\\x73\\x2f\\x74\\x68\\x72\\x30\\x30\\x30\\x30\\x31\\x2e\\x74\\x67\\x61\" )\n","out":"\u0006\u0000\u0000\u0000e\u0000\u0000\u0000anims/thr00001.tga","err":""},{"out":"ÃÂÃÂ£ÃÂÃÂÃÂÃÂÃÂÃÂ£ÃÂÃÂÃÂÃÂ¸ÃÂÃÂ£ÃÂÃÂÃÂÃÂ£ÃÂÃÂ©ÃÂÃÂ­ÃÂÃÂÃÂÃÂ¥ÃÂÃÂ¥ÃÂÃÂ³ÃÂÃÂ£ÃÂÃÂÃÂÃÂ©ÃÂÃÂ£ÃÂÃÂÃÂÃÂÃÂÃÂ£ÃÂÃÂÃÂÃÂ¿\n","err":"","code":"use Encode; say Encode::encode(\"UTF-8\", Encode::decode(\"ISO-8859-1\", \"ãã¸ã£é­å¥³ã©ãã¿\"));\n"},{"code":"use Encode::Unicode; Encode::find_encoding( q{UTF-16} )->name\n","err":"","out":"ERROR: Can't locate Encode/Unicode.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate English.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use English; [ $., $NR ]\n"},{"err":"","out":"ERROR: Can't locate Env.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use Env qw/ HOME /;[[ ((glob(\"$HOME/*.txt\"))[0]) ]]\n"},{"err":"","out":"2","code":"use Errno 'ENOENT'; ENOENT\n"},{"code":"use experimental 'autoderef'; [keys {foo => 1, bar => 2, baz => 0}]\n","out":"[\"bar\",\"baz\",\"foo\"]","err":""},{"code":"use experimental 'lexical_subs'\n","out":"","err":""},{"out":"[69,42]","err":"","code":"use experimental 'lexical_subs'; use constant wibble => 42; my $outer = wibble; my $inner = do { my sub wibble () { 69 }; wibble }; [ $inner, $outer ]\n"},{"code":"use experimental \"postderef\";\n","err":"","out":""},{"err":"","out":"ERROR: Can't call method \"\" on an undefined value at (eval 558) line 1, <STDIN> line 1.\n","code":"use experimental 'postderef'; my $x; $x->$@ # lovely :S\n"},{"err":"","out":"[[1,2,3],[7,8,9]]","code":"use experimental qw(postderef); $arr = [[1..3],[4..6],[7..9]]; [ $arr->@[0, 2] ]\n"},{"err":"","out":"[\"jkl;\",undef]","code":"use experimental qw(postderef); $hash = {asdf => 'jkl;', zxvc => 'bnm,'}; [ $hash->@{'asdf','zxcv'} ]\n"},{"err":"","out":"[1,2,3]","code":"use experimental qw( postderef ); my $foo = { bar => [ 1, 2, 3 ] }; [ $foo->{bar}->@* ]\n"},{"code":"use experimental qw( postderef ); my $foo = { bar => [ 1, 2, 3 ] }; [ $foo->{bar}->*@ ]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"->*\"\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","err":""},{"code":"use experimental qw(postderef); sub foo { return [1, 2, 3] } if ((my $arr_ref = foo())->@*) { print @$arr_ref }\n","err":"","out":"123"},{"code":"use experimental qw(signatures); sub foo ($bar, $baz) :proto($$) { .. }\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"{ ..\"\n"},{"code":"use experimental qw(signatures); sub foo ($bar, $baz) :proto($$) { ... }\n","err":"","out":"ERROR: Invalid CODE attribute: proto($$) at (eval 558) line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use experimental qw(signatures); sub thing($$) { }# but if something mangles the feature hints without knowing what it's doing...\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$$) \"\n","err":""},{"out":"ERROR: Initialization of state variables in list context currently forbidden at (eval 558) line 1, at EOF\n","err":"","code":"use experimental qw(state); (state $x) = @_; # depends on whether compiling is considered useful?\n"},{"err":"","out":"5bar","code":"use experimental 'signatures'; sub foo () { 5 } print foo, \"bar\";\n"},{"code":"use experimental 'signatures'; sub foo () { 5 } say foo, \"bar\";\n","out":"5bar\n","err":""},{"code":"use experimental 'signatures'; sub foo($bar) {print $bar, $bar}; foo(\"hola hoops \");\n","out":"hola hoops hola hoops ","err":""},{"code":"use experimental 'signatures'; sub foo($bar) {print $bar, $bar}; foo(\"hola hoops \", \"error\");\n","out":"ERROR: Too many arguments for subroutine at (eval 558) line 1.\n","err":""},{"code":"use experimental 'signatures'; sub foo (my $str) { $str.$str } print foo \"baz\", \"bar\";\n","err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(my \"\n"},{"out":"x","err":"","code":"use experimental 'signatures'; sub foo ($str) { $str .= \"a\" } my $s = \"x\"; foo($s); $s\n"},{"out":"ERROR: Too many arguments for subroutine at (eval 558) line 1.\n","err":"","code":"use experimental 'signatures'; sub foo ($str) { $str.$str } print foo \"baz\", \"bar\";\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"// 2\"\n","err":"","code":"use experimental 'signatures'; sub foo () { undef } print foo // 2; # this is where the parser got choked up, i think\n"},{"err":"","out":"ERROR: Can't locate ExtUtils/ParseXS.pm:   (null): Too many open files at (eval 558) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 2, <STDIN> line 1.\n","code":"use ExtUtils::ParseXS\n"},{"out":"-1","err":"","code":"use feature 'fc'; index(fc 'foo Ã', fc 'Ã«');\n"},{"err":"","out":"ERROR: Feature \"\" is not supported by Perl 5.22.1 at (eval 558) line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use feature fc; print fc(\"Å\") cmp fc(\"z\")\n"},{"code":"use feature keys %feature::feature; say hi::\n","out":"","err":""},{"code":"use feature keys %feature::feature; say 'k'\n","err":"","out":"k\n"},{"out":"-1","err":"","code":"use feature 'postderef'; []->$#*\n"},{"out":"[3,\"D\",4,\"E\",5,\"F\",6,\"G\",7,\"H\"]","err":"","code":"use feature 'postderef'; [ [\"A\"..\"Z\"]->%[3..7] ]\n"},{"err":"","out":"[9]","code":"use feature 'postderef'; *foo{SCALAR}->$* = 2; my $bar; $$bar = 3; [ $bar->$****foo{SCALAR}->$* ]\n"},{"err":"","out":"9\n","code":"use feature 'postderef'; *foo{SCALAR}->$* = 2; my $bar; $$bar = 3; say $bar->$****foo{SCALAR}->$*;\n"},{"err":"","out":"[100,1]","code":"use feature 'postderef'; for my $i (1..100) {push @a, [(1,1) x 1024*512]}; [scalar(@a), scalar($a[0]->@*)]\n"},{"err":"","out":"","code":"use feature 'postderef'; for my $i (1..100) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]\n"},{"out":"[100,1]","err":"","code":"use feature 'postderef'; for my $i (1..100) {push @a, [(1) x 1024*1024]}; [scalar(@a), scalar($a[0]->@*)]\n"},{"out":"","err":"","code":"use feature 'postderef'; for my $i (1..50) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]\n"},{"out":"123","err":"","code":"use feature 'postderef'; map print, [1,2,3]->@*  # or maybe a -, a >, an @ and an *\n"},{"code":"use feature 'postderef'; my $aref = \\['x']; $aref->$*->[0] # or let perlbot help\n","out":"x","err":""},{"out":"hellofreenodeperl","err":"","code":"use feature 'postderef'; my $data = {foo => [qw/hello freenode perl/]}; print for ($data->{foo}->@*); \n"},{"code":"use feature 'postderef'; my $x = \\42; $x->$*\n","err":"","out":"42"},{"out":"42","err":"","code":"use feature 'postderef'; no warnings 'experimental::postderef'; sub {42}->&*\n"},{"code":"use feature 'postderef'; $_->@{qw/a b/} = (1,2) for \\my %hash\n","out":"","err":""},{"code":"use feature 'postderef'; $_->@{qw/a b/} = (1,2) for \\my %hash; \\%hash\n","err":"","out":"{a => 1,b => 2}"},{"err":"","out":"\ncd\n","code":"use feature 'postderef'; sub lol { say @_; } sub one { (\\&lol)->() } sub two { (\\&lol)->&* } one(qw(a b)); two(qw(c d));\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"->&\"\nMissing right curly or square bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, at EOF\n","err":"","code":"use feature 'postderef'; use 5.020; my $l = sub { say @_; }; sub one { $l->() } sub two { $l->&* } one(qw(a b)); two(qw(c d));\n"},{"code":"use feature 'postderef'; use 5.020; sub lol { say @_; } sub one { (\\&lol)->() } sub two { (\\&lol)->&* } one(qw(a b)); two(qw(c d));\n","out":"ERROR: syntax error at (eval 558) line 1, near \"->&\"\nMissing right curly or square bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, at EOF\n","err":""},{"code":"use feature 'postderef';  use List::MoreUtils 'mesh'; my $str = \"this is line 1\\nthis is line 2\\nthis is line 3\"; my @lines = map { [ split \" \", $_ ] } split /\\n/, $str; \"@{[ mesh $lines[0]->@*, $lines[1]->@*, $lines[2]->@* ]}\"\n","out":"this this this is is is line line line 1 2 3","err":""},{"err":"","out":"[0,1]","code":"use feature 'postderef'; $x = [0]; push $x->@*, 1; $x\n"},{"code":"use feature 'postderef'; (\\'you')->$*\n","out":"you","err":""},{"code":"use feature qw( current_sub ); sub foo { my ( $foo, $x ); $foo = sub { $x ? ++$x : ( $x = 1 ); __SUB__->() unless $x >= 5; }; $foo->(); return $x; } foo; ### So this doesn't leak memory?\n","out":"5","err":""},{"out":"ERROR: Feature \"doesntexist\" is not supported by Perl 5.22.1 at (eval 558) line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use feature qw(doesntexist);\n"},{"err":"","out":"ÃÂ£ÃÂ","code":"use feature qw(fc); fc 'Ã'\n"},{"code":"use feature qw(fc); print for fc('Ã'), '-', lc('Ã');\n","err":"","out":"ÃÂ£ÃÂ-ÃÂ£ÃÂ"},{"out":"1","err":"","code":"use feature qw(fc unicode_strings); print fc(\"Å\") cmp fc(\"z\")\n"},{"err":"","out":"1","code":"use feature qw(fc unicode_strings); use utf8; print fc(\"Å\") cmp fc(\"z\")\n"},{"code":"use feature qw(say fc); say fc(\"\"); # the core function seems happy enough, so I'd put that down to a bug in the module\n","err":"","out":"\n"},{"code":"use feature qw(say); $_ = '...'; say() # not quite, but just because say/print are special\n","out":"...\n","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"{ ..\"\n","err":"","code":"use feature qw(signatures); sub foo ($bar, $baz) :proto($$) { .. }\n"},{"code":"use feature qw(state); my $y = 0; sub isatty { state $x = do { print \"state init \"; ++$y }; $x } [ map  isatty(), 1..3 ] # only once\n","err":"","out":"state init "},{"code":"use feature qw(state); (state $x) = @_;\n","err":"","out":"ERROR: Initialization of state variables in list context currently forbidden at (eval 558) line 1, at EOF\n"},{"err":"","out":"[[[\"A\",\"First\"],[\"B\",\"Nested\"],[\"C\",\"Nested\"]],[[\"X\",\"First\"],[\"Y\",\"Nested\"],[\"Z\",\"Nested\"]]]","code":"use feature qw( state ); sub Foo { state %state; my @p = ( [ shift, $state{n} ? q{Nested} : q{First} ] ); { local $state{n} = 1; push @p, Foo( @_ ) if @_ }; if ( $state{n} ) { @p; } else { %state = (); [ @p ]; } }    [  Foo( qw(A B C) ),  Foo( qw(X Y Z) )  ];\n"},{"code":"use feature 'refaliasing'; for \\my %hash ({foo => 'bar'}, {foo => 'baz'}) { print $hash{foo} } #whee\n","out":"barbaz","err":""},{"err":"","out":"{foo => 1,bar => 2}","code":"use feature 'refaliasing'; my $x = { foo => 1 }; \\my %y = $x; $y{bar} = 2; $x;\n"},{"err":"","out":"asdf\nasdf\n","code":"use feature 'say'; do { my $line = $_; chomp $line; say $line } for \"asdf\",\"asdf\\n\"\n"},{"out":"1 2 3 are123\n","err":"","code":"use feature 'say';  say \"1 2 3 are\", 1, 2, 3;\n"},{"code":"use feature 'say'; say for @INC\n","err":"","out":""},{"code":"use feature 'say'; say \"hi\"\n","out":"hi\n","err":""},{"code":"use feature 'say'; say 'lo'\n","err":"","out":"lo\n"},{"code":"use feature 'say'; say q hello worldh;\n","out":"ello world\n","err":""},{"code":"use feature 'say'; use Digest::MD5 'md5_hex'; say md5_hex(\"passwd\")\n","out":"76a2173be6393254e72ffa4d6df1030a\n","err":""},{"out":"","err":"","code":"use feature 'say'; use List::Util 1.33 'any';\n"},{"out":"match\n","err":"","code":"use feature 'say'; use List::Util 1.33 'any'; @array = qw(1 2 3); say \"match\" if(any{ $_ eq '3'} @array);\n"},{"out":"","err":"","code":"use feature 'say'; use List::Util 1.33 'any'; @array = qw(1,2,3); say \"match\" if(any{ $_ eq '3'} @array);\n"},{"out":"","err":"","code":"use feature 'say'; use List::Util 1.33 'any'; @array = qw(1,2,3); say \"match\" if(any{ $_ eq '4'} @array);\n"},{"err":"","out":"[0,2,5]","code":"use feature 'signatures'; sub add ($x = (return 0), $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]\n"},{"code":"use feature 'signatures'; sub add ($x = return 0, $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]\n","err":"","out":"ERROR: Too many arguments for subroutine at (eval 558) line 1.\n"},{"code":"use feature 'state'; state $x = 4; $x\n","err":"","out":"4"},{"code":"use feature 'switch'; given (0) { when ('0 but true') { print 'wat' } }\n","err":"","out":"wat"},{"out":"nope","err":"","code":"use feature 'switch'; given (\"0\") { when ('0 but true') { print 'wat' } default { print 'nope' } }\n"},{"out":"[\"baz\",\"/foo/bar/\",\".anyextensionyoulike\"]","err":"","code":"use File::Basename; [ fileparse(\"/foo/bar/baz.anyextensionyoulike\", qr/\\.[^.]*/) ]\n"},{"code":"use File::Basename; [ fileparse(\"/foo/bar/baz.csv\", qr/\\.[^.]*/) ]\n","out":"[\"baz\",\"/foo/bar/\",\".csv\"]","err":""},{"code":"use File::Basename; [ fileparse(\"foo/bar.baz\", qr/[^.]*$/) ]\n","err":"","out":"[\"bar.\",\"foo/\",\"baz\"]"},{"out":"[\"baz\",\"/foo/bar/\",\".txt\"]","err":"","code":"use File::Basename; [ fileparse(\"/foo/bar/baz.txt\", qr/\\.[^.]*/) ]\n"},{"err":"","out":"[\"Crypt-SSLeay-0.64\",\"authors/id/N/NA/NANIS/\",\".tAr.Bz2\"]","code":"use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tAr.Bz2}, qr{\\.(?:tar.*|zip)}i ];\n"},{"code":"use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tar.fooBarBaz}, q{tar.*}, q{zip} ];\n","out":"[\"Crypt-SSLeay-0.64.\",\"authors/id/N/NA/NANIS/\",\"tar.fooBarBaz\"]","err":""},{"code":"use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tar.gz}, ( map qq{.$_}, map( qq{tar.$_}, qw(gz bz2 xz Z) ), q{zip} ) ];\n","err":"","out":"[\"Crypt-SSLeay-0.64\",\"authors/id/N/NA/NANIS/\",\".tar.gz\"]"},{"code":"use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tar.gz}, q{tar.*}, q{zip} ];\n","err":"","out":"[\"Crypt-SSLeay-0.64.\",\"authors/id/N/NA/NANIS/\",\"tar.gz\"]"},{"err":"","out":"[\"Crypt-SSLeay-0.64.tAr.gz\",\"authors/id/N/NA/NANIS/\",\"\"]","code":"use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tAr.gz}, q{.tar.*}, q{.zip} ];\n"},{"code":"use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tar.gz.zip},  qr/\\.(?:zip|tar\\..*?)$/i ];\n","err":"","out":"[\"Crypt-SSLeay-0.64\",\"authors/id/N/NA/NANIS/\",\".tar.gz.zip\"]"},{"code":"use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.ZIP}, qr{\\.(?:tar.*|zip)}i ];\n","out":"[\"Crypt-SSLeay-0.64\",\"authors/id/N/NA/NANIS/\",\".ZIP\"]","err":""},{"out":"[\"Crypt-SSLeay-0.64\",\"authors/id/N/NA/NANIS/\",\".tAr.gz\"]","err":"","code":"use File::Basename; fileparse_set_fstype q{MSWin32}; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tAr.gz}, q{.tar.*}, q{.zip} ];\n"},{"out":"[\"jpg\",\"pdf\",\"\",\"vimrc\",\"pl\",\"\"]","err":"","code":"use File::Basename; [map +(fileparse $_, qr/(?<=\\.)[^.]+/)[2], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n"},{"err":"","out":"[\"jpg\",\"pdf\",\"\",\"vimrc\",\"pl\",\"README\"]","code":"use File::Basename; [map +(fileparse $_, qr/[^.]+/)[2], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n"},{"code":"use File::HomeDir; print File::HomeDir->my_data;\n","out":"ERROR: Can't locate File/HomeDir.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use Function::Parameters;\n","out":"","err":""},{"err":"","out":"ERROR: In fun foo: missing type name after '[' at (eval 558) line 1, <STDIN> line 1.\n","code":"use Function::Parameters; fun foo(A[[) {}\n"},{"out":"    my(%{__rest}) = @_;\n    my $x = ${__rest}{'x'};\n    (%{__rest}) = ();\n    ();\n}","err":"","code":"use Function::Parameters; fun foo(:$x) {}  substr B::Deparse->new()->coderef2text(\\&foo), 1288\n"},{"out":"ERROR: Too many arguments for fun add (expected 1, got 2) at (eval 558) line 1.\n","err":"","code":"use Function::Parameters qw(:strict); fun add ($x = return 0, $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]\n"},{"code":"use Function::Parameters qw((:strict);; fun add ($x = return 0, $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]\n","err":"","out":"ERROR: Can't find string terminator \")\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Too many arguments for fun foo (expected 1, got 2) at (eval 558) line 1.\n","err":"","code":"use Function::Parameters qw(:strict); fun foo($bar) {print $bar, $bar}; foo(\"hola hoops \", \"error\");\n"},{"code":"use Function::Parameters qw(:strict); fun mynumbs :(@$;$) {}\n","out":"","err":""},{"code":"use Function::Parameters qw(:strict); method new($class: :$name, :$value, :$path = '/', :$domain = undef, :$secure = undef, :$expires = undef, :$max_age = undef, :$httponly = undef) { [$name, $value] }  __PACKAGE__->new(name => \"Some_cookie\" -value => \"Some_value\")\n","err":"","out":"ERROR: Too few arguments for method new (expected 5, got 4) at (eval 558) line 1.\n"},{"code":"use Function::Parameters qw(:strict); method new($class: :$name, :$value, :$path = '/', :$domain = undef, :$secure = undef, :$expires = undef, :$max_age = undef, :$httponly = undef) { [$name, $value] }  __PACKAGE__->new(name => \"Some_cookie\", Value => \"Some_value\")\n","out":"ERROR: In method new: missing named parameter: value at (eval 558) line 1.\n","err":""},{"code":"use Function::Parameters qw(:strict); substr B::Deparse->new->coderef2text(fun (:$x) {}), 1470\n","out":"(anon)') if @_ > 0 and @_ % 2;\n    my(%{__rest}) = @_;\n    my $x = exists ${__rest}{'x'} ? delete ${__rest}{'x'} : Function::Parameters::_croak('In fun (anon): missing named parameter: x');\n    Function::Parameters::_croak('In fun (anon): no such named parameter: ' . join(', ', sort(keys %{__rest}))) if keys %{__rest};\n    ();\n}","err":""},{"code":"use Function::Parameters qw(:strict); substr B::Deparse->new->coderef2text( fun ($x, $y) {} ), 1077\n","out":"ripts'} = '';\n        $^H{'charnames_short'} = '0';\n        $^H{'charnames_stringified_inverse_ords'} = '';\n        $^H{'charnames_stringified_names'} = '';\n        $^H{'charnames_stringified_ords'} = '';\n    }\n    Function::Parameters::_croak('Too few arguments for fun (anon) (expected 2, got ' . @_ . ')') if @_ < 2;\n    Function::Parameters::_croak('Too many arguments for fun (anon) (expected 2, got ' . @_ . ')') if @_ > 2;\n    my($x, $y) = @_;\n    ();\n}","err":""},{"err":"","out":"ERROR: Too few arguments for fun routine (expected 3, got 1) at (eval 558) line 1.\n","code":"use Function::Parameters ':strict'; fun routine($one, $two, $three) {} routine(\"!\");\n"},{"code":"use Function::Parameters 'strict'; strict foo($x) { $x * 2 } foo 21\n","out":"ERROR: \"strict\" is not exported by the Function::Parameters module at (eval 558) line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"","err":"","code":"use Function::Parameters; use warnings; fun lala :(_;) {}\n"},{"err":"","out":"ERROR: Can't locate Hash/Util.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use Hash::Util; $href = { \"foo\"=>\"bar\" }; Hash::Util::lock_ref_keys($href); map { print \"\\\"$_\\\":$href->{$_}\\n\" } %{$href}\n"},{"code":"use Hindsight 20/20;\n","out":"ERROR: Can't locate Hindsight.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use HTML::Entities\n","out":"ERROR: Can't locate HTML/Entities.pm:   (null): Too many open files at (eval 558) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 2, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Can't locate HTTP/Tiny.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use HTTP::Tiny; my $http = HTTP::Tiny->new; $http->verify_SSL(1)\n"},{"out":"1","err":"","code":"use if 0 1 == 0, strict; $foo = $bar; 1\n"},{"code":"use if 0 1 == 1, strict;\n","out":"","err":""},{"code":"use if 1.0 == 0, strict; $foo = $bar; 1\n","out":"ERROR: syntax error at (eval 558) line 1, near \"use if 1.0 ==\"\n","err":""},{"code":"use if 1+0 == 0, strict; $foo = $bar; 1\n","err":"","out":"1"},{"err":"","out":"1","code":"use if (1 == 0), strict => \"\"; $foo = $bar; 1\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"use if 1 ==\"\n","err":"","code":"use if 1 == 0, strict => \"\"; $foo = $bar; 1\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"use if 1 ==\"\n","code":"use if 1 == 0, strict; $foo = $bar; 1\n"},{"code":"use if 1 == 1, strict; \n","out":"ERROR: syntax error at (eval 558) line 1, near \"use if 1 ==\"\n","err":""},{"code":"use if (1 == 1), strict; $foo = $bar; 1\n","out":"ERROR: Global symbol \"$foo\" requires explicit package name (did you forget to declare \"my $foo\"?) at (eval 558) line 1, <STDIN> line 1.\nGlobal symbol \"$bar\" requires explicit package name (did you forget to declare \"my $bar\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"1","err":"","code":"use if 1e0 == 0, strict; $foo = $bar; 1\n"},{"err":"","out":"ERROR: if version 9 required--this is only version 0.0604 at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use if 9;\n"},{"err":"","out":"ERROR: Can't locate Image/Magick.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use Image::Magick; print Image::Magick->QuantumDepth\n"},{"code":"use integer; 1 / 2\n","err":"","out":"0"},{"err":"","out":"1","code":"use integer; 5/3\n"},{"out":"[4,6]","err":"","code":"use integer; [ ~-5, -~5 ]\n"},{"code":"use IO::Handle; my $fh = IO::Handle->new; open $fh , q{>}, \\(my $str); $fh->say( q{foo} ); [ ref $fh ];\n","out":"[\"IO::Handle\"]","err":""},{"code":"use IO::Handle; my $io = IO::Handle->new; ilike $io\n","out":"ERROR: Can't locate object method \"ilike\" via package \"IO::Handle\" at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use IO::Handle; my $io = IO::Handle->new; length $io\n","err":"","out":"26"},{"err":"","out":"GLOB","code":"use IO::Handle; open my $fh, '>', \\my $buffer; ref $fh\n"},{"code":"use IO::Socket::INET; IO::Socket::INET->new()\n","out":"ERROR: Can't locate IO/Socket/INET.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Can't locate IO/Socket/INET.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use IO::Socket::INET;  my $sock = IO::Socket::INET->new(Timeout => 4, Proto => \"tcp\" , PeerAddr => \"www.gamezstorm.com\", PeerPort => 25) or die $!;  for(<$sock>){print $_ ,\"\\n\";}\n"},{"code":"use IPC::Shm\n","out":"ERROR: Can't locate IPC/Shm.pm:   (null): Too many open files at (eval 558) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 2, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Can't locate iso.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use iso-8859-1; uc \"Ã±\"\n"},{"code":"use iso8859-1; uc \"Ã±\"\n","out":"ERROR: Can't locate iso8859.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Can't locate iso8859.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use iso8859; uc \"Ã±\"\n"},{"code":"use JSON (); { abc => 123 }->JSON::encode_json\n","err":"","out":"ERROR: Can't call method \"encode_json\" on unblessed reference at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use JSON; from_json q~ { \"a\" : \"b\" } ~\n","err":"","out":"{a => \"b\"}"},{"out":"[{\"name\":3},{\"name\":4}]","err":"","code":"use JSON; @list = ({name => 1}, {name => 2}, {name => 3}, {name => 4}); to_json([grep { $_->{name} > 2 } @list])\n"},{"code":"use JSON; @list = ({name => 1, x => one}, {name => 2, x => two}, {name => 3, x => three}, {name => 4, x => four}); to_json([map {$_->{x}} grep { $_->{name} > 2 } @list])\n","err":"","out":"[\"three\",\"four\"]"},{"code":"use JSON'MaybeXS;\n","err":"","out":""},{"code":"use JSON::MaybeXS; [encode_json [''.1341015082000]]\n","out":"[\"[\\\"1341015082000\\\"]\"]","err":""},{"out":"[\"[1341015082000]\"]","err":"","code":"use JSON::MaybeXS; [encode_json [1341015082000]]\n"},{"out":"ERROR: hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use JSON::MaybeXS; [encode_json 1341015082000]\n"},{"out":"{\"foo\":\"1.20\"}","err":"","code":"use JSON::MaybeXS; encode_json { foo => '1.20' }\n"},{"out":"{\"foo\":\"1.22\"}","err":"","code":"use JSON::MaybeXS; encode_json { foo => '1.22' }\n"},{"err":"","out":"{\"foo\":\"1.22\"}","code":"use JSON::MaybeXS; encode_json { foo => sprintf '%.2f', 1.22 }\n"},{"out":"Cpanel::JSON::XS","err":"","code":"use JSON::MaybeXS; JSON()\n"},{"err":"","out":"\"\\u0007\"","code":"use JSON::MaybeXS; JSON::MaybeXS->new(allow_nonref => 1, ascii => 0)->encode(\"\\07\")\n"},{"err":"","out":"\"\\u2603\"","code":"use JSON::MaybeXS; JSON::MaybeXS->new(allow_nonref => 1, ascii => 1)->encode(\"\\x{2603}\")\n"},{"out":"\"\\u0007\"","err":"","code":"use JSON::MaybeXS; JSON::MaybeXS->new(allow_nonref => 1)->encode(\"\\07\")\n"},{"out":"[0,1,2,3,4,5,6,7,11,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]","err":"","code":"use JSON::MaybeXS; my $j = JSON::MaybeXS->new(allow_nonref => 1, ascii => 1); [grep { $j->encode(chr($_)) =~ /\\\\u/ } 0..127]\n"},{"code":"use JSON::MaybeXS; my $json = JSON::MaybeXS->new(allow_nonref => 1, ascii => 1); my $encoded = $json->encode(\"\\x{2603}\"); [$encoded, $json->decode($encoded)]\n","out":"[\"\\\"\\\\u2603\\\"\",\"\\x{2603}\"]","err":""},{"err":"","out":"[\"\\\"\\\\u2603\\\"\"]","code":"use JSON::MaybeXS; my $json_str = JSON::MaybeXS->new(allow_nonref => 1, ascii => 1)->encode(\"\\x{2603}\"); [$json_str]\n"},{"out":"{\n   \"name\" : true\n}\n","err":"","code":"use JSON::MaybeXS; my %test = (name => JSON->true); JSON::MaybeXS->new(pretty => 1)->encode(\\%test)\n"},{"code":"use JSON::MaybeXS; my $var = 1341015082000; [encode_json [\"$var\"]]\n","out":"[\"[\\\"1341015082000\\\"]\"]","err":""},{"out":"[{\"1\":2},{\"3\":4},{\"5\":6}]","err":"","code":"use JSON; my $aoh = [{1=>2},{3=>4}];my $str=encode_json($aoh); my $new_aoh = decode_json($str); push @{ $new_aoh  }, {5=>6}; my $new_str = encode_json($new_aoh); $new_str\n"},{"code":"use JSON; my $var = ~~\"0\"; encode_json([$var])\n","out":"[\"0\"]","err":""},{"code":"use JSON; use strict; my %test = ( name => \\1, ); print JSON->new->pretty->encode(\\%test);\n","err":"","out":"{\n   \"name\" : true\n}\n"},{"code":"use JSON::XS; decode_json('[\"\\ud834\\udd1e\"]')\n","out":"[\"\\x{1d11e}\"]","err":""},{"code":"use less 'abomination';\n","err":"","out":"ERROR: Can't locate less.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use Lingua::EN::Numbers qw(num2en);Â sub isodd {return (num2en shift) =~ /e.?$/}Â \n","err":"","out":"ERROR: Can't locate Lingua/EN/Numbers.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"1","code":"use List::MoreUtils 'any'; if (any {$_ eq 'a'}, 'b', 'c') { 1 }\n"},{"err":"","out":"[[3,4],[1,2,5,6,7,8]]","code":"use List::MoreUtils 'firstidx'; sub merge_refs { my $input = shift; return $input unless @_; my @indices; for my $ref (@_) { push @indices, firstidx { $ref == \\$_ } @$input }; my $merged = $input->[pop @indices]; unshift @$merged, @{splice @$input, $_, 1} for @indices; return $input } my $x = [ [1,2], [3,4], [5,6,7,8] ]; merge_refs $x, \\$x->[0], \\$x->[2];\n"},{"code":"use List::MoreUtils qw(firstidx); my $y = 3; my @list = (1,2,3,4,5,6,7); splice @list, $_, 0, 'above' for grep defined, firstidx { $_ > $y } @list; \\@list\n","err":"","out":"[1,2,3,\"above\",4,5,6,7]"},{"err":"","out":"{x => {a => 1,b => 3,c => 2},z => {a => 3}}","code":"use List::MoreUtils qw(uniq); my %x = (x => {a => 1, c => 2}, z => { a => 3 }); my %y = (x => {b => 3}, z => {a => 4}); my %z = %x; for my $k (uniq keys(%x), keys(%y)) { $z{$k}{$_} = $y{$k}{$_} for grep !exists $x{$k}{$_}, keys %{$y{$k}} } \\%z\n"},{"out":"ERROR: Sort subroutine didn't return single value at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use List::MoreUtils qw/uniq/; [ sort uniq qw/a b c a/ ];\n"},{"code":"use List::MoreUtils qw/uniq/; [ sort(uniq qw/a b c a/) ];\n","err":"","out":"ERROR: Sort subroutine didn't return single value at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"[\"a\",\"b\",\"c\"]","code":"use List::MoreUtils qw/uniq/; [ sort(uniq(qw/a b c a/)) ];\n"},{"err":"","out":"[\"a\",\"b\",\"c\"]","code":"use List::MoreUtils qw/uniq/; [ uniq qw/a b c a/ ];\n"},{"code":"use List::MoreUtils qw(zip); $ab = [ \"a\",\"b\"]; $xyz = [\"u\",\"v\",\"a\",\"b\",\"w\"]; grep defined, @{ { zip @$xyz, @$xyz } }{@$ab} == @$ab\n","out":"1","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"&zip \\\"\n","code":"use List::MoreUtils qw(zip); my @list = qw( AAA BBB CCC ); [ &zip \\@list, [('|') x @list - 1] ]\n"},{"out":"ERROR: Type of arg 2 to List::MoreUtils::mesh must be array (not subtraction (-)) at (eval 558) line 1, near \"1 ]\"\n","err":"","code":"use List::MoreUtils qw(zip); my @list = qw( AAA BBB CCC ); [ zip @list, ('|') x @list - 1 ]\n"},{"code":"use List::MoreUtils qw(zip); my @list = qw( AAA BBB CCC ); [ &zip(\\@list, [('|') x @list - 1]) ]  # hardly worth it\n","err":"","out":"[\"AAA\",-1,\"BBB\",undef,\"CCC\",undef]"},{"code":"use List::Util 0.0 qw(9999);\n","err":"","out":"ERROR: List::Util version 9999 required--this is only version 1.41 at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/Exporter/Heavy.pm line 125, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: List::Util version 9999 required--this is only version 1.41 at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/Exporter/Heavy.pm line 125, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use List::Util 0 qw(9999);\n"},{"out":"","err":"","code":"use List::Util 1.33 'any';@array = qw(1 2 3); print \"match\" if(any{ $_ eq '4'} @array);\n"},{"out":"ERROR: List::Util version 9999 required--this is only version 1.41 at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/Exporter/Heavy.pm line 125, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use List::Util '9999';\n"},{"code":"use List::Util (9999);\n","err":"","out":"ERROR: List::Util version 9999 required--this is only version 1.41 at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/Exporter/Heavy.pm line 125, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't \"goto\" out of a pseudo block at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use List::Util 'first';  first { goto HERE } 1, 2, 3; HERE: print \"hello\"\n"},{"out":"1.41","err":"","code":"use List::Util; $List::Util::VERSION\n"},{"out":"3","err":"","code":"use List::Util 'max';max 2,3;\n"},{"err":"","out":"3","code":"use List::Util 'max';max 2,3;max(2,3);\n"},{"err":"","out":"9","code":"use List::Util 'max';  max(4, 9)\n"},{"err":"","out":"1","code":"use List::Util; my $c = [qw(a b c)]; print \"1\" if List::Util::any { $_ eq \"a\" } @{$c}\n"},{"code":"use List::Util 'product';  product 0, 1\n","out":"","err":""},{"code":"use List::Util () qw(9999);\n","out":"ERROR: syntax error at (eval 558) line 1, near \") qw(9999)\"\n","err":""},{"code":"use List::Util qw(9999);\n","err":"","out":"ERROR: List::Util version 9999 required--this is only version 1.41 at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/Exporter/Heavy.pm line 125, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: List::Util version 9999 required--this is only version 1.41 at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/Exporter/Heavy.pm line 125, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use List::Util qw(any 9999);\n"},{"code":"use List::Util qw(any); my @x = qw(a b c); my @y = qw(d e f); for my $_ (@x) { print \"found\" if any { /b/ } @y } # I know it's in Texas, probably in Tennnessee...\n","err":"","out":"found"},{"err":"","out":"2","code":"use List::Util qw/first/; --$i if first { $i++; /z/ } qw/foo bar baz/   # even more vomit inducing\n"},{"out":"[1,2,3,\"above\",5,6,7]","err":"","code":"use List::Util qw(first); my $y = 3; my @list = (1,2,3,4,5,6,7); $_ = 'above' for grep defined, first { $_ > $y } @list; \\@list # ?\n"},{"err":"","out":"[30]","code":"use List::Util qw(max); my $str = '( G1 Z0.252 F7200.000 )'; [ max 30, $str =~ /G1 Z(\\d+\\.\\d+)/ ];\n"},{"code":"use List::Util qw(max); my $str = '( G1 Z0.252 F7200.000 )'; my ($value) = $str =~ /G1 Z(\\d+\\.\\d+)/; max 30, $value\n","out":"30","err":""},{"code":"use List::Util qw(min); [ map \"$_\", \\&min, \\&List::Util::min ] # Exporter gives the same value for both\n","out":"[\"CODE(0xbd2908)\",\"CODE(0xbd2908)\"]","err":""},{"err":"","out":"ERROR: Not an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n","code":"use List::Util qw( pairmap ); do { my %pairs; pairmap { push $pairs{$a}, $b; } ( \"x\", \"1\", \"x\", \"2\", \"y\", \"baz\" ); \\%pairs; };\n"},{"code":"use List::Util qw( pairmap ); my %pairs; pairmap { push @{ $pairs{$a} }, $b; } ( \"x\", \"1\", \"x\", \"2\", \"y\", \"baz\" ); \\%pairs\n","out":"{y => [\"baz\"],x => [1,2]}","err":""},{"err":"","out":"[\"T\",\"F\",\"T\",\"T\"]","code":"use List::Util qw(pairmap); [ pairmap { !($a * !$b) ? 'T' : 'F' } qw(1 1 1 0 0 1 0 0) ]\n"},{"err":"","out":"[\"T\",\"F\",\"T\",\"T\"]","code":"use List::Util qw(pairmap); [ pairmap { !$a || $b ? 'T' : 'F' } qw(1 1 1 0 0 1 0 0) ]\n"},{"code":"use List::Util qw(product); say product 1..10;\n","out":"3628800\n","err":""},{"code":"use List::Util qw(reduce); my @ar = qw /a list of errors/; [reduce {$a.\" \".$b} @ar]\n","err":"","out":"[\"a list of errors\"]"},{"out":"[1,2,2,3,3,4,4,5]","err":"","code":"use List::Util qw(reduce); my @output; reduce { push @output, ($a, $b); $b } qw(1 2 3 4 5); \\@output\n"},{"err":"","out":"0","code":"use List::Util qw(reduce); reduce {$1*$b} 1..10;\n"},{"err":"","out":"3628800","code":"use List::Util qw(reduce); reduce {$a*$b} 1..10;\n"},{"code":"use List::Util qw(sum0); [ map sum0(@$_), grep $_->[0] ** 2 == $_->[1] ** 2 + $_->[2] ** 2, map { my ($x, $y) = @$_; map [ $x, $y, $_ ], 1..$y } map { my $x = $_; map [ $x, $_ ], 1..$x } 1..10 ] # probably wrong, but you can see why the map approach isn't great here\n","out":"[12,24]","err":""},{"code":"use List::Util qw(sum); chr sum map ord, qw(A B C);\n","out":"ÃÂ","err":""},{"err":"","out":"[262]","code":"use List::Util qw/sum/; [ sum '92.168.1.1' =~ /(\\d+)/g ]\n"},{"code":"use List::Util qw(sum); sum map ord, qw(A B C);\n","out":"198","err":""},{"err":"","out":"1","code":"use List::Util 'reduce';  reduce { die \"BOK\" } 1\n"},{"err":"","out":"ERROR: BOK at (eval 558) line 1, <STDIN> line 1.\n","code":"use List::Util 'reduce';  reduce { die \"BOK\" } 1, 2\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"1. 2\"\n","err":"","code":"use List::Util 'reduce';  reduce { die \"BOK\" } 1. 2\n"},{"err":"","out":"","code":"use List::UtilsBy;\n"},{"out":"[[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\"],[\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\"],[\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]]","err":"","code":"use List::UtilsBy 'bundle_by'; my @array = split '', 'abcdefghijklmnopqrstuvwxyz'; [bundle_by { [@_] } 9, @array]\n"},{"code":"use List::UtilsBy qw(partition_by); +{ partition_by { $_ % 3 } 1..12 } # perlbot has all the things\n","out":"{0 => [3,6,9,12],2 => [2,5,8,11],1 => [1,4,7,10]}","err":""},{"code":"use List::UtilsBy qw(sort_by); [ sort_by { $_->{name} } { name => 'x' }, { name => 'y' }, { name => 'z' } ]\n","err":"","out":"[{name => \"x\"},{name => \"y\"},{name => \"z\"}]"},{"code":"use List::UtilsBy qw(zip_by); @a=map{$_%10}zip_by{$_[0]+$_[1]}[9,5,3],[map{9-$_}1,7,6];++@a[-1]; [@a]\n","out":"[7,7,7]","err":""},{"code":"use List::UtilsBy 'sort_by'; @topics = qw/alias:topic alias:topic2 topic/; %t =map { s/^alias://r => $_ } sort_by { ! /^alias:/ } @topics; [ values %t ]\n","out":"[\"alias:topic2\",\"topic\"]","err":""},{"err":"","out":"{\"alias:topic\" => \"topic\",\"alias:topic2\" => \"topic2\"}","code":"use List::UtilsBy 'sort_by'; @topics = qw/alias:topic topic2 topic/; %t =map { (/^alias:/ ? $_ : \"alias:$_\") => $_ } sort_by { ! /^alias:/ } @topics; \\%t\n"},{"err":"","out":"[\"topic\",\"topic2\"]","code":"use List::UtilsBy 'sort_by'; @topics = qw/alias:topic topic2 topic/; %t =map { s/^alias://r => $_ } sort_by { ! /^alias:/ } @topics; [ values %t ]\n"},{"code":"use List::UtilsBy 'sort_by'; @topics = qw/topic topic2 alias:topic/; %t =map { (/^alias:/ ? $_ : \"alias:$_\") => $_ } sort_by { ! /^alias:/ } @topics; \\%t\n","out":"{\"alias:topic\" => \"topic\",\"alias:topic2\" => \"topic2\"}","err":""},{"code":"use List::UtilsBy 'sort_by'; @topics = qw/topic topic2 alias:topic/; %t =map { (/^alias:/ ? $_ : \"alias:$_\") => $_ } sort_by { /^alias:/ } @topics; \\%t\n","out":"{\"alias:topic\" => \"alias:topic\",\"alias:topic2\" => \"topic2\"}","err":""},{"out":"AaBbCc","err":"","code":"use List::UtilsBy 'zip_by'; my $u = 'ABC'; my $l = 'abc'; join '', zip_by { @_ } map { [split //] } $u, $l\n"},{"code":"use List::UtilsBy 'zip_by'; my $u = 'ABC'; my $l = 'abc'; join '', zip_by { @_ } [split //, $u], [split //, $l]\n","out":"AaBbCc","err":""},{"code":"use List::Util 'sum'; sum map { 1 / $_ } ( 1,3,5,7,9,11,13,15,17 )\n","err":"","out":"2.08062395121219"},{"code":"use List::Util 'sum'; sum map { 1 / $_ } ( 1,3,5,7,9,13,15,17,19 )\n","err":"","out":"2.04234643925046"},{"code":"use List::Util; use strict; use warnings; my $y = max $a, $b; # perl5.20 gives me \"Useless use of a variable in void context\" there, not sure why this one doesn't\n","out":"ERROR: Can't call method \"max\" on an undefined value at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Can't locate LWP/UserAgent.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use LWP::UserAgent; my $ua = LWP::UserAgent->new; length $ua\n"},{"code":"use manager::dedicated::dedicated.fr;\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"use manager::dedicated::dedicated.\"\n"},{"code":"use Math::BigInt\n","err":"","out":""},{"out":"[bless( {sign => \"NaN\",value => [0]}, 'Math::BigInt' )]","err":"","code":"use Math::BigInt; [157 + \"9.95\" + Math::BigInt->new(13) + 0]\n"},{"out":"Inf","err":"","code":"use Math::BigInt; 1e1000\n"},{"code":"use Math::BigInt; 2790**2753 % 3233\n","err":"","out":"NaN"},{"err":"","out":"3.14159265358979","code":"use Math::BigInt; atan2(0, -1);\n"},{"out":"bless( {value => [176640045,432902008,3],sign => \"+\"}, 'Math::BigInt' )","err":"","code":"use Math::BigInt; Math::BigInt->new(\"3432902008176640045\")\n"},{"err":"","out":"[\"0x7d0\"]","code":"use Math::BigInt; my $x = Math::BigInt->new(2000); [ $x->as_hex ]\n"},{"code":"use Math::BigInt; $x=Math::BigInt->new(4); print $x->bfac();\n","out":"24","err":""},{"err":"","out":"242","code":"use Math::BigInt; $x=Math::BigInt->new(4); $y=Math::BigInt->new(2); print $x->bfac(); print $y->bfac();\n"},{"code":"use Math::Complex; sqrt -1\n","out":"ERROR: Can't locate Math/Complex.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Can't locate Math/Round.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use Math::Round; round(3.2939232942 * 100) / 100\n"},{"code":"use Math; sqrt -1;\n","out":"ERROR: Can't locate Math.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"","code":"use MIME::Base64;\n"},{"out":"ERROR: Can't locate Missing/Thing.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use Missing::Thing;\n"},{"out":"ERROR: Can't locate Module/Build.pm:   (null): Too many open files at (eval 558) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 2, <STDIN> line 1.\n","err":"","code":"use Module::Build\n"},{"err":"","out":"ERROR: Can't locate Module/Corelist.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use Module::Corelist; [ Module::Corelist->first_release( 'experimental' ) ]\n"},{"code":"use Module::CoreList; [ Module::CoreList->first_release( 'experimental' ) ]\n","err":"","out":"ERROR: Can't locate Module/CoreList.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"","code":"use Mojo::DOM;\n"},{"err":"","out":"<html><head><meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"></head><body></body></html>","code":"use Mojo::DOM; my $dom = Mojo::DOM->new('<html><head></head><body></body></html>'); $dom->at('head')->append_content('<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"></meta>'); $dom->to_string\n"},{"err":"","out":"bless( do{\\(my $o = bless( {tree => [\"root\",[\"tag\",\"html\",{},${$VAR1}->{tree},[\"tag\",\"head\",{},${$VAR1}->{tree}->[1]],[\"tag\",\"meta\",{\"http-equiv\" => \"Content-Type\",content => \"text/html; charset=utf-8\"},${$VAR1}->{tree}->[1]],[\"tag\",\"body\",{},${$VAR1}->{tree}->[1]]]]}, 'Mojo::DOM::HTML' ))}, 'Mojo::DOM' )","code":"use Mojo::DOM; my $dom = Mojo::DOM->new('<html><head></head><body></body></html>'); $dom->at('head')->append('<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"></meta>'); $dom\n"},{"code":"use Mojo::DOM; my $dom = Mojo::DOM->new('<html><head></head><body></body></html>'); $dom->at('head')->append('<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"></meta>'); $dom->to_string\n","err":"","out":"<html><head></head><meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\"><body></body></html>"},{"err":"","out":"","code":"use Mojo::DOM; use Mojo::DOM::CSS; use Mojo::Collection;\n"},{"err":"","out":"ERROR: Can't locate Mojo/JSON.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use Mojo::JSON; my $var = 1341015082000; [encode_json [\"$var\"]]\n"},{"code":"use Mojo::Util 'punycode_decode'; encode 'UTF-8', punycode_decode 'wkr'\n","out":"ÃÂ¥ÃÂÃÂ","err":""},{"out":"ÃÂ¥ÃÂÃÂ","err":"","code":"use Mojo::Util 'punycode_decode'; encode 'UTF-8', punycode_decode zkr\n"},{"err":"Prototype mismatch: sub main::decode ($$;$) vs none at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/Exporter.pm line 66, <STDIN> line 1.\n at (eval 558) line 1.\n","out":"tdi","code":"use Mojo::Util 'punycode_encode', 'decode'; punycode_encode decode('UTF-8', 'â')\n"},{"code":"use Mojo::Util 'punycode_encode'; punycode_encode decode('UTF-8', 'â')\n","err":"","out":"tdi"},{"code":"use Moo;\n","out":"ERROR: Can't locate Moo.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use Moose ()\n","out":"","err":""},{"code":"use Moose;\n","out":"","err":""},{"err":"","out":"7","code":"use Moose; 7;\n"},{"code":"use Net::HTTP::Spore;\n","out":"ERROR: Can't locate Net/HTTP/Spore.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Can't locate Number/Format.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use Number::Format qw(:subs :vars); $THOUSANDS_SEP = '.'; my $a = 123456789; say format_number($a);\n"},{"code":"use open IN  => \":crlf\", OUT => \":bytes\"; [ ${^OPEN} ]\n","out":"ERROR: Can't locate open.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Can't locate or.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use or die perl;\n"},{"err":"","out":"[\"forty two\"]","code":"use overload q|\"\"| => sub { 42 }; my @a; $a[42] = 'forty two'; [ $a[bless {}, 'main'] ]\n"},{"code":"use overload qw,\"\",=> sub { die }; bless {}, bless []; 42;\n","err":"","out":"ERROR: Died at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use overload '\"\"' => sub { \"\" }, \"bool\" => sub { 1 }; my $foo = bless []; if( $foo ) { print \"_${foo}\" } else { print \"aww\" }\n","out":"_","err":""},{"code":"use overload '@{}' => sub { print 'converting to array'; ['42'] }; my $foo; bless \\$foo; (\\$foo)->[0];\n","err":"","out":"converting to array"},{"err":"","out":"ERROR: Undefined subroutine &main::primt called at (eval 558) line 1, <STDIN> line 1.\n","code":"use overload '@{}' => sub { print 'converting to array'; ['42'] }; my $foo; bless \\$foo; primt (\\$foo)->[0];\n"},{"code":"use overload '@{}' => sub { print 'converting to array'; ['42'] }; my $foo; bless \\$foo; print + (\\$foo)->[0];\n","out":"converting to array42","err":""},{"code":"use overload '+' => sub { print \"foo\" }; my $x = bless []; $x + 2;\n","err":"","out":"foo"},{"code":"use overload '@{}' => sub { say 'converting to array'; ['42'] }; my $foo; bless \\$foo; (\\$foo)->[0];\n","err":"","out":"converting to array\n"},{"code":"use overload '\"\"' => sub { shift @{ shift() } || '' }; $, = bless [' another ', ' hacker']; print qw(Just Perl ,);\n","out":"Just another Perl hacker,","err":""},{"code":"use overload '\"\"' => sub { \"wibble\" }; $x = []; bless $x; $y = []; bless $y, $x; ref $y\n","out":"wibble","err":""},{"code":"use Perl;\n","err":"","out":"ERROR: Can't locate Perl.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"3.29","code":"use POSIX; floor((3.2949232942 + 0.005) * 100)/100\n"},{"code":"use POSIX; floor((3.2959232942 + 0.005) * 100)/100\n","err":"","out":"3.3"},{"code":"use POSIX qw(atan); 4*atan(1) # if you disapprove of passing multiple parameters to a function, there are alternatives\n","err":"","out":"3.14159265358979"},{"out":"1","err":"","code":"use POSIX qw(floor); floor(5/3)\n"},{"err":"","out":"\n","code":"use POSIX qw/locale_h/; say setlocale(LC_TIME, \"ja_JP.utf-8\");\n"},{"code":"use POSIX qw( modf ); my $n = 1.2345; sprintf q{%02d%s}, reverse map { s/^0+//r } modf $n; ### leobut\n","err":"","out":"01.2345"},{"out":"01","err":"","code":"use POSIX qw( modf ); my $n = 1; sprintf q{%02d%s}, reverse map { s/^0+//r } modf $n; ### leobut\n"},{"err":"","out":"[268435456]","code":"use POSIX qw(sysconf); [ sysconf(_SC_PAGE_SIZE) ]\n"},{"out":"23.45","err":"","code":"use POSIX; setlocale(LC_NUMERIC, \"de_DE\"); sprintf(\"%.2f\", 23.45)\n"},{"code":"use Psychic::Hotline;\n","out":"ERROR: Can't locate Psychic/Hotline.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use Quote::Code\n","out":"ERROR: Can't locate Quote/Code.pm:   (null): Too many open files at (eval 558) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 2, <STDIN> line 1.\n","err":""},{"code":"use Quote::Code; qc{!}\n","out":"ERROR: Can't locate Quote/Code.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Can't locate Quote/Code.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use Quote::Code; [ qcw< a {$_} b > ]\n"},{"code":"[ 'user:anything-else:' !~ /^user:!!:$/ ]\n","out":"[1]","err":""},{"err":"Compiling REx \"^+\"\nFinal program:\n   1: CURLYX[0] {1,32767} (5)\n   3:   SBOL /^/ (4)\n   4: WHILEM[1/1] (0)\n   5: NOTHING (6)\n   6: END (0)\nanchored(SBOL) minlen 0 \nMatching REx \"^+\" against \"\"\n   0 <> <>                   |  1:CURLYX[0] {1,32767}(5)\n   0 <> <>                   |  4:  WHILEM[1/1](0)\n                                    whilem: matched 0 out of 1..32767\n   0 <> <>                   |  3:    SBOL /^/(4)\n   0 <> <>                   |  4:    WHILEM[1/1](0)\n                                      whilem: matched 1 out of 1..32767\n                                      whilem: empty match detected, trying continuation...\n   0 <> <>                   |  5:      NOTHING(6)\n   0 <> <>                   |  6:      END(0)\nMatch successful!\nFreeing REx: \"^+\"\n","out":"1","code":"use re 'debug'; /^+/\n"},{"code":"use re 'debug'; /a(bc)+/o;\n","err":"Compiling REx \"a(bc)+\"\nFinal program:\n   1: EXACT <a> (3)\n   3: CURLYM[1] {1,32767} (13)\n   7:   EXACT <bc> (11)\n  11:   SUCCEED (0)\n  12: NOTHING (13)\n  13: END (0)\nanchored \"abc\" at 0 floating \"bc\" at 1..9223372036854775807 (checking anchored) minlen 3 \nFreeing REx: \"a(bc)+\"\n","out":""},{"out":"ERROR: Can't locate Regexp/Assemble.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use Regexp::Assemble;\n"},{"out":"0.1231e10","err":"","code":"use Regexp::Common; (\"12 bananas buys you 0.1231e10 ruby\" =~ /$RE{num}{real}/g)[1]\n"},{"code":"use Regexp::Common; print \"ok\" if (\"foo bar)\" eq \"(foo bar))\" =~ s/($RE{balanced}{-parens => \"()\"})/$1/r);\n","err":"","out":""},{"code":"use Regexp::Common qw/net/; my $ip = q(100.10.1.101); [$ip =~ /$RE{net}{IPv4}/]\n","out":"[1]","err":""},{"err":"","out":"[]","code":"use Regexp::Common qw/net/; my $ip = q(100.10.1.101); [$ip =~ /\\[$RE{net}{IPv4}\\]/]\n"},{"err":"","out":"[\"100.10.1.101\"]","code":"use Regexp::Common qw/net/; my $ip = q(100.10.1.101); [$ip =~ /($RE{net}{IPv4})/] # I meant that\n"},{"code":"use Regexp::Common qw( net ); $_ = q(00:11:22:33:44:55); if (/$RE{net}{MAC}{-keep}/) { print \"<b>$3:$4</b>\"; }\n","err":"","out":"<b>11:22</b>"},{"err":"","out":"ERROR: Can't locate Return/MultiLevel.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use Return::MultiLevel;\n"},{"err":"","out":"[\"\"]","code":"[ 'user:!!:' !~ /^user:!!:$/ ]\n"},{"err":"","out":"1","code":"'user' =~ /user(?!-agent)/\n"},{"code":"use Scalar::Util\n","out":"","err":""},{"err":"","out":"[\"Regexp\"]","code":"use Scalar::Util 'blessed'; my $re = qr/hai/; [blessed $re]\n"},{"code":"use Scalar::Util 'looks_like_number'; looks_like_number '10%s'\n","out":"","err":""},{"code":"use Scalar::Util 'looks_like_number'; looks_like_number('123abc   ')\n","out":"","err":""},{"err":"","out":"1","code":"use Scalar::Util 'looks_like_number'; looks_like_number('     9') ? 1 : 0\n"},{"out":"[123,\"4.5\",\"5E7\"]","err":"","code":"use Scalar::Util 'looks_like_number'; my $s = qq{ 123 4.5 0xFF 5E7 }; [ grep looks_like_number $_, split /\\s+/, $s ];\n"},{"code":"use Scalar::Util 'looks_like_number'; my $s = qq{ 123 4.5 0xFF 5E7 }; [ map 0+$_, grep looks_like_number $_, split /\\s+/, $s ];\n","out":"[123,\"4.5\",50000000]","err":""},{"code":"use Scalar::Util qw(dualvar); my $foo = dualvar 42, \"\"; if ($foo) { print \"_${foo}_\"; } else { print \"aww\"; }\n","err":"","out":"aww"},{"out":"[\"two\",\"one\"]","err":"","code":"use Scalar::Util qw/dualvar/; my $i = dualvar 1, 'forty two'; my @a = qw/one two/; [ $a[ $i ], $a[ \"$i\" ] ]; # fun :)\n"},{"code":"use Scalar::Util qw(dualvar); my $x = dualvar 12, 'twelve'; my $y = $x; [ 0+$y, \"$y\" ] # so something like this\n","err":"","out":"[12,\"twelve\"]"},{"code":"use Scalar::Util qw/dualvar/; my $x = dualvar 42, 'forty two'; [$x+0, \"$x\"]\n","err":"","out":"[42,\"forty two\"]"},{"code":"use Scalar::Util qw/dualvar/; my $x = dualvar 42, 'forty two'; [$x+0, \"$x\"]>\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n"},{"code":"use Scalar::Util qw/dualvar/; $x = dualvar 42, 'foo'; [ $x.'', $x+0 ]\n","out":"[\"foo\",42]","err":""},{"code":"use Scalar::Util qw(looks_like_number); looks_like_number '4'\n","out":"1","err":""},{"err":"","out":"\\o/","code":"use Scalar::Util qw(looks_like_number); looks_like_number 'infinity' ? '\\o/' : '/o\\\\'\n"},{"code":"use Scalar::Util qw(looks_like_number); looks_like_number 'Inf'  # wat\n","out":"1","err":""},{"err":"","out":"1","code":"use Scalar::Util qw(looks_like_number); looks_like_number 'nan'\n"},{"err":"","out":"1","code":"use Scalar::Util qw(looks_like_number); looks_like_number 'NAN'\n"},{"code":"use Scalar::Util qw(looks_like_number); looks_like_number 'nandos';\n","err":"","out":""},{"code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'sNan' ]\n","out":"[1]","err":""},{"out":"{23 => \"Yes\",-32 => \"Yes\",\"0xFF\" => \"No\",FF => \"No\",\"123.456\" => \"Yes\",0 => \"Yes\",255 => \"Yes\",abc => \"No\",106000 => \"Yes\"}","err":"","code":"use Scalar::Util qw(looks_like_number); +{ map { $_ => looks_like_number $_ ? q{Yes} : q{No} } 0, 123.456, 10.6E4, q{abc}, q{FF}, q{0xFF}, 0xFF, +23, \"-32\" }; ### Seems to fill my needs. I'm wondering if there are any gotchas.\n"},{"out":"[87213600,87213600]","err":"","code":"use Scalar::Util qw(refaddr); my $meow = []; [refaddr($meow), refaddr(\\@{$meow})]\n"},{"code":"use Scalar::Util qw( refaddr); sub foo { } my $foo = \\&foo; my $bar = \\&bar; [ refaddr $foo eq refaddr $bar ]\n","out":"[\"\"]","err":""},{"out":"ERROR: Missing right curly or square bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, at EOF\n","err":"","code":"use Scalar::Util qw/reftype blessed/; my $obj = bless {}, 'ARRAY'; my $obj2 = bless {}, 'Foo'; { obj => [ ref($obj), reftype($obj), blessed($obj) ], obj2 => [ref($obj2), reftype($obj2), blessed($obj2)], ref => [ ref([]), reftype([]), blessed([]) ]\n"},{"code":"use Scalar::Util qw/reftype blessed/; my $obj = bless {}, 'ARRAY'; my $obj2 = bless {}, 'Foo'; { obj => [ ref($obj), reftype($obj), blessed($obj) ], obj2 => [ref($obj2), reftype($obj2), blessed($obj2)], ref => [ ref([]), reftype([]), blessed([]) ] }\n","err":"","out":"{obj2 => [\"Foo\",\"HASH\",\"Foo\"],obj => [\"ARRAY\",\"HASH\",\"ARRAY\"],ref => [\"ARRAY\",\"ARRAY\",undef]}"},{"out":"[\"FOO=ARRAY(0x50d89d8)\",\"FOO\",\"ARRAY\"]","err":"","code":"use Scalar::Util qw(reftype); my $x = bless [7,8,9], q{FOO}; [ qq{$x}, ref $x, reftype $x ]; # Cool :)\n"},{"out":"[\"IO\"]","err":"","code":"use Scalar::Util qw,reftype,; [ reftype *STDOUT{IO} ]\n"},{"code":"use Scalar::Util qw(weaken); my $v; $v = sub { my $x = $v; 1 }; $v->(); weaken $v; die if $v # dropping the extra var and moving weaken() after the call looks okay to me\n","out":"","err":""},{"code":"use Scalar::Util 'refaddr'; my $foo = []; my $addr = sprintf '%x', refaddr $foo; my %bar = ($foo => 1, \"ARRAY(0x$addr)\" => 1); \\%bar\n","err":"","out":"{\"ARRAY(0x498c738)\" => 1}"},{"err":"","out":"[86771728,86771656,{foo => 43}]","code":"use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $h2={foo=>43}; %$h=%$h2; [ refaddr($h), refaddr($h2), $h ]\n"},{"err":"","out":"[75465200,75464960,{}]","code":"use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $h2={foo=>43}; %$h=%h2; [ refaddr($h), refaddr($h2), $h ]\n"},{"err":"","out":"ERROR: Can't call method \"mh\" on an undefined value at (eval 558) line 1, <STDIN> line 1.\n","code":"use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $hadd1 = refaddr $h; my $h2={foo=>43}; mh $h2add1 = refaddr $h2; %$h=%h2; [ $hadd1, $h2add1, refaddr($h), refaddr($h2), $h ]\n"},{"code":"use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $hadd1 = refaddr $h; my $h2={foo=>43}; my $h2add1 = refaddr $h2; %$h=%$h2; [ $hadd1, $h2add1, refaddr($h), refaddr($h2), $h ]\n","out":"[106132320,106132248,106132320,106132248,{foo => 43}]","err":""},{"err":"","out":"[83948504,83948432,83948504,83948432,{}]","code":"use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $hadd1 = refaddr $h; my $h2={foo=>43}; my $h2add1 = refaddr $h2; %$h=%h2; [ $hadd1, $h2add1, refaddr($h), refaddr($h2), $h ]\n"},{"code":"use Scalar::Util 'refaddr'; my $h = { foo => 42 }; [ refaddr($h), refaddr(\\%{$h}) ]\n","err":"","out":"[76892184,76892184]"},{"code":"use Scalar::Util 'reftype'; eval: $x = 'three'; $y = \\$x; [ reftype $x, reftype $y ] #as contrast\n","out":"[undef,\"SCALAR\"]","err":""},{"out":"[\"REF\",\"REF\"]","err":"","code":"use Scalar::Util 'reftype'; eval: $x = 'three'; $y = \\$x; $x = \\$x; [ reftype $x, reftype $y ]\n"},{"err":"","out":"ARRAY","code":"use Scalar::Util 'reftype'; my $r = bless [], \"HASH\";  reftype $r\n"},{"out":"[\"\",undef]","err":"","code":"use Scalar::Util 'reftype'; [ ref undef, reftype undef ]\n"},{"code":"use Scalar::Util 'weaken'; my $foo = {}; my $bar = {}; my $closure; { my ($foo2, $bar2) = ($foo, $bar); $closure = sub { $foo2 }; } weaken $foo; weaken $bar; [$foo, $bar]\n","err":"","out":"[{},undef]"},{"out":"ERROR: Can't locate signatures.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use signatures; sub foo () { 5 } say foo, \"bar\";\n"},{"err":"","out":"ERROR: Can't locate Socket.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use Socket 'inet_aton'; [unpack 'N', inet_aton '92.168.1.1']\n"},{"code":"use Socket 'pack_sockaddr_in6'; length pack_sockaddr_in6( 80, \"\\0\" x 16 )\n","out":"ERROR: Can't locate Socket.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Can't locate Socket/pack_sockaddr_in6.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use Socket::pack_sockaddr_in6; length pack_sockaddr_in6( 80, \"\\0\" x 16 )\n"},{"err":"","out":"ERROR: Can't locate Socket.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use Socket qw(inet_pton AF_INET6); my $ip_addr = inet_pton(AF_INET6, \"::ffff:127.0.0.1\"); $ip_addr\n"},{"code":"use Socket;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in(8989,inet_aton(\"107.191.117.124\")))){print S hi};\n","out":"ERROR: Can't locate Socket.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use Storable qw,dclone,; my @arr = ([], []); my $copyref = dclone(\\@arr); $copyref->[0][0] = 3; \\@arr\n","err":"","out":"[[],[]]"},{"out":"SCALAR(0x62bd3d0)","err":"","code":"use Storable qw(nfreeze thaw); my $x = 42; print thaw(nfreeze(\\$x)); # easier to see the issue if you just leave out the pack/unpack, though\n"},{"out":"[{A => 123,C => [\"x\",\"y\",\"z\"],B => \"foo\"},{B => \"foo\",C => [\"x\",\"y\",\"z\"],A => 123}]","err":"","code":"use Storable; use strict; use warnings; my $x = { A => 123, B => q/foo/, C => [ qw(x y z) ] }; my $y = Storable::dclone $x; [ $x, $y ];\n"},{"code":"use Storable; use strict; use warnings; my $x = { A => 123, B => qr/foo/, C => [ qw(x y z) ] }; my $y = Storable::dclone $x; [ $x, $y ];\n","out":"ERROR: Can't store REGEXP items at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use Storable; use strict; use warnings; my $x = { A => 123, B => qr/foo/, C => [ qw(x y z) ] }; my $y = Storable::dclone $x; [ $x, $y ]; ### Why is it so hard to clone Regexp objects?\n","err":"","out":"ERROR: Can't store REGEXP items at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"","err":"","code":"use strict;\n"},{"err":"","out":"ERROR: Can't use string (\"19471\") as a SCALAR ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; [ $$$ ]\n"},{"err":"","out":"[60]","code":"use strict; [ %~, @/, $= ]\n"},{"out":"","err":"","code":"use strict; 0->[0];\n"},{"out":"ERROR: Segmentation Fault\n","err":"","code":"use strict; &{0 == &{0 == 0}} * 0\n"},{"code":"${use strict; 1;};\n","err":"","out":""},{"code":"use strict; ${;1}\n","out":"ERROR: Can't use string (\"1\") as a SCALAR ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"","code":"use strict; ${1}\n"},{"out":"ERROR: Can't use string (\"2\") as a SCALAR ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; ${1 + 1}\n"},{"out":"","err":"","code":"use strict; 1234->{key}\n"},{"code":"use strict; \"${ 12+45 }\"\n","out":"ERROR: Can't use string (\"57\") as a SCALAR ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; ${2}\n","out":"","err":""},{"err":"","out":"ERROR: Undefined subroutine &main::404 called at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; 404->();\n"},{"err":"","out":"ok","code":"use strict; *4 = sub { 'ok' }; &{4};\n"},{"code":"use strict; *4 = sub { 'ok' }; main->${ \\4 };\n","out":"ok","err":""},{"code":"use strict; @5 = \"hi\";\n","err":"","out":"1"},{"code":"use strict; @5 = \"hi\"; \\@5\n","out":"[\"hi\"]","err":""},{"err":"","out":"ERROR: Global symbol \"@a\" requires explicit package name (did you forget to declare \"my @a\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; @a\n"},{"err":"","out":"","code":"use strict; $a->[0];\n"},{"code":"use strict; a->[0]\n","err":"","out":"ERROR: Can't use bareword (\"a\") as an ARRAY ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; $a = \"it works\"; print \"${chr 97}\"\n","out":"ERROR: Can't use string (\"a\") as a SCALAR ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; *{$::{Altreus}}{SCALAR}\n","err":"","out":"ERROR: Can't use an undefined value as a symbol reference at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"","err":"","code":"use strict; $ARGV\n"},{"err":"","out":"1","code":"use strict; \"asd\" ~~ s/^[:ascii:]]//g;\n"},{"code":"use strict; \"asd\" ~~ s/^[:ascii:]]/g;\n","out":"ERROR: Substitution replacement not terminated at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; @b = 42;\n","err":"","out":"ERROR: Global symbol \"@b\" requires explicit package name (did you forget to declare \"my @b\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; BEGIN { package Zomg; *::foo = \\$::foo; }  $foo = 42;\n","err":"","out":"42"},{"code":"use strict; blargh\n","out":"ERROR: Bareword \"blargh\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Undefined subroutine &main::blargh called at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; blargh()\n"},{"err":"","out":"ERROR: Bareword \"config\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; config\n"},{"code":"use strict; defined (my $thing = $_[0]) or $thing = 'default'; $thing;\n","out":"ERROR: Global symbol \"$thing\" requires explicit package name (did you forget to declare \"my $thing\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; @F = 42;\n","out":"ERROR: Global symbol \"@F\" requires explicit package name (did you forget to declare \"my @F\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict \\&{\"foo\"}\n","err":"","out":"ERROR: Unknown 'strict' tag(s) 'CODE(0x62811b8)' at (eval 558) line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; $foo\n","out":"ERROR: Global symbol \"$foo\" requires explicit package name (did you forget to declare \"my $foo\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; \\&{\"foo\"}\n","out":"sub { \"DUMMY\" }","err":""},{"code":"use strict; [ Foo ]\n","out":"ERROR: Bareword \"Foo\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; $foo = 'bar'; ++$$foo; $bar\n","out":"ERROR: Global symbol \"$foo\" requires explicit package name (did you forget to declare \"my $foo\"?) at (eval 558) line 1, <STDIN> line 1.\nGlobal symbol \"$foo\" requires explicit package name (did you forget to declare \"my $foo\"?) at (eval 558) line 1, <STDIN> line 1.\nGlobal symbol \"$bar\" requires explicit package name (did you forget to declare \"my $bar\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; grep my $x = 1, 1, 2, 3; $x\n","out":"","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"}->\"\n","err":"","code":"use strict; {{@{[\"I get it now\"=>2, bar=>3]}}}->{\"I get it now\"}\n"},{"out":"I get it now","err":"","code":"use strict; {{@{[\"I get it now\"=>2, bar=>3]}}}{\"I get it now\"}\n"},{"out":"2","err":"","code":"use strict; ${{@{[\"I get it now\"=>2, bar=>3]}}}{\"I get it now\"}\n"},{"err":"","out":"2","code":"use strict; +{ @{[\"I get it now\"=>2, bar=>3]} }->{\"I get it now\"}\n"},{"err":"","out":"So this takes an arrayref, converts it to a array, then converts it to a hashref which is needed index the key because a hashref puts it into a hash context.  %{@a} does not work because % expects a \"scalar\" like a hashref or an arrayref (same with @), so you have to %{ {@a} }.","code":"use strict; ${ { @{[\"I get it now\"=>'So this takes an arrayref, converts it to a array, then converts it to a hashref which is needed index the key because a hashref puts it into a hash context.  %{@a} does not work because % expects a \"scalar\" like a hashref or an arrayref (same with @), so you have to %{ {@a} }.', bar=>3]} } }{\"I get it now\"}\n"},{"code":"use strict; $INC\n","err":"","out":""},{"err":"","out":"ERROR: Can't use string (\"2\") as a HASH ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; keys (%{ 'dave' => 1, 'bob' => 2 });\n"},{"code":"use strict; [ map { my $foo if 0; ++$foo } 1 .. 10 ]\n","err":"","out":"[1,2,3,4,5,6,7,8,9,10]"},{"out":"ERROR: Global symbol \"$k2\" requires explicit package name (did you forget to declare \"my $k2\"?) at (eval 558) line 1, <STDIN> line 1.\nGlobal symbol \"$v2\" requires explicit package name (did you forget to declare \"my $v2\"?) at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, at EOF\n","err":"","code":"use strict; my $a = {a=>\"BLA\", b=>\"BLO\"}; print \"$k2:$v2\\n\" while((my($k2,$v2) = each %$a);\n"},{"code":"use strict; my $action = \"foo\"; &{$action}()\n","out":"ERROR: Can't use string (\"foo\") as a subroutine ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; my $action = \"foo\"; &{\\&{$action}}()\n","out":"ERROR: Undefined subroutine &main::foo called at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; my $bar; (my $foo, $bar) = 1 .. 2;\n","err":"","out":"2"},{"err":"","out":"ERROR: Global symbol \"$dog\" requires explicit package name (did you forget to declare \"my $dog\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; my $cat, $dog;\n"},{"code":"use strict; my $diff=todayDay-serviceEndDay;\n","out":"ERROR: Bareword \"todayDay\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\nBareword \"serviceEndDay\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; (my $foo, $bar) = ''\n","err":"","out":"ERROR: Global symbol \"$bar\" requires explicit package name (did you forget to declare \"my $bar\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: Global symbol \"$foo\" requires explicit package name (did you forget to declare \"my $foo\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; my $foo = 'bar' and $foo\n"},{"code":"use strict; my %foo; %{ 'foo' }\n","out":"ERROR: Can't use string (\"foo\") as a HASH ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; my %foo; %{ foo }\n","err":"","out":"0"},{"code":"use strict; my %foo; %{ foo; }\n","out":"ERROR: Bareword \"foo\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; my $foo; $foo = sub { return $foo };\n","out":"sub { \"DUMMY\" }","err":""},{"out":"2","err":"","code":"use strict; (my $foo, my $bar) = 1 .. 2;\n"},{"code":"use strict; my $foo = sub { 'hi there!' }; $foo->()\n","err":"","out":"hi there!"},{"code":"use strict; my $foo = sub { return $foo };\n","out":"ERROR: Global symbol \"$foo\" requires explicit package name (did you forget to declare \"my $foo\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Can't use string (\"1\") as a HASH ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; my %hash = (one => 'foo'); sub bar { my $href = @_; $href->{one} = 'baz'; } bar(\\%hash);  [ %hash ]\n"},{"out":"ERROR: Global symbol \"%hash\" requires explicit package name (did you forget to declare \"my %hash\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; @{\\my %hash}{qw(a b)} = (1, 2); \\%hash\n"},{"out":"ERROR: Bareword \"SOME_CONSTANT\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; my %hash = (thing => SOME_CONSTANT); sub SOME_CONSTANT { 5 }; $hash{thing}\n"},{"out":"[undef,{}]","err":"","code":"use strict; my $h; [ (delete $h->{foo}), $h ]\n"},{"code":"use strict; my $h; [ delete $h->{foo}, %$h ]\n","err":"","out":"[undef]"},{"out":"[undef]","err":"","code":"use strict; my $h; [ $h and %$h ]\n"},{"code":"use strict; my $h; [ scalar %$h ]\n","out":"ERROR: Can't use an undefined value as a HASH reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; { my $i = 0; } $i\n","out":"ERROR: Global symbol \"$i\" requires explicit package name (did you forget to declare \"my $i\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Global symbol \"$nwe\" requires explicit package name (did you forget to declare \"my $nwe\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; my $new = \"foo\"; print $nwe;\n"},{"out":"ERROR: Global symbol \"$search_name\" requires explicit package name (did you forget to declare \"my $search_name\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; my $params; my $student; my $search_name = $params->{name} && $student->name =~ /\\Q$search_name/i\n"},{"code":"use strict; my %test = ( name => true, );\n","out":"ERROR: Bareword \"true\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; my $x = 'code'; $$x;\n","err":"","out":"ERROR: Can't use string (\"code\") as a SCALAR ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"[\"-CONSTANT\"]","code":"use strict; my %x = (-+CONSTANT => 123); [keys %x]\n"},{"err":"","out":"[\"-CONSTANT\"]","code":"use strict; my %x = (-CONSTANT => 123); [keys %x]\n"},{"out":"[\"CONSTANT\"]","err":"","code":"use strict; my %x = (+CONSTANT => 123); [keys %x]\n"},{"code":"use strict; my %x = (+CONSTANT => 123); keys %x\n","out":"1","err":""},{"err":"","out":"1/8","code":"use strict; my %x = (+CONSTANT => 123); %x\n"},{"code":"use strict; my $x if $x || 1;\n","err":"","out":"ERROR: Global symbol \"$x\" requires explicit package name (did you forget to declare \"my $x\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"nope","err":"","code":"use strict; my $x = 'nope'; use warnings my $x = 'all'; $x\n"},{"code":"use strict; my @x =  qw(1 2); undef @x; push @x,1;\n","err":"","out":"1"},{"err":"","out":"ERROR: Global symbol \"@x\" requires explicit package name (did you forget to declare \"my @x\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; my %x; $x[1] = 123;\n"},{"code":"use strict; my $x->{y} = $x;\n","err":"","out":"ERROR: Global symbol \"$x\" requires explicit package name (did you forget to declare \"my $x\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Global symbol \"$y\" requires explicit package name (did you forget to declare \"my $y\"?) at (eval 558) line 1, <STDIN> line 1.\nGlobal symbol \"$x\" requires explicit package name (did you forget to declare \"my $x\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; my ($x, $y) = ($y, $x);\n"},{"code":"use strict; package foo; sub bar { our $baz; package fizzbuz; \"[\". ++$baz . \"]\" }; [ bar(), bar()  ]\n","out":"[\"[1]\",\"[2]\"]","err":""},{"out":"ERROR: Global symbol \"$baz\" requires explicit package name (did you forget to declare \"my $baz\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; package foo; sub bar { our $baz; package fizzbuz; \"[\". ++$baz . \"]\" }; [ bar(), bar(), $baz ]\n"},{"err":"","out":"[\"[1]\",\"[2]\",2]","code":"use strict; package foo; sub bar { our $baz; package fizzbuz; \"[\". ++$baz . \"]\" }; [ bar(), bar(), $foo::baz ]\n"},{"err":"","out":"ERROR: Global symbol \"@optype\" requires explicit package name (did you forget to declare \"my @optype\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; package Foo; use B '@optype'; package Bar; [ @optype ]\n"},{"code":"use strict; package Foo; use B '@optype'; package Foo; [ @optype ]\n","err":"","out":"[\"OP\",\"UNOP\",\"BINOP\",\"LOGOP\",\"LISTOP\",\"PMOP\",\"SVOP\",\"PADOP\",\"PVOP\",\"LOOP\",\"COP\",\"METHOP\",\"UNOP_AUX\"]"},{"code":"use strict; print \"${chr(24)}\"\n","err":"","out":"ERROR: Can't use string (\"\u0018\") as a SCALAR ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; print foo::\n","err":"","out":""},{"err":"","out":"foobar","code":"use strict; print foo::, bar:: ;\n"},{"out":"foo\n","err":"","code":"use strict; print(foo::,\"\\n\");\n"},{"code":"use strict; print 'hi' if my $x = 1;\n","out":"hi","err":""},{"code":"use strict; print STDOUT:: foo:: ;\n","err":"","out":"foo1"},{"code":"use 'strict'; print $x;\n","out":"ERROR: syntax error at (eval 558) line 1, near \"use 'strict'\"\n","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"qw(subs):\"\n\"use\" not allowed in expression at (eval 558) line 1, near \": \"\n","code":"use strict qw(subs): use warnings;\n"},{"code":"use strict; @% = qw(x y z); [ \\@%, \"@%\" ] # doesn't even seem to interpolate in a string\n","out":"[[\"x\",\"y\",\"z\"],\"\\@%\"]","err":""},{"out":"ERROR: Can't use string (\"\") as a HASH ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict \"refs\"; %{\"\"}\n"},{"code":"use strict; require foo.pl;\n","err":"","out":"ERROR: Bareword \"pl\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; \"string\"->{key}\n","out":"ERROR: Global symbol \"%string\" requires explicit package name (did you forget to declare \"my %string\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Can't use string (\"string\") as a HASH ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; ${\\\"string\"}->{key}  # why is this different\n"},{"err":"","out":"[main::foo]","code":"use strict; sub AUTOLOAD { our $AUTOLOAD; print \"[$AUTOLOAD]\" }; foo();\n"},{"out":"[main::foo]","err":"","code":"use strict; sub AUTOLOAD { our $AUTOLOAD; print \"[$AUTOLOAD]\" }; my $obj = bless []; $obj->foo();\n"},{"out":"ERROR: Global symbol \"$AUTOLOAD\" requires explicit package name (did you forget to declare \"my $AUTOLOAD\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; sub AUTOLOAD { print \"[$AUTOLOAD]\" }; foo();\n"},{"code":"use strict; sub AUTOLOAD { print \"[$main::AUTOLOAD]\" }; foo();\n","out":"[main::foo]","err":""},{"code":"use strict; sub config { return \"meow\" } config\n","err":"","out":"meow"},{"code":"use strict; sub Foo { \"Bar\" }; [ Foo ]\n","err":"","out":"[\"Bar\"]"},{"out":"foohoo","err":"","code":"use strict; sub foo { 'foohoo' } my $str = 'foo'; __PACKAGE__->can($str)->()\n"},{"err":"","out":"","code":"use strict; sub foo { quux(); } # Grinnz_ I think he means that all his subs don't actually get called..\n"},{"code":"use strict; sub foo { return false; }\n","err":"","out":"ERROR: Bareword \"false\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"hej","code":"use strict; sub lala { 'hej' } my $name = 'lala'; my $ref = \\&$name; $ref->()\n"},{"out":"ERROR: Undefined subroutine &main::subname called at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; subname();\n"},{"err":"","out":"ERROR: Undefined subroutine &main::subname called at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; subname(); { no strict 'refs'; *{__PACKAGE__ . \"::subname\"} = sub {1} }\n"},{"code":"use strict; sub SOME_CONSTANT; my %hash = (thing => SOME_CONSTANT); sub SOME_CONSTANT { 5 }; $hash{thing}\n","err":"","out":"5"},{"code":"use strict; sub what { my ($foo, @_) = @_; \\@_ } what(qw(a b c d));\n","out":"ERROR: Can't use global @_ in \"my\" at (eval 558) line 1, near \", @_\"\n","err":""},{"code":"use strict; try {} catch {};\n","out":"ERROR: Can't call method \"catch\" without a package or object reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; $_ = undef; say @$_[1]; [ $_ ]\n","err":"","out":"\n"},{"code":"use strict; $_ = undef; say @$_[1]; say Data::Dumper::Dumper [ $_ ]\n","out":"\n$VAR1 = [\n          []\n        ];\n\n","err":""},{"out":"[\"OP\",\"UNOP\",\"BINOP\",\"LOGOP\",\"LISTOP\",\"PMOP\",\"SVOP\",\"PADOP\",\"PVOP\",\"LOOP\",\"COP\",\"METHOP\",\"UNOP_AUX\"]","err":"","code":"use strict; use B '@optype'; [ @optype ]\n"},{"out":"ERROR: Global symbol \"$y\" requires explicit package name (did you forget to declare \"my $y\"?) at (eval 558) line 1, <STDIN> line 1.\nGlobal symbol \"$x\" requires explicit package name (did you forget to declare \"my $x\"?) at (eval 558) line 1, <STDIN> line 1.\nGlobal symbol \"$y\" requires explicit package name (did you forget to declare \"my $y\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use feature 'signatures'; sub add ($x = return 0, $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]\n"},{"code":"use strict; use Function::Parameters qw(:strict); fun func($foo, $bar = sub { $foo }) { $bar } func(42)->()\n","err":"","out":"42"},{"code":"use strict; use v5.20; say \"hi\" for Altreus =>\n","err":"","out":"hi\n"},{"err":"","out":"ERROR: Bareword \"Altreus\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use v5.20; say \"hi\" for Altreus;\n"},{"err":"","out":"[0]","code":"use strict; use warnings; [\"$ -\"]\n"},{"code":"use strict; use warnings; $! = 0; close \"yolo\" . rand; \"$!\"\n","out":"Bad file descriptor","err":""},{"out":"","err":"readline() on unopened filehandle at (eval 558) line 1.\n","code":"use strict; use warnings; $! = 0; readline \"yolo\" . rand; \"$!\"\n"},{"err":"","out":"","code":"use strict; use warnings; 1234->{key}\n"},{"err":"","out":"[undef]","code":"use strict; use warnings; [ @$_[3] ]\n"},{"code":"use strict; use warnings; [ @{$_[3]} ] # you sure about that\n","err":"","out":"ERROR: Can't use an undefined value as an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; ['' * 5]\n","err":"Argument \"\" isn't numeric in multiplication (*) at (eval 558) line 1, <STDIN> line 1.\n","out":"[0]"},{"code":"use strict; use warnings; $_ = \"abc123xyz\"; /\\d{,3}/ ? \">$&<\" : \"no\"\n","err":"Unescaped left brace in regex is deprecated, passed through in regex; marked by <-- HERE in m/\\d{ <-- HERE ,3}/ at (eval 558) line 1, <STDIN> line 1.\n","out":"no"},{"code":"use strict; use warnings; @a = {foo => 1, bar => 2}; print ${$a}{\"foo\"}\n","out":"ERROR: Global symbol \"@a\" requires explicit package name (did you forget to declare \"my @a\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"Variable \"@a\" is not imported at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"","err":"","code":"use strict; use warnings; blasdsdasdsa->import\n"},{"out":"","err":"","code":"use strict; use warnings; close \"yolo\" . rand\n"},{"err":"","out":"test\n","code":"use strict; use warnings; CORE::say \"test\" # use 5.016 mostly just covers imports, I think\n"},{"code":"use strict; use warnings; @F=('5'); [@F]\n","out":"ERROR: Global symbol \"@F\" requires explicit package name (did you forget to declare \"my @F\"?) at (eval 558) line 1, <STDIN> line 1.\nGlobal symbol \"@F\" requires explicit package name (did you forget to declare \"my @F\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; use warnings; $_ = \"First Name Position first.name\\@somewhere.com 745 45363\\nSome One Worker some.one\\@somewhere.com 343 5454\\n\" =~ s/^\\s*(\\S)\\S*\\s+(\\S+).+?(\\d\\d\\d \\d\\d\\d\\d)\\s*/$1., $2, $3/gmr # for milfjord :)\n","err":"","out":"F., Name, 745 45363\nS., One, 343 5454"},{"code":"use strict; use warnings; $_ = \"First Name Position first.name\\@somewhere.com 745 45363\\nSome One Worker some.one\\@somewhere.com 343 5454\\n\" =~ s/^\\s*(\\S)\\S*\\s+(\\S+).+?(\\d\\d\\d \\d+)\\s*/$1., $2, $3/gmr # for milfjord :)\n","out":"F., Name, 745 45363S., One, 343 5454","err":""},{"err":"","out":"[\"F., Name, 745 45363\\nS., One, 343 5454\\n\"]","code":"use strict; use warnings; [ \"First Name Position first.name\\@somewhere.com 745 45363\\nSome One Worker some.one\\@somewhere.com 343 5454\\n\" =~ s/^\\s*(\\S)\\S*\\s+(\\S+).+?(\\d\\d\\d \\d+)\\s*/$1., $2, $3\\n/gmr ]\n"},{"err":"","out":"[\"-foo\"]","code":"use strict; use warnings; [-foo]\n"},{"err":"","out":"[\"foo\"]","code":"use strict; use warnings; [foo=>]\n"},{"err":"","out":"ERROR: Global symbol \"@foo\" requires explicit package name (did you forget to declare \"my @foo\"?) at (eval 558) line 1, <STDIN> line 1.\nGlobal symbol \"@foo\" requires explicit package name (did you forget to declare \"my @foo\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; @foo = (1, 2, undef, 4); for my $foo (@foo) { print $foo }\n"},{"err":"","out":"ERROR: Bareword \"foo\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; foo; sub foo { \"foo\" }\n"},{"code":"use strict; use warnings; foo(); sub foo { \"foo\" }\n","err":"","out":"foo"},{"err":"","out":"[]","code":"use strict; use warnings; [ 'hentai' =~ m/#(?:hentai|yuri)/ ] # that line looks fine\n"},{"err":"","out":"Perfectly OK\n","code":"use strict; use warnings; if (0) {i_am_not_defined();} else {print \"Perfectly OK\\n\";}\n"},{"code":"use strict; use warnings; if (1) {} elseif (2) {}\n","err":"elseif should be elsif at (eval 558) line 1, <STDIN> line 1.\n","out":"ERROR: syntax error at (eval 558) line 1, near \") {\"\n"},{"code":"use strict; use warnings; 'inf' * 3\n","out":"Inf","err":""},{"code":"use strict; use warnings; inf * 3\n","out":"bless( {_p => undef,value => [0],sign => \"+inf\",_a => undef}, 'Math::BigInt' )","err":""},{"code":"use strict; use warnings; keys %{'main::'};\n","err":"","out":"ERROR: Can't use string (\"main::\") as a HASH ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"1706","code":"use strict; use warnings; keys %{main::};\n"},{"code":"use strict; use warnings;  length $12345678987654321\n","out":"","err":""},{"out":"UTF-32","err":"Use of uninitialized value $1 in concatenation (.) or string at (eval 559) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; local $_ = \"UCS-4\"; eval q@qr/^UCS-?4-?(BE|LE)?$/i; uc(\"UTF-32$1\")@\n"},{"out":"UTF-32","err":"","code":"use strict; use warnings; local $_ = \"UCS-4\"; my $p = qr/^UCS-?4-?(BE|LE|)?$/i; s@$p@uc(\"UTF-32$1\")@er\n"},{"out":"ERROR: Global symbol \"$x\" requires explicit package name (did you forget to declare \"my $x\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; { local $x = 123; } # nor on undeclared variables\n"},{"code":"use strict; use warnings; [map { $_; last } (1,2,3)]\n","out":"","err":"Useless use of a variable in void context at (eval 558) line 1, <STDIN> line 1.\nExiting eval via last at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; map {print $_} [1,2,3]\n","err":"","out":"ARRAY(0x65bc1c8)"},{"code":"use strict; use warnings; ''.methods.length\n","err":"","out":"ERROR: Bareword \"methods\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; my @a = 'a'..'z'; [ $a[ 2..1 ] ];\n","err":"Argument \"\" isn't numeric in array element at (eval 558) line 1, <STDIN> line 1.\n","out":"[\"a\"]"},{"out":"mno","err":"","code":"use strict; use warnings; my $abc = 'xyz'; my $asdf = 'mno'; sub asdf { return \\$abc; } print \"${asdf}\"\n"},{"code":"use strict; use warnings; my $abc = 'xyz'; sub asdf { return \\$abc; } print \"${asdf}\"\n","err":"","out":"ERROR: Global symbol \"$asdf\" requires explicit package name (did you forget to declare \"my $asdf\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"xyz","err":"","code":"use strict; use warnings; my $abc = 'xyz'; sub asdf { return \\$abc; } print ${asdf()}\n"},{"out":"ERROR: Global symbol \"$asdf\" requires explicit package name (did you forget to declare \"my $asdf\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"Ambiguous use of ${asdf} resolved to $asdf at (eval 558) line 1, <STDIN> line 1.\nVariable \"$asdf\" is not imported at (eval 558) line 1, <STDIN> line 1.\n\t(Did you mean &asdf instead?)\n","code":"use strict; use warnings; my $abc = 'xyz'; sub asdf { return \\$abc; } print ${asdf}\n"},{"err":"","out":"[\"foo=\\\"foo\\\", desc=\\\"lambda\\\", foo=\\\"baz\\\", desc=\\\"bring_it\\\"\"]","code":"use strict; use warnings; my  @a = ({foo=> \"foo\", moo => \"bar\", desc=> \"lambda\",},{foo=>\"baz\", moo=>\"moo\", desc=>\"bring_it\",}); my @keys = ('foo', 'desc'); [join(\", \", map { my $href = $_; map { my $key = $_; \"$key=\\\"$href->{$key}\\\"\" } @keys } @a)]\n"},{"out":"ERROR: Can't modify constant item in scalar assignment at (eval 558) line 1, near \"\"bring_it\",\"\nBareword \"desc\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; my  @a = ({foo=> \"foo\", moo => \"bar\", desc=> \"lambda\",},{foo=>\"baz\", moo=>\"moo\", desc=\"bring_it\",}); my @keys = ('foo', 'desc'); [join(\", \", map { my $href = $_; map { my $key = $_; \"$key=\\\"$href->{$key}\\\"\" } @keys } @a)]\n"},{"err":"","out":"[\"foo=\\\"foo\\\", foo=\\\"baz\\\"\"]","code":"use strict; use warnings; my  @a = ({foo=> \"foo\", moo => \"bar\"},{foo=>\"baz\", moo=>\"moo\"}); my $key = 'foo'; [join(\", \", map { \"$key=\\\"$_->{$key}\\\"\" } @a)]\n"},{"code":"use strict; use warnings; my @allowed = ('a'..'z','A'..'Z',' ', '{','}');my%allowed_hash = (map { $_ => 1 } @allowed); my %found; foreach my $c (split// , q#MPOPCNTSF: INTEGER[9]#) { if (!exists($allowed_hash{$c})) { $found{$c} = 1; } } [sort {$a cmp $b } keys%found]\n","err":"","out":"[9,\":\",\"[\",\"]\"]"},{"code":"use strict; use warnings; my @allowed = ('a'..'z','A'..'Z',' ', '{','}');my%allowed_hash = (map { $_ => 1 } @allowed}; my %found; foreach my $c (split// , q#MPOPCNTSF: INTEGER[9]#) { if (!exists($allowed_hash{$c})) { $found{$c} = 1; } } [sort {$a cmp $b } keys%found]\n","err":"","out":"ERROR: Unmatched right curly bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, at EOF\n"},{"code":"use strict; use warnings;  my $aref = [1,2,3];  @{ $aref + 1 }\n","err":"","out":"ERROR: Can't use string (\"76539649\") as an ARRAY ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; my %args = ( number => 100 ); print $args{number};\n","err":"","out":"100"},{"out":"1","err":"Reference found where even-sized list expected at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value in print at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my %args = { number => 100 }; print $args{number};\n"},{"out":"x","err":"Argument \"\" isn't numeric in array element at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $ar = [qw(x y z a b c)]; $ar->[2..4] # warnings to the rescue?\n"},{"code":"use strict; use warnings; my $array = (1,2,3);\n","out":"3","err":"Useless use of a constant (2) in void context at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; my $array_ref = [3,4,5]; [\"$array_ref\"]\n","out":"[\"ARRAY(0x4e520e8)\"]","err":""},{"err":"","out":"[3]","code":"use strict; use warnings; my $array_ref = [3,4,5]; [scalar @$array_ref]\n"},{"err":"","out":"[\"One\",\"Four\"]","code":"use strict; use warnings; my @arr = ('One', 'Two', 'Three', 'Four'); @arr = grep { !/\\AT/ } @arr; [@arr]\n"},{"err":"Parentheses missing around \"my\" list at (eval 558) line 1, <STDIN> line 1.\n","out":"ERROR: Global symbol \"$dog\" requires explicit package name (did you forget to declare \"my $dog\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $cat, $dog;\n"},{"code":"use strict; use warnings; my @c=qw(a b c d);print((map{$_ >1}@c)/@c)\n","out":"1","err":"Argument \"a\" isn't numeric in numeric gt (>) at (eval 558) line 1, <STDIN> line 1.\nArgument \"b\" isn't numeric in numeric gt (>) at (eval 558) line 1, <STDIN> line 1.\nArgument \"c\" isn't numeric in numeric gt (>) at (eval 558) line 1, <STDIN> line 1.\nArgument \"d\" isn't numeric in numeric gt (>) at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"[\"Match\"]","err":"","code":"use strict; use warnings; my $cwd = \"/archivepath/SHORT\"; my $ARCHIVEPATH=\"/archivepath/\"; [$cwd =~ m#^${ARCHIVEPATH}(SHORT|MEDIUM|LONG)$# ? \"Match\" : \"No match\"]\n"},{"err":"","out":"[\"No match\"]","code":"use strict; use warnings; my $cwd = \"/archivepath/SHORT\"; my $ARCHIVEPATH=\"/archivepath/\"; [$cwd =~ m#^${ARCHIVEPATH}(SHORT|MEDIUM|LONG)\\$# ? \"Match\" : \"No match\"]\n"},{"code":"use strict; use warnings; my %d = ( A => sub{'a'}, B => 5, C => sub{'c'}, D => [], E => sub{'e'} ); while ( my ($name, $code) = each %d ) { delete $d{$name} unless ref $code eq 'CODE'; } \\%d;\n","err":"","out":"{E => sub { \"DUMMY\" },A => sub { \"DUMMY\" },C => sub { \"DUMMY\" }}"},{"code":"use strict; use warnings; my @data = (\"foo\"); $data[0]{label} = $data[0]; [@data]\n","err":"","out":"ERROR: Can't use string (\"foo\") as a HASH ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; my @data = (\"foo\"); $data[0] = {label => $data[0]}; [$data[0]{label}]\n","out":"[\"foo\"]","err":""},{"code":"use strict; use warnings; my $data = [{}, { url => 'xyz' }]; $data->[\"1\\n\"]{url} # shouldn't matter\n","err":"","out":"xyz"},{"err":"","out":"[qr/a|d|e|f|l|t|u/,qr/A|B|C/]","code":"use strict; use warnings; my @default = qw(d e f a u l t); my $h = { y => [ qw(A B C) ] }; [ map Data::Munge::list2re(@{ $h->{$_} // \\@default }), qw(x y) ]\n"},{"code":"use strict; use warnings; my @default = qw(d e f a u l t); my $h = { y => [ qw(A B C) ] }; [ map {   join q{|}, map { qq{\\Q$_\\E} } ( ref $h->{$_} eq q{ARRAY} && @{ $h->{$_} } ? @{ $h->{$_} } : @default )   } qw(x y) ];\n","out":"[\"d|e|f|a|u|l|t\",\"A|B|C\"]","err":""},{"code":"use strict; use warnings; my $foo = 1; my $bar = 2; my $name = \"foo\"; print \"ok\" if (defined(${$name}));\n","err":"","out":"ERROR: Can't use string (\"foo\") as a SCALAR ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; my %foo = (bar => 1); print %{foo};\n","err":"","out":"bar1"},{"out":"ERROR: Can't use string (\"stuff\") as a HASH ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; my $foo = { bar => \"stuff\" }; $foo->{bar}->{baz}\n"},{"err":"","out":"[22]","code":"use strict; use warnings; my %foo = (hello => [1,22,303]); [$foo{hello}[1]]\n"},{"code":"use strict; use warnings; my @foo = \"hi\"; \"class ${foo[0]}{ ... };\"\n","out":"class hi{ ... };","err":""},{"code":"use strict; use warnings; my @foo = \"hi\"; \"class $foo[0]\\{ ... };\"\n","err":"","out":"class hi{ ... };"},{"code":"use strict; use warnings; my $foo; push @$foo, 1; $foo\n","out":"[1]","err":""},{"code":"use strict; use warnings; my @groups; my $chunk = []; for my $x (\"foo\", \"bar\", \"baz\\n\", \"x\", \"y\", \"z\") { push @$chunk, $x; if ($x =~ /\\R\\z/) { push @groups, $chunk; $chunk = []; } } push @groups, $chunk if @$chunk; [ @groups ]\n","err":"","out":"[[\"foo\",\"bar\",\"baz\\n\"],[\"x\",\"y\",\"z\"]]"},{"out":"25","err":"","code":"use strict; use warnings; my %h = ( 1 => 200, 0 => 100, q{} => 50, undef => 25 ); $h{undef};\n"},{"out":"50","err":"Use of uninitialized value $x in hash element at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my %h = ( 1 => 200, 0 => 100, q{} => 50, undef => 25 ); my $x; $h{$x}; ### Wtf?\n"},{"code":"use strict; use warnings; my %h = (1 => 2); sub x {my $ref = shift; $ref->{1} = 3}; x(\\%h); $h{1}\n","err":"","out":"3"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"m/(.)/$h\"\nBareword \"b\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\nBareword \"d\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\nBareword \"f\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":"Scalar found where operator expected at (eval 558) line 1, near \"m/(.)/$h\"\n","code":"use strict; use warnings; my %h = (a => b, c => d, e => f); my $str = \"abcdef\"; $str =~ m/(.)/$h{$1}/g; print \"$str\";\n"},{"code":"use strict; use warnings; my %h = (a => \"b\", c => \"d\", e => \"f\"); my $str = \"abcdef\"; $str =~ s/(.)/$h{$1} // $1 /eg; print \"$str\";\n","err":"Useless use of division (/) in void context at (eval 558) line 1, <STDIN> line 1.\n","out":"ERROR: Bareword \"eg\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"b,d","code":"use strict; use warnings; my $h = {a => \"b\", c => \"d\", e => \"f\"}; my $str = join \",\", grep defined, @$h{qw/a b c/}; print $str;\n"},{"code":"use strict; use warnings; my $h = {a => \"b\", c => \"d\", e => \"f\"}; my $str = join(\",\", grep {defined($h->{$_})} (qw/a b c/)); print $str;\n","out":"a,c","err":""},{"code":"use strict; use warnings; my $h = {a => \"b\", c => \"d\", e => \"f\"}; my $str = join(\",\", map { $h->{$_} // () } (qw/a b c/)); print $str; # or do both in the map\n","err":"","out":"b,d"},{"err":"","out":"1","code":"use strict; use warnings; my $h = {a => \"b\", c => \"d\", e => \"f\"}; my $str = map $h->{$_}, join(\",\", grep {defined($h->{$_})} (qw/a b c/)); print $str;\n"},{"out":"ERROR: Global symbol \"%hash\" requires explicit package name (did you forget to declare \"my %hash\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; my %hash;  \"hash\"->{key} = \"message\"; \\%hash\n"},{"err":"","out":"ERROR: Can't use string (\"hash\") as a HASH ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my %hash; ${\"hash\"}{key} = \"message\"; \\%hash\n"},{"code":"use strict; use warnings; my $hash_ref = { 'foo' => 'bar' }; $%hash_ref{'foo'};\n","err":"Bareword found where operator expected at (eval 558) line 1, near \"$%hash_ref\"\n\t(Missing operator before hash_ref?)\n","out":"ERROR: syntax error at (eval 558) line 1, near \"$%hash_ref\"\n"},{"err":"","out":"ERROR: Global symbol \"%hash_ref\" requires explicit package name (did you forget to declare \"my %hash_ref\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $hash_ref = { 'foo' => 'bar' }; $hash_ref{'foo'};\n"},{"out":"bar","err":"","code":"use strict; use warnings; my $hash_ref = { 'foo' => 'bar' }; %$hash_ref{'foo'};\n"},{"err":"Reference found where even-sized list expected at (eval 558) line 1, <STDIN> line 1.\n","out":"","code":"use strict; use warnings; my %hash_ref = { 'foo' => 'bar' }; $hash_ref{'foo'};\n"},{"code":"use strict; use warnings; my %h = ('a' => \"This is A\", 'b' => \"This is B\"); $h{'a'} = \"One A too many.\"; $h{'c'} = \"Foobar\"; \\%h\n","out":"{b => \"This is B\",a => \"One A too many.\",c => \"Foobar\"}","err":""},{"code":"use strict; use warnings; my $_ # hence the \"experimental\" - generally safer not to use it, and avoid things that do\n","err":"Use of my $_ is experimental at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"code":"use strict; use warnings; my %h = ('fling' => 1, 'rindolf' => 2, 'gamo' => 3); my @arr = (map { [$_, $h{$_}] } keys %h); [@arr]\n","out":"[[\"rindolf\",2],[\"gamo\",3],[\"fling\",1]]","err":""},{"err":"","out":"ERROR: Not an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $h = {\"foo\" => 5, \"bar\" => 6, \"baz\" => 2}; print Dumper(@{$h}->{qw/foo bar baz/});\n"},{"code":"use strict; use warnings; my %h = (foo => 'bar'); my $aref = [\\%h,\\%h,\\%h]; $aref->[0]{foo} = 'dexter'; $aref\n","err":"","out":"[{foo => \"dexter\"},$VAR1->[0],$VAR1->[0]]"},{"out":"ERROR: Bareword \"bar\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; my %h = (foo => bar); my $aref = [\\%h,\\%h,\\%h]; $aref->[0]{foo} = 'dexter'; $aref\n"},{"err":"","out":"ERROR: Global symbol \"@aref\" requires explicit package name (did you forget to declare \"my @aref\"?) at (eval 558) line 1, <STDIN> line 1.\nBareword \"bar\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my %h = (foo => bar); my $aref = [\\%h,\\%h,\\%h]; $aref[0]{foo} = 'dexter'; $aref\n"},{"out":"{\"foo\\34bar\" => \"much\"}","err":"","code":"use strict; use warnings; my %h; $h{'foo','bar'} = \"much\"; \\%h\n"},{"out":"ERROR: Can't use an undefined value as a HASH reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; my $href; %$href\n"},{"out":"[\"55.668840408325195\",\"20.794050693511963\",\"58.08229207992554\",\"28.241150379180908\"]","err":"","code":"use strict; use warnings; my $input=\"Exact map coverage is (55.668840408325195,20.794050693511963) to (58.08229207992554,28.241150379180908)\"; [ $input =~ m#([0-9]+(?:\\.[0-9]+)?)#g]\n"},{"out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/( <-- HERE [0-9]+(\\.[0-9]+)?/ at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; my $input=\"Exact map coverage is (55.668840408325195,20.794050693511963) to (58.08229207992554,28.241150379180908)\"; [ $input =~ m#([0-9]+(\\.[0-9]+)?#g]\n"},{"out":"","err":"","code":"use strict; use warnings; my $my->{my}\n"},{"code":"use strict; use warnings; my $name = 'something'; $$name = 'data'; { our $something; $something } # if you get an error when you make that change...\n","err":"","out":"ERROR: Can't use string (\"something\") as a SCALAR ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"Hello Tectu!\n","code":"use strict; use warnings; my $name = 'Tectu'; print \"Hello $name!\\n\";\n"},{"code":"use strict; use warnings; my $num = 5.2323232; $num = sprintf(\"%.3f\", $num); [$num]\n","out":"[\"5.232\"]","err":""},{"code":"use strict; use warnings; my %old_hash = (1 => 2, 3 => undef); my %new_hash; $new_hash{$old_hash{$_}} = $_ for keys %old_hash; \\%new_hash\n","out":"{2 => 1,\"\" => 3}","err":"Use of uninitialized value $old_hash{\"3\"} in hash element at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"Use of uninitialized value $old_hash{\"3\"} in list assignment at (eval 558) line 1, <STDIN> line 1.\n","out":"{2 => 1,\"\" => 3}","code":"use strict; use warnings; my %old_hash = (1 => 2, 3 => undef); my %new_hash = reverse %old_hash; \\%new_hash\n"},{"out":"CODE(0x4740300)","err":"","code":"use strict; use warnings; my $PROG = sub { \"like this?\" }; \"${PROG}\" # really?\n"},{"code":"use strict; use warnings; my $ref = [qw(hi one two)]; unshift(@$ref, \"Hello\"); [$ref]\n","out":"[[\"Hello\",\"hi\",\"one\",\"two\"]]","err":""},{"code":"use strict; use warnings; my $s = \"5/5/1977\"; $s =~ s/(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})/sprintf(\"%04d%02d%02d\", $3, $2, $1)/e; [$s]\n","err":"","out":"[19770505]"},{"code":"use strict; use warnings; my $s = \"aabaaaaaaaaaaaab\"; my @x = $s =~ /(a++b)/; [@x]\n","out":"[\"aab\"]","err":""},{"code":"use strict; use warnings; my $s = \"aabaaaaaaaaaaaab\"; @x = $s =~ /(a++b)/; [@x]\n","err":"","out":"ERROR: Global symbol \"@x\" requires explicit package name (did you forget to declare \"my @x\"?) at (eval 558) line 1, <STDIN> line 1.\nGlobal symbol \"@x\" requires explicit package name (did you forget to declare \"my @x\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; my %sections = { name => \"testname\" }; [ %sections ] # probably not what you wanted in %sections\n","err":"Reference found where even-sized list expected at (eval 558) line 1, <STDIN> line 1.\n","out":"[\"HASH(0x5952e80)\",undef]"},{"out":"[\"maroloccio. How is your day.\"]","err":"","code":"use strict; use warnings; my $s = \"Hello maroloccio___. How is your day.\"; $s =~ s#\\AHello (\\w+)# my $name = $1; $name =~ s/_+\\z//; $name#e; [$s]\n"},{"code":"use strict; use warnings; my $s = \"Hello maroloccio___. How is your day.\"; $s =~ s#\\AHello (\\w+)# my $name = $1; $name =~ s/_+\\z//; $name#; [$s]\n","err":"Unrecognized escape \\z passed through at (eval 558) line 1, <STDIN> line 1.\n","out":"ERROR: Global symbol \"$name\" requires explicit package name (did you forget to declare \"my $name\"?) at (eval 558) line 1, <STDIN> line 1.\nGlobal symbol \"$name\" requires explicit package name (did you forget to declare \"my $name\"?) at (eval 558) line 1, <STDIN> line 1.\nGlobal symbol \"$name\" requires explicit package name (did you forget to declare \"my $name\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; my %shift = (bar => 1); print %shift\n","out":"bar1","err":""},{"code":"use strict; use warnings; my %shift = (bar => 1); print %{shift}\n","out":"bar1","err":"Ambiguous use of %{shift} resolved to %shift at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"Use of uninitialized value $1 in substitution (s///) at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value $1 in concatenation (.) or string at (eval 558) line 1, <STDIN> line 1.\n","out":"Match: \n","code":"use strict; use warnings; my $s = q{<a rel=\"nofollow\" href=\"http://www.FOOtube.com/v/ABCDEFG\" target=\"_blank\">Youtube Video</a>}; $s =~ s#<a(?:\\s+(?:href=(\\S+\\byoutube\\.com/\\S+)|[^>]*?))+\\s*\\>.*?</a>#$1# && print qq{Match: $1\\n}; [ $s, $1 ];\n"},{"err":"","out":"Match: \"http://www.youtube.com/v/ABCDEFG\"\n","code":"use strict; use warnings; my $s = q{<a rel=\"nofollow\" href=\"http://www.youtube.com/v/ABCDEFG\" target=\"_blank\">Youtube Video</a>}; $s =~ s#<a(?:\\s+(?:href=(\\S+\\byoutube\\.com/\\S+)|[^>]*?))+\\s*\\>.*?</a>#$1# && print qq{Match: $1\\n}; [ $s, $1 ];\n"},{"code":"use strict; use warnings; my $s = q{foo=bar=baz}; my $p = qr/=(.*?)=/; my $r = q{\",$1,\"}; $s =~ s/$p/$r/re;\n","out":"foo\",$1,\"baz","err":""},{"err":"","out":"ERROR: Substitution pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $s = q{}; my $r = s =~ s///; OK wtf?\n"},{"code":"use strict; use warnings; my $s = q{}; my $r = s =~ s///; # wtf?\n","out":"ERROR: Substitution pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"012","err":"","code":"use strict; use warnings; my $str = \"012\"; my @f = (qw/2 1 0/); $str =~ s/(join(\"|\", @f))/$f[$1]/g; print $str\n"},{"err":"","out":"pre [\"foo bar baz\"]\npost [\"foo bar ba]\n","code":"use strict; use warnings; my $str = \"\\\"foo bar baz\\\"\"; print \"pre [$str]\\n\"; $str =~ s/(?:[^\\\\])\"$//; print \"post [$str]\\n\";\n"},{"err":"","out":"","code":"use strict; use warnings; my $str; length($str)\n"},{"err":"Reference found where even-sized list expected at (eval 558) line 1, <STDIN> line 1.\n","out":"1","code":"use strict; use warnings; my %table = {}; # strict+warnings may help with issues like that\n"},{"code":"use strict; use warnings; my $test = \"\"; [defined($test) ? \"Def\" : \"Undef\"]\n","out":"[\"Def\"]","err":""},{"err":"","out":"[123,456,234]","code":"use strict; use warnings; my @things; (my $x = '%%123@@@@456&&234') =~ s/([\\$%\\@&])\\1+\\K([0-9]+)/push @things, $2/ge; \\@things # could even do something like this, for example\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","code":"use strict; use warnings; { my $v=0; sub foo : lvalue { $v } } foo++;\n"},{"code":"use strict; use warnings; { my $v=0; sub x : lvalue { $v } } ++x;\n","err":"","out":"1"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":"","code":"use strict; use warnings; { my $v=0; sub x : lvalue { $v } } x++;\n"},{"out":"ERROR: Can't use an undefined value as an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; my $var = undef; @{$var} # and you understand why this fails but Bar(@{$var}) doesn't, right?\n"},{"code":"use strict; use warnings; my $v = sub { \"Miesco\", 1+1, print(\"Blessed are the cheese makers\") }->(); print \" Return value was: [ $v ]\" # seems print turns off auto-value-dump in perlbot?\n","out":"Blessed are the cheese makers Return value was: [ 1 ]","err":""},{"err":"","out":"Blessed are the cheese makers","code":"use strict; use warnings; my $v = sub { \"Miesco\", 1+1, print(\"Blessed are the cheese makers\") }->(); [ $v ]\n"},{"code":"use strict; use warnings; my $word_re = qr/\\w+/; my $pat_re = qr/(?:$word_re-)*$word_re/; [grep { $_ =~ /\\A$pat_re\\z/ } (\"foo-123\")]\n","out":"[\"foo-123\"]","err":""},{"code":"use strict; use warnings; my $word_re = qr/\\w+/; my $pat_re = qr/(?:$word_re-)*$word_re/; [grep { $_ =~ /\\A$pat_re\\z/ } (\"foo-123\", \"bar-3600-Zab\",\"Maj+4\")]\n","out":"[\"foo-123\",\"bar-3600-Zab\"]","err":""},{"code":"use strict; use warnings; my %x = { };\n","err":"Reference found where even-sized list expected at (eval 558) line 1, <STDIN> line 1.\n","out":"1"},{"code":"use strict; use warnings; my @x = ([0,1,2]) x 5; $x[0][2] = 100; [@x]\n","err":"","out":"[[0,1,100],$VAR1->[0],$VAR1->[0],$VAR1->[0],$VAR1->[0]]"},{"code":"use strict; use warnings; my $x = 0; for my $i (1 .. 100) { $x += 0.01; } [sprintf(\"%.50f\", $x)]\n","out":"[\"1.00000000000000066613381477509392425417900085449219\"]","err":""},{"out":"1","err":"","code":"use strict; use warnings; my $x = -100 ; for my $y (0 .. $x) { hello_there(); } 1;\n"},{"err":"","out":"[100,2,200,4,5]","code":"use strict; use warnings; my @x = (1 .. 5); @x[0,2] = (100,200); [@x]\n"},{"err":"","out":"\\*::STDOUT","code":"use strict; use warnings; my $x = 1; my $h = do { if ( $x == 2 ) { \\*STDERR; } elsif ( $x == 1 ) { \\*STDOUT; } }; $h\n"},{"code":"use strict; use warnings; my $x = 1; my $h = do { if ( $x == 2 ) { \\*STDERR; } if ( $x == 1 ) { \\*STDOUT; } }; $h\n","err":"Useless use of single ref constructor in void context at (eval 558) line 1, <STDIN> line 1.\n","out":"\\*::STDOUT"},{"code":"use strict; use warnings; my $x = 1; my $h = do { \\*STDERR if $x == 2; \\*STDOUT if $x == 1; }; $h\n","err":"Useless use of single ref constructor in void context at (eval 558) line 1, <STDIN> line 1.\n","out":"\\*::STDOUT"},{"code":"use strict; use warnings; my $x = 1; our $x = 2; $x\n","err":"\"our\" variable $x masks earlier declaration in same scope at (eval 558) line 1, <STDIN> line 1.\n","out":"2"},{"err":"","out":"2","code":"use strict; use warnings; my $ x = 2  # or even\n"},{"code":"use strict; use warnings; my @x = (500, 24, 300, 2800); $#x = -1; [@x]\n","err":"","out":"[]"},{"code":"use strict; use warnings; my @x = (500, 24, 300, 2800); $#x = 1; [@x]\n","err":"","out":"[500,24]"},{"code":"use strict; use warnings; my $x = 'abc'; ${x}\n","err":"Ambiguous use of ${x} resolved to $x at (eval 558) line 1, <STDIN> line 1.\n","out":"abc"},{"code":"use strict; use warnings; my $x = \"| |\"; [\"Foo $x y $x\"]\n","out":"[\"Foo | | y | |\"]","err":""},{"code":"use strict; use warnings; my $x = []; push $x, '...';\n","out":"1","err":"push on reference is experimental at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"4","code":"use strict; use warnings; my %x = ( qw(AAA 1111 BBB 222 CCC 333 DDD 444) ); (()=%x)/2;\n"},{"out":"2","err":"Argument \"2/8\" isn't numeric in addition (+) at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my %x = ( qw(AAA 1111 BBB 222) ); %x+0\n"},{"code":"use strict; use warnings; my $x; sub Foo : lvalue { $x } sub Bar { } my $var = undef; Bar(@{Foo()}) # does that make it any clearer?\n","err":"","out":""},{"err":"","out":"[\"test\"]","code":"use strict; use warnings; my $x = \"test\"; [\"$ x\"] # any clearer?\n"},{"code":"use strict; use warnings; my ($x, undef) = (5,10);\n","err":"","out":"2"},{"out":"1","err":"Use of uninitialized value $x in numeric lt (<) at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $x; undef $x; length($x) < 4 # the length() warnings can be mildly confusing\n"},{"code":"use strict; use warnings ; my @x; $x[5] = 5; [keys@x]\n","out":"[0,1,2,3,4,5]","err":""},{"code":"use strict; use warnings;  my %x; $x{a} = 4; @x{a} = (5); print $x{a};\n","out":"5","err":""},{"code":"use strict; use warnings; my $x; --$x if $x > 1; \\$x; # Just wondering, is there a nice rewrite this to avoid the warning, without using something like if $x && $x > 1 (is there a shorter/simpler way?)\n","err":"Use of uninitialized value $x in numeric gt (>) at (eval 558) line 1, <STDIN> line 1.\n","out":"\\undef"},{"code":"use strict; use warnings; my $x; $$x = 'test'; $x # even scalars\n","out":"\\\"test\"","err":""},{"out":"ERROR: Can't modify postincrement (++) in scalar assignment at (eval 558) line 1, at EOF\n","err":"","code":"use strict; use warnings; my $x; ($x ? $x++ : $x ) = 1; $x;\n"},{"err":"","out":"1","code":"use strict; use warnings; my $x; $x ? $x++ : ($x = 1); $x;\n"},{"out":"ERROR: Can't modify postincrement (++) in scalar assignment at (eval 558) line 1, at EOF\n","err":"","code":"use strict; use warnings; my $x; $x ? $x++ : $x = 1; $x;\n"},{"code":"use strict; use warnings; my $x->{y} = 55\n","out":"55","err":""},{"out":"hi","err":"","code":"use strict; use warnings; $_ = my ($x, $y); $x = \"hi\"\n"},{"err":"","out":"{y => \"z\",hey => 100}","code":"use strict; use warnings; my %x = (y => 'z'); $x{'hey'} += 100; \\%x\n"},{"err":"","out":"ERROR: Can't use an undefined value as an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $y; my @x = @$y; # rvalue\n"},{"out":"0","err":"","code":"use strict; use warnings; my $y; my @x; @$y = @x; # lvalue\n"},{"code":"use strict; use warnings; my $z = {}; (my $z)->{z}\n","out":"","err":"\"my\" variable $z masks earlier declaration in same scope at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"\"my\" variable $z masks earlier declaration in same scope at (eval 558) line 1, <STDIN> line 1.\n","out":"ERROR: Can't declare hash element in \"my\" at (eval 558) line 1, at EOF\n","code":"use strict; use warnings; my $z = {}; my ($z->{z})\n"},{"out":"","err":"\"my\" variable $z masks earlier declaration in same scope at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $z = {}; my $z->{z}\n"},{"err":"","out":"[\"NaN\"]","code":"use strict; use warnings; [ 'NaN' + 'sNaN' ]\n"},{"code":"use strict; use warnings; no strict 'refs'; my $name = 'something'; $$name = 'data'; { our $something; $something } # ... then add no strict 'refs';\n","err":"","out":"data"},{"code":"use strict; use warnings; 'ok'; ()\n","err":"Useless use of a constant (\"ok\") in void context at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"out":"[undef]","err":"","code":"use strict; use warnings; [open my $fh, '<', '']\n"},{"out":"1","err":"\"my\" variable $fh masks earlier declaration in same scope at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; open(my $fh, \">\", \"myfic.txt\");my ($fh) = @_; # because this should give you a warning\n"},{"out":"[undef]","err":"","code":"use strict; use warnings; [open my $fh, '<', undef]\n"},{"err":"hi","out":"1","code":"use strict; use warnings; open my $out2, q{>&=}, 2 or die qq{open failed: $!}; print $out2 \"hi\";\n"},{"code":"use strict; use warnings; our $x = 1; my $x = 2; $x\n","err":"\"my\" variable $x masks earlier declaration in same scope at (eval 558) line 1, <STDIN> line 1.\n","out":"2"},{"code":"use strict; use warnings; package foo {} foo->import;\n","err":"","out":""},{"code":"use strict; use warnings; { package Foo; our $bar = 42; } my $pkg = \"Foo\"; my $var = do { no strict 'refs'; \\${\"${pkg}::bar\"} }; $$var\n","out":"42","err":""},{"out":"42","err":"","code":"use strict; use warnings; { package Foo; our $bar = 42; } my $pkg = \"Foo\"; ${ $::{$pkg . '::'}->{bar} }\n"},{"err":"","out":"42","code":"use strict; use warnings; { package Foo; sub bar { 42 } } my $pkg = \"Foo\"; my $fn = \\&{\"${pkg}::bar\"}; $fn->()\n"},{"code":"use strict; use warnings; { package Foo; sub bar { 42 } } my $pkg = \"Foo\"; \"${pkg}::bar\"->()\n","err":"","out":"ERROR: Can't use string (\"Foo::bar\") as a subroutine ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"[1,2]","err":"","code":"use strict; use warnings; package Obj; sub new { return bless {} , shift; } sub w_state { state $foo; return ++$foo; } ; package main; my @x; my $t = Obj->new; my $r = Obj->new; push @x, $t->w_state; push @x, $r->w_state; [@x]\n"},{"err":"","out":"[1,12,13,15,2,3,31,42]","code":"use strict; use warnings; {package sort::numeric; BEGIN { $INC{'sort/numeric.pm'} = 1 } sub import { no strict 'refs'; *{caller . '::sort'} = sub { GLOBAL::CORE::sort { $a <=> $b } @_ } } } use sort::numeric; [ sort 1,3,2,31,13,12,15,42 ] # pragma\n"},{"code":"use strict; use warnings; package SubTest; sub DESTROY { print qq{Good bye cruel wor...\\n}; } package main; sub foo { my ( $x, $worker ); $worker = bless sub { $x++; $worker->() unless $x >= 5; }, q{SubTest}; $worker->(); undef $worker; $x; } print foo;\n","err":"","out":"Good bye cruel wor...\n5"},{"err":"","out":"5Good bye cruel wor...\n","code":"use strict; use warnings; package SubTest; sub DESTROY { print qq{Good bye cruel wor...\\n}; } package main; sub foo { my ( $x, $worker ); $worker = bless sub { $x++; $worker->() unless $x >= 5; }, q{SubTest}; $worker->(); $x; } print foo;\n"},{"code":"use strict; use warnings; package SubTest; sub DESTROY { print qq{Good bye cruel wor...\\n}; } package main; sub foo { my ( $x, $worker ); $worker = bless sub { $x++; $worker->() unless $x >= 5; undef $worker; }, q{SubTest}; $worker->(); $x; } foo;\n","out":"Good bye cruel wor...\n","err":""},{"out":"Good bye cruel wor...\n5","err":"","code":"use strict; use warnings; package SubTest; sub DESTROY { print qq{Good bye cruel wor...\\n}; } package main; sub foo { my ( $x, $worker ); $worker = bless sub { $x++; $worker->() unless $x >= 5; undef $worker; }, q{SubTest}; $worker->(); $x; } print foo;\n"},{"err":"","out":"Too many open files","code":"use strict; use warnings; print $!\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"&$!\"\n","err":"","code":"use strict; use warnings; print &$!;\n"},{"code":"use strict; use warnings; print chr(0xe08)\n","err":"Wide character in print at (eval 558) line 1, <STDIN> line 1.\n","out":"ÃÂ ÃÂ¸ÃÂ"},{"code":"use strict; use warnings; print \"Foo $_\" foreach qw(one two three);\n","err":"","out":"Foo oneFoo twoFoo three"},{"code":"use strict; use warnings; rand * 3\n","out":"0.567366485807241","err":"Argument \"*main::3\" isn't numeric in rand at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; reduce 1;\n","out":"ERROR: syntax error at (eval 558) line 1, near \"reduce 1\"\n","err":"Number found where operator expected at (eval 558) line 1, near \"reduce 1\"\n\t(Do you need to predeclare reduce?)\n"},{"out":"ERROR: Undefined subroutine &main::reduce called at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; reduce(1)\n"},{"code":"use strict; use warnings; say 1.2.3\n","out":"\u0001\u0002\u0003\n","err":""},{"code":"use strict; use warnings; sort { $a <=> $x } 1,2,3; # looks like an error to me\n","out":"ERROR: Global symbol \"$x\" requires explicit package name (did you forget to declare \"my $x\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; use warnings; s/^\\///r for ''; ''\n","err":"Useless use of non-destructive substitution (s///r) in void context at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"out":"[]","err":"Subroutine main::xyz redefined at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; sub abc { } sub xyz { } *xyz = sub { 123 }; { no warnings \"redefine\"; *abc = sub { 4 }; [] } # no warnings '...' is usefully self-documenting, any particular reason to do things manually?\n"},{"code":"use strict; use warnings; sub ALL_EMPS { return +{ one => 1, two => 2, three => 3}}; my %h = %{ ALL_EMPS() }; [$h{three}]\n","out":"[3]","err":""},{"code":"use strict; use warnings; sub a :lvalue { $a } a=10;a=20; print \"$a\\n\"; # <--- see, strict and warnings clean\n","out":"20\n","err":""},{"code":"use strict; use warnings; sub Bar { ++$_ for @_ } my $x; 1 for @{$x}; $x # note that it's not just function calls, you'll get the same with foreach aliasing\n","out":"[]","err":""},{"code":"use strict; use warnings; sub create_iterator { my ($val) = @_; my $iter = sub { return ++$val; } ; return $iter } my $iter1 = create_iterator(100); my $iter2 = create_iterator(5); [$iter1->(),$iter2->(),$iter1->(),$iter2->()]\n","out":"[101,6,102,7]","err":""},{"err":"","out":"[1,2,3,4,5,6]","code":"use strict; use warnings; sub flatten { return map { ref($_) eq 'ARRAY' ? flatten(@$_) : $_ } @_ } [flatten([1, [2, 3], [4, [5]], 6])]\n"},{"code":"use strict; use warnings; sub flatten { return map { ref($_) eq 'ARRAY' ? flatten(@$_) : $_ } @_ } [flatten(1, [2, 3], [4, [5]], 6])]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"6]\"\nUnmatched right square bracket at (eval 558) line 1, at end of line\n","err":""},{"code":"use strict; use warnings; sub foo { 42 } *bar = \\&foo; bar()\n","out":"42","err":""},{"code":"use strict; use warnings; sub foo { 42 } my $name = 'foo'; 'main'->$name\n","out":"42","err":""},{"err":"","out":"foo","code":"use strict; use warnings; sub foo { \"foo\" } foo\n"},{"out":"2","err":"","code":"use strict; use warnings; sub foo { my ($ch, $name) = @_; } foo(undef, undef); #are you sure?\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","code":"use strict; use warnings; sub foo { shift } my $name = 'foo'; 'main'->can($name\n"},{"err":"","out":"42","code":"use strict; use warnings; sub foo { shift } my $name = 'foo'; 'main'->can($name)->(42)\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \")(\"\n","code":"use strict; use warnings; sub foo { shift } my $name = 'foo'; 'main'->can($name)(42)\n"},{"code":"use strict; use warnings; sub Foo { undef } sub Bar { } Bar(@{Foo()}) # you're saying this one works, or did you mean the else { } clause?\n","out":"ERROR: Can't use an undefined value as an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; use warnings; sub Foo {undef } sub Bar { } my $x; Bar(@{$x = Foo()})\n","out":"ERROR: Can't use an undefined value as an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; use warnings; sub func { return undef;} if(1 and defined(func(\"Foo\"))) { print \"Success!\"; }\n","err":"","out":""},{"err":"","out":"Success!\n","code":"use strict; use warnings; sub func { return undef;} if(1 and !defined(func(\"Foo\"))) { print \"Success!\\n\"; }\n"},{"out":"","err":"","code":"use strict; use warnings; sub func { return undef;} if(1 and defined(func(\"Foo\"))) { print \"Success!\\n\"; }\n"},{"err":"","out":"[125]","code":"use strict; use warnings; sub get_closure { my $x = 124; my $returnval = sub { return $x; }; ++$x; return $returnval; } my $foo = get_closure(); [$foo->()]\n"},{"out":"ERROR: Global symbol \"$retval\" requires explicit package name (did you forget to declare \"my $retval\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; sub get_closure { my $x = 124; my $returnval = sub { return $x; }; ++$x; return $retval; } my $foo = get_closure(); [$foo->()]\n"},{"code":"use strict; use warnings; sub get_closure { my $x = 124; return sub { return $x; } } my $foo = get_closure(); [$foo->()]\n","out":"[124]","err":""},{"code":"use strict; use warnings; sub get_closure { my $x = 124; return sub { return $x; }; ++$x; } my $foo = get_closure(); [$foo->()]\n","out":"[124]","err":""},{"err":"","out":"3","code":"use strict; use warnings; sub ls{my ($n, $h)=@_;my $ret;for(0..$#$h){$ret=$_ and last if $n eq $h->[$_]}$ret}; ls (3,[0,1,4,3,2])\n"},{"code":"use strict; use warnings; sub { my $x = 42; sub { eval '$x' } }->()->()\n","err":"Variable \"$x\" is not available at (eval 559) line 1, <STDIN> line 1.\n","out":""},{"out":"oneone","err":"Variable \"$var\" will not stay shared at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; sub outer { my ($var) = @_; sub inner { print $var||'three' } }   outer(\"one\"); inner(); outer(\"two\"); inner() # as the warning implies, \"don't do this\"\n"},{"code":"use strict; use warnings; sub sort { CORE::GLOBAL::sort { $a <=> $b } @_ } [ sort 1,3,2,31,13,12,15,42 ] # huh, maybe\n","err":"","out":"[1,12,13,15,2,3,31,42]"},{"code":"use strict; use warnings; sub sort { GLOBAL::CORE::sort { $a <=> $b } @_ } [ sort 1,3,2,31,13,12,15,42 ] # all \u0002*your*\u0002 sorts, sure, but not all sorts everywhere\n","err":"","out":"[1,12,13,15,2,3,31,42]"},{"code":"use strict; use warnings; sub test { return bareword { return 42; } }; test()\n","err":"","out":"42"},{"code":"use strict; use warnings; sub what { (my $foo, @_) = @_; \\@_ } what(qw(a b c d));\n","err":"","out":"[\"b\",\"c\",\"d\"]"},{"code":"use strict; use warnings; sub what { my ($foo, @_) = @_; \\@_ } what(qw(a b c d));\n","err":"","out":"ERROR: Can't use global @_ in \"my\" at (eval 558) line 1, near \", @_\"\n"},{"code":"use strict;use warnings;sub x { my($x,$y,$z)=@_;print $x } x(1,2);\n","out":"1","err":""},{"code":"use strict; use warnings; system \"echo 'xxx@xxxxxxxx$' rsync\"\n","err":"Possible unintended interpolation of @xxxxxxxx in string at (eval 558) line 1, <STDIN> line 1.\n","out":"ERROR: Global symbol \"@xxxxxxxx\" requires explicit package name (did you forget to declare \"my @xxxxxxxx\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; \\&this_sub_doesnt_exist\n","err":"","out":"sub { \"DUMMY\" }"},{"code":"use strict; use warnings; \"UCS-4\" =~ /^UCS-?4-?(BE|LE)?$/i; eval q@uc(\"UTF-32$1\")@\n","err":"Use of uninitialized value $1 in concatenation (.) or string at (eval 559) line 1, <STDIN> line 1.\n","out":"UTF-32"},{"code":"use strict; use warnings; (undef) = 10;\n","err":"","out":"1"},{"err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; undef = 10;\n"},{"out":"ERROR: Global symbol \"$f\" requires explicit package name (did you forget to declare \"my $f\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; undef $f; my $f;\n"},{"code":"use strict; use warnings; use 5.016; package Obj; sub new { return bless {} , shift; } sub w_state { state $foo; return ++$foo; } ; package main; my @x; my $t = Obj->new; my $r = Obj->new; push @x, $t->w_state; push @x, $r->w_state; [@x]\n","out":"[1,2]","err":""},{"code":"use strict; use warnings; use constant TEST2 => TEST1; use constant TEST1 => 1; use constant TEST3 => TEST1; [TEST1, TEST2, TEST3]\n","err":"","out":"ERROR: Bareword \"TEST1\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\nBEGIN not safe after errors--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; use DateTime::TimeZone; my $tz = DateTime::TimeZone->new(name => '-0400')->name\n","out":"-0400","err":""},{"out":"ERROR: The timezone 'America/New_York' could not be loaded, or is an invalid name.\n","err":"","code":"use strict; use warnings; use DateTime::TimeZone; my $tz = DateTime::TimeZone->new(name => 'America/New_York')\n"},{"code":"use strict; use warnings; use experimental qw[signatures]; sub test ($foo) { say $foo } test ('moo')\n","out":"moo\n","err":""},{"code":"use strict; use warnings; use experimental qw(signatures); sub whatever($=) { print $= } whatever(3) # I'm happy enough with the way signatures work at the moment though\n","err":"","out":"60"},{"code":"use strict; use warnings; use feature qw(say); say for qw(foo -- bar); # what makes you think it throws an error?\n","err":"","out":"foo\n--\nbar\n"},{"err":"","out":"ERROR: Can't locate XML/LibXML.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; use feature qw(say); use XML::LibXML; my $t1 = XML::LibXML::Text->new( q{foo} ); my $t2 = XML::LibXML::Text->new( q{bar} ); $t1->appendChild( $t2 ); say $t1;\n"},{"code":"use strict; use warnings; use List::MoreUtils qw(any all); my $count = 5; my @nums = (sort { $a <=> $b} qw(10 4 3 4 4 59 39 5 3)); [any { my $x = $_; my $p = $nums[$_]; all { $nums[$x+$_]-$p <= 3 } (0 .. $count-1) } 0 .. (@nums-$count)]\n","out":"[1]","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\nUnmatched right square bracket at (eval 558) line 1, at end of line\n","err":"","code":"use strict; use warnings; use List::MoreUtils qw(any all); my @nums = (sort { $a <=> $b} qw(10 4 3 4 4 59 39 5 3)); [any { my $x = $_; my $p = $nums[$_]; all { $nums[$x+$_]-$p <= 3 } (0 .. 5) } } keys(@nums)]\n"},{"out":"[1]","err":"","code":"use strict; use warnings; use List::MoreUtils qw(any all); my @nums = (sort { $a <=> $b} qw(10 4 3 4 4 59 39 5 3)); [any { my $x = $_; my $p = $nums[$_]; all { $nums[$x+$_]-$p <= 3 } (0 .. 5) } keys(@nums)]\n"},{"code":"use strict; use warnings; use List::MoreUtils qw/uniq/; [ sort(uniq qw/a b c a/) ];\n","err":"Unquoted string \"uniq\" may clash with future reserved word at (eval 558) line 1, <STDIN> line 1.\n","out":"ERROR: Sort subroutine didn't return single value at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"[\"a\",\"b\",\"c\"]","code":"use strict; use warnings; use List::MoreUtils qw/uniq/; [ sort(uniq(qw/a b c a/)) ];\n"},{"err":"","out":"1","code":"use strict; use warnings; use List::Util; my $c = [qw(a b c)]; print \"1\" if List::Util::any { $_ eq \"a\" } @{$c}\n"},{"code":"use strict; use warnings; use List::Util qw(pairmap); $_ = qq{foo}; my @l = /(\\R)/; push @l, undef if @l%2; [ pairmap { [$a, $b] } @l ]\n","out":"[]","err":""},{"code":"use strict; use warnings; use List::Util qw(pairmap); $_ = qq{foo\\n}; [ pairmap { } split /\\R/ ];\n","out":"[]","err":"Odd number of elements in pairmap at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; use List::Util qw(pairmap); $_ = qq{foo}; [ pairmap { } split /(\\R)/ ]; # Better test case.\n","out":"[]","err":"Odd number of elements in pairmap at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"[6]","code":"use strict; use warnings; use List::Util qw[sum]; my $var = {  a => {count => 1},  b => {count => 5} }; [sum map { $_->{count} } values %{ $var }]\n"},{"code":"use strict; use warnings; use List::Util qw[sum]; my $var = {  a => {count => 1},  b => {count => 5} }; [sum values %{ $var }]\n","err":"","out":"[177109080]"},{"code":"use strict; use warnings; use POSIX qw(sysconf); [ sysconf(POSIX::_SC_PAGESIZE()) ]\n","err":"","out":"[4096]"},{"code":"use strict; use warnings; use POSIX; setlocale(LC_NUMERIC, \"de_DE\") or die $!; sprintf(\"%.2f\", 23.45)\n","err":"","out":"ERROR: Too many open files at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"23.45","code":"use strict; use warnings; use POSIX; setlocale(LC_NUMERIC, \"de_DE\"); sprintf(\"%.2f\", 23.45)\n"},{"code":"use strict; use warnings; use Scalar::Util qw(blessed); [ blessed qr/foo/ ]\n","out":"[\"Regexp\"]","err":""},{"code":"use strict; use warnings; use Scalar::Util qw( reftype ); my $foreach = q{}; ref $foreach eq q{CODE}; # No warning.\n","out":"","err":""},{"code":"use strict; use warnings; use Scalar::Util qw( reftype ); my $foreach = q{}; reftype $foreach eq q{CODE}; # Why does this warning occur?\n","err":"Use of uninitialized value in string eq at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"err":"","out":"[\"Regexp\",\"REGEXP\"]","code":"use strict; use warnings; use Scalar::Util qw(reftype); my $re = qr/foo/; [ ref $re, reftype $re ];\n"},{"err":"","out":"[\"main\",\"GLOB\"]","code":"use strict; use warnings; use Scalar::Util qw(reftype); my $x = bless \\*STDOUT; [ ref $x, reftype $x ];\n"},{"out":"[\"ARRAY\",\"ARRAY\"]","err":"","code":"use strict; use warnings; use Scalar::Util qw(reftype); my $x = []; [ ref $x, reftype $x ];\n"},{"code":"use strict; use warnings; use Scalar::Util qw(reftype); my $x = {}; [ ref $x, reftype $x ];\n","out":"[\"HASH\",\"HASH\"]","err":""},{"code":"use strict; use warnings; use Scalar::Util qw(reftype); my $x = \\*STDOUT; [ ref $x, reftype $x ];\n","err":"","out":"[\"GLOB\",\"GLOB\"]"},{"code":"use strict; use warnings; use Scalar::Util qw(reftype); my $x = sub{}; [ ref $x, reftype $x ];\n","out":"[\"CODE\",\"CODE\"]","err":""},{"err":"","out":"bless( {original => \"1.0.0\",qv => 1,version => [1,0,0]}, 'version' )","code":"use strict; use warnings; use version; my $ver = qv(q{1.0.0}); $ver;\n"},{"code":"use strict; use warnings; use version; my $ver = qv(q{1.0.0}); version->parse( $ver )->stringify;\n","err":"","out":"1.0.0"},{"code":"use strict; use warnings; vA.10\n","err":"","out":"ERROR: Bareword \"vA\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"like this","code":"use strict; use warnings; $::whatever = 'like this'; $::whatever\n"},{"code":"use strict; while (my $x = 1) { last } continue { say $x }\n","err":"","out":""},{"code":"use strict; $x->()\n","err":"","out":"ERROR: Global symbol \"$x\" requires explicit package name (did you forget to declare \"my $x\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: Global symbol \"@x\" requires explicit package name (did you forget to declare \"my @x\"?) at (eval 558) line 1, <STDIN> line 1.\nGlobal symbol \"@x\" requires explicit package name (did you forget to declare \"my @x\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; @x = (foo => 1, bar => 2); ${{@x}}{\"foo\"}\n"},{"code":"use strict; $x = inf;\n","out":"ERROR: Global symbol \"$x\" requires explicit package name (did you forget to declare \"my $x\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use String::Util qw/trim/; trim(\"pink_mist\");\n","out":"ERROR: Can't locate String/Util.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Can't locate strit.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strit; 404->();\n"},{"code":"use subs 'defined'; sub defined { 42 } defined\n","err":"","out":"ERROR: Can't locate subs.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use subs 'foo'; sub AUTOLOAD { print 'hi' } foo;\n","out":"ERROR: Can't locate subs.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use subs print; sub print {CORE::print \"foo: @_\"}; print bar;\n","out":"ERROR: Can't locate subs.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Can't locate subs.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use subs qw/print/; sub *print {CORE::print \"foo: @_\"}; print bar;\n"},{"code":"use subs qw/print/; sub print {CORE::print \"foo: @_\"}; print bar;\n","err":"","out":"ERROR: Can't locate subs.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use Sub::Util\n","err":"","out":""},{"err":"","out":"ERROR: Can't locate Switch/Plain.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use Switch::Plain;\n"},{"err":"","out":"ERROR: Can't locate Test/more.pm:   (null): Too many open files at (eval 558) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 2, <STDIN> line 1.\n","code":"use Test::more\n"},{"err":"","out":"ERROR: Can't locate Test/More.pm:   (null): Too many open files at (eval 558) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 2, <STDIN> line 1.\n","code":"use Test::More\n"},{"err":"","out":"ERROR: Can't locate Tie/IxHash.pm:   (null): Too many open files at (eval 558) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 2, <STDIN> line 1.\n","code":"use Tie::IxHash\n"},{"out":"ERROR: Time::HiRes::usleep(-1): negative time not invented yet at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use Time::HiRes 'usleep'; usleep(-1);\n"},{"out":"ERROR: Can't locate Time/Moment.pm:   (null): Too many open files at (eval 558) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 2, <STDIN> line 1.\n","err":"","code":"use Time::Moment\n"},{"code":"use Time::Piece\n","err":"","out":""},{"err":"","out":"","code":"use Time::Piece;\n"},{"code":"use Time::Seconds; say ONE_YEAR\n","out":"31556930\n","err":""},{"err":"","out":"ERROR: Missing right curly or square bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, at EOF\n","code":"use Try::Tiny; $a=1; $b=1; LABL: while($a--) {try {die if $b--} catch {redo LABL;} finally {print \"bark \"; print \"hello world\"};\n"},{"code":"use Try::Tiny; $a=1; $b=1; LABL: while($a--) {try {die if $b--} catch {redo LABL;} finally {print \"bark \"}; print \"hello world\"};\n","err":"","out":"bark bark hello world"},{"code":"use Try::Tiny; $a=1; $b=1; LABL: while($a--) {try {die if $b--} catch {redo LABL;}; print \"hello world\"};\n","err":"","out":"hello world"},{"code":"use Try::Tiny; try {die \"baz\";} catch {die \"foo\"} finally { print \"hoyl shit that broke\"};\n","err":"","out":"hoyl shit that brokeERROR: foo at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use Unicode::UCD qw(charinfo); charinfo('x')\n","out":"ERROR: Can't locate Unicode/UCD.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"","code":"use URI\n"},{"code":"use URI;\n","out":"","err":""},{"code":"use URI::Encode qw/uri_encode/; uri_encode \"<arg>\", {\"encode_reserved\", 1}; \n","out":"%3Carg%3E","err":""},{"code":"use URI::Escape;\n","out":"","err":""},{"err":"","out":"foo%2Bbar","code":"use URI::Escape qw( uri_escape ); uri_escape q{foo+bar};\n"},{"code":"use URI::Escape; uri_escape_utf8 \"http://web.de/\"\n","err":"","out":"http%3A%2F%2Fweb.de%2F"},{"code":"use URI; my $foo = URI->new('http://www.example.com?q=Ãthelo&s=blah'); $foo->as_string;\n","out":"ERROR: Can't locate URI/http.pm:   (null): Too many open files at (eval 559) line 2, <STDIN> line 1.\n","err":""},{"code":"use URI; my $u = URI->new( q{http://foo.com/bar?x=1&x=2&y=baz} ); +{ $u->query_form };\n","err":"","out":"ERROR: Can't locate URI/http.pm:   (null): Too many open files at (eval 559) line 2, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate URI/http.pm:   (null): Too many open files at (eval 559) line 2, <STDIN> line 1.\n","err":"","code":"use URI; my $u = URI->new( q{http://foo} ); do { no overload; print $u; }\n"},{"out":"ERROR: Can't locate URI/http.pm:   (null): Too many open files at (eval 559) line 2, <STDIN> line 1.\n","err":"","code":"use URI; $u = URI->new(\"foo\", \"http\"); [ $u->as_string, $u->canonical ]\n"},{"code":"use utf8;  Â§$Â§\")/\"\n","out":"ERROR: Unrecognized character \\x{a7}; marked by <-- HERE after se utf8;  <-- HERE near column 102 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use utf8; \"â\"\n","out":"ÃÂ¢ÃÂÃÂ","err":""},{"out":"ERROR: Unrecognized character \\x{2603}; marked by <-- HERE after se utf8; $<-- HERE near column 102 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use utf8; $â = 1; $â\n"},{"code":"use utf8; ['Ù¢Ù Ù¡Ù¦-Ù Ù£-Ù¢Ù¢ Ù¡Ù¨:Ù¥Ù¤:Ù£Ù¢' =~ /(\\d{4}-\\d{2}-\\d{2}) (\\d{2}:\\d{2}:\\d{2})/]\n","err":"","out":"[\"\\x{662}\\x{660}\\x{661}\\x{666}-\\x{660}\\x{663}-\\x{662}\\x{662}\",\"\\x{661}\\x{668}:\\x{665}\\x{664}:\\x{663}\\x{662}\"]"},{"code":"use utf8; ['Ù¢Ù Ù¡Ù¦-Ù Ù£-Ù¢Ù¢ Ù¡Ù¨:Ù¥Ù¤:Ù£Ù¢' =~ /(\\d{4}-\\d{2}-\\d{2}) (\\d{2}:\\d{2}\\d{2})/]\n","err":"","out":"[]"},{"err":"","out":"[]","code":"use utf8; ['Ù¢Ù Ù¡Ù¦-Ù Ù£-Ù¢Ù¢ Ù¡Ù¨:Ù¥Ù¤:Ù£Ù¢' =~ /(\\d{4}-\\d{2}-\\d{2}) (\\d{2}:\\d{2}:\\d{2})/a]\n"},{"code":"use utf8; \"Ù¢Å±\" =~ /^\\w+$/ # thomas_d\n","out":"1","err":""},{"code":"use utf8; 'Ù£' =~ /\\d/\n","err":"","out":"1"},{"code":"use utf8; [ 'Ù£' =~ /\\d/a, 'Ù£' =~ /./a, \"Ù¢\" =~ /[Ù¡-Ù£]/a, 'Ù£' =~ /\\D/a ]\n","err":"","out":"[1,1,1]"},{"out":"ERROR: Unrecognized character \\x{1f5fe}; marked by <-- HERE after se utf8; $<-- HERE near column 102 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use utf8; $ð¾ = 42;\n"},{"code":"use utf8; $â = 5;\n","out":"ERROR: Unrecognized character \\x{2706}; marked by <-- HERE after se utf8; $<-- HERE near column 102 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"\\u00e6\\u00f8\\u00e5","code":"use utf8; $_ = \"Ã¦Ã¸Ã¥\"; s/(.)/sprintf('\\\\u%04x', ord $1)/ger\n"},{"code":"use utf8; binmode STDOUT, ':utf8'; my $foo = \"test\\x{327}\"; $foo =~ tr/\\x{327}/\\x{326}/; $foo\n","err":"","out":"testÃÂÃÂ¦"},{"err":"","out":"11000010\n","code":"use utf8; $bit = \"C\"; print unpack(\"b8\", $bit) . \"\\n\"; $bit | 1 << 6; $bit = unpack(\"b8\", $bit); print $bi\n"},{"out":"bless( {}, 'skjÃÂ¦rgÃÂ¥rdsÃÂ¸l' )","err":"","code":"use utf8; bless {}, \"skjÃ¦rgÃ¥rdsÃ¸l\";\n"},{"out":"1","err":"","code":"use utf8; 'ð¢' =~ /\\d/\n"},{"code":"use utf8; 'ð¢' =~ /\\d/a\n","out":"","err":""},{"err":"","out":"1","code":"use utf8; $_=\"Ã©\"; $_++; $_\n"},{"err":"","out":"[1,\"\"]","code":"use utf8; ['Ã©' =~ /[[:alpha:]]/ . '', 'Ã©' =~ /[[:alpha:]]/a . '']\n"},{"err":"","out":"ss","code":"use utf8; fc \"Ã\"\n"},{"code":"use utf8; [fc(\"Ô±\"), fc(\"ä¹\")]\n","err":"","out":"[\"\\x{561}\",\"\\x{4e55}\"]"},{"code":"use utf8; $ããã«ã¡ã¯ = \"Good afternoon\"; $ããã«ã¡ã¯\n","out":"Good afternoon","err":""},{"code":"use utf8; $l = \"fooso\"; [ $l & chr(0x80)x(length $l) ]\n","out":"[\"\\0\\0\\0\\0\\0\"]","err":""},{"code":"use utf8; $l = \"fooso\"; [ $l =~tr/\\0-\\225//dr   ]\n","out":"[\"\"]","err":""},{"code":"use utf8; [ map fc, qw(SS ss Ã Î£ Ï Ï I i Ä° Ä±) ]\n","err":"","out":"[\"ss\",\"ss\",\"ss\",\"\\x{3c3}\",\"\\x{3c3}\",\"\\x{3c3}\",\"i\",\"i\",\"i\\x{307}\",\"\\x{131}\"]"},{"err":"Use of uninitialized value $list in pattern match (m//) at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/utf8_heavy.pl line 605, <STDIN> line 1.\n","out":"[\"ss\",\"ss\",\"\\x{df}\",\"\\x{3a3}\",\"\\x{3c3}\",\"\\x{3c2}\",\"i\",\"i\",\"\\x{130}\",\"\\x{131}\"]","code":"use utf8; [ map lc, qw(SS ss Ã Î£ Ï Ï I i Ä° Ä±) ]\n"},{"code":"use utf8; my $Ã¥ = \"buu\"\n","err":"","out":"buu"},{"err":"","out":"lukelovefuckit","code":"use utf8; my %foo = ('â¥' => 'lukelove'); print $foo{'â¥'} . 'fuckit';\n"},{"code":"use utf8; my %foo = ('â¥' => 'lukelove'); say $foo{'â¥'};\n","err":"","out":"lukelove\n"},{"code":"use utf8; my $foo = \"test\\x{327}\"; $foo =~ tr/\\x{327}/\\x{326}/; $foo\n","err":"","out":"testÃÂÃÂ¦"},{"code":"use utf8; my $input = 'Ù£'; say $input + 42;\n","err":"","out":"42\n"},{"out":"[\"\\x{c4}\"]","err":"","code":"use utf8; my $str = \"ÃÃ¶\"; [ $str =~ /([[:upper:]])/ ]\n"},{"code":"use utf8;  my $szÃ­n = 1; $szÃ­n + 1\n","out":"2","err":""},{"out":"ff21.ff22.ff23","err":"","code":"use utf8; my $x = \"ABC\"; $x =~ tr/ABC/ï¼¡ï¼¢ï¼£/; sprintf \"%vx\", $x\n"},{"code":"use utf8; my $x = \"BiÃ¨re\"; printf \"%vx\", $x;\n","out":"42.69.e8.72.65","err":""},{"err":"","out":"[1,1]","code":"use utf8; my $x = \"cafÃ©\"; my $y = substr($x, 1); [ utf8::is_utf8($x), utf8::is_utf8($y) ]\n"},{"code":"use utf8; my $Î±, $Î²; #these are fine, my $a, $b; is not :P\n","err":"","out":""},{"code":"use utf8; [ord \"Ä\"]\n","err":"","out":"[265]"},{"err":"","out":"265","code":"use utf8; ord \"Ä\"\n"},{"code":"use utf8; [ord \"Ã¸\"]\n","err":"","out":"[248]"},{"out":"[369]","err":"","code":"use utf8; [ord \"Å±\"]\n"},{"code":"use utf8; ord uc \"Ã±\"\n","out":"209","err":""},{"code":"use utf8; package Âµ; sub message { \"Hi\" };  say Âµ->message;\n","err":"","out":"Hi\n"},{"err":"","out":"1","code":"use utf8; 'pokÃ¨mon' =~ /\\bpok[eÃ¨]mon\\b/\n"},{"err":"","out":"ERROR: Unrecognized character \\x{37e}; marked by <-- HERE after  print \"a\"<-- HERE near column 110 at (eval 558) line 1, <STDIN> line 1.\n","code":"use utf8; print \"a\"Í¾ print \"b\"\n"},{"out":"?","err":"","code":"use utf8; print join \"\", (\"?\"..\"?\");\n"},{"code":"use utf8; q ÌhelloÌ\n","out":"hello","err":""},{"err":"","out":"qÃÂÃÂhelloÃÂÃÂ","code":"use utf8; qÌhelloÌ\n"},{"code":"use utf8; quotemeta \"Ç\"\n","out":"ÃÂÃÂ","err":""},{"out":"\\ÃÂÃÂ","err":"","code":"use utf8; \"Ç\" =~ s/([^A-Za-z_0-9])/\\\\$1/gr\n"},{"out":"[\"\",1,1,1]","err":"","code":"use utf8; [ scalar('Ù£' =~ /^\\d$/a), scalar('Ù£' =~ /^.$/a), scalar(\"Ù¢\" =~ /^[Ù¡-Ù£]$/a), scalar('Ù£' =~ /^\\D$/a) ]\n"},{"code":"use utf8; [ scalar('Ù£' =~ /\\d/a), scalar('Ù£' =~ /./a), scalar(\"Ù¢\" =~ /[Ù¡-Ù£]/a), scalar('Ù£' =~ /\\D/a) ]\n","err":"","out":"[\"\",1,1,1]"},{"err":"","out":"151","code":"use utf8; sprintf \"%x\", ord \"Å\"\n"},{"code":"use utf8; sprintf \"%x\", ord uc \"Ã±\"\n","err":"","out":"d1"},{"code":"use utf8; [ 'Ã' =~ m/^\\Qss\\E\\z/i ? 'True' : 'False' ];\n","out":"[\"True\"]","err":""},{"out":"ERROR: Illegal declaration of subroutine main::a at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use utf8; sub aâb { \"hi\" } aâb\n"},{"code":"use utf8; sub fÃ¥bar { print \"whee\" } fÃ¥bar();\n","err":"","out":"whee"},{"out":"1","err":"","code":"use utf8; sub InGerm { join \"\\n\", map sprintf(\"%x\", ord($_)), qw(Ã¤ Ã¶ Ã¼) } \"Ã¶\" =~ /\\p{InGerm}/\n"},{"out":"ERROR: Illegal declaration of anonymous subroutine at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use utf8; sub Â» { print \"whee\" } Â»()\n"},{"code":"use utf8; sub t { 1, 2, 3 } tâ¦0â¦\n","out":"ERROR: Unrecognized character \\x{2987}; marked by <-- HERE after , 2, 3 } t<-- HERE near column 120 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use utf8; sub à² _à²  { \"yay\" } à² _à² \n","err":"","out":"yay"},{"code":"use utf8; sub ä¸ª { print \"whee\" } ä¸ª();\n","out":"whee","err":""},{"out":"ÃÂ","err":"","code":"use utf8; uc \"Ã±\"\n"},{"err":"","out":"SS","code":"use utf8; uc \"Ã\"\n"},{"err":"","out":"51","code":"use utf8; unpack \"H2\", \"Å\"\n"},{"err":"","out":"ERROR: Can't find Unicode property definition \"Foo\" at (eval 558) line 1, <STDIN> line 1.\n","code":"use utf8; use constant Foo => join \"\\n\", map sprintf(\"%x\", ord($_)), qw(Ã¤ Ã¶ Ã¼); [ \"Ã¶\" =~ /\\p{Foo}/ ];\n"},{"code":"use utf8; use constant InFoo => join \"\\n\", map sprintf(\"%x\", ord($_)), qw(Ã¤ Ã¶ Ã¼); [ \"Ã¶\" =~ /\\p{InFoo}/ ];\n","err":"","out":"[1]"},{"code":"use utf8; use feature fc; [fc(\"Ô±\"), fc(\"ä¹\")]\n","err":"","out":"ERROR: Feature \"\" is not supported by Perl 5.22.1 at (eval 558) line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't locate Mojo/UserAgent.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use utf8; use Mojo::UserAgent; Mojo::UserAgent->new->get('http://maÃ±ana.com')->res->dom->at('title')->text\n"},{"out":"ERROR: Illegal declaration of subroutine main::ÃÂ¢ÃÂÃÂ at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use utf8; use strict; sub ââ () { \"cool\" } ââ\n"},{"code":"use utf8; [ \"Ó¦ser BÃ¡nana\" =~ /\\w+/g ]\n","err":"","out":"[\"\\x{4e6}ser\",\"B\\x{e1}nana\"]"},{"out":"ÃÂÃÂ¯ ÃÂÃÂ¾ÃÂÃÂÃÂÃÂµÃÂÃÂ½ÃÂÃÂ ÃÂÃÂ¿ÃÂÃÂ»ÃÂÃÂ¾ÃÂÃÂÃÂÃÂ¾ ÃÂÃÂ³ÃÂÃÂ¾ÃÂÃÂ²ÃÂÃÂ¾ÃÂÃÂÃÂÃÂ ÃÂÃÂ¿ÃÂÃÂ¾ ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂºÃÂÃÂ¸ÃÂÃÂ¹","err":"","code":"use utf8; \"Ð¯ Ð¾ÑÐµÐ½Ñ Ð¿Ð»Ð¾ÑÐ¾ Ð³Ð¾Ð²Ð¾ÑÑ Ð¿Ð¾ ÑÑÑÑÐºÐ¸Ð¹\"\n"},{"code":"use utf8; $Ô± = 5; $ä¹ = 7; [ $Ô± + $ä¹ ]\n","out":"[12]","err":""},{"code":"use utf8; [\"Ô±\" < \"ä¹\"?\"yes\":\"no\"]\n","err":"","out":"[\"no\"]"},{"code":"use v5.12; $foo = 'bar'; ++$$foo; $bar\n","out":"1","err":""},{"err":"","out":"foo\nbar\nfoo\n","code":"use v5.12; \"foo\" =~ /(.*)/; say $1; { if (\"bar\" =~ /(.*)/) { say $1; } } say $1;\n"},{"code":"use v5.12; \"foo\" =~ /(.*)/; say $1; if (\"bar\" =~ /(.*)/) { say $1; } say $1;\n","err":"","out":"foo\nbar\nbar\n"},{"err":"","out":"a, 1, 2\na, 1, 3\nb, 1, 2\nb, 1, 3\n","code":"use v5.12; sub combine { my $f = shift; @_ or return $f->(); my $xs = shift; for my $x (@$xs) { combine(sub { $f->($x, @_) }, @_); } } combine sub { say join(\", \", @_) }, ['a', 'b'], [1], [2, 3];\n"},{"out":"a, 1, 2 | \na, 1, 3 | \nb, 1, 2 | \nb, 1, 3 | \n","err":"","code":"use v5.12; sub combine { my $f = shift; @_ or return $f->(); my $xs = shift; for my $x (@$xs) { combine(sub { $f->($x, @_) }, @_); } } combine sub { say join(\", \", @_), \" | \"; }, ['a', 'b'], [1], [2, 3];\n"},{"out":"1","err":"","code":"use v5.12; ++$x\n"},{"out":"0","err":"","code":"use v5.16; $[ = 0\n"},{"err":"","out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 558) line 1, <STDIN> line 1.\n","code":"use v5.16; $[ = 1\n"},{"code":"use v5.16; $_=1; $0xfc\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"$0xfc\n\"\n"},{"code":"use v5.16; $_=1; $0x fc\n","err":"","out":"/home/ryan/bots/perlbuut/lib/eval.pl"},{"err":"","out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 558) line 1, <STDIN> line 1.\n","code":"use v5.16; $[ = -5;\n"},{"code":"use v5.16; my $f = sub { my ($n) = @_; print \"$n \"; $n or return; @_ = $n - 1; goto __SUB__; }; $f->(5);\n","out":"5 4 3 2 1 0 ","err":""},{"err":"","out":"1","code":"use v5.16; ++$x\n"},{"code":"use v5.18; 1;\n","out":"1","err":""},{"out":"","err":"","code":"use v5.18.2;\n"},{"out":"[0,1,2,3]","err":"","code":"use v5.20; my @x; push @x, foo(), foo(); sub foo { state $var = 0; $var++ } push @x, foo(), foo(); \\@x\n"},{"err":"","out":"","code":"use v5.20; say hi\n"},{"code":"use v5.20; say \"hi\" for Altreus;\n","err":"","out":"hi\n"},{"code":"use v5.20; sub foo { __SUB__ } foo\n","out":"sub { \"DUMMY\" }","err":""},{"out":"[0,1,2]","err":"","code":"use v5.20; use warnings; { package Hi; sub foo { state $x = 0; $x++ }  sub new { bless {}, $_[0] } }  [ Hi->new->foo, Hi->new->foo, Hi->new->foo ]\n"},{"err":"","out":"","code":" use v5.6.1;\n"},{"err":"","out":"surprise!\n","code":"use Variable::Magic qw(cast wizard); cast my $foo = 4, wizard get => sub { ${$_[0]}++ }; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say \"surprise!\" }\n"},{"code":"use vars qw( $foo ); $foo = 123; $foo;\n","out":"123","err":""},{"out":"1.1","err":"","code":"use version; my $v = version->new( 1.000001 ); printf q{%vd}, $v;\n"},{"out":"bless( {version => [1,0,1],original => \"1.000001\"}, 'version' )","err":"","code":"use version; my $v = version->new( 1.000001 ); $v;\n"},{"err":"","out":"v5.22.1","code":"use version; print version->parse($])->normal\n"},{"out":"","err":"","code":"use warnings;\n"},{"out":"1","err":"Argument \"\" isn't numeric in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\nArgument \"\" isn't numeric in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; \"\" == \"\"\n"},{"code":"use warnings; ();\n","err":"","out":""},{"code":"use warnings; {{}}\n","err":"","out":"{}"},{"code":"use warnings; $#\n","err":"$# is no longer supported at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"code":"use warnings; +{{}}\n","out":"{\"HASH(0x5a34468)\" => undef}","err":"Odd number of elements in anonymous hash at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"[1]","code":"use warnings;  [ !!\"\" == 0 ]\n"},{"out":"[1]","err":"Argument \"\" isn't numeric in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings;  [ \"\" == 0 ]\n"},{"err":"Scalar value @_[0] better written as $_[0] at (eval 558) line 1, <STDIN> line 1.\n","out":"use warnings; @_[0]","code":"use warnings; @_[0]\n"},{"out":"0","err":"Argument \"\" isn't numeric in addition (+) at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; 0 + ''\n"},{"err":"Argument \"\" isn't numeric in addition (+) at (eval 558) line 1, <STDIN> line 1.\n","out":"0","code":"use warnings; 0+''\n"},{"code":"use warnings; 0+\"\"\n","out":"0","err":"Argument \"\" isn't numeric in addition (+) at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"100328920","err":"","code":"use warnings; 0+{}\n"},{"err":"","out":"","code":"use warnings; 0->[0];\n"},{"out":"ERROR: Incomplete expression within '(?[ ])' in regex; marked by <-- HERE in m/(?[() <-- HERE ])/ at (eval 558) line 1, <STDIN> line 1.\n","err":"The regex_sets feature is experimental in regex; marked by <-- HERE in m/(?[ <-- HERE ()])/ at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; 00./(?[()])/\n"},{"code":"use warnings; 0+!1\n","err":"","out":"0"},{"err":"","out":"0","code":"use warnings; 0 + !5\n"},{"out":"9","err":"","code":"use warnings; 0+'    9'\n"},{"code":"use warnings; 0+\"    9e5\";  # boo!\n","err":"","out":"900000"},{"code":"use warnings; 0+\"    9e\";  # yay!\n","out":"9","err":"Argument \"    9e\" isn't numeric in addition (+) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; 0+(\"a\" eq \"b\")\n","err":"","out":"0"},{"out":"[1]","err":"Argument \"\" isn't numeric in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; [ '' == 0 ] # but you'll get a warning\n"},{"out":"0","err":"","code":"use warnings; 0 + defined( undef )\n"},{"out":"Inf","err":"","code":"use warnings; 0+'Inf'\n"},{"err":"Argument \"nanny\" isn't numeric in addition (+) at (eval 558) line 1, <STDIN> line 1.\n","out":"NaN","code":"use warnings; 0+'nanny'\n"},{"err":"Use of uninitialized value in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\n","out":"1","code":"use warnings; '0' == undef\n"},{"out":"hello ","err":"Use of uninitialized value $0 in scalar assignment at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; $0 = undef; \"hello $0\"\n"},{"code":"use warnings; [ 1 + \"\" ]\n","out":"[1]","err":"Argument \"\" isn't numeric in addition (+) at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"1","code":"use warnings; !1 == !1\n"},{"code":"use warnings; [ 1 == \"1\" ]\n","out":"[1]","err":""},{"out":"[1]","err":"Argument \"1foo\" isn't numeric in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; [ 1 == \"1foo\" ]\n"},{"code":"use warnings; 1+2; 3+4\n","err":"Useless use of a constant (3) in void context at (eval 558) line 1, <STDIN> line 1.\n","out":"7"},{"code":"use warnings; '15.8' == '123abc   '\n","out":"","err":"Argument \"123abc   \" isn't numeric in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; '15.8' == undef\n","err":"Use of uninitialized value in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"code":"use warnings; '15.8' == (undef // '')\n","out":"","err":"Argument \"\" isn't numeric in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","code":"use warnings; '15.8' == (undef // ')'\n"},{"code":"use warnings; '15.8' == undef // ''\n","err":"Use of uninitialized value in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"out":"ERROR: Unknown warnings category '1' at (eval 558) line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use warnings 1e0;\n"},{"code":"use warnings; [ 1 + \"NaN\" ]\n","out":"[\"NaN\"]","err":""},{"out":"[\"NaN\"]","err":"Argument \"Nanny may I have another?\" isn't numeric in addition (+) at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; [ 1 + \"Nanny may I have another?\" ]\n"},{"code":"use warnings; [ 1 + \"not a number\" ]\n","out":"[1]","err":"Argument \"not a number\" isn't numeric in addition (+) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; 2 + '0 but foo'\n","err":"Argument \"0 but foo\" isn't numeric in addition (+) at (eval 558) line 1, <STDIN> line 1.\n","out":"2"},{"code":"use warnings; 2 + '0 but true'\n","out":"2","err":""},{"out":"ERROR: Unmatched right square bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, near \"$#a ]\"\n","err":"","code":"use warnings; $[ = 2; my @a = 5..9; [ keys @a], $#a ]\n"},{"out":"3","err":"Use of uninitialized value in addition (+) at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; 3 + undef\n"},{"code":"use warnings; $] < 5.13.6\n","err":"Argument \"^E\\r^F\" isn't numeric in numeric lt (<) at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"err":"Argument \"infinityandbeyond\" isn't numeric in numeric comparison (<=>) at (eval 558) line 1, <STDIN> line 1.\nArgument \"nananananananananaBATMAN\" isn't numeric in numeric comparison (<=>) at (eval 558) line 1, <STDIN> line 1.\n","out":"[-1,undef]","code":"use warnings; [ 5 <=> \"infinityandbeyond\", 8 <=> \"nananananananananaBATMAN\" ]\n"},{"out":"[1]","err":"Argument \"cats\" isn't numeric in numeric comparison (<=>) at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; [ 7 <=> \"cats\" ]\n"},{"err":"","out":"[undef]","code":"use warnings; [ 7 <=> \"nan\" ]\n"},{"code":"use warnings; [ 7 <=> \"nand\" ]\n","out":"[undef]","err":"Argument \"nand\" isn't numeric in numeric comparison (<=>) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; [ 7 <=> \"nandos\" ]\n","err":"Argument \"nandos\" isn't numeric in numeric comparison (<=>) at (eval 558) line 1, <STDIN> line 1.\n","out":"[undef]"},{"code":"use warnings; 'a' < 0\n","out":"","err":"Argument \"a\" isn't numeric in numeric lt (<) at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"Scalar value @a[1] better written as $a[1] at (eval 558) line 1, <STDIN> line 1.\n","out":"","code":"use warnings; @a[1]\n"},{"err":"Unescaped left brace in regex is deprecated, passed through in regex; marked by <-- HERE in m/a{ <-- HERE / at (eval 558) line 1, <STDIN> line 1.\n","out":"[1]","code":"use warnings; [ \"a{b\" =~ /a{/ ]\n"},{"out":"1","err":"","code":"use warnings; \"a{b\" =~ m/{/;\n"},{"out":"1","err":"Unescaped left brace in regex is deprecated, passed through in regex; marked by <-- HERE in m/a{ <-- HERE / at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; \"a{b\" =~ m/a{/;\n"},{"code":"use warnings; @a = (); print 'true' if @a == undef;\n","out":"true","err":"Use of uninitialized value in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"1","code":"use warnings; @array[0]=5\n"},{"code":"use warnings; $array[99999]=5; 0+ $array[99998]\n","err":"Use of uninitialized value $array[99998] in addition (+) at (eval 558) line 1, <STDIN> line 1.\n","out":"0"},{"code":"use warnings; @array[$index]\n","out":"","err":"Scalar value @array[...] better written as $array[...] at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value $index in array slice at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; \"a\" =~ s/./$1/gr\n","err":"Use of uninitialized value $1 in substitution (s///) at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"err":"Use of uninitialized value $1 in substitution (s///) at (eval 558) line 1, <STDIN> line 1.\n","out":"","code":"use warnings; \"a\" =~ s/./$1/r\n"},{"code":"use warnings; \"a\" =~ s/./$dict{1}/r\n","out":"","err":"Use of uninitialized value $dict{\"1\"} in substitution iterator at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; 'bill.gates@microsoft.com' =~ /[\\w.]+\\@microsoft\\.com$/ ? \"matches\" : \"does not\"\n","out":"matches","err":""},{"out":"Ã°ÂÂÂ©","err":"Wide character in print at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; binmode STDOUT; print \"\\x{1f4a9}\"\n"},{"code":"use warnings; \"blah\" == \"bleh\"\n","out":"1","err":"Argument \"bleh\" isn't numeric in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\nArgument \"blah\" isn't numeric in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"Use of uninitialized value in hash slice at (eval 558) line 1, <STDIN> line 1.\n","out":"","code":"use warnings; @bucket_store_content{ $_path_dismantled_tmp[-2] }\n"},{"code":"use warnings; @confignew{ \"vm-id\" } = [@listvm];\n","err":"","out":"1"},{"code":"use warnings; die, die, die;\n","err":"","out":"ERROR: Died at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"Use of uninitialized value $_ in substitution (s///) at (eval 558) line 1, <STDIN> line 1.\n","out":"[21561,'8214565720323784704']","code":"use warnings; [ $$, do { $a=++$$.s/../$$/;$$<<~~+$a } ]\n"},{"code":"use warnings; dump\n","out":"","err":"dump() better written as CORE::dump() at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"","err":"each on reference is experimental at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; each []\n"},{"err":"","out":"","code":"use warnings; -e \"foo\\nbar\";\n"},{"out":"[\"yes\"]","err":"Argument \"strength\" isn't numeric in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\nArgument \"endurance\" isn't numeric in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; [ 'endurance' == 'strength' ? 'yes' : 'no' ]\n"},{"code":"use warnings; eval{print 1; next; print 2}\n","out":"1","err":"Exiting eval via next at (eval 558) line 1, <STDIN> line 1.\nExiting eval via next at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; eval{print 1; next; print 2}; print 'code: '.$?\n","err":"Exiting eval via next at (eval 558) line 1, <STDIN> line 1.\nExiting eval via next at (eval 558) line 1, <STDIN> line 1.\n","out":"1"},{"code":"use warnings; eval { $x->{a}{b} }\n","out":"","err":""},{"out":"","err":"Argument \"with a string\" isn't numeric in exit at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; exit \"with a string\"\n"},{"code":"use warnings FATAL => \"all\"; if (1 { my $x = 42; print $x; }\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"1 { \"\n\"my\" variable $x masks earlier declaration in same statement at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"; }\"\n"},{"out":"ERROR: Can't locate Unicode/UTF8.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use warnings FATAL => 'utf8'; use Unicode::UTF8 'decode_utf8'; decode_utf8 \"\\x20\\xf8\\x20\"\n"},{"code":"use warnings; [ -f \"/\", -f \"/does-not-exist\", -f undef ]\n","out":"[\"\",undef,undef]","err":"Use of uninitialized value in -f at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; @foo = (1,2,3); length(@foo)\n","out":"1","err":"length() used on @foo (did you mean \"scalar(@foo)\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"","err":"Smartmatch is experimental at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; \"foo\" ~~ \"Bar\"\n"},{"code":"use warnings; \"{{foo\" =~ /{{f/\n","err":"Unescaped left brace in regex is deprecated, passed through in regex; marked by <-- HERE in m/{{ <-- HERE f/ at (eval 558) line 1, <STDIN> line 1.\n","out":"1"},{"code":"use warnings; $foo = $foo . \"abc\";\n","out":"abc","err":"Use of uninitialized value $foo in concatenation (.) or string at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't modify constant item in substitution (s///) at (eval 558) line 1, at EOF\n","err":"\\1 better written as $1 at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; 'foo' =~ s/(.)/\\1/\n"},{"code":"use warnings; 'foo' =~ s/(.)/\\1/re\n","err":"Can't use \\1 to mean $1 in expression at (eval 558) line 1, <STDIN> line 1.\n","out":"SCALAR(0x484e150)oo"},{"code":"use warnings; \"foo\"=~s/(foo)/\\1/r\n","err":"\\1 better written as $1 at (eval 558) line 1, <STDIN> line 1.\n","out":"foo"},{"code":"use warnings; @hash{$key}\n","err":"Scalar value @hash{...} better written as $hash{...} at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value $key in hash slice at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"code":"use warnings; @hash{$key} = [ @list ]\n","out":"1","err":"Use of uninitialized value $key in hash slice at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; $hash{thing} => $value;\n","out":"","err":"Useless use of hash element in void context at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; ${^HELLO_GUYS} . \"\"\n","out":"","err":"Use of uninitialized value $^HELLO_GUYS in concatenation (.) or string at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings;+{[ here => \"are\", my => \"values\" ]}\n","err":"Odd number of elements in anonymous hash at (eval 558) line 1, <STDIN> line 1.\n","out":"{\"ARRAY(0x5991348)\" => undef}"},{"err":"Integer overflow in hexadecimal number at (eval 551) line 5, <STDIN> line 1.\n","out":"3.16059037807746e+20","code":"use warnings; hex q{112233445566778899}\n"},{"code":"use warnings; %h = { stuff => 'sterf' }; \\%h\n","err":"Reference found where even-sized list expected at (eval 558) line 1, <STDIN> line 1.\n","out":"{\"HASH(0x4e17308)\" => undef}"},{"err":"\"my\" variable $x masks earlier declaration in same statement at (eval 558) line 1, <STDIN> line 1.\n","out":"ERROR: syntax error at (eval 558) line 1, near \"1 { \"\nsyntax error at (eval 558) line 1, near \"; }\"\n","code":"use warnings; if (1 { my $x = 42; print $x; }\n"},{"code":"use warnings; if(\"a\" == \"b\"){print \"true\";}else{print \"false\";}\n","err":"Argument \"b\" isn't numeric in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\nArgument \"a\" isn't numeric in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\n","out":"true"},{"code":"use warnings; if (my $blah) { my $count = read $fh, my ($chunk), $chunk_size; }\n","out":"","err":""},{"code":"use warnings; if (my $blah) { my $count = read $fh, my $chunk, ($chunk_size); }\n","out":"","err":""},{"out":"","err":"","code":"use warnings; if (my $blah) { my $count = read $fh, my $chunk, $chunk_size }\n"},{"code":"use warnings; if (my $blah) { my $count = read $fh, my $chunk, $chunk_size; }\n","out":"","err":"Parentheses missing around \"my\" list at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"","err":"","code":"use warnings; if (my $blah) { my $count = read $fh, my $chunk, +$chunk_size; }\n"},{"code":"use warnings; if ($_) { sub foo { ... } } else { sub foo { ... } }\n","err":"Subroutine foo redefined at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"err":"","out":"","code":"use warnings; if (\"this section commented out\" x 0) { die }\n"},{"out":"","err":"","code":"use warnings; $INC{42}\n"},{"out":"0","err":"Argument \"\"1\"\" isn't numeric in int at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; int(q(\"1\"))\n"},{"code":"use warnings; join \" \", undef, undef, undef;\n","out":"  ","err":"Use of uninitialized value in join or string at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value in join or string at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value in join or string at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; keys +{}\n","out":"0","err":"keys on reference is experimental at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; keys INC\n","err":"","out":"ERROR: Type of arg 1 to keys must be hash (not constant item) at (eval 558) line 1, at EOF\n"},{"code":"use warnings; LABEL: { sub { last LABEL }->(); print \"fail\" }; print \"ok\";\n","err":"Exiting subroutine via last at (eval 558) line 1, <STDIN> line 1.\n","out":"ok"},{"err":"","out":"[0,0,0]","code":"use warnings; [ map { $_ + 0 } !!0, !!\"\", !!undef ]\n"},{"code":"use warnings; [ map { ($_+0) ? 'True' : 'False' } 0, '0', '0 but true', '0e0', '0.0' ]\n","out":"[\"False\",\"False\",\"False\",\"False\",\"False\"]","err":""},{"code":"use warnings; [ map { $_ ? 'True' : 'False' } 0, '0', '0 but true', '0e0', '0.0' ]\n","err":"","out":"[\"False\",\"False\",\"True\",\"True\",\"True\"]"},{"code":"use warnings; ''.methods.length\n","out":"methods","err":"Unquoted string \"methods\" may clash with future reserved word at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value in concatenation (.) or string at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; \"@microsoft.com\" =~ /microsoft.com$/ ? \"matches\" : \"does not\"\n","err":"Possible unintended interpolation of @microsoft in string at (eval 558) line 1, <STDIN> line 1.\n","out":"does not"},{"code":"use warnings; m/$var/\n","out":"1","err":"Use of uninitialized value $var in regexp compilation at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value $_ in pattern match (m//) at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"Use of my $_ is experimental at (eval 558) line 1, <STDIN> line 1.\n","out":"","code":"use warnings; my $_;\n"},{"out":"3","err":"Odd number of elements in hash assignment at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; my @a = 1..3; my %hash = @a;\n"},{"out":"hello\n","err":"","code":"use warnings; my $a=5+3, \"hello\\n\";\n"},{"out":"8","err":"Useless use of a constant (\"hello\\n\") in void context at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; my $a=5+3, \"hello\\n\"; print $a\n"},{"code":"use warnings; my @a = 5..9; delete $a[3] [ keys @a ]\n","err":"","out":""},{"code":"use warnings; my @a = 5..9; delete $a[3]; [ keys @a ]\n","out":"[0,1,2,3,4]","err":""},{"err":"","out":"[0,1,2,3]","code":"use warnings; my @a = 5..9; delete $a[4]; [ keys @a ]\n"},{"code":"use warnings; my @a = 5..9; delete $a[4]; [ [keys @a], $#a ]\n","err":"","out":"[[0,1,2,3],3]"},{"err":"","out":"[0,1,2,3,4]","code":"use warnings; my @a = 5..9; [ keys @a ]\n"},{"code":"use warnings; my $aref = [1,2,3]; @{$aref}[1]\n","err":"","out":"2"},{"out":"2","err":"","code":"use warnings; my $aref = [1,2,3]; my $two = @{$aref}[1]\n"},{"code":"use warnings; my %args = { foo => 'bar' };\n","out":"1","err":"Reference found where even-sized list expected at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; my @arr = 1 .. 10; length(0 + @arr)\n","out":"2","err":""},{"code":"use warnings; my @arr = 1 .. 10; length('' . @arr)\n","out":"2","err":""},{"code":"use warnings; my @arr = 1 .. 10; length(@arr)\n","err":"length() used on @arr (did you mean \"scalar(@arr)\"?) at (eval 558) line 1, <STDIN> line 1.\n","out":"2"},{"code":"use warnings; my $arr = [1 .. 10]; length('' . @$arr)\n","out":"2","err":""},{"err":"","out":"2","code":"use warnings; my @arr = 1 .. 10; length(map \"now that's just silly\", @arr)\n"},{"code":"use warnings; my @arr = (1, 3); @arr[0]\n","err":"Scalar value @arr[0] better written as $arr[0] at (eval 558) line 1, <STDIN> line 1.\n","out":"1"},{"out":"42","err":"Argument \"anything\" isn't numeric in array element at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; my @arr; $arr[\"anything\"] = 42;\n"},{"code":"use warnings; my @arr; $arr[\"inf\"] = 42; [ @arr ]\n","err":"","out":"[42]"},{"err":"","out":"42","code":"use warnings; my @arr; $arr[\"NaN\"] = 42;\n"},{"code":"use warnings; my @arr; $arr[\"NaN\"] = 42; [ @arr ]\n","err":"","out":"[42]"},{"out":"1","err":"Use of uninitialized value in print at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; my @array; print $array[5];\n"},{"err":"Strings with code points over 0xFF may not be mapped into in-memory file handles\n","out":"ERROR: open: Invalid argument at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; my $buf = \"\\x{666}\"; open my $fh, '<', \\$buf or die \"open: $!\"\n"},{"code":"use warnings; my $buf = \"\\x{666}\"; open my $fh, '<:encoding(utf8)', \\$buf or die \"open: $!\"\n","out":"ERROR: open: Too many open files at (eval 558) line 1, <STDIN> line 1.\n","err":"Unknown PerlIO layer \"encoding\" at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; my $buf = \"\\xd9\\xa6\"; open my $fh, '<:encoding(utf8)', \\$buf or die \"open: $!\"\n","out":"ERROR: open: Too many open files at (eval 558) line 1, <STDIN> line 1.\n","err":"Unknown PerlIO layer \"encoding\" at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"this matches","err":"Smartmatch is experimental at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; my @foo = 0..10; print \"this matches\" if \"0 but true\" ~~ @foo;\n"},{"code":"use warnings; my @foo = 0..10; print \"this matches\" if \"0 but true\" ~~ @foo; # thanks, pink_mist++\n","out":"this matches","err":"Smartmatch is experimental at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"... too vague \"\n\"use\" not allowed in expression at (eval 558) line 1, near \", \"\n","err":"Smartmatch is experimental at (eval 558) line 1, <STDIN> line 1.\nUnquoted string \"mean\" may clash with future reserved word at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; my @foo = 0..10; print \"this matches\" if \"0 but true\" ~~ @foo; ... too vague for predictable behavior, use the comparison you mean or try Smart::Match for explicit smartmatching\n"},{"code":"use warnings; my @foo = 0..10; print \"this matches\" if \"0 but true\" ~~ @foo; ... too vague for predictable behavior, use the comparison you mean or try Smart::Match for explicit smartmatching | \"Any non-trivial example of smartmatch usually does something other than the author intended.\"\n","out":"ERROR: syntax error at (eval 558) line 1, near \"... too vague \"\n\"use\" not allowed in expression at (eval 558) line 1, near \", \"\n","err":"Smartmatch is experimental at (eval 558) line 1, <STDIN> line 1.\nUnquoted string \"mean\" may clash with future reserved word at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"Smartmatch is experimental at (eval 558) line 1, <STDIN> line 1.\n","out":"this matches","code":"use warnings; my @foo = 0..10; \"this matches\" if \"0 but true\" ~~ @foo;\n"},{"out":"2","err":"","code":"use warnings; my $foo = 1,2;\n"},{"code":"use warnings; my $foo = 1,2,3; $foo\n","out":"1","err":"Useless use of a constant (2) in void context at (eval 558) line 1, <STDIN> line 1.\nUseless use of a constant (3) in void context at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; my $foo = 1,2; $foo\n","err":"Useless use of a constant (2) in void context at (eval 558) line 1, <STDIN> line 1.\n","out":"1"},{"out":"","err":"","code":"use warnings; my $foo = 1; my $bar = 2; my $name = \"foo\"; print \"ok\" if (defined(${$name}));\n"},{"code":"use warnings; my $foo = 1; my $foobar = 2; \"$foo\\bar\"\n","out":"1\bar","err":""},{"out":"\n","err":"Use of uninitialized value $foo in say at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; my $foo = 1; undef $foo; say $foo\n"},{"err":"Parentheses missing around \"my\" list at (eval 558) line 1, <STDIN> line 1.\n","out":"*main::bar","code":"use warnings; my $foo, *bar;\n"},{"code":"use warnings; my @foo; defined @foo\n","out":"ERROR: Can't use 'defined(@array)' (Maybe you should just omit the defined()?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use warnings; my $foo; $foo; 1;\n","out":"1","err":"Useless use of private variable in void context at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; my $foo = { foo => 42}; [ keys  $foo]\n","out":"[\"foo\"]","err":"keys on reference is experimental at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"","err":"\"my\" variable $foo masks earlier declaration in same scope at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; { my $foo; my $foo; }\n"},{"out":"","err":"","code":"use warnings; my $foo; { my $foo; }\n"},{"code":"use warnings; my $foo = sub { +{ content => 'content' }; }; $foo->()->{content};\n","out":"content","err":""},{"code":"use warnings; my $foo = sub { +{ content => 'content' }; }; $foo->(){'content'};\n","out":"content","err":""},{"err":"Unquoted string \"content\" may clash with future reserved word at (eval 558) line 1, <STDIN> line 1.\n","out":"content","code":"use warnings; my $foo = sub { +{ content => 'content' }; }; $foo->(){content};\n"},{"code":"use warnings; my $foo = undef; \"$foo\"\n","err":"Use of uninitialized value $foo in string at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"err":"Odd number of elements in hash assignment at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value in list assignment at (eval 558) line 1, <STDIN> line 1.\n","out":"1","code":"use warnings; my %hash = undef;\n"},{"code":"use warnings; my @list = 0 .. 10; [%list[1..2]]\n","out":"[1,1,2,2]","err":""},{"err":"","out":"[1,\"b\",2,\"c\",3,\"d\"]","code":"use warnings; my @list = \"a\" .. \"h\"; [%list[1..3]]\n"},{"out":"Ã¯Â¼ÂªustÃ¯Â¼ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂtÃ¯Â½ÂÃ¯Â½ÂrÃ¯Â¼ÂÃ¯Â¼ÂµÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂrÃ¯Â¼Â","err":"","code":"use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; eval qq{ 'Just another Unicode hacker,' =~ tr[\\Q$l\\E][\\Q$r\\E]r };\n"},{"out":"4","err":"","code":"use warnings; my $n=split(/\\|/,\"one|two|three|four\");\n"},{"err":"","out":"1","code":"use warnings; my $n = () = split(/\\|/,\"one|two|three|four\");\n"},{"code":"use warnings; my $ref = []; @$ref[0]\n","out":"","err":""},{"err":"","out":"ERROR: Substitution replacement not terminated at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; my $ret = \"foo\" =~ s/Z/; [ $ret.\"\", $ret+0 ]\n"},{"code":"use warnings; my $ret = \"foo\" =~ s/Z//; [ $ret.\"\", $ret+0 ]\n","err":"","out":"ERROR: Can't modify constant item in substitution (s///) at (eval 558) line 1, at EOF\n"},{"err":"","out":"[\"\",0]","code":"use warnings; my $ret = ( my $tmp = \"foo\" ) =~ s/Z//; [ $ret.\"\", $ret+0 ]\n"},{"code":"use warnings; my $str; chomp($str);\n","err":"Use of uninitialized value $str in scalar chomp at (eval 558) line 1, <STDIN> line 1.\n","out":"0"},{"code":"use warnings; my $undefined; $undefined =~ s///;\n","out":"1","err":"Use of uninitialized value $undefined in substitution (s///) at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value $undefined in substitution (s///) at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"Use of uninitialized value in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\n","out":"","code":"use warnings; my $value = undef;  undef == 2\n"},{"code":"use warnings; my $value = undef;  $value == 2\n","err":"Use of uninitialized value $value in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"err":"","out":"[1912]","code":"use warnings; my $x = 12; [ \"19\" . $x ]\n"},{"out":"[1912]","err":"","code":"use warnings; my $x = 12; [ 19 . $x ]\n"},{"code":"use warnings; my $x = \"1234abc\"; $x++; $x\n","err":"Argument \"1234abc\" isn't numeric in preincrement (++) at (eval 558) line 1, <STDIN> line 1.\n","out":"1235"},{"code":"use warnings; my $x = \"abcd\"; $x++; $x\n","out":"abce","err":""},{"code":"use warnings; my $xml = { sessions => [ { session => { status => 42 } } ] }; $xml->{sessions}{session}{status}\n","out":"ERROR: Not a HASH reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use warnings; my $x, my $x;\n","out":"","err":"\"my\" variable $x masks earlier declaration in same statement at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"","err":"\"my\" variable $x masks earlier declaration in same statement at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; my ($x, $x)\n"},{"code":"use warnings; my $x; $x += 2;\n","out":"2","err":""},{"err":"","out":"foo","code":"use warnings; my $x; $x .= \"foo\";\n"},{"code":"use warnings; my $x; $x . 'foo'\n","err":"Use of uninitialized value $x in concatenation (.) or string at (eval 558) line 1, <STDIN> line 1.\n","out":"foo"},{"code":"use warnings; my $x; $x = $x . 'foo'; # Zoffix\n","err":"","out":"foo"},{"code":"use warnings; my ($x, $y, $var) = (42, 37, 0); $var += max $x, $y; $var\n","out":"ERROR: Can't locate object method \"max\" via package \"42\" (perhaps you forgot to load \"42\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"Useless use of private variable in void context at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"","err":"\"my\" variable $x masks earlier declaration in same statement at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; my($x, $y, $x)\n"},{"out":"2","err":"","code":"use warnings; my ($x, $y) = ($y, $x);\n"},{"code":"use warnings; no warnings 'experimental::autoderef'; keys +{}\n","out":"0","err":""},{"code":"use warnings \"\\N{U+7FFFFFFF}\"\n","err":"","out":"ERROR: Unknown warnings category 'ÃÂ½ÃÂ¿ÃÂ¿ÃÂ¿ÃÂ¿ÃÂ¿' at (eval 558) line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; \"\\N{U+7FFFFFFF}\"\n","err":"","out":"ÃÂ½ÃÂ¿ÃÂ¿ÃÂ¿ÃÂ¿ÃÂ¿"},{"out":"","err":"","code":"use warnings; opendir my $dirh, \".\";\n"},{"out":"lala\n|lulu","err":"","code":"use warnings; open $fh, '<', \\\"lala\\nlulu\"; join '|', <$fh>\n"},{"code":"use warnings; open $fh, \"lala\\nlulu\"; join '|', <$fh>\n","out":"","err":"readline() on closed filehandle $fh at (eval 558) line 1.\n"},{"out":"","err":"readline() on closed filehandle $fh at (eval 558) line 1.\n","code":"use warnings; open $fh, \\ \"lala\\nlulu\"; join '|', <$fh>\n"},{"code":"use warnings; open my $fh, '>&=', 2\n","err":"","out":"1"},{"code":"use warnings;  our $NEGATIVE_INDICES = 1; sub M::TIEARRAY { bless {}, shift } sub M::FETCH { print \"Element $_[1]\" }  tie my @arr, \"M\";   $arr[\"onetwothree\"]\n","out":"Element 0","err":"Argument \"onetwothree\" isn't numeric in array element at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Type of arg 1 to pop must be array (not constant item) at (eval 558) line 1, at EOF\n","err":"pop on reference is experimental at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; pop INC\n"},{"code":"use warnings; print 'argh' and exit if $error;\n","err":"","out":""},{"code":"use warnings; print(\"~/\").\"\\n\"\n","out":"~/","err":""},{"code":"use warnings; print \"\\x{2603}\"\n","err":"Wide character in print at (eval 558) line 1, <STDIN> line 1.\n","out":"ÃÂ¢ÃÂÃÂ"},{"code":"use warnings; push INC, undef;\n","out":"ERROR: Type of arg 1 to push must be array (not constant item) at (eval 558) line 1, at EOF\n","err":"push on reference is experimental at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; qr{(?(DEFINE)(?<A>(?&B)|(?&C))}xms;\n","err":"","out":"ERROR: Switch (?(condition)... not terminated in regex; marked by <-- HERE in m/(?(DEFINE)(?<A>(?&B)|(?&C)) <-- HERE / at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"1,2,3","err":"Possible attempt to separate words with commas at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; qw(1,2,3)\n"},{"code":"use warnings qw(experimental); my sub foo { ... }\n","out":"","err":"The lexical_subs feature is experimental at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; readline \"{a,b,c}\"\n","out":"","err":"readline() on unopened filehandle at (eval 558) line 1.\n"},{"code":"use warnings; [ ref undef ]\n","out":"[\"\"]","err":""},{"out":"1","err":"","code":"use warnings; reset\n"},{"out":"\n","err":"Use of uninitialized value in say at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; say undef\n"},{"code":"use warnings; scalar( 0, 1, 0, 1 );\n","err":"","out":"1"},{"code":"use warnings; scalar( 2, 3, 4, 5 );\n","out":"5","err":"Useless use of a constant (2) in void context at (eval 558) line 1, <STDIN> line 1.\nUseless use of a constant (3) in void context at (eval 558) line 1, <STDIN> line 1.\nUseless use of a constant (4) in void context at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"14804","code":"use warnings; scalar grep {     $_ == 0 or $_ % 2 == 0 or $_ % 3 == 0 or $_ % 5 == 0 or $_ % 7 == 0 } map eval, glob join '{+,-,}', split //, \"7474810769\";\n"},{"out":"15197","err":"","code":"use warnings; scalar grep {     $_ == 0 or $_ % 2 == 0 or $_ % 3 == 0 or $_ % 5 == 0 or $_ % 7 == 0 } map eval, map s{[^0-9]\\K0([0-9])}{$1}gr, glob join \"{+,-,}\", split //, \"7474810769\";\n"},{"out":"available","err":"Useless use of a constant (\"set_status\") in void context at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; set_status => 'available';\n"},{"code":"use warnings; s///gI\n","out":"ERROR: Unknown regexp modifier \"/I\" at (eval 558) line 1, near \"; \"\n","err":""},{"err":"","out":"[0,3,7,\"nan\"]","code":"use warnings; [ sort { $a != $a ? 1 : $b != $b ? -1 : $a <=> $b } 0, 7, \"nan\", 3 ]\n"},{"out":"[1,2,3,4,4,11,11,15,\"NaN\",\"nan\",8]","err":"Use of uninitialized value in sort at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; [ sort { $a <=> $b } 4, 15, 11, \"NaN\", 11, 2, 1, 4, 3, \"nan\", 8 ]\n"},{"err":"Use of uninitialized value in sort at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value in sort at (eval 558) line 1, <STDIN> line 1.\n","out":"[0,7,\"nan\",3]","code":"use warnings; [ sort { $a <=> $b } 7, 0, \"nan\", 3 ]\n"},{"code":"use warnings; [ sort { \"NaN\" } 4, 15, 11, 11, 2, 1, 4, 3, 8 ]\n","out":"[4,15,11,11,2,1,4,3,8]","err":""},{"code":"use warnings; splice @a, 2, 2, qw/foo bar/; \\@a\n","out":"[\"foo\",\"bar\"]","err":"splice() offset past end of array at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"","code":"use warnings; \"string\"->{key}\n"},{"err":"","out":"","code":"use warnings; ${\\\"string\"}->{key}\n"},{"out":"2","err":"Variable \"$x\" will not stay shared at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; sub a { my $x=2; sub b { print $x } } a()\n"},{"code":"use warnings; sub a { my $x=2; sub b ($x) { my $x = $_[0]; print $x; } } a()\n","out":"2","err":"The signatures feature is experimental at (eval 558) line 1, <STDIN> line 1.\n\"my\" variable $x masks earlier declaration in same scope at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"0 01 ","code":"use warnings; sub f { my $foo .= \"x\" if shift; $foo .= shift; \"$foo \"; } f(0,0).f(0,1);\n"},{"code":"use warnings; sub f { my $foo .= \"x\" if shift; $foo .= shift; \"$foo \"; } f(1,0).f(0,1);\n","err":"","out":"x0 1 "},{"code":"use warnings; sub foo {1} $x = foo and 1\n","out":"1","err":""},{"code":"use warnings; sub foo(){{}} %{foo}\n","err":"The signatures feature is experimental at (eval 558) line 1, <STDIN> line 1.\nAmbiguous use of %{foo} resolved to %foo at (eval 558) line 1, <STDIN> line 1.\n","out":"0"},{"code":"use warnings; sub foo { @foos = 0; return @foos } @x = 'a' .. 'c'; [@x[foo()], $x[foo()]];\n","err":"","out":"[\"a\",\"b\"]"},{"code":"use warnings; sub foo { @foos = 0 } @x = 'a' .. 'c'; @x[foo()]\n","out":"a","err":""},{"err":"","out":"[\"b\",\"b\"]","code":"use warnings; sub foo { @foos = 1; return @foos } @x = 'a' .. 'c'; [@x[foo()], $x[foo()]];\n"},{"code":"use warnings; sub foo { @foos = 1 } @x = 'a' .. 'c'; [@x[foo()], $x[foo()]];\n","out":"[\"b\",\"b\"]","err":""},{"err":"The signatures feature is experimental at (eval 558) line 1, <STDIN> line 1.\nAmbiguous use of %{foo} resolved to %foo at (eval 558) line 1, <STDIN> line 1.\n","out":"0","code":"use warnings; sub foo(){{}} my %foo; %{foo}\n"},{"out":"2","err":"","code":"use warnings; sub foo { my $x = 1; sub bar {my $y = 2;}}; foo(); bar();\n"},{"err":"Variable \"$x\" will not stay shared at (eval 558) line 1, <STDIN> line 1.\n","out":"","code":"use warnings; sub foo { my $x = 1; sub bar {my $y = $x} }\n"},{"out":"1","err":"Variable \"$x\" will not stay shared at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; sub foo { my $x = 1; sub bar {$x++}}; foo(); bar();\n"},{"code":"use warnings; sub foo (&@) { sub foo; }\n","err":"The signatures feature is experimental at (eval 558) line 1, <STDIN> line 1.\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(&@\"\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":"","code":"use warnings; sub format {} format\n"},{"code":"use warnings sub get_var { warn \"GET VAR\\n\"; return \\my $var }   ${ get_var } += 1\n","out":"ERROR: syntax error at (eval 558) line 1, near \"use warnings sub get_var \"\nsyntax error at (eval 558) line 1, near \"$var }\"\n","err":""},{"code":"use warnings; sub get_var { warn \"GET VAR\\n\"; return \\my $var }   ${ get_var } += 1\n","err":"Ambiguous use of ${get_var} resolved to $get_var at (eval 558) line 1, <STDIN> line 1.\n","out":"1"},{"err":"Ambiguous call resolved as CORE::index(), qualify as such or use & at (eval 558) line 1, <STDIN> line 1.\n","out":"2","code":"use warnings; sub index { ... } index \"asdf\", \"d\"\n"},{"code":"use warnings; sub index :index { ... } index \"asdf\", \"d\"\n","err":"","out":"ERROR: Invalid CODE attribute: index at (eval 558) line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"2","err":"","code":"use warnings; sub index :method { ... } index \"asdf\", \"d\"\n"},{"err":"","out":"ERROR: Unimplemented at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; sub index :method { ... } main::index\n"},{"out":"5","err":"","code":"use warnings; sub index :method { scalar @_ } main::index qw( A B C D E )\n"},{"out":"Element 0","err":"Argument \"onetwothree\" isn't numeric in array element at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings;  sub M::TIEARRAY { bless {}, shift } sub M::FETCH { print \"Element $_[1]\" }  tie my @arr, \"M\";   $arr[\"onetwothree\"]\n"},{"code":"use warnings; sub mynumbs (@$;$);\n","err":"The signatures feature is experimental at (eval 558) line 1, <STDIN> line 1.\nScalar found where operator expected at (eval 558) line 1, near \"$;$)\"\n\t(Missing operator before $)?)\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"@$;\"\n"},{"code":"use warnings; sub push :method { ... }  my @array; push @array, \"value\";\n","out":"1","err":""},{"code":"use warnings; sub push { ... }  my @array; push @array, \"value\";\n","out":"1","err":"Ambiguous call resolved as CORE::push(), qualify as such or use & at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; sub test { $_[0] < 0 and return } test('a')\n","err":"Argument \"a\" isn't numeric in numeric lt (<) at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"out":"","err":"Possible unintended interpolation of @things in string at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; \"@things\"\n"},{"out":"","err":"","code":"use warnings; !!undef\n"},{"out":"[1]","err":"Use of uninitialized value in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; [ undef == 0 ]\n"},{"code":"use warnings; undef @foo;\n","out":"","err":""},{"err":"Use of uninitialized value $undefined in substitution (s///) at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value $undefined in substitution (s///) at (eval 558) line 1, <STDIN> line 1.\n","out":"1","code":"use warnings; $undefined =~ s//bar/;\n"},{"code":"use warnings; undef =~ s//foo/r;\n","err":"Use of uninitialized value in substitution (s///) at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value in substitution (s///) at (eval 558) line 1, <STDIN> line 1.\n","out":"foo"},{"out":"[undef,\"\"]","err":"Use of uninitialized value in concatenation (.) or string at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; [undef, ''.undef]\n"},{"code":"use warnings; use constant cat => 15; cat while $x++<1\n","err":"Useless use of a constant (15) in void context at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"err":"","out":"","code":"use warnings; use constant cat => 1; cat while $x++<1\n"},{"code":"use warnings; use constant cat => 1; cat() while $x++<1\n","err":"","out":""},{"err":"","out":"d9.a6","code":"use warnings; use Encode; my $buf = encode('UTF-8', \"\\x{666}\"); open my $fh, '<', \\$buf or die \"open: $!\"; printf \"%vx\", <$fh>;\n"},{"err":"Unknown PerlIO layer \"encoding\" at (eval 558) line 1, <STDIN> line 1.\n","out":"ERROR: open: Too many open files at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; use Encode; my $buf = encode('UTF-8', \"\\x{666}\"); open my $fh, '<:encoding(UTF-8)', \\$buf or die \"open: $!\" #fine, Grinnz_\n"},{"err":"","out":"[\"c480\"]","code":"use warnings; use Encode; my $x = qq<\\x{100}>; [ unpack q{H*}, Encode::encode_utf8 $x ]\n"},{"err":"Character in 'H' format wrapped in unpack at (eval 558) line 1, <STDIN> line 1.\n","out":"[\"00\"]","code":"use warnings; use Encode; my $x = qq<\\x{100}>; [ unpack q{H*}, $x ]\n"},{"err":"","out":"","code":"use warnings; use experimental 'smartmatch'; \"foo\" ~~ \"Bar\"\n"},{"code":"use warnings; use Function::Parameters qw(:strict); fun mynumbs :(@$;$) {}\n","out":"","err":"prototype after '@' for fun mynumbs: $;$ at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: Can't locate List/Uil.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; use List::Uil 'max'; my ($x, $y, $var) = (42, 37, 0); $var += max $x, $y; $var\n"},{"out":"42","err":"","code":"use warnings; use List::Util 'max'; my ($x, $y, $var) = (42, 37, 0); $var += max $x, $y; $var\n"},{"code":"use warnings; use Moose; has foo => (isa => 'rw); $x = $main->new; $x->foo(undef)\n","err":"","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"outer1: A foo; ERROR: Died at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; use strict; \"foo bar\" =~ /(?<A>\\w+)/ or die; print \"outer1: @{[%+]}; \"; { \"baz\" =~ /(?<B>failed match)/ or die; print \"inner: @{[%+]}; \"; } print \"outer2: @{[%+]}; \";\n"},{"code":"use warnings; use strict; \"foo bar\" =~ /(?<A>\\w+)/ or die; print \"outer1: @{[%+]}; \"; { \"baz\" =~ /(?<B>failed match)/; print \"inner: @{[%+]}; \"; } print \"outer2: @{[%+]}; \";\n","err":"","out":"outer1: A foo; inner: A foo; outer2: A foo; "},{"code":"use warnings; use strict; \"foo bar\" =~ /(?<A>\\w+)/ or die; print \"outer1: @{[%+]}; \"; { \"baz\" =~ /(?<B>\\w+)/ or die; print \"inner: @{[%+]}; \"; } print \"outer2: @{[%+]}; \";\n","err":"","out":"outer1: A foo; inner: B baz; outer2: A foo; "},{"code":"use warnings; use strict; \"foo bar\" =~ /(?<A>\\w+)/ or die; print \"outer1: ${\\\\%+} @{[%+]}; \"; { \"baz\" =~ /(?<B>\\w+)/ or die; print \"inner: ${\\\\%+} @{[%+]}; \"; } print \"outer2: ${\\\\%+} @{[%+]}; \";\n","out":"outer1: HASH(0x2b99ad8) A foo; inner: HASH(0x2b99ad8) B baz; outer2: HASH(0x2b99ad8) A foo; ","err":""},{"code":"use warnings; use strict; my @arr; $arr[-1] = 'foo';\n","out":"ERROR: Modification of non-creatable array value attempted, subscript -1 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use warnings; use strict; my $bar; if (my $foo = $bar) { 1 }\n","err":"","out":""},{"err":"","out":"ERROR: Can't use an undefined value as a symbol reference at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; use strict; my $fh; print $fh 42\n"},{"out":"[42,42]","err":"","code":"use warnings; use strict; my (our $x) = 42; [$x, $::x]\n"},{"code":"use warnings; use strict; my $str = 'afgasfasdf{afsfasdfsdafasf}asdfasfasdf'; my ($blah) = $str =~ m#^.*?{(.*?)}#; $blah\n","err":"","out":"afsfasdfsdafasf"},{"code":"use warnings; use strict; my $str = 'afgasfasdf{afsfasdfsdafasfasdfasfasdf'; my ($blah) = $str =~ m#^.*?{(.*)#; $blah\n","err":"","out":"afsfasdfsdafasfasdfasfasdf"},{"code":"use warnings; use strict; my $x = UNIVERSAL->can('can'); ''->$x('can')\n","err":"","out":""},{"code":"use warnings; use strict; my %x; $x{1}++;\n","out":"0","err":""},{"err":"","out":"1","code":"use warnings; use strict; my $x; $x++; $x\n"},{"code":"use warnings; use strict; our (my $x) = 42; [$x, $::x]\n","out":"[42,undef]","err":""},{"out":"cats","err":"","code":"use warnings; use strict; package Don; sub t { 'cats' } package main; Don't;\n"},{"out":"/foo/bar","err":"","code":"use warnings; use strict; { package Foo; sub TIESCALAR { '/foo/bar' } } tie my $var, Foo::\n"},{"err":"Use of uninitialized value $var in string at (eval 558) line 1, <STDIN> line 1.\n","out":"","code":"use warnings; use strict; { package Foo; sub TIESCALAR { '/foo/bar' } } tie my $var, Foo::; \"$var\"\n"},{"err":"Ambiguous use of %{foo} resolved to %foo at (eval 558) line 1, <STDIN> line 1.\nVariable \"%foo\" is not imported at (eval 558) line 1, <STDIN> line 1.\n\t(Did you mean &foo instead?)\n","out":"ERROR: Global symbol \"%foo\" requires explicit package name (did you forget to declare \"my %foo\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; use strict; sub foo{{}} %{foo}\n"},{"code":"use warnings; use strict; sub foo { my $x; BEGIN { $x = 42; } $x++ } [ foo, foo ]\n","out":"[42,0]","err":"Variable \"$x\" will not stay shared at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"","err":"The signatures feature is experimental at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; use strict; sub test($hr) { print Dumper(%$hr); }\n"},{"err":"","out":"ERROR: Can't use string (\"blue\") as a subroutine ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; use strict; { test => sub { print shift }, color => 'blue' }->{color}->(\"bar\")\n"},{"err":"","out":"bar","code":"use warnings; use strict; { test => sub { print shift } }->{test}->(\"bar\")\n"},{"code":"use warnings; use strict; use experimental 'postderef'; my $x; my @z = @{ $x || [] }; $x->@*\n","err":"","out":"ERROR: Can't use an undefined value as an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"n","code":"use warnings; $^V < 5.013006 ? \"y\" : \"n\"\n"},{"code":"use warnings; $^V < 5.13.6 ? \"y\" : \"n\"\n","err":"","out":"n"},{"code":"use warnings; $^V < 5.136 ? \"y\" : \"n\"\n","err":"","out":"y"},{"err":"Argument \"^F\\0^A\" isn't numeric in numeric lt (<) at (eval 558) line 1, <STDIN> line 1.\n","out":"1","code":"use warnings; v6.0.1 < 4\n"},{"err":"Unquoted string \"wibble\" may clash with future reserved word at (eval 558) line 1, <STDIN> line 1.\n","out":"ERROR: syntax error at (eval 558) line 1, near \"{^\"\n","code":"use warnings; ${^WIBBLE}{wat} = 42; [ keys %{^wibble} ]\n"},{"out":"[\"wat\"]","err":"","code":"use warnings; ${^WIBBLE}{wat} = 42; [ keys %{^WIBBLE} ]\n"},{"code":"use warnings; $worldlen > 20\n","out":"","err":"Use of uninitialized value $worldlen in numeric gt (>) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; \"$x\"\n","err":"Use of uninitialized value $x in string at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"code":"use warnings; $x\n","err":"","out":""},{"code":"use warnings; $x=0;121321 while $x++<1\n","err":"Useless use of a constant (121321) in void context at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"code":"use warnings; $x = !0 + 1; $y = !0 . ''\n","err":"","out":"1"},{"out":"","err":"","code":"use warnings; $x = [ 0 ]; $x->[0][2]\n"},{"code":"use warnings; $_=\"\\x19\"; $_=\"$_\\x00\"; print unpack \"B*\", $_&\"\\x80\\x00\"\n","out":"0000000000000000","err":""},{"out":"1","err":"Found = in conditional, should be == at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; $x = 1 and 1\n"},{"code":"use warnings; $x = 1; @bucket_store_content{ $x }\n","out":"","err":"Scalar value @bucket_store_content{...} better written as $bucket_store_content{...} at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; $x = \"32 string\"; $y = 43; $x + $y\n","err":"Argument \"32 string\" isn't numeric in addition (+) at (eval 558) line 1, <STDIN> line 1.\n","out":"75"},{"out":"[\"\",\"\"]","err":"","code":"use warnings; $x[3] = 9; [exists $x[0], exists $x[4]];\n"},{"out":"4","err":"","code":"use warnings; $x=[4,5,6]; @$x[0]\n"},{"code":"use warnings; $x = \"4\"; $y = \"3\"; $l = $x . $y; $s = $x + $y; print $l print $s\n","err":"print() on unopened filehandle 43 at (eval 558) line 1, <STDIN> line 1.\n","out":"7"},{"code":"use warnings; $x .= \"hallo\";\n","err":"","out":"hallo"},{"code":"use warnings; $xml->{sessions}{session}{'status'}\n","out":"","err":""},{"code":"use warnings; @x = qw(a b); splice @x, 2, 0, 'c'; \\ @x\n","out":"[\"a\",\"b\",\"c\"]","err":""},{"code":"use warnings; $x = @x[0]\n","err":"Scalar value @x[0] better written as $x[0] at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"code":"use warnings; $x x101\n","out":"","err":"Use of uninitialized value $x in repeat (x) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; $x == $y\n","err":"Use of uninitialized value $y in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value $x in numeric eq (==) at (eval 558) line 1, <STDIN> line 1.\n","out":"1"},{"err":"","out":"[42,[]]","code":"use warnings; @y = (42); $x = delete $y[0]; [ $x, \\@y ]\n"},{"code":"use x $^W++;join(($x)x101)\n","out":"ERROR: Can't locate x.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"\"U+\" . sprintf \"%*v04X\", \" U+\", \"hello\"\n","err":"","out":"U+0068 U+0065 U+006C U+006C U+006F"},{"out":"","err":"","code":"#!/usr/bin/perl -w                                      # camel code\n"},{"err":"","out":"[\"openerp-server\"]","code":"[ '/usr/local/bin/openerp-server' =~ m{([^/]+)$} ]\n"},{"err":"","out":"ÃÂ´","code":"utf8::downgrade(my $o = \"\\x{f4}\"); $o\n"},{"code":"utf8::downgrade(my $o = \"\\x{f4}\"); use Data::Dumper; Dumper($o)\n","out":"$VAR1 = 'ÃÂ´';\n","err":""},{"code":"utf8::encode(chr(2<<15))\n","err":"","out":""},{"err":"","out":"ÃÂ°ÃÂÃÂÃÂ","code":"utf8::encode(my $s = chr(2<<15)); $s\n"},{"code":"utf8::is_utf8 chr 255\n","err":"","out":""},{"err":"","out":"1","code":"utf8::is_utf8 chr 321\n"},{"code":"utf8::upgrade(my $o = \"\\x{f4}\"); $o\n","err":"","out":"ÃÂ´"},{"err":"","out":"$VAR1 = \"\\x{f4}\";\n","code":"utf8::upgrade(my $o = \"\\x{f4}\"); use Data::Dumper; Dumper($o)\n"},{"out":"1","err":"","code":"'Ã¼' =~ /\\w/\n"},{"code":"'Ã¼' =~ /\\w/a\n","err":"","out":""},{"code":"\"Ã¼\" xor \"Ã¼\"\n","err":"","out":""},{"code":"[\"Ã¼\" xor \"Ã¼\"]\n","out":"[\"\"]","err":""},{"code":"\"$^V\"\n","err":"","out":"v5.22.1"},{"code":"[ $^V ]\n","err":"","out":"[bless( {version => [5,22,1],original => \"v5.22.1\",qv => 1}, 'version' )]"},{"code":"[ %{ $^V } ]\n","out":"[\"original\",\"v5.22.1\",\"qv\",1,\"version\",[5,22,1]]","err":""},{"code":"[ %$^V ]\n","out":"[0]","err":""},{"err":"","out":"[bless( {original => \"v5.22.1\",qv => 1,version => [5,22,1]}, 'version' )]","code":"[$^V]\n"},{"err":"","out":"","code":"$V\n"},{"code":"$^V\n","out":"bless( {version => [5,22,1],qv => 1,original => \"v5.22.1\"}, 'version' )","err":""},{"err":"","out":"[bless( {original => \"v5.22.1\",version => [5,22,1],qv => 1}, 'version' ),'18446744073709551615']","code":"[$^V, ~0]\n"},{"code":"$v = 0x100202020; $v =( ($v << 1) & 0xFFFFFFFF) | (($v >> 31) & 0x1); sprintf \"%08X\", $v\n","err":"","out":"00404040"},{"code":"$v = 0x100202020; $v =( ($v << 4) & 0xF) | (($v >> (32-4)) & 0x7); sprintf \"%08X\", $v\n","err":"","out":"00000000"},{"out":"20404040","err":"","code":"$v = 0x10202020; $v =( ($v << 1) & 0xFFFFFFFF) | (($v >> 31) & 0x1); sprintf \"%08X\", $v\n"},{"out":"02020201","err":"","code":"$v = 0x10202020; $v =( ($v << 4) & 0xFFFFFFFF) | (($v >> (32-4)) & 0x7); sprintf \"%08X\", $v\n"},{"code":"v112.97.110\n","out":"pan","err":""},{"err":"","out":"thx pink_mist","code":"v116.104.120.32.112.105.110.107.95.109.105.115.116\n"},{"out":"[v1.2.3]","err":"","code":"[v1.2.3]\n"},{"code":"v1.2.3\n","out":"\u0001\u0002\u0003","err":""},{"out":"ERROR: Can't modify constant item in scalar assignment at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, near \"echo \"${v//[^0-9]/}\"\"\n","err":"","code":"v=\"123 abc\"; echo \"${v//[^0-9]/}\";\n"},{"code":"[ v127.0.0.1 ]\n","err":"","out":"[v127.0.0.1]"},{"out":"ÃÂPNG\r\n\u001a\n","err":"","code":"v137.80.78.71.13.10.26.10\n"},{"out":"ERROR: operation not supported with version object at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$^V^2\n"},{"code":"v5.14.0\n","err":"","out":"\u0005\u000e\u0000"},{"code":"v5.22.0\n","out":"\u0005\u0016\u0000","err":""},{"out":"Tracking-Num... ","err":"","code":"v84.114.97.99.107.105.110.103.45.78.117.109.46.46.46.32\n"},{"err":"","out":"0","code":"vA.10 <=> vB.9\n"},{"err":"","out":"","code":"vA.10 < vB.9\n"},{"code":"$val = 'a'; [map $val++, 1 .. 3]\n","err":"","out":"[\"a\",\"b\",\"c\"]"},{"err":"","out":"\"Validation25\",\\N,\\N,\\N,\\N,1,1,1,1,\\N,","code":"$_ = '\"Validation25\",,,,,1,1,1,1,,'; s/,(?=,)/,\\\\N/g; $_\n"},{"code":"@values = (1, 0, 1, 1); $n = 0; $idx = $#values; $n += $_ * (2 ** ($#values - $idx)), --$idx foreach reverse @values; $n;\n","out":"11","err":""},{"err":"","out":"13","code":"@values = (1, 0, 1, 1);  $n = 0; ($n *= 2) += $_ for reverse @values; $n;\n"},{"code":"$var = 0; $var = ! $var;\n","out":"1","err":""},{"code":"$var1 = ''; $var2 = 0; $var3 = undef; [ defined $var1, defined $var2, defined $var3 ]\n","out":"[1,1,\"\"]","err":""},{"out":"0777\n","err":"","code":"$variable = sprintf \"%04o\\n\",0777;\n"},{"code":"$varname=\"raddtiz\"; print \"$varname lol\"\n","out":"raddtiz lol","err":""},{"err":"","out":"original replacement original ","code":"$var = 'original '; print $var; { local $var = 'replacement '; print $var }; print $var;\n"},{"err":"","out":"REF","code":"$var =[]; ref \\$var\n"},{"err":"","out":"[\"ARRAY\",\"REF\"]","code":"$var = []; [ref $var, ref \\$var]\n"},{"out":"GLOB","err":"","code":"$var = *STDOUT; ref \\$var\n"},{"err":"","out":"[\"\",\"GLOB\"]","code":"$var = *STDOUT; [ref $var, ref \\$var]\n"},{"code":"$var = \\*STDOUT; [ref $var, ref \\$var]\n","out":"[\"GLOB\",\"REF\"]","err":""},{"code":"*var = \\substr $_, 0, 1; ref \\$var\n","err":"","out":"LVALUE"},{"code":"vec($_,7,1)=1; [unpack \"s>\", $_]\n","err":"","out":"[]"},{"code":"vec($_,8,1)=1; [unpack \"s>\", $_]\n","err":"","out":"[1]"},{"out":"\u0000\u0002","err":"","code":"vec($_,9,1)=1; print $_\n"},{"code":"vec($_,9,1)=1; print ord $_\n","err":"","out":"01"},{"code":"vec( my $x, 4, 4 ) = 1; printf '%*08b', ' ', $x;\n","out":"%*08b","err":""},{"out":"00000000 00000000 00000001","err":"","code":"vec( my $x, 4, 4 ) = 1; printf '%*v08b', ' ', $x;\n"},{"out":"00000000 00000000 00001000","err":"","code":"vec( my $x, 4, 4 ) = 8; printf '%*v08b', ' ', $x;\n"},{"code":"vec($str, $_, 8) = rand 256 for 0 .. 5; [split //, $str]\n","out":"[\"B\",\"\\306\",\"[\",\"T\",\"\\224\",\"\\333\"]","err":""},{"code":"[ 'version'->can('(\"\"') ]\n","out":"[sub { \"DUMMY\" }]","err":""},{"code":"version->new(\"0.01_002\")->numify\n","out":"0.01_020","err":""},{"out":"[\"v1.0.1\",\"v1.0.1\"]","err":"","code":"[version->parse('1.000001')->normal, version->parse('v1.0.1')->normal]\n"},{"out":"ERROR: Invalid version format (non-numeric data) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"[ version->parse(\"1.023-TRIAL\") ]\n"},{"out":"ERROR: Invalid version format (non-numeric data) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"version->parse('2.08-TRIAL') # not that well, although CPAN itself knows enough to treat it as a dev release\n"},{"code":"version->parse($])->normal # same as $^V\n","err":"","out":"v5.22.1"},{"code":"[version->parse('v0.01'), version->parse('v0.1'), version->parse('v0.10'), version->parse('0.10')]\n","err":"","out":"[bless( {qv => 1,original => \"v0.01\",version => [0,1,0]}, 'version' ),bless( {qv => 1,version => [0,1,0],original => \"v0.1\"}, 'version' ),bless( {qv => 1,original => \"v0.10\",version => [0,10,0]}, 'version' ),bless( {original => \"0.10\",version => [0,100]}, 'version' )]"},{"code":"version->parse('vA.10.0')->normal\n","out":"ERROR: Invalid version format (dotted-decimal versions require at least three parts) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Invalid version format (dotted-decimal versions require at least three parts) at (eval 558) line 1, <STDIN> line 1.\n","code":"version->parse('vA.10')->normal\n"},{"code":"version::qv('5.22.0')\n","err":"","out":"bless( {original => \"5.22.0\",version => [5,22,0],qv => 1}, 'version' )"},{"code":"[$^V, $^O]\n","err":"","out":"[bless( {qv => 1,original => \"v5.22.1\",version => [5,22,1]}, 'version' ),\"haiku\"]"},{"code":"'<' =~ /[[:vowel:]]/\n","err":"","out":"ERROR: POSIX class [:vowel:] unknown in regex; marked by <-- HERE in m/[[:vowel:] <-- HERE ]/ at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"255","code":"$v = unpack('C', pack('B8', '11111111')); $v\n"},{"code":"$w = 3; $h = 4; @out = ( (0) x $w ) x $h; \\@out\n","err":"","out":"[0,0,0,0,0,0,0,0,0,0,0,0]"},{"out":"[[0,0,0],$VAR1->[0],$VAR1->[0],$VAR1->[0]]","err":"","code":"$w = 3; $h = 4; @out = ([ (0) x $w ]) x $h; \\@out\n"},{"out":"[\\0,$VAR1->[0],$VAR1->[0],$VAR1->[0],$VAR1->[0],$VAR1->[0],$VAR1->[0],$VAR1->[0],$VAR1->[0],$VAR1->[0],$VAR1->[0],$VAR1->[0]]","err":"","code":"$w = 3; $h = 4; @out = (\\( (0) x $w )) x $h; \\@out\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"] 1\"\n","err":"","code":"$w = 3; $h = 4; @out = map [ (0) x $w ] 1..$h; \\@out\n"},{"err":"","out":"[[0,0,0],[0,0,0],[0,0,0],[0,0,0]]","code":"$w = 3; $h = 4; @out = map [ (0) x $w ], 1..$h; \\@out\n"},{"code":"wantarray\n","err":"","out":""},{"code":"wantarray ? \"list context\" : defined wantarray ? \"scalar context\" : \"void context\" # there, made it more clearer\n","out":"scalar context","err":""},{"err":"","out":"scalar->()}","code":"\"${\\( wantarray() ? 'list' : 'scalar' )}->()}\"\n"},{"out":"scalar","err":"","code":"\"${\\( wantarray() ? 'list' : 'scalar' )}\"\n"},{"err":"","out":"scalar","code":"wantarray() ? 'list' : 'scalar'\n"},{"code":"wantarray ? \"yes\" : defined wantarray ? \"no\" : \"maybe\"\n","err":"","out":"no"},{"out":"1","err":"Warning: something's wrong at (eval 558) line 1, <STDIN> line 1.\n","code":"warn\n"},{"err":"hello at (eval 558) line 1, <STDIN> line 1.\n","out":"1","code":"warn \"hello\"\n"},{"code":"warn \"hello\\n\"\n","out":"1","err":"hello\n"},{"code":"warn \"test \" . join(\", \", @INC) . \"\\n\";\n","out":"1","err":"test \n"},{"err":"Warning: something's wrong at (eval 558) line 1, <STDIN> line 1.\n","out":"1","code":"warn undef\n"},{"code":"$^W++;eval \"0\".\".undef\"x101\n","out":"","err":""},{"code":"'/**' =~ /^\\/\\*\\*/ # wfm\n","out":"1","err":""},{"out":"ERROR: Can't modify constant item in transliteration (tr///) at (eval 558) line 1, at EOF\n","err":"","code":"'wftedskaebjgdpjgidbsmnjgc' =~ tr/a-z/oh, turtleneck Phrase Jar!/;\n"},{"code":"$_ = \"wftedskaebjgdpjgidbsmnjgc\"; tr/a-z/oh, turtleneck Phrase Jar!/; print;\n","out":"Just another Perl hacker,","err":""},{"code":"$_ = \"wftedskaebjgdpjgidbsmnjgc\";tr/a-z/oh, turtleneck Phrase Jar!/; print;\n","err":"","out":"Just another Perl hacker,"},{"err":"","out":"Just another Perl hacker,","code":"'wftedskaebjgdpjgidbsmnjgc' =~ tr/a-z/oh, turtleneck Phrase Jar!/r;\n"},{"out":"[\"a, 1, 3\",\"a, 1, 4\",\"a, 2, 3\",\"a, 2, 4\",\"b, 1, 3\",\"b, 1, 4\",\"b, 2, 3\",\"b, 2, 4\"]","err":"","code":"@what = ([a,b],[1,2],[3,4]); [ map { s/_//r=~s/_/, /gr } glob join '', map { $\"=',_'; \"{_@$_}\" } @what ]\n"},{"err":"","out":"[0]","code":"[$whatever++]\n"},{"code":"while ( 1 ) { print \"Don't break\\n\"; }\n","err":"","out":""},{"code":"while(@ARGV){@ARVG[1] = \"test\"; print \"true\"; exit()}\n","err":"","out":"0"},{"out":"0","err":"","code":"while(@ARGV){print \"true\"; exit()}\n"},{"code":"'while cloud dark CLoud fluffy CLOUD ClOuD' =~ s/(cloud)/ (~($1 & ' ' x length $1) ^ ' ' x length $1) & lc 'butt' /egir\n","err":"","out":"while butt dark BUtt fluffy BUTT BuTt"},{"code":"while(my $e = glob \"{foo,bar}\") {print $e, \"    \"}\n","out":"foo    bar    ","err":""},{"out":"done","err":"","code":"while((my $pid = -1) > 0) { print $pid } \"done\"\n"},{"err":"","out":"[[\"e\",\"a\"],[\"a\",\"n\"],[\"a\",\"r\"],[\"o\",\"t\"]]","code":"while ('peas and carrots' =~ /([aeiou])(.)/g) { push @bar, [ $1, $2 ] } \\@bar\n"},{"code":"while ('peas and carrots' =~ /(?<v>[aeiou])(?<n>.)/g) { push @bar, { %+ } } \\@bar\n","out":"[{v => \"e\",n => \"a\"},{v => \"a\",n => \"n\"},{v => \"a\",n => \"r\"},{v => \"o\",n => \"t\"}]","err":""},{"code":" while (($x < 10)) { ($y = $x); say($x); } continue { ($x += my $y) }\n","out":"","err":""},{"out":"whoami","err":"","code":"whoami\n"},{"err":"","out":"","code":"`whoami`\n"},{"code":"\"who knows?\"\n","out":"who knows?","err":""},{"code":"\"wibble\" =~ s/wi(b+)/{\"a\".(\"g\"x length $1)}re\n","out":"ERROR: Substitution replacement not terminated at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"\"wibble\" =~ s{wi(b+)}{\"a\".(\"g\"x length $1)}re\n","out":"aggle","err":""},{"code":"$^W++;join(($x)x101)\n","err":"","out":""},{"out":"1","err":"","code":"'word $3' =~ /^\\w+ \\$\\d$/\n"},{"out":"1","err":"","code":"'word $3' =~ /^\\w+\\s\\$\\d$/\n"},{"out":"__n___n  __n_m_n  __n_m_n  _an_man  _angman  hangman  ","err":"","code":"$word = 'hangman'; $sofar = $word =~ s/./_/gr; for $guess (qw(n m z a g h)){ $sofar ^= $word =~ s/[^$guess]/\\0/gr =~ s/$guess/$guess ^ '_'/ger; print \"$sofar  \" }\n"},{"out":"[\"words\",\"in\",\"quotes\"]","err":"","code":"['\"words in quotes\"' =~ /\\b(\\w+)\\b/g ]\n"},{"code":"[\"worker1worker2\" =~ /^(worker[0-9],?)+$/]\n","out":"[\"worker2\"]","err":""},{"out":"[\"worker2\"]","err":"","code":"[\"worker1worker2\" =~ /(worker[0-9],?)+/]\n"},{"code":"[\"worker1worker2\" =~ /^(worker[0-9],?)\\1*$/]\n","err":"","out":"[]"},{"code":"[\"worker1worker2\" =~ /(worker[0-9],?)\\1*/]\n","err":"","out":"[\"worker1\"]"},{"code":"$_ = ' worker.loadbalancer.balance_workers=  worker_1,worker_2,worker_3,worker_4,worker_5'; my (@out, @tmp); m{ \\A \\s* \\Qworker.loadbalancer.balance_workers=\\E \\s* (worker_[0-9]) (?{ push @tmp, $1 }) (?: , (worker_[0-9]) (?{ push @tmp, $2 }) )* \\z (?{ @out = @tmp }) }x; [ @out ]\n","out":"[\"worker_1\",\"worker_2\",\"worker_3\",\"worker_4\",\"worker_5\"]","err":""},{"code":"... works too\n","out":"ERROR: syntax error at (eval 558) line 1, near \"... works too\n\"\n","err":""},{"code":"$worldlen > 20\n","out":"","err":""},{"code":"write($sock, $request, length($request));\n","err":"","out":""},{"err":"","out":"{\"HASH(0x62e7fb0)\" => undef}","code":"%wrong = +{}; \\%wrong\n"},{"out":"[0,1,2]","err":"","code":"[$^W, $^S, $^F]\n"},{"err":"","out":"[\"s\",\"sp\",\"spe\",\"spec\",\"speci\",\"specif\",\"specifi\",\"specific\",\"p\",\"pe\",\"pec\",\"peci\",\"pecif\",\"pecifi\",\"pecific\",\"e\",\"ec\",\"eci\",\"ecif\",\"ecifi\",\"ecific\",\"c\",\"ci\",\"cif\",\"cifi\",\"cific\",\"i\",\"if\",\"ifi\",\"ific\",\"f\",\"fi\",\"fic\",\"i\",\"ic\",\"c\"]","code":"$w=\"specific\"; $len=length $w; for my $i (0..$len-1) { for my $j (1..$len-$i) { push @parts,substr $w,$i,$j}} \\@parts\n"},{"code":"$^W + $^T + $^F\n","out":"1460504119","err":""},{"code":"$::{wtf} = \\*hi; wft();\n","err":"","out":"ERROR: Undefined subroutine &main::wft called at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: Undefined subroutine &main::wtf called at (eval 558) line 1, <STDIN> line 1.\n","code":"$::{wtf} = \\\"hi\"; wtf()\n"},{"code":"\"$x\"\n","err":"","out":""},{"err":"","out":"\u0000<","code":"\"\\x<\"\n"},{"out":"\u0000","err":"","code":"\"\\x\"\n"},{"out":"[\"x\",76816040]","err":"","code":"[x=>~~[]]\n"},{"out":"","err":"","code":"$x\n"},{"code":"$x->()\n","out":"ERROR: Can't use an undefined value as a subroutine reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"\\$x\n","out":"\\undef","err":""},{"code":"++$x\n","out":"1","err":""},{"err":"","out":"/home/ryan/perl5/perlbrew/perls/perl-5.22.1/bin/perl","code":"$^X\n"},{"err":"","out":"<_<","code":"$^X = \"<_<\";\n"},{"code":"$x**0\n","err":"","out":"1"},{"out":"ERROR: Invalid quantifier in {,} in regex; marked by <-- HERE in m/x{ <-- HERE 00}/ at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"/x{00}/\n"},{"err":"","out":"ERROR: Invalid quantifier in {,} in regex; marked by <-- HERE in m/x{ <-- HERE 01}/ at (eval 558) line 1, <STDIN> line 1.\n","code":"/x{01}/\n"},{"err":"","out":"0.00537109375","code":"$x = '0.101010101110011'; hex(\"0b$x\")/2**(length($x) - 2)\n"},{"code":"\"\\x{0265}\\x{01DD}\\x{028E}\"\n","out":"ÃÂÃÂ¥ÃÂÃÂÃÂÃÂ","err":""},{"code":"$x = '042'; [ $x, \"$x\" ]\n","out":"[\"042\",\"042\"]","err":""},{"code":"@x = (0 .. 5); [\\@x, $#x, scalar @x]\n","err":"","out":"[[0,1,2,3,4,5],5,6]"},{"err":"","out":"2","code":"${\"\\x{06}\"} = 1; ++${\"\\x{06}\"};\n"},{"err":"","out":"9","code":"@x = (0 .. 9); pop @x;\n"},{"out":"0","err":"","code":"@x = (0 .. 9); shift @x;\n"},{"err":"","out":"[\"\\n\"]","code":"[\"\\x0a\"]\n"},{"err":"","out":"00000100","code":"$x = 0b00001000; $x >>= 1; sprintf '%08b', $x\n"},{"code":"$x = 0; for (1..1000) {$x += 0.01;}; for (1..1000) {$x -= 0.01}; $x\n","out":"1.35308431126191e-16","err":""},{"err":"","out":"9.99999999999983","code":"$x = 0; for (1 .. 1000) { $x += 0.01; } $x\n"},{"out":"[\"0.5\",\"0.75\",\"0.875\",\"0.9375\",\"0.96875\",\"0.984375\",\"0.9921875\",\"0.99609375\",\"0.998046875\",\"0.9990234375\",\"0.99951171875\",\"0.999755859375\",\"0.9998779296875\",\"0.99993896484375\",\"0.999969482421875\",\"0.999984741210938\",\"0.999992370605469\",\"0.999996185302734\",\"0.999998092651367\",\"0.999999046325684\",\"0.999999523162842\",\"0.999999761581421\",\"0.99999988079071\",\"0.999999940395355\",\"0.999999970197678\",\"0.999999985098839\",\"0.999999992549419\",\"0.99999999627471\",\"0.999999998137355\",\"0.999999999068677\",\"0.999999999534339\",\"0.999999999767169\",\"0.999999999883585\",\"0.999999999941792\",\"0.999999999970896\",\"0.999999999985448\",\"0.999999999992724\",\"0.999999999996362\",\"0.999999999998181\",\"0.999999999999091\",\"0.999999999999545\",\"0.999999999999773\",\"0.999999999999886\",\"0.999999999999943\",\"0.999999999999972\",\"0.999999999999986\",\"0.999999999999993\",\"0.999999999999996\",\"0.999999999999998\",\"0.999999999999999\",1,1,1,1,1,1,1,1,1,1,1,1,1,1]","err":"","code":"$x = 0; [ map {; $x += 1/(2**$_); $x } 1..64 ]\n"},{"code":"$x = 0; [ map {; $x += 1/(2**$_); $x } 1..8 ]\n","err":"","out":"[\"0.5\",\"0.75\",\"0.875\",\"0.9375\",\"0.96875\",\"0.984375\",\"0.9921875\",\"0.99609375\"]"},{"err":"","out":"[0,0,0,1,1,1,2,2,2,3,3,3,3,4,4,4,5,5,5,6,6,6,6,7,7,7,8,8,8,9,9,9,9,10,10,10,11,11,11,12,12,12,12,13,13,13,14,14,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]","code":"$x = 0; [ map {; $x += 1/(2**$_); $x =~ /\\.(9*)/ ? length($1) : -1 } 1..64 ]\n"},{"code":"$x = [ 0 ]; $x->[0][2]\n","out":"","err":""},{"out":"[undef]","err":"","code":"'x' =~ /./; [$1]\n"},{"out":"[1,undef]","err":"","code":"[ %x{1} ]\n"},{"err":"","out":"[\"x\",'18446744073709551615']","code":"[x=>~~-1]\n"},{"code":"$x[-1]\n","err":"","out":""},{"err":"","out":"","code":"/x{10}/\n"},{"err":"","out":"","code":"\"x\"=~/\\{10}/;\n"},{"out":"ÃÂÃÂ","err":"","code":"\"\\x{100}\"\n"},{"out":"10","err":"","code":"$x = '10.12'; $x =~ s/\\..+$//; $x\n"},{"code":"\"\\x{10c}\\x{e1}ste\\x{10d}n\\x{11b} schv\\x{e1}leno\"\n","err":"","out":"ÃÂÃÂÃÂÃÂ¡steÃÂÃÂnÃÂÃÂ schvÃÂÃÂ¡leno"},{"out":"","err":"Out of memory!\n","code":"$x[10e10]++\n"},{"code":"[ ('?') x 10 ] # magic ()\n","out":"[\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\"]","err":""},{"code":"[ ('?' x 10) ] # the () do nothing\n","out":"[\"??????????\"]","err":""},{"code":"$x = 10; while ( $x --> 0 ) { push @arr, $x } \\@arr\n","err":"","out":"[9,8,7,6,5,4,3,2,1,0]"},{"err":"","out":"ERROR: Can't modify constant item in scalar assignment at (eval 558) line 1, at EOF\n","code":"x = 10 || (x > 20 && x < 30)\n"},{"code":"$x = 10; $y = 9; [ [$x, $y], $x <= $y, [$x, $y]->[\"\"] ]\n","out":"[[10,9],\"\",10]","err":""},{"out":"[[10,9],\"\",10]","err":"","code":"$x = 10; $y = 9; [ [$x, $y], $x <= $y, [$x, $y]->[$x <= $y] ]\n"},{"code":"@x=(11,12,13); grep { s/1/9/ } @x; \\@x\n","err":"","out":"[91,92,93]"},{"code":"$x = '11223344'; join( '+', map {  join('-', map { $_  } split //) } $x =~/../g);\n","out":"1-1+2-2+3-3+4-4","err":""},{"code":"$x='${\\1+1}'; eval qq{ \"\\Q$x\\E\" }\n","err":"","out":"${\\1+1}"},{"out":"12 13","err":"","code":"@x = (12, 13); sprintf '%d %d', @x\n"},{"code":"@x = (1, 2, 1); delete @x[@x]; \\@x\n","err":"","out":"[undef,undef,1]"},{"code":"@x = (1, 2, 3,4 ,5 , 6, 7, 8); foreach my $x (@x[0..2]) { print $x; }\n","err":"","out":"123"},{"code":"@x = (1, 2, 3,4 ,5 , 6, 7, 8); @x[0..2];\n","out":"3","err":""},{"out":"5","err":"","code":"@x=([[1,2],[3,4]],[5]); $x[1][0]\n"},{"code":"@x=([[1,2],[3,4]],[5]); $x[1][1]\n","out":"","err":""},{"err":"","out":"","code":"@x=([[1,2],[3,4]],[5]); $x[1][2]\n"},{"err":"","out":"[undef,[1,2,3,4,5]]","code":"@x=(1,2,3,4,5); [$x[-20], \\@x]\n"},{"code":"@x=(1,2,3,4); scalar @x\n","err":"","out":"4"},{"out":"5","err":"","code":"$x = (1, (2, 3), 5);\n"},{"code":"$x = [1,2,3]; Data::Dumper::Dumper([$x, $x])\n","err":"","out":"$VAR1 = [\n          [\n            1,\n            2,\n            3\n          ],\n          $VAR1->[0]\n        ];\n"},{"out":"[undef,2]","err":"","code":"@x=(1,2,3); delete @x[0,2]; \\@x\n"},{"code":"@x=(1,2,3); delete $x[1];\n","out":"2","err":""},{"out":"[1]","err":"","code":"@x=(1,2,3); delete @x[1,2]; \\@x\n"},{"code":"@x=(1,2,3); delete @x[1]; \\@x\n","err":"","out":"[1,undef,3]"},{"out":"[1,undef,3]","err":"","code":"@x=(1,2,3); delete $x[1]; \\@x\n"},{"code":"$x = '1.23'; $x =~ s/\\D+//g; $x\n","out":"123","err":""},{"code":"$x = () = (1,2,4); print($x)\n","err":"","out":"3"},{"code":"$x = 12; { ++local($x) } $x\n","out":"12","err":""},{"out":"[{x => 12},{x => 13},{x => 14}]","err":"","code":"[{x => 12}, {x => 13}, {x => 14}]\n"},{"err":"","out":", 0x1]","code":"$x = \"1   2\"; @y = split(' ', $x); print \"$x[0], $[x1]\";\n"},{"out":"1, 2","err":"","code":"$x = \"1   2\"; @y = split(' ', $x); print \"$y[0], $y[1]\";\n"},{"err":"","out":"3\n","code":"@x = (1..547); say length @x\n"},{"err":"","out":"547\n","code":"@x = (1..547); say scalar @x\n"},{"out":"6","err":"","code":"@x = 1 .. 6; scalar @x\n"},{"code":"@x = (1 .. 8); print @x[0..2];\n","out":"123","err":""},{"code":"$_=\"\\x19\"; $_=\"$_\\x00\"; print unpack \"B*\", $_&\"\\x80\\x00\"\n","err":"","out":"0000000000000000"},{"code":"$_=\"\\x19\"; $_=\"$_\\x00\"; print \"yes\" if $_&\"\\x80\\x00\"\n","out":"yes","err":""},{"code":"\"\\x{1f441}\\x{200d}\\x{1f5e8}\"\n","err":"","out":"ÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ¨"},{"code":"\"\\x{1F478}\\x{200D}\\x{2764}\\x{FE0F}\\x{200D}\\x{1F48B}\\x{200D}\\x{1F438}\"\n","err":"","out":"ÃÂ°ÃÂÃÂÃÂ¸ÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂ¤ÃÂ¯ÃÂ¸ÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ¸"},{"code":"\"\\x{1F64C}\"\n","out":"ÃÂ°ÃÂÃÂÃÂ","err":""},{"code":"$x = 1; sub { @_[0] = 2; }->($x); print $x\n","out":"2","err":""},{"code":"$x =1; $x *= (2**2**$_ + 1) for 1 .. 4; $x\n","out":"1431655765","err":""},{"code":"$x=1; $x *= $_ for 2..10; $x\n","out":"3628800","err":""},{"out":"2","err":"","code":"$x=1; $x = \\$x; $$x=2; $x\n"},{"code":"{} x 2\n","err":"","out":"HASH(0x4d14c48)HASH(0x4d14c48)"},{"err":"","out":"2015-02-23","code":"$x = \"2015-0223\"; substr($x,7,0) = \"-\"; $x\n"},{"code":"$x = 20; [ ++$x, $x++, $x ] # wheeee\n","out":"[22,21,22]","err":""},{"code":"@x = (2, 1, 2); delete @x[@dup = @x]; \\ @x # this one is right\n","err":"","out":"[2]"},{"code":"@x = (2, 1, 2); delete @x[@x]; \\ @x # right\n","out":"[]","err":""},{"code":"@x = (2, 1, 2); delete @x[@x]; \\ @x # wrong!\n","out":"[]","err":""},{"out":"x21\\x21","err":"","code":"'\\x21\\x21' =~ s/(.)/qq(\"$1\")/eer\n"},{"out":"!!","err":"","code":"'\\x21\\x21' =~ s/(.*)/qq(\"$1\")/eer\n"},{"out":"\"\"","err":"","code":"'\\x22\\x22' =~ s/(.*)/qq(\"$1\")/eer\n"},{"out":"\"1","err":"","code":"\"\\x{22}\\x{31}\"\n"},{"out":"[undef,undef,[4,5]]","err":"","code":"@{ $x->[2] } = (4, 5); $x\n"},{"err":"","out":"[\"'\"]","code":"[\"\\x27\"]\n"},{"code":"($x = 2903000)/($y = 2903000)*100\n","out":"100","err":""},{"code":"$x='\\\"2+@'; eval qq{ \"\\Q$x\\E\" }\n","err":"","out":"\\\"2+@"},{"out":"/vi","err":"","code":"'\\x2F\\x76\\x69' =~ s/\\\\x([[:xdigit:]]{1,2})/chr hex $1/ger\n"},{"code":"$x[3] = 123; [keys @x]\n","err":"","out":"[0,1,2,3]"},{"code":"@x = 31 .. 33; scalar @x\n","out":"3","err":""},{"code":"$x = \"32 string\"; $y = 43; $x + $y\n","out":"75","err":""},{"out":"2","err":"","code":"@x = (3, 4); print scalar @x\n"},{"err":"","out":"4","code":"@x = (3, 4); print scalar @x[0,1];\n"},{"code":"$x = 3; $cond = '$x == 3'; print \"$cond is true\" if (eval $cond) # still, though -- ugh\n","err":"","out":"$x == 3 is true"},{"code":"('?') x 4\n","out":"????","err":""},{"code":"[ ('?') x 4 ]\n","out":"[\"?\",\"?\",\"?\",\"?\"]","err":""},{"out":"[\"????\"]","err":"","code":"[ ('?'x4) ]\n"},{"err":"","out":"@@","code":"'\\x40\\x40' =~ s/(.*)/qq(\"$1\")/eer\n"},{"code":"'\\x41\\x41'\n","out":"\\x41\\x41","err":""},{"code":"'\\x41\\x41' =~ s/(.*)/qq(\"$1\")/eer  # /me ducks\n","err":"","out":"AA"},{"err":"","out":"AA","code":"'\\x41\\x41' =~ s/\\\\x([0-9a-fA-F]{2})/pack 'H*', $1/rge;\n"},{"out":"AA","err":"","code":"'\\x41\\x41' =~ s/\\\\x(\\d\\d)/chr hex $1/rge;\n"},{"err":"","out":"ERROR: Can't modify constant item in substitution (s///) at (eval 558) line 1, at EOF\n","code":"'\\x41\\x41' =~ s/\\\\x(\\d\\d)/hex $1/ge;\n"},{"out":"AA","err":"","code":"'\\x41\\x41' =~ s/\\\\x(\\d\\d)/pack 'H*', $1/rge;\n"},{"code":"'\\x41\\x41' =~ s/\\\\x(\\d\\d)/pack 'HH', $1/rge;\n","err":"","out":"@\u0000@\u0000"},{"code":"'\\x41\\x41' =~ s/(\\\\x..)/'qq('.$1.')'/rgee;\n","err":"","out":"AA"},{"err":"","out":"SCALAR(0x4e567e0)SCALAR(0x4e56cd8)","code":"'\\x41\\x41' =~ s/(\\\\x..)/qq($1)/rgee;\n"},{"code":"'\\x41\\x41' =~ s/(\\\\x..)/qq(qq($1))/rgee;\n","out":"AA","err":""},{"code":"'\\x41\\x41' =~ s((\\\\x..))(qq(qq($1)))rgee; # lisp-y?\n","out":"AA","err":""},{"err":"","out":"[5,2]","code":"$x = 42; $first3 = ($x & 56) >> 3; $last3 = $x & 7; [ $first3, $last3 ]\n"},{"err":"","out":"42","code":"$x = 42; sub foo { $x += 23 } { local $x; foo() } $x\n"},{"code":"$x = 42; $x /= 2; $x\n","out":"21","err":""},{"out":"x is 42, eh","err":"","code":"$x = 42; \"x is ${\\$x}, eh\"\n"},{"out":"[37,\\37]","err":"","code":"$x = 42; $x_ref = \\$x; ${$x_ref} = 37; [ $x, $x_ref ]\n"},{"err":"","out":"[\\42,42]","code":"$x = 42; $x_ref = \\$x; [ $x_ref, ${ $x_ref } ]\n"},{"out":"4","err":"","code":"$x=[4,5,6]; @$x[0]\n"},{"code":"$x=[4,5,6]; $$x[0]\n","out":"4","err":""},{"code":"$x = [4, 5, 6]; @$x[0, 1]\n","err":"","out":"5"},{"code":"$x = 4; $x //= 3;\n","out":"4","err":""},{"code":"(' ') x 5\n","out":"     ","err":""},{"code":"[ \" \" x 5 ]\n","err":"","out":"[\"     \"]"},{"code":"[ (' ') x 5 ]\n","out":"[\" \",\" \",\" \",\" \",\" \"]","err":""},{"err":"","out":"[\" \",\" \",\" \",\" \",\" \"]","code":"[ (\" \") x 5 ]\n"},{"code":"[\"_ \" x 5]\n","out":"[\"_ _ _ _ _ \"]","err":""},{"out":"[\" \",\" \",\" \",\" \",\" \"]","err":"","code":"[(\" \") x 5]\n"},{"code":"[(\"_ \") x 5]\n","err":"","out":"[\"_ \",\"_ \",\"_ \",\"_ \",\"_ \"]"},{"code":"[\"#\" x 50 . \"\\n\"]\n","out":"[\"##################################################\\n\"]","err":""},{"code":"[\"#\"x50.\"\\n\"]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"50.\"\\n\"\"\n"},{"code":"[(\"_ \") x 5] [16:44] <perlbot> Altreus: [\"_ \",\"_ \",\"_ \",\"_ \",\"_ \"]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"] [\"\n"},{"out":"5","err":"","code":"$x=5; qq'$x'\n"},{"err":"","out":"8.225621385","code":"$x = 6.7233 * 1.22345;\n"},{"code":"$x = 6.7233 * 1.22345; [ sprintf(\"%f\", $x), unpack(\"H*\",$f) ]\n","out":"[\"8.225621\",\"\"]","err":""},{"out":"[[9,10],1,10]","err":"","code":"$x = 9; $y = 10; [ [$x, $y], $x <= $y, [$x, $y]->[1] ]\n"},{"out":"ERROR: Can't modify constant item in scalar assignment at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, near \"{{\"\n","err":"","code":"$x={'{a}'=2}; $x->{{a}};\n"},{"err":"","out":"2/8","code":"%x = (a => 3, b => 4); print scalar %x\n"},{"err":"","out":"4","code":"%x = (a => 3, b => 4); print scalar @x{'a','b'}\n"},{"code":"%x = ( 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'); my @sortedkeys = sort(keys(%x)); my $highestkey = $sortedkeys[-1]; print $highestkey;\n","out":"d","err":""},{"code":"%x = ( 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'); my @sortedkeys = sort(values(%x)); my $highestkey = $sortedkeys[-1]; print $highestkey;\n","err":"","out":"9"},{"out":"abcd","err":"","code":"%x = ( 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'); print sort { $a cmp $b } keys %x;\n"},{"out":"HASH(0x48653a8)","err":"","code":"%x = { 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'}; print sort { $a cmp $b } keys %x;\n"},{"out":"1","err":"","code":"%x = { 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'}; print $x{'c'};\n"},{"err":"","out":"ERROR: Unknown regexp modifier \"/3\" at (eval 558) line 1, near \"=~ \"\n","code":"$x = \"a a a a a a\"; $x =~ s/a/x/3;print $x\n"},{"code":"$x = () = 'Ã¥' =~ /[Ã¥Ã¤]/g\n","err":"","out":"2"},{"code":"$x=\"aa\";++;print ++$x\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":""},{"err":"","out":"ac","code":"$x=\"aa\";++$x;print ++$x\n"},{"out":"ERROR: Can't modify constant item in scalar assignment at (eval 558) line 1, at EOF\n","err":"","code":"$x = { 'a.b' = 'c' }\n"},{"out":"abCDEFG","err":"","code":"$x = 'abcdefg'; substr($x, 2) =~ y/a-z/A-Z/; $x\n"},{"err":"","out":"abcdefghi","code":"$x = \"abcdfghi\"; substr($x, 4, 0, 'e'); $x\n"},{"code":"$x=\"abcdfghi\"; $x=~s/(abcd).*(fghi)/$1e$2/g; print $x;\n","out":"abcdefghi","err":""},{"out":"cd\n","err":"","code":"$x=\"abcd\"; push @{$x{j}}, split(//,$x); print join(\"\", @{$x{j}}[2,3]), \"\\n\"\n"},{"code":"$x=\"abcd\"; push @{$x{j}}, split(//,$x); print join(\"\", @{$x{j}}[2..3]), \"\\n\"\n","err":"","out":"cd\n"},{"code":"$x->{abc} #so it might\n","out":"","err":""},{"code":"$x->{abc}; $x\n","out":"{}","err":""},{"code":"@x = 'a' .. 'c'; sub lala { my ($aref) = @_; \"@$aref\" } lala \\@x\n","err":"","out":"a b c"},{"code":"%x=(a=>undef); exists $x{a}\n","err":"","out":"1"},{"code":"$x = { a => 'value', b => $x->{a} }; $x\n","err":"","out":"{b => undef,a => \"value\"}"},{"code":"$x->{a}; $x\n","err":"","out":"{}"},{"err":"cannot handle ref type 10 at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/Data/Dumper.pm line 231, <STDIN> line 1.\n","out":"","code":"$x = \"banana\"; \\substr($x, 2)\n"},{"code":"$x = bless [], 'ARRYY(0xDEADBEEF)'; ref $x\n","err":"","out":"ARRYY(0xDEADBEEF)"},{"code":"$x = bless {}, \"Banana\"; [\"$x\", $x =~ /t/]\n","err":"","out":"[\"Banana=HASH(0x541e2c0)\"]"},{"code":"$x = bless {}, \"Banana\"; [$x, $x =~ /t/]\n","err":"","out":"[bless( {}, 'Banana' )]"},{"code":"$x = []; bless $x, \"$x\"; ref $x\n","err":"","out":"ARRAY(0x559c1f8)"},{"out":"ERROR: Attempt to bless into a reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$x = []; bless $x, $x; ref $x\n"},{"code":"\"\\x^C\"\n","out":"\u0000^C","err":""},{"code":"\"\\xc6\"\n","out":"ÃÂ","err":""},{"code":"[\"\\x{cf}\", \"\\xcf\" ]\n","err":"","out":"[\"\\317\",\"\\317\"]"},{"err":"","out":"ÃÂÃÂ","code":"$x = chr(0xC6); Encode::encode_utf8($x)\n"},{"err":"","out":"c386","code":"$x = chr(0xC6); unpack \"H*\", Encode::encode_utf8($x)\n"},{"code":"$x = chr 0xcf; $y = chr 0xcf; Encode::_utf8_on($x); Encode::_utf8_off($y); [$x, $y]\n","err":"Malformed UTF-8 character (1 byte, need 2, after start byte 0xcf) in subroutine entry at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/Data/Dumper.pm line 231, <STDIN> line 1.\nMalformed UTF-8 character (1 byte, need 2, after start byte 0xcf) in subroutine entry at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/Data/Dumper.pm line 231, <STDIN> line 1.\n","out":"[\"\\x{0}\",\"\\317\"]"},{"out":"ÃÂ","err":"","code":"\"\\xd1\"\n"},{"out":"@{[ die 'horribly' ]}","err":"","code":"$x=\"@\" . \"{[ die 'horribly' ]}\"; eval qq{ \"\\Q$x\\E\" }\n"},{"err":"","out":"ERROR: horribly at (eval 558) line 1, <STDIN> line 1.\n","code":"$x=\"@{[ die 'horribly' ]}\"; eval qq{ \"\\Q$x\\E\" }\n"},{"code":"[ $^X, $EXECUTABLE_NAME ]\n","out":"[\"/home/ryan/perl5/perlbrew/perls/perl-5.22.1/bin/perl\",undef]","err":""},{"code":"@x=([],{},$\",\\&f,\\0);s/..(..).*/$1/ for@x;$\"=\"\";\"@x\"\n","out":"RASH DEAL","err":""},{"code":"$\"=\"\";@x=([],{},\" \",\\&f,\\0);s/..(..).*/$1/ for@x;\"@x\"\n","out":"RASH DEAL","err":""},{"err":"","out":"ÃÂ°ÃÂÃÂÃÂ","code":"\"\\xF0\\x9F\\x99\\x8C\"\n"},{"err":"","out":"ÃÂ´","code":"\"\\x{f4}\"\n"},{"code":"\"\\xf6\"\n","err":"","out":"ÃÂ¶"},{"out":"ÃÂ¾ÃÂ«","err":"","code":"\"\\xFE\\xAB\"\n"},{"code":"\"\\xff\"\n","out":"ÃÂ¿","err":""},{"code":"@x = (foo => 1, bar => 2); print ${{@x}}{\"foo\"}\n","err":"","out":"1"},{"code":"@x = (foo => 1, bar => 2); ${{@x}}{\"foo\"}\n","out":"1","err":""},{"err":"","out":"1","code":"@x = ( {foo => 1} ); $x[0]->{foo}\n"},{"code":"@x = (foo => 3, bar => 4); ${{[a=>2, b=>3]}}{\"foo\"}\n","out":"","err":""},{"code":"@x = (foo => 3, bar => 4); ${[foo=>2, bar=>3]}{\"foo\"}\n","err":"","out":"ERROR: Not a HASH reference at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"@x = (foo => 3, bar => 4); ${{[foo=>2, bar=>3]}}{\"foo\"}\n","out":"","err":""},{"code":"@x = (foo => 3, bar => 4); ${{@x}}{\"foo\"}\n","err":"","out":"3"},{"code":"$x = \\@Foo::bar; delete $Foo::{bar}; @$x = \"meow\";\n","err":"","out":"1"},{"code":"@x = (foo => \"fooval\", bar => \"barval\"); print +{@x}->{\"foo\"}\n","err":"","out":"fooval"},{"out":"1","err":"","code":"$x = \\@{\"Foo::ISA\"}; delete $Foo::{ISA}; @$x = \"Bar\"\n"},{"code":"$x=\"foo\\n\"; [ $x, chomp $x ];\n","out":"[\"foo\",1]","err":""},{"err":"","out":"[\"foo\",1,\"foo\"]","code":"$x=\"foo\\n\"; [ $x, chomp $x, $x ];\n"},{"code":"$x{foo}++, $x{foo}\n","out":"1","err":""},{"code":"$x = \"foo\"; [ $x, $x =~ s/foo/bar/r ]\n","err":"","out":"[\"foo\",\"bar\"]"},{"code":"$x{$_}++ for qw[a b c]; \\%x\n","err":"","out":"{c => 1,a => 1,b => 1}"},{"code":"@x = grep /[^\\Wt]/, qw<q w t 6 ! . X>; [@x]\n","err":"","out":"[\"q\",\"w\",6,\"X\"]"},{"code":"@x = 'hello'; my @y = $x[@x] = 'world'; [ \\@y, \\@x ]\n","out":"[[\"world\"],[\"hello\",\"world\"]]","err":""},{"out":"[\"\"]","err":"","code":"[ ('?'x@ids) ]\n"},{"code":"$x = { key => 'value' }, push @{$x->{foo}}, 'bar'; push @{$x->{foo}}, 'baz'; $x\n","err":"","out":"{foo => [\"bar\",\"baz\"],key => \"value\"}"},{"code":"$x = \"lala\"; *$x = \"cat\"; $lala\n","err":"","out":""},{"code":"$x = \"lala\"; *$x = \\\"cat\"; $lala\n","err":"","out":"cat"},{"code":"$x = \"lala\"; *$x = sub {2*3}; lala();\n","out":"6","err":""},{"err":"","out":"XX","code":"$x = 'loooong'; substr($x, 4, 0) = 'XX'; # substr is an lvalue\n"},{"out":"loooXXong","err":"","code":"$x = 'loooong'; substr($x, 4, 0) = 'XX'; $x ; # substr is an lvalue\n"},{"err":"","out":"[*::X,*::X,*::X,*::X]","code":"[*::X, *main::X, *::main::X, *main::main::main::main::X]\n"},{"code":"@x = ( map ord, split //, 64.64.64.5000000000.64.64.64 );  $x = join \",\", @x;  print \"$x\\n\"\n","err":"","out":"64,64,64,5000000000,64,64,64\n"},{"code":"$x = \"\\n\"; chomp $x; [$x]\n","err":"","out":"[\"\"]"},{"code":"[ \"x\\n   \\t \\t   \\n \\n\\n\\n\\n\\n\\n\\ny\" =~ /^(.*)\\s*$/gm ]\n","out":"[\"x\",\"\",\"y\"]","err":""},{"err":"","out":"[\"x\",\"y\"]","code":"[ \"x\\n   \\t \\t   \\n \\n\\n\\n\\n\\n\\n\\ny\" =~ /^\\s*(.*)$/gm ] # like this?\n"},{"code":"[ \"x\\n   \\t \\t   \\n \\n\\n\\n\\n\\n\\n\\ny\" =~ /^\\s*(.*)\\s*$/gm ] # so perhaps you wanted \\h instead of \\s?\n","err":"","out":"[\"x\",\"y\"]"},{"code":"$x = \"(??{print 42})\"; \"banana\" =~ /$x/\n","out":"ERROR: Eval-group not allowed at runtime, use re 'eval' in regex m/(??{print 42})/ at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"qr/^cats$/u","code":"$x = qr/^cats$/\n"},{"err":"","out":"[qr/lala/u,qr/lala/u]","code":"$x = qr/lala/; $xx = qr/$x/; [$x, $xx]\n"},{"err":"","out":"1","code":"$x = qr/something/; \"that's something\" =~ $x\n"},{"err":"","out":"no","code":"\"X\\\\Q(s)Y\" =~ qr'\\Q(s)' ? [$`, $&, $'] : \"no\"\n"},{"err":"","out":"[\"X\\\\\",\"Qs\",\"Y\"]","code":"\"X\\\\QsY\" =~ qr'\\Q(s)' ? [$`, $&, $'] : \"no\"\n"},{"out":"b c a","err":"","code":"@x=qw(a b c); push @x, shift @x; \"@x\"\n"},{"code":"@x=qw(a b c); push @x, shift @x; @x\n","err":"","out":"3"},{"out":"[5,\"b\",\"c\"]","err":"","code":"@x=qw(a b c); sub z{$_[0]=5;} z(@x); \\@x\n"},{"code":"@x=qw(a b c); unshift @x, pop @x; \"@x\"\n","err":"","out":"c a b"},{"code":"@x{qw{a b c}}++; \\%x\n","err":"","out":"{c => 1,a => undef,b => undef}"},{"err":"","out":"[3,\"a\"]","code":"@x=qw(a b c); $x=@x;($y)=@x;[$x,$y]\n"},{"code":"@x=qw/a b c/; $z=[@x[0,1]]; for(@$z){$_++; print} \\@x\n","err":"","out":"bc"},{"code":"@x=qw/a b c/; $z=[@x[0,1]]; for(@$z){$_++} \\@x\n","err":"","out":"[\"a\",\"b\",\"c\"]"},{"err":"","out":"3","code":"@x=qw( a b ); print push @x, 'c'\n"},{"out":"{baz => undef,bar => undef,foo => undef}","err":"","code":"@x{qw/foo bar baz/}=(); \\%x\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"})\"\n","err":"","code":"@x{qw/foo bar baz/})=(); \\%x\n"},{"code":"@x = qw{' . \"@INC\" . '}; \\ @x\n","out":"[\"'\",\".\",\"\\\"\\@INC\\\"\",\".\",\"'\"]","err":""},{"code":"$x = ''; $ref = \\$x; [ \"\".$ref, \"\". \\${$$ref} ]\n","out":"[\"SCALAR(0x6264ec8)\",\"SCALAR(0x65989f8)\"]","err":""},{"out":"[\"REF(0x503b000)\",\"SCALAR(0x533e460)\"]","err":"","code":"$x = ''; $ref = \\$x; [ \"\".\\$ref, \"\". \\${$$ref} ]\n"},{"code":"$x = { site => 'lol' }; $y = \"foo\";  \"lefoobar\" =~ s/$y/$x->{site}/r\n","out":"lelolbar","err":""},{"out":"HASH(0x61d12f8) 61d12f8","err":"","code":"$x = {}; sprintf \"%s %x\", $x, $x\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"} $x\"\n","err":"","code":"$x = sub { 3 } $x->() + 1\n"},{"out":"4","err":"","code":"$x = sub { 3 }; $x->() + 1\n"},{"out":"here we go","err":"","code":"$x = [ sub { 'here ' . shift } ]; $x->[0]->('we go')\n"},{"err":"","out":"RA SH   DE AL","code":"@x=([],{},\" \",sub{},\\\"\");map{s/..(..).*/$1/}@x;\"@x\"\n"},{"out":"RASH DEAL","err":"","code":"$\"=\"\";@x=([],{},\" \",sub{},\\\"\");map{s/..(..).*/$1/}@x;\"@x\"\n"},{"err":"","out":"RASH DEAL","code":"$\"=\"\";@x=([],{},\" \",sub{},\\\"\");s/..(..).*/$1/ for@x;\"@x\"\n"},{"code":"$x = 'text25more text25fdsdf'; $x =~ s/text(\\d+)more text(\\1)fdsdf/'foo' . ($1 * $1)/e; $x\n","err":"","out":"foo625"},{"code":"' ' =~ /[ ]/x ? 'T' : 'F';\n","err":"","out":"T"},{"code":"%x = (this => {0..3}, that => {'a'..'d'}); \\%x;\n","err":"","out":"{this => {0 => 1,2 => 3},that => {c => \"d\",a => \"b\"}}"},{"code":"@x = \"This\" =~ s/(.)/sprintf \"%b \", ord $1/gre; [@x]\n","out":"[\"1010100 1101000 1101001 1110011 \"]","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"] is it \"\n","err":"","code":"@x = \"This\" =~ s/(.)/sprintf \"%b \", ord $1/gre; [@x] is it a command ?\n"},{"err":"","out":"[\\$VAR1->[0],$VAR1->[0]]","code":"$x = 'three'; $y = \\$x; $x = \\$x; [ $x, $y ]\n"},{"code":"$x = \\undef; \"$x\"\n","out":"SCALAR(0x7b3860)","err":""},{"err":"","out":"3","code":"$x = undef; $x //= 3;\n"},{"code":"@x[$wa = wantarray]; $wa\n","err":"","out":""},{"out":"[0,1]","err":"","code":"[ $x++, $x ]\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"} [\"\n","err":"","code":"$x = {} [ \"$x\", 0+$x ]\n"},{"code":"$x = {}; [ \"$x\", 0+$x ]\n","err":"","out":"[\"HASH(0x61f5278)\",102716024]"},{"code":"@x = $x || (12, 13, 14); \\ @x\n","out":"[12,13,14]","err":""},{"err":"","out":"[\"\\x{2019}\",\"'\"]","code":" @x = \"\\x{2019}\"; push @x, ($x[0] =~ s/\\x{2019}/'/r); [@x]\n"},{"out":"[\"xxxxx\"]","err":"","code":"[ 'x' x 5 ]\n"},{"code":"$x = \"\\x65\\x66\\x67\";\n","err":"","out":"efg"},{"code":"$x = \"\\x65\\x66\\x67\"; eval \"qq($x)\" # not recommended\n","out":"efg","err":""},{"code":"@x = \"xAyxByxCy\" =~ /x(.)y/g; $1 # last capture, not first\n","out":"C","err":""},{"err":"","out":"[]","code":"[ 'XX' =~ /((?i)x)x/ ]\n"},{"code":"\"xx: m:q\" =~ /(^[a-z367]*?: |\\s|^)(?:m|mixer):(\\S+)/; [$1, $2]\n","err":"","out":"[\"xx: \",\"q\"]"},{"code":"'xxS01E32yy' =~ s/S01E([0-9][0-9])/\"S01E\" . ($1*2) . \"E\" . ($1*2 + 1)/er\n","out":"xxS01E64E65yy","err":""},{"code":"'xxS01E32yy' =~ s/S01E([0-9][0-9])/\"S01E\" . $1*2 . \"E\" . $1*2 + 1/er\n","err":"","out":"xx1yy"},{"out":"[1,2,3]","err":"","code":"[ ++$x . '', ++$x . '', ++$x . '' ]\n"},{"out":"[3,3,3]","err":"","code":"[ ++$x, ++$x, ++$x ]\n"},{"out":"[0,1,2]","err":"","code":"[$x++, $x++, $x++]\n"},{"code":"\"xxx\" + 5\n","err":"","out":"5"},{"code":"\"\\x<\\x-\\xc\\xt\\xr\\xc\"\n","err":"","out":"\u0000<\u0000-\f\u0000t\u0000r\f"},{"code":"{ \"XXX\" =~ /(.*)/; } print $1\n","out":"1","err":""},{"out":"X!xX!x!X!","err":"","code":"$_ = \"x!xx!x!x!\"; my $state = 0; s/(\\w)/++$state % 2 ? (uc $1) : (lc $1)/ge; $_\n"},{"code":"\"x x xx xxx xxxxx\\n\" =~ /^\\s*(?:((?(1)(?(3)(?(2)\\2|\\3)(\\1)|(\\S))|\\S))\\s+)+$/ ? \"\\\\o/\" : \":-(\"\n","out":"\\o/","err":""},{"code":"\"x x xx xxx xxxxx\\n\" =~ /^\\s*(?:((?(1)(?(3)(?(2)\\2|\\3)(\\1)|(\\S))|\\S))\\s+)+$/ ? \"\\o/\" : \":-(\"\n","out":"ERROR: Missing braces on \\o{} at (eval 558) line 1, within string\n","err":""},{"code":"\"x x xx xxx xxxxx xxxxxxxx\\n\" =~ /^\\s*(?:((?(1)(?(3)(?(2)\\2|\\3)(\\1)|(\\S))|\\S))\\s+)+$/ ? \"a fibonacci sequence\" : \"bzzt\"\n","out":"a fibonacci sequence","err":""},{"code":"$x = 'XYZ XYZ XYZ'; $y =()= $x =~ /XYZ/g; $y\n","err":"","out":"3"},{"err":"","out":"\\undef","code":"\\$x = \\$y\n"},{"err":"","out":"[\"\"]","code":"'x' =~ /(y?)/; [$1]\n"},{"code":"'x' =~ /(y)?/; [$1]\n","err":"","out":"[undef]"},{"code":"[ ($x, $y) = 5 .. 10 ]\n","err":"","out":"[5,6]"},{"code":"($x, $y) = 'abc' =~ /(..)(.)/; [$1, $2] # $1, $2 are populated even when storing the values elsewhere\n","out":"[\"ab\",\"c\"]","err":""},{"out":"4","err":"","code":"($x, $y) = qw(a b c d)\n"},{"out":"[\"z\"]","err":"","code":"$x=\"y\"; [ ++$x ]\n"},{"code":"%x = { \"y\" => \"z\" }; $x{\"hey\"} += 5; print $x{\"hey\"};\n","err":"","out":"5"},{"code":"[ 'xyzzy' =~ /(\\w)\\g{1}/ ]\n","out":"[\"z\"]","err":""},{"code":"'xZx' =~ m'Z'\n","err":"","out":"1"},{"out":"1","err":"","code":"'xZx' =~ m\"Z\"\n"},{"code":"$x=\"z\"; $x++; $x\n","err":"","out":"aa"},{"err":"","out":"aaaa","code":"$x = 'zzz'; $x++; $x\n"},{"code":"@y = (1, 2, 3); \\ @y\n","err":"","out":"[1,2,3]"},{"code":"@y = 1, 2, 3; \\ @y\n","out":"[1]","err":""},{"code":"$y=1; *x = (sub { \\@_ })->($y); $x[0] = 2; print \"$y\\n\";\n","out":"2\n","err":""},{"code":"$_ = \"yes\" ; y/e/Ã©/; $_\n","err":"","out":"yÃÂs"},{"code":"$_ = \"yes\" ; y/e/Ã©//; $_\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n"},{"err":"","out":"1","code":"$y=\"one\"; $z = undef; $y = $z || ''; print $z;\n"},{"code":"$y=\"one\"; $z = undef; $y = $z || undef; print $z;\n","err":"","out":"1"},{"out":"\\\"you\"","err":"","code":"\\\"you\"\n"},{"out":"ERROR: \"use\" not allowed in expression at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 2, near \"you can use sprintf\n\"\n","err":"","code":"you can use sprintf\n"},{"out":"ERROR: Can't locate object method \"your\" via package \"code\" (perhaps you forgot to load \"code\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"your code\n"},{"out":"ERROR: Global symbol \"$x\" requires explicit package name (did you forget to declare \"my $x\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$y; { use strict; $x }\n"},{"out":"IO::Handle=GLOB(0x527a3b8)","err":"","code":"$z=new IO::Handle; \"$z\"\n"},{"code":"[ \"Zoffix doubts that map example works\" =~ /(?=(..))/sg ]\n","out":"[\"Zo\",\"of\",\"ff\",\"fi\",\"ix\",\"x \",\" d\",\"do\",\"ou\",\"ub\",\"bt\",\"ts\",\"s \",\" t\",\"th\",\"ha\",\"at\",\"t \",\" m\",\"ma\",\"ap\",\"p \",\" e\",\"ex\",\"xa\",\"am\",\"mp\",\"pl\",\"le\",\"e \",\" w\",\"wo\",\"or\",\"rk\",\"ks\"]","err":""},{"err":"","out":"1","code":"'zoom' =~ m moom\n"},{"code":"$z='the quick brown fox jumped over the lazy dogs in leet speak'; $z=~s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $z;\n","out":"THe quick brOWn fOx jUmpEd OVer THe laZy dOGS in Leet spEak","err":""},{"err":"","out":"1","code":"$z='the quick brown fox jumped over the lazy dogs in leet speak'; $z = s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $z;\n"},{"code":"$z=\\$x; \"$z\"\n","err":"","out":"SCALAR(0x4aa3698)"},{"code":"[ \"ÎRRÎÎ¥\" ]\n","out":"[\"\\316\\221RR\\316\\221\\316\\245\"]","err":""},{"err":"","out":"[1]","code":"[ 'Î©' cmp 'Î' ]\n"},{"code":"\"Ð¯ Ð¾ÑÐµÐ½Ñ Ð¿Ð»Ð¾ÑÐ¾ Ð³Ð¾Ð²Ð¾ÑÑ Ð¿Ð¾ ÑÑÑÑÐºÐ¸Ð¹\"\n","err":"","out":"ÃÂÃÂ¯ ÃÂÃÂ¾ÃÂÃÂÃÂÃÂµÃÂÃÂ½ÃÂÃÂ ÃÂÃÂ¿ÃÂÃÂ»ÃÂÃÂ¾ÃÂÃÂÃÂÃÂ¾ ÃÂÃÂ³ÃÂÃÂ¾ÃÂÃÂ²ÃÂÃÂ¾ÃÂÃÂÃÂÃÂ ÃÂÃÂ¿ÃÂÃÂ¾ ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂºÃÂÃÂ¸ÃÂÃÂ¹"}],"evals/evals-freenode-#perl-cats.lst":[{"code":"\"0.0\"+0 ? 1 : 0\n","out":"0","err":""},{"out":"1","err":"","code":"\"0.0\" ? 1 : 0\n"},{"err":"","out":"0","code":"0.0 ? 1 : 0\n"},{"err":"","out":"0","code":"\"0e0\"+\"0e0\" ? 1 : 0\n"},{"out":"1","err":"","code":"\"0e0\" ? 1 : 0\n"},{"out":"0","err":"","code":"0e0 ? 1 : 0\n"},{"code":"0xffff == 0b1111111111111111\n","out":"1","err":""},{"err":"","out":"1","code":"1\n"},{"code":"\"1\"\n","err":"","out":"1"},{"err":"","out":"ERROR: Illegal division by zero at (eval 558) line 1, <STDIN> line 1.\n","code":"1/0\n"},{"code":"1.0 == 3.0/2.999999999999999999999999999999999999999999999\n","out":"1","err":""},{"out":"1","err":"","code":"1.0 == 3.0/3.0\n"},{"out":"[24]","err":"","code":"[20+4]\n"},{"err":"","out":"OK","code":"BEGIN { package v5::Please; $INC{'v5/Please.pm'} = 1; sub import { print q[OK] } }; use v5::Please;\n"},{"code":"BEGIN { package v5::Please; $INC{'v5/Please.pm'} = 1; sub import { q[OK] } }; use v5::Please;\n","out":"","err":""},{"code":"{foo => 1, foo => 2}\n","out":"{foo => 2}","err":""},{"err":"","out":"3","code":"($inf, $neginf, $nan) = (9**9**9, -9**9**9, -sin(9**9**9))\n"},{"code":"($inf, $neginf, $nan) = (9**9**9, -9**9**9, -sin(9**9**9)); $nan\n","err":"","out":"NaN"},{"code":"($inf, $neginf, $nan) = (9**9**9, -9**9**9, -sin(9**9**9)); use List::Util qw/max/; max(1.0, $nan)\n","out":"NaN","err":""},{"code":"($inf, $neginf, $nan) = (9**9**9, -9**9**9, -sin(9**9**9)); use List::Util qw/max/; max($nan, 1.0)\n","out":"1","err":""},{"out":"30","err":"","code":"length \"America/Argentina/Buenos_Aires\"\n"},{"code":"length qq{{\"customer_id\":114631,\"survey_id\":485,\"ttl\":10}};\n","out":"47","err":""},{"code":"length \"\\t->alloc called: 12345678 12345678 12345 12345\"\n","out":"46","err":""},{"err":"","out":"\\0","code":"my $a = [0]; sub foo {my $b = shift; return \\$b->[0]}; foo $a\n"},{"err":"","out":"[1]","code":"my $a = [0]; sub foo {my $b = shift; return \\$b->[0]}; ${foo $a} = 1; $a\n"},{"err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","code":"my @a = qw/a 1 b 2 c 3/; ${@a}->{a};\n"},{"code":"my @a = qw/a 1 b 2 c 3/; {@A}->{a}\n","out":"ERROR: syntax error at (eval 558) line 1, near \"}->\"\n","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"}->\"\n","err":"","code":"my @a = qw/a 1 b 2 c 3/; {+@A}->{a}\n"},{"code":"my @a = qw/a 1 b 2 c 3/; ${+@A}{a}\n","out":"","err":""},{"out":"{b => 2,a => 1,c => 3}","err":"","code":"my @a = qw/a 1 b 2 c 3/; my $h = {@a}; $h\n"},{"code":"my @a = qw/a 1 b 2 c 3/; my $h = {@A}; $h\n","out":"{}","err":""},{"err":"","out":"[]","code":"my $b = []; $a = \\$b;  $$a = []; $a = $$a; $a = []; $b\n"},{"out":"Just another Perl hacker\n","err":"","code":"my($this)=qw(viogel$pviT$vilxsre$xwyN); my(@arr)=split(//,$this);  foreach(reverse(@arr)){ print(chr(ord($_)-(1<<2))); } print \"\\n\";\n"},{"err":"","out":"ÃÂ","code":"\"\\N{NEL}\"\n"},{"code":"\"\\N{PILE OF POO}\"\n","out":"ÃÂ°ÃÂÃÂÃÂ©","err":""},{"code":"\"\\N{SNOWMAN}\"\n","out":"ÃÂ¢ÃÂÃÂ","err":""},{"err":"","out":"pi","code":"pi\n"},{"code":"print \"foo\" if (+{});\n","err":"","out":"foo"},{"code":"print \"foo\" if (keys %{+{}});\n","err":"","out":"0"},{"err":"","out":"ERROR: Can't find string terminator \"ÃÂ\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","code":"print qÍ¾This is a test;;\n"},{"code":"[quotemeta \"\\n\"]\n","err":"","out":"[\"\\\\\\n\"]"},{"err":"","out":"\\\n","code":"quotemeta \"\\n\"\n"},{"code":"[quotemeta \"\\n\" =~ s/\\\\\\n/\\n/gr]\n","out":"[\"\\\\\\n\"]","err":""},{"code":"sprintf \"%08b\", 015  # dick\n","out":"00001101","err":""},{"code":"sprintf('0x%x', 0b1111111111111111)\n","out":"0xffff","err":""},{"code":"sprintf \"%8b\", 015\n","out":"    1101","err":""},{"out":"$VAR1 = [\n          'main'\n        ];\n$VAR2 = 'main::boo';\n","err":"","code":"sub AUTOLOAD {Dumper(\\@_, $AUTOLOAD)}; my $foo = \"boo\"; __PACKAGE__->$foo\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":"","code":"sub AUTOLOAD {Dumper(\\@_, $AUTOLOAD}; my $foo = \"boo\"; __PACKAGE__->$foo\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"->\"\"\"\n","err":"","code":"sub AUTOLOAD {Dumper(\\@_, $AUTOLOAD)}; my $foo = \"\"; __PACKAGE__->\"\"\n"},{"code":"sub AUTOLOAD {Dumper(\\@_, $AUTOLOAD)}; my $foo = \"\"; __PACKAGE__->(\"foo\")\n","out":"$VAR1 = [\n          'foo'\n        ];\n$VAR2 = 'main::main';\n","err":""},{"code":"sub AUTOLOAD {Dumper(\\@_, $AUTOLOAD)}; my $foo = \"\"; __PACKAGE__->$foo\n","err":"","out":"$VAR1 = [\n          'main'\n        ];\n$VAR2 = 'main::';\n"},{"out":"$VAR1 = 'main';\n","err":"","code":"sub AUTOLOAD {Dumper@_}; my $foo = \"boo\"; __PACKAGE__->$foo\n"},{"code":"sub AUTOLOAD {Dumper@_}; my $foo = \"\"; __PACKAGE__->$foo\n","out":"$VAR1 = 'main';\n","err":""},{"err":"","out":"1460494466","code":"$^T\n"},{"code":"use CGI;\n","err":"","out":"ERROR: Can't locate CGI.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't enable unknown feature signature at (eval 558) line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use experimental 'signature';\n"},{"out":"","err":"","code":"use experimental 'signatures';\n"},{"code":"use experimental 'signatures'; sub foo($bar) {print $bar, $bar}; foo(\"hola hoops \");\n","err":"","out":"hola hoops hola hoops "},{"code":"use JSON::MaybeXS; JSON->decode(q/{\"foo\": undefined, \"bar\": null}/)\n","out":"ERROR: object is not of type Cpanel::JSON::XS at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: malformed JSON string, neither tag, array, object, number, string or atom, at character offset 8 (before \"undefined, \"bar\": nu...\") at (eval 558) line 1, <STDIN> line 1.\n","code":"use JSON::MaybeXS; JSON->new()->decode(q/{\"foo\": undefined, \"bar\": null}/)\n"},{"err":"","out":"","code":"use strict; my @foo; my $x = $foo[1];\n"},{"out":"[1]","err":"Argument \"bar\" isn't numeric in array element at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my @x; $x['bar'] = 1; [@x]\n"},{"err":"","out":"ERROR: Unrecognized character \\x{37e}; marked by <-- HERE after e utf8; *\"<-- HERE near column 103 at (eval 558) line 1, <STDIN> line 1.\n","code":"use utf8; *\"Í¾\" = {\"Hello World\"};\n"},{"err":"","out":"ERROR: Unrecognized character \\x{1f62b}; marked by <-- HERE after utf8; my $<-- HERE near column 105 at (eval 558) line 1, <STDIN> line 1.\n","code":"use utf8; my $ð«=\"hi\";\n"},{"code":"use utf8; print qÍ¾This is a test;;\n","out":"ERROR: Can't find string terminator \"ÃÂ\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Unrecognized character \\x{37e}; marked by <-- HERE after se utf8; *<-- HERE near column 102 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use utf8; *Í¾ = sub {\"Hello World\"};\n"},{"out":"ERROR: Illegal declaration of anonymous subroutine at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use utf8; sub Í¾ {\"Hello World\"};\n"},{"code":"$^V\n","out":"bless( {qv => 1,version => [5,22,1],original => \"v5.22.1\"}, 'version' )","err":""},{"code":"$^V - 10\n","out":"ERROR: operation not supported with version object at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"\"â-\\x{0305}1 2Â³ âÏ and it was really strange\"\n","err":"","out":"ÃÂÃÂ¢ÃÂÃÂÃÂÃÂ-ÃÂÃÂ1 2ÃÂÃÂÃÂÃÂ³ ÃÂÃÂ¢ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ and it was really strange"},{"code":"\"â-\\x{0305}1\\x{0305} 2Â³ âÏ and it was really strange\"\n","out":"ÃÂÃÂ¢ÃÂÃÂÃÂÃÂ-ÃÂÃÂ1ÃÂÃÂ 2ÃÂÃÂÃÂÃÂ³ ÃÂÃÂ¢ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ and it was really strange","err":""},{"out":"ÃÂÃÂ¢ÃÂÃÂÃÂÃÂ-ÃÂÃÂ1 2ÃÂÃÂÃÂÃÂ³ ÃÂÃÂ¢ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ and it was really strange","err":"","code":"\"â-\\x{035E}1 2Â³ âÏ and it was really strange\"\n"},{"out":"ÃÂ¢ÃÂÃÂ-\u00035E1 2ÃÂÃÂ³ ÃÂ¢ÃÂÃÂÃÂÃÂ and it was really strange","err":"","code":"\"â-\\x035E1 2Â³ âÏ and it was really strange\"\n"},{"code":"\"â-\\x{203E}1 2Â³ âÏ and it was really strange\"\n","out":"ÃÂÃÂ¢ÃÂÃÂÃÂÃÂ-ÃÂ¢ÃÂÃÂ¾1 2ÃÂÃÂÃÂÃÂ³ ÃÂÃÂ¢ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ and it was really strange","err":""},{"out":"ÃÂÃÂ¢ÃÂÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂÃÂ1ÃÂÃÂ 2ÃÂÃÂÃÂÃÂ³ ÃÂÃÂ¢ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ and it was really strange","err":"","code":"\"â\\x{2212}\\x{0305}1\\x{0305} 2Â³ âÏ and it was really strange\"\n"},{"err":"","out":"ÃÂ","code":"\"\\x85\"\n"}],"evals/evals-freenode-#perlcafe.lst":[{"out":"ERROR: Incomplete expression within '(?[ ])' in regex; marked by <-- HERE in m/(?[()-! <-- HERE ])/ at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"/(?[()-!])/\n"},{"err":"","out":"[8]","code":"[0b1010 & 0b1000]\n"},{"code":"[0b11111100000]\n","out":"[2016]","err":""},{"err":"","out":"42.5833333333333","code":"1022/24\n"},{"out":"4.880859375","err":"","code":"(188982-183984)/1024\n"},{"code":"[20+4]\n","err":"","out":"[24]"},{"out":"[11]","err":"","code":"[5+6]\n"},{"err":"","out":"","code":"BEGIN(){i or$[}\n"},{"err":"","out":"","code":"eval 'BEGIN(){i or$[}'\n"},{"code":"eval 'BEGIN(){i or$[}'; [5+6]\n","err":"","out":"[11]"},{"code":"[grep {/Trig/} keys %INC]\n","err":"","out":"[]"},{"code":"($inf, $neginf, $nan) = (9**9**9, -9**9**9, -sin(9**9**9)); use List::Util qw/max/; max(1.0, $nan)\n","out":"NaN","err":""},{"err":"","out":"1","code":"($inf, $neginf, $nan) = (9**9**9, -9**9**9, -sin(9**9**9)); use List::Util qw/max/; max($nan, 1.0)\n"},{"code":"[map {$_->[1] * 2 ** (32-$_->[0])} ([11, 1], [21, 2], [22, 4], [23, 127], [24, 479])]\n","out":"[2097152,4096,4096,65024,122624]","err":""},{"out":"This is my line.","err":"","code":"my $line = \"This is my line.\"; $line;\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"$string ~\"\n","code":"my $string = 'I<Literature|^hardcover^>'; if ($string ~= /I\\<(.+)\\|(.+)\\>/) { \"<i $2>$1</i>\"} else { \"fail\" }\n"},{"err":"","out":"<i ^hardcover^>Literature</i>","code":"my $string = 'I<Literature|^hardcover^>'; if ($string =~ /I\\<(.+)\\|(.+)\\>/) { \"<i $2>$1</i>\"} else { \"fail\" }\n"},{"code":"my $string = 'I<Literature|^hardcover^> Other text'; $string =~ /I\\<(.+)\\|(.+)\\>/<i $2>$1<\\/i>/; $string;\n","out":"ERROR: syntax error at (eval 558) line 1, near \"$2>\"\n","err":""},{"code":"my $string = 'I<Literature|^hardcover^> Other text'; $string =~ /I\\<(.+)\\|(.+)\\>/<i $2\\>$1<\\/i>/; $string;\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"\\>\"\n"},{"code":"my $x = [{z => \\{foo=>1}]; $x;\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"}]\"\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n"},{"code":"my $x = [{z => \\{foo=>1}}]; $x;\n","err":"","out":"[{z => \\{foo => 1}}]"},{"code":"my $x = [{z => \\{foo=>1}}]; $x->[0]{z}->$*;\n","err":"","out":"{foo => 1}"},{"code":"pack('V' . 99999990);\n","err":"Out of memory!\npanic: fold_constants JMPENV_PUSH returned 2 at /home/ryan/bots/perlbuut/lib/eval.pl line 301, <STDIN> line 1.\n","out":""},{"code":"say \"Hello libreman.\"\n","err":"","out":"Hello libreman.\n"},{"code":"tan(0)\n","out":"0","err":""},{"code":"use experimental 'signatures'; sub rindolf($message) {print \"There's a message for you sire: \", $message}; rindolf(\"HI!\");\n","out":"There's a message for you sire: HI!","err":""},{"out":"2292992","err":"","code":"use List::Util qw/reduce/; reduce {$a + $b} map {$_->[1] * 2 ** (32-$_->[0])} ([11, 1], [21, 2], [22, 4], [23, 127], [24, 479])\n"},{"err":"","out":"ERROR: Can't locate List/Utils.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use List::Utils qw/reduce/; reduce {$a + $b} map {$_->[1] * 2 ** (32-$_->[0])} ([11, 1], [21, 2], [22, 4], [23, 127], [24, 479])\n"},{"out":"ERROR: cot is not a valid POSIX macro at (eval 558) line 1\n","err":"","code":"use POSIX; [POSIX::cot(0)]\n"},{"code":"use POSIX; [POSIX::tan(0)]\n","err":"","out":"[0]"},{"err":"","out":"Hello world\n","code":"use strict; use warnings; my $sub = sub { print \"Hello world\\n\" }; &$sub;\n"},{"err":"","out":"sub { \"DUMMY\" }","code":"use strict; use warnings; my $sub = sub { print 'Hello world'; }; $sub;\n"},{"code":"$^V;\n","err":"","out":"bless( {qv => 1,version => [5,22,1],original => \"v5.22.1\"}, 'version' )"},{"out":"ERROR: Segmentation Fault\n","err":"","code":"$x[()[()]]\n"}],"evals/evals-magnet-#perl.lst":[{"out":"1","err":"","code":"$.\n"},{"out":"30118","err":"","code":"$$\n"},{"err":"","out":"0","code":"0 && 1\n"},{"code":"$_ = '02 Maria';  my ( $n, $name ) = split ' '; my %h; push @{ $h{ $n } }, $name; \\%h\n","out":"{\"02\" => [\"Maria\"]}","err":""},{"code":"[0b00, 0b11, 0b01, 0b10]\n","out":"[0,3,1,2]","err":""},{"err":"","out":"0","code":"0 && print \"foo\"\n"},{"code":"[1]\n","err":"","out":"[1]"},{"out":"1e+20","err":"","code":"10**20\n"},{"err":"","out":"2","code":"1 + 1\n"},{"code":"11+16\n","err":"","out":"27"},{"out":"5676","err":"","code":"12*473\n"},{"out":"1496.25","err":"","code":"1995 * .75\n"},{"err":"","out":"[1,\"\"]","code":"@_=(1); [ defined(1), defined(shift) ]\n"},{"err":"","out":"NaN","code":"1+nan\n"},{"code":"@_ = (1); print 'YES' if( shift == undef )\n","err":"","out":"YES"},{"code":" 2 * @\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n"},{"out":"4","err":"","code":" 2 * 2\n"},{"err":"","out":"1.83333333333333","code":"220/8*4/60\n"},{"code":"2 ** 3\n","out":"8","err":""},{"code":"(2**32)/92682\n","out":"46340.9000237371","err":""},{"code":"[ 2.5 * 6 ];\n","out":"[15]","err":""},{"err":"","out":"","code":"2 == ('a','b')\n"},{"err":"","out":"1","code":"2 == @{['a','b']}\n"},{"code":"(3/2)*(3/2)*(19/16)*(271/512)\n","out":"1.41421508789062","err":""},{"err":"","out":"1.26818351361432","code":"34/26.81\n"},{"err":"","out":"227.04","code":"473*12*.04\n"},{"err":"","out":"7568","code":"473*16\n"},{"err":"","out":"6.2375","code":"499/80\n"},{"code":"6/16\n","err":"","out":"0.375"},{"err":"","out":"[]","code":" $_ = \"a[b]\"; [ \"a[b]\" =~ /$_/ ]\n"},{"code":" $_ = \"a[b]\"; [ \"a[b]\" =~ /\\Q$_\\E/ ]\n","err":"","out":"[1]"},{"code":"@ARGV = \"hello\"; [ shift ]\n","err":"","out":"[\"hello\"]"},{"err":"","out":"","code":"a..z\n"},{"out":"Ã¢ÂÂ­JÃ¢ÂÂ®,Ã¢ÂÂ­uÃ¢ÂÂ®rÃ¢ÂÂ­sÃ¢ÂÂ®eÃ¢ÂÂ­tÃ¢ÂÂ®kÃ¢ÂÂ­ Ã¢ÂÂ®cÃ¢ÂÂ­aÃ¢ÂÂ®aÃ¢ÂÂ­nÃ¢ÂÂ®HÃ¢ÂÂ­oÃ¢ÂÂ® Ã¢ÂÂ­tÃ¢ÂÂ®IÃ¢ÂÂ­hÃ¢ÂÂ®DÃ¢ÂÂ­eÃ¢ÂÂ®IÃ¢ÂÂ­rÃ¢ÂÂ®BÃ¢ÂÂ­ Ã¢ÂÂ®/Ã¢ÂÂ­PÃ¢ÂÂ®lÃ¢ÂÂ­eÃ¢ÂÂ®r","err":"","code":"binmode STDOUT; $_ = \"Just another Perl/BIDI Hacker,\"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/; # does this show up right for everyone?\n"},{"code":"binmode STDOUT; 'Unicode can be confusing,' =~ tr[\\x20-\\x7f][\\x{3000}\\x{ff01}-\\x{ff5f}]r; # tr is better\n","err":"","out":"Ã¯Â¼ÂµÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ£ÂÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ£ÂÂÃ¯Â½ÂÃ¯Â½ÂÃ£ÂÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼Â"},{"code":"binmode \\*STDOUT, ':utf8'; print v3232.95.3232\n","err":"","out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ "},{"code":"binmode STDOUT ':utf8'; print v3232.95.3232\n","err":"","out":"ERROR: Missing comma after first argument to binmode function at (eval 558) line 1, at EOF\n"},{"err":"","out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ ","code":"binmode(STDOUT, ':utf8'); print v3232.95.3232\n"},{"code":"binmode \\*STDOUT, ':utf8'; say v3232.95.3232\n","out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ \n","err":""},{"code":"binmode \\&STDOUT, ':utf8'; say v3232.95.3232\n","err":"","out":"ERROR: Not a GLOB reference at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"binmode STDOUT; v3232.95.3232\n","out":"Ã Â²Â _Ã Â²Â ","err":""},{"code":"$code\n","out":"use 5.022001; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; $code","err":""},{"code":"$code =~ s/[^\\$]*\\$/\\$/r;\n","err":"","out":"$code =~ s/[^\\$]*\\$/\\$/r;"},{"out":"0","err":"","code":"do{...;\"abc\"} if 0;\n"},{"code":"do{...;\"abc\"} if 1;\n","err":"","out":"ERROR: Unimplemented at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"$equation","err":"","code":"'$equation'\n"},{"err":"","out":"1","code":"'example@gmail.com' =~ m/[a-z0-9A-Z-_]+\\@[a-z0-9A-Z-_]+\\./\n"},{"out":"1","err":"","code":"\"fmekmftestdwadwad\" =~ m/test/i\n"},{"code":"\"fmekmftestdwadwad\" =~ m/tesT/i\n","err":"","out":"1"},{"code":"\"fmekmftestdwadwad\" =~ /tesT/i # \"m\" is optional with standard / / delimiters\n","err":"","out":"1"},{"code":"'fnnny' =~ s/nn(?!n)/tt/r\n","out":"fntty","err":""},{"err":"","out":"foo","code":"'foo'\n"},{"err":"","out":"1","code":"'foo&amp;bar' =~ /&amp;/;\n"},{"out":"foo foo","err":"","code":"'foo bar' =~ s/(foo) bar/$1 $1/r\n"},{"out":"","err":"","code":"'&foo' =~ /\\b&foo/;\n"},{"code":"'&foo' =~ /&\\bfoo/;\n","out":"1","err":""},{"out":"[[[use 5.022001; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; for $$code (sub { print 'ok' }) { print \"[[[$code]]]\" }]]]","err":"","code":"for $$code (sub { print 'ok' }) { print \"[[[$code]]]\" }\n"},{"code":"$_++ for map $_, qw(hobbs mst)\n","err":"","out":""},{"out":"x is wrongx is wrong","err":"","code":"for \\my @foo (['foo', 'foo'], ['foo', 'bar'], ['bar', 'foo'], ['bar', 'bar']) { my $correct = ($foo[0] ne 'foo' && $foo[1] ne 'foo');  my $x = !($foo[0] eq 'foo' && $foo[1] eq 'foo'); my $y = !($foo[0] eq 'foo' || $foo[1] eq 'foo');  print $correct == $x ? '' : 'x is wrong'; print $correct == $y ? '' : 'y is wrong'; }\n"},{"out":"[undef]","err":"","code":"@_ = \"hello\"; [ shift ]\n"},{"code":"%h = (   foo => \"bar\",  bar => [ \"baz\" ],  argle => { \"blargle\" => \"blop\" } ); print %h\n","err":"","out":"argleHASH(0x4e9a080)barARRAY(0x4e9a128)foobar"},{"err":"","out":"$VAR1 = {\n          'foo' => 'bar',\n          'argle' => {\n                       'blargle' => 'blop'\n                     },\n          'bar' => [\n                     'baz'\n                   ]\n        };\n","code":"%h = (   foo => \"bar\",  bar => [ \"baz\" ],  argle => { \"blargle\" => \"blop\" } ); use Data::Dumper; print Dumper \\%h\n"},{"err":"","out":"$VAR1 = 'argle';\n$VAR2 = {\n          'blargle' => 'blop'\n        };\n$VAR3 = 'bar';\n$VAR4 = [\n          'baz'\n        ];\n$VAR5 = 'foo';\n$VAR6 = 'bar';\n","code":"%h = (   foo => \"bar\",  bar => [ \"baz\" ],  argle => { \"blargle\" => \"blop\" } ); use Data::Dumper; print Dumper %h\n"},{"code":"if (rand) {{ say 1; next; say 2 }} say 3;\n","out":"1\n3\n","err":""},{"err":"","out":"2","code":"index \"banana\", \"na\", -2\n"},{"out":"BCDEFGHIJKLMNOPQRSTUVWXYZ[","err":"","code":"join('','A'..'Z') =~ s/(.)/chr(ord($1)+1)/ger\n"},{"out":"STFU","err":"","code":"join\"\",map uc,map$_ eq\"i\"?\"u\":$_,(\"fist\"=~/./sg)[2,3,0,1] or \"Show Them Fury Unleashed\" or St. Thomas Franciscan University or shut the fuck up or subsiste sermonem statim\n"},{"code":"kill 19, getppid\n","out":"0","err":""},{"code":"length sprintf \"%b\", ~0\n","out":"64","err":""},{"err":"","out":"","code":"`ls`\n"},{"code":"[ map prototype(\"CORE::$_\"), qw(sysopen truncate) ]\n","err":"","out":"[\"*\\$\\$;\\$\",\"\\$\\$\"]"},{"out":"","err":"","code":"$memper = '60.1'; if ( int $memper > 90 ) { print \"int($memper) is more than 90\"  }\n"},{"code":"$memper = 60.1; if ( int $memper > 90 ) { print \"int($memper) is more than 90\"  }\n","out":"","err":""},{"out":"[\"1234567890abcdefghij1234567890\",\"1234567890bcdefghijk1234567890\",\"1234567890klmnopqrst1234567890\"]","err":"","code":"my @array = (\"1234567890abcdefghij1234567890\", \"1234567890klmnopqrst1234567890\", \"1234567890bcdefghijk1234567890\");    my @sorted = sort { substr($a, 9, 10) cmp substr($b, 9, 10) } @array;  [ @sorted ] # seems to work for me\n"},{"err":"","out":"","code":"my $a = sub{ shift == undef }; print \"YES\" if $a->( 1 );\n"},{"err":"","out":"YES","code":"my $a = sub{ shift == undef }; print \"YES\" if $a->( 'AF' );\n"},{"code":"my $copy; for my $foo (1) { $copy = $foo } [$copy]\n","err":"","out":"[1]"},{"out":"ERROR: Can't localize through a reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $foo = 42; my $bar = \\$foo; local $$bar = 53;\n"},{"code":"my $foo; for  $foo (1) { $copy = $foo } [$foo]\n","out":"[undef]","err":""},{"code":"my $foo; for $foo (1) { ''; } [$foo]\n","out":"[undef]","err":""},{"err":"","out":"[]","code":"my @foo; local $foo[0] = 1; \\@foo;\n"},{"code":"my $foo = \"wi(bb)le\"; qr/\\Q$foo\\E/\n","out":"qr/wi\\(bb\\)le/u","err":""},{"code":"my $hack_int = 42; [ !!( $hack_int ^ $hack_int ) ]\n","out":"[\"\"]","err":""},{"code":"my $hack_int = 42; \"$hack_int\"; [ !!( $hack_int ^ $hack_int ) ]\n","err":"","out":"[\"\"]"},{"out":"[1]","err":"","code":"my $hack_str = \"42\"; [ !!( $hack_str ^ $hack_str ) ]\n"},{"out":"[\"Gwgh\"]","err":"","code":"my %h = ( A => q(W), a => q(w), B => q(G), b => q(g), y => q(h) ); [join q(), map { $h{$_} } split //, q(Baby)]\n"},{"code":"my %h = (a..z)\n","out":"26","err":""},{"code":"my %h = a..z\n","err":"","out":"26"},{"out":"","err":"","code":"my %h = (a..z); ${%h}\n"},{"err":"","out":"{\"how strange\" => \"is this, anyway?\"}","code":"my %h = ('a'..'z'); ${%h}{\"how strange\"} = \"is this, anyway?\"; \\%{%h};\n"},{"code":"my %h = (a..z); ${%h}{\"how strange\"} = \"is this, anyway?\"; \\%{%h};\n","err":"","out":"{\"how strange\" => \"is this, anyway?\"}"},{"err":"","out":"[\"baz\",\"foo\",\"bar\"]","code":" my $h = {\"foo\" => 5, \"bar\" => 6, \"baz\" => 2}; [ sort { $h->{$a} <=> $h->{$b} } keys %$h ]\n"},{"code":" my $h = {\"foo\" => 5, \"bar\" => 6, \"baz\" => 2}; [ sort keys %$h ]\n","err":"","out":"[\"bar\",\"baz\",\"foo\"]"},{"err":"HASH(0x5d27e48) at (eval 558) line 1, <STDIN> line 1.\n","out":"1","code":"my $h = {}; undef( %$h ); warn $h\n"},{"err":"","out":"Zoffix is awesome!","code":"my %map = map +( $_ => chr(ord()+1) ), 'A'..'Z', 'a'..'z'; @map{qw/A a Z z/} = qw/Z z A a/; my $encoded = 'Aneehw hr zvdrnld!'; $encoded =~ s#(.)#$map{$1} // $1#ge; $encoded\n"},{"code":"my @names=[\"Bill\", \"Smith\", \"John\", \"Jane\"]; [$names[0][0]]\n","out":"[\"Bill\"]","err":""},{"out":"[[1,2,3,4,5,6,7,8,9,10]]","err":"","code":"my @nums = 1..10; [\\@nums]\n"},{"code":"my @nums = 1..10; [$nums[0]]\n","out":"[1]","err":""},{"err":"","out":"NO","code":"my $s = sub{wantarray?'YES':'NO'}; $z='a'; my( $fh ) =  $s->()  ||  $s->(); print $fh;\n"},{"code":"my $s = sub{wantarray?'YES':'NO'}; $z='a'; my( $fh ) =  $z =~/^(\\d+)$/  ||  $s->(); print $fh;\n","err":"","out":"YES"},{"err":"","out":"[\"asdf\"]","code":"my $str = \"asdf\"; open(my $fh, \"+<\", \\$str) or die \"open: $!\"; [ <$fh> ]\n"},{"out":"foo","err":"","code":"my $str = \"foo\"; open my $fh, '<', \\$str; <$fh>\n"},{"code":"my $str = \"\\x{2603}\"; $fh = IO::String->new($str) or die \"new: $!\"; [ <$fh> ]\n","err":"","out":"[\"\\x{2603}\"]"},{"code":"my $str = \"\\x{2603}\"; open(my $fh, \"+<\", \\$str) or die \"open: $!\"; [ <$fh> ]\n","err":"","out":"ERROR: open: Invalid argument at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"my $test_link = \"http://zombo.com/\"; my $re = q`(?^:[a-zA-Z][a-zA-Z0-9\\+]*):[\\;\\/\\?\\\\@\\&\\=\\+\\$\\,\\[\\]\\p{isAlpha}A-Za-z0-9\\-_\\.\\!\\~\\*\\'\\(\\)%][\\|\\;\\/\\?\\:\\@\\&\\=\\+\\$\\,\\[\\]\\p{isAlpha}A-Za-z0-9\\-_\\.\\!\\~\\*\\'\\(\\)%#]*`; $test_link =~ /$re/g && warn 1; $test_link =~ /$re/g && warn 2; \n","err":"1 at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"out":"sub { \"DUMMY\" }","err":"","code":"my $test = sub { say 'ran it' }; my $foo = \\&$test;\n"},{"out":"ran it\n","err":"","code":"my $test = sub { say 'ran it' }; my $foo = &$test;\n"},{"code":"my $t = v3232.95.3232;  [map ord, split //, $t]\n","err":"","out":"[3232,95,3232]"},{"err":"","out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ ","code":"my $t = v3232.95.3232; utf8::decode($t); $t\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"// 4\"\n","err":"","code":"my $t = v3232.95.3232; utf8::downgrade($t); [map ord, split // 4t]\n"},{"out":"ERROR: Wide character in subroutine entry at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $t = v3232.95.3232; utf8::downgrade($t); [map ord, split //, $t]\n"},{"out":"ERROR: Wide character in subroutine entry at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $t = v3232.95.3232; utf8::downgrade($t); $t\n"},{"code":"my $t = v3232.95.3232;  utf8::encode($t); binmode STDOUT; $t\n","err":"","out":"Ã Â²Â _Ã Â²Â "},{"code":"my $t = v3232.95.3232;  utf8::encode($t); binmode STDOUT, \":utf8\"; $t\n","err":"","out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ "},{"err":"","out":"[224,178,160,95,224,178,160]","code":"my $t = v3232.95.3232;  utf8::encode($t); [map ord, split //, $t]\n"},{"err":"","out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ ","code":"my $t = v3232.95.3232; utf8::encode($t); $t\n"},{"code":"my $t = v3232.95.3232; utf::downgrade($t); $t\n","out":"ERROR: Undefined subroutine &utf::downgrade called at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"my $t = v3232.95.3232; utf::encode($t); $t\n","err":"","out":"ERROR: Undefined subroutine &utf::encode called at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":" 1 2 3 4  camel snake hummingbird hamster ","code":"my %unstricthash = ( a => [ qw / 1 2 3 4 /] , b => [ qw/ camel snake  hummingbird hamster/ ]) ; for ( %unstricthash ) {  print  \" @{ $_ } \"  if (@{ $_ } )  }  ;\n"},{"code":"my $w = 'The'; my @r = \"The\\nend\" =~ /$w$end/msg; @r;\n","err":"","out":"1"},{"code":"my $w = 'The'; my @r = \"The\\nend\" =~ /$w$end/msg; \\@r\n","out":"[\"The\"]","err":""},{"code":"my $w = 'The'; \"The\\nend\" =~ /$w$end/msg;\n","out":"1","err":""},{"err":"","out":"1","code":"my $w = 'The'; (\"The\\nend\" =~ /$w$end/msg);\n"},{"err":"","out":"35\n","code":"my $x = [1..10]; say $x->@[2,4]\n"},{"code":"my $x = \"lex\"; eval 'say $x'\n","out":"lex\n","err":""},{"err":"","out":"80","code":"    $     OMG     =     8_0;    $                 OMG\n"},{"out":"4","err":"","code":"package Foo { sub index { ... } index('aaaao', 'o'); }\n"},{"code":"package Foo; use strict; use warnings; our $VERSION = 'blah'; package main; say Foo->VERSION\n","out":"ERROR: Invalid version format (non-numeric data) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"package loose; sub import { shift; strict->unimport(@_) }; sub unimport { shift; strict->import(@_) }\n","err":"","out":""},{"code":"[pack 'NI', 12345, 12345]\n","err":"","out":"[\"\\0\\0000990\\0\\0\"]"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"perl -e \"\n","code":"perl -e 'warn hey { \"wtf\" }'\n"},{"err":"","out":"1","code":"'Please identify via /msg NickServ identify <password>.' =~ /^(?:If this is your nickname, type|Please identify via|Type) \\/msg NickServ identify/\n"},{"code":"print $code\n","out":"use 5.022001; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; print $code","err":""},{"code":"print\"F\"x!($_%3).b x!($_%5)||$_ for 1..32\n","err":"","out":"12F4bF78Fb11F1314Fb1617F19bF2223Fb26F2829Fb3132"},{"code":"print \"hi\"\n","out":"hi","err":""},{"code":"print \"I'm a Perl \", 5 + !!\"0\", \" program.\"\n","out":"I'm a Perl 5 program.","err":""},{"err":"","out":"Just another Sort hacker,","code":"print sort { $|-- or -1 } 'ruJt tc,en hoetokarrasS h' =~ /./g\n"},{"out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ ","err":"","code":"print v3232.95.3232\n"},{"code":"print 'YES'  if( 1 == undef ) \n","out":"","err":""},{"code":"({qw/ a 1 b 2/})->{b} # kes\n","out":"2","err":""},{"code":"qw/BuildBot, Tinderbox, Hudson, Jenkins, TeamCity, Bamboo/[rand]\n","out":"BuildBot,","err":""},{"out":"take_a_cab","err":"","code":"qw/dial_a_bottle  take_a_cab/[rand 2]\n"},{"code":"qw (foo bar);\n","err":"","out":"bar"},{"code":"qw ÌyoÌ\n","out":"ERROR: Unrecognized character \\x81; marked by <-- HERE after ; qw ÃÂÃÂyoÃÂ<-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"rindex \"banana\", \"na\"\n","err":"","out":"4"},{"err":"","out":"30656\n","code":"say $$\n"},{"code":"say 0xFFFFFFFFFFFFFFFFF\n","out":"2.95147905179353e+20\n","err":""},{"code":"say 1 + 1\n","out":"2\n","err":""},{"err":"","out":"ERROR: Unrecognized character \\xE0; marked by <-- HERE after res/; say <-- HERE near column 95 at (eval 558) line 1, <STDIN> line 1.\n","code":"say à¼¡ + à¼¢\n"},{"code":"say âÂ²\n","err":"","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after res/; say <-- HERE near column 95 at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"\n","err":"","code":"say `ps ax`\n"},{"err":"","out":"ERROR: Unrecognized character \\x80; marked by <-- HERE after ay qÃÂ¢ÃÂÃÂ42ÃÂ¢<-- HERE near column 102 at (eval 558) line 1, <STDIN> line 1.\n","code":"say qâ42â;\n"},{"code":"say $^V\n","err":"","out":"v5.22.1\n"},{"code":"scalar ('a','b')\n","out":"b","err":""},{"code":"sprintf \"%08b\", 0x36\n","out":"00110110","err":""},{"out":"0.075000000000000011","err":"","code":"sprintf '%.18f', .025 + .05\n"},{"code":"sprintf '%.18f', .075\n","err":"","out":"0.074999999999999997"},{"code":"sprintf \"%b\", 0x36\n","err":"","out":"110110"},{"out":"1.4142135623731","err":"","code":"sqrt(2)\n"},{"code":"sqrt(2)*(2 ** 16)\n","err":"","out":"92681.9000236832"},{"code":"*STDOUT{IO}\n","err":"cannot handle ref type 15 at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/Data/Dumper.pm line 231, <STDIN> line 1.\n","out":"bless( , 'IO::File' )"},{"err":"","out":"2 00\n","code":"$str = '2 floor'; $str =~ s/([0-9]*)\\bFlo*r/${1}00/i; say $str\n"},{"code":"$str = '2 floor'; $str =~ s/([0-9]*)( +Flo*r)/${1}00$2/i; say $str\n","err":"","out":"200 floor\n"},{"err":"","out":"200\n","code":"$str = '2 floor'; $str =~ s/([0-9]*) +Flo*r/${1}00/i; say $str\n"},{"code":"s TT$ Donald Trump\n","err":"","out":" "},{"code":"sub foo { \"bar\" }; goto +foo; print \"foo\"; bar: print \"bar\"\n","err":"","out":"bar"},{"err":"","out":"bar\n","code":"sub foo { \"bar\" }; goto +foo; say \"foo\"; bar: say \"bar\"\n"},{"err":"","out":"foo calledERROR: Can't locate object method \"TIESCALAR\" via package \"main\" at (eval 558) line 1, <STDIN> line 1.\n","code":"sub foo :lvalue { print \"foo called\"; $tmp }; tie &foo, \"main\";\n"},{"code":"sub foo { my $bar = \\@_; $bar->[0] = 'abc'; 'def' }; my $quux = 42; foo($quux); $quux;\n","out":"abc","err":""},{"code":"sub foo { my $bar = \\@_; local $_[0] = 'abc'; 'def' }; my $quux = 42; foo($quux); $quux;\n","out":"42","err":""},{"out":"42","err":"","code":"sub foo { my $bar = \\@_; local $bar->[0] = 'abc'; 'def' }; my $quux = 42; foo($quux); $quux;\n"},{"out":"[[0,0,0],3]","err":"","code":"sub foo { my @x = (0,0,0); @x } [ [foo()], scalar foo() ]\n"},{"out":"Just another Perl hacker, ","err":"","code":"sub hacker'Perl{\"Perl @_,\"}sub another'Just{\"Just @_ \"}     Just another Perl hacker, \n"},{"out":"[[1,1,1],[\"\",1,\"\"],[\"\",\"\",\"\"],[\"\",1,\"\"]]","err":"","code":"sub o { (!$_[0]) && (!$_[1]) } sub j { !( $_[0] && $_[1] ) }  sub p { !($_[0] || $_[1]) } [ map [o($_->[0], $_->[1]), j($_->[0], $_->[1]), p($_->[0], $_->[1])], [0, 0], [1, 0], [1, 1], [0, 1] ]\n"},{"code":"substr(\"banana\", -2) =~ /na/\n","out":"1","err":""},{"err":"","out":"sub { \"DUMMY\" }","code":"sub test { say 'ran it' }; my $test = *test; my $foo = \\&$test;\n"},{"out":"ran it\n","err":"","code":"sub test { say 'ran it' }; my $test = *test; ( \\&$test ) -> ();\n"},{"code":"sub TIEHANDLE { [] }; sub READLINE { \"asdf\" }; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ scalar readline FH ];\n","err":"","out":"[undef]"},{"code":"use bigint; my ($k, $c) = (\"3\", \"37\"); say ((($k+0)**($c+0))-1);\n","out":"450283905890997362\n","err":""},{"code":"use bigint; my ($k, $c) = (\"3\", \"37\"); say (($k**$c)-1);\n","err":"","out":"450283905890996999\n"},{"err":"","out":"450283905890997362\n","code":"use bigint; my ($k, $c) = (3, 37); say (($k**$c)-1);\n"},{"code":"use bigint; print 11**20;\n","out":"672749994932560009201","err":""},{"out":"9","err":"","code":"use experimental 'postderef'; my $z =[ 1..10]; $z->$#* # or this\n"},{"err":"given is experimental at (eval 558) line 1, <STDIN> line 1.\nwhen is experimental at (eval 558) line 1, <STDIN> line 1.\n","out":"ok","code":"use experimental 'switch'; use warnings; given (1) { when (1) { print \"ok\"; } }\n"},{"code":"use feature 'refaliasing'; my @a = (1, 2, 3); \\my (@b) = \\(@a); @b[2] = 5; [@a];\n","err":"","out":"[1,2,5]"},{"out":"[1,2,5]","err":"","code":"use feature 'refaliasing'; my @a = (1, 2, 3); \\my (@b) = \\(@a); @b[2] = 5; shift @b; [@a];\n"},{"err":"","out":"[2,5]","code":"use feature 'refaliasing'; my @a = (1, 2, 3); \\my @b = \\@a; @b[2] = 5; shift @b; [@a];\n"},{"code":"use feature 'refaliasing'; my @a = (1, 2, 3); \\my (@b) = \\(@a); @b[2] = 5; shift @b; [@b];\n","err":"","out":"[2,5]"},{"err":"","out":"[[1,2,3]]","code":"use feature 'refaliasing'; my $zoit = [1 .. 3]; \\my $narf = \\$zoit; [ $narf ]\n"},{"out":"REF(0x5107528)\n","err":"","code":"use feature 'refaliasing'; my $zoit = [1 .. 3]; my $narf = \\$zoit; say $narf;\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"my \\\"\n","err":"","code":"use feature 'refaliasing'; my $zoit = [1 .. 3]; my \\$narf = \\$zoit; say $narf;\n"},{"code":"use integer; my $x; for $x (1 .. 10 ) { say $x; }\n","out":"1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n","err":""},{"err":"","out":"{foo => [\"foo\",\"oof\"],abz => [\"baz\",\"bza\"],abr => [\"bar\"]}","code":"use List::Util qw(reduce); reduce { my $key = join '', sort split '', $b; +{ %$a, $key => [ @{$a->{$key}||[]}, $b ] } } {}, qw(foo oof bar baz bza)\n"},{"out":"ERROR: Can't locate List/Utils.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use List::Utils qw(reduce); reduce { my $key = join '', sort split '', $b; +{ %$a, $key => [ @{$a->{$key}||[]}, $b ] } } {}, qw(foo oof bar baz bza)\n"},{"err":"","out":"ERROR: Can't locate open.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use open qw(:std utf8); say v3232.95.3232\n"},{"out":"42","err":"","code":"use overload '&{}' => sub { sub { 42 } }; (bless [])->();\n"},{"out":"ERROR: Operation \"\"\"\": no method found, argument in overloaded package main at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use overload '&{}' => sub { sub { 42 } }; my $foo = bless []; my $bar = bless [], 'baz'; [ $bar->$foo ]\n"},{"out":"ERROR: Can't locate object method \"main=ARRAY(0x5af9cd8)\" via package \"baz\" at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use overload '&{}' => sub { sub { 42 } }; my $foo = bless []; my $bar = bless [], 'baz'; no overloading; [ $bar->$foo ]\n"},{"out":"1\n","err":"","code":"use strict; my $foo  = () = 3; say $foo;\n"},{"code":"use strict; my( $foo ) = () = 3; say $foo;\n","out":"\n","err":""},{"err":"","out":"ERROR: Global symbol \"$bar\" requires explicit package name (did you forget to declare \"my $bar\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; my $foo = $bar = 3;\n"},{"out":"3\n","err":"","code":"use strict; my $foo = my $bar = 3; say $bar;\n"},{"err":"","out":"3\n","code":"use strict; my $foo = my $bar = 3; say $foo;\n"},{"code":"use strict; my $foo  = my( $bar ) = 3; say $foo;\n","out":"1\n","err":""},{"err":"","out":"3\n","code":"use strict; my( $foo  ) = my( $bar ) = 3; say $foo;\n"},{"code":"use strict; my $w = 'The'; my @r = \"The\\nend\" =~ /$w$(?:)end/msg; \\@r\n","out":"[]","err":""},{"err":"","out":"ERROR: Global symbol \"$end\" requires explicit package name (did you forget to declare \"my $end\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; my $w = 'The'; my @r = \"The\\nend\" =~ /$w$end/msg; \\@r\n"},{"out":"ERROR: Global symbol \"$fh\" requires explicit package name (did you forget to declare \"my $fh\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; my $z=7; my ( $fh ) =  $z =~/^(\\d+)$/  ||  $fh; print $fh;\n"},{"code":"use strict; use warnings; my $h = {\"foo\" => 5, \"bar\" => 6, \"baz\" => 2}; print Dumper(@{$h}->{qw/foo bar baz/});\n","out":"ERROR: Not an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use strict; use warnings; sub TIEHANDLE { bless [] }; sub READLINE { \"asdf\" }; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ scalar readline FH ];\n","err":"","out":"[\"asdf\"]"},{"code":"use strict; use warnings; sub TIEHANDLE { [] }; sub READLINE { \"asdf\" }; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ scalar readline FH ];\n","out":"[undef]","err":"readline() on unopened filehandle FH at (eval 558) line 1.\n"},{"code":"use ut8; sub æ¨å¥½ { say \"æ¨å¥½\" }; æ¨å¥½\n","err":"","out":"ERROR: Can't locate ut8.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"Ã¢ÂÂ¥","code":"use utf8; ${\"âº\"} = \"â¤\"; binmode STDOUT; chr 1 + ord ${\"âº\"}\n"},{"code":"use utf8; package ãã¹ã; sub new { bless {}, shift} sub ã¢ã¼ { say \"ã¢ã¼\" }; package main; ãã¹ã->new->ã¢ã¼\n","out":"ÃÂ£ÃÂÃÂ¢ÃÂ£ÃÂÃÂ¼\n","err":""},{"out":"ERROR: Can't locate object method \"new\" via package \"ÃÂ£ÃÂÃÂÃÂ£ÃÂÃÂ¹ÃÂ£ÃÂÃÂ\" at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use utf8; package ãã¹ã; sub ã¢ã¼ { say \"ã¢ã¼\" }; package main; ãã¹ã->new->ã¢ã¼\n"},{"code":"use utf8; qw ÌyoÌ\n","out":"yo","err":""},{"code":"use utf8; say à¼¡ + à¼¢\n","out":"ERROR: Unrecognized character \\x{f21}; marked by <-- HERE after utf8; say <-- HERE near column 105 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use utf8; sub æ¨å¥½ { say \"æ¨å¥½\" }; æ¨å¥½\n","out":"ÃÂ¦ÃÂÃÂ¨ÃÂ¥ÃÂ¥ÃÂ½\n","err":""},{"code":"use v5.20; say \"hi\"; state $your_business;\n","err":"","out":"hi\n"},{"out":"[\\42,0,\"\\34\",\"\"]","err":"","code":"use warnings; $^I = 42; [ \\$^I, 0, eval(\"\\$\\t;\"), $@ ]\n"},{"err":"Smartmatch is experimental at (eval 558) line 1, <STDIN> line 1.\n","out":"this matches","code":"use warnings; my @foo = 0..10; print \"this matches\" if \"0 but true\" ~~ @foo; # thanks, pink_mist++  \n"},{"err":"Scalar value @foo[0] better written as $foo[0] at (eval 558) line 1, <STDIN> line 1.\n","out":"bar","code":"use warnings; my @foo = qw/bar/; print @foo[0] # Perl911 yours will warn I expect\n"},{"code":"use warnings; package Foo; sub index { ... }  index('aaaao', 'o');\n","err":"Ambiguous call resolved as CORE::index(), qualify as such or use & at (eval 558) line 1, <STDIN> line 1.\n","out":"4"},{"code":"use warnings; package Foo; sub index :method { ... }  index('aaaao', 'o');\n","out":"4","err":""},{"out":"ok","err":"","code":"use warnings; use experimental 'switch'; given (1) { when (1) { print \"ok\"; } }\n"},{"err":"given is experimental at (eval 558) line 1, <STDIN> line 1.\nwhen is experimental at (eval 558) line 1, <STDIN> line 1.\n","out":"ok","code":"use warnings; use feature 'switch'; given (1) { when (1) { print \"ok\"; } }\n"},{"err":"","out":"[undef]","code":"use warnings; use strict; my $x; for $x (1 .. 10) { last if $x % 2 == 0; } [ $x ]\n"},{"err":"","out":"[bless( {original => \"v5.22.1\",qv => 1,version => [5,22,1]}, 'version' )]","code":"[$^V]\n"},{"code":"$^V\n","out":"bless( {original => \"v5.22.1\",qv => 1,version => [5,22,1]}, 'version' )","err":""},{"code":"v3232.95.3232\n","out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ ","err":""},{"code":"v3232.95.3232;  # This looks like Ã  Â² _ Ã  Â² \n","err":"","out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ "},{"out":"[bless( {qv => 1,version => [5,22,1],original => \"v5.22.1\"}, 'version' ),\"freebsd\",64]","err":"","code":"[$^V,$^O, log(~0+1)/log(2)]\n"},{"code":"warn hey { \"wtf\" }\n","err":"","out":"ERROR: Can't locate object method \"hey\" via package \"wtf\" (perhaps you forgot to load \"wtf\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"21","err":"","code":"$_=\"Whfg nabgure crey unpxre\"; tr/A-Za-z/N-ZA-Mn-za-m/;\n"},{"err":"","out":"42","code":"$_=\"Whfg nabgure crey unpxre\"; tr/A-Za-z/N-ZA-Mn-za-m/ * 2; \n"},{"out":"Just another perl hacker","err":"","code":"$_=\"Whfg nabgure crey unpxre\"; tr/A-Za-z/N-ZA-Mn-za-m/r; \n"},{"code":"$_=\"Whfg nabgure crey unpxre\"; tr/A-Zn-za-m/N-ZA-Ma-z/r;\n","out":"Just another perl hacker","err":""},{"out":"ERROR: Undefined format \"$stdh\" called at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"write select\n"},{"err":"","out":"/home/ryan/perl5/perlbrew/perls/perl-5.22.1/bin/perl","code":"$^X\n"},{"err":"","out":"","code":"\"\\x{02}\" =~ /\\s/\n"},{"code":"%x = ( 1 => \"a\", b => 3 ); $str = \"ab\"; print $x{ $str =~ /(.)$/ }\n","out":"a","err":""},{"err":"","out":"yes","code":"\"\\x7f\" =~ /[[:cntrl:]]/ ? \"yes\" : \"no\"\n"},{"err":"","out":"900900\n","code":"$x = 99; $x =~ s/([0-9])/${1}00/g; say $x\n"},{"out":"9009\n","err":"","code":"$x = 99; $x =~ s/([0-9])/${1}00/; say $x\n"},{"code":"\"\\x{a9}\\x{263a}\\x{2665}\"\n","err":"","out":"ÃÂÃÂ©ÃÂ¢ÃÂÃÂºÃÂ¢ÃÂÃÂ¥"},{"code":"[ '+-++-X' =~ /([+\\-](?=[+\\-]*X))/g ]\n","out":"[\"+\",\"-\",\"+\",\"+\",\"-\"]","err":""},{"out":"1","err":"","code":"$z=0; ( $fh ) =  $z =~/^(\\d+)$/  ||  $fh; print $fh;\n"},{"code":"$z=7; ( $fh ) =  $z =~/^(\\d+)$/  ||  $fh; print $fh;\n","err":"","out":"1"},{"err":"","out":"YES","code":"$z='a'; my( $fh ) =  $z =~/^(\\d+)$/  ||  sub {wantarray?'YES':'NO'}->(); print $fh;\n"},{"code":"$z='a'; my( $fh ) =  $z =~/^(\\d+)$/  ||  (wantarray?'YES':'NO'); print $fh;\n","err":"","out":"NO"},{"code":"\"Zoffix\" =~ m âzofâi ? 'yes' : 'nope'\n","err":"","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after  m ÃÂ¢ÃÂÃÂzofÃÂ¢<-- HERE near column 112 at (eval 558) line 1, <STDIN> line 1.\n"}],"evals/evals-freenode-#perlbot.lst":[{"err":"","out":"","code":"\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","code":"- -\n"},{"code":"- - ' .'\n","err":"","out":"0"},{"err":"","out":"0","code":"- - ' '\n"},{"code":"- - '-'\n","out":"-","err":""},{"out":"0","err":"","code":"- - '.'\n"},{"code":"- - '\"'\n","err":"","out":"0"},{"out":"+","err":"","code":"- - '+'\n"},{"out":"0","err":"","code":"- - 'â§'\n"},{"out":"","err":"","code":";;;;;;;;;;;;;;;;;;;\n"},{"err":"","out":"$stdh_TOP","code":"\"$^\";\n"},{"code":"()\n","out":"","err":""},{"code":"();\n","err":"","out":""},{"err":"","out":"[\"::\"]","code":"[ :: ]\n"},{"out":"[\"HASH(0x5d08498)\",\"HASH(0x5d08420)\",\"HASH(0x5d083d8)\",\"HASH(0x5d083a8)\",\"HASH(0x4b13208)\",\"HASH(0x5cf1ce8)\"]","err":"","code":"[{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',]\n"},{"code":"[{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',]\n","err":"","out":"[\"HASH(0x48e2420)\",\"HASH(0x48e23a8)\",\"HASH(0x48e2378)\",\"HASH(0x48e2318)\",\"HASH(0x36ec328)\",\"HASH(0x48cacb8)\",\"HASH(0x45f7750)\",\"HASH(0x45f7768)\",\"HASH(0x45f77c8)\",\"HASH(0x45f77b0)\",\"HASH(0x45f77f8)\",\"HASH(0x48e2528)\"]"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"\\]\"\n","err":"","code":"[{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',\\]\n"},{"out":"1","err":"","code":"@_\n"},{"code":"$^]\n","err":"","out":""},{"out":"Too many open files","err":"","code":"$!\n"},{"code":"$]\n","out":"5.022001","err":""},{"err":"","out":"[\"\\\\\\@_\"]","code":"\\@_\n"},{"err":"","out":"ERROR: Unrecognized character \\xCD; marked by <-- HERE after natures/; <-- HERE near column 91 at (eval 558) line 1, <STDIN> line 1.\n","code":"Í¾\n"},{"code":"Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾\n","err":"","out":"ERROR: Unrecognized character \\xCD; marked by <-- HERE after natures/; <-- HERE near column 91 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"0^^0\n","out":"ERROR: syntax error at (eval 558) line 1, near \"^^\"\n","err":""},{"code":"0**0\n","err":"","out":"1"},{"code":"'0.00'+0 ? 'y' : 'n'\n","err":"","out":"n"},{"code":"'000202056D4C' =~ s/..\\K\\B/:/gr\n","err":"","out":"00:02:02:05:6D:4C"},{"code":"'000202056D4C' =~ s/..\\K/:/gr\n","out":"00:02:02:05:6D:4C:","err":""},{"code":"'0.00' ? 'y' : 'n'\n","out":"y","err":""},{"out":"y","err":"","code":"'0.0'? 'y' : 'n'\n"},{"code":"0%10\n","err":"","out":"0"},{"code":"[ '010' + 0 ]\n","err":"","out":"[10]"},{"code":" \"!(0 || 1 && (0 || 0)) && !(1 && 1)\"\n","err":"","out":"!(0 || 1 && (0 || 0)) && !(1 && 1)"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","code":"((0.1 + 0.2)\n"},{"code":"((0.1 + 0.2))\n","out":"0.3","err":""},{"out":"[\"0.3\",\"n\"]","err":"","code":"[ 0.1 + 0.2, ((0.1 + 0.2) == 0.3) ? 'y' : 'n' ]\n"},{"out":"n","err":"","code":"((0.1 + 0.2) == 0.3) ? 'y' : 'n'\n"},{"out":"n","err":"","code":"0.1 + 0.2 == 0.3 ? 'y' : 'n'\n"},{"out":"64","err":"","code":"0+grep - - chr, 0..255;\n"},{"out":"53","err":"","code":"0+grep { length(- - chr) > 1 } 0..255;\n"},{"code":"[ '0x010' + 0 ]\n","err":"","out":"[0]"},{"code":"[ 0x7f - 0x20, 0xff5f - 0xff00 ];\n","err":"","out":"[95,95]"},{"out":"128","err":"","code":"0x80\n"},{"code":"0xFFF\n","out":"4095","err":""},{"code":"1\n","err":"","out":"1"},{"out":"1","err":"","code":"\"1\"\n"},{"err":"","out":"Operation not permitted","code":"$! = 1; \"$!\"\n"},{"code":"[ !1, !0, !0+0]\n","err":"","out":"[\"\",1,1]"},{"err":"","out":"[\"\",1,0]","code":"[ !1, !0, !1+0]\n"},{"err":"","out":"10000000","code":"10**length q|*******|\n"},{"err":"","out":"[\\1,\\1]","code":"[\\1, \\1]\n"},{"out":"[1111111]","err":"","code":"[ 1111111 =~ /^(1+)+$/ ];\n"},{"code":"1111111 =~ /^(1{1,10})(1{1,10})(1{1,10})(?{ push @comb, [$1, $2, $3] })(?!)/; \\@comb\n","err":"","out":"[[11111,1,1],[1111,11,1],[1111,1,11],[1111,1,1],[111,111,1],[111,11,11],[111,11,1],[111,1,111],[111,1,11],[111,1,1],[11,1111,1],[11,111,11],[11,111,1],[11,11,111],[11,11,11],[11,11,1],[11,1,1111],[11,1,111],[11,1,11],[11,1,1],[1,11111,1],[1,1111,11],[1,1111,1],[1,111,111],[1,111,11],[1,111,1],[1,11,1111],[1,11,111],[1,11,11],[1,11,1],[1,1,11111],[1,1,1111],[1,1,111],[1,1,11],[1,1,1]]"},{"code":"1111111 =~ /^(1{1,10})(1{1,10})(1{1,10})(?{ push @comb, [$1, $2, $3] })(?!)/; [map [map length, @$_], @comb]\n","out":"[[5,1,1],[4,2,1],[4,1,2],[4,1,1],[3,3,1],[3,2,2],[3,2,1],[3,1,3],[3,1,2],[3,1,1],[2,4,1],[2,3,2],[2,3,1],[2,2,3],[2,2,2],[2,2,1],[2,1,4],[2,1,3],[2,1,2],[2,1,1],[1,5,1],[1,4,2],[1,4,1],[1,3,3],[1,3,2],[1,3,1],[1,2,4],[1,2,3],[1,2,2],[1,2,1],[1,1,5],[1,1,4],[1,1,3],[1,1,2],[1,1,1]]","err":""},{"code":"1111111 =~ /^(1{1,10})(1{1,10})(1{1,10})$(?{ push @comb, [$1, $2, $3] })(?!)/; [map [map length, @$_], @comb]\n","err":"","out":"[[5,1,1],[4,2,1],[4,1,2],[3,3,1],[3,2,2],[3,1,3],[2,4,1],[2,3,2],[2,2,3],[2,1,4],[1,5,1],[1,4,2],[1,3,3],[1,2,4],[1,1,5]]"},{"out":"[[],[],[],[],[]]","err":"","code":"1111111 =~ /^((1+)(?{ local @one = @one, $1 }))+$(?{ push @comb, \\@one })(?!)/; \\@comb;\n"},{"code":"1111111 =~ /^((1+)(?{ local @one = @one, $2 }))+$(?{ push @comb, \\@one })(?!)/; \\@comb;\n","err":"","out":"[[],[],[],[],[]]"},{"code":"1111111 =~ /^((1+)(?{ local @one = @one, $2 })+$(?{ push @comb, \\@one })(?!)/; \\@comb;\n","err":"","out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/^( <-- HERE (1+)(?{ local @one = @one, $2 })+$(?{ push @comb, \\@one })(?!)/ at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"[]","err":"","code":"[ 1111111 =~ /^(<A>1+)+$/ ];\n"},{"code":"[ 1111111 =~ /^(?<A>1+)+$/ ];\n","err":"","out":"[1111111]"},{"code":"1111111 =~ /^(<A>1+)*$/;\n","out":"","err":""},{"code":"1111111 =~ /^(<A>1+)*$(?{ print 'yes'; push @comb, [@{$-{A}}] })(?!)/; \\@comb;\n","out":"[]","err":""},{"err":"","out":"yesyesyesyesyes","code":"1111111 =~ /^(?<A>1+)*$(?{ print 'yes'; push @comb, [@{$-{A}}] })(?!)/; \\@comb;\n"},{"out":"[[1111111],[1],[11],[1],[111]]","err":"","code":"1111111 =~ /^(?<A>1+)*$(?{ push @comb, [@{$-{A}}] })(?!)/; \\@comb;\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","code":"1111111 =~ /^(<A>1+)*$(?{ push @comb, [@{$-{A}}] })(?!)/ ? [map [map length, @$_], @comb] : \n"},{"err":"","out":"[]","code":"1111111 =~ /^(<A>1+)*$(?{ push @comb, [@{$-{A}}] })(?!)/; [map [map length, @$_], @comb]\n"},{"err":"","out":"no","code":"1111111 =~ /^(<A>1+)*$(?{ push @comb, [@{$-{A}}] })(?!)/ ? [map [map length, @$_], @comb] : 'no';\n"},{"err":"","out":"3","code":"1+2\n"},{"err":"","out":"match","code":"'12' =~ /1\\B2/ ? 'match' : 'nope'\n"},{"out":"[123,456,789,0,\"\"]","err":"","code":"[ '1234567890' =~ /.{0,3}/g ]\n"},{"out":"[123,456,789,0]","err":"","code":"[ '1234567890' =~ /.{1,3}/g ]\n"},{"out":"[]","err":"","code":"[ '1234567890' =~ /.{,3}/g ]\n"},{"code":"/13\n","err":"","out":"ERROR: Search pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"21","err":"","code":"1.5 * 14\n"},{"code":"/1\\b2/ ? 'match' : 'nope'\n","err":"","out":"nope"},{"out":"nope","err":"","code":"/1\\B2/ ? 'match' : 'nope'\n"},{"out":"Inf","err":"","code":"1e1000\n"},{"code":"[ 1e205 / 1e192 ]\n","err":"","out":"[\"10000000000000\"]"},{"code":"1+print 4\n","out":"4","err":""},{"code":"1+print \"4\"\n","err":"","out":"4"},{"out":"ERROR: Assigning non-zero to $[ is no longer possible at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$[ = 1;  [ qw/Foo Bar/[1] ]\n"},{"out":"1","err":"","code":"'-1' =~ s/(.+)/-$1/er\n"},{"out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"++${\\1}; say 1\n"},{"code":"$! = 2; \"$!\"\n","err":"","out":"No such file or directory"},{"code":"20%10\n","err":"","out":"0"},{"out":"4","err":"","code":"2 << 1\n"},{"code":"[ 2 << 1, 2 >> 1 ]\n","err":"","out":"[4,1]"},{"code":"[ 2 << 1, 4 >> 1 ]\n","err":"","out":"[4,2]"},{"code":"2 << 2\n","out":"8","err":""},{"err":"","out":"1.46666666666667","code":"220/10*4/60\n"},{"out":"1.83333333333333","err":"","code":"220/8*4/60\n"},{"err":"","out":"0","code":"*2=2.5; *2+*2\n"},{"code":"- - '234567'\n","err":"","out":"234567"},{"out":"1099511627776","err":"","code":"2**40\n"},{"code":"255.244\n","err":"","out":"255.244"},{"code":"3%10\n","err":"","out":"3"},{"out":"0.818181818181818","err":"","code":"378/462\n"},{"err":"","out":"[]","code":"[ 3 + asdfadsf->import ]\n"},{"code":"(4095 & 0xFF00) >> 8;\n","out":"15","err":""},{"err":"","out":"106752","code":"417 * 256\n"},{"code":"42\n","err":"","out":"42"},{"code":"â42â\n","err":"","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after natures/; <-- HERE near column 91 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"('42 bottles of beer' =~ /(\\d+)/)[0]\n","err":"","out":"42"},{"out":"\\undef","err":"","code":"\\42->can(\"foo\");\n"},{"out":"","err":"","code":"42->can(\"foo\");\n"},{"code":"(42 =~ /(\\d+)/)[0]\n","out":"42","err":""},{"code":"473*6\n","out":"2838","err":""},{"code":"*4 = sub { 'ok' }; main->${ \\4 };\n","err":"","out":"ok"},{"code":"*4 = sub { 'ok' }; main->4;\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"->4\"\n"},{"code":"*4 = sub { print \"yes\" }; 4->()\n","out":"yes","err":""},{"err":"","out":"6","code":"6%10\n"},{"code":"71503 + 46697- 999\n","out":"117201","err":""},{"code":"[ 98-110,106-117,118-103]  \n","out":"[-12,-11,15]","err":""},{"code":"998*999\n","out":"997002","err":""},{"code":"999*999\n","out":"998001","err":""},{"err":"","out":"0","code":"- - ' A'\n"},{"code":"- - 'A'\n","err":"","out":"+A"},{"code":"*$a = 1;\n","out":"ERROR: Can't use an undefined value as a symbol reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"@a=(1..5); $a[-20]\n","err":"","out":""},{"out":"ERROR: Can't modify constant item in substitution (s///) at (eval 558) line 1, near \"s/\\D+//,\"\n","err":"","code":"[ 'a 42 b' =~ s/\\D+//, 'a 42 b' =~ s/\\D+//g ]\n"},{"code":"[ 'a 42 b' =~ s/\\D+//r, 'a 42 b' =~ s/\\D+//gr ]\n","out":"[\"42 b\",42]","err":""},{"code":"$_ = \"aa\"; /^(.)$1$/\n","out":"","err":""},{"err":"","out":"1","code":"$_ = \"aa\"; /^(.)\\1$/\n"},{"err":"","out":"012345","code":"$a = 'a'; my $b = \\*a; for $$b (0..5) { print $a }\n"},{"code":"\\$a = \\$b\n","out":"\\undef","err":""},{"out":"nope","err":"","code":"/a\\Ba/ ? 'match' : 'nope'\n"},{"err":"","out":"[\\\"abc\",\\\"abc\"]","code":"[ \\'abc', \\'abc' ]\n"},{"out":"[\\\"abc\",\\\"abc\"]","err":"","code":"[ \\abc::, \\abc:: ]\n"},{"code":"[ \\('abc' x 2) ]\n","err":"","out":"[\\\"abcabc\"]"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"abc:: x \"\n","err":"","code":"[ \\(abc:: x 2) ]\n"},{"code":"/a\\b/ ? 'match' : 'nope'\n","err":"","out":"nope"},{"code":"/a\\b#/ ? 'match' : 'nope'\n","err":"","out":"nope"},{"err":"","out":"ERROR: Can't modify multiplication (*) in scalar assignment at (eval 558) line 1, at EOF\n","code":"$a=\"foo bar\" *$a = 1;\n"},{"code":"$a=\"foo bar\"; *$a = 1;\n","err":"","out":"*main::1"},{"err":"","out":"*main::foo bar","code":"$a=\"foo bar\"; *$a = sub {\"baz\"};\n"},{"code":"$a=\"foo bar\"; *$a = sub {\"baz\"}; \"foo bar\"->()\n","err":"","out":"baz"},{"code":"/a/ ? 'match' : 'nope'\n","err":"","out":"nope"},{"code":"'A' =~ s/(A)/lcfirst $1/re\n","out":"a","err":""},{"code":"'A' =~ s/(A)/'lcfirst $1'/ree\n","err":"","out":"a"},{"code":"[asdfadsf->can('import')]\n","out":"[undef]","err":""},{"code":"asdfadsf->fooo\n","out":"ERROR: Can't locate object method \"fooo\" via package \"asdfadsf\" (perhaps you forgot to load \"asdfadsf\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"[]","err":"","code":"[ asdfadsf->import ]\n"},{"code":"asdfadsf->import\n","err":"","out":""},{"code":"'/asdf//' =~ m{/[^/]*/(?!/)} ? 'y' : 'n'\n","err":"","out":"y"},{"out":"[\"a\"]","err":"","code":"[ ('a' x 30) =~ /(.*a){25,}/ ];\n"},{"out":"1","err":"","code":"('a' x 30) =~ /([^a]*a){25,}/\n"},{"out":"[\"a\"]","err":"","code":"[ ('a' x 30) =~ /([^a]*a){25,}/ ];\n"},{"err":"","out":"aXYbXYc","code":"'aXYbXYcXYdeXfYgX' =~ s/.+\\KXY.+$//r;\n"},{"code":"'aXYbXYcXYdeXfYgX' =~ s/(.+)XY.+$/$1/r;\n","out":"aXYbXYc","err":""},{"code":"'aXYbXYcXYdeXfYgX' =~ s/XY(.(?!=XY))+//r\n","out":"a","err":""},{"code":"'aXYbXYcXYdeXfYgX' =~ s/XY(.(?!=XY))+$//r\n","err":"","out":"a"},{"out":"aXYcXYdeXfYgX","err":"","code":"'aXYbXYcXYdeXfYgX' =~ s/XY(.(?!=XY)+)//r\n"},{"out":"aXYbXYcXYdeXfYgX","err":"","code":"'aXYbXYcXYdeXfYgX' =~ s/XY(.(?!=XY)+)$//r\n"},{"code":"'aXYbXYcXYdeXfYgX' =~ s/XY(.(?!=XY)+)+//r\n","out":"a","err":""},{"out":"aXYbXYc","err":"","code":"'aXYbXYcXYdeXfYgX' =~ s/XY(.(?!XY))+$//r\n"},{"code":"[ ('A'..'Z', 0..9)[29] ]\n","out":"[3]","err":""},{"code":"[(a..z)[24]]\n","err":"","out":"[\"y\"]"},{"err":"","out":"[\"z\"]","code":"[ ('a'..'z')[25] ]\n"},{"err":"","out":"[undef]","code":"[ ('a'..'z')[26] ]\n"},{"code":"[ 'babgbag' =~ /.*?b.*?a.*?g.*?/g ]\n","err":"","out":"[\"babg\",\"bag\"]"},{"code":"[ 'babgbag' =~ /.*?b.*?a.*?g.*/g ]\n","err":"","out":"[\"babgbag\"]"},{"code":"[ 'babgbag' =~ /.*b.*a.*g.*/g ]\n","out":"[\"babgbag\"]","err":""},{"code":"[ () = 'babgbag' =~ /.*?b.*?a.*?g.*?/g ]\n","out":"[]","err":""},{"out":"[]","err":"","code":"[ () = 'babgbag' =~ /.*b.*a.*g.*/g ]\n"},{"out":"+bar","err":"","code":"- - '+bar'\n"},{"err":"","out":"-bar","code":"- 'bar'\n"},{"code":"--'bar'\n","out":"ERROR: Can't modify constant item in predecrement (--) at (eval 558) line 1, at EOF\n","err":""},{"code":"-(-'bar')\n","out":"+bar","err":""},{"code":"'bar' - 'bar'\n","out":"0","err":""},{"code":"BEGIN { *4 = sub () { 'ok' } }; &{ 4 };\n","out":"ERROR: Too many arguments for subroutine at (eval 558) line 1.\n","err":""},{"err":"","out":"ok","code":"BEGIN { *4 = sub () { 'ok' } }; &{ 4 }();\n"},{"code":"BEGIN { $::{ARRAY} = \\[qw(one two three)] }; ARRAY\n","err":"","out":"[\"one\",\"two\",\"three\"]"},{"code":"BEGIN { *consecrate = \\&CORE::bless }  [ consecrate  {}, 'Foo' ]\n","out":"[bless( {}, 'Foo' )]","err":""},{"code":"BEGIN{ $^H = 0 }; use strict; use feature 'state';  for( 1..3) { print ++(state $x) }\n","err":"","out":"123"},{"code":"BEGIN{ $^H = 0 }; use strict; use feature 'state';  for( 1..3) { state $x; print ++$x }\n","err":"","out":"123"},{"code":"BEGIN { &Internals::SvREADONLY(\\1, 0); ++${ \\1 } }; say 1\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"BEGIN { Internals::SvREADONLY(\\1, 0); ++${ \\1 } }; say 1\n","err":"","out":"ERROR: Type of arg 1 to Internals::SvREADONLY must be one of [$%@] (not constant item) at (eval 558) line 1, near \"0)\"\nBEGIN not safe after errors--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"BEGIN { &Internals::SvREADONLY(\\undef, 0); ++${ \\undef } }; say undef;\n","err":"","out":"ERROR: Modification of a read-only value attempted at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"..","code":"BEGIN { $SIG{__DIE__} = sub { say \"42\"; } } '..'\n"},{"code":"BEGIN { $SIG{__DIE__} = sub { say \"42\"; } }  a ab \n","out":"42\nERROR: Can't locate object method \"a\" via package \"ab\" (perhaps you forgot to load \"ab\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"42\nERROR: Can't locate object method \"a\" via package \"bc\" (perhaps you forgot to load \"bc\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"BEGIN { $SIG{__DIE__} = sub { say 42 };  }  a bc\n"},{"out":"42\nERROR: Can't locate object method \"a\" via package \"bc\" (perhaps you forgot to load \"bc\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"BEGIN { $SIG{__DIE__} = sub { say 42; };  }  a bc\n"},{"out":"","err":"","code":"BEGIN { $SIG{__DIE__} = sub { say 42; exit  };  }  a bc\n"},{"err":"","out":"42\nERROR: Can't locate object method \"a\" via package \"bc\" (perhaps you forgot to load \"bc\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"BEGIN { $SIG{__DIE__} = sub { say 42; return 0 };  }  a bc\n"},{"err":"","out":"42\nERROR: Can't locate object method \"a\" via package \"bc\" (perhaps you forgot to load \"bc\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"BEGIN { $SIG{__DIE__} = sub { say 42; return  };  }  a bc\n"},{"code":"BEGIN { $SIG{__DIE__} = sub { say 42; return false };  }  a bc\n","err":"","out":"42\nERROR: Can't locate object method \"a\" via package \"bc\" (perhaps you forgot to load \"bc\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"BenGoldberg ÃÂ¢ÃÂÃÂ","err":"","code":"\"BenGoldberg \\N{HEAVY SPARKLE}\"\n"},{"code":"binmode STDOUT; ($a,$b) = (\"\\x{202d}\", \"\\x{202e}\");\n","err":"","out":"2"},{"err":"","out":"Ã¢ÂÂ­JÃ¢ÂÂ®,Ã¢ÂÂ­uÃ¢ÂÂ®rÃ¢ÂÂ­sÃ¢ÂÂ®eÃ¢ÂÂ­tÃ¢ÂÂ®kÃ¢ÂÂ­ Ã¢ÂÂ®cÃ¢ÂÂ­aÃ¢ÂÂ®aÃ¢ÂÂ­nÃ¢ÂÂ®HÃ¢ÂÂ­oÃ¢ÂÂ® Ã¢ÂÂ­tÃ¢ÂÂ®IÃ¢ÂÂ­hÃ¢ÂÂ®DÃ¢ÂÂ­eÃ¢ÂÂ®IÃ¢ÂÂ­rÃ¢ÂÂ®B","code":"binmode STDOUT; ($a,$b) = (\"\\x{202d}\", \"\\x{202e}\"); $_ = \"Just another BIDI Hacker,\\n\"; print \"$a$1$b$3\" while s/(.)(.*)(.)/$2/;\n"},{"err":"","out":"Ã¢ÂÂ­JÃ¢ÂÂ® Ã¢ÂÂ­uÃ¢ÂÂ®,Ã¢ÂÂ­sÃ¢ÂÂ®rÃ¢ÂÂ­tÃ¢ÂÂ®eÃ¢ÂÂ­ Ã¢ÂÂ®kÃ¢ÂÂ­aÃ¢ÂÂ®cÃ¢ÂÂ­nÃ¢ÂÂ®aÃ¢ÂÂ­oÃ¢ÂÂ®HÃ¢ÂÂ­tÃ¢ÂÂ® Ã¢ÂÂ­hÃ¢ÂÂ®IÃ¢ÂÂ­eÃ¢ÂÂ®DÃ¢ÂÂ­rÃ¢ÂÂ®IÃ¢ÂÂ­ Ã¢ÂÂ®B","code":"binmode STDOUT; ($a,$b) = (\"\\x{202d}\", \"\\x{202e}\"); $_ = \"Just another BIDI Hacker, \"; print \"$a$1$b$3\" while s/(.)(.*)(.)/$2/;\n"},{"out":"Ã¢ÂÂ­JÃ¢ÂÂ®rÃ¢ÂÂ­uÃ¢ÂÂ®eÃ¢ÂÂ­sÃ¢ÂÂ®kÃ¢ÂÂ­tÃ¢ÂÂ®cÃ¢ÂÂ­ Ã¢ÂÂ®aÃ¢ÂÂ­aÃ¢ÂÂ®HÃ¢ÂÂ­nÃ¢ÂÂ® Ã¢ÂÂ­oÃ¢ÂÂ®IÃ¢ÂÂ­tÃ¢ÂÂ®DÃ¢ÂÂ­hÃ¢ÂÂ®IÃ¢ÂÂ­eÃ¢ÂÂ®BÃ¢ÂÂ­rÃ¢ÂÂ® ","err":"","code":"binmode STDOUT; ($a,$b) = (\"\\x{202d}\", \"\\x{202e}\"); $_ = \"Just another BIDI Hacker\"; print \"$a$1$b$3\" while s/(.)(.*)(.)/$2/;\n"},{"code":"binmode STDOUT, 'encoding(utf8)'; my @o = (\"\\x{202d}\", \"\\x{202e}\"); print \"$o[--$|]$_\" for split //, 'J,ursetk cAanHo tIhDeIrB /Pler'\n","err":"","out":"ÃÂ¢ÃÂÃÂ­JÃÂ¢ÃÂÃÂ®,ÃÂ¢ÃÂÃÂ­uÃÂ¢ÃÂÃÂ®rÃÂ¢ÃÂÃÂ­sÃÂ¢ÃÂÃÂ®eÃÂ¢ÃÂÃÂ­tÃÂ¢ÃÂÃÂ®kÃÂ¢ÃÂÃÂ­ ÃÂ¢ÃÂÃÂ®cÃÂ¢ÃÂÃÂ­AÃÂ¢ÃÂÃÂ®aÃÂ¢ÃÂÃÂ­nÃÂ¢ÃÂÃÂ®HÃÂ¢ÃÂÃÂ­oÃÂ¢ÃÂÃÂ® ÃÂ¢ÃÂÃÂ­tÃÂ¢ÃÂÃÂ®IÃÂ¢ÃÂÃÂ­hÃÂ¢ÃÂÃÂ®DÃÂ¢ÃÂÃÂ­eÃÂ¢ÃÂÃÂ®IÃÂ¢ÃÂÃÂ­rÃÂ¢ÃÂÃÂ®BÃÂ¢ÃÂÃÂ­ ÃÂ¢ÃÂÃÂ®/ÃÂ¢ÃÂÃÂ­PÃÂ¢ÃÂÃÂ®lÃÂ¢ÃÂÃÂ­eÃÂ¢ÃÂÃÂ®r"},{"code":"binmode STDOUT; $_ = \"Just another BIDI Hacker, \"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n","err":"","out":"Ã¢ÂÂ­JÃ¢ÂÂ® Ã¢ÂÂ­uÃ¢ÂÂ®,Ã¢ÂÂ­sÃ¢ÂÂ®rÃ¢ÂÂ­tÃ¢ÂÂ®eÃ¢ÂÂ­ Ã¢ÂÂ®kÃ¢ÂÂ­aÃ¢ÂÂ®cÃ¢ÂÂ­nÃ¢ÂÂ®aÃ¢ÂÂ­oÃ¢ÂÂ®HÃ¢ÂÂ­tÃ¢ÂÂ® Ã¢ÂÂ­hÃ¢ÂÂ®IÃ¢ÂÂ­eÃ¢ÂÂ®DÃ¢ÂÂ­rÃ¢ÂÂ®IÃ¢ÂÂ­ Ã¢ÂÂ®B"},{"err":"","out":"Ã¢ÂÂ­JÃ¢ÂÂ® Ã¢ÂÂ­uÃ¢ÂÂ® Ã¢ÂÂ­sÃ¢ÂÂ®,Ã¢ÂÂ­tÃ¢ÂÂ®rÃ¢ÂÂ­ Ã¢ÂÂ®eÃ¢ÂÂ­aÃ¢ÂÂ®kÃ¢ÂÂ­nÃ¢ÂÂ®cÃ¢ÂÂ­oÃ¢ÂÂ®aÃ¢ÂÂ­tÃ¢ÂÂ®HÃ¢ÂÂ­hÃ¢ÂÂ® Ã¢ÂÂ­eÃ¢ÂÂ®tÃ¢ÂÂ­rÃ¢ÂÂ®aÃ¢ÂÂ­ Ã¢ÂÂ®hÃ¢ÂÂ­HÃ¢ÂÂ®cÃ¢ÂÂ­eÃ¢ÂÂ®x","code":"binmode STDOUT; $_ = \"Just another Hexchat Hacker,  \"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n"},{"err":"","out":"Ã¢ÂÂ­JÃ¢ÂÂ® Ã¢ÂÂ­uÃ¢ÂÂ®,Ã¢ÂÂ­sÃ¢ÂÂ®rÃ¢ÂÂ­tÃ¢ÂÂ®eÃ¢ÂÂ­ Ã¢ÂÂ®kÃ¢ÂÂ­aÃ¢ÂÂ®cÃ¢ÂÂ­nÃ¢ÂÂ®aÃ¢ÂÂ­oÃ¢ÂÂ®HÃ¢ÂÂ­tÃ¢ÂÂ® Ã¢ÂÂ­hÃ¢ÂÂ®tÃ¢ÂÂ­eÃ¢ÂÂ®aÃ¢ÂÂ­rÃ¢ÂÂ®hÃ¢ÂÂ­ Ã¢ÂÂ®cÃ¢ÂÂ­HÃ¢ÂÂ®x","code":"binmode STDOUT; $_ = \"Just another Hexchat Hacker, \"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n"},{"code":"binmode STDOUT; $_ = \"Just another Hexchat Hacker,\"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n","out":"Ã¢ÂÂ­JÃ¢ÂÂ®,Ã¢ÂÂ­uÃ¢ÂÂ®rÃ¢ÂÂ­sÃ¢ÂÂ®eÃ¢ÂÂ­tÃ¢ÂÂ®kÃ¢ÂÂ­ Ã¢ÂÂ®cÃ¢ÂÂ­aÃ¢ÂÂ®aÃ¢ÂÂ­nÃ¢ÂÂ®HÃ¢ÂÂ­oÃ¢ÂÂ® Ã¢ÂÂ­tÃ¢ÂÂ®tÃ¢ÂÂ­hÃ¢ÂÂ®aÃ¢ÂÂ­eÃ¢ÂÂ®hÃ¢ÂÂ­rÃ¢ÂÂ®cÃ¢ÂÂ­ Ã¢ÂÂ®xÃ¢ÂÂ­HÃ¢ÂÂ®e","err":""},{"err":"","out":"Ã¢ÂÂ­JÃ¢ÂÂ®,Ã¢ÂÂ­uÃ¢ÂÂ®rÃ¢ÂÂ­sÃ¢ÂÂ®eÃ¢ÂÂ­tÃ¢ÂÂ®kÃ¢ÂÂ­ Ã¢ÂÂ®cÃ¢ÂÂ­aÃ¢ÂÂ®aÃ¢ÂÂ­nÃ¢ÂÂ®HÃ¢ÂÂ­oÃ¢ÂÂ® Ã¢ÂÂ­tÃ¢ÂÂ®IÃ¢ÂÂ­hÃ¢ÂÂ®DÃ¢ÂÂ­eÃ¢ÂÂ®IÃ¢ÂÂ­rÃ¢ÂÂ®BÃ¢ÂÂ­ Ã¢ÂÂ®/Ã¢ÂÂ­PÃ¢ÂÂ®lÃ¢ÂÂ­eÃ¢ÂÂ®r","code":"binmode STDOUT; $_ = \"Just another Perl/BIDI Hacker,\"; print \"\\x{202d}$1\\x{202e}$3\" while s/(.)(.*)(.)/$2/;\n"},{"out":"hÂÂÂ>ÂÂÂÂÂÂ>sÂÂÂÂÂÂ>ÂÂÂÂÂJ","err":"","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x10-\\x7f][\\xff00-\\xff5f]r;\n"},{"out":"Ã¯Â¼ÂªÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¢ÂÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¢ÂÂÃ¯Â¼ÂµÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¢ÂÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼Â","err":"","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\x{2000}\\x{ff01}-\\x{ff5f}]r;\n"},{"code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\x{2001}\\x{ff01}-\\x{ff5f}]r;\n","err":"","out":"Ã¯Â¼ÂªÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¢ÂÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¢ÂÂÃ¯Â¼ÂµÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¢ÂÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼Â"},{"code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\x{2003}\\x{ff01}-\\x{ff5f}]r;\n","out":"Ã¯Â¼ÂªÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¢ÂÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¢ÂÂÃ¯Â¼ÂµÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¢ÂÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼Â","err":""},{"code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\x{ff00}-\\x{ff5f}]r;\n","out":"Ã¯Â¼ÂªÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼ÂÃ¯Â¼ÂµÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼Â","err":""},{"err":"","out":"XÂÂÂÃ¿o|}ÂvsÂÃ¿c|wq}rsÃ¿voqysÂ:","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\xff00-\\xff5f]r;\n"},{"err":"","out":"Ã¯Â¼ÂªÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½Â Ã¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½Â Ã¯Â¼ÂµÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½Â Ã¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼Â","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][ \\x{ff01}-\\x{ff5f}]r;\n"},{"err":"","out":"XÂÂÂÃ¿o|}ÂvsÂÃ¿c|wq}rsÃ¿voqysÂ:","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\xff10-\\xff5f]r;\n"},{"code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\xff20-\\xff5f]r;\n","err":"","out":"XÂÂÂÃ¿o|}ÂvsÂÃ¿c|wq}rsÃ¿voqysÂ:"},{"code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\xff30-\\xff5f]r;\n","err":"","out":"XÂÂÂÃ¿o|}ÂvsÂÃ¿c|wq}rsÃ¿voqysÂ:"},{"out":"XÂÂÂÃ¿o|}ÂvsÂÃ¿c|wq}rsÃ¿voqysÂ:","err":"","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\xff40-\\xff5f]r;\n"},{"err":"","out":"XÂÂÂÃ¿o|}ÂvsÂÃ¿c|wq}rsÃ¿voqysÂ:","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x20-\\x7f][\\xff50-\\xff5f]r;\n"},{"code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x30-\\x7f][\\xff00-\\xff5f]r;\n","out":"Hsqr _lmrfcp Slgambc f_aicp,","err":""},{"out":"8cab O\\]bVS` C\\WQ]RS VOQYS`,","err":"","code":"binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\\x40-\\x7f][\\xff00-\\xff5f]r;\n"},{"out":"Ã¢ÂÂ­JÃ¢ÂÂ®,Ã¢ÂÂ­uÃ¢ÂÂ®rÃ¢ÂÂ­sÃ¢ÂÂ®eÃ¢ÂÂ­tÃ¢ÂÂ®kÃ¢ÂÂ­ Ã¢ÂÂ®cÃ¢ÂÂ­AÃ¢ÂÂ®aÃ¢ÂÂ­nÃ¢ÂÂ®HÃ¢ÂÂ­oÃ¢ÂÂ® Ã¢ÂÂ­tÃ¢ÂÂ®IÃ¢ÂÂ­hÃ¢ÂÂ®DÃ¢ÂÂ­eÃ¢ÂÂ®IÃ¢ÂÂ­rÃ¢ÂÂ®BÃ¢ÂÂ­ Ã¢ÂÂ®/Ã¢ÂÂ­PÃ¢ÂÂ®lÃ¢ÂÂ­eÃ¢ÂÂ®r","err":"","code":"binmode STDOUT; my @o = (\"\\x{202d}\", \"\\x{202e}\"); print \"$o[--$|]$_\" for split //, 'J,ursetk cAanHo tIhDeIrB /Pler'\n"},{"err":"","out":"Ã¢ÂÂ","code":"binmode STDOUT; print 'â' .. 'â'\n"},{"err":"","out":"Ã¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂ Ã¢ÂÂ¡Ã¢ÂÂ¢Ã¢ÂÂ£Ã¢ÂÂ¤Ã¢ÂÂ¥Ã¢ÂÂ¦Ã¢ÂÂ§Ã¢ÂÂ¨Ã¢ÂÂ©Ã¢ÂÂªÃ¢ÂÂ«Ã¢ÂÂ¬Ã¢ÂÂ­Ã¢ÂÂ®Ã¢ÂÂ¯Ã¢ÂÂ°Ã¢ÂÂ±Ã¢ÂÂ²Ã¢ÂÂ³Ã¢ÂÂ´Ã¢ÂÂµÃ¢ÂÂ¶Ã¢ÂÂ·Ã¢ÂÂ¸Ã¢ÂÂ¹Ã¢ÂÂºÃ¢ÂÂ»Ã¢ÂÂ¼Ã¢ÂÂ½Ã¢ÂÂ¾Ã¢ÂÂ¿Ã¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂÃ¢ÂÂ","code":"binmode STDOUT; print chr($_) for 0x2719 .. 0x2749;\n"},{"code":"binmode STDOUT; print for 'â' .. 'â'\n","err":"","out":"Ã¢ÂÂ"},{"out":"Ã°ÂÂÂ©","err":"","code":"binmode STDOUT; print \"\\x{1f4a9}\"\n"},{"code":"binmode STDOUT; srand 42; my @o = (\"\\U{202d}\", \"\\U{202e}\"); print \"$o[--$|]$_\" for 'a'..'z', '_';\n","out":"{202D}a{202E}b{202D}c{202E}d{202D}e{202E}f{202D}g{202E}h{202D}i{202E}j{202D}k{202E}l{202D}m{202E}n{202D}o{202E}p{202D}q{202E}r{202D}s{202E}t{202D}u{202E}v{202D}w{202E}x{202D}y{202E}z{202D}_","err":""},{"code":"binmode STDOUT; srand 42; my @o = (\"\\U202d\", \"\\U202e\"); print \"$o[--$|]$_\" for 'a'..'z', '_';\n","out":"202Da202Eb202Dc202Ed202De202Ef202Dg202Eh202Di202Ej202Dk202El202Dm202En202Do202Ep202Dq202Er202Ds202Et202Du202Ev202Dw202Ex202Dy202Ez202D_","err":""},{"err":"","out":"202Ea202Db202Dc202Dd202De202Ef202Dg202Dh202Ei202Ej202Dk202El202Em202Dn202Eo202Ep202Eq202Dr202Es202Dt202Du202Dv202Ew202Dx202Ey202Ez202E_","code":"binmode STDOUT; srand 42; my @o = (\"\\U202d\", \"\\U202e\"); print \"$o[rand 2]$_\" for 'a'..'z', '_';\n"},{"err":"","out":"202EA202DB202DC202DD202DE202EF202DG202DH202EI202EJ202DK202EL202EM202DN202EO202EP202EQ202DR202ES202DT202DU202DV202EW202DX202EY202EZ202E_","code":"binmode STDOUT; srand 42; my @o = (\"\\U202d\", \"\\U202e\"); print \"$o[rand 2]$_\" for 'A'..'Z', '_';\n"},{"code":"binmode STDOUT; srand 42; my @o = (\"\\x{202d}\", \"\\x{202e}\"); print \"$o[--$|]$_\" for 'a'..'z', '_';\n","out":"Ã¢ÂÂ­aÃ¢ÂÂ®bÃ¢ÂÂ­cÃ¢ÂÂ®dÃ¢ÂÂ­eÃ¢ÂÂ®fÃ¢ÂÂ­gÃ¢ÂÂ®hÃ¢ÂÂ­iÃ¢ÂÂ®jÃ¢ÂÂ­kÃ¢ÂÂ®lÃ¢ÂÂ­mÃ¢ÂÂ®nÃ¢ÂÂ­oÃ¢ÂÂ®pÃ¢ÂÂ­qÃ¢ÂÂ®rÃ¢ÂÂ­sÃ¢ÂÂ®tÃ¢ÂÂ­uÃ¢ÂÂ®vÃ¢ÂÂ­wÃ¢ÂÂ®xÃ¢ÂÂ­yÃ¢ÂÂ®zÃ¢ÂÂ­_","err":""},{"code":"binmode STDOUT; srand 42; my @o = (\"\\x{202d}\", \"\\x{202e}\"); print \"$o[--$|]$_\" for 'a'..'z', 0..3;\n","out":"Ã¢ÂÂ­aÃ¢ÂÂ®bÃ¢ÂÂ­cÃ¢ÂÂ®dÃ¢ÂÂ­eÃ¢ÂÂ®fÃ¢ÂÂ­gÃ¢ÂÂ®hÃ¢ÂÂ­iÃ¢ÂÂ®jÃ¢ÂÂ­kÃ¢ÂÂ®lÃ¢ÂÂ­mÃ¢ÂÂ®nÃ¢ÂÂ­oÃ¢ÂÂ®pÃ¢ÂÂ­qÃ¢ÂÂ®rÃ¢ÂÂ­sÃ¢ÂÂ®tÃ¢ÂÂ­uÃ¢ÂÂ®vÃ¢ÂÂ­wÃ¢ÂÂ®xÃ¢ÂÂ­yÃ¢ÂÂ®zÃ¢ÂÂ­0Ã¢ÂÂ®1Ã¢ÂÂ­2Ã¢ÂÂ®3","err":""},{"code":"binmode STDOUT; srand 42; my @o = (\"\\x{202d}\", \"\\x{202e}\"); print \"$o[rand 2]$_\" for 'a'..'z', '_';\n","err":"","out":"Ã¢ÂÂ®aÃ¢ÂÂ­bÃ¢ÂÂ­cÃ¢ÂÂ­dÃ¢ÂÂ­eÃ¢ÂÂ®fÃ¢ÂÂ­gÃ¢ÂÂ­hÃ¢ÂÂ®iÃ¢ÂÂ®jÃ¢ÂÂ­kÃ¢ÂÂ®lÃ¢ÂÂ®mÃ¢ÂÂ­nÃ¢ÂÂ®oÃ¢ÂÂ®pÃ¢ÂÂ®qÃ¢ÂÂ­rÃ¢ÂÂ®sÃ¢ÂÂ­tÃ¢ÂÂ­uÃ¢ÂÂ­vÃ¢ÂÂ®wÃ¢ÂÂ­xÃ¢ÂÂ®yÃ¢ÂÂ®zÃ¢ÂÂ®_"},{"code":"binmode STDOUT; srand 42; my @o = (\"\\x202d\", \"\\x202e\"); print \"$o[rand 2]$_\" for 'a'..'z', '_';\n","out":" 2ea 2db 2dc 2dd 2de 2ef 2dg 2dh 2ei 2ej 2dk 2el 2em 2dn 2eo 2ep 2eq 2dr 2es 2dt 2du 2dv 2ew 2dx 2ey 2ez 2e_","err":""},{"code":"binmode STDOUT; srand 42; my @o = (\"\\x{202d}\", \"\\x{202e}\"); print \"$o[rand 2]$_\" for split //, \"rJust anekocath ehder oUcin\";\n","err":"","out":"Ã¢ÂÂ®rÃ¢ÂÂ­JÃ¢ÂÂ­uÃ¢ÂÂ­sÃ¢ÂÂ­tÃ¢ÂÂ® Ã¢ÂÂ­aÃ¢ÂÂ­nÃ¢ÂÂ®eÃ¢ÂÂ®kÃ¢ÂÂ­oÃ¢ÂÂ®cÃ¢ÂÂ®aÃ¢ÂÂ­tÃ¢ÂÂ®hÃ¢ÂÂ® Ã¢ÂÂ®eÃ¢ÂÂ­hÃ¢ÂÂ®dÃ¢ÂÂ­eÃ¢ÂÂ­rÃ¢ÂÂ­ Ã¢ÂÂ®oÃ¢ÂÂ­UÃ¢ÂÂ®cÃ¢ÂÂ®iÃ¢ÂÂ®n"},{"out":"Ã¢ÂÂ®rÃ¢ÂÂ­JÃ¢ÂÂ­uÃ¢ÂÂ­sÃ¢ÂÂ­tÃ¢ÂÂ®_Ã¢ÂÂ­aÃ¢ÂÂ­nÃ¢ÂÂ®eÃ¢ÂÂ®kÃ¢ÂÂ­oÃ¢ÂÂ®cÃ¢ÂÂ®aÃ¢ÂÂ­tÃ¢ÂÂ®hÃ¢ÂÂ®_Ã¢ÂÂ®eÃ¢ÂÂ­hÃ¢ÂÂ®dÃ¢ÂÂ­eÃ¢ÂÂ­rÃ¢ÂÂ­_Ã¢ÂÂ®oÃ¢ÂÂ­UÃ¢ÂÂ®cÃ¢ÂÂ®iÃ¢ÂÂ®n","err":"","code":"binmode STDOUT; srand 42; my @o = (\"\\x{202d}\", \"\\x{202e}\"); print \"$o[rand 2]$_\" for split //, \"rJust_anekocath_ehder_oUcin\";\n"},{"code":"binmode STDOUT; srand 42; my @o = (\"\\x{202d}\", \"\\x{202e}\"); print \"$o[rand 2]$_\" for split //, \"rJust__Anekocath_ehder_oUcin\";\n","out":"Ã¢ÂÂ®rÃ¢ÂÂ­JÃ¢ÂÂ­uÃ¢ÂÂ­sÃ¢ÂÂ­tÃ¢ÂÂ®_Ã¢ÂÂ­_Ã¢ÂÂ­AÃ¢ÂÂ®nÃ¢ÂÂ®eÃ¢ÂÂ­kÃ¢ÂÂ®oÃ¢ÂÂ®cÃ¢ÂÂ­aÃ¢ÂÂ®tÃ¢ÂÂ®hÃ¢ÂÂ®_Ã¢ÂÂ­eÃ¢ÂÂ®hÃ¢ÂÂ­dÃ¢ÂÂ­eÃ¢ÂÂ­rÃ¢ÂÂ®_Ã¢ÂÂ­oÃ¢ÂÂ®UÃ¢ÂÂ®cÃ¢ÂÂ®iÃ¢ÂÂ­n","err":""},{"err":"","out":"Ã¢ÂÂ®rÃ¢ÂÂ­JÃ¢ÂÂ­uÃ¢ÂÂ­sÃ¢ÂÂ­tÃ¢ÂÂ®_Ã¢ÂÂ­AÃ¢ÂÂ­nÃ¢ÂÂ®eÃ¢ÂÂ®kÃ¢ÂÂ­oÃ¢ÂÂ®cÃ¢ÂÂ®aÃ¢ÂÂ­tÃ¢ÂÂ®hÃ¢ÂÂ®_Ã¢ÂÂ®eÃ¢ÂÂ­hÃ¢ÂÂ®dÃ¢ÂÂ­eÃ¢ÂÂ­rÃ¢ÂÂ­_Ã¢ÂÂ®oÃ¢ÂÂ­UÃ¢ÂÂ®cÃ¢ÂÂ®iÃ¢ÂÂ®n","code":"binmode STDOUT; srand 42; my @o = (\"\\x{202d}\", \"\\x{202e}\"); print \"$o[rand 2]$_\" for split //, \"rJust_Anekocath_ehder_oUcin\";\n"},{"code":"binmode STDOUT; srand 42; my @o = (\"\\x{202d}\", \"\\x{202e}\"); print \"$o[rand 2]$_\" for split //, \"rJustA_nekocath_ehder_oUcin\";\n","err":"","out":"Ã¢ÂÂ®rÃ¢ÂÂ­JÃ¢ÂÂ­uÃ¢ÂÂ­sÃ¢ÂÂ­tÃ¢ÂÂ®AÃ¢ÂÂ­_Ã¢ÂÂ­nÃ¢ÂÂ®eÃ¢ÂÂ®kÃ¢ÂÂ­oÃ¢ÂÂ®cÃ¢ÂÂ®aÃ¢ÂÂ­tÃ¢ÂÂ®hÃ¢ÂÂ®_Ã¢ÂÂ®eÃ¢ÂÂ­hÃ¢ÂÂ®dÃ¢ÂÂ­eÃ¢ÂÂ­rÃ¢ÂÂ­_Ã¢ÂÂ®oÃ¢ÂÂ­UÃ¢ÂÂ®cÃ¢ÂÂ®iÃ¢ÂÂ®n"},{"code":"binmode STDOUT; srand 42; my @o = (\"\\x{202d}\", \"\\x{202e}\"); print \"$o[rand 2]$_\" for split //, \"rJustAnekocath_ehder_oUcin_\";\n","out":"Ã¢ÂÂ®rÃ¢ÂÂ­JÃ¢ÂÂ­uÃ¢ÂÂ­sÃ¢ÂÂ­tÃ¢ÂÂ®AÃ¢ÂÂ­nÃ¢ÂÂ­eÃ¢ÂÂ®kÃ¢ÂÂ®oÃ¢ÂÂ­cÃ¢ÂÂ®aÃ¢ÂÂ®tÃ¢ÂÂ­hÃ¢ÂÂ®_Ã¢ÂÂ®eÃ¢ÂÂ®hÃ¢ÂÂ­dÃ¢ÂÂ®eÃ¢ÂÂ­rÃ¢ÂÂ­_Ã¢ÂÂ­oÃ¢ÂÂ®UÃ¢ÂÂ­cÃ¢ÂÂ®iÃ¢ÂÂ®nÃ¢ÂÂ®_","err":""},{"code":"binmode STDOUT, 'utf8'; my @o = (\"\\x{202d}\", \"\\x{202e}\"); print \"$o[--$|]$_\" for split //, 'J,ursetk cAanHo tIhDeIrB /Pler'\n","out":"ÃÂ¢ÃÂÃÂ­JÃÂ¢ÃÂÃÂ®,ÃÂ¢ÃÂÃÂ­uÃÂ¢ÃÂÃÂ®rÃÂ¢ÃÂÃÂ­sÃÂ¢ÃÂÃÂ®eÃÂ¢ÃÂÃÂ­tÃÂ¢ÃÂÃÂ®kÃÂ¢ÃÂÃÂ­ ÃÂ¢ÃÂÃÂ®cÃÂ¢ÃÂÃÂ­AÃÂ¢ÃÂÃÂ®aÃÂ¢ÃÂÃÂ­nÃÂ¢ÃÂÃÂ®HÃÂ¢ÃÂÃÂ­oÃÂ¢ÃÂÃÂ® ÃÂ¢ÃÂÃÂ­tÃÂ¢ÃÂÃÂ®IÃÂ¢ÃÂÃÂ­hÃÂ¢ÃÂÃÂ®DÃÂ¢ÃÂÃÂ­eÃÂ¢ÃÂÃÂ®IÃÂ¢ÃÂÃÂ­rÃÂ¢ÃÂÃÂ®BÃÂ¢ÃÂÃÂ­ ÃÂ¢ÃÂÃÂ®/ÃÂ¢ÃÂÃÂ­PÃÂ¢ÃÂÃÂ®lÃÂ¢ÃÂÃÂ­eÃÂ¢ÃÂÃÂ®r","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"blahblah q|0.000.000_YYMMDDhhmm|\"\n","code":"blahblah q|0.000.000_YYMMDDhhmm|\n"},{"code":"bless bless(), \"Bar\"\n","out":"ERROR: Not enough arguments for bless at (eval 558) line 1, near \"bless()\"\n","err":""},{"out":"bless( {}, 'Bar' )","err":"","code":"bless bless({}, \"Foo\"), \"Bar\"\n"},{"code":"*::bless = sub { print \"foo\" }; bless {}, 'Foo';\n","err":"","out":"bless( {}, 'Foo' )"},{"err":"","out":"bless( {}, 'Foo' )","code":"*bless = sub { print \"foo\" }; bless {}, 'Foo';\n"},{"code":"$_ = 'CamelCaseXMLParser'; join('_', map {lc} grep {length} split /([A-Z]+[^A-Z]*)/)\n","err":"","out":"camel_case_xmlparser"},{"out":"CamelCaseXmlparser","err":"","code":"$_ = 'CamelCaseXMLParser'; join '', map { ucfirst lc } split '_', join('_', map {lc} grep {length} split /([A-Z]+[^A-Z]*)/)\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":"","code":"$_ = 'CamelCaseXMLParser'; join('', map { ucfirst lc } split '_', join('_', map {lc} grep {length} split /([A-Z]+[^A-Z]*)/)\n"},{"code":"'CamelCaseXMLParser' =~ s/([A-Z]+[^A-Z]*)/\\u\\L$1/gr;\n","err":"","out":"CamelCaseXmlparser"},{"code":"\"\"->can(\"foo\");\n","out":"ERROR: Can't call method \"can\" without a package or object reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"$Carp::CarpLevel++; Carp::croak(\"loaded\");\n","err":"","out":"ERROR: loaded at /home/ryan/bots/perlbuut/lib/eval.pl line 301, <STDIN> line 1.\n\tmain::perl_code(\"\\$Carp::CarpLevel++; Carp::croak(\\\"loaded\\\");\") called at /home/ryan/bots/perlbuut/lib/eval.pl line 248\n"},{"err":"","out":"ERROR: loaded at (eval 558) line 1, <STDIN> line 1.\n\teval 'use 5.022001; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; Carp::croak(\"loaded\")' called at /home/ryan/bots/perlbuut/lib/eval.pl line 301\n\tmain::perl_code(\"Carp::croak(\\\"loaded\\\")\") called at /home/ryan/bots/perlbuut/lib/eval.pl line 248\n","code":"Carp::croak(\"loaded\")\n"},{"code":"$Carp::Internal{\"main\"}++; Carp::croak(\"loaded\");\n","out":"ERROR: loaded at (eval 558) line 1, <STDIN> line 1.\n\teval 'use 5.022001; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; $Carp::Internal{\"main\"}++; Carp::croak(\"loaded\");' called at /home/ryan/bots/perlbuut/lib/eval.pl line 301\n\tmain::perl_code(\"\\$Carp::Internal{\\\"main\\\"}++; Carp::croak(\\\"loaded\\\");\") called at /home/ryan/bots/perlbuut/lib/eval.pl line 248\n","err":""},{"out":"[0]","err":"","code":"$cat_line = 'Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 3 ? 1 : 0; [ $is_deep ]\n"},{"err":"","out":"[[\"Foo\",\"Bar\",\"Ber\",\"Bez\"],\"Foo*::*Bar*::*Ber*::*Bez\"]","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur*::*Brooze'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my @cat_bits = split /\\Q*::*\\E/, $cat_line; splice @cat_bits, -2; my $unwanted_cat = join '*::*', @cat_bits; [ \\@cat_bits, $unwanted_cat  ]\n"},{"code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (=() = $cat_line =~ /\\Q*::*\\E/) > 3 ? 1 : 0; [ $is_deep ]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"(=\"\n"},{"code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/) > 3 ? 1 : 0; [ $is_deep ]\n","out":"[0]","err":""},{"err":"","out":"[[\"Foo\",\"Bar\",\"Ber\",\"Bez\",\"Bur\"]]","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my @cat_bits = split /\\Q*::*\\E/, $cat_line; [ \\@cat_bits ]\n"},{"out":"[[\"Foo\",\"Bar\"],\"Ber*::*Bez*::*Bur\"]","err":"","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my @cat_bits = split /\\Q*::*\\E/, $cat_line; $cat_line = join '*::*', splice @cat_bits, 2; [ \\@cat_bits, $cat_line ]\n"},{"code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my @cat_bits = split /\\Q*::*\\E/, $cat_line = join '*::*', splice @cat_bits, 2; [ \\@cat_bits, $cat_line ]\n","out":"[[],\"\"]","err":""},{"code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my @cat_bits = split /\\Q*::*\\E/, $cat_line = join '*::*', splice @cat_bits, 3; [ \\@cat_bits, $cat_line ]\n","out":"[[],\"\"]","err":""},{"out":"[[\"Foo\",\"Bar\",\"Ber\"],\"Foo*::*Bar*::*Ber\"]","err":"","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my @cat_bits = split /\\Q*::*\\E/, $cat_line; splice @cat_bits, -2; my $unwanted_cat = join '*::*', @cat_bits; [ \\@cat_bits, $unwanted_cat  ]\n"},{"out":"[[\"Foo\",\"Bar\"],\"Foo*::*Bar\"]","err":"","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my @cat_bits = split /\\Q*::*\\E/, $cat_line; splice @cat_bits, 2; my $unwanted_cat = join '*::*', @cat_bits; [ \\@cat_bits, $unwanted_cat  ]\n"},{"code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my $prefix = splice 0, 3, @{[split /\\Q*::*\\E/, $cat_line]; [ $prefix ]\n","out":"ERROR: Missing right curly or square bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, at EOF\n","err":""},{"code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my $prefix = splice 0, 3, @{[split /\\Q*::*\\E/, $cat_line]}; [ $prefix ]\n","err":"","out":"ERROR: Type of arg 1 to splice must be array (not constant item) at (eval 558) line 1, at EOF\n"},{"code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 1 ? 1 : 0; my $prefix = splice 0, 3, split /\\Q*::*\\E/, $cat_line; [ $prefix ]\n","out":"ERROR: Type of arg 1 to splice must be array (not constant item) at (eval 558) line 1, at EOF\n","err":""},{"code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\\Q*::*\\E/g) > 3 ? 1 : 0; [ $is_deep ]\n","err":"","out":"[1]"},{"err":"","out":"[4]","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = () = $cat_line =~ /\\Q*::*\\E/g;  [ $is_deep ]\n"},{"code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = () = $cat_line =~ /\\Q*::*\\E/;  [ $is_deep ]\n","err":"","out":"[1]"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"/\\Q*::*\\E/)\"\n","code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = () = $cat_line =~ /\\Q*::*\\E/);  [ $is_deep ]\n"},{"err":"","out":"[\"Ber*::*Bur]\"]","code":"$cat_line = '[Foo*::*Bar*::*Ber*::*Bez*::*Bur]'; $wanted_cat = join '*::*', (split /\\Q*::*\\E/, $cat_line)[-3,-1]; [ $wanted_cat ]\n"},{"code":"$cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; $wanted_cat = join '*::*', (split /\\Q*::*\\E/, $cat_line)[-3,-1]; [ $wanted_cat ]\n","out":"[\"Ber*::*Bur\"]","err":""},{"code":"$c=\"{a,v,p,r}\"; [grep {$_ !~ /(.)\\1/} glob $c.$c]\n","out":"[\"av\",\"ap\",\"ar\",\"va\",\"vp\",\"vr\",\"pa\",\"pv\",\"pr\",\"ra\",\"rv\",\"rp\"]","err":""},{"out":"[0]","err":"","code":"$_ = 'C########C_##'; /(#*)C/; [ length $1 ]\n"},{"code":"$_ = '########C_##'; /(#+)C/; [ length $1 ]\n","err":"","out":"[8]"},{"code":"$_ = '########C_##'; /C/; [ pos ]\n","out":"[undef]","err":""},{"code":"@charmap = qw/Botje!!!/; @charmap->[qw/Botje/]\n","err":"","out":"ERROR: Can't use an array as a reference at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"@charmap = qw/Botje/; @charmap->[qw/Botje!/]\n","out":"ERROR: Can't use an array as a reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"charnames::string_vianame(\"SNOWMAN\")\n","err":"","out":"ÃÂ¢ÃÂÃÂ"},{"code":"charnames::viacode(1234)\n","err":"","out":"CYRILLIC CAPITAL LETTER A WITH DIAERESIS"},{"out":"ÃÂ­ÃÂ ÃÂ","err":"","code":"chr 0xd800\n"},{"code":"chr 'Î§'\n","out":"\u0000","err":""},{"out":"[undef]","err":"","code":"$_ = '########_##'; /(#*)C/; [ length $1 ]\n"},{"code":"$code\n","err":"","out":"use 5.022001; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; $code"},{"err":"","out":"[code]\n","code":"*code = sub { print 'ok' }; say '[', code, ']';\n"},{"code":"\\&code = sub { print 'ok' }; say '[', code, ']';\n","err":"","out":"[code]\n"},{"code":"*CORE::bless = sub { print \"foo\" }\n","out":"*CORE::bless","err":""},{"code":"\\*$CORE::bless = sub { print \"foo\" }\n","err":"","out":"ERROR: Can't modify reference to ref-to-glob cast in scalar assignment at (eval 558) line 1, at EOF\n"},{"code":"\\*CORE::bless = sub { print \"foo\" }\n","out":"ERROR: Can't modify reference to ref-to-glob cast in scalar assignment at (eval 558) line 1, at EOF\n","err":""},{"out":"ERROR: Not enough arguments for bless at (eval 558) line 1, at EOF\n","err":"","code":"*CORE::bless = sub { print \"foo\" }; bless\n"},{"err":"","out":"bless( {}, 'Foo' )","code":"*CORE::bless = sub { print \"foo\" }; bless {}, 'Foo';\n"},{"code":"*CORE::die = sub { say \"42\"; } die  \n","out":"ERROR: syntax error at (eval 558) line 1, near \"} die\n\"\n","err":""},{"out":"ERROR: Died at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"*CORE::die = sub { say \"42\"; }; die  \n"},{"code":"$CORE::GLOBAL::print = sub { print 42 }; print \"foo\"\n","out":"foo","err":""},{"code":"*CORE::GLOBAL::print = sub { print 42 }; print \"foo\"\n","out":"foo","err":""},{"code":"CORE::GLOBAL{print} = sub { print 42 }; print \"foo\"\n","err":"","out":"ERROR: CORE::GLOBAL is not a keyword at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"*CORE::print","code":"*CORE::print\n"},{"out":"\\*CORE::print","err":"","code":"\\*CORE::print\n"},{"out":"0","err":"","code":"@d\n"},{"code":"$Data::Dumper::Deparse = 1; my $a = sub { say \"Hello World\" }; my $b = $a; \\(sub {say \"Goodbye Mars\"});\n","err":"","out":"\\sub {    no warnings;    use feature 'current_sub', 'evalbytes', 'fc', 'lexical_subs', 'postderef', 'postderef_qq', 'refaliasing', 'say', 'signatures', 'state', 'switch', 'unicode_strings', 'unicode_eval';    no feature 'array_base';    BEGIN {        $^H{'charnames'} = 'CODE(0x27ec7b0)';        $^H{'charnames_full'} = '1';        $^H{'charnames_inverse_ords'} = 'HASH(0x28453c0)';        $^H{'charnames_loose'} = '0';        $^H{'charnames_name_aliases'} = 'HASH(0x28455b8)';        $^H{'charnames_ord_aliases'} = 'HASH(0x2845978)';        $^H{'charnames_scripts'} = '';        $^H{'charnames_short'} = '0';        $^H{'charnames_stringified_inverse_ords'} = '';        $^H{'charnames_stringified_names'} = '';        $^H{'charnames_stringified_ords'} = '';    }    say 'Goodbye Mars';}"},{"code":"Data::Dumper::Deparse = 1; my $a = sub { say \"Hello World\" }; my $b = $a; \\(sub {say \"Goodbye Mars\"});\n","out":"ERROR: Can't modify non-lvalue subroutine call in scalar assignment at (eval 558) line 1, at EOF\n","err":""},{"code":"$Data::Dumper::Terse = 1; $r = [ 1, 2, 3, { foo => bar }, ]; @a = @$r; $r->[0] = 42; $r->[3]{ber} = 'bez'; [ \\@a, $r ]\n","err":"","out":"[[1,2,3,{foo => \"bar\",ber => \"bez\"}],[42,2,3,$VAR1->[0][3]]]"},{"out":"decode_json","err":"","code":"decode_json\n"},{"out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, at EOF\n","err":"","code":"deparse: sub foo (;$) { say \"[@_]\"; }; my %h = ( bar => foo(42), meow => 'moo' ); \\%h\n"},{"err":"","out":"[42]\n","code":"deparse: sub foo ($) { say \"[@_]\"; }; my %h = ( bar => foo(42), meow => 'moo' ); \\%h\n"},{"code":"deparse: sub foo ($$) { say \"[@_]\"; }; my %h = ( bar => foo(42), meow => 'moo' ); \\%h\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$$) \"\n","err":""},{"err":"","out":"ERROR: Denied. at (eval 558) line 1, <STDIN> line 1.\n","code":"()?(): die 'Denied.';\n"},{"out":"foo","err":"","code":"do {my $print = \\&CORE::GLOBAL::print; *CORE::GLOBAL::print = sub { $print->(\"wut wut: \", @_)}}; CORE::print \"foo\"\n"},{"out":"[1]","err":"","code":"do { my @tmp = 1, 2, 3; \\@tmp }\n"},{"code":"[ $!{EINSUFFICIENT_POO} ]\n","out":"[\"\"]","err":""},{"out":"","err":"","code":"$!{EINSUFFICIENT_POO}\n"},{"out":"[52]","err":"","code":"[ Errno::EBADE ]\n"},{"out":"[\"Errno::EBADY\"]","err":"","code":"[ Errno::EBADY ]\n"},{"out":"[16]","err":"","code":"[ Errno::EBUSY ]\n"},{"code":"[ Errno::EPERM ]\n","err":"","out":"[1]"},{"out":"[109]","err":"","code":"[ Errno::ETOOMANYREFS ]\n"},{"out":"","err":"","code":"eval \"!(0 || 1 && (0 || 0)) && !(1 && 1)\"\n"},{"err":"","out":"[\"yes\",\"yes\",\"yes\",\"yes\"]","code":"[ eval \"qw(yes yes),\\n#no\\nqw(yes yes)\" ]\n"},{"code":"exec '/bin/cwd'; $!;\n","out":"No such file or directory","err":""},{"out":"No such file or directory","err":"","code":"exec '/bin/ls'; $!;\n"},{"code":"exec '/usr/bin/ls'; $!;\n","out":"No such file or directory","err":""},{"err":"","out":"$b$b$b","code":"$_ = '@f@f@f'; s'@f'$b'gr; \n"},{"out":"ERROR: Nested quantifiers in regex; marked by <-- HERE in m/^+++ <-- HERE ????? random shit any user can send to the bot/ at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$fl = '+++????? random shit any user can send to the bot'; my @mem_list = grep { $_ =~ /^$fl/i} 42;\n"},{"err":"","out":"0","code":"$fl = '+++ random shit any user can send to the bot'; my @mem_list = grep { $_ =~ /^$fl/i} keys %$refer;\n"},{"out":"0","err":"","code":"$fl = '+++????? random shit any user can send to the bot'; my @mem_list = grep { $_ =~ /^$fl/i} keys %$refer;\n"},{"code":"$fl = '+++????? random shit any user can send to the bot'; my @mem_list = grep { $_ =~ /^$fl/i} keys %$refer; 42\n","err":"","out":"42"},{"out":"ERROR: Can't modify postincrement (++) in preincrement (++) at (eval 558) line 1, at EOF\n","err":"","code":"++($foo++)\n"},{"out":"ERROR: Missing right curly or square bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, at EOF\n","err":"","code":"++${($foo++)\n"},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"* \"foo\" = 1;\n"},{"code":"*'foo' = 1;\n","err":"","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"[1]","err":"","code":"$foo = 1; $bar = *foo; [ $$bar ]\n"},{"code":"$foo1 = $foo2 = '4 a 2'; ( $foo1 ) = $foo1 =~ /(\\d+)/; $foo2 =~ s/\\D+//g; [ $foo1, $foo2 ]\n","out":"[4,42]","err":""},{"code":"$foo = 42; $bar = *foo; [ *$bar = sub { 53 } ]\n","err":"","out":"[*::foo]"},{"code":"$foo = 42; $bar = *foo; *$bar = sub { 53 }; $$bar;\n","err":"","out":"42"},{"code":"$foo = 42; $bar = *foo; *$bar = sub { 53 }; $bar->();\n","out":"53","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"^.\"\n","err":"","code":"'foo   ' ^. '   bar'\n"},{"err":"","out":"{foo => \"bar\",ber => undef}","code":"+{ foo => bar => 'ber' }\n"},{"code":"$foo = 'bar'; $qux = \\$foo; for $$qux (1..3) { print $foo }\n","out":"ERROR: Not a GLOB reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"123","err":"","code":"$foo = 'bar'; $qux = \\*foo; for $$qux (1..3) { print $foo }\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","code":"'foo' =~ /(?<foo>foo)/; 'bar' =~ /(ba)/; [ $+{foo} \n"},{"out":"[undef]","err":"","code":"'foo' =~ /(?<foo>foo)/; 'bar' =~ /(ba)/; [ $+{foo} ]\n"},{"err":"","out":"","code":"'foo' =~ /(?<foo>foo)/; 'bar' =~ /(ba)/; $+{foo}\n"},{"code":"\"foo\" =~ /(?<foo>foo)/; \"bar\" =~ /(ba)/; [ $+{foo} ]\n","err":"","out":"[undef]"},{"err":"","out":"foo","code":"'foo' =~ /(?<foo>foo)/; $+{foo}\n"},{"code":"'foo' =~ /.+/; 'foo' =~ s//bar/r;\n","out":"bar","err":""},{"code":"Foo->meta\n","err":"","out":"ERROR: Can't locate object method \"meta\" via package \"Foo\" (perhaps you forgot to load \"Foo\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"n","code":"'foo\\n' =~ /foo$/m ? 'y' : 'n'\n"},{"code":"'foo\\n' =~ /foo$/ ? 'y' : 'n'\n","err":"","out":"n"},{"out":"[\"bar\",\"fxx\"]","err":"","code":"[ 'foo' =~ s/foo/bar/r, 'foo' =~ tr/o/x/r ]\n"},{"code":"* \"foo\"* = sub {\"bar\"};\n","err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"*\"foo\" = sub {\"bar\"};\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"*\"foo*\" = sub {\"bar\"};\n"},{"err":"","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","code":"*\"foo*\"* = sub {\"bar\"};\n"},{"err":"","out":"foobar","code":"'foo' =~ /x.+/; 'foo' =~ s//bar/r;\n"},{"err":"","out":"a\n","code":"for (\"a\"..\"z\", \" \") { say ($_ eq \" \" ? \"SPACE\" : $_) if (/(c|a)/i && /[^MCI]/i && /[ai]/i && /[^ki\\sp]/i) }\n"},{"code":"for (\"a\"..\"z\", \" \") { say ($_ eq \" \" ? \"SPACE\" : $_) if (/(cat|a-t)/i && /[^MCI]/i && /[ai]/i && /[^ki\\sp]/i) }\n","out":"","err":""},{"out":"t\n","err":"","code":"for (\"a\"..\"z\", \" \") { say if (/[a-gn-z]/i && /[^a-ru-z]/i && /[a-ks-v]/i && /[^a-di-s]/i) }\n"},{"out":"e\n","err":"","code":"for (\"a\"..\"z\", \" \") { say if (/[a-gn-z]/i && /[d-hj-m]/i && /[^f-km-z]/i && /[^a-di-s]/i) }\n"},{"out":"","err":"","code":"for (\"a\"..\"z\", \" \") { say \" \" if (/(cat|a-t)/i && /[^MCI]/i && /[ai]/i && /[^ki\\sp]/i) }\n"},{"code":"for (\"a\"..\"z\", \" \") { say if (/(cat|a-t)/i && /[^MCI]/i && /[ai]/i && /[^ki\\sp]/i) }\n","err":"","out":""},{"code":"for (\"a\"..\"z\") { say if /[HELP\\s]/ }\n","out":"","err":""},{"code":"for (\"a\"..\"z\") { say if /[HELP\\s]/i }\n","err":"","out":"e\nh\nl\np\n"},{"code":"for (\"a\"..\"z\", \" \") { say if (/[HELP\\s]/i && /[\\sCOPE]/i && /[^SEAP]/i) }\n","err":"","out":" \n"},{"err":"","out":"","code":"for (\"a\"..\"z\") { say if (/[HELP\\s]/i && /[\\sCOPE]/i && /[^SEAP]/i) }\n"},{"out":"N\n","err":"","code":"for (\"a\"..\"z\", \" \") { say \"N\" if (/[a-gn-z]/i && /[^a-ru-z]/i && /[a-ks-v]/i && /[^a-di-s]/i) }\n"},{"out":"N\n","err":"","code":"for (\"a\"..\"z\", \" \") { say \"N\" if (/[a-gn-z]/i && /[d-hj-m]/i && /[^f-km-z]/i && /[^a-di-s]/i) }\n"},{"out":"N\n","err":"","code":"for (\"a\"..\"z\", \" \") { say \"N\" if (/[HELP\\s]/i && /[\\sCOPE]/i && /[^SEAP]/i) }\n"},{"out":"ERROR: Undefined subroutine &use 5.022001; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; for $$code (sub { print 'ok:: }) { $code->() } called at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"for $$code (sub { print 'ok' }) { $code->() }\n"},{"code":"for $$code (sub { print 'ok' }) { code() }\n","out":"ERROR: Undefined subroutine &main::code called at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"for *code (sub { print 'ok' }) { code() }\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"for *code\"\n"},{"code":"for \\$code (sub { print 'ok' }) { code() }\n","out":"ERROR: Assigned value is not a SCALAR reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"\\*code\"\n","code":"for \\*code (sub { print 'ok' }) { code() }\n"},{"code":"for \\&code (sub { print 'ok' }) { code }\n","out":"","err":""},{"code":"for \\&code (sub { print 'ok' }) { code() }\n","out":"ok","err":""},{"out":"[[[]]]","err":"","code":"for \\&code (sub { print 'ok' }) { print \"[[[$asdf]]]\" }\n"},{"err":"","out":"[[[use 5.022001; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; for $$code (sub { print 'ok' }) { print \"[[[$code]]]\" }]]]","code":"for $$code (sub { print 'ok' }) { print \"[[[$code]]]\" }\n"},{"out":"use 5.022001; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; for $$code (sub { print 'ok' }) { print $code }","err":"","code":"for $$code (sub { print 'ok' }) { print $code }\n"},{"code":"for $code (sub { print 'ok' }) { print \"[[[$code]]]\" }\n","err":"","out":"[[[CODE(0x493dde8)]]]"},{"out":"[[[use 5.022001; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; for \\&code (sub { print 'ok' }) { print \"[[[$code]]]\" }]]]","err":"","code":"for \\&code (sub { print 'ok' }) { print \"[[[$code]]]\" }\n"},{"code":"for \\&code (sub { print 'ok' }) { print code }\n","out":"","err":""},{"out":"","err":"","code":"for $$code (sub { print 'ok' }) { print ref $code }\n"},{"code":"for $*code (sub { print 'ok' }) { print ref $code }\n","out":"ERROR: syntax error at (eval 558) line 1, near \"$*code \"\n","err":""},{"out":"[code]\n","err":"","code":"for \\&code (sub { print 'ok' }) { say '[', code, ']' }\n"},{"code":"for \\&code (sub { print 'ok' }) { say code }\n","err":"","out":""},{"out":"ERROR: Missing $ on loop variable at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"for my (\"a\"..\"z\") { say if /[HELP\\s]/ }\n"},{"code":"for ( [qw/foo bar/]->@* ) { print}\n","err":"","out":"foobar"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"->*\"\n","err":"","code":"for ( [qw/foo bar/]->*@ ) { print}\n"},{"err":"","out":"0 \n1 \n1 \n0 \n","code":"for $x (0..1) {for $y (0..1) {say $x ^ $y, \" \"}}\n"},{"code":"@f{qw/sign exponent fraction/} = (unpack \"b*\",(pack \"d\", 0.1)) =~ /^(\\d)(\\d{11,11})(\\d+)$/; \\%f\n","err":"","out":"{exponent => \"10110011001\",sign => 0,fraction => \"1001100110011001100110011001100110011001110111111100\"}"},{"code":"@f{qw/sign exponent fraction/} = unpack \"b*\",(pack \"d\", 0.1) =~ /^(\\d)(\\d{11,11})(\\d+)$/; \\%f\n","err":"","out":"{sign => \"\",exponent => undef,fraction => undef}"},{"code":" 'get http://ignorantdesigner.com/japh.html' =~ y â» a-z:/ â» n-za-m|â»r \n","err":"","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂ» n-za-m|ÃÂ¢<-- HERE near column 162 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":" 'get http://ignorantdesigner.com/japh.html' =~ y â¢ a-z:/ â¢ n-za-m â»â¢r \n","err":"","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂ¢ n-za-m ÃÂ¢<-- HERE near column 162 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":" 'get http://ignorantdesigner.com/japh.html' =~ y â¢ a-z:/ â¢ n-za-m â¢r \n","err":"","out":"ERROR: Unrecognized character \\x80; marked by <-- HERE after ÃÂ¢ n-za-m ÃÂ¢<-- HERE near column 162 at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂÃÂ¢ n-za-mÃÂ¢<-- HERE near column 161 at (eval 558) line 1, <STDIN> line 1.\n","code":" 'get http://ignorantdesigner.com/japh.html' =~ y â¢ a-z:/ â¢ n-za-mâ â¢r \n"},{"out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂ» n-za-m|ÃÂ¢<-- HERE near column 161 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":" 'get http://ignorantdesigner.com/japh.html' =~ yâ» a-z:/ â» n-za-m|â»r \n"},{"code":" 'get http://ignorantdesigner.com/japh.html' =~ yâ»a-z:/â»n-za-m|â»r \n","err":"","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂÃÂ»n-za-m|ÃÂ¢<-- HERE near column 158 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":" 'get http://ignorantdesigner.com/japh.html' =~ yâ»a-z:/â»n-za-m.|â»r \n","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂ»n-za-m.|ÃÂ¢<-- HERE near column 159 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":" [ 'get http://ignorantdesigner.com/japh.html' =~ y â¢ a-z: â¢ n-za-m â¢r ]\n","err":"","out":"ERROR: Unrecognized character \\x80; marked by <-- HERE after ÃÂ¢ n-za-m ÃÂ¢<-- HERE near column 163 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":" [ 'get http://ignorantdesigner.com/japh.html' =~ y â¢ a-z:/ â¢ n-za-mâ â¢r ]\n","err":"","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂÃÂ¢ n-za-mÃÂ¢<-- HERE near column 163 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"[ 'get http://ignorantdesigner.com/japh.html' =~ y â¢ a-z: â¢ n-za-m â¢ r ]\n","err":"","out":"ERROR: Unrecognized character \\x80; marked by <-- HERE after ÃÂ¢ n-za-m ÃÂ¢<-- HERE near column 163 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"[ 'get http://ignorantdesigner.com/japh.html' =~ y/a-z/n-za-m/r ]\n","err":"","out":"[\"trg uggc://vtabenagqrfvtare.pbz/wncu.ugzy\"]"},{"code":" 'get http://ignorantdesigner.com/japh.html' =~ yâ»a-z:/â»n-za-mX|â»r \n","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂ»n-za-mX|ÃÂ¢<-- HERE near column 159 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"1","err":"","code":"'.gitattributes' eq '.gitattributes'\n"},{"code":"[ glob '{a,b,c}' ]\n","out":"[\"a\",\"b\",\"c\"]","err":""},{"code":"[grep {$_ !~ /(.)\\1/} glob \"{a,v,p,r}{a,v,p,r}\"]\n","err":"","out":"[\"av\",\"ap\",\"ar\",\"va\",\"vp\",\"vr\",\"pa\",\"pv\",\"pr\",\"ra\",\"rv\",\"rp\"]"},{"code":"[ grep /cc/i, keys \\%INC ]\n","out":"[\"Moose/Meta/Method/Accessor/Native/Array/Writer.pm\",\"Moose/Meta/Method/Accessor/Native/Array.pm\",\"Moose/Meta/Method/Accessor/Native.pm\",\"Moose/Meta/Method/Accessor/Native/Array/push.pm\",\"Moose/Meta/Method/Accessor/Native/Array/elements.pm\",\"Moose/Meta/Method/Accessor/Native/Counter/dec.pm\",\"Moose/Meta/Method/Accessor/Native/Reader.pm\",\"Moose/Meta/Method/Accessor.pm\",\"Regexp/Common/CC.pm\",\"Moose/Meta/Method/Accessor/Native/Array/unshift.pm\",\"Class/MOP/Method/Accessor.pm\",\"Moose/Meta/Method/Accessor/Native/Counter/inc.pm\",\"Moose/Meta/Method/Accessor/Native/Array/count.pm\",\"Moose/Meta/Method/Accessor/Native/Writer.pm\",\"Moose/Meta/Method/Accessor/Native/Collection.pm\"]","err":""},{"out":"[\"Regexp/Common/CC.pm\"]","err":"","code":"[ grep /CC/, keys \\%INC ]\n"},{"code":"[ grep /cgi/i, keys \\%INC ]\n","err":"","out":"[]"},{"err":"","out":"[\"File/Spec.pm\",\"File/Spec/Functions.pm\",\"File/Glob.pm\",\"PPI/Document/File.pm\",\"Regexp/Common/URI/file.pm\",\"File/Basename.pm\",\"File/Find.pm\",\"File/Spec/Unix.pm\"]","code":"[ grep /file/i, keys \\%INC ]\n"},{"err":"","out":"[]","code":"[grep {/Foo/} keys %INC]\n"},{"err":"","out":"0","code":"grep {/Foo/} keys %INC\n"},{"code":"[ grep { length($_) == 1 and $_ ne 0 } map - - chr, 0..255 ]\n","out":"[\"+\",\"-\",1,2,3,4,5,6,7,8,9]","err":""},{"out":"[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,91,92,93,94,96,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255]","err":"","code":"[ grep { length(- - chr) == 1 } 0..255 ]\n"},{"code":"[ grep { length(- - chr) == 1 } 0..255; ]\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":""},{"code":"[ grep m|^http://(?!.*avatar)|, qw( http://assets.tumblr.com/images/default_avatar/octahedron_open_48.png http://assets.tumblr.com/images/default_avatar/cube_closed_48.png http://40.media.tumblr.com/b3e62ef833996a4ffb544ed37300807d/tumblr_nlf8czGMpJ1s61cido1_500.jpg http://40.media.tumblr.com/c0e108161497f351e40db139289b3818/tumblr_nldblnzio71s61cido1_500.jpg ) ]\n","err":"","out":"[\"http://40.media.tumblr.com/b3e62ef833996a4ffb544ed37300807d/tumblr_nlf8czGMpJ1s61cido1_500.jpg\",\"http://40.media.tumblr.com/c0e108161497f351e40db139289b3818/tumblr_nldblnzio71s61cido1_500.jpg\"]"},{"err":"","out":"[\"http://default_avatar/octa\"]","code":"[ grep m|^http://(?=.*avatar)|, qw( http://default_avatar/octa  http://40.media ) ]\n"},{"code":"[ grep m|^http://(?!.*?avatar)|, qw( http://default_avatar/octa  http://40.media ) ]\n","out":"[\"http://40.media\"]","err":""},{"out":"[\"http://40.media\"]","err":"","code":"[ grep m|^http://(?!.*avatar)|, qw( http://default_avatar/octa  http://40.media ) ]\n"},{"code":"grep { $_ ne 0 } map - - chr, 0..255\n","err":"","out":"64"},{"out":"ERROR: syntax error at (eval 558) line 1, near \";print\"\n","err":"","code":"$h={a=>1, v=>2}; {av =>{;print 1}, ap=>, ar=>, pv=>, rv=>, pr=>sub{}}\n"},{"code":"$h={a=>1, v=>2}; sub calc {my %h=@_;my ($a,$v,$p,$r)=@h{qw/a v p r/};  {av =>sub {$r=$v/$a;$p=$v*$a}, ap=>sub{$v=$p/$a;$r=$v/$a}, ar=>sub{$v=$r*$a;$p=$a*$v}, pv=>sub{$a=$p/$v;$r=$v/$a}, rv=>sub{$a=$v*$r}, pr=>sub{$a=sqrt($p/$r);$v=$p/$a}}};\n","err":"","out":"{v => 2,a => 1}"},{"code":"$h={a=>1, v=>2}; sub calc {my %h=@_;my ($a,$v,$p,$r)=@h{qw/a v p r/};  {av =>sub {$r=$v/$a;$p=$v*$a}, ap=>sub{$v=$p/$a;$r=$v/$a}, ar=>sub{$v=$r*$a;$p=$a*$v}, pv=>sub{$a=$p/$v;$r=$v/$a}, rv=>sub{$a=$v*$r;$p=$v*$a}, pr=>sub{$a=sqrt($p/$r);$v=$p/$a}}};\n","err":"","out":"{a => 1,v => 2}"},{"out":"[1,2,2,2]","err":"","code":"$h={a=>1, v=>2}; sub calc {my %h=@_;my ($a,$v,$p,$r)=@h{qw/a v p r/}; my $c=join '', sort keys %h; {av =>sub {$r=$v/$a;$p=$v*$a}, ap=>sub{$v=$p/$a;$r=$v/$a}, ar=>sub{$v=$r*$a;$p=$a*$v}, pv=>sub{$a=$p/$v;$r=$v/$a}, rv=>sub{$a=$v*$r;$p=$v*$a}, pr=>sub{$a=sqrt($p/$r);$v=$p/$a}}->{$c}->(); [$a, $v, $r, $p]}; calc %$h\n"},{"code":"$h={a=>1, v=>2}; sub calc {my %h=@_;my ($a,$v,$p,$r)=@h{qw/a v p r/}; my $c=sort keys %h; {av =>sub {$r=$v/$a;$p=$v*$a}, ap=>sub{$v=$p/$a;$r=$v/$a}, ar=>sub{$v=$r*$a;$p=$a*$v}, pv=>sub{$a=$p/$v;$r=$v/$a}, rv=>sub{$a=$v*$r;$p=$v*$a}, pr=>sub{$a=sqrt($p/$r);$v=$p/$a}}->{$c}->(); [$a, $v, $r, $p]}\n","out":"{v => 2,a => 1}","err":""},{"out":"ERROR: Can't use an undefined value as a subroutine reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$h={a=>1, v=>2}; sub calc {my %h=@_;my ($a,$v,$p,$r)=@h{qw/a v p r/}; my $c=sort keys %h; {av =>sub {$r=$v/$a;$p=$v*$a}, ap=>sub{$v=$p/$a;$r=$v/$a}, ar=>sub{$v=$r*$a;$p=$a*$v}, pv=>sub{$a=$p/$v;$r=$v/$a}, rv=>sub{$a=$v*$r;$p=$v*$a}, pr=>sub{$a=sqrt($p/$r);$v=$p/$a}}->{$c}->(); [$a, $v, $r, $p]}; calc %$h\n"},{"out":"2","err":"","code":"%h = ( -desc => 'created_at' ); \n"},{"code":"%h = ( -desc => 'created_at' ); \\%h\n","err":"","out":"{\"-desc\" => \"created_at\"}"},{"code":"hex 0x255\n","out":"1431","err":""},{"out":"296","err":"","code":"hex 0x80\n"},{"err":"","out":"256","code":"hex 100\n"},{"code":"hex 255\n","out":"597","err":""},{"code":"\"hi \".(v0.01)\n","err":"","out":"hi \u0000\u0001"},{"err":"","out":"hi \u0000\u0001","code":"\"hi \".(v0.1)\n"},{"err":"","out":"","code":"$holyshit < 0\n"},{"code":"<- htmleval\n","err":"","out":"ERROR: Unterminated <> operator at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"[\"1J2KAFHQk_.jpg\"]","code":" [ 'http://go2web4free.com:7004/img/users/1/1J2KAFHQk_.jpg' =~ m{[^/]+$}g ]\n"},{"code":" 'http://ignorantdesigner.com/japh.html' =~ yâ»a-z:/â»n-za-m|â»r \n","err":"","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂÃÂ»n-za-m|ÃÂ¢<-- HERE near column 154 at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂ»n-za-m.|ÃÂ¢<-- HERE near column 155 at (eval 558) line 1, <STDIN> line 1.\n","code":" 'http://ignorantdesigner.com/japh.html' =~ yâ»a-z:/â»n-za-m.|â»r \n"},{"err":"","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂ»n-za-mX|ÃÂ¢<-- HERE near column 155 at (eval 558) line 1, <STDIN> line 1.\n","code":" 'http://ignorantdesigner.com/japh.html' =~ yâ»a-z:/â»n-za-mX|â»r \n"},{"err":"","out":"ERROR: Can't use an undefined value as a subroutine reference at (eval 558) line 1, <STDIN> line 1.\n","code":"h->{two}();  sub h { +{ one => sub { 1 }, two => sub { 2 } } } \n"},{"code":"h()->{two}();  sub h { +{ one => sub { 1 }, two => sub { 2 } } } \n","err":"","out":"2"},{"err":"","out":"ERROR: Usage: UNIVERSAL::can(object-ref, method) at (eval 558) line 1, <STDIN> line 1.\n","code":"huf->can(\"can\")->()\n"},{"code":"huf->can(\"can\")->can\n","err":"","out":"ERROR: Can't call method \"can\" on unblessed reference at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Usage: UNIVERSAL::can(object-ref, method) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"huf->can(\"can\")->(\"can\")->(\"can\")->(\"can\")->(\"can\")->(\"can\")\n"},{"code":"huf->can(\"can\")->(huf => \"can\")\n","out":"sub { \"DUMMY\" }","err":""},{"err":"","out":"sub { \"DUMMY\" }","code":"huf->can(\"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")->(huf => \"can\")\n"},{"code":"$^I\n","out":"","err":""},{"code":"if ( '0.00' ) { say \"foo\" }\n","out":"foo\n","err":""},{"code":"if ( 0.00 ) { say \"foo\" }\n","out":"0","err":""},{"code":"if (1 ) { last; print \"lols\"; } print \"lulz\"\n","out":"","err":""},{"out":"lelz","err":"","code":"{ if (1 ) { last; print \"lols\"; } print \"lulz\"; } print \"lelz\"; \n"},{"code":"if('besaid' =~ m/(\\w*said)/) {print qq{matched \"$1\"\\n};} \n","err":"","out":"matched \"besaid\"\n"},{"code":"if ( $x = \"\\0\" ) { print 1 }\n","err":"","out":"1"},{"code":"if ( $x = \"x\\b\" ) { print \"_${x}_\" }\n","err":"","out":"_x\b_"},{"err":"","out":"_","code":"if ( $x = \"x\\b\" ) { print \"_$x_\" }\n"},{"code":"Im a little teapot\n","err":"","out":"ERROR: Can't locate object method \"little\" via package \"teapot\" (perhaps you forgot to load \"teapot\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"[ $INC{'strict.pm'} ]\n","err":"","out":"[\"/home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/strict.pm\"]"},{"code":"inf\n","err":"","out":"bless( {sign => \"+inf\",_a => undef,value => [0],_p => undef}, 'Math::BigInt' )"},{"code":"+Inf\n","err":"","out":"Inf"},{"out":"{}","err":"","code":"\\%ISA;\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"is [\"\n","code":"is [fact htmleval [arg]]  \n"},{"out":"[\"\"]","err":"","code":"[join '']\n"},{"out":"freenode.net\u001d#regex\u001dre101","err":"","code":"join \"\\035\", qw/freenode.net #regex re101/\n"},{"code":"$_ = join '', 'a'..'y'; tr<acegikmoqsuwybdfhjlnprtvx><Just another Sort hacker,>; print\n","err":"","out":"JSuosrtt  ahnaoctkheerr, "},{"code":"$_ = join '', 'a'..'y'; tr<acegikmoqsuwybdfhjlnprtvx><Just another Sort hacker,>; print \"[$_]\"\n","out":"[JSuosrtt  ahnaoctkheerr, ]","err":""},{"out":"ruJt tc,en hoetokarrasS h","err":"","code":"$_ = join '', 'a'..'y'; tr/cbvokujpfynsewmtdxlrgqiah/Just another Sort hacker,/; print\n"},{"code":"[ (join '', 'a'..'y') =~ tr/sdyckamijgqbhtrfwuelnpovx/Just another :8() hacker,/r ]\n","out":"[\"artuh(h ot anceke8J: r),s\"]","err":""},{"code":"[ (join '', 'a'..'y') =~ tr/sdyckamijgqbhtrfwuelnpovx/Just another sort hacker,/ ]\n","err":"","out":"ERROR: Can't modify join or string in transliteration (tr///) at (eval 558) line 1, near \"tr/sdyckamijgqbhtrfwuelnpovx/Just another sort hacker,/ ]\"\n"},{"code":"[ (join '', 'a'..'y') =~ tr/sdyckamijgqbhtrfwuelnpovx/Just another sort hacker,/r ]\n","err":"","out":"[\"artuhrh ot ancekeoJs rt,s\"]"},{"err":"","out":"J,ursetk cAanHo tIhDeIrB /Pler","code":"$_ = join '', 'a'..'z', 0..3; tr!acegikmoqsuwy0231zxvtrpnljhfdb!Just Another Perl/BIDI Hacker,!; print\n"},{"code":"$_ = join '', 'a'..'z', 0..3; tr/acegikmoqsuwy0231zxvtrpnljhfdb/Just Another Perl/BIDI Hacker,/; print\n","err":"","out":"ERROR: Search pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"bceghijklmnopqrtuvwxyz","code":"$_ = join '', 'a'..'z'; $_ =~ tr/434dfddsaaaaa//d; $_\n"},{"code":"$_ = join '', 'a'..'z'; $_ =~ tr/434dfdds//d; $_\n","err":"","out":"abceghijklmnopqrtuvwxyz"},{"err":"","out":"[\"rJust anekocath ehder oUcin\"]","code":"$_ = join('', 'a'..'z','_'); tr/bcdefghknrtuvx_zywsqpomljifa/Just another Unicode hacker/; [ $_  ]\n"},{"out":"","err":"","code":"$_ = join '', 'a'..'z'; $_ =~ tr/JwG7IpBbAFr4tyoVbbECZ26HYml 5QdDjLicbhUTdvWIzsnOuRTfE9ahgam2EkDqgVSXpUNGCPID KW exU7M//d; $_\n"},{"code":"[ join \"\", map +{}, 1..10 ]\n","err":"","out":"[\"HASH(0x5e84548)HASH(0x5e845f0)HASH(0x5e845c0)HASH(0x5e84578)HASH(0x4c8f4c8)HASH(0x5b81038)HASH(0x5b81008)HASH(0x5b81050)HASH(0x5b81098)HASH(0x5b81080)\"]"},{"out":"","err":"","code":"join('_', map {lc} grep {length} split /([A-Z]{1}[^A-Z]*)/)\n"},{"err":"","out":"[\"Hello World\\342\\230\\203 \"]","code":"[ join '', map { pack \"c\", $_ } 72,101,108,108,111,32,87,111,114,108,100,-30,-104,-125,32]\n"},{"code":"[join '|', map ref, \\*f, +{}, [], qr//,  \\'', sub{}, \\substr(\\$x, 0, 0), \\\\\"\", \\*STDOUT{FORMAT}, \\*STDIN{IO}, \\v5.10.0 ]\n","err":"","out":"[\"GLOB|HASH|ARRAY|Regexp|SCALAR|CODE|LVALUE|REF|SCALAR|REF|VSTRING\"]"},{"err":"","out":"CamelCaseXmlparser","code":"join '', map { ucfirst lc } 'CamelCaseXMLParser' =~ /([A-Z]+[^A-Z]*)/g;\n"},{"err":"","out":"CamelCaseXmlparser","code":"join '', map { ucfirst lc } split /([A-Z]+[^A-Z]*)/, 'CamelCaseXMLParser';\n"},{"code":"join '', map { ucfirst lc } split /([A-Z]+[^A-Z]*)/i, 'CamelCaseXMLParser';\n","out":"Camelcasexmlparser","err":""},{"code":"join '', map {; \"\\x03\".int(rand 16).\",\".int(rand 16).\"X\" } 0..20;\n","out":"\u000311,4X\u00036,15X\u000315,1X\u000314,11X\u000314,7X\u00030,8X\u000310,12X\u00036,1X\u00039,3X\u000314,2X\u000314,7X\u000315,2X\u00033,14X\u00031,9X\u00034,2X\u000314,1X\u000311,5X\u000311,3X\u00030,10X\u000312,13X\u00033,1X","err":""},{"err":"","out":"[\"cbdafeghjiklnmoprqstvuwxy\"]","code":"[join '', sort {$|--} a..'y']\n"},{"code":"[join '', sort {$|--} split //, \"suJta nohterP er lhakcer,\"]\n","out":"[\"Juts another Perl hacker,\"]","err":""},{"code":"[join '', sort {$|--} split //, \"sutJa nohterP er lhakcer,\"]\n","err":"","out":"[\"tuJs another Perl hacker,\"]"},{"out":"[\"Just another Perl hacker,\"]","err":"","code":"[join '', sort {$|--} split //, \"tuJsa nohterP er lhakcer,\"]\n"},{"code":"[ join \":\", split /../, '000202056D4C' ]\n","out":"[\"\"]","err":""},{"err":"","out":"[\"00:0:2:0:2:0:5:6:D:4:C\"]","code":"[ join \":\", split /(?<=..)/, '000202056D4C' ]\n"},{"code":"[ join \":\", split /(?=..)/, '000202056D4C' ]\n","out":"[\"0:0:0:2:0:2:0:5:6:D:4C\"]","err":""},{"out":"[\":00::02::02::05::6D::4C\"]","err":"","code":"[ join \":\", split /(..)/, '000202056D4C' ]\n"},{"out":"","err":"","code":"join \":\", split /../, '000202056D4C'\n"},{"code":"[ join \":\", split /(?=\\w{2])/, '000202056D4C' ]\n","out":"[\"000202056D4C\"]","err":""},{"out":"[\"0:0:0:2:0:2:0:5:6:D:4C\"]","err":"","code":"[ join \":\", split /(?=\\w{2})/, '000202056D4C' ]\n"},{"err":"","out":"[\"\"]","code":"[join '', undef]\n"},{"code":"[ JSON() ]\n","out":"ERROR: Undefined subroutine &main::JSON called at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"[\"encode_json\",\"decode_json\",\"JSON\"]","code":"\\@JSON::MaybeXS::EXPORT\n"},{"out":"0","err":"","code":"keys( {} ) = 42\n"},{"code":"[keys %DB:: ]\n","err":"","out":"[\"sub\",\"args\"]"},{"code":"'knbZw6mW5RGbCQksNDg64g==' =~ /([\\w=]{12,30})/\n","out":"1","err":""},{"code":"length @{[10]}\n","out":"1","err":""},{"out":"18","err":"","code":"length 'barbarbarbarbarbar'\n"},{"err":"","out":"[28]","code":"[ length 'bcdefghknrtuvx_zywsqpomljifa' ]\n"},{"err":"","out":"","code":"length $holyshit < 0\n"},{"err":"","out":"[30]","code":"[length \"Just Another Perl/BIDI Hacker,\"];\n"},{"code":"[length \"Just another perl hacker,\"]\n","err":"","out":"[25]"},{"out":"[27]","err":"","code":"[ length \"Just another Unicode hacker\" ]\n"},{"out":"27","err":"","code":"length \"Just another Unicode hacker\"\n"},{"code":"length q|\t|\n","out":"1","err":""},{"out":"78","err":"","code":"length q|\"Added note that raw license copy/paste needs modification of copyright owner\"|\n"},{"err":"","out":"398","code":"length q|Croatia [Zagreb], Czechia [Brno Prague], Denmark [Aarhus Copenhagen], Equatorial Guinea [Bata Malabo], France [Lyon Marseille Nice Paris Toulouse], Gabon [Libreville Port-Gentil], Germany [Berlin Cologne Essen Frankfurt Hamburg Munich Stuttgart], Gibraltar, Hungary [Budapest Debrecen], Italy [Milan Naples Palermo Rome Turin], Liechtenstein, Luxembourg, Macedonia [Bitola Skopje], Malta [Valletta]|\n"},{"code":"length q|Happy New Year to Albania [DurrÃ«s Tirana], Algeria [Algiers Boumerdas Oran], Andorra, Angola [Luanda N'dalatando], Austria [Graz Vienna], Belgium [Antwerp Brussels], Benin [Abomey-Calavi Porto-Novo], Bosnia and Herzegovina [Sarajevo], Cameroon [Douala YaoundÃ©], Central African Republic [Bangui Bimbo], Chad [Moundou N'Djamena], Congo-Brazzaville [Brazzaville Pointe-Noire], Congo-Kinshasa [Kikwit Kinshas|\n","err":"","out":"407"},{"out":"68","err":"","code":"length q|\tif ( !$ok and $@=~/^SKIP:.+BEGIN failed--compilation aborted/si ) {|\n"},{"err":"","out":"ERROR: Can't find string terminator \"#\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","code":"length q# mojobar.removeClass('animated');\n"},{"out":"84","err":"","code":"length q# mojobar.removeClass('animated').css({'position': 'absolute', 'top': start + 'px'});#\n"},{"code":"length q|See C<< ->new >> method for mo|\n","out":"30","err":""},{"code":"$l = \"foos\" . chr(0x220); [ $l & chr(0x80)x(length $l) ]\n","out":"[\"\\0\\0\\0\\0\\0\"]","err":""},{"out":"[\"\\0\\0\\0\\0\\200\"]","err":"","code":"$l = \"foos\" . chr(0xFA); [ $l & chr(0x80)x(length $l) ]\n"},{"code":"$l = \"foos\"; [ $l & chr(0x80)x(length $l) ]\n","out":"[\"\\0\\0\\0\\0\"]","err":""},{"code":"$l = \"fooso\"; [ $l & chr(0x80)x(length $l) ]\n","err":"","out":"[\"\\0\\0\\0\\0\\0\"]"},{"code":"\\%LoadAllMooseXDeclare::\n","out":"{BEGIN => *LoadAllMooseXDeclare::BEGIN,can => *LoadAllMooseXDeclare::can,ISA => *LoadAllMooseXDeclare::ISA,meta => *LoadAllMooseXDeclare::meta,isa => *LoadAllMooseXDeclare::isa}","err":""},{"code":"local $/ = 'd'; print \"abc\"\n","out":"abc","err":""},{"err":"","out":"abcd","code":"local $\\ = 'd'; print \"abc\"\n"},{"code":"local $/ = $\\; print \"abc\"\n","out":"abc","err":""},{"code":"local $\\ = $/; print \"abc\"\n","err":"","out":"abc\n"},{"code":"[ log(1e205 / 1e192)/log 10 ]\n","out":"[13]","err":""},{"err":"","out":"[\"43.1850652335357\"]","code":"[ log(1e205 / 1e192)/log 2 ]\n"},{"err":"","out":"12.0411998265592","code":"log(2**40)/log(10)\n"},{"code":"$long_var_blah = 42;  $my_pay = $long_var_b1ah * 1000; print \"I'm fucking rich, I got $my_pay!\";\n","err":"","out":"I'm fucking rich, I got 0!"},{"out":"[\"main\"]","err":"","code":"[ main:: ]\n"},{"out":"bless( {}, 'Foo' )","err":"","code":"*main::bless = sub { print \"foo\" }; bless {}, 'Foo';\n"},{"out":"ERROR: Can't locate object method \"foo\" via package \"main\" at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"main->foo\n"},{"err":"","out":"ERROR: Can't locate object method \"foo\" via package \"main\" at (eval 558) line 1, <STDIN> line 1.\n","code":"main->foo;\n"},{"code":"[ *main::{JSON} ]\n","out":"[undef]","err":""},{"err":"","out":"","code":"*main::{JSON}\n"},{"code":"[ *main::JSON{CODE} ]\n","out":"[undef]","err":""},{"code":"[ map [ $_+0, $_ ], Scalar::util::dualvar 6*9, '42 (base 13)' ]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"Scalar::util::dualvar 6\"\n","err":""},{"out":"[[54,\"42 (base 13)\"]]","err":"","code":"[ map [ $_+0, $_ ], Scalar::Util::dualvar 6*9, '42 (base 13)' ]\n"},{"out":"[\"args\",[],\"sub\",undef]","err":"","code":"[map --$| ? *{$_}{ARRAY} : $_, %DB:: ]\n"},{"out":"[\"H\",\"e\",\"l\",\"l\",\"o\",\" \",\"W\",\"o\",\"r\",\"l\",\"d\",\"\\342\",\"\\230\",\"\\203\",\" \"]","err":"","code":"[map chr, 72,101,108,108,111,32,87,111,114,108,100,226,152,131,32]\n"},{"out":"[\"args\",undef,\"sub\",undef]","err":"","code":"[map --$| ? *{$_}{CODE} : $_, %DB:: ]\n"},{"err":"","out":"[undef,*DB::sub,undef,*DB::args]","code":"[map --$| ? $_ : $$_, %DB:: ]\n"},{"code":"[map --$| ? $$_ : $_, %DB:: ]\n","err":"","out":"[\"args\",undef,\"sub\",undef]"},{"code":"[map --$| ? \\%$_ : $_, %DB:: ]\n","err":"","out":"[\"args\",{},\"sub\",{}]"},{"code":"[map { - - $_ } map chr, 0..255]\n","out":"[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\"+\",0,\"-\",0,0,0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,\"+A\",\"+B\",\"+C\",\"+D\",\"+E\",\"+F\",\"+G\",\"+H\",\"+I\",\"+J\",\"+K\",\"+L\",\"+M\",\"+N\",\"+O\",\"+P\",\"+Q\",\"+R\",\"+S\",\"+T\",\"+U\",\"+V\",\"+W\",\"+X\",\"+Y\",\"+Z\",0,0,0,0,\"+_\",0,\"+a\",\"+b\",\"+c\",\"+d\",\"+e\",\"+f\",\"+g\",\"+h\",\"+i\",\"+j\",\"+k\",\"+l\",\"+m\",\"+n\",\"+o\",\"+p\",\"+q\",\"+r\",\"+s\",\"+t\",\"+u\",\"+v\",\"+w\",\"+x\",\"+y\",\"+z\",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"},\"\n","code":"[map { - - $_ }, map chr, 0..255]\n"},{"err":"","out":"[98,110,106,117,118,103]","code":"[ map ord,  'b' => 'n', 'j' => 'u', 'v' => 'g' ]\n"},{"out":"[32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32]","err":"","code":"[ map ord, split //, '                                                     ' ]\n"},{"code":"map ord, split //, '                                                     \n","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"map ord, split //, '                                                     '\n","err":"","out":"53"},{"code":"[map ord, split //, \"Hello Worldâ \"]\n","err":"","out":"[72,101,108,108,111,32,87,111,114,108,100,226,152,131,32]"},{"out":"[\"H\",\"e\",\"l\",\"l\",\"o\",\" \",\"W\",\"o\",\"r\",\"l\",\"d\",\"\\342\",\"\\230\",\"\\203\",\" \"]","err":"","code":"[map { pack \"c\", $_ } 72,101,108,108,111,32,87,111,114,108,100,-30,-104,-125,32]\n"},{"out":"[]","err":"","code":"[map pack \"c\", 72,101,108,108,111,32,87,111,114,108,100,-30,-104,-125,32]\n"},{"code":"[map {rand * 10} 1..10]\n","err":"","out":"[\"0.186651562663855\",\"0.526996290582371\",\"0.649898608770805\",\"0.947815047006845\",\"0.364433480877764\",\"0.470683192738161\",\"0.239514876430881\",\"0.896803131783972\",\"0.397553323826969\",\"0.181011651658803\"]"},{"err":"","out":"[\"9.75604317939968\",\"8.66619265443784\",\"7.86139857113945\",\"4.52222740173131\",\"5.47946252845563\",\"1.81052668389693\",\"3.62575608113808\",\"2.37510430617849\",\"3.14364196325869\",\"3.01705231440604\"]","code":"[map {rand() * 10} 1..10]\n"},{"code":"[ map ref, \\1, [], {}, sub{}, qr//,  ]\n","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\"]","err":""},{"err":"","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"GLOB\"]","code":"[ map ref, \\1, [], {}, sub{}, qr//, \\*CORE::substr ]\n"},{"err":"","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"CODE\"]","code":"[ map ref, \\1, [], {}, sub{}, qr//, \\&CORE::substr ]\n"},{"err":"","out":"ERROR: Not enough arguments for substr at (eval 558) line 1, near \"CORE::substr ]\"\n","code":"[ map ref, \\1, [], {}, sub{}, qr//, \\CORE::substr ]\n"},{"code":"[ map ref, \\1, [], {}, sub{}, qr//, &CORE::substr ]\n","out":"ERROR: Not enough arguments for substr at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"[ map ref, \\1, [], {}, sub{}, qr//, \\(pos) ]\n","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"LVALUE\"]","err":""},{"code":"[ map ref, \\1, [], {}, sub{}, qr//, \\(pos),  ]\n","err":"","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"LVALUE\"]"},{"code":"[ map ref, \\1, [], {}, sub{}, qr//, \\pos,  ]\n","err":"","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"LVALUE\"]"},{"err":"","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"LVALUE\",\"VSTRING\"]","code":"[ map ref, \\1, [], {}, sub{}, qr//, \\pos, \\v1.2  ]\n"},{"err":"","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"CODE\"]","code":"[ map ref, \\1, [], {}, sub{}, qr//, sub :lvalue{} ]\n"},{"code":"[ map ref, \\1, [], {}, sub{}, qr//, \\&substr ]\n","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"CODE\"]","err":""},{"code":"[ map ref, \\1, [], {}, sub{}, qr//, \\substr ]\n","err":"","out":"ERROR: Not enough arguments for substr at (eval 558) line 1, near \"substr ]\"\n"},{"code":"[ map ref, \\1, [], {}, sub{}, qr//, substr ]\n","err":"","out":"ERROR: Not enough arguments for substr at (eval 558) line 1, near \"substr ]\"\n"},{"code":"[ map ref, \\1, [], {}, sub{}, qr//, substr() ]\n","err":"","out":"ERROR: Not enough arguments for substr at (eval 558) line 1, near \"substr() \"\n"},{"code":"[ map ref, \\1, [], {}, sub{}, qr//, substr($_) ]\n","err":"","out":"ERROR: Not enough arguments for substr at (eval 558) line 1, near \"$_) \"\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \") ]\"\n","code":"[ map ref, \\1, [], {}, sub{}, qr//, \\(substr($_,1) ]\n"},{"out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"LVALUE\"]","err":"","code":"[ map ref, \\1, [], {}, sub{}, qr//, \\(substr($_,1)) ]\n"},{"out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"\"]","err":"","code":"[ map ref, \\1, [], {}, sub{}, qr//, substr($_, 1) ]\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \") ]\"\n","err":"","code":"[ map ref, \\1, [], {}, sub{}, qr//, \\(substr($_,1,1) ]\n"},{"code":"[ map ref, \\1, [], {}, sub{}, qr//, substr($_, 1)=1 ]\n","out":"ERROR: substr outside of string at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"[map ref, \\*f, +{}, [], qr//,  \\'',  ]\n","err":"","out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\"]"},{"code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, \\\\\"\" ]\n","err":"","out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\",\"CODE\",\"REF\"]"},{"err":"","out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\",\"CODE\",\"CODE\"]","code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, sub:lvalue{}, ]\n"},{"err":"","out":"ERROR: Not enough arguments for substr at (eval 558) line 1, near \"''  ]\"\n","code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, substr ''  ]\n"},{"code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, substr(), ]\n","out":"ERROR: Not enough arguments for substr at (eval 558) line 1, near \"substr()\"\n","err":""},{"code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, substr(),\\  ]\n","err":"","out":"ERROR: Not enough arguments for substr at (eval 558) line 1, near \"substr()\"\nsyntax error at (eval 558) line 1, near \"\\  ]\"\n"},{"err":"","out":"ERROR: Not enough arguments for substr at (eval 558) line 1, near \"substr()\"\nsyntax error at (eval 558) line 1, near \"\\ ]\"\n","code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, substr(),\\ ]\n"},{"out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\",\"CODE\",\"\"]","err":"","code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, substr(\\$x, \"\", \"\", \"\"), ]\n"},{"code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, \\substr(\\$x, 0, 0), ]\n","err":"","out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\",\"CODE\",\"LVALUE\"]"},{"code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, \\substr(\\$x, 0, 0), \\\\\"\" ]\n","err":"","out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\",\"CODE\",\"LVALUE\",\"REF\"]"},{"code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, substr(\\$x, 0, 0), ]\n","err":"","out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\",\"CODE\",\"\"]"},{"code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, substr(\\$x, 0, 0, 0, 0), ]\n","err":"","out":"ERROR: Too many arguments for substr at (eval 558) line 1, near \"0)\"\n"},{"code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, (substr(\\$x, 0, 0, 0) = \"foo\"), ]\n","err":"","out":"ERROR: Can't modify substr in scalar assignment at (eval 558) line 1, near \"\"foo\")\"\n"},{"code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, substr(\\$x, 0, 0, 0) = \"foo\", ]\n","err":"","out":"ERROR: Can't modify substr in scalar assignment at (eval 558) line 1, near \"\"foo\",\"\n"},{"out":"ERROR: Assigned value is not a reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, (substr(\\$x, 0, 0) = \"foo\"), ]\n"},{"code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, \\substr(\\$x, 0, 0), \\\\\"\", *STDOUT{FORMAT} ]\n","out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\",\"CODE\",\"LVALUE\",\"REF\",\"\"]","err":""},{"code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, \\substr(\\$x, 0, 0), \\\\\"\", *STDOUT{FORMAT}, *STDIN{IO} ]\n","out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\",\"CODE\",\"LVALUE\",\"REF\",\"\",\"IO::File\"]","err":""},{"code":"[map ref, \\*f, +{}, [], qr//,  \\'', sub{}, \\substr(\\$x, 0, 0), \\\\\"\", \\*STDOUT{FORMAT}, \\*STDIN{IO}, \\v5.10.0 ]\n","err":"","out":"[\"GLOB\",\"HASH\",\"ARRAY\",\"Regexp\",\"SCALAR\",\"CODE\",\"LVALUE\",\"REF\",\"SCALAR\",\"REF\",\"VSTRING\"]"},{"code":"[map +ref, \\*, {}, [], qr//,  \\'',  ]\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":"","code":"[map ref, \\*, {}, [], qr//,  \\'',  ]\n"},{"err":"","out":"[\"\",\"ARRAY\",\"Regexp\",\"SCALAR\"]","code":"[map ref, \\*, +{}, [], qr//,  \\'',  ]\n"},{"code":"[ map {scalar caller $_} -1 .. 4 ]\n","err":"","out":"[undef,\"main\",\"main\",undef,undef,undef]"},{"code":"[map ~$_, sort map ~$_, 'a'..'z']\n","out":"[\"z\",\"y\",\"x\",\"w\",\"v\",\"u\",\"t\",\"s\",\"r\",\"q\",\"p\",\"o\",\"n\",\"m\",\"l\",\"k\",\"j\",\"i\",\"h\",\"g\",\"f\",\"e\",\"d\",\"c\",\"b\",\"a\"]","err":""},{"out":"[-2,-2,\"-0\",0,2,2]","err":"","code":"[map { sprintf '%0.0f', $_ } -2.5, -1.5, -0.5, 0.5, 1.5, 2.5]\n"},{"code":"[map { sprintf '%0f', $_ } -2.5, -1.5, -0.5, 0.5, 1.5, 2.5]\n","err":"","out":"[\"-2.500000\",\"-1.500000\",\"-0.500000\",\"0.500000\",\"1.500000\",\"2.500000\"]"},{"code":"[ map sprintf('%.f', $_), 6.5, 7.5, 8.5, 11.5 ]\n","out":"[6,8,8,12]","err":""},{"code":"[ map sprintf('%.f', $_), 6.5, 7.5, 8.5, 9.5 ]\n","out":"[6,8,8,10]","err":""},{"out":"[8,12]","err":"","code":"[ map sprintf('%.f', $_), 8.5, 11.5 ]\n"},{"code":"[ map //'undef', 1, '', undef, 42 ]\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"//'undef'\"\n"},{"out":"[1,\"\",\"undef\",42]","err":"","code":"[ map $_//'undef', 1, '', undef, 42 ]\n"},{"err":"","out":"[undef,undef]","code":"[map $$_, values %DB:: ]\n"},{"err":"","out":"ERROR: Can't locate object method \"methname\" via package \"main\" at (eval 558) line 1, <STDIN> line 1.\n","code":"methname {'main'} 1;\n"},{"code":"methname {main} 1;\n","err":"","out":"ERROR: Can't locate object method \"methname\" via package \"main\" at (eval 558) line 1, <STDIN> line 1.\n"},{"code":" $    money   +    $    money   ==    $ $money\n","out":"1","err":""},{"code":" $    money   +    $    money   ==    $ $    money\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"$ $    money\n\"\n"},{"out":"1","err":"","code":" $    money   +    $    money   ==    $$money\n"},{"err":"","out":"[undef,[1,2,3,4,5,6,7,8,9,10]]","code":"my @a = 1..10; [ $a[-20], \\@a ]\n"},{"out":"[3,[1,2,3,4,5,6,7,8,9,10]]","err":"","code":"my @a = 1..10; [ $a[20%$#a], \\@a ]\n"},{"code":"my @a = 1..10; [ delete $a[-20], \\@a ]\n","err":"","out":"[undef,[1,2,3,4,5,6,7,8,9,10]]"},{"code":"my @a = 1..10; [ delete $a[20], \\@a ]\n","err":"","out":"[undef,[1,2,3,4,5,6,7,8,9,10]]"},{"code":"my @a = 1..10; [ delete $a[20%$#a], \\@a ]\n","out":"[3,[1,2,undef,4,5,6,7,8,9,10]]","err":""},{"err":"","out":"3","code":"my @a = 1..3; \n"},{"err":"","out":"[1,2,3]","code":"my @a = 1..3; \\@a\n"},{"out":"[1,2,3]","err":"","code":"my @a = 1..3; each @a; \\@a\n"},{"code":"my @a = 1..4; [ @a == grep $_ =~ /42/, @a ]\n","out":"[\"\"]","err":""},{"code":"my @a = 1..4; [ @a == grep $_ =~ /4/, @a ]\n","out":"[\"\"]","err":""},{"code":"my @a = 1..4; [ @a == grep $_, @a ]\n","out":"[1]","err":""},{"code":"my @a = 1..4; my %h1 = map +( $_ => $_+1 ), @a[0..@a/2]; my %h2 = map +( $_ => $_+1 ), @a[@a/2-1..$#a]; [ \\%h1, \\%h2 ]\n","err":"","out":"[{1 => 2,3 => 4,2 => 3},{2 => 3,4 => 5,3 => 4}]"},{"code":"my @a = 1..4; my %h1 = map +( $_ => $_+1 ), splice @a, 0, @a/2; my %h2 = map +( $_ => $_+1 ), splice @a, @a/2-1; [ \\%h1, \\%h2 ]\n","err":"","out":"[{1 => 2,2 => 3},{4 => 5,3 => 4}]"},{"code":"my @a = 1..4; my %h1 = map +( $_ => $_+1 ), splice @a, 0, @a/2; my %h2 = map +( $_ => $_+1 ), splice @a, @a/2; [ \\%h1, \\%h2 ]\n","out":"[{1 => 2,2 => 3},{4 => 5}]","err":""},{"code":"my @a = 1..5; (shift @a)x3; \\@a\n","out":"[2,3,4,5]","err":""},{"err":"","out":"[2,3,4,5]","code":"my @a = 1..5; (shift @a)x5; \\@a\n"},{"out":"abcxxx","err":"","code":"my @a = 'a'..'c'; for( @a ) { print $_; push @a, 'x' if rand > .5 }; \\@a;\n"},{"out":"[\"a\",\"b\",\"c\",\"x\"]","err":"","code":"my @a = 'a'..'c'; for( @a ) { push @a, 'x' if rand > .5 }; \\@a;\n"},{"err":"","out":"ERROR: Not a GLOB reference at (eval 558) line 1, <STDIN> line 1.\n","code":"my $a = 'a'; my $b = \\$a; for $$b (0..5) { print $a }\n"},{"out":"ERROR: syntax error at (eval 558) line 1, at EOF\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","err":"","code":"my (  @a, @b ) = 1..10; $_%2 and push @b, delete $a[$_\n"},{"code":"my ($a, $b, (undef) x 3, $c) = (1..10); [$a, $b, $c]\n","err":"","out":"ERROR: Can't declare repeat (x) in \"my\" at (eval 558) line 1, near \") =\"\n"},{"code":"my $a = {foo => 1}; sub foo {my $b={%{shift()}}; delete $b->{foo}}; foo($a); $a\n","out":"{foo => 1}","err":""},{"code":"my $a = {foo => 1}; sub foo {my $b=\\%{shift()}; delete $b->{foo}}; foo($a); $a\n","err":"","out":"{}"},{"err":"","out":"6","code":"my @a = (grep /2/, 1..4 )[0..5];\n"},{"err":"","out":"[2,undef]","code":"my @a = (grep /2/, 1..4 )[0..5]; splice @a, 2; \\@a\n"},{"err":"","out":"[2,undef,undef,undef]","code":"my @a = (grep /2/, 1..4 )[0..5]; splice @a, 4; \\@a\n"},{"out":"[\"m\",2]","err":"","code":"[ ++(my $a = \"l\"), ++(my $b = \"1\") ]\n"},{"code":"my @a; { local push @a, 1 }; \\@a;\n","out":"ERROR: Can't modify push in local at (eval 558) line 1, at EOF\n","err":""},{"err":"","out":"ERROR: Unrecognized character \\xCD; marked by <-- HERE after es/; my $a<-- HERE near column 96 at (eval 558) line 1, <STDIN> line 1.\n","code":"my $aÍ¾ print;\n"},{"out":"ERROR: Can't localize lexical variable @a at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my @a; { push (local @a), 42 }; \\@a;\n"},{"out":"[\"one\"]","err":"","code":"my @a = qw/one two/; [ $a['forty two'] ];\n"},{"err":"","out":"[\"asdf\",\"\\\"foo\\\"\"]","code":"my $_ = 'asdf \"foo\"'; my $h = 0x20000; my %h; s/(([\"'])(?:[^\"']+|\\\\.|(?!\\2).)*\\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split ' '; $h = chr($h-1); s/([\\x{20000}-$h])/$h{$1}/g for @words; \\@words;\n"},{"err":"","out":"[]","code":"my $_ = 'asdf \"foo\"'; my $h = 0x20000; my %h; s/(([\"'])(?:[^\"']+|\\\\.|(?!\\2).)*\\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split ' ', $str; $h = chr($h-1); s/([\\x{20000}-$h])/$h{$1}/g for @words; \\@words;\n"},{"code":"my $_ = 'asdf \"foo\"'; my $h = 0x20000; my %h; $str =~ s/(([\"'])(?:[^\"']+|\\\\.|(?!\\2).)*\\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split ' ', $str; $h = chr($h-1); s/([\\x{20000}-$h])/$h{$1}/g for @words; \\@words;\n","out":"[]","err":""},{"err":"","out":"sub { \"DUMMY\" }","code":"my $a = sub { say \"Hello World\" }; my $b = $a; $a\n"},{"err":"","out":"Hello World\n","code":"my $a = sub { say \"Hello World\" }; my $b = $a; $a->();\n"},{"code":"my $a = sub { say \"Hello World\" }; my $b = $a; \\*$a\n","out":"ERROR: Not a GLOB reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"my $a = sub { say \"Hello World\" }; my $b = $a; \\&$a\n","out":"sub { \"DUMMY\" }","err":""},{"code":"my $a = sub { say \"Hello World\" }; my $b = $a; &$a\n","out":"Hello World\n","err":""},{"err":"","out":"ERROR: Not a GLOB reference at (eval 558) line 1, <STDIN> line 1.\n","code":"my $a = sub { say \"Hello World\" }; my $b = $a; *$a = \\(sub {say \"Goodbye Mars\"});\n"},{"out":"ERROR: Can't modify non-lvalue subroutine call at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $a = sub { say \"Hello World\" }; my $b = $a; &$a = \\(sub {say \"Goodbye Mars\"});\n"},{"err":"","out":"ERROR: Can't modify non-lvalue subroutine call at (eval 558) line 1, <STDIN> line 1.\n","code":"my $a = sub { say \"Hello World\" }; my $b = $a; &$a = \\&{sub {say \"Goodbye Mars\"}};\n"},{"code":"my $a = sub { say \"Hello World\" }; my $b = $a; &$a = &{sub {say \"Goodbye Mars\"}};\n","out":"Goodbye Mars\nERROR: Can't modify non-lvalue subroutine call at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"\\sub { \"DUMMY\" }","code":"my $a = sub { say \"Hello World\" }; my $b = $a; \\(sub {say \"Goodbye Mars\"});\n"},{"code":"my $bar = 42; my @foo = (12, 24, 42); say grep($_ eq $bar, @foo) ? 42 : 52;\n","out":"42\n","err":""},{"code":"my $bar = 42; my @foo = (12, 24); say grep($_ eq $bar, @foo) ? 42 : 52;\n","out":"52\n","err":""},{"out":"ERROR: &CORE::pop cannot be called directly at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $c = \\&CORE::pop; my @abc = qw,a b c,; [$c->(\\@abc)]\n"},{"code":"my @chars = '$#**\\01000' =~/(.)+?([01]+)$/; \\@chars\n","err":"","out":"[\"\\\\\",\"01000\"]"},{"out":"{}","err":"","code":"my $dist = { author => [qw/foo bar/] }; my %z = ( author_id => $dist->{author} // (ref $dist->{authors} ? $dist->{authors}[0] : $dist->{authors}) // 'N/A', url => 'N/A',); \\%h\n"},{"err":"","out":"{url => \"N/A\",author_id => [\"foo\",\"bar\"]}","code":"my $dist = { author => [qw/foo bar/] }; my %z = ( author_id => $dist->{author} // (ref $dist->{authors} ? $dist->{authors}[0] : $dist->{authors}) // 'N/A', url => 'N/A'); \\%z\n"},{"out":"\n","err":"","code":"my $foo = 'BAR!'; BEGIN { say $foo }\n"},{"out":"ERROR: Illegal declaration of subroutine BEGIN at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $foo = 'BAR!'; BEGIN say { $foo }\n"},{"code":"my $foo = 'bar' =~ /ber/; [ $foo ]\n","err":"","out":"[\"\"]"},{"code":"my $foo = 'bar'; -$foo\n","out":"-bar","err":""},{"code":"my $foo = 'bar'; $foo = -$foo for 1, 2; $foo\n","err":"","out":"+bar"},{"err":"","out":"-","code":"my $foo = '-'; $foo = -$foo for 1, 2; $foo\n"},{"code":"my $foo = ''; $foo = -$foo for 1, 2; $foo\n","out":"0","err":""},{"out":"7","err":"","code":"my $foo = grep $_, 1..5, 'a', 'b'; $foo;\n"},{"out":"5","err":"","code":"my $foo = grep $_, 1..5; $foo;\n"},{"code":"my ($foo) if 0;\n","out":"0","err":""},{"err":"","out":"ERROR: No such class foo at (eval 558) line 1, near \"; my foo\"\n","code":"my foo $x = 3; [ $x ]\n"},{"err":"","out":"ERROR: No such class foo:: at (eval 558) line 1, near \"; my foo::\"\n","code":"my foo:: $x = 3; [ $x ]\n"},{"code":"my $h = {1..4};  [$h->@{1, 3}]\n","err":"","out":"[2,4]"},{"code":"my $hash = {ref => [1, 2, 3]}; while(my $num = $hash->{ref}->\"CORE::each\") {print $num, \" => \";}\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"->\"CORE::each\"\"\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"->&\"\n","err":"","code":"my $hash = {ref => [1, 2, 3]}; while(my $num = $hash->{ref}->&CORE::each) {print $num, \" => \";}\n"},{"err":"","out":"2","code":"my %hash = ( \"Ø£\" => 1, )\n"},{"code":"my %hash = ( \"Ø£\" => 1\", )\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"my %hash = ( \"Ø£\" => 1\"\", )\n","out":"ERROR: syntax error at (eval 558) line 1, near \"1\"\"\"\n","err":""},{"err":"","out":"{\"how strange\" => \"is this, anyway?\"}","code":"my %h = (a..z); ${%h}{\"how strange\"} = \"is this, anyway?\"; \\%{%h};\n"},{"code":"my @heterological_scalar; my %autological_hash;\n","out":"0","err":""},{"code":"my %h = ( foo => { bar => {ber => [boor] } } } ); my $ar = $h{foo}{bar}{ber}; push @$ar, 'foor';  \n","err":"","out":"ERROR: Unmatched right curly bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, at EOF\n"},{"code":"my %h = ( foo => { bar => {ber => [boor] } } ); my $ar = $h{foo}{bar}{ber}; push @$ar, 'foor';  \\%h\n","err":"","out":"{foo => {bar => {ber => [\"boor\",\"foor\"]}}}"},{"out":"ERROR: Unmatched right curly bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, at EOF\n","err":"","code":"my %h = ( foo => { bar => {ber => [boor] } } } ); my $ar = $h{foo}{bar}{ber}; push @$ar, 'foor';  \\%h\n"},{"code":"my ($home) = \"git://github.com/labster/p6-IO-Path-More.git\" =~ m[(?:git|https?)://([\\w\\.]+)/]; $home\n","out":"github.com","err":""},{"err":"","out":"0","code":"my ($home) = \"git://github.com/labster/p6-IO-Path-More.git\" =~ m[(?:git|https?)://([\\w\\.]+)/]; my ($auth, $repo_name) = $url =~ m[(?:git|https?)://$home/([^/]+)/([^/]+)\\.git];\n"},{"err":"","out":"github.com","code":"my ($home) = \"http://github.com/labster/p6-IO-Path-More/\" =~ m[(?:git|https?)://([\\w\\.]+)/]; $home\n"},{"err":"","out":"[1,2,3]","code":"my %h=qw/q 1 d 2 b 3/; [@h{qw/q d b/}]\n"},{"code":"my $hyphenated = 'foo-bar'; *$hyphenated = sub { 'works' }; main->$hyphenated();\n","out":"works","err":""},{"err":"","out":"ÃÂÃÂ","code":"my $i = 0; ++$i until charnames::viacode($i) =~ /music|note/i; chr $i;\n"},{"code":"my $i = 0; my $n; ++$i until ($n=charnames::viacode($i)) =~ /music|\\bnote/i; [ chr $i, $n ]\n","err":"","out":"[\"\\x{749}\",\"SYRIAC MUSIC\"]"},{"err":"","out":"[\"\\x{602}\",\"ARABIC FOOTNOTE MARKER\"]","code":"my $i = 0; my $n; ++$i until ($n=charnames::viacode($i)) =~ /music|note/i; [ chr $i, $n ]\n"},{"code":"my $j = 'Foo'; $j =~ tr/\\x20-\\x7f/\\xff00-\\xff5f/; binmode STDOUT; print $j;\n","err":"","out":"T}}"},{"out":"ÂÃÃ","err":"","code":"my $j = 'Foo'; $j =~ tr/\\x20-\\x7f/\\xff0x-\\xff5f/; binmode STDOUT; print $j;\n"},{"err":"","out":"T}}","code":"my $j = 'Foo'; $j =~ tr/\\x20-\\x7f/\\xff10-\\xff5f/; binmode STDOUT; print $j;\n"},{"code":"my $j = 'Foo'; $j =~ tr/\\x20-\\x7f/\\xff20-\\xff5f/; binmode STDOUT; print $j;\n","err":"","out":"T}}"},{"code":"my $j = 'Foo'; $j =~ tr/\\x20-\\xff/\\xff10-\\xff5f/; binmode STDOUT; print $j;\n","err":"","out":"T}}"},{"out":"T}}","err":"","code":"my $j = 'Foo'; $j =~ tr/\\x20-\\xff/\\xff10-\\xffff/; binmode STDOUT; print $j;\n"},{"code":"my $j = 'Just another Perl/Unicode Hacker,'; $j =~ tr/\\x00-\\xff/\\xff00-\\xffff/; binmode STDOUT;  $j;\n","err":"","out":"xÂ£Â¡Â¢NÂÂÂÂ¢ÂÂÂ N~ÂÂ Â]ÂÂÂÂÂÂÂNvÂÂÂÂÂ Z"},{"err":"","out":"xÂ£Â¡Â¢NÂÂÂÂ¢ÂÂÂ N~ÂÂ Â]ÂÂÂÂÂÂÂNvÂÂÂÂÂ Z","code":"my $j = 'Just another Perl/Unicode Hacker,'; $j =~ tr/\\x00-\\xff/\\xff00-\\xffff/; binmode STDOUT; print $j;\n"},{"code":"my $j = 'Just another Perl/Unicode Hacker,'; $j =~ tr/\\x00-\\xff/\\xff00-\\xffff/; $j;\n","out":"xÃÂ£ÃÂ¡ÃÂ¢NÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ N~ÃÂÃÂ ÃÂ]ÃÂÃÂÃÂÃÂÃÂÃÂÃÂNvÃÂÃÂÃÂÃÂÃÂ Z","err":""},{"out":"XÂÂÂÃ¿o|}ÂvsÂÃ¿^sÂz=c|wq}rsÃ¿VoqysÂ:","err":"","code":"my $j = 'Just another Perl/Unicode Hacker,'; $j =~ tr/\\x20-\\x7f/\\xff00-\\xff5f/; binmode STDOUT; print $j;\n"},{"code":"my $l = 0; [ 0 << 2 ]\n","err":"","out":"[0]"},{"out":"[2]","err":"","code":"my $l = 0; [ 1 << 1 ]\n"},{"code":"my $l = 0; [ 1 << 2 ]\n","out":"[4]","err":""},{"err":"","out":"[16]","code":"my $l = 0; [ 1 << 2  << 2]\n"},{"err":"","out":"[4]","code":"my $l = 0; [ 2 << 1 ]\n"},{"out":"[6]","err":"","code":"my $l = 0; [ 3 << 1 ]\n"},{"code":"my $l = 0; [ 3 << 2 ]\n","err":"","out":"[12]"},{"code":"my $l = 0; [ sprintf('b', 3), sprintf('b', 3 << 1) ]\n","out":"[\"b\",\"b\"]","err":""},{"out":"ERROR: Not an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"my $lambda = sub { shift @_+1 }; @a=1..4; [{map{$_=>$lambda->($_)}@a[0..@a/2-1]},{map{$_=>$lambda->($_)}@a[@a/2..$#a]}]\n"},{"err":"","out":"[{2 => 3,1 => 2},{3 => 4,4 => 5}]","code":"my $lambda = sub { shift()+1 }; @a=1..4; [{map{$_=>$lambda->($_)}@a[0..@a/2-1]},{map{$_=>$lambda->($_)}@a[@a/2..$#a]}]\n"},{"code":"my $lambda = sub { shift+1 }; @a=1..4; [{map{$_=>$lambda->($_)}@a[0..@a/2-1]},{map{$_=>$lambda->($_)}@a[@a/2..$#a]}]\n","err":"","out":"ERROR: Type of arg 1 to shift must be array (not constant item) at (eval 558) line 1, at EOF\n"},{"code":"my main $x = 3; [ $x ]\n","out":"[3]","err":""},{"out":"[\"|1|2a|3abc\"]","err":"","code":"my $n = 3; my $str = q(|1|2a|3abc|4abcd|5abcde); [join q(|), (split /\\|/, $str)[0..$n]];\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"CORE::GLOBAL::print \"foo\"\"\n","err":"","code":"{my $print = \\&CORE::GLOBAL::print; *CORE::GLOBAL::print = sub { $print->(\"wut wut: \", @_)}}; CORE::GLOBAL::print \"foo\"\n"},{"err":"","out":"foo","code":"{my $print = \\&CORE::GLOBAL::print; *CORE::GLOBAL::print = sub { $print->(\"wut wut: \", @_)}}; CORE::print \"foo\"\n"},{"code":"{my $print = \\&CORE::GLOBAL::print; *CORE::GLOBAL::print = sub { $print->(\"wut wut: \", @_)}}; print \"foo\"\n","out":"foo","err":""},{"code":"my $print = \\&CORE::GLOBAL::print; sub myprint {$print->(\"I don't wanna\");}; *CORE::GLOBAL::print = &myprint; print \"foo\"\n","out":"ERROR: Undefined subroutine &CORE::GLOBAL::print called at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"{my $print = \\&CORE::print; *CORE::GLOBAL::print = sub { $print->(\"wut wut: \", @_)}}; print \"foo\"\n","err":"","out":"foo"},{"err":"","out":"ERROR: Can't modify reference to ref-to-glob cast in scalar assignment at (eval 558) line 1, at EOF\n","code":"{my $print = \\&CORE::print; \\*CORE::GLOBAL::print = sub { $print->(\"wut wut: \", @_)}}; print \"foo\"\n"},{"code":"my $print = \\*CORE::print; sub myprint {$print->(\"I don't wanna\");}; *CORE::GLOBAL::print = &myprint; print \"foo\"\n","err":"","out":"ERROR: Not a CODE reference at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"my $print = \\&CORE::print; sub myprint {$print->(\"I don't wanna\");}; *CORE::GLOBAL::print = &myprint; print \"foo\"\n","err":"","out":"ERROR: Undefined subroutine &CORE::print called at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"{my $print = \\&CORE::print; sub print { $print->(\"wut wut: \", @_)}}; print \"foo\"\n","err":"","out":"foo"},{"code":"{my $print = \\&CORE::print; sub print { $print->(\"wut wut: \", @_}}; print \"foo\"\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n"},{"out":"[\"asdf\",\"\\\"foo\\\"='bar baz'\"]","err":"","code":"my $_ = q,asdf \"foo\"='bar baz',; my $h = 0x20000; my %h; s/(([\"'])(?:[^\"']+|\\\\.|(?!\\2).)*\\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split ' '; $h = chr($h-1); s/([\\x{20000}-$h])/$h{$1}/g for @words; \\@words;\n"},{"code":"my $rule = qr/!!(.+?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; my @s; { my @bits = split /$rule/, $s, 2; push @s, @bits == 1 ? { t => $bits[0] } : ( { t => $bits[0]}, { t => $bits[1], shiny => 1 }, { t => $bits[2] } );  last if @bits == 1; $s =~ s/$rule//; } \\@s\n","err":"","out":"[{t => \"Foo bar \"},{t => \"meow\",shiny => 1},{t => \" lulz  !!mooo!!\"}]"},{"err":"","out":"","code":"my $rule = qr/!!(.+?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; my @s; { my @bits = split /$rule/, $s, 2; push @s, @bits == 1 ? { t => $bits[0] } : ( { t => $bits[0]}, { t => $bits[1], shiny => 1 }, { t => $bits[2] } );  redo unless @bits == 1} \\@s\n"},{"out":"[{t => \"Foo bar \"},{shiny => 1,t => \"meow\"},{t => \" lulz  !!mooo!!\"}]","err":"","code":"my $rule = qr/!!(.+?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; my @s; { my @bits = split /$rule/, $s, 2; push @s, @bits == 1 ? { t => $bits[0] } : ( { t => $bits[0]}, { t => $bits[1], shiny => 1 }, { t => $bits[2] } ); } \\@s\n"},{"out":"[{t => \"Foo bar \"},{t => \"meow\"},{t => \" lulz  !!mooo!!\"}]","err":"","code":"my $rule = qr/!!(.+?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; my @s; { my @bits = split /$rule/, $s, 2; push @s, @bits == 1 ? { t => $bits[0] } : ( { t => $bits[0]}, { t => $bits[1] }, { t => $bits[2] } ); } \\@s\n"},{"err":"","out":"ERROR: Missing right curly or square bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, at EOF\n","code":"my $rule = qr/!!(.+?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; my @s; { my @bits = split /$rule/, $s, 2; push @s, @bits == 1 ? { t => $bits[0] } : ( { t => $bits[0]}, { t => $bits[1] }, { t => $bits[2] } ); \\@s\n"},{"code":"my $rule = qr/!!(.?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; [  split /$rule/, $s ]\n","out":"[\"Foo bar !!meow!! lulz  !!mooo!!\"]","err":""},{"code":"my $rule = qr/!!(.?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; [  split $rule, $s ]\n","err":"","out":"[\"Foo bar !!meow!! lulz  !!mooo!!\"]"},{"code":"my $rule = qr/!!(.+?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; [  split /$rule/, $s ]\n","out":"[\"Foo bar \",\"meow\",\" lulz  \",\"mooo\"]","err":""},{"out":"[\"Foo bar !!meow!! lulz  !!mooo!!\"]","err":"","code":"my $rule = qr/!!(.+?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; [  split /$rule/, $s, 1 ]\n"},{"code":"my $rule = qr/!!(.+?)!!/; my $s = \"Foo bar !!meow!! lulz  !!mooo!!\"; [  split /$rule/, $s, 2 ]\n","err":"","out":"[\"Foo bar \",\"meow\",\" lulz  !!mooo!!\"]"},{"code":"my %seen; $seen{foo}; $seen{bar}; \\%seen\n","out":"{}","err":""},{"code":"my %seen; $seen{''} //= keys(%seen); print $seen{''}.\"\\n\";\n","err":"","out":"1\n"},{"code":"my %seen; $test=\"one\"; $seen{$test} //= [keys(%seen)]; \\%seen\n","out":"{one => [\"one\"]}","err":""},{"err":"","out":"[\"a\",2,3]","code":"my $self; $self->{messages} = [1,2,3]; $self->{messages}->[0] = \"a\"; $self->{messages}\n"},{"err":"","out":"[undef]","code":"my $stash = \\%{ __PACKAGE__ . \"::\" } ; sub foo { 42 }; [ $main->{foo} ]\n"},{"out":"[sub { \"DUMMY\" }]","err":"","code":"my $stash = \\%{ __PACKAGE__ . \"::\" } ; sub foo { 42 }; [ $stash->{foo} ]\n"},{"code":"my sub stat;\n","err":"","out":""},{"err":"","out":"[\"1.3\"]","code":"my sub stat { 1.3 }; [ stat ]\n"},{"code":"my $t = 'ï¼¹ï¼¯ï¼µ  ï¼¨ï¼¡ï¼¶ï¼¥'; binmode STDOUT;  $t;\n","out":"Ã¯Â¼Â¹Ã¯Â¼Â¯Ã¯Â¼Âµ  Ã¯Â¼Â¨Ã¯Â¼Â¡Ã¯Â¼Â¶Ã¯Â¼Â¥","err":""},{"out":"[\"gi|300707803|ref|XP_002996096.1|hypothetical protein NCER_100860 \",\"Nosema ceranae BRL01] >gi|239605364|gb|EEQ82425.1| hypothetical protein NCER_100860 \"]","err":"","code":"my @tmp; $tmp[3] = \"gi|300707803|ref|XP_002996096.1|hypothetical protein NCER_100860 [Nosema ceranae BRL01] >gi|239605364|gb|EEQ82425.1| hypothetical protein NCER_100860 [Nosema ceranae BRL01]\"; my($ia,$ib) = split(/\\[/,$tmp[3]); [ $ia, $ib]\n"},{"code":"my $t = 'ï¼¹ï¼¯ï¼µ  ï¼¨ï¼¡ï¼¶ï¼¥'; $t;\n","out":"ÃÂ¯ÃÂ¼ÃÂ¹ÃÂ¯ÃÂ¼ÃÂ¯ÃÂ¯ÃÂ¼ÃÂµ  ÃÂ¯ÃÂ¼ÃÂ¨ÃÂ¯ÃÂ¼ÃÂ¡ÃÂ¯ÃÂ¼ÃÂ¶ÃÂ¯ÃÂ¼ÃÂ¥","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"/./pos $u\"\n","err":"","code":"my $u = 'ABC'; say $u =~ /./pos $u/ger;\n"},{"out":"\n","err":"","code":"my $u = 'ABC'; say $u =~ s/./pos $u/ger;\n"},{"err":"","out":"[undef,undef]","code":"my $url = \"http://github.com/labster/p6-IO-Path-More/\"; my ($auth, $repo_name) = $url =~ m[(?:git|https?)://$home/([^/]+)/([^/]+)\\.git]; [ $auth, $repo_name ]\n"},{"err":"","out":"[undef,undef]","code":"my $url = \"http://github.com/labster/p6-IO-Path-More/\"; my ($home) = $url =~ m[(?:git|https?)://([\\w\\.]+)/]; my ($auth, $repo_name) = $url =~ m[(?:git|https?)://$home/([^/]+)/([^/]+)\\.git]; [ $auth, $repo_name ]\n"},{"err":"","out":"[\"github.com\",undef,undef]","code":"my $url = \"http://github.com/labster/p6-IO-Path-More/\"; my ($home) = $url =~ m[(?:git|https?)://([\\w\\.]+)/]; my ($auth, $repo_name) = $url =~ m[(?:git|https?)://$home/([^/]+)/([^/]+)\\.git]; [ $home, $auth, $repo_name ]\n"},{"out":"[\"github.com\",\"labster\",\"p6-IO-Path-More\"]","err":"","code":"my $url = \"http://github.com/labster/p6-IO-Path-More/\"; my ($home) = $url =~ m[(?:git|https?)://([\\w\\.]+)/]; my ($auth, $repo_name) = $url =~ m[(?:git|https?)://\\Q$home\\E/([^/]+)/([^/]+)(\\.git|/)?$]; [ $home, $auth, $repo_name ]\n"},{"err":"","out":"[\"github.com\",\"labster\",\"p6-IO-Path-More\"]","code":"my $url = \"http://github.com/labster/p6-IO-Path-More/\"; my ($home) = $url =~ m[(?:git|https?)://([\\w\\.]+)/]; my ($auth, $repo_name) = $url =~ m[(?:git|https?)://\\Q$home\\E/([^/]+)/([^/]+)(\\.git|/)$]; [ $home, $auth, $repo_name ]\n"},{"out":"pwned\n","err":"","code":"my ( $user, $nick ) = ( 'root', 'ro.+' ); if($user =~ /^$nick$/){ say 'pwned' }\n"},{"code":"my ( $user, $nick ) = ( 'root', 'ro.+' ); if($user =~ /^$nick$/){ say 'pwned' } else { say 'you are not root' }\n","err":"","out":"pwned\n"},{"out":"[3]","err":"","code":"my utf8 $x = 3; [ $x ]\n"},{"code":"my @vals = (0); [pack(\"C*\", @vals)];\n","err":"","out":"[\"\\0\"]"},{"code":"my $x = 0.1 + 0.2; [ $x,  (\"$x\" == \"0.3\") ? 'y' : 'n' ]\n","err":"","out":"[\"0.3\",\"y\"]"},{"code":"my $x = 0.1 + 0.2; [ $x,  ($x == 0.3) ? 'y' : 'n' ]\n","err":"","out":"[\"0.3\",\"n\"]"},{"err":"","out":"[\"Inf\",\"Inf\"]","code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 123456; [ exp $x, $y ];\n"},{"code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 123456; [ $x, exp $x, $y ];\n","err":"","out":"[\"1323904.4924838\",\"Inf\",\"Inf\"]"},{"code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 12345; [ exp $x, $y ];\n","err":"","out":"[\"Inf\",\"Inf\"]"},{"out":"[\"103962.95347845\",\"Inf\",\"Inf\"]","err":"","code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 12345; [ $x, exp $x, $y ];\n"},{"code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 1234; [ $x, exp $x, $y, (exp $x) - $y ];\n","err":"","out":"[\"7554.11001047673\",\"Inf\",\"Inf\",\"NaN\"]"},{"code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 1234; [ $x, exp $x, $y, exp $x - $y ];\n","err":"","out":"[\"7554.11001047673\",\"Inf\",\"Inf\",0]"},{"out":"[\"472.224383926981\",\"1.21463043670265e+205\",\"1.21463043670253e+205\"]","err":"","code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 123; [ $x, exp $x, $y ];\n"},{"code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 123; [ $x, exp $x, $y, (exp $x) - $y ];\n","err":"","out":"[\"472.224383926981\",\"1.21463043670265e+205\",\"1.21463043670253e+205\",\"1.17625422173072e+192\"]"},{"code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 123; [ $x, exp $x, $y, $y - exp $x ];\n","out":"[\"472.224383926981\",\"1.21463043670265e+205\",\"1.21463043670253e+205\",\"-1.17625422173072e+192\"]","err":""},{"code":"my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 12; [ $x, exp $x, $y, $y - exp $x ];\n","err":"","out":"[\"19.9872144956619\",\"479001600.000001\",479001600,\"-1.01327896118164e-06\"]"},{"code":"my $x = 0; $x += log for 1 .. 123456; \"123456! is a \" . int($x / log 10 + .99999) . \" digit number\";\n","out":"123456! is a 552111 digit number","err":""},{"out":"123456! is a 574964 digit number","err":"","code":"my $x = 0; $x += log for 1 .. 123456; \"123456! is a \" . int($x / log 10) . \" digit number\";\n"},{"code":"my $x = 0; $x += log for 1 .. 123456; \"123456! is a \" . ($x / log 10) . \" digit number\";\n","out":"123456! is a 574964.415652639 digit number","err":""},{"code":"my $x = 0; $x += log for 1 .. 123456; \"123456! is a \" . $x / log 10 . \" digit number\";\n","err":"","out":"123456! is a 574964.415652639"},{"out":"[\"1323904.4924838\",\"574964.415652639\",\"1909990.445917\"]","err":"","code":"my $x = 0; $x += log for 1 .. 123456; [ $x, $x / log 10, $x / log 2 ];\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"logfor 1\"\n","code":"my $x = 0; $x += logfor 1 .. 123456; [ $x, $x / log 10, $x / log 2 ];\n"},{"code":"my $x = 10.01; $x -= 10.00; print $x\n","out":"0.00999999999999979","err":""},{"code":"my $x = 10.01; $x -= 10; print $x\n","err":"","out":"0.00999999999999979"},{"code":"my $x = [1..10]; say $x->@[2,4]\n","out":"35\n","err":""},{"code":"my @x = (1, { x => z }, 2); sub foo {my @t = @_; undef @t } foo(@x); \\@x\n","out":"[1,{x => \"z\"},2]","err":""},{"code":"my $x = [3, 4, 5]; for my $y (map @$_, $x) { ++$y }\n","out":"","err":""},{"out":"[3,4,5]","err":"","code":"my $x = [3, 4, 5]; for my $y (map @$_, $x) { ++$y }; $x;\n"},{"out":"91116451","err":"","code":"my $x = [3, 4, 5]; for my $y (map @$_, $x) { ++$y, ++$x }; $x;\n"},{"code":"my $x = [3, 4, 5]; for my $y (map @$_, $x) { ++$y, ++$y }; $x;\n","out":"[3,4,5]","err":""},{"code":"my $x = [3, 4, 5]; for my $y (@$x) { ++$y, ++$y }; $x;\n","err":"","out":"[5,6,7]"},{"code":"my $x = 42; join ' ', ++$x, ++$x, ++$x;\n","err":"","out":"45 45 45"},{"err":"","out":"599","code":"my $x = '$5.99'; $x =~ tr/0-9//cd; $x\n"},{"out":"foos foos foos foos foos ","err":"","code":"my $x = 5; until ( $x-- == 0 ) { print \"foos \" }\n"},{"out":"[\"GLOB\"]","err":"","code":"my $x = *a; [ ref \\$x ]\n"},{"err":"","out":"[\"\"]","code":"my $x = bless [], 'foo'; [ ref($x)->isa( 'main' ) ]\n"},{"out":"[\"sutJa nohterP er lhakcer,\"]","err":"","code":"my $x = \"cbdafeghjiklnmoprqstvuwxy\"; $x =~ tr/a-y/Just another Perl hacker,/; [$x];\n"},{"code":"my $x; [ defined &$x ]\n","out":"[\"\"]","err":""},{"code":"my $x = 'foo bar baz'; say 's-' . ($x =~ s/\\s.+//r) . '42'\n","err":"","out":"s-foo42\n"},{"err":"","out":"s-foo42\n","code":"my $x = 'foo bar baz'; say 's-' . $x =~ s/\\s.+//r . '42'\n"},{"code":"my $x = 'foo bar baz'; say 's-' . ($x =~ s/\\S.+//r) . '42'\n","err":"","out":"s-42\n"},{"err":"","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","code":"my $x = 'foo bar baz'; say 's-' . $x =~ s/\\S.+//r . '42\n"},{"code":"my $x = 'foo bar baz'; say 's-' . $x =~ s/\\S.+//r . '42'\n","out":"s-42\n","err":""},{"code":"my $x = \\*foo; $x\n","err":"","out":"\\*::foo"},{"code":"my $x = \\*foo; *$x\n","err":"","out":"*main::foo"},{"err":"","out":"42\n","code":"my $x = '+foo'; $x =~ s/^\\+// and say \"42\";\n"},{"out":"","err":"","code":"my $x = 'foo'; $x =~ s/^\\+// and say \"42\";\n"},{"code":"my @x; local $x[0] = 1; \\@x\n","out":"[]","err":""},{"code":"my $x; local $x->[0] = 1; [ $x ]\n","err":"","out":"[[]]"},{"err":"","out":"42","code":"my @x; local $x[0] = 42; \"@x\";\n"},{"code":"my @x; local $x[0] = 42; \\@x\n","out":"[]","err":""},{"code":"my $x; local $$x = 1; [ $x ]\n","err":"","out":"ERROR: Can't localize through a reference at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"my $x = \"main::a\"; [ ref \\$x ]\n","out":"[\"SCALAR\"]","err":""},{"err":"","out":"[\"got\",\"Can't find label nowhere at (eval 558) line 1, <STDIN> line 1.\\n\"]","code":"my $x = 'nowhere'; eval { goto $x }; [ 'got', $@ ]\n"},{"code":"my $x = []; [ ref($x)->isa( 'main' ) ]\n","out":"[\"\"]","err":""},{"code":"my $x = []; [ ref($x)->SUPER::isa( 'main' ) ]\n","out":"[\"\"]","err":""},{"code":"my $x = \"\\r\\n\"; chomp $x; [ $x ]\n","err":"","out":"[\"\\r\"]"},{"err":"","out":"\r","code":"my $x = \"\\r\\n\"; chomp $x; $x\n"},{"out":"[\"a\",\"b\",\"c\"]","err":"","code":"my $x = (sub { [1..3], [a..c] })->();\n"},{"err":"","out":"0","code":"my $x = []; $x->@*\n"},{"code":"my $x; $x += 4;\n","err":"","out":"4"},{"code":"my $x = {}; $x->@{qw/foo bar/} = (\"foo\", \"bar\"); $x\n","out":"{foo => \"foo\",bar => \"bar\"}","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"@*{\"\n","err":"","code":"my $x = {}; $x->@*{qw/foo bar/} = (\"foo\", \"bar\"); $x\n"},{"code":"my $x = []; [ $x->SUPER::isa( 'main' ) ]\n","out":"ERROR: Can't call method \"isa\" on unblessed reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"Zoooooofix","err":"","code":"my $x = 'Zoffix'; substr($x, 2, 1) = 'ooooo'; $x\n"},{"code":"my $x = \"z\\r\\n\"; chomp $x; [ $x ]\n","out":"[\"z\\r\"]","err":""},{"out":"[\"a\",\"A\",\"b\",\"B\",\"c\",\"C\",\"d\",\"D\",\"e\",\"E\",\"f\",\"F\",\"g\",\"G\",\"h\",\"H\",\"i\",\"I\",\"j\",\"J\",\"k\",\"K\",\"l\",\"L\",\"m\",\"M\",\"n\",\"N\",\"o\",\"O\",\"p\",\"P\",\"q\",\"Q\",\"r\",\"R\",\"s\",\"S\",\"t\",\"T\",\"u\",\"U\",\"v\",\"V\",\"w\",\"W\",\"x\",\"X\",\"y\",\"Y\",\"z\",\"Z\"]","err":"","code":"my @Z = 'a'..'z'; my @Z2; for ( @Z ) { push @Z2, $_, uc $_; } \\@Z2;\n"},{"code":"$n == 0 + reverse $n\n","out":"1","err":""},{"code":"$! = 'NaN'; $!\n","err":"","out":"No such file or directory"},{"err":"","out":"","code":"$! = 'NaN'; $1\n"},{"err":"","out":"ÃÂ¢ÃÂÃÂ«","code":"\"\\N{DONG SIGN}\"\n"},{"code":"no feature ':all'; sub foo (;$$;) { [@_] }; my %h = ( bar => foo 42, 'bar'  );  \\%h\n","err":"","out":"{bar => [42,\"bar\"]}"},{"out":"ERROR: Too many arguments for main::foo at (eval 558) line 1, near \"'moo' )\"\n","err":"","code":"no feature ':all'; sub foo (;$$;) { [@_] }; my %h = ( bar => foo 42, bar => meow => 'moo' );  \\%h\n"},{"code":"no feature ':all'; sub foo (;\\[$@]) { [@_] }; my %h = ( bar => foo 42, bar => meow => 'moo' );  \\%h\n","err":"","out":"ERROR: Type of arg 1 to main::foo must be one of [$@] (not constant item) at (eval 558) line 1, near \"42,\"\n"},{"out":"ERROR: Type of arg 1 to main::foo must be one of [$$] (not constant item) at (eval 558) line 1, near \"42,\"\n","err":"","code":"no feature ':all'; sub foo (;\\[$$]) { [@_] }; my %h = ( bar => foo 42, bar => meow => 'moo' );  \\%h\n"},{"code":"no feature ':all'; sub foo ($$;) { [@_] }; my %h = ( bar => foo 42, bar => meow => 'moo' );  \\%h\n","out":"ERROR: Too many arguments for main::foo at (eval 558) line 1, near \"'moo' )\"\n","err":""},{"code":"no feature ':all'; sub foo ($$) { [@_] }; my %h = ( bar => foo 42, bar => meow => 'moo' );  \\%h\n","out":"ERROR: Too many arguments for main::foo at (eval 558) line 1, near \"'moo' )\"\n","err":""},{"code":"no feature ':all'; sub foo (+) { [@_] }; my %h = ( bar => foo 42, bar => meow => 'moo' );  \\%h\n","err":"","out":"{bar => \"meow\",moo => undef}"},{"err":"","out":"ERROR: Too many arguments for main::foo at (eval 558) line 1, near \"'moo' )\"\n","code":"no feature ':all'; sub foo (+$) { [@_] }; my %h = ( bar => foo 42, bar => meow => 'moo' );  \\%h\n"},{"out":"{meow => \"moo\",bar => [42]}","err":"","code":"no feature ':all'; sub foo (;$) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \\%h\n"},{"out":"ERROR: Too many arguments for main::foo at (eval 558) line 1, near \"'moo' )\"\n","err":"","code":"no feature ':all'; sub foo (;$$;) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \\%h\n"},{"code":"no feature ':all'; sub foo (;$$) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \\%h\n","err":"","out":"ERROR: Too many arguments for main::foo at (eval 558) line 1, near \"'moo' )\"\n"},{"out":"{bar => [42,\"meow\",\"moo\"]}","err":"","code":"no feature ':all'; sub foo (;%$) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \\%h\n"},{"code":"no feature ':all'; sub foo ($$) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \\%h\n","err":"","out":"ERROR: Too many arguments for main::foo at (eval 558) line 1, near \"'moo' )\"\n"},{"code":"no feature ':all'; sub foo ($;@) { [@_] }; my %h = ( bar => foo 42, x => meow => 'moo' );  \\%h\n","out":"{bar => [42,\"x\",\"meow\",\"moo\"]}","err":""},{"code":"no feature ':all'; sub foo ($@) { [@_] }; my %h = ( bar => foo 42, x => meow => 'moo' );  \\%h\n","err":"","out":"{bar => [42,\"x\",\"meow\",\"moo\"]}"},{"code":"no feature ':all'; sub foo (+) { [@_] }; my %h = ( bar => foo 42, x => meow => 'moo' );  \\%h\n","err":"","out":"{bar => [42],x => \"meow\",moo => undef}"},{"out":"ERROR: Too many arguments for main::foo at (eval 558) line 1, near \"'moo' )\"\n","err":"","code":"no feature ':all'; sub foo (++) { [@_] }; my %h = ( bar => foo 42, x => meow => 'moo' );  \\%h\n"},{"err":"","out":"ERROR: Too many arguments for main::foo at (eval 558) line 1, near \"'moo' )\"\n","code":"no feature ':all'; sub foo (;$$) { print  \"[@_]\"; }; my %h = ( bar => foo 42, meow => 'moo' ); \\%h\n"},{"code":"no feature ':all'; sub foo (;$$) { print  \"[@_]\"; }; my %h = ( bar => foo(42), meow => 'moo' ); \\%h\n","err":"","out":"[42]"},{"code":"no feature ':all'; sub foo ($) { print  \"[@_]\"; }; my %h = ( bar => foo(42), meow => 'moo' ); \\%h\n","err":"","out":"[42]"},{"code":"no feature ':all'; sub foo (;$) { print \"[@_]\"; }; my %h = ( bar => foo 42, meow => 'moo' ); print Dumper \\%h\n","err":"","out":"[42]$VAR1 = {\n          'bar' => 1,\n          'meow' => 'moo'\n        };\n"},{"code":"no feature ':all'; sub foo (;$$) { print \"[@_]\"; }; my %h = ( bar => foo 42, meow => 'moo' ); print Dumper \\%h\n","out":"ERROR: Too many arguments for main::foo at (eval 558) line 1, near \"'moo' )\"\n","err":""},{"code":"no feature ':all'; sub foo ($) { say \"[@_]\"; }; my %h = ( bar => foo(42), meow => 'moo' ); \\%h\n","out":"ERROR: syntax error at (eval 558) line 1, near \"say \"[@_]\"\"\n","err":""},{"err":"","out":"","code":"no feature 'signatures'; sub foo (\\@) { say @_ };\n"},{"code":"no feature 'signatures'; sub foo (\\@) { say @_ };  foo +(split //, \"foobar\")\n","out":"ERROR: Type of arg 1 to main::foo must be array (not split) at (eval 558) line 1, at EOF\n","err":""},{"err":"Indirect call of method \"catch\" on a block at (eval 558) line 1.\nIndirect call of method \"try\" on a block at (eval 558) line 1.\n","out":"hwERROR: hello at (eval 558) line 1, <STDIN> line 1.\n","code":"no indirect; try {print \"hw\"} catch {die \"hello\"};\n"},{"out":"","err":"","code":"'nonexist'->import();\n"},{"out":"ÃÂ°ÃÂÃÂÃÂ©","err":"","code":"\"\\N{PILE OF POO}\"\n"},{"err":"","out":"ÃÂ¢ÃÂÃÂ","code":"\"\\N{SNOWMAN}\"\n"},{"code":"\"\\N{SPARKLE}\"\n","out":"ÃÂ¢ÃÂÃÂ","err":""},{"code":"\"\u0002\\N{SPARKLE}\u0002\\N{SPARKLE}\"\n","out":"\u0002ÃÂ¢ÃÂÃÂ\u0002ÃÂ¢ÃÂÃÂ","err":""},{"err":"","out":"\u0002ÃÂ¢ÃÂÃÂ\u0002\u001dÃÂ¢ÃÂÃÂ\u001d","code":"\"\u0002\\N{SPARKLE}\u0002\u001d\\N{SPARKLE}\u001d\"\n"},{"code":"\"\u0002\\N{SPARKLE}\u0002\u001d\u0002\\N{SPARKLE}\u001d\"\n","out":"\u0002ÃÂ¢ÃÂÃÂ\u0002\u001d\u0002ÃÂ¢ÃÂÃÂ\u001d","err":""},{"out":"n","err":"","code":"'\\n' =~ /^$/ ? 'y' : 'n'\n"},{"out":"y","err":"","code":"\"\\n\" =~ /^$/ ? 'y' : 'n'\n"},{"code":"\"\\n\" =~ /^\\z/ ? 'y' : 'n'\n","out":"n","err":""},{"code":"$^O\n","err":"","out":"openbsd"},{"code":"[ 'o010' + 0 ]\n","out":"[0]","err":""},{"out":"","err":"","code":"    $     OMG     =     8_0         ;$_;\n"},{"code":"    $     OMG     =     8_0         ;$_$;\n","out":"ERROR: syntax error at (eval 558) line 1, near \"$_$;\n\"\n","err":""},{"code":"    $     OMG     =     8_0      ;$    OMG\n","err":"","out":"80"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"$    OMG!\"\n","code":"    $     OMG     =     8_0      ;$    OMG!\n"},{"code":"    $     OMG     =     8_0      ;$    OMG\\\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"$    OMG\\\"\n"},{"code":"    $     OMG     =     8_0;                 $    OMG\n","out":"80","err":""},{"code":"    $     OMG     =     8_0;    $                 OMG\n","err":"","out":"80"},{"code":"open my $fh, '<', $z; [ map ref, \\1, [], {}, sub{}, qr//, \\pos, \\v1.2, $fh ]\n","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"LVALUE\",\"VSTRING\",\"GLOB\"]","err":""},{"err":"","out":"[\"SCALAR\",\"ARRAY\",\"HASH\",\"CODE\",\"Regexp\",\"LVALUE\",\"VSTRING\",\"REF\"]","code":"open my $fh, '<', $z; [ map ref, \\1, [], {}, sub{}, qr//, \\pos, \\v1.2, \\$fh ]\n"},{"code":"ord 'a'\n","out":"97","err":""},{"err":"","out":"88","code":"ord 'X'\n"},{"code":"ord 'Î§'\n","out":"206","err":""},{"code":"our @a; { push (local @a), 42 }; \\@a;\n","err":"","out":"[]"},{"err":"","out":"ERROR: loaded at (eval 558) line 1, <STDIN> line 1.\n\teval 'use 5.022001; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; our @CARP_NOT=qw/main/; Carp::croak(\"loaded\");' called at /home/ryan/bots/perlbuut/lib/eval.pl line 301\n\tmain::perl_code(\"our \\@CARP_NOT=qw/main/; Carp::croak(\\\"loaded\\\");\") called at /home/ryan/bots/perlbuut/lib/eval.pl line 248\n","code":"our @CARP_NOT=qw/main/; Carp::croak(\"loaded\");\n"},{"code":"our %temp = (1,2); [ *main::{ temp } ]\n","err":"","out":"[undef]"},{"err":"","out":"[undef]","code":"our %temp = (1,2); [ $main::{ 'temp' }{ HASH } ]\n"},{"code":"our %temp = (1,2); [ *main::{ 'temp' }{ HASH } ]\n","out":"ERROR: Can't use an undefined value as a HASH reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"our %temp; [ $main::{ 'temp' }\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","err":""},{"code":"our %temp; [ $main::{ 'temp' } ]\n","err":"","out":"[*::temp]"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"'HASH' ]\"\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n","err":"","code":"our %temp; [ $main::{ 'temp' }{ 'HASH' ]\n"},{"code":"our %temp; [ $main::{ 'temp' }{ 'HASH' } ]\n","err":"","out":"[undef]"},{"code":"our %temp; [ $main::{ 'temp' }{ HASH } ]\n","out":"[undef]","err":""},{"code":"our $VERSION = 'blah';  __PACKAGE__->VERSION\n","out":"ERROR: Invalid version format (non-numeric data) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"{1 => 3}","err":"","code":"%p = (1, 2); ++$$_ for \\(%p); \\%p\n"},{"code":"%p = (1, 2); [ (()=%p) ]\n","err":"","out":"[]"},{"code":"%p = (1, 2); [ \\(%p) ]\n","out":"[\\1,\\2]","err":""},{"out":"[{1 => 2}]","err":"","code":"%p = (1, 2); [ \\%p, map s/\\d/3/, (()=%p) ]\n"},{"code":"%p = (1, 2); [ \\%p, map s/\\d/3/, %p ]\n","out":"[{1 => 3},1,1]","err":""},{"err":"","out":"[{1 => 2},3,3]","code":"%p = (1, 2); [ \\%p, map s/\\d/3/r, %p ]\n"},{"err":"","out":"[{1 => undef},3,undef]","code":"%p = 1, 2; [ \\%p, map s/\\d/3/r, %p ]\n"},{"code":"%p = 1, 2; \\%p, map s/\\d/3/r, %p\n","err":"","out":"2"},{"out":"__PACAKAGE__","err":"","code":"__PACAKAGE__\n"},{"err":"","out":"ERROR: Can't locate object method \"pacakge\" via package \"Foo\" at (eval 558) line 1, <STDIN> line 1.\n","code":"pacakge Foo; sub foo { bar() }; BEGIN { print join \",\", keys %Foo:: }; \n"},{"code":"__PACKAGE__\n","err":"","out":"main"},{"out":"Later: BEGIN,quux,CHECK","err":"","code":"package Bar; CHECK { my @early; BEGIN { @early = keys %Bar:: }; print \"CHECK: @early\" }; sub quux { 42 }; print \"Later: \", join(\",\", keys %Bar:: )\n"},{"out":"Later: CHECK,BEGIN,quux","err":"","code":"package Bar; CHECK { my @early; BEGIN { @early = keys %Bar:: }; print \"@early\" }; sub quux { 42 }; print \"Later: \", join(\",\", keys %Bar:: )\n"},{"out":"[]","err":"","code":"package Bar; [ keys %Bar:: ]\n"},{"out":"[]","err":"","code":"package Bar; [ keys %Foo:: ]\n"},{"out":"Later: CHECK,quux,croak,BEGIN","err":"","code":"package Bar; use Carp qw,croak,; CHECK { my @early; BEGIN { @early = keys %Bar:: }; print \"CHECK: @early\" }; sub quux { 42 }; print \"Later: \", join(\",\", keys %Bar:: )\n"},{"code":"package Bar; use Carp qw,croak,; do { my @early; BEGIN { @early = keys %Bar:: }; print \"Early: @early\" }; sub quux { 42 }; print \"Later: \", join(\",\", keys %Bar:: )\n","err":"","out":"Early: croak BEGINLater: quux,croak,BEGIN"},{"out":"Later: croak,BEGIN,quux,INIT","err":"","code":"package Bar; use Carp qw,croak,; INIT { my @early; BEGIN { @early = keys %Bar:: }; print \"Early: @early\" }; sub quux { 42 }; print \"Later: \", join(\",\", keys %Bar:: )\n"},{"err":"","out":"*main::Charlie::","code":"package Charlie; sub talk { 'blah' }; package main; $::{'DB::Sandie::'} = $::{'Charlie::'};\n"},{"err":"","out":"ERROR: Can't locate object method \"talk\" via package \"DB::Sandie\" (perhaps you forgot to load \"DB::Sandie\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"package Charlie; sub talk { 'blah' }; package main; $::{'DB::Sandie::'} = $::{'Charlie::'}; DB::Sandie->talk\n"},{"code":"package Charlie; sub talk { 'blah' }; package main; *::{'DB::Sandie::'} = $::{'Charlie::'}; DB::Sandie->talk\n","err":"","out":"ERROR: Can't modify glob elem in scalar assignment at (eval 558) line 1, at EOF\n"},{"code":"package Charlie; sub talk { 'blah' }; package main; *::{'DB::Sandie::'} = *::{'Charlie::'}; DB::Sandie->talk\n","out":"ERROR: Can't modify glob elem in scalar assignment at (eval 558) line 1, at EOF\n","err":""},{"err":"","out":"ERROR: Can't modify glob elem in scalar assignment at (eval 558) line 1, at EOF\n","code":"package Charlie; sub talk { 'blah' }; package main; *::{'DB::Sandie::'} = \\%$::{'Charlie::'}; DB::Sandie->talk\n"},{"code":"package Charlie; sub talk { 'blah' }; package main; *{$::{'DB::Sandie::'}} = \\%{$::{'Charlie::'}}; DB::Sandie->talk\n","err":"","out":"ERROR: Can't use an undefined value as a symbol reference at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"package Charlie; sub talk { 'blah' }; package main; *{$::{'DB::Sandie::'}} = \\%{*::{'Charlie::'}}; DB::Sandie->talk\n","out":"ERROR: Can't use an undefined value as a HASH reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"package Charlie; sub talk { 'blah' }; package main; *DB::Sandie:: = *Charlie:: ; DB::Sandie->talk;\n","err":"","out":"blah"},{"code":"package Charlie; sub talk { 'blah' }; package main; local *DB::Sandie:: = *Charlie:: ; DB::Sandie->talk;\n","out":"blah","err":""},{"code":"package Charlie; sub talk { 'blah' }; package main; local $::{'DB::Sandy::'} = $::{'Charlie::'}; DB::Sandy->talk;\n","err":"","out":"ERROR: Can't locate object method \"talk\" via package \"DB::Sandy\" (perhaps you forgot to load \"DB::Sandy\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't modify glob elem in local at (eval 558) line 1, near \"} =\"\n","err":"","code":"package Charlie; sub talk { 'blah' }; package main; local *::{'DB::Sandy::'} = *::{'Charlie::'}; DB::Sandy->talk;\n"},{"code":"package Charlie; sub talk { 'blah' }; package main; local *::{'DB::Sandy::} = *::{'Charlie::'}; DB::Sandy->talk;\n","err":"","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't modify key/value hash slice in local at (eval 558) line 1, near \"} =\"\n","err":"","code":"package Charlie; sub talk { 'blah' }; package main; local %$::{'DB::Sandy::'} = %$::{'Charlie::'}; DB::Sandy->talk;\n"},{"code":"package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; Charlie->talk;\n","err":"","out":"blah"},{"out":"ERROR: Can't locate object method \"talk\" via package \"DB::Sandie\" (perhaps you forgot to load \"DB::Sandie\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; DB::Sandie->talk;\n"},{"code":"package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; $g = $Charlie::{'::'} [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]\n","err":"","out":""},{"code":"package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; $g = *Charlie:: ; [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]\n","err":"","out":"[{talk => *Charlie::talk},\\undef,undef,\\*{'::Charlie::'}]"},{"code":"package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; $g = *Charlie:: [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"*Charlie:: [\"\n","err":""},{"code":"package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; $g = $DB::Sandie::{'::'} [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]\n","err":"","out":""},{"err":"","out":"[{talk => *Charlie::talk},\\undef,undef,\\*{'::Charlie::'}]","code":"package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]\n"},{"err":"","out":"[{talk => *Charlie::talk},\\undef,undef,\\*{'::Charlie::'}]","code":"package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]\n"},{"code":"package Charlie; sub talk { 'blah' }; package main; my $g = \\*::{'Charlie::'}; [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]\n","err":"","out":"ERROR: Not a GLOB reference at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"*main::Charlie::","err":"","code":"package Charlie; sub talk { 'blah' }; package main; print $::{'Charlie::'}\n"},{"code":"package Charlie; sub talk { 'blah' }; package main; print *::{'Charlie::'}\n","out":"1","err":""},{"code":"package Foo; [ keys %Foo:: ]\n","err":"","out":"[]"},{"out":"[undef,\"main\",\"main\",undef,undef,undef]","err":"","code":"package Foo; [ map {scalar caller $_} -1 .. 4 ]\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"}::\n\"\n","err":"","code":"package Foo; our $foo = 42; package main; \\%{\\Foo}::\n"},{"code":"package Foo; our $foo = 42; package main; \\%Foo::\n","out":"{foo => *Foo::foo}","err":""},{"code":"package Foo; our $foo = 42; package main; \\%{Foo}::foo\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"%{Foo}::foo\n\"\n"},{"code":"package Foo; our $foo = 42; package main; \\%Foo::foo\n","out":"{}","err":""},{"out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"package Foo; our $foo = 42; package main; my $z = 'Foo';  \\%\"$x\"::\n"},{"code":"package Foo; our $foo = 42; package main; my $z = 'Foo';  \\%{{$x}::\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"}::\n\"\nMissing right curly or square bracket at (eval 558) line 1, at end of line\n"},{"code":"package Foo; our $foo = 42; package main; my $z = 'Foo';  \\%{$x}::\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"}::\n\"\n"},{"code":"package Foo; our $foo = 42; package main; my $z = 'Foo';  \\%$x::\n","err":"","out":"{}"},{"code":"package Foo; our $VERSION = 'blah'; package main; say Foo->VERSION\n","out":"ERROR: Invalid version format (non-numeric data) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"[undef]","code":"package Foo; package main; [ Foo->can('import') ]\n"},{"code":"package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );\n","out":"2","err":""},{"out":"42","err":"","code":"package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );  $x->can($foo{bar})->()\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"->\"$foo{bar}\"\"\n","code":"package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );  $x->\"$foo{bar}\"\n"},{"out":"ERROR: Not a CODE reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );  $x->(\"$foo{bar}\")\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"->\\\"\n","err":"","code":"package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );  $x->\\\"$foo{bar}\"\n"},{"out":"ERROR: Not a CODE reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' ); $x->($foo{bar})\n"},{"err":"","out":"ERROR: Not a CODE reference at (eval 558) line 1, <STDIN> line 1.\n","code":"package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' ); $x->(\\\"$foo{bar}\")\n"},{"err":"","out":"ERROR: Not a CODE reference at (eval 558) line 1, <STDIN> line 1.\n","code":"package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' ); $x->(\\$foo{bar})\n"},{"err":"","out":"baz","code":"package foo; sub bar {\"baz\"}; sub boo {\"boobs\"}; $a = \"bar\"; *{\"foo::\".$a}->()\n"},{"code":"package foo; sub bar {\"baz\"}; sub boo {\"boobs\"}; $a = \"bar\"; \\*{\"foo::\".$a}\n","out":"\\*foo::bar","err":""},{"out":"\\\"baz\"","err":"","code":"package foo; sub bar {\"baz\"}; sub boo {\"boobs\"}; $a = \"bar\"; \\*{\"foo::\".$a}->()\n"},{"out":"ERROR: Bad name after foo:: at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"package foo; sub bar {\"baz\"}; sub boo {\"boobs\"}; $a = \"bar\"; \\*{foo::$a}\n"},{"code":"package Foo; sub bar; [ grep defined &$_, keys %Foo:: ]\n","out":"[]","err":""},{"out":"[\"bar\"]","err":"","code":"package Foo; sub bar; [ keys %Foo:: ]\n"},{"code":"package Foo; sub bar; use strict; [ grep defined &$_, keys %Foo:: ]\n","out":"[]","err":""},{"err":"","out":"BEGIN,bar,foo","code":"package Foo; sub foo { bar() }; BEGIN { print join \",\", keys %Foo:: }; \n"},{"code":"package Foo; sub import {} package main; [ Foo->can('import') ]\n","out":"[sub { \"DUMMY\" }]","err":""},{"err":"","out":"bless( [42], 'FOO' )","code":"package FOO; sub new { return bless [42], __PACKAGE__ };  package main; use constant BAR => 'FOO';  BAR->new\n"},{"code":"package FOO; sub new { return bless [42], __PACKAGE__;  use constant BAR => 'FOO';  BAR->new\n","out":"ERROR: Missing right curly or square bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, at EOF\n","err":""},{"out":"","err":"","code":"package foo; tie *STDOUT, 'foo'; sub TIEHANDLE { return bless {}, 'foo' } sub PRINT { CORE::print \"TEST\" } print \"hello\"\n"},{"code":"package foo; tie *STDOUT, 'foo'; sub TIEHANDLE { return bless {}, 'foo' } sub PRINT { print \"TEST\" } print \"hello\"\n","err":"","out":""},{"code":"package Foo; use overload q{\"\"} => sub {42 }; package main; my $x = bless {}, 'Foo'; 'foo'->$x\n","out":"ERROR: Can't locate object method \"42\" via package \"foo\" (perhaps you forgot to load \"foo\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"package Foo; use overload q{\"\"} => sub {42 }; package main; my $x = bless sub{ 45 }, 'Foo'; [ 'foo'->$x // 'z', \"$x\" //'z' ]\n","err":"","out":"[45,42]"},{"code":"package Foo; use overload q{\"\"} => sub {42 }; package main; my $x = bless sub{}, 'Foo'; 'foo'->$x\n","err":"","out":""},{"code":"package Foo; use overload q{\"\"} => sub {42 }; package main; my $x = bless sub{}, 'Foo'; [ 'foo'->$x, \"$x\" ]\n","out":"[42]","err":""},{"code":"package Foo; use overload q{\"\"} => sub {42 }; package main; my $x = bless sub{}, 'Foo'; [ 'foo'->$x, \"$x\"]\n","out":"[42]","err":""},{"code":"package Foo; use overload q{\"\"} => sub {42 }; package main; my $x = bless sub{}, 'Foo'; [ 'foo'->$x // 'z', \"$x\" //'z' ]\n","out":"[\"z\",42]","err":""},{"code":"package Foo; use overload q{\"\"} => sub {42 }; package main; my $x = bless sub{ shift }, 'Foo'; [ 'foo'->$x // 'z', \"$x\" //'z' ]\n","err":"","out":"[\"foo\",42]"},{"code":"package Foo; use strict; use warnings; 'blah'->VERSION;\n","out":"","err":""},{"out":"blah","err":"","code":"package Foo; use strict; use warnings; our $VERSION = 'blah';\n"},{"code":"package Foo; use strict; use warnings; our $VERSION = 'blah'; package main; say Foo->VERSION\n","out":"ERROR: Invalid version format (non-numeric data) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Undefined subroutine &main::foo called at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"package Foo; use warnings; sub foo { undef()+0 }; package main; foo();\n"},{"code":"package Foo; use warnings; sub foo { undef+0 }; package main; foo();\n","err":"Warning: Use of \"undef\" without parentheses is ambiguous at (eval 558) line 1, <STDIN> line 1.\n","out":"ERROR: Can't modify constant item in undef operator at (eval 558) line 1, at EOF\n"},{"err":"Use of uninitialized value in addition (+) at (eval 558) line 1, <STDIN> line 1.\n","out":"0","code":"package Foo; use warnings; sub foo { undef()+0 }; package main; Foo::foo();\n"},{"code":"package Foo; use warnings; sub foo { undef()+0 }; package main; $Foo::{'^WARNING_BITS'}=0; Foo::foo();\n","out":"0","err":"Use of uninitialized value in addition (+) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"package Foo; use warnings; sub foo { undef()+0 }; package main; $Foo::{'^WARNING_BITS'}=0; Foo::foo(); [1]\n","err":"Use of uninitialized value in addition (+) at (eval 558) line 1, <STDIN> line 1.\n","out":"[1]"},{"out":"0","err":"Use of uninitialized value in addition (+) at (eval 558) line 1, <STDIN> line 1.\n","code":"package Foo; use warnings; sub foo { undef()+0 }; package main; no warnings; Foo::foo();\n"},{"code":"package Foo; use warnings; sub foo { undef()+0 }; package main; no warnings 'Foo::uninitialized'; Foo::foo();\n","err":"","out":"ERROR: Unknown warnings category 'Foo::uninitialized' at (eval 558) line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"package OOBLA; sub _compare {\"compare\"}; $self = bless {}; my $method = $self->can(\"_compare_\".ref $comp) || $self->can(\"_compare\"); &$method($self, \"foo\");\n","out":"compare","err":""},{"code":"package OOBLA; sub _compare {\"compare\"}; $self = bless {}; my $method = $self->can(\"_compare_\".ref $comp) || $self->can(\"_compare\"); &$method($self, \\\"foo\");\n","out":"compare","err":""},{"code":"package OOBLA; sub _compare {\"compare\"}; sub _compare_SCALAR {\"compare_scalar\"}; my $self = bless {}; my $comp = \"foo\"; my $method = $self->can(\"_compare_\".ref $comp) || $self->can(\"_compare\"); &$method($self, $comp);\n","err":"","out":"compare"},{"code":"package OOBLA; sub _compare {\"compare\"}; sub _compare_SCALAR {\"compare_scalar\"}; my $self = bless {}; my $comp = \\\"foo\"; my $method = $self->can(\"_compare_\".ref $comp) || $self->can(\"_compare\"); &$method($self, $comp);\n","err":"","out":"compare_scalar"},{"code":"package OOBLA; sub _compare {\"compare\"}; sub _compare_SCALAR {\"compare_scalar\"}; $self = bless {}; my $method = $self->can(\"_compare_\".ref $comp) || $self->can(\"_compare\"); &$method($self, \\\"foo\");\n","err":"","out":"compare"},{"code":"package OOBLA; sub _compare_OOBLA {\"compare_OOBLA\"; \\@_}; sub _compare {\"compare\"}; sub _compare_SCALAR {\"compare_scalar\"}; my $self = bless {}; my $comp = $self; my $method = $self->can(\"_compare_\".ref $comp) || $self->can(\"_compare\"); $method->($self, $comp);\n","err":"","out":"[bless( {}, 'OOBLA' ),$VAR1->[0]]"},{"code":"package OOBLA; sub _compare_OOBLA {\"compare_OOBLA\"}; sub _compare {\"compare\"}; sub _compare_SCALAR {\"compare_scalar\"}; my $self = bless {}; my $comp = $self; my $method = $self->can(\"_compare_\".ref $comp) || $self->can(\"_compare\"); $method->($self, $comp);\n","err":"","out":"compare_OOBLA"},{"code":"package OOBLA; sub _compare_OOBLA {\"compare_OOBLA\"}; sub _compare {\"compare\"}; sub _compare_SCALAR {\"compare_scalar\"}; my $self = bless {}; my $comp = $self; my $method = $self->can(\"_compare_\".ref $comp) || $self->can(\"_compare\"); &$method($self, $comp);\n","err":"","out":"compare_OOBLA"},{"code":"package OOBLA; sub _compare_OOBLA {\"compare_OOBLA\"; \\@_}; sub _compare {\"compare\"}; sub _compare_SCALAR {\"compare_scalar\"}; my $self = bless {}; my $comp = $self; $self->${[\"_compare\"]}\n","out":"ERROR: Not a SCALAR reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"package OOBLA; sub _compare_OOBLA {\"compare_OOBLA\"; \\@_}; sub _compare {\"compare\"}; sub _compare_SCALAR {\"compare_scalar\"}; my $self = bless {}; my $comp = $self; $self->${\\(\"_compare\")}\n","err":"","out":"compare"},{"err":"","out":"[1]","code":"package _; use constant test => 1; [ _->test ]\n"},{"err":"","out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n","code":"package Ï; package main; require Ï;\n"},{"out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"package Ï; sub 2 {atan2(1,1) * 2}; Ï::2\n"},{"code":"package Ï; sub new { bless {}, shift } package main;   my $x = Ï->new; say $x\n","out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"package Ï; use overload fallback => 1, '+' => sub () {atan2(0,-1)}; 0+bless []\n"},{"err":"","out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n","code":"package Ï; use overload fallback => 1, '+' => sub {atan2(0,-1)}; 0+bless []\n"},{"out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"package Ï; use overload fallback => 1, '+' => sub () {atan2(0,-1)}; ''.bless []\n"},{"err":"","out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n","code":"package Ï; use overload '+' => sub () {atan2(0,-1)}; ''.bless []\n"},{"code":"package Ï; use Ï;\n","out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"package Ï; \\*{\"Ï::2\"}\n"},{"code":"package Ï; *{\"Ï::2\"} = sub {atan2(0,-1)}; Ï->${\\2}\n","err":"","out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"package Ï; *{\"Ï::2\"} = sub {atan2(1,1) * 2}\n"},{"out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"package Ï; *{\"Ï::2\"} = sub {atan2(1,-1) * 2}; Ï->${\\2}\n"},{"code":"package Ï; *{\"Ï::2\"} = sub {atan2(1,1) * 2}; Ï->2\n","out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n","code":"package Ï; *{\"Ï::2\"} = sub {atan2(1,1) * 2}; Ï->${\\2}\n"},{"code":"package Ï; *{\"Ï::2\"} = sub {atan2(1,1) * 2}; Ï::2\n","out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"package Ï; *{\"Ï::2\"} = sub {atan2(1,-1)}; Ï->${\\2}\n"},{"code":"package Ï; *{\"Ï::(+\"} = sub () {atan2(0,-1)}; ''.bless []\n","err":"","out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"package Ï; *{\"Ï::+)\"} = sub () {atan2(0,-1)}; ''.bless []\n","out":"ERROR: Unrecognized character \\xCF; marked by <-- HERE after ; package <-- HERE near column 99 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"[pack(\"C*\", 0)];\n","err":"","out":"[\"\\0\"]"},{"code":"pack(\"C*\", 0);\n","out":"\u0000","err":""},{"out":"ÃÂÃÂÃÂÃÂÃÂÃÂÃÂ¹?","err":"","code":"pack \"d\", 0.1\n"},{"code":"[ pack 'H', 1 ]\n","out":"[\"\\20\"]","err":""},{"code":"pack(\"H*\", 4095);\n","err":"","out":"@ÃÂ"},{"code":"pack \"H*\", \"547275746820\"\n","out":"Truth ","err":""},{"code":"pack \"H*\", \"54727574682077617320746865206f6e6c79206461\"\n","out":"Truth was the only da","err":""},{"code":"pack \"H*\", \"54727574682077617320746865206f6e6c79206461756768746572206f662054696d652e\"\n","out":"Truth was the only daughter of Time.","err":""},{"out":"ÃÂ¢ÃÂÃÂ","err":"","code":"print 'â' .. 'â'\n"},{"err":"","out":"1","code":"print 1\n"},{"out":"1","err":"","code":"print 1; 1\n"},{"err":"","out":"1","code":"print 1; 2\n"},{"err":"","out":"1","code":"print 123 =~ /[[digit]]/;\n"},{"out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after s/; print <-- HERE near column 97 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"print â42â\n"},{"err":"","out":"4","code":"print 4; 2\n"},{"code":"print \"\\a\"\n","err":"","out":"\u0007"},{"code":"printf '[%5s]', 'x'\n","err":"","out":"[    x]"},{"code":"print \"I'm a Perl \", 5 + !!\"0\", \" program.\"\n","out":"I'm a Perl 5 program.","err":""},{"code":"print q Í¾ $a Í¾ \n","err":"","out":"ERROR: Unrecognized character \\xBE; marked by <-- HERE after  q ÃÂÃÂ¾ $a ÃÂ<-- HERE near column 106 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"print qÍ¾ $aÍ¾ \n","err":"","out":"ERROR: Unrecognized character \\xBE; marked by <-- HERE after nt qÃÂÃÂ¾ $aÃÂ<-- HERE near column 104 at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"foo/bar","err":"","code":"print q\u001dfoo/bar\u001d\n"},{"err":"","out":"cbvokujpfynsewmtdxlrgqiah","code":"print sort { $|-- or -1 } 'a'..'y'\n"},{"code":"print sort { $|-- or -1 } 'ruJt tc,en hoetokarrasS h'\n","err":"","out":"ruJt tc,en hoetokarrasS h"},{"out":"Just another Sort hacker,","err":"","code":"print sort { $|-- or -1 } 'ruJt tc,en hoetokarrasS h' =~ /./g\n"},{"code":"print \"\\x{1f4a9}\"\n","out":"ÃÂ°ÃÂÃÂÃÂ©","err":""},{"err":"","out":"ERROR: Can't use an undefined value as a HASH reference at (eval 558) line 1, <STDIN> line 1.\n","code":"push(@$campaigns_by_type->{$$campaign{'campaign_type'}}, $campaign);  [ $campaigns_by_type ]\n"},{"out":"ERROR: Recursive inheritance detected in package 'main' at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"push @ISA, 'main'; [ main::->can('foo') ]\n"},{"code":"qÍ¾Í¾\n","out":"ERROR: Unrecognized character \\xBE; marked by <-- HERE after res/; qÃÂÃÂ¾ÃÂ<-- HERE near column 95 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"qÍ¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾Í¾\n","out":"ERROR: Unrecognized character \\xBE; marked by <-- HERE after res/; qÃÂÃÂ¾ÃÂ<-- HERE near column 95 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":";$a;","err":"","code":"q=;$a;=;\n"},{"out":";$a; ","err":"","code":"q=;$a; =;\n"},{"err":"","out":"; $a; ","code":"q =; $a; =;\n"},{"out":"5","err":"","code":"q =; $a; =; 5; \n"},{"out":"ERROR: Unrecognized character \\xBE; marked by <-- HERE after  q ÃÂÃÂ¾ $a ÃÂ<-- HERE near column 117 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"q= $a = 5; print q Í¾ $a Í¾ \n"},{"err":"","out":"ERROR: Unrecognized character \\xBE; marked by <-- HERE after  q ÃÂÃÂ¾ $a ÃÂ<-- HERE near column 121 at (eval 558) line 1, <STDIN> line 1.\n","code":"q =; $a; =; 5; print q Í¾ $a Í¾ \n"},{"out":"Js nte othce,utaohrSr akr","err":"","code":"$_ = q<acegikmoqsuwybdfhjlnprtvx>; tr/a-y/Just another Sort hacker,/; print\n"},{"code":"$_ = qÂ«acegikmoqsuwybdfhjlnprtvxÂ»; tr/a-y/Just another Sort hacker,/; print\n","err":"","out":"ERROR: Unrecognized character \\xBB; marked by <-- HERE after hjlnprtvxÃÂ<-- HERE near column 125 at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"1","err":"","code":"q|{:amount($[4.95e0, 4.85e0, 2.4e0]), :description($[\"Hot beef burrito\", \"Mild fish taco\", \"Medium size orange juice\"]), :name($[\"BUBH\", \"TAFM\", \"BEOM\"]), :price($[4.95e0, 4.85e0, 1.2e0]), :quantity($[1, 1, 2])}| eq q|{:amount($[4.95e0, 4.85e0, 2.4e0]), :description($[\"Hot beef burrito\", \"Mild fish taco\", \"Medium size orange juice\"]), :name($[\"BUBH\", \"TAFM\", \"BEOM\"]), :price($[4.95e0, 4.85e0, 1.2e0]), :quantity($[1, 1, 2])}|\n"},{"out":"ERROR: Can't find string terminator \"=\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"q= $a; print q Í¾ $a Í¾ \n"},{"out":"ERROR: Can't find string terminator \"=\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"q = $a; print q Í¾ $a Í¾ \n"},{"code":"q=;$a;==~s/;//gr\n","out":"$a","err":""},{"out":"ERROR: syntax error at (eval 558) line 1, near \"q=;$a;=~\"\n","err":"","code":"q=;$a;=~s/;//r\n"},{"err":"","out":"$a;","code":"q=;$a;==~s/;//r\n"},{"code":"q=;$a;=;=~s/;//r\n","out":"ERROR: syntax error at (eval 558) line 1, near \";=~\"\n","err":""},{"code":"[ q(\\d) ]\n","out":"[\"\\\\d\"]","err":""},{"err":"","out":"[\"echo\",\"foo\",\"bar=baz\",\"hmm=\\\"1 2 3\\\"\",\"nn='aa bb'\"]","code":"$_ = q,echo foo bar=baz hmm=\"1 2 3\" nn='aa bb',; my @h; s/(([\"'])(?:[^\"']+|\\\\.|(?!\\2).)*\\2)/push @h, $1;\"\\xFFFD\"/ge; my @words = split ' '; s/\\xFFFD/shift @h/ge for @words; \\@words;\n"},{"code":"[  q{\"foo bar \\\"something\\\"\"} =~ s/(?!<=\\\\)\"//gr ]\n","out":"[\"foo bar \\\\something\\\\\"]","err":""},{"err":"","out":"ERROR: Unrecognized character \\x80; marked by <-- HERE after s/; q ÃÂ¢ÃÂÃÂ¤ÃÂ¢<-- HERE near column 97 at (eval 558) line 1, <STDIN> line 1.\n","code":"q â¤â Happy Valentine's Day, #perl â¤â  s â¤ â¤ â¤âr\n"},{"code":"q â¤â Happy Valentine's Day, #perl â¤â  s â¤ â¤âr\n","err":"","out":"ERROR: Unrecognized character \\x80; marked by <-- HERE after s/; q ÃÂ¢ÃÂÃÂ¤ÃÂ¢<-- HERE near column 97 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"q{Number::RGB->new_from_guess() couldn't guess type} =~ /new_from_guess() couldn't guess/ ? 'y' : 'n'\n","err":"","out":"n"},{"code":"q ð âº Perl \\o/ âº  ð\n","err":"","out":"ERROR: Unrecognized character \\x9F; marked by <-- HERE after \\o/ ÃÂ¢ÃÂÃÂº  ÃÂ°<-- HERE near column 117 at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"[\"\\\\~\\\\!\\\\\\@\\\\#0\\\\^\\\\&\\\\*\\\\(\\\\)_\\\\\\\\\\\\+\\\\?\"]","err":"","code":"[ quotemeta \"~!@#$%^&*()_\\\\+?\" ]\n"},{"err":"","out":"\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)_\\\\\\{\\}\\.\\,\\+\\?","code":"quotemeta '~!@#$%^&*()_\\\\{}.,+?'\n"},{"code":"quotemeta '~!@#$%^&*()_\\\\+?'\n","out":"\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)_\\\\\\+\\?","err":""},{"err":"","out":"\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)_\\+\\?","code":"quotemeta '~!@#$%^&*()_+?'\n"},{"code":"quotemeta \"Ç\n","out":"ERROR: Can't find string terminator '\"' anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ÃÂ­ÃÂÃÂ","code":"quotemeta \"\\x{D000}\"\n"},{"code":"({qw/ a 1 b 2/})->{b}\n","out":"2","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"}->\"\n","code":"{qw/ a 1 b 2/}->{b}\n"},{"err":"","out":"take_a_cab","code":"qw/dial_a_bottle  take_a_cab/[rand 2]\n"},{"code":"qw[foo bar]\n","out":"bar","err":""},{"out":"[[1,2,3,{ber => \"bez\",foo => \"bar\"}],[42,2,3,$VAR1->[0][3]]]","err":"","code":"$r = [ 1, 2, 3, { foo => bar }, ]; @a = @$r; $r->[0] = 42; $r->[3]{ber} = 'bez'; [ \\@a, $r ]\n"},{"code":"rand 4\n","err":"","out":"1.24603047351218"},{"err":"","out":"","code":"readpipe q(echo foo)\n"},{"err":"","out":"[\"foo\"]","code":"[ref bless [], 'foo' ]\n"},{"err":"","out":"ERROR: Undefined subroutine &CORE::GLOBAL::print called at (eval 558) line 1, <STDIN> line 1.\n","code":"ref &CORE::GLOBAL::print\n"},{"code":"ref *CORE::print\n","out":"","err":""},{"err":"","out":"GLOB","code":"ref \\*CORE::print\n"},{"out":"ERROR: Undefined subroutine &CORE::print called at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"ref &CORE::print\n"},{"out":"ERROR: Undefined subroutine &main::print called at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"ref &print\n"},{"code":"ref qr//\n","out":"Regexp","err":""},{"out":"[1]","err":"","code":"[ require File::Spec ]\n"},{"code":"require Foo; [ Foo::bar \"baz\" ]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"Foo::bar \"baz\"\"\n","err":""},{"code":"require Foo; [ Foo::bar( \"baz\" ) ]\n","err":"","out":"ERROR: Can't locate Foo.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ÃÂ°ÃÂÃÂÃÂ","code":"$s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand(4)]; $c=int(rand(13)); chr 0x1F000+$s+$c\n"},{"err":"","out":"352","code":"$s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand*4]; $c=int(rand*13);  hex $s+$c\n"},{"code":"$s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand*4]; $c=int(rand*13); pack \"H*\" $s+$c\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"\"H*\" $s\"\n"},{"out":"\u0016\u0000","err":"","code":"$s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand*4]; $c=int(rand*13); pack \"H*\", $s+$c\n"},{"out":"170","err":"","code":"$s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand()*4]; $c=int(rand() *13); $s+$c\n"},{"out":"183","err":"","code":"$s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand(4)]; $c=int(rand(13)); $s+$c\n"},{"code":"$s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand*4]; $c=int(rand*13);  $s+$c\n","err":"","out":"160"},{"code":"$s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand*4]; $c=int(rand*13); $s+$c\n","out":"160","err":""},{"code":"$s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand*4]; $c=int(rand*13); unpack \"H*\", $s+$c\n","err":"","out":"313630"},{"out":"ERROR: Not a CODE reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$s=[0xA0, 0xB0, 0xC0, 0xD0]->(rand*4); $c=rand*13; unpack \"H*\", $s+$c\n"},{"code":"$s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand*4]; $c=rand*13; unpack \"H*\", $s+$c\n","err":"","out":"3136302e383730343736353530393237"},{"code":"s/(A)/'lcfirst $1'/ee\n","err":"","out":""},{"err":"","out":"","code":"s/(A)/'lcfirst $1'/ee; $_\n"},{"err":"","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after res/; say <-- HERE near column 95 at (eval 558) line 1, <STDIN> line 1.\n","code":"say â\n"},{"code":"say \"\\002\"\n","err":"","out":"\u0002\n"},{"code":"say \\002\n","err":"","out":"SCALAR(0x48f1f70)\n"},{"code":"say \"!(0 || 1 && (0 || 0)) && !(1 && 1)\"\n","err":"","out":"!(0 || 1 && (0 || 0)) && !(1 && 1)\n"},{"out":"ERROR: POSIX class [:hexdigit:] unknown in regex; marked by <-- HERE in m/^[[:hexdigit:] <-- HERE ]{40}$/ at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"say '4c6567f85f0980f30987b69b78767647c2165a26' =~ /^[[:hexdigit:]]{40}$/ ? 'y' : 'n'\n"},{"code":"say '4c6567f85f0980f30987b69b78767647c2165a26' =~ /^[[:xdigit:]]{40}$/ ? 'y' : 'n'\n","out":"y\n","err":""},{"code":"say '4c6567f85f0980f30987b69b78767647c2165a26' ? 'y' : 'n'\n","err":"","out":"y\n"},{"code":"say blahblah \n","err":"","out":""},{"out":"ÃÂ¯ÃÂºÃÂ\n","err":"","code":"say chr 0xFE86\n"},{"code":"say chr 10689\n","out":"ÃÂ¢ÃÂ§ÃÂ\n","err":""},{"code":"say for 0.. 0xFF\n","out":"0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n","err":""},{"code":"say hex 42\n","err":"","out":"66\n"},{"err":"","out":"250\n","code":"say hex 'FA'\n"},{"err":"","out":"1\n","code":"say length chr 0xFE86\n"},{"code":"say length chr 10689\n","err":"","out":"1\n"},{"code":"say length q|0.99999999999992|\n","out":"16\n","err":""},{"err":"","out":"1\n","code":"say length quotemeta chr 0xFE86\n"},{"out":"2\n","err":"","code":"say length quotemeta chr 10689\n"},{"out":"3\n","err":"","code":"say length \"ïº\"\n"},{"err":"","out":"ERROR: Unknown charname 'COMBINING ACCUTE ACCENT' at (eval 558) line 1, within string\n","code":"say \"\\N{COMBINING ACCUTE ACCENT}y\"\n"},{"err":"","out":"10\n","code":"say ord \"\\n\"\n"},{"code":"say q|{:amount($[4.95e0, 4.85e0, 2.4e0]), :description($[\"Hot beef burrito\", \"Mild fish taco\", \"Medium size orange juice\"]), :name($[\"BUBH\", \"TAFM\", \"BEOM\"]), :price($[4.95e0, 4.85e0, 1.2e0]), :quantity($[1, 1, 2])}| eq q|{:amount($[4.95e0, 4.85e0, 2.4e0]), :description($[\"Hot beef burrito\", \"Mild fish taco\", \"Medium size orange juice\"]), :name($[\"BUBH\", \"TAFM\", \"BEOM\"]), :price($[4.95e0, 4.85e0, 1.2e0]), :quantity($[1, 1, 2])}|\n","err":"","out":"1\n"},{"code":"say q|{:amount($[4.95e0, 4.85e0, 2.4e0]), :description($[\"Hot beef burrito\", \"Mild fish taco\", \"Medium size orange juice\"]), :name($[\"BUBH\", \"TAFM\", \"BEOM\"]), :price($[4.95e0, 4.85e0, 1.2e0]), :quantity($[1, 1, 2])}| eq q|{:amount($[4.95e0, 4.85e0, 2.4e0]), :description($[\"Hot beef burrito\", \"Mild fish taco\", \"Medium size orange juice\"]), :name($[\"BUBH\", \"TAFM\", \"BEOM\"]), :price($[4.95e0, 4.85e0, 1.2e0]), :quantity($[1, 1, 2])}| ? 's\n","err":"","out":"ERROR: Can't find string terminator \"'\" anywhere before EOF at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"\n","code":"say ref $^O\n"},{"err":"","out":"version\n","code":"say ref $^V\n"},{"code":"say sort { $|-- or -1 } 'ruJt tc,en hoetokarrasS h' =~ /./g\n","out":"Just another Sort hacker,\n","err":""},{"err":"","out":"64\n","code":"say sprintf '%x', 100\n"},{"out":"f\n","err":"","code":"say sprintf '%x', 15\n"},{"err":"","out":"10\n","code":"say sprintf '%x', 16\n"},{"err":"","out":"60\n","code":"say sprintf '%x', 96\n"},{"code":"say \"$^V\"\n","out":"v5.22.1\n","err":""},{"err":"","out":"v5.22.1\n","code":"say $^V\n"},{"code":"say â * Ï\n","err":"","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after res/; say <-- HERE near column 95 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"[ scalar asdfadsf->import ]\n","out":"[]","err":""},{"code":"scalar grep $_, 1..5\n","out":"5","err":""},{"code":"[ scalar keys \\%INC ]\n","err":"","out":"[498]"},{"err":"","out":"[\"a\",2,3]","code":"$self->{messages} = [1,2,3]; $self->{messages}->[0] = \"a\"; $self->{messages}\n"},{"code":"$_ = '@@@'; s'@'$'gr; \n","err":"","out":"$$$"},{"code":"\"\\\\\" =~ s'\\'\\\\'gsr;\n","err":"","out":"ERROR: Substitution replacement not terminated at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"\"\\\\\" =~ s'\\\\'\\\\'gsr;\n","out":"\\","err":""},{"err":"","out":"ERROR: Unrecognized character \\x9D; marked by <-- HERE after y, #perl ÃÂ¢<-- HERE near column 130 at (eval 558) line 1, <STDIN> line 1.\n","code":"s â¤â Happy Valentine's Day, #perl â¤â â¤â â¤âr\n"},{"out":"[undef]","err":"","code":"[shift]\n"},{"code":"$SIG{__DIE__} = sub { say \"42\"; } '..'\n","out":"ERROR: syntax error at (eval 558) line 1, near \"} '..'\"\n","err":""},{"code":"$SIG{__DIE__} = sub { say 42 };  die  \n","out":"42\nERROR: Died at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"0","code":"-sin\n"},{"err":"","out":"[\"-sin\"]","code":"[ -(sin =>)  ]\n"},{"err":"","out":"[\"-sin\"]","code":"[ -sin =>  ]\n"},{"out":"[0]","err":"","code":"[ -sin  ]\n"},{"err":"","out":"[\"sin\"]","code":"[ sin =>  ]\n"},{"err":"","out":"some text \n[3] some more text \n[4] even more text","code":"\"some text [3] some more text [4] even more text\" =~ s/(?=\\[\\d+\\])/\\n/gr\n"},{"out":"some text ÃÂ¢ÃÂÃÂ¤[3] some more text ÃÂ¢ÃÂÃÂ¤[4] even more text","err":"","code":"\"some text [3] some more text [4] even more text\" =~ s/(?=\\[)/â¤/gr\n"},{"code":"\"some text [3] some more text [4] even more text\" =~ s/(?=[)/\\n/gr\n","out":"ERROR: Unmatched [ in regex; marked by <-- HERE in m/(?=[ <-- HERE )/ at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"some text \n[3] some more text \n[4] even more text","err":"","code":"\"some text [3] some more text [4] even more text\" =~ s/(?=\\[)/\\n/gr\n"},{"out":"[5,3,2]","err":"","code":"[sort { -1 } 5, 2, 3]\n"},{"code":"[sort {--$|} a..'y']\n","out":"[\"a\",\"b\",\"d\",\"c\",\"e\",\"f\",\"h\",\"g\",\"i\",\"j\",\"l\",\"k\",\"m\",\"n\",\"p\",\"o\",\"q\",\"r\",\"t\",\"s\",\"u\",\"v\",\"x\",\"w\",\"y\"]","err":""},{"code":"[sort {--$|} a..y]\n","out":"ERROR: Transliteration pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"[sort {$|--} a..'y']\n","out":"[\"c\",\"b\",\"d\",\"a\",\"f\",\"e\",\"g\",\"h\",\"j\",\"i\",\"k\",\"l\",\"n\",\"m\",\"o\",\"p\",\"r\",\"q\",\"s\",\"t\",\"v\",\"u\",\"w\",\"x\",\"y\"]","err":""},{"code":"[ sort { int(rand(3)) - 1 } 1..20 ]\n","err":"","out":"[11,6,5,15,12,1,7,16,2,3,4,17,9,8,10,14,18,13,19,20]"},{"out":"[\"a\",\"b\",\"u\",\"p\",\"l\",\"v\",\"i\",\"o\",\"e\",\"y\",\"m\",\"t\",\"f\",\"x\",\"n\",\"s\",\"d\",\"w\",\"k\",\"q\",\"h\",\"r\",\"j\",\"c\",\"g\"]","err":"","code":"[sort { --$| or -1 } 'a'..'y']\n"},{"out":"[\"c\",\"b\",\"v\",\"o\",\"k\",\"u\",\"j\",\"p\",\"f\",\"y\",\"n\",\"s\",\"e\",\"w\",\"m\",\"t\",\"d\",\"x\",\"l\",\"r\",\"g\",\"q\",\"i\",\"a\",\"h\"]","err":"","code":"[sort { $|-- or -1 } 'a'..'y']\n"},{"err":"","out":"","code":"sort { --$| or -1 } 'a'..'y'\n"},{"code":"[ sort { rand(3) - 1 } 1..20 ]\n","err":"","out":"[9,3,4,1,2,5,6,7,8,10,16,11,12,13,14,15,18,17,19,20]"},{"out":"[18,19,20,6,17,12,15,10,11,16,5,14,13,9,7,1,8,2,4,3]","err":"","code":"[ sort { rand() > .5 ? 1 : -1 } 1..20 ]\n"},{"err":"","out":"[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]","code":"[ sort { rand() - .5 } 1..20 ]\n"},{"out":"[\"foo\",\"\",\"\",\"\",\"\",\"bar\"]","err":"","code":"[ split / /, \"foo     bar\" ]\n"},{"err":"","out":"[[\"foo\",\"\",\"\",\"\",\"\",\"bar\"],[\"foo\",\"bar\"]]","code":"[[ split / /, \"foo     bar\" ], [ split ' ', \"foo     bar\" ]]\n"},{"out":"[\"foo\",\"bar\",\"mer\"]","err":"","code":"[ split ' ', \"foo  \\n  bar\\nmer\\n  \"]\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"bin sprintf\"\n","err":"","code":"[ sprintf('%020b', 4), bin sprintf('%b', 4 << 1) ]\n"},{"code":"[ sprintf('%020b', 4), oct '0b' .  sprintf('%b', 4 << 1) ]\n","err":"","out":"[\"00000000000000000100\",8]"},{"out":"[\"00000000000000000100\",1000]","err":"","code":"[ sprintf('%020b', 4), sprintf('%b', 4 << 1) ]\n"},{"out":"[\".0f%\"]","err":"","code":"[ sprintf '.0f%', 8.5 ]\n"},{"code":"[ sprintf '%.0f', 8.5 ]\n","out":"[8]","err":""},{"code":"sprintf '%1$s %1$s', 'foo'\n","err":"","out":"foo foo"},{"code":"[ sprintf('%20b', 4), sprintf('%b', 4 << 1) ]\n","err":"","out":"[\"                 100\",1000]"},{"err":"","out":"[100,1000]","code":"[ sprintf('%2b', 4), sprintf('%b', 4 << 1) ]\n"},{"code":"[ sprintf('%b', 3), sprintf('%b', 3 << 1) ]\n","out":"[11,110]","err":""},{"out":"[\"b\",\"b\"]","err":"","code":"[ sprintf('b', 3), sprintf('b', 3 << 1) ]\n"},{"code":"[ sprintf('%b', 4), sprintf('%b', 4 << 1) ]\n","err":"","out":"[100,1000]"},{"err":"","out":"[8]","code":"[ sprintf '%.f', 8.5 ]\n"},{"err":"","out":"[8]","code":"[ sprintf '%.f', 8.5, 11.5 ]\n"},{"code":"$_ = '@@@'; s'@'$'r; \n","err":"","out":"$@@"},{"out":"ERROR: Too many arguments for chr at (eval 558) line 1, near \"0x202e)\"\n","err":"","code":"srand 42; my @o = chr(0x202d, 0x202e); print \"$o[rand 2]$_\" for 'a'..'z', '_';\n"},{"err":"","out":" 2ea 2db 2dc 2dd 2de 2ef 2dg 2dh 2ei 2ej 2dk 2el 2em 2dn 2eo 2ep 2eq 2dr 2es 2dt 2du 2dv 2ew 2dx 2ey 2ez 2e_","code":"srand 42; my @o = (\"\\x202d\", \"\\x202e\"); print \"$o[rand 2]$_\" for 'a'..'z', '_';\n"},{"out":"wolfrevostac","err":"","code":"$_ = \"stackoverflow\"; reverse 'catsoverflow'\n"},{"err":"","out":"catsoverflow","code":"$_ = \"stackoverflow\"; reverse 'wolfrevostac'\n"},{"out":"","err":"","code":"state $x;\n"},{"code":"state $x; ++$x\n","out":"1","err":""},{"code":"$_ = \"STDERR output success\\nSTDERR output fsuccess\\n\";  /^STDERR output success(?=.(?!STDERR output success))/ ? 'y' : 'n'\n","err":"","out":"n"},{"code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STD42ERR output success(?!STDERR output success)/ ? 'y' : 'n'\n","err":"","out":"n"},{"err":"","out":"y","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?=\\nSTDERR output success)/ ? 'y' : 'n'\n"},{"code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?!\\nSTDERR output success)/ ? 'y' : 'n'\n","out":"n","err":""},{"err":"","out":"n","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?!.*STDERR output success)/s ? 'y' : 'n'\n"},{"code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success.*?(?!STDERR output success)/ ? 'y' : 'n'\n","err":"","out":"y"},{"err":"","out":"y","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success.*(?!STDERR output success)/ ? 'y' : 'n'\n"},{"code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?=.(?!STDERR output success))/ ? 'y' : 'n'\n","out":"n","err":""},{"out":"y","err":"","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?=.*(?!STDERR output success))/ ? 'y' : 'n'\n"},{"err":"","out":"n","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?=STDERR output success)/ ? 'y' : 'n'\n"},{"code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?!.*STDERR output success)/ ? 'y' : 'n'\n","err":"","out":"y"},{"out":"y","err":"","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?!.+STDERR output success)/ ? 'y' : 'n'\n"},{"out":"ERROR: Unmatched ) in regex; marked by <-- HERE in m/^STDERR output success(?!.+STDERR output success)) <-- HERE / at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?!.+STDERR output success))/ ? 'y' : 'n'\n"},{"out":"y","err":"","code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?!STDERR output success)/ ? 'y' : 'n'\n"},{"code":"$_ = \"STDERR output success\\nSTDERR output success\\n\";  /^STDERR output success(?.*(?!STDERR output success))/ ? 'y' : 'n'\n","err":"","out":"ERROR: Sequence (?....) not recognized in regex; marked by <-- HERE in m/^STDERR output success(?. <-- HERE *(?!STDERR output success))/ at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: Too many arguments for subroutine at (eval 558) line 1.\n","code":"sub add ( $x = return 0, $y = return $x ) { return $x + $y }   [ add(), add(2), add(2,3), add(2,3,4) ]\n"},{"code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/ }; fizz(), buzz();\n","out":"fizzbuzz","err":""},{"code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/, \" \" }; for(1..100) { undef($f), fizz() if 2 == ++$f; undef($b), buzz() if 4 == ++$b; $f && $b || &{$_}() }\n","err":"","out":"fizz 2 fizz buzz 4 fizz 6 fizz buzz 8 fizz 10 fizz buzz 12 fizz 14 fizz buzz 16 fizz 18 fizz buzz 20 fizz 22 fizz buzz 24 fizz 26 fizz buzz 28 fizz 30 fizz buzz 32 fizz 34 fizz buzz 36 fizz 38 fizz buzz 40 fizz 42 fizz buzz 44 fizz 46 fizz buzz 48 fizz 50 fizz buzz 52 fizz 54 fizz buzz 56 fizz 58 fizz buzz 60 fizz 62 fizz buzz 64 fizz 66 fizz buzz 68 fizz 70 fizz buzz 72 fizz 74 fizz buzz 76 fizz 78 fizz buzz 80 fizz 82 fizz buzz 84 fizz 86 fizz buzz 88 fizz 90 fizz buzz 92 fizz 94 fizz buzz 96 fizz 98 fizz buzz 100 "},{"code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/, \" \" }; for(1..100) { undef($f), fizz() if 2 == ++$f; undef($b), buzz() if 4 == ++$b; $f && $b && nope(); &{$_}() }\n","err":"","out":"nope 1 fizz 2 nope 3 fizz buzz 4 nope 5 fizz 6 nope 7 fizz buzz 8 nope 9 fizz 10 nope 11 fizz buzz 12 nope 13 fizz 14 nope 15 fizz buzz 16 nope 17 fizz 18 nope 19 fizz buzz 20 nope 21 fizz 22 nope 23 fizz buzz 24 nope 25 fizz 26 nope 27 fizz buzz 28 nope 29 fizz 30 nope 31 fizz buzz 32 nope 33 fizz 34 nope 35 fizz buzz 36 nope 37 fizz 38 nope 39 fizz buzz 40 nope 41 fizz 42 nope 43 fizz buzz 44 nope 45 fizz 46 nope 47 fizz buzz 48 nope 49 fizz 50 nope 51 fizz buzz 52 nope 53 fizz 54 nope 55 fizz buzz 56 nope 57 fizz 58 nope 59 fizz buzz 60 nope 61 fizz 62 nope 63 fizz buzz 64 nope 65 fizz 66 nope 67 fizz buzz 68 nope 69 fizz 70 nope 71 fizz buzz 72 nope 73 fizz 74 nope 75 fizz buzz 76 nope 77 fizz 78 nope 79 fizz buzz 80 nope 81 fizz 82 nope 83 fizz buzz 84 nope 85 fizz 86 nope 87 fizz buzz 88 nope 89 fizz 90 nope 91 fizz buzz 92 nope 93 fizz 94 nope 95 fizz buzz 96 nope 97 fizz 98 nope 99 fizz buzz 100 "},{"out":"1 fizz nope 2 3 fizz buzz nope 4 5 fizz nope 6 7 fizz buzz nope 8 9 fizz nope 10 11 fizz buzz nope 12 13 fizz nope 14 15 fizz buzz nope 16 17 fizz nope 18 19 fizz buzz nope 20 21 fizz nope 22 23 fizz buzz nope 24 25 fizz nope 26 27 fizz buzz nope 28 29 fizz nope 30 31 fizz buzz nope 32 33 fizz nope 34 35 fizz buzz nope 36 37 fizz nope 38 39 fizz buzz nope 40 41 fizz nope 42 43 fizz buzz nope 44 45 fizz nope 46 47 fizz buzz nope 48 49 fizz nope 50 51 fizz buzz nope 52 53 fizz nope 54 55 fizz buzz nope 56 57 fizz nope 58 59 fizz buzz nope 60 61 fizz nope 62 63 fizz buzz nope 64 65 fizz nope 66 67 fizz buzz nope 68 69 fizz nope 70 71 fizz buzz nope 72 73 fizz nope 74 75 fizz buzz nope 76 77 fizz nope 78 79 fizz buzz nope 80 81 fizz nope 82 83 fizz buzz nope 84 85 fizz nope 86 87 fizz buzz nope 88 89 fizz nope 90 91 fizz buzz nope 92 93 fizz nope 94 95 fizz buzz nope 96 97 fizz nope 98 99 fizz buzz nope 100 ","err":"","code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/, \" \" }; for(1..100) { undef($f), fizz() if 2 == ++$f; undef($b), buzz() if 4 == ++$b; $f && $b or nope(); &{$_}() }\n"},{"err":"","out":"fizz3buzz5fizz6fizz9buzz10fizz12fizzbuzz15fizz18buzz20fizz21fizz24buzz25fizz27fizzbuzz30fizz33buzz35fizz36fizz39buzz40fizz42fizzbuzz45fizz48buzz50fizz51fizz54buzz55fizz57fizzbuzz60fizz63buzz65fizz66fizz69buzz70fizz72fizzbuzz75fizz78buzz80fizz81fizz84buzz85fizz87fizzbuzz90fizz93buzz95fizz96fizz99buzz100","code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/ }; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b || &{$_}() }\n"},{"err":"","out":"1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 17 fizz 19 buzz fizz 22 23 fizz buzz 26 fizz 28 29 fizzbuzz 31 32 fizz 34 buzz fizz 37 38 fizz buzz 41 fizz 43 44 fizzbuzz 46 47 fizz 49 buzz fizz 52 53 fizz buzz 56 fizz 58 59 fizzbuzz 61 62 fizz 64 buzz fizz 67 68 fizz buzz 71 fizz 73 74 fizzbuzz 76 77 fizz 79 buzz fizz 82 83 fizz buzz 86 fizz 88 89 fizzbuzz 91 92 fizz 94 buzz fizz 97 98 fizz buzz ","code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/ }; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b && &{$_}(); &{\" \"}() }\n"},{"code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/ }; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b && &$_; &{\" \"} }\n","err":"","out":"1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 17 fizz 19 buzz fizz 22 23 fizz buzz 26 fizz 28 29 fizzbuzz 31 32 fizz 34 buzz fizz 37 38 fizz buzz 41 fizz 43 44 fizzbuzz 46 47 fizz 49 buzz fizz 52 53 fizz buzz 56 fizz 58 59 fizzbuzz 61 62 fizz 64 buzz fizz 67 68 fizz buzz 71 fizz 73 74 fizzbuzz 76 77 fizz 79 buzz fizz 82 83 fizz buzz 86 fizz 88 89 fizzbuzz 91 92 fizz 94 buzz fizz 97 98 fizz buzz "},{"out":"fizz 3 buzz 5 fizz 6 fizz 9 buzz 10 fizz 12 fizz buzz 15 fizz 18 buzz 20 fizz 21 fizz 24 buzz 25 fizz 27 fizz buzz 30 fizz 33 buzz 35 fizz 36 fizz 39 buzz 40 fizz 42 fizz buzz 45 fizz 48 buzz 50 fizz 51 fizz 54 buzz 55 fizz 57 fizz buzz 60 fizz 63 buzz 65 fizz 66 fizz 69 buzz 70 fizz 72 fizz buzz 75 fizz 78 buzz 80 fizz 81 fizz 84 buzz 85 fizz 87 fizz buzz 90 fizz 93 buzz 95 fizz 96 fizz 99 buzz 100 ","err":"","code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/, \" \" }; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b || &{$_}() }\n"},{"code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/, \" \" }; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b && &{$_}() }\n","out":"1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizz buzz 16 17 fizz 19 buzz fizz 22 23 fizz buzz 26 fizz 28 29 fizz buzz 31 32 fizz 34 buzz fizz 37 38 fizz buzz 41 fizz 43 44 fizz buzz 46 47 fizz 49 buzz fizz 52 53 fizz buzz 56 fizz 58 59 fizz buzz 61 62 fizz 64 buzz fizz 67 68 fizz buzz 71 fizz 73 74 fizz buzz 76 77 fizz 79 buzz fizz 82 83 fizz buzz 86 fizz 88 89 fizz buzz 91 92 fizz 94 buzz fizz 97 98 fizz buzz ","err":""},{"code":"sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/, \" \" }; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b && nope(); &{$_}() }\n","err":"","out":"nope 1 nope 2 fizz 3 nope 4 buzz 5 fizz 6 nope 7 nope 8 fizz 9 buzz 10 nope 11 fizz 12 nope 13 nope 14 fizz buzz 15 nope 16 nope 17 fizz 18 nope 19 buzz 20 fizz 21 nope 22 nope 23 fizz 24 buzz 25 nope 26 fizz 27 nope 28 nope 29 fizz buzz 30 nope 31 nope 32 fizz 33 nope 34 buzz 35 fizz 36 nope 37 nope 38 fizz 39 buzz 40 nope 41 fizz 42 nope 43 nope 44 fizz buzz 45 nope 46 nope 47 fizz 48 nope 49 buzz 50 fizz 51 nope 52 nope 53 fizz 54 buzz 55 nope 56 fizz 57 nope 58 nope 59 fizz buzz 60 nope 61 nope 62 fizz 63 nope 64 buzz 65 fizz 66 nope 67 nope 68 fizz 69 buzz 70 nope 71 fizz 72 nope 73 nope 74 fizz buzz 75 nope 76 nope 77 fizz 78 nope 79 buzz 80 fizz 81 nope 82 nope 83 fizz 84 buzz 85 nope 86 fizz 87 nope 88 nope 89 fizz buzz 90 nope 91 nope 92 fizz 93 nope 94 buzz 95 fizz 96 nope 97 nope 98 fizz 99 buzz 100 "},{"code":"sub AUTOLOAD { print \"hi\" } 'foo'->();\n","out":"hi","err":""},{"err":"","out":"ERROR: Can't use an undefined value as a subroutine reference at (eval 558) line 1, <STDIN> line 1.\n","code":"sub AUTOLOAD { print \"hi\" } ${*foo}->();\n"},{"code":"sub AUTOLOAD { print \"hi\" } foo();\n","out":"hi","err":""},{"err":"","out":"hi","code":"sub AUTOLOAD { print \"hi\" } main->foo();\n"},{"code":"sub AUTOLOAD { print \"hi\" } $x=\\*foo; (&$x)->();\n","err":"","out":"ERROR: Not a CODE reference at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"sub AUTOLOAD { print \"hi\" } $x=\\*foo; $x->();\n","err":"","out":"ERROR: Not a CODE reference at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Not a CODE reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"sub AUTOLOAD { print \"hi\" } $x=\\*foo; &$x->();\n"},{"err":"","out":"hi","code":"sub AUTOLOAD { print \"hi\" } $x = *foo; $x->();\n"},{"out":"hi","err":"","code":"sub AUTOLOAD { print \"hi\" } $x = *foo; &{$x}();\n"},{"code":"sub AUTOLOAD { print \"hi\" } $x = \\*foo; $x->();\n","err":"","out":"ERROR: Not a CODE reference at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"hi","err":"","code":"sub AUTOLOAD { print \"hi\" } $x = \\*foo; *{$x}->();\n"},{"err":"","out":"ERROR: Not a CODE reference at (eval 558) line 1, <STDIN> line 1.\n","code":"sub AUTOLOAD { print \"hi\" } $x = \\*foo; &{$x}();\n"},{"code":"sub AUTOLOAD { print \"hi\" } $x = \\*foo; &{*$x}();\n","out":"hi","err":""},{"out":"ERROR: Can't use an undefined value as a subroutine reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"sub AUTOLOAD { print \"hi\" } $x = *foo; *$x{CODE}->();\n"},{"err":"","out":"ERROR: Can't use an undefined value as a subroutine reference at (eval 558) line 1, <STDIN> line 1.\n","code":"sub AUTOLOAD { print \"hi\" } $x = \\*foo; *$x{CODE}->();\n"},{"out":"[\"\",1]","err":"","code":"sub blah { !!@_ } [ blah, blah(1) ]\n"},{"code":"sub bubsort { my $arr = shift; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i] } }\n","out":"","err":""},{"err":"","out":"[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]","code":"sub bubsort { my $arr = shift; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i] }; $arr }; bubsort [ sort { rand(1) < .5 } 1..20 ]\n"},{"code":"sub bubsort { my $arr = shift; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i] }; $arr }; bubsort [ sort { rand < .5 } 1..20 ]\n","err":"","out":"ERROR: Unterminated <> operator at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"sub bubsort { my $arr = shift; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i] }; $arr }; [ sort { rand(1) < .5 } 1..20 ]\n","out":"[6,2,1,4,3,5,9,8,10,7,20,16,12,11,14,13,15,19,18,17]","err":""},{"out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, near \"1 if\"\n","err":"","code":"sub Buffalo(;@) {return 1 if ($_[0] eq 'buffalo')}; sub buffalo {\"buffalo\"}; \n"},{"code":"sub Buffalo(;@) {return 1 if $_[0] eq 'buffalo'}; sub buffalo {\"buffalo\"}; \n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, near \"1 if\"\n","err":""},{"code":"sub Buffalo(;@) {return 1;}; sub buffalo {\"buffalo\"}; \n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, at EOF\n","err":""},{"code":"sub Buffalo(@) {return 1;}; sub buffalo {\"buffalo\"}; \n","err":"","out":""},{"out":"ERROR: Can't modify constant item in chomp at (eval 558) line 1, near \"\"x\\n\" ]\"\n","err":"","code":"sub chomp { 42 }; [chomp \"x\\n\" ]\n"},{"code":"sub chomp { \"blah\" }; [ chomp ]\n","out":"[0]","err":""},{"out":"ok[1]\n","err":"","code":"sub code; for \\&code (sub { print 'ok' }) { say '[', code, ']' }\n"},{"code":"sub *CORE::die { say \"42\"; } die  \n","err":"","out":"ERROR: Illegal declaration of anonymous subroutine at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: Died at (eval 558) line 1, <STDIN> line 1.\n","code":"sub CORE::die { say \"42\"; } die  \n"},{"out":"ERROR: Died at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"sub die { say \"42\"; } die  \n"},{"err":"","out":"ERROR: Can't modify constant item in scalar assignment at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, near \"} say\"\n","code":"sub { 'FILE' = 42; } say $FILE;\n"},{"code":"sub foo { [1..3], [a..c] }; my $x = foo;\n","err":"","out":"[\"a\",\"b\",\"c\"]"},{"code":"sub foo {} \"->${ \\\\&foo }\"\n","out":"->CODE(0x5dcf788)","err":""},{"code":"sub foo { \"foo [@_]\" }; my @bar = ((bless []), 43); shift(@bar)->foo(@bar);\n","out":"foo [main=ARRAY(0x66c61a0) 43]","err":""},{"err":"","out":"","code":"sub foo {\" Hello\"}; undef &foo;\n"},{"code":"sub foo {\" Hello\"}; undef &foo; foo()\n","err":"","out":"ERROR: Undefined subroutine &main::foo called at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Undefined subroutine &main::foo called at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"sub foo :lvalue { print \"FOO!\" }  undef &foo; foo()\n"},{"code":"sub foo { my $x = 1; use constant FOO => \\$x; 2 }; [ foo, FOO ];\n","err":"","out":"[2,\\1]"},{"out":"[1,\\1]","err":"","code":"sub foo { my $x = 1; use constant FOO => \\$x }; [ foo, FOO ];\n"},{"code":"sub foo { my @xs = \"a\" .. \"c\"; return (\"X\", \"Y\", @xs); }  my $x = foo; $x\n","out":"3","err":""},{"code":"sub foo { my $x = shift; use constant FOO => \\$x; 42 }; [ foo(1) ];\n","err":"","out":"[42]"},{"out":"[42,1]","err":"","code":"sub foo { my $x = shift; use constant FOO => \\$x; 42 }; [ foo(1), ${ FOO() } ];\n"},{"code":"sub foo { my $x = shift; use constant FOO => \\$x; 42 }; [ foo(1), ${ FOO() }, foo(2) ];\n","err":"","out":"[42,1,42]"},{"code":"sub foo { my $x = shift; use constant FOO => \\$x; 42 }; my @a = foo(1), @{FOO()}; my @b = foo(2), @{FOO()}; [ @a, @b ];\n","err":"","out":"ERROR: Not an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"[42,42]","err":"","code":"sub foo { my $x = shift; use constant FOO => \\$x; 42 }; my @a = foo(1), ${FOO()}; my @b = foo(2), ${FOO()}; [ @a, @b ];\n"},{"out":"[1,1]","err":"","code":"sub foo { my $x = shift; use constant FOO => \\$x; () }; [ foo(1), ${ FOO() }, foo(2), ${ FOO() } ];\n"},{"out":"[1,1]","err":"","code":"sub foo { my $x = shift; use constant FOO => \\$x; ${ &{'FOO'}() } }; [ foo(1), foo(2) ];\n"},{"code":"sub foo { my $x = shift; use constant FOO => \\$x; &{'FOO'}() }; [ foo(1), foo(2) ];\n","out":"[\\1,$VAR1->[0]]","err":""},{"code":"sub foo { my @z = (1, 2, 3); my @y = qw<a b c>; return \\@z, \\@y; } my $x = foo(); $x\n","err":"","out":"[\"a\",\"b\",\"c\"]"},{"code":"sub foo { print \"FOO!\" }  foo()\n","out":"FOO!","err":""},{"err":"","out":"ERROR: Undefined subroutine &main::foo called at (eval 558) line 1, <STDIN> line 1.\n","code":"sub foo { print \"FOO!\" }  undef &foo; foo()\n"},{"out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(\\\"\n","err":"","code":"sub foo (\\@) { say @_ };\n"},{"err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(\\\"\n","code":"sub foo (\\@\\@;\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@) { say @_ };\n"},{"err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(\\\"\n","code":"sub foo (\\@) { say @_ }; foo +(split //, \"foobar\")\n"},{"code":"sub foo (;$) { say \"[@_]\"; }; my %h = ( bar => foo(42), meow => 'moo' ); \\%h\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, at EOF\n","err":""},{"code":"sub foo { say \"[@_]\"; }; my %h = ( bar => foo(42), meow => 'moo' ); \\%h\n","err":"","out":"[42]\n"},{"code":"sub foo(;$) { say \"[@_]\"; }; my %h = ( bar => foo 42, meow => 'moo' ); \\%h\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, near \"foo 42\"\n","err":""},{"err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, at EOF\nsyntax error at (eval 558) line 1, at EOF\n","code":"sub foo(;$) { say \"[@_]\"; }; my %h = ( bar => foo(42), meow => 'moo' ); \\%h\n"},{"code":"sub foo($) { say \"[@_]\"; }; my %h = ( bar => foo(42), meow => 'moo' ); \\%h\n","err":"","out":"[42]\n"},{"code":"sub foo { shift }; @_ = 'a'..'d'; &foo; [ @_ ]\n","err":"","out":"[\"b\",\"c\",\"d\"]"},{"err":"","out":"{foo => \"bar\"}","code":"sub foo {shift} { foo => 'bar' }->${ \\\\&foo }\n"},{"code":"sub foo { wantarray ? 'foos' : 'bars' }  [ () = foo ]\n","err":"","out":"[]"},{"code":"sub j { !( $_[0] && $_[1] ) }  sub p { !($_[0] || $_[1]) } [ map [j($_->[0], $_->[1]), p($_->[0], $_->[1])], [0, 0], [1, 0], [1, 1], [0, 1] ]\n","out":"[[1,1],[1,\"\"],[\"\",\"\"],[1,\"\"]]","err":""},{"code":"sub List::Util::0sum {\"Hello World\"};\n","out":"","err":""},{"code":"sub List::Util::0sum {\"Hello World\"}; List::Util::0sum()\n","out":"Hello World","err":""},{"code":"sub List::Util::0sum {my ($a, $b)=(0,0); $a+=$_, $b-=$_ for @_; ($a, $b)}; [List::Util::0sum(1,2,3,4,5)]\n","err":"","out":"[15,-15]"},{"code":"sub o { (!$_[0]) && (!$_[1]) } sub j { !( $_[0] && $_[1] ) }  sub p { !($_[0] || $_[1]) } [ map [j($_->[0], $_->[1]), j($_->[0], $_->[1]), p($_->[0], $_->[1])], [0, 0], [1, 0], [1, 1], [0, 1] ]\n","out":"[[1,1,1],[1,1,\"\"],[\"\",\"\",\"\"],[1,1,\"\"]]","err":""},{"code":"sub o { ((!$_[0]) && (!$_[1])) } sub j { !( ($_[0] && $_[1]) ) }  sub p { !($_[0] || $_[1]) } [ map [j($_->[0], $_->[1]), j($_->[0], $_->[1]), p($_->[0], $_->[1])], [0, 0], [1, 0], [1, 1], [0, 1] ]\n","err":"","out":"[[1,1,1],[1,1,\"\"],[\"\",\"\",\"\"],[1,1,\"\"]]"},{"code":"sub _ { print /::(.*)/ }; *AUTOLOAD = *_; for(1..100) { $f=0, fizz() if 3 == ++$f; $b=0, buzz() if 5 == ++$b; $f && $b && &$_; &{\" \"} }\n","err":"","out":"1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 17 fizz 19 buzz fizz 22 23 fizz buzz 26 fizz 28 29 fizzbuzz 31 32 fizz 34 buzz fizz 37 38 fizz buzz 41 fizz 43 44 fizzbuzz 46 47 fizz 49 buzz fizz 52 53 fizz buzz 56 fizz 58 59 fizzbuzz 61 62 fizz 64 buzz fizz 67 68 fizz buzz 71 fizz 73 74 fizzbuzz 76 77 fizz 79 buzz fizz 82 83 fizz buzz 86 fizz 88 89 fizzbuzz 91 92 fizz 94 buzz fizz 97 98 fizz buzz "},{"code":"sub _ { print /::(.*)/ }; *_ = *AUTOLOAD; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b && &$_; &{\" \"} }\n","out":"ERROR: Undefined subroutine &main::1 called at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"sub _ { print /::(.*)/ }; *AUTOLOAD = *_; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b && &$_; &{\" \"} }\n","err":"","out":"1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 17 fizz 19 buzz fizz 22 23 fizz buzz 26 fizz 28 29 fizzbuzz 31 32 fizz 34 buzz fizz 37 38 fizz buzz 41 fizz 43 44 fizzbuzz 46 47 fizz 49 buzz fizz 52 53 fizz buzz 56 fizz 58 59 fizzbuzz 61 62 fizz 64 buzz fizz 67 68 fizz buzz 71 fizz 73 74 fizzbuzz 76 77 fizz 79 buzz fizz 82 83 fizz buzz 86 fizz 88 89 fizzbuzz 91 92 fizz 94 buzz fizz 97 98 fizz buzz "},{"code":"sub _ { print /::(.*)/ }; *AUTOLOAD = *_; for(1..50) { $f=0, fizz() if 3 == ++$f; $b=0, buzz() if 5 == ++$b; $f && $b && &$_; &{\" \"} }\n","err":"","out":"1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 17 fizz 19 buzz fizz 22 23 fizz buzz 26 fizz 28 29 fizzbuzz 31 32 fizz 34 buzz fizz 37 38 fizz buzz 41 fizz 43 44 fizzbuzz 46 47 fizz 49 buzz "},{"out":"Just another Perl hacker, ","err":"","code":"sub _ { print /::(.*)/, ' ' }; *AUTOLOAD = *_; Just(), another(), Perl(), &{\"hacker,\"};\n"},{"out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$ & )\"\nsyntax error at (eval 558) line 1, near \"proc 'foo'\"\n","err":"","code":"sub proc ( $ & ) {}; [ proc 'foo', {; } ]\n"},{"code":"sub proc ( $ & ) {}; [ proc 'foo', {;} ]\n","err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$ & )\"\nsyntax error at (eval 558) line 1, near \"proc 'foo'\"\n"},{"out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$ & )\"\nsyntax error at (eval 558) line 1, near \"proc 'foo'\"\n","err":"","code":"sub proc ( $ & ) {}; [ proc 'foo', {} ]\n"},{"out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$ & )\"\nsyntax error at (eval 558) line 1, near \"proc 'foo'\"\n","err":"","code":"sub proc ( $ & ) {}; [ proc 'foo', +{} ]\n"},{"code":"sub proc ( $ & ) {}; [ proc 'foo', { 42} ]\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$ & )\"\nsyntax error at (eval 558) line 1, near \"proc 'foo'\"\n","err":""},{"out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$ & )\"\nsyntax error at (eval 558) line 1, near \"proc 'foo'\"\nsyntax error at (eval 558) line 1, near \"42}\"\n","err":"","code":"sub proc ( $ & ) {}; [ proc 'foo', {; 42} ]\n"},{"code":"sub proc ( $ & ) {}; [ proc 'foo', { 42; 45; } ]\n","err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"$ & )\"\nsyntax error at (eval 558) line 1, near \"proc 'foo'\"\nsyntax error at (eval 558) line 1, near \"; }\"\n"},{"code":"sub ps(&@) { my $c = shift; my $p = ''; while(1) { my $i = 0; 1 until ++vec $p, $i++, 8; return if vec $p, @_, 1; $c->(@_[grep vec $p, $_, 1], 0..$#_]) } }\n","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(&@\"\nsyntax error at (eval 558) line 1, near \"$#_]\"\nUnmatched right curly bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, near \"} }\"\n","err":""},{"code":"sub ps(&@) { my $c = shift; my $p = ''; while(1) { my $i = 0; 1 until ++vec $p, $i++, 8; return if vec $p, @_, 1; $c->(@_[grep vec($p, $_, 1), 0..$#_]) } }; my @a;ps { push @a, \"@_\" } 'a'..'c'; \\@a\n","err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(&@\"\nsyntax error at (eval 558) line 1, near \"} }\"\n"},{"err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(&@\"\nsyntax error at (eval 558) line 1, near \"} }\"\n","code":"sub ps(&@) { my $c = shift; my $p = ''; while(1) { my $i = 0; 1 until ++vec $p, $i++, 8; return if vec $p, @_, 1; $c->(@_[grep vec($p, $_, 1), 0..$#_]) } }; my @a;ps { push @a, \"@_\" } 'a'..'d'; \\@a\n"},{"err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(&@\"\nsyntax error at (eval 558) line 1, near \"$#_]\"\nUnmatched right curly bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, near \"} }\"\n","code":"sub ps(&@) { my $c = shift; my $p = ''; while(1) { my $i = 0; 1 until ++vec $p, $i++, 8; return if vec $p, @_, 1; $c->(@_[grep vec $p, $_, 1], 0..$#_]) } }; my @a;ps { push @a, \\@_ } 'a'..'e'; \\@a\n"},{"out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(&@\"\nsyntax error at (eval 558) line 1, near \"} }\"\n","err":"","code":"sub ps(&@) { my $c = shift; my $p = ''; while(1) { my $i = 0; 1 until ++vec $p, $i++, 8; return if vec $p, @_, 1; $c->(@_[grep vec($p, $_, 1), 0..$#_]) } }; my @a;ps { push @a, \"@_\" } 'a'..'e'; \\@a\n"},{"err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(&@\"\nsyntax error at (eval 558) line 1, near \"} }\"\n","code":"sub ps(&@) { my $c = shift; my $p = ''; while(1) { my $i = 0; 1 until ++vec $p, $i++, 8; return if vec $p, @_, 1; $c->(@_[grep vec($p, $_, 1), 0..$#_]) } }; my @a;ps { push @a, \\@_ } 'a'..'e'; \\@a\n"},{"out":"ERROR: Illegal declaration of anonymous subroutine at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"sub { @_ = qw/foo bar baz/; } my @z = 1..10; sub @z; \\@z\n"},{"out":"fo","err":"","code":"substr 'foo', 0, -1\n"},{"err":"","out":"o","code":"substr 'foo', -1\n"},{"code":"sub TIEHANDLE { [] }; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ scalar <FH> ];\n","out":"[undef]","err":""},{"out":"[undef]","err":"","code":"sub TIEHANDLE { [] }; sub READLINE { \"asdf\" }; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ scalar <FH> ];\n"},{"out":"[undef]","err":"","code":"sub TIEHANDLE { [] }; sub READLINE { \"asdf\" }; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ scalar readline FH ];\n"},{"err":"","out":"[undef]","code":"sub TIEHANDLE { [] }; sub READLINE; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ scalar <FH> ];\n"},{"err":"","out":"[undef]","code":"sub TIEHANDLE { [] }; tie *FH, 'main'; [ print FH \"foo\" ];\n"},{"code":"sub TIEHANDLE { [] }; tie *FH, 'main'; print FH \"foo\";\n","out":"","err":""},{"err":"","out":"[undef]","code":"sub TIEHANDLE { [] }; tie *FH, 'main'; [ scalar <FH> ];\n"},{"code":"sub TIEHASH { bless [] }; sub FETCH { __FILE__ }; BEGIN { tie %INC, 'main' }; sub UNIVERSAL::import { print \"import @_\" }; use How::Strange;\n","err":"","out":"import How::Strange"},{"code":"sub TIEHASH { bless [] }; sub FETCH { __FILE__ }; BEGIN { tie %INC, 'main' }; sub UNIVERSAL::import { print \"@_\" }; use How::Strange;\n","err":"","out":"How::Strange"},{"code":"sub TIEHASH { bless [] }; sub FETCH { __FILE__ }; BEGIN { tie %INC, 'main' }; use How::Strange;\n","err":"","out":""},{"code":"sub TIEHASH { bless [] }; sub FETCH { __FILE__ }; [ (tie %INC, 'main'), require WhatDoesThisDo ]\n","err":"","out":"[bless( [], 'main' ),1]"},{"code":"sub UNIVERSAL::maybe {$class=shift; rand() > 0.5 ? $class->new() : undef}; package bar { sub new {\"Hello World\"};}; bar->maybe()\n","err":"","out":"Hello World"},{"out":"ERROR: Can't locate object method \"new\" via package \"main\" at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"sub UNIVERSAL::maybe {rand() > 0.5 ? __PACKAGE__->new() : undef}; package bar { sub new {\"Hello World\"};}; bar->maybe()\n"},{"code":"sub use constant foo::bar => 42; foo::bar\n","err":"","out":"ERROR: Illegal declaration of subroutine main::use at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"[0,0]","err":"","code":"sub x { my $params ||= '0' || '0'; $params } [ x(42), x(43) ]\n"},{"code":"sub x { my $params ||= '0' || 'b'; $params } [ x(42), x(43) ]\n","out":"[\"b\",\"b\"]","err":""},{"out":"[undef,undef]","err":"","code":"sub x { my $params ||= '0' || undef; $params } [ x(42), x(43) ]\n"},{"code":"sub x { my $params ||= 'a' || 'b'; $params } [ x(42), x(43) ]\n","out":"[\"a\",\"a\"]","err":""},{"out":"[42,43]","err":"","code":"sub x { my $params ||= shift; $params } [ x(42), x(43) ]\n"},{"code":"sub x { @_ = qw/foo bar baz/; } my @z = 1..10; x @z; \\@z\n","out":"[1,2,3,4,5,6,7,8,9,10]","err":""},{"err":"","out":"","code":"sub z { }  z('â´')\n"},{"code":"sub z { }  z(â´)\n","err":"","out":"ERROR: Unrecognized character \\xE2; marked by <-- HERE after  z { }  z(<-- HERE near column 104 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"sub Ï { atan2(1,1) * 4; } say Ï\n","out":"ERROR: Illegal declaration of anonymous subroutine at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"1","err":"","code":"'\t' =~ /\\t/\n"},{"out":"test","err":"","code":"\"test\"\n"},{"err":"","out":"3","code":"\"test123Wow\" =~ /^.*(\\d+).*$/g; $1\n"},{"err":"","out":"[1]","code":"*{'$::test'} = sub { 1 }; [ '$'->test ]\n"},{"err":"","out":"the real life","code":"(\"the real life\", \"just fantasy\")[\"is this\"]\n"},{"code":" 'trg uggc|||vtabenagqrfvtare.pbz|wncu.ugzy' =~ yâ»n-za-m|â»a-z:/â»r \n","err":"","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after |ÃÂ¢ÃÂÃÂ»a-z:/ÃÂ¢<-- HERE near column 158 at (eval 558) line 1, <STDIN> line 1.\n"},{"code":" 'trg uggc.||vtabenagqrfvtare.pbz|wncu.ugzy' =~ yâ»n-za-m.|â»a-z:/â»r \n","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after |ÃÂ¢ÃÂÃÂ»a-z:/ÃÂ¢<-- HERE near column 159 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"'trg uggcX||vtabenagqrfvtare.pbz|wncu.ugzy //obql' =~ yâ»n-za-mX|â»a-z:/â»r\n","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after |ÃÂ¢ÃÂÃÂ»a-z:/ÃÂ¢<-- HERE near column 166 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"try {foo}\n","out":"ERROR: Can't locate object method \"try\" via package \"foo\" (perhaps you forgot to load \"foo\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"try {print \"hw\"\n","err":"","out":"ERROR: Missing right curly or square bracket at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, at EOF\n"},{"out":"hwERROR: Can't locate object method \"try\" via package \"1\" (perhaps you forgot to load \"1\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"try {print \"hw\"}\n"},{"code":"try {print \"hw\"} catch {die \"foo\"}\n","err":"","out":"hwERROR: foo at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"","err":"","code":"($two4s, $delta, $secs)\n"},{"code":" 'uggc|||vtabenagqrfvtare.pbz|wncu.ugzy' =~ yâ»n-za-m.|â»a-z:/â»r \n","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after |ÃÂ¢ÃÂÃÂ»a-z:/ÃÂ¢<-- HERE near column 155 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":" 'uggc.||vtabenagqrfvtare.pbz|wncu.ugzy' =~ yâ»n-za-m.|â»a-z:/â»r \n","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after |ÃÂ¢ÃÂÃÂ»a-z:/ÃÂ¢<-- HERE near column 155 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after |ÃÂ¢ÃÂÃÂ»a-z:/ÃÂ¢<-- HERE near column 155 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":" 'uggcX||vtabenagqrfvtare.pbz|wncu.ugzy' =~ yâ»n-za-mX|â»a-z:/â»r \n"},{"err":"","out":"ERROR: Unterminated <> operator at (eval 558) line 1, <STDIN> line 1.\n","code":"undef < 0\n"},{"code":"[\\undef, \\undef]\n","out":"[\\undef,$VAR1->[0]]","err":""},{"err":"","out":"ok","code":"UNITCHECK { print 'ok' }; 42;\n"},{"code":"[UNIVERSAL->can('import')]\n","err":"","out":"[undef]"},{"code":"unless( $a or $b ){}\n","err":"","out":""},{"code":"unless( a or b ){}\n","out":"a","err":""},{"out":"[\"abc\",\"def\",\"ghi\"]","err":"","code":"[ unpack '(A3)*', 'abcdefghi' ]\n"},{"err":"","out":"[\"Hello World\"]","code":"[unpack \"a*\", \"Hello World\"]\n"},{"err":"","out":"0101100110011001100110011001100110011001100110011001110111111100","code":"unpack \"b*\",(pack \"d\", 0.1)\n"},{"err":"","out":"[97,98,99]","code":"[ unpack 'C3', 'abcdefghi' ]\n"},{"code":"[unpack \"c*\", \"Hello World\"]\n","out":"[72,101,108,108,111,32,87,111,114,108,100]","err":""},{"code":"[unpack \"c*\", \"Hello Worldâ \"]\n","err":"","out":"[72,101,108,108,111,32,87,111,114,108,100,-30,-104,-125,32]"},{"err":"","out":"[72,101,108,108,111,32,87,111,114,108,100,226,152,131,32]","code":"[unpack \"C*\", \"Hello Worldâ \"]\n"},{"code":"unpack \"d\", \"0.1\"\n","err":"","out":""},{"err":"","out":"","code":"unpack \"d\", 0.1\n"},{"err":"","out":"ERROR: Invalid type 'D' in unpack at (eval 558) line 1, <STDIN> line 1.\n","code":"unpack \"D\", \"0.1\"\n"},{"code":"unpack(\"H*\", (4095 & 0xFF00) >> 8);\n","err":"","out":"3135"},{"err":"","out":"ff","code":"unpack(\"H*\", chr 4095);\n"},{"code":"unpack(\"H*\", pack(\"C*\", 0xFA, 15, 255))\n","out":"fa0fff","err":""},{"out":"fa0cff","err":"","code":"unpack(\"H*\", pack(\"C*\", 0xFA, (3192 & 0x0F00) >> 8, 255))\n"},{"err":"","out":"a999999999999bf3","code":"unpack \"h*\", pack \"d\", 0.1\n"},{"code":"unpack \"h*\",(pack \"d\", 0.1)\n","out":"a999999999999bf3","err":""},{"out":"ERROR: Can't locate URI/_generic.pm:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/URI.pm line 104, <STDIN> line 1.\n","err":"","code":"URI->new('/product/IDHEREFUCKER');\n"},{"out":"ERROR: Perl v10.0.0 required--this is only v5.22.1, stopped at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use 10;\n"},{"code":"use 5.008; You know what I like about perl? It's the fact that this English sentence is perfectly parsable!\n","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","err":""},{"code":"use 5.008; You know what I like about perl? It's the fact that this English sentence is perfectly parsable! Some may say: \"no way\", but I got deparse to prove it\n","err":"","out":"ERROR: Can't locate object method \"Some\" via package \"may\" (perhaps you forgot to load \"may\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"567856785678","code":"use 5.010; for( 1..3 ) { my $x = sub { state $x = 5; print $x++ }; $x->() for 1..4 }\n"},{"out":"555","err":"","code":"use 5.010; for( 1..3 ) { sub { state $x = 5; print $x++ }->() }\n"},{"out":"[1,2,3]","err":"","code":"use 5.010; my $x; sub foo { ++$foo }; [ foo, foo, foo ]\n"},{"err":"","out":"[3,3,3]","code":"use 5.010; my $x; sub foo :lvalue { ++$foo }; [ foo, foo, foo ]\n"},{"err":"","out":"[3,3,3]","code":"use 5.010; my $x; [ ++$x,++$x,++$x ]\n"},{"out":"\n","err":"","code":"use 5.010; say `ls -a`;\n"},{"out":"Just another Sort hacker,\n","err":"","code":"use 5.010; say sort { $|-- or -1 } 'ruJt tc,en hoetokarrasS h' =~ /./g\n"},{"out":"[\"zof!\",\"zof!\",\"zof!\",\"zof!\",\"zof!\",\"zof!\",\"zof!\",\"zof!\",\"zof!\",\"zof!\",\"zof!\"]","err":"","code":"use 5.010; sub foo :lvalue { state $foo = shift; @_ and $foo = shift;$foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo(\"zof!\"), foo, foo]\n"},{"code":"use 5.010; sub foo { state $foo = do { print \"TEST\" }; @_ and $foo = shift; $foo }; [ foo, foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo(\"zof!\"), foo, foo]\n","err":"","out":"TEST"},{"code":"use 5.010; sub foo { ++state $foo }; [ foo, foo, foo ]\n","err":"","out":"[1,2,3]"},{"out":"[41,42,42]","err":"","code":"use 5.010; sub foo { state $foo = shift; @_ and $foo = 42;$foo }; [ foo(41), , foo(1), foo]\n"},{"out":"[41,41,41]","err":"","code":"use 5.010; sub foo { state $foo = shift; @_ and $foo = 42;$foo }; [ foo(41), foo, foo]\n"},{"out":"[41,41,42,42]","err":"","code":"use 5.010; sub foo { state $foo = shift; @_ and $foo = 42;$foo }; [ foo(41), foo , foo(1), foo]\n"},{"code":"use 5.010; sub foo { state $foo = shift; @_ and $foo = 42;$foo }; [ foo, foo, foo]\n","out":"[undef,undef,undef]","err":""},{"code":"use 5.010; sub foo { state $foo = shift; @_ and $foo = shift;$foo }; [ foo(41), foo , foo(1), foo]\n","err":"","out":"[41,41,1,1]"},{"err":"","out":"[41,41,1,1,1,1,75,75,\"zof!\",\"zof!\",\"zof!\"]","code":"use 5.010; sub foo { state $foo = shift; @_ and $foo = shift;$foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo(\"zof!\"), foo, foo]\n"},{"code":"use 5.010; sub foo { state $foo = shift; $foo = shift;$foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo(\"zof!\"), foo, foo]\n","err":"","out":"[undef,undef,1,undef,undef,undef,75,undef,\"zof!\",undef,undef]"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"->@* \"\n","err":"","code":"use 5.020; for ( [qw/foo bar/]->@* ) { print}\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"->*\"\n","code":"use 5.020; for ( [qw/foo bar/]->*@ ) { print}\n"},{"code":"use 5.020; my $x = \\42; $x->$*\n","out":"ERROR: Can't call method \"\" on unblessed reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Malformed prototype for main::add: $x = return 0, $y = return $x at (eval 558) line 1, <STDIN> line 1.\n","code":"use 5.020; sub add ($x = return 0, $y = return $x) { return $x + $y }   [ add(), add(2), add(2,3)  ]\n"},{"code":"use 5.020; sub add ( $x = return 0, $y = return $x ) { return $x + $y }   [ add(), add(2), add(2,3), add(2,3,4) ]\n","out":"ERROR: Malformed prototype for main::add:  $x = return 0, $y = return $x  at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Malformed prototype for main::add: $x = return 0, $y = return $x at (eval 558) line 1, <STDIN> line 1.\n","code":"use 5.020; sub add ($x = return 0, $y = return $x) { return $x + $y }   [ add(), add(2), add(2,3), add(2,3,4) ]\n"},{"code":"use 5.020; use feature 'postderef'; no warnings 'experimental::postderef'; for ( [qw/foo bar/]->@* ) { print}\n","out":"foobar","err":""},{"code":"use 5.08; You know what I like about perl? It's the fact that this English sentence is perfectly parsable! Some may say: \"no way\", but I got deparse to prove it\n","out":"ERROR: Perl v5.80.0 required--this is only v5.22.1, stopped at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Perl v5.200.0 required (did you mean v5.20.0?)--this is only v5.22.1, stopped at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use 5.20; my $x = \\42; $x->$*\n"},{"out":"ERROR: Perl v6.0.0 required--this is only v5.22.1, stopped at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use 6;\n"},{"code":"use 999;\n","out":"ERROR: Perl v999.0.0 required--this is only v5.22.1, stopped at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"","code":"use Carp;\n"},{"code":"use Carp 9;\n","err":"","out":"ERROR: Carp version 9 required--this is only version 1.36 at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use Carp::croak(\"loaded\")\n","out":"ERROR: Can't locate Carp/croak.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use charnames (); [ charnames::viacode 0x92 ]\n","err":"","out":"[\"PRIVATE USE TWO\"]"},{"out":"[\\[\"one\",\"two\",\"three\"]]","err":"","code":"use constant ARRAY => [qw(one two three)]; [ $::{ARRAY} ]\n"},{"code":"use constant ARRAY => [qw(one two three)]; $::{ARRAY}\n","out":"\\[\"one\",\"two\",\"three\"]","err":""},{"code":"use constant ARRAY => [qw(one two three)]; ${$::{ARRAY}}\n","err":"","out":"[\"one\",\"two\",\"three\"]"},{"code":"use constant foo::bar => 42; foo::bar\n","out":"42","err":""},{"code":"use constant FOO => 'BAR!'; BEGIN { say FOO }\n","out":"BAR!\n","err":""},{"code":"use constant FOO => 'BAR!'; BEGIN say { FOO }\n","err":"","out":"ERROR: Illegal declaration of subroutine BEGIN at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"BAR!\nBAR!\n","code":"use constant FOO => 'BAR!'; our $dir = FOO; BEGIN { say FOO } say $dir\n"},{"code":"use constant FOO => 'BAR!'; our $dir = FOO; BEGIN { say FOO } say \"Moar $dir!\"\n","out":"BAR!\nMoar BAR!!\n","err":""},{"code":"use constant foo => bar; package bar; sub baz { 'quux' }; package main; [ baz { foo } ];\n","err":"","out":"[\"quux\"]"},{"code":"use constant foo => bar; package bar; sub baz { 'quux' }; package main; [ baz { foo() } ];\n","out":"[\"quux\"]","err":""},{"code":"use constant foo => bar; package bar; sub baz { 'quux' }; package main; [ baz foo ];\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"baz foo \"\n"},{"out":"ERROR: Too many arguments for subroutine at (eval 558) line 1.\n","err":"","code":"use constant foo => bar; package bar; sub baz() { 'quux' }; package main; [ baz { foo } ];\n"},{"code":"use constant foo => bar; package bar; sub baz() { 'quux' }; package main; [ baz { foo() } ];\n","out":"ERROR: Too many arguments for subroutine at (eval 558) line 1.\n","err":""},{"code":"use constant foo => bar; package bar; sub baz() { 'quux' }; package main; [ baz foo ];\n","err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"baz foo \"\n"},{"err":"","out":"","code":"use constant foo => 'ok'; *main::{foo};\n"},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"list[\"\n","code":"use constant list => qw(a b c); [list[2]]\n"},{"out":"ERROR: Can't use an array as a reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use constant list => qw(a b c); list->[2]\n"},{"err":"","out":"2\n","code":"use constant one => 1; BEGIN { &Internals::SvREADONLY(\\one, 0); ++${ \\one } }; say one;\n"},{"code":"use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); for my \\%hash (@a) {print Dumper(%hash);}\n","out":"ERROR: Missing $ on loop variable at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Can't locate Devel/Peek.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use Devel::Peek qw,SvREFCNT,;\n"},{"err":"","out":"","code":"use Encode;\n"},{"code":"use Encode; [Encode->encodings()];\n","err":"","out":"[\"ascii\",\"ascii-ctrl\",\"iso-8859-1\",\"null\",\"utf-8-strict\",\"utf8\"]"},{"err":"","out":"ERROR: Unrecognized character \\x98; marked by <-- HERE after ÃÂÃÂ¢ n-za-mÃÂ¢<-- HERE near column 194 at (eval 558) line 1, <STDIN> line 1.\n","code":"use Encode; print encode 'utf8', 'get http://ignorantdesigner.com/japh.html' =~ y â¢ a-z:/ â¢ n-za-mâ â¢r \n"},{"code":"use experimental 'postderef'; my $x; $x->$@\n","err":"","out":"ERROR: Can't call method \"\" on an undefined value at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use experimental 'postderef'; my $x;  @{ $x || [] }; $x->@*\n","out":"","err":""},{"code":"use experimental 'postderef'; my $x;  @{ $x || [] }; $x->$@\n","out":"ERROR: Can't call method \"\" on an undefined value at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Can't call method \"\" on an undefined value at (eval 558) line 1, <STDIN> line 1.\n","code":"use experimental 'postderef'; my @z = 1..10; $z->$#\n"},{"code":"use experimental 'postderef'; my $z =[ 1..10]; $z->$*#\n","out":"ERROR: Not a SCALAR reference at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Can't call method \"\" on unblessed reference at (eval 558) line 1, <STDIN> line 1.\n","code":"use experimental 'postderef'; my $z =[ 1..10]; $z->$#\n"},{"code":"use experimental 'postderef'; my $z =[ 1..10]; $z->$#*\n","out":"9","err":""},{"err":"","out":"ERROR: Can't call method \"\" on an undefined value at (eval 558) line 1, <STDIN> line 1.\n","code":"use experimental 'postderef'; undef->$@\n"},{"code":"use feature ':all'; sub add (@) { __CODE__->(1,2) }   [ add(), add(2), add(2,3)  ]\n","out":"ERROR: Undefined subroutine &main::__CODE__ called at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use feature ':all'; sub add (__CODE__->(2,2)) { }   [ add(), add(2), add(2,3)  ]\n","err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(__CODE__\"\n"},{"out":"","err":"","code":"use feature ':all'; sub add (@) { __SUB__->(1,2) }   [ add(), add(2), add(2,3)  ]\n"},{"err":"","out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(__SUB__\"\n","code":"use feature ':all'; sub add (__SUB__->(2,2)) { }   [ add(), add(2), add(2,3)  ]\n"},{"code":"use feature ':all'; sub add ($x = return 0, $y = return $x) { return $x + $y }   [ add(), add(2), add(2,3)  ]\n","out":"ERROR: Too many arguments for subroutine at (eval 558) line 1.\n","err":""},{"err":"","out":"\\undef","code":"use feature 'postderef'; \\(42)->$*\n"},{"err":"","out":"\\undef","code":"use feature 'postderef'; \\42->$*\n"},{"err":"","out":"","code":"use feature 'postderef'; for my $i (1..10) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]\n"},{"code":"use feature 'postderef'; for my $i (1..10) {push @a, [(1) x (1024*1024)]}; sleep 15; [scalar(@a), scalar($a[0]->@*)]\n","err":"","out":""},{"code":"use feature 'postderef'; for my $i (1..15) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]\n","err":"","out":""},{"err":"","out":"","code":"use feature 'postderef'; for my $i (1..30) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]\n"},{"err":"","out":"[5,1048576]","code":"use feature 'postderef'; for my $i (1..5) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"$ ;[\"\n","err":"","code":"use feature 'postderef'; my $a; ++$a->$ ;[ $a ]\n"},{"err":"","out":"x","code":"use feature 'postderef'; my $aref = \\['x']; $$aref->[0]\n"},{"code":"use feature q,postderef,; my $x = 42; my $y = \\$x; [ \\$x, \\$y->$* ]\n","err":"","out":"[\\42,$VAR1->[0]]"},{"code":"use feature q,postderef,; my $x = 42; my $y = \\$x; [ \\$x, \\++$y->$* ]\n","err":"","out":"[\\43,$VAR1->[0]]"},{"err":"","out":"!(0 || 1 && (0 || 0)) && !(1 && 1)\n","code":"use feature 'say'; say \"!(0 || 1 && (0 || 0)) && !(1 && 1)\"\n"},{"out":"ERROR: Parse error at (eval 558) line 1, <STDIN> line 1.\nsyntax error at (eval 558) line 1, near \"(__SUB__\"\n","err":"","code":"use feature 'signatures'; sub add (__SUB__->(2,2)) { }   [ add(), add(2), add(2,3)  ]\n"},{"code":"use feature 'signatures'; sub add ($x = 0, $y = 0) { return $x + $y }   [ add(), add(2), add(2,3)  ]\n","err":"","out":"[0,2,5]"},{"code":"use feature 'signatures'; sub add ($x = return 0, $y = return $x) { return $x + $y }   [ add(), add(2), add(2,3)  ]\n","out":"ERROR: Too many arguments for subroutine at (eval 558) line 1.\n","err":""},{"code":"use File::Basename;\n","out":"","err":""},{"out":"[\"./\",\"./\",\"./\",\"./\",\"./\",\"./\"]","err":"","code":"use File::Basename; [map +(fileparse $_)[1], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n"},{"out":"[\"\",\"\",\"\",\"\",\"\",\"\"]","err":"","code":"use File::Basename; [map +(fileparse $_)[2], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n"},{"out":"[\"./\",\"./\",\"./\",\"./\",\"./\",\"./\"]","err":"","code":"use File::Basename; [map +(fileparse $_, qr/(?<=.)[^.]+/)[1], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n"},{"code":"use File::Basename; [map +(fileparse $_, qr/(?<=\\.)[^.]+/)[1], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n","err":"","out":"[\"./\",\"./\",\"./\",\"./\",\"./\",\"./\"]"},{"out":"[\"./\",\"./\",\"./\",\"./\",\"./\",\"./\"]","err":"","code":"use File::Basename; [map +(fileparse $_, qr/[^.]+/)[1], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n"},{"out":"[\"jpg\",\"pdf\",\"\",\"vimrc\",\"pl\",\"\"]","err":"","code":"use File::Basename; [map +(fileparse $_, qr/(?<=\\.)[^.]+/)[2], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n"},{"code":"use File::Basename; [map +(fileparse $_, qr/[^.]+/)[2], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n","out":"[\"jpg\",\"pdf\",\"\",\"vimrc\",\"pl\",\"README\"]","err":""},{"code":"use File::Basename qw/fileparse/; [map +(basename $_)[2], \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n","err":"","out":"ERROR: Can't locate object method \"basename\" via package \"foo.jpg\" (perhaps you forgot to load \"foo.jpg\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: syntax error at (eval 558) line 1, near \"] \"foo.jpg\"\"\n","err":"","code":"use File::Basename qw/fileparse/; [map +(basename$_)[2] \"foo.jpg\", \"foo\\nbar.pdf\",\"foo.png.\", \".vimrc\",\"x.js.pl\",\"README\"]\n"},{"code":"use File::Spec; \n","out":"","err":""},{"code":"use File::Spec; use CGI\n","out":"ERROR: Can't locate CGI.pm:   (null): Too many open files at (eval 558) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 2, <STDIN> line 1.\n","err":""},{"code":"use JSON;\n","err":"","out":""},{"out":"","err":"","code":"use JSON::MaybeXS;\n"},{"err":"","out":"Cpanel::JSON::XS","code":"use JSON::MaybeXS; JSON\n"},{"out":"[\"Cpanel::JSON::XS\"]","err":"","code":"use JSON::MaybeXS; [ JSON() ]\n"},{"code":"use JSON::MaybeXS; JSON()\n","out":"Cpanel::JSON::XS","err":""},{"code":"use JSON::MaybeXS; [ *main::JSON{CODE} ]\n","out":"[sub { \"DUMMY\" }]","err":""},{"code":"use JSON::PP; no JSON::XS; no Cpanel::JSON::XS; use JSON::MaybeXS; JSON(); # Don't think this will work\n","err":"","out":"ERROR: Can't locate JSON/PP.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use JSON::XS;\n","out":"","err":""},{"code":"use  JSON::XS; no Cpanel::JSON::XS; use JSON::MaybeXS; JSON(); # Don't think this will work\n","out":"Cpanel::JSON::XS","err":"Prototype mismatch: sub main::decode_json ($) vs ($;$) at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/Exporter.pm line 66, <STDIN> line 1.\n at (eval 558) line 1.\n"},{"out":"","err":"","code":"use List::Util;\n"},{"err":"","out":"[55,210,120,136,171,153]","code":"use List::Util qw/reduce/; [ map { reduce {$a + $b} 1..$_ } 10, 20, 15, 16, 18, 17 ]\n"},{"code":"use List::Util qw/reduce/; [ map { reduce {$a + $b} 1..$_ } sort 10, 20, 15..18 ]\n","out":"[55,120,136,153,171,210]","err":""},{"err":"","out":"55","code":"use List::Util qw/reduce/; reduce {$a + $b} 1..10\n"},{"code":"use List::Util qw/reduce/; reduce {$a + $b} 1..15\n","err":"","out":"120"},{"code":"use List::Util qw/reduce/; reduce {$a + $b} 1..16\n","out":"136","err":""},{"code":"use List::Util qw/reduce/; reduce {$a + $b} 1..17\n","out":"153","err":""},{"err":"","out":"171","code":"use List::Util qw/reduce/; reduce {$a + $b} 1..18\n"},{"err":"","out":"210","code":"use List::Util qw/reduce/; reduce {$a + $b} 1..20\n"},{"code":"use List::Util qw(shufffle); [ shuffle 1..20 ]\n","out":"ERROR: \"shufffle\" is not exported by the List::Util module\nCan't continue after import errors at (eval 558) line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"[11,9,10,12,2,5,14,7,3,13,17,16,20,6,19,18,8,15,1,4]","err":"","code":"use List::Util qw(shuffle); [ shuffle 1..20 ]\n"},{"code":"use List::Util qw(shuffle); sub bubsort { my $arr = shift; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i] }; $arr }; bubsort [ shuffle 1..20 ]\n","out":"[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]","err":""},{"err":"","out":"[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]","code":"use List::Util qw(shuffle); sub bubsort { my $arr = shift; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i]; &bubsort }; $arr }; bubsort [ shuffle 1..20 ]\n"},{"err":"","out":"[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]","code":"use List::Util qw(shuffle); sub bubsort { my ($arr) = @_; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i]; &bubsort }; $arr }; bubsort [ shuffle 1..100 ]\n"},{"code":"use List::Util qw(shuffle); sub bubsort { my ($arr) = @_; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i]; &bubsort }; $arr }; bubsort [ shuffle 1..20 ]\n","err":"","out":"[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]"},{"err":"","out":"ERROR: Can't locate Math/Complex.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use Math::Complex; \n"},{"out":"","err":"","code":"use MIME::Base64;\n"},{"out":"http://safr.kingfeatures.com/BeetleBailey/2004/05/Beetle_Bailey.20040522_900.gif","err":"","code":"use MIME::Base64; decode_base64 'aHR0cDovL3NhZnIua2luZ2ZlYXR1cmVzLmNvbS9CZWV0bGVCYWlsZXkvMjAwNC8wNS9CZWV0bGVfQmFpbGV5LjIwMDQwNTIyXzkwMC5naWY='\n"},{"code":"use MIME::Base64; use warnings; sub z { substr shift, 1, 1 }  z('â´')\n","out":"ÃÂ","err":""},{"err":"","out":"","code":"use overload\n"},{"code":"use overload;\n","err":"","out":""},{"code":"use overload q|\"\"| => sub { 42 }; my @a; $a[42] = 'forty two'; [ $a[bless 'main'] ]\n","out":"ERROR: Can't bless non-reference value at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use overload q|\"\"| => sub { 42 }; my @a; $a[42] = 'forty two'; [ $a[bless {}, 'main'] ]\n","err":"","out":"[\"forty two\"]"},{"out":"ERROR: Died at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use overload qw,\"\",=> sub { die }; bless {}, bless []; 42;\n"},{"err":"","out":"42","code":"use overload qw,\"\",=> sub { die }; my $x = bless []; 42;\n"},{"err":"","out":"ERROR: Died at (eval 558) line 1, <STDIN> line 1.\n","code":"use overload qw,\"\",=> sub { die }; my $x = bless []; bless {}, $x; 42;\n"},{"err":"","out":"abcdef","code":"use overload '\"\"' => sub { 'abcdef' }; '' . bless [];\n"},{"out":"abcdef","err":"","code":"use overload '\"\"' => sub { 'abcdef' }; ref bless [], bless [];\n"},{"code":"use overload '\"\"' => sub { die 'abcdef' }; ref bless [], bless [];\n","out":"ERROR: abcdef at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use POSIX qw/ceil/; [ ceil(-2.20, int -2.2 ]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"2.2 ]\"\n","err":""},{"code":"use POSIX qw/ceil/; [ ceil -2.2, int(-2.2) ]\n","out":"ERROR: Usage: POSIX::ceil(x) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use POSIX qw/ceil/; [ ceil(-2.2), int -2.2 ]\n","err":"","out":"[-2,-2]"},{"err":"","out":"ERROR: Can't locate Safe.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use Safe;\n"},{"err":"","out":"[\"two\"]","code":"use Scalar::Util qw/dualvar/; my $i = dualvar 1, 'forty two'; my @a = qw/one two/; [ $a[ $i ] ];\n"},{"out":"[\"two\",\"one\"]","err":"","code":"use Scalar::Util qw/dualvar/; my $i = dualvar 1, 'forty two'; my @a = qw/one two/; [ $a[ $i ], $a[ \"$i\" ] ];\n"},{"out":"[\"two\",\"two\"]","err":"","code":"use Scalar::Util qw/dualvar/; my $i = dualvar 1, 'forty two'; my @a = qw/one two/; [ $a[ $i ], $a[ $i+0 ] ];\n"},{"out":"[42,\"foo\"]","err":"","code":"use Scalar::Util qw/dualvar/; my $x = dualvar(42,'foo'); [ $x+0, \"$x\" ]\n"},{"out":"[55,55]","err":"","code":"use Scalar::Util qw/dualvar/; my $x = dualvar('42','foo'); $x = 55; [ $x+0, \"$x\" ]\n"},{"out":"[42,\"forty two\"]","err":"","code":"use Scalar::Util qw/dualvar/; my $x = dualvar 42, 'forty two'; [$x+0, \"$x\"]\n"},{"code":"use Scalar::Util qw/dualvar/; my $x = dualvar 42, 'forty two'; [$x, \"$x\"]\n","err":"","out":"[\"forty two\",\"forty two\"]"},{"code":"use Scalar::Util qw/dualvar/; my $x = dualvar('NaN','foo'); [ $x+0, \"$x\" ]\n","err":"","out":"[\"NaN\",\"foo\"]"},{"out":"[\"foo\",42]","err":"","code":"use Scalar::Util qw/dualvar/; $x = dualvar 42, 'foo'; [ $x.'', $x+0 ]\n"},{"err":"","out":"ERROR: \"looks_like_a_number\" is not exported by the Scalar::Util module\nCan't continue after import errors at (eval 558) line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use Scalar::Util qw/looks_like_a_number/; looks_like_a_number 'NaN'\n"},{"err":"","out":"[\"\"]","code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'iNan' ]\n"},{"code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'Nan' ]\n","out":"[1]","err":""},{"err":"","out":"[1]","code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'NaN' ]\n"},{"out":"1","err":"","code":"use Scalar::Util qw/looks_like_number/; looks_like_number 'NaN'\n"},{"code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'sdss' ]\n","err":"","out":"[\"\"]"},{"err":"","out":"[1]","code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'sNan' ]\n"},{"code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'sNaN' ]\n","err":"","out":"[1]"},{"err":"","out":"[\"\"]","code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'wtfNan' ]\n"},{"err":"","out":"[\"\"]","code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'xsNan' ]\n"},{"code":"use Scalar::Util qw/looks_like_number/; [ looks_like_number 'zNan' ]\n","out":"[\"\"]","err":""},{"err":"","out":"ERROR: Can't locate Scalar/Utils.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use Scalar::Utils qw/dualvar/; my $x = dualvar 42, 'forty two'; [$x, \"$x\"]\n"},{"code":"use strict; *4 = sub { 'ok' }; *{ \\4 };\n","err":"","out":"ERROR: Not a GLOB reference at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"*main::4","err":"","code":"use strict; *4 = sub { 'ok' }; *{ 4 };\n"},{"err":"","out":"ERROR: Not a CODE reference at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; *4 = sub { 'ok' }; &{ \\4 };\n"},{"out":"ok","err":"","code":"use strict; *4 = sub { 'ok' }; &{4};\n"},{"code":"use strict; *4 = sub { 'ok' }; main->${ \\4 };\n","out":"ok","err":""},{"code":"use strict; $a=\"foo bar\"; *$a = sub {\"baz\"}; \"foo bar\"->()\n","err":"","out":"ERROR: Can't use string (\"foo bar\") as a symbol ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: Global symbol \"$foo\" requires explicit package name (did you forget to declare \"my $foo\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict;  BEGIN { *::foo = \\$::foo; } $foo = 42;\n"},{"code":"use strict; BEGIN { package Zomg; use strict; *::foo = \\$::foo; }  $foo = 42;\n","err":"","out":"42"},{"out":"ERROR: Global symbol \"$fl\" requires explicit package name (did you forget to declare \"my $fl\"?) at (eval 558) line 1, <STDIN> line 1.\nGlobal symbol \"$fl\" requires explicit package name (did you forget to declare \"my $fl\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; $fl = '+++????? random shit any user can send to the bot'; my @mem_list = grep { $_ =~ /^$fl/i} 42;\n"},{"code":"use strict;  *::foo = \\$::foo;  $foo = 42;\n","err":"","out":"ERROR: Global symbol \"$foo\" requires explicit package name (did you forget to declare \"my $foo\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; inf\n","out":"bless( {_a => undef,_p => undef,value => [0],sign => \"+inf\"}, 'Math::BigInt' )","err":""},{"code":"use strict; \"-inf\"<0\n","out":"1","err":""},{"code":"use strict; \"inf\"<0\n","err":"","out":""},{"code":"use strict; \"inf\">0\n","out":"1","err":""},{"code":"use strict; \"inf\"+0\n","out":"Inf","err":""},{"err":"","out":"ERROR: Global symbol \"$x_\" requires explicit package name (did you forget to declare \"my $x_\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; my $x; if ( $x = \"x\\b\" ) { print \"_$x_\" }\n"},{"out":"ERROR: Can't use single ref constructor for loop variable at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use v5.21; use feature qw(refaliasing);use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); foreach \\%hash (@a) {print Dumper(%hash);}\n"},{"out":"ERROR: Missing $ on loop variable at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use v5.21; use feature qw(refaliasing);use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); foreach my \\%hash (@a) {print Dumper(%hash);}\n"},{"err":"","out":"$VAR1 = 'bar';\n$VAR2 = 2;\n$VAR3 = 'foo';\n$VAR4 = 1;\n$VAR1 = 'problems';\n$VAR2 = 99;\n$VAR3 = 'bitches';\n$VAR4 = 0;\n","code":"use strict; use v5.21; use feature qw(refaliasing);use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); my %hash; foreach \\%hash (@a) {print Dumper(%hash);}\n"},{"out":"","err":"","code":"use strict; use warnings; blasdsdasdsa->import\n"},{"err":"","out":"$b$b$b","code":"use strict; use warnings; $_ = '@f@f@f'; s'@f'$b'gr; \n"},{"out":"[\"b\",\"d\"]","err":"","code":"use strict; use warnings; [ grep defined, @{+{a => \"b\", c => \"d\", e => \"f\"}}{qw/a b c/} ];\n"},{"code":"use strict use warnings; h->{two}();  sub h { +{ one => sub { 1 }, two => sub { 2 } } }\n","out":"ERROR: \"use\" not allowed in expression at (eval 558) line 1, at end of line\nsyntax error at (eval 558) line 1, near \"use strict use warnings\"\n","err":""},{"out":"ERROR: Can't use bareword (\"h\") as a HASH ref while \"strict refs\" in use at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; h->{two}();  sub h { +{ one => sub { 1 }, two => sub { 2 } } }\n"},{"out":"2","err":"","code":"use strict; use warnings; h()->{two}();  sub h { +{ one => sub { 1 }, two => sub { 2 } } }\n"},{"err":"","out":"ERROR: Bareword \"Inf\" not allowed while \"strict subs\" in use at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; +Inf\n"},{"err":"","out":"[1]","code":"use strict; use warnings; [ \"+inf\" > 0 ]\n"},{"code":"use strict; use warnings; \"+Inf\"+0\n","out":"Inf","err":""},{"code":"use strict; use warnings; [ \"-Inf\" > 0 ]\n","out":"[\"\"]","err":""},{"out":"[1]","err":"","code":"use strict; use warnings; [ \"+Inf\" > 0 ]\n"},{"err":"Argument \"+Inx\" isn't numeric in numeric gt (>) at (eval 558) line 1, <STDIN> line 1.\n","out":"[\"\"]","code":"use strict; use warnings; [ \"+Inx\" > 0 ]\n"},{"code":"use strict; use warnings; my $a = 42; my $z = 42; [ sort { $z <=> $b } 42 ]\n","err":"","out":"[42]"},{"code":"use strict; use warnings; my $a = 42; [ sort ]\n","out":"[]","err":""},{"code":"use strict; use warnings; my $a = 42; sort \n","out":"","err":"Useless use of sort in scalar context at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; my $a = 42; [ sort { $a <=> $b } 42 ]\n","out":"[42]","err":"\"my $a\" used in sort comparison at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use strict; use warnings; my $a = 42; [ sort { $z <=> $b } 42 ]\n","out":"ERROR: Global symbol \"$z\" requires explicit package name (did you forget to declare \"my $z\"?) at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"Use of uninitialized value in array element at (eval 558) line 1, <STDIN> line 1.\n","out":"","code":"use strict; use warnings; my @a; $a[undef]\n"},{"code":"use strict; use warnings; my $foo; if ( %$foo ) { 1; }\n","err":"","out":"ERROR: Can't use an undefined value as a HASH reference at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"","err":"","code":"use strict; use warnings; my $foo; if ( $foo and %$foo ) { 1; }\n"},{"code":"use strict; use warnings; my $h = {a => \"b\", c => \"d\", e => \"f\"}; my $str = join \",\", grep defined, @$h{qw/a b c/}; print $str;\n","out":"b,d","err":""},{"code":"use strict; use warnings; my $str = join \",\", grep defined, @{+{a => \"b\", c => \"d\", e => \"f\"}}{qw/a b c/}; print $str;\n","out":"b,d","err":""},{"code":"use strict; use warnings; my $x = 42; [ defined &$x ]\n","out":"[\"\"]","err":""},{"out":"[\"\"]","err":"Use of uninitialized value $x in subroutine dereference at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; my $x; [ defined &$x ]\n"},{"code":"use strict; use warnings; my $x; [ &$x ]\n","err":"","out":"ERROR: Can't use an undefined value as a subroutine reference at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"[\"\"]","code":"use strict; use warnings; [ \"nan\" > 0 ]\n"},{"out":"[\"\"]","err":"","code":"use strict; use warnings; [ \"Nan\" > 0 ]\n"},{"out":"[\"\"]","err":"","code":"use strict; use warnings; [ \"NaN\" > 0 ]\n"},{"code":"use strict; use warnings; [ \"nann\" > 0 ]\n","out":"[\"\"]","err":"Argument \"nann\" isn't numeric in numeric gt (>) at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"[\"NaN\"]","err":"","code":"use strict; use warnings; [ 'NaN' + 'sNaN' ]\n"},{"code":"use strict; use warnings; [ 'NaN' + 'sNaN' + 55]\n","err":"","out":"[\"NaN\"]"},{"code":"use strict; use warnings; open( my($fh), \"<\", \\\"asdf\" ); [ <$fh> ];\n","err":"","out":"[\"asdf\"]"},{"out":"[\"asdf\",undef]","err":"","code":"use strict; use warnings; open( my($fh), \"<\", \\\"asdf\" ); [ <$fh>, scalar <$fh> ];\n"},{"err":"","out":"[\"asdf\",undef,undef]","code":"use strict; use warnings; open( my($fh), \"<\", \\\"asdf\" ); [ <$fh>, scalar <$fh>, scalar <$fh> ];\n"},{"err":"","out":"[10,9,8,7,6,5,4,3,2,1]","code":"use strict; use warnings; our $a = -1; [ sort {  $b <=> $a } 1..10 ]\n"},{"out":"[10,9,8,7,6,5,4,3,2,1]","err":"","code":"use strict; use warnings; our $a = 42; [ sort {  $b <=> $a } 1..10 ]\n"},{"out":"blah","err":"","code":"use strict; use warnings; our $VERSION = 'blah';\n"},{"err":"","out":"ERROR: Global symbol \"$foo\" requires explicit package name (did you forget to declare \"my $foo\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict;  use warnings; sub bar { 42 } print \"Return $foo\" if my $foo = bar;\n"},{"code":"use strict; use warnings; sub h { +{ one => sub { 1 }, two => sub { 2 } } }  h->{two}();  \n","out":"2","err":""},{"code":"use strict; use warnings; sub TIEHANDLE { bless [] }; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ print FH 'adfasdf' ];\n","out":"In autoload!","err":""},{"code":"use strict; use warnings; sub TIEHANDLE { bless [] }; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ scalar readline FH ];\n","err":"","out":"In autoload!"},{"err":"","out":"ERROR: Global symbol \"$AUTOLOAD\" requires explicit package name (did you forget to declare \"my $AUTOLOAD\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"use strict; use warnings; sub TIEHANDLE { bless [] }; sub AUTOLOAD { print \"In autoload! $AUTOLOAD\"; 42 }; tie *FH, 'main'; [ print FH 'adfasdf' ];\n"},{"err":"","out":"[\"asdf\"]","code":"use strict; use warnings; sub TIEHANDLE { bless [] }; sub READLINE { \"asdf\" }; sub AUTOLOAD { print \"In autoload!\"; 42 }; tie *FH, 'main'; [ scalar readline FH ];\n"},{"out":"ERROR: Can't locate autodie.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use strict; use warnings; use autodie; open( my($fh), \"<\", \\\"asdf\" ); [ <$fh> ];\n"},{"code":"use strict; use warnings; $VERSION = 'blah';\n","err":"","out":"ERROR: Global symbol \"$VERSION\" requires explicit package name (did you forget to declare \"my $VERSION\"?) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use Test::More\n","out":"ERROR: Can't locate Test/More.pm:   (null): Too many open files at (eval 558) line 2, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 2, <STDIN> line 1.\n","err":""},{"code":"use Text::Soundex;\n","out":"ERROR: Can't locate Text/Soundex.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use Text::SoundEx;\n","out":"ERROR: Can't locate Text/SoundEx.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Can't locate Tie/Handle.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use Tie::Handle; tie *FH, 'Tie::Handle'; \n"},{"code":"use Try::Tiny; try {die \"baz\";} catch {die \"foo\"}; die \"bar\";\n","err":"","out":"ERROR: foo at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: foo at (eval 558) line 1, <STDIN> line 1.\n","code":"use Try::Tiny; try {die \"baz\";} catch {die \"foo\"} finally { \"bar\"};\n"},{"code":"use Try::Tiny; try {die \"baz\";} catch {die \"foo\"} finally { die \"bar\"};\n","err":"Execution of finally() block CODE(0x463fc08) resulted in an exception, which *CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. Your program will continue as if this event never took place. Original exception text follows:\n\nbar at (eval 558) line 1, <STDIN> line 1.\n\n","out":"ERROR: foo at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"hoyl shit that brokeERROR: foo at (eval 558) line 1, <STDIN> line 1.\n","code":"use Try::Tiny; try {die \"baz\";} catch {die \"foo\"} finally { print \"hoyl shit that broke\"};\n"},{"out":"","err":"","code":"use URI::Encode qw/uri_encode/;\n"},{"code":"use URI::Encode qw/uri_encode/; uri_encode \"<arg>\", {\"encode_reserved\", 1}; \n","err":"","out":"%3Carg%3E"},{"code":"use URI::Encode qw/uri_encode/; uri_encode \"LWP::Authen::Digest\"\n","out":"LWP::Authen::Digest","err":""},{"err":"","out":"[\"test\"]","code":"use URI::Encode; [ URI::Encode::uri_encode \"test\", {encode_reserved=>1} ];\n"},{"code":"use URI; URI->new('/product/IDHEREFUCKER');\n","out":"ERROR: Can't locate URI/_generic.pm:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/URI.pm line 104, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Can't locate URI/_generic.pm:   (null): Too many open files at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/URI.pm line 104, <STDIN> line 1.\n","code":"use URI; URI->new(\"www.ebay.com\");\n"},{"code":"use utf8; - - 'â§'\n","out":"0","err":""},{"out":"ERROR: Can't modify constant item in transliteration (tr///) at (eval 558) line 1, near \"y ÃÂ¢ÃÂÃÂ¢ a-z: ÃÂ¢ÃÂÃÂ¢ n-za-m ÃÂ¢ÃÂÃÂ¢ r \"\nsyntax error at (eval 558) line 1, near \"y ÃÂ¢ÃÂÃÂ¢ a-z: ÃÂ¢ÃÂÃÂ¢ n-za-m ÃÂ¢ÃÂÃÂ¢ r \"\n","err":"","code":"use utf8; [ 'get http://ignorantdesigner.com/japh.html' =~ y â¢ a-z: â¢ n-za-m â¢ r ]\n"},{"code":"use utf8; [ 'get http://ignorantdesigner.com/japh.html' =~ y â¢ a-z: â¢ n-za-m â¢r ]\n","err":"","out":"[\"trg uggc //vtabenagqrfvtare.pbz/wncu.ugzy\"]"},{"out":"[\"\\0\\0\\0\\0\\0\"]","err":"","code":"use utf8; $l = \"fooso\"; [ $l & chr(0x80)x(length $l) ]\n"},{"out":"[\"\"]","err":"","code":"use utf8; $l = \"fooso\"; [ $l =~tr/[\\0-\\127]//cdr  ]\n"},{"code":"use utf8; $l = \"fooso\"; [ $l =~tr/[\\0-\\127]//dr  ]\n","out":"[\"fooso\"]","err":""},{"err":"","out":"[\"fooso\"]","code":"use utf8; $l = \"fooso\"; [ $l =~tr/\\0-\\127//dr  ]\n"},{"code":"use utf8; $l = \"fooso\"; [ $l =~tr/[\\0-\\127]//r  ]\n","err":"","out":"[\"fooso\"]"},{"out":"[\"\"]","err":"","code":"use utf8; $l = \"fooso\"; [ $l =~tr/\\0-\\225//dr  ]\n"},{"code":"use utf8; $l = \"fooso\"; [ $l =~tr/\\0-\\250//dr  ]\n","err":"","out":"[\"\"]"},{"err":"","out":"ERROR: Unrecognized character \\x{37e}; marked by <-- HERE after f8; my $ a<-- HERE near column 107 at (eval 558) line 1, <STDIN> line 1.\n","code":"use utf8; my $ aÍ¾ print;\n"},{"code":"use utf8; my $aÍ¾ print;\n","out":"ERROR: Unrecognized character \\x{37e}; marked by <-- HERE after tf8; my $a<-- HERE near column 106 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Unrecognized character \\x{2019}; marked by <-- HERE after f8; print <-- HERE near column 107 at (eval 558) line 1, <STDIN> line 1.\n","code":"use utf8; print â42â\n"},{"err":"","out":"ERROR: Unrecognized character \\x{200e}; marked by <-- HERE after y, #perl ÃÂ¢ÃÂÃÂ¤<-- HERE near column 136 at (eval 558) line 1, <STDIN> line 1.\n","code":"use utf8; q â¤â Happy Valentine's Day, #perl â¤â \n"},{"err":"","out":"ERROR: Unrecognized character \\x{200e}; marked by <-- HERE after y, #perl ÃÂ¢ÃÂÃÂ¤<-- HERE near column 136 at (eval 558) line 1, <STDIN> line 1.\n","code":"use utf8; q â¤â Happy Valentine's Day, #perl â¤â â¤âr\n"},{"code":"use utf8; q â¤â Happy Valentine's Day, #perl â¤â  s â¤ â¤âr\n","out":"ERROR: Unrecognized character \\x{200e}; marked by <-- HERE after y, #perl ÃÂ¢ÃÂÃÂ¤<-- HERE near column 136 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"err":"","out":"ERROR: Unrecognized character \\x{200e}; marked by <-- HERE after y, #perl ÃÂ¢ÃÂÃÂ¤<-- HERE near column 136 at (eval 558) line 1, <STDIN> line 1.\n","code":"use utf8; q â¤â Happy Valentine's Day, #perl â¤â  s â¤ â¤â â¤r\n"},{"code":"use utf8; q â¤â Happy Valentine's Day, perl â¤ ;â  s â¤ â¤â â¤r\n","out":"ERROR: Unrecognized character \\x{200e}; marked by <-- HERE after , perl ÃÂ¢ÃÂÃÂ¤ ;<-- HERE near column 137 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"code":"use utf8; q â¤â Happy Valentine's Day, perl â¤;â  s â¤ â¤â â¤r\n","out":"ERROR: Unrecognized character \\x{200e}; marked by <-- HERE after y, perl ÃÂ¢ÃÂÃÂ¤;<-- HERE near column 136 at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"ERROR: Unrecognized character \\x{200e}; marked by <-- HERE after ay, perl ÃÂ¢ÃÂÃÂ¤<-- HERE near column 135 at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use utf8; q â¤â Happy Valentine's Day, perl â¤â  s â¤ â¤â â¤r\n"},{"err":"","out":" ÃÂ¢ÃÂÃÂº Perl \\o/ ÃÂ¢ÃÂÃÂº  ","code":"use utf8; q ð âº Perl \\o/ âº  ð\n"},{"code":"use utf8; quotemeta 'Ã·'\n","out":"\\ÃÂ·","err":""},{"code":"use utf8; quotemeta \"Ç\"\n","err":"","out":"ÃÂÃÂ"},{"code":"use utf8; say length \"ïº\"\n","out":"1\n","err":""},{"err":"","out":"\\ÃÂÃÂ","code":"use utf8; \"Ç\" =~ s/([^A-Za-z_0-9])/\\\\$1/gr\n"},{"err":"","out":"\\ÃÂÃÂ","code":"use utf8; \"Ç\" =~ s/([^A-Za-z_0-9])/\\\\$1/r\n"},{"code":"use utf8; s â¤â Happy Valentine's Day, #perl â¤â â¤ â¤âr\n","err":"","out":"ERROR: Unrecognized character \\x{2764}; marked by <-- HERE after perl ÃÂ¢ÃÂÃÂ¤ÃÂ¢ÃÂÃÂ ÃÂ¢ÃÂÃÂ¤ <-- HERE near column 140 at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"ERROR: Unrecognized character \\x{200e}; marked by <-- HERE after #perl ÃÂ¢ÃÂÃÂ¤ÃÂ¢ÃÂÃÂ ÃÂ¢ÃÂÃÂ¤<-- HERE near column 139 at (eval 558) line 1, <STDIN> line 1.\n","code":"use utf8; s â¤â Happy Valentine's Day, #perl â¤â â¤âr\n"},{"err":"","out":"ERROR: Unrecognized character \\x{200e}; marked by <-- HERE after #perl ÃÂ¢ÃÂÃÂ¤ÃÂ¢ÃÂÃÂ ÃÂ¢ÃÂÃÂ¤<-- HERE near column 139 at (eval 558) line 1, <STDIN> line 1.\n","code":"use utf8; s â¤â Happy Valentine's Day, #perl â¤â â¤â â¤âr\n"},{"out":"[1,3]","err":"","code":"use utf8; use Encode; my $z = 'â';  [ length($z), length(encode 'utf8', $z) ]\n"},{"out":"ÃÂ¢ÃÂÃÂ´","err":"Wide character in print at (eval 558) line 1, <STDIN> line 1.\n","code":"use utf8; use warnings; sub z { print shift }  z('â´')\n"},{"code":"use utf8; use warnings; sub z { substr shift, 1, 1 }  z('â´')\n","out":"","err":""},{"code":"use v5.21; 0.deadbeefp2\n","out":"ERROR: syntax error at (eval 558) line 1, near \"0.deadbeefp2\n\"\n","err":""},{"code":"use v5.21; $a = 0.deadbeefp2\n","out":"ERROR: syntax error at (eval 558) line 1, near \"0.deadbeefp2\n\"\n","err":""},{"err":"","out":"[1,2,6]","code":"use v5.21; ($a, $b, (undef) x 3, $c) = (1..10); [$a, $b, $c]\n"},{"out":"ERROR: Can't declare repeat (x) in \"my\" at (eval 558) line 1, near \") =\"\n","err":"","code":"use v5.21; my ($a, $b, (undef) x 3, $c) = (1..10); [$a, $b, $c]\n"},{"out":"ERROR: Missing $ on loop variable at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use v5.21; use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); for my \\%hash (@a) {print Dumper(%hash);}\n"},{"err":"","out":"ERROR: Missing $ on loop variable at (eval 558) line 1, <STDIN> line 1.\n","code":"use v5.21; use feature qw(refaliasing);use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); foreach my \\%hash (@a) {print Dumper(%hash);}\n"},{"code":"use v5.21; use feature qw(refaliasing);use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); for \\%hash (@a) {print Dumper(%hash);}\n","err":"","out":"$VAR1 = 'bar';\n$VAR2 = 2;\n$VAR3 = 'foo';\n$VAR4 = 1;\n$VAR1 = 'bitches';\n$VAR2 = 0;\n$VAR3 = 'problems';\n$VAR4 = 99;\n"},{"out":"ERROR: Missing $ on loop variable at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use v5.21; use feature qw(refaliasing);use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); for my \\%hash (@a) {print Dumper(%hash);}\n"},{"out":"ERROR: Missing $ on loop variable at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use v5.22; use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); for my \\%hash (@a) {print Dumper(%hash);}\n"},{"code":"use vars qw/@CARP_NOT/; Carp::croak(\"loaded\");\n","out":"ERROR: loaded at (eval 558) line 1, <STDIN> line 1.\n\teval 'use 5.022001; use feature qw/postderef refaliasing lexical_subs postderef_qq signatures/; use vars qw/@CARP_NOT/; Carp::croak(\"loaded\");' called at /home/ryan/bots/perlbuut/lib/eval.pl line 301\n\tmain::perl_code(\"use vars qw/\\@CARP_NOT/; Carp::croak(\\\"loaded\\\");\") called at /home/ryan/bots/perlbuut/lib/eval.pl line 248\n","err":""},{"err":"","out":"$b$b$b","code":"use warnings; $_ = '@f@f@f'; s'@f'$b'gr; \n"},{"code":"use warnings; foo(3); sub foo(@) { print @_ }\n","err":"The signatures feature is experimental at (eval 558) line 1, <STDIN> line 1.\n","out":"3"},{"out":"3","err":"The signatures feature is experimental at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; foo(3); sub foo($) { print @_ }\n"},{"code":"use warnings; \"foo\" ~~ \"Bar\"\n","err":"Smartmatch is experimental at (eval 558) line 1, <STDIN> line 1.\n","out":""},{"code":"use warnings; \"foo\" ~~ \"Bar\":\n","out":"ERROR: syntax error at (eval 558) line 1, near \"\"Bar\":\"\n","err":"Smartmatch is experimental at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; +{ foo => bar => 'ber' }\n","out":"{foo => \"bar\",ber => undef}","err":"Odd number of elements in anonymous hash at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; @hash{$key} = [ @list ];\n","err":"Use of uninitialized value $key in hash slice at (eval 558) line 1, <STDIN> line 1.\n","out":"1"},{"code":"use warnings; my $foo = 1; my $foo_bar = 2; \"$foo\\_bar\"\n","err":"","out":"1_bar"},{"code":"use warnings; my $foo = 1; my $foobar = 2; \"$foo\\bar\"\n","err":"","out":"1\bar"},{"code":"use warnings; my ($foo) if 0;\n","out":"0","err":"Deprecated use of my() in false conditional at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; my $j = 'Foo'; $j =~ tr/\\x20-\\xff/\\xff10-\\xffff/; binmode STDOUT; print $j;\n","out":"T}}","err":""},{"code":"use warnings; my $j = 'Foo'; $j =~ tr/\\x20-\\xff/\\xff30-\\xffff/; binmode STDOUT; print $j;\n","err":"","out":"T}}"},{"err":"","out":"[]","code":"use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; [ eval qq{ 'Just another Unicode hacker,' =~ tr[$l][$r]r } ];\n"},{"out":"","err":"","code":"use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; eval qq{ 'Just another Unicode hacker,' =~ tr[$l][$r]r };\n"},{"code":"use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; eval qq{ 'Just another Unicode hacker,' =~ tr[$l][$r]r }; $@\n","out":"Transliteration pattern not terminated at (eval 559) line 1, <STDIN> line 1.\n","err":""},{"code":"use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; eval qq{ 'Just another Unicode hacker,' =~ tr[\\Q$l\\E][\\Q$r\\E]r };\n","err":"","out":"Ã¯Â¼ÂªustÃ¯Â¼ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂtÃ¯Â½ÂÃ¯Â½ÂrÃ¯Â¼ÂÃ¯Â¼ÂµÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â¼ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂrÃ¯Â¼Â"},{"code":"use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; eval qq{ 'Just another Unicode hacker,' =~ tr[\\Q$l\\E][\\Q$r\\E]r }; $@\n","err":"","out":""},{"err":"","out":" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnop","code":"use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; $l\n"},{"out":"Ã¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼ÂÃ¯Â¼Â Ã¯Â¼Â¡Ã¯Â¼Â¢Ã¯Â¼Â£Ã¯Â¼Â¤Ã¯Â¼Â¥Ã¯Â¼Â¦Ã¯Â¼Â§Ã¯Â¼Â¨Ã¯Â¼Â©Ã¯Â¼ÂªÃ¯Â¼Â«Ã¯Â¼Â¬Ã¯Â¼Â­Ã¯Â¼Â®Ã¯Â¼Â¯Ã¯Â¼Â°Ã¯Â¼Â±Ã¯Â¼Â²Ã¯Â¼Â³Ã¯Â¼Â´Ã¯Â¼ÂµÃ¯Â¼Â¶Ã¯Â¼Â·Ã¯Â¼Â¸Ã¯Â¼Â¹Ã¯Â¼ÂºÃ¯Â¼Â»Ã¯Â¼Â¼Ã¯Â¼Â½Ã¯Â¼Â¾Ã¯Â¼Â¿Ã¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½ÂÃ¯Â½Â","err":"","code":"use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; $r\n"},{"code":"use warnings; my $u = 'ABC'; say $u =~ s/./pos $u/ger;\n","out":"\n","err":"Use of uninitialized value in substitution iterator at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value in substitution iterator at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value in substitution iterator at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"","code":"use warnings; my @x = (1...4); undef @x;\n"},{"code":"use warnings; my $x; $x++;\n","err":"","out":"0"},{"code":"use warnings; my $x; ++$x;\n","out":"1","err":""},{"err":"","out":"-4","code":"use warnings; my $x; $x -= 4;\n"},{"code":"use warnings; my $x; $x .= 4;\n","out":"4","err":""},{"err":"","out":"4","code":"use warnings; my $x; $x += 4;\n"},{"code":"use warnings; my $x; $x . 'foo'\n","err":"Use of uninitialized value $x in concatenation (.) or string at (eval 558) line 1, <STDIN> line 1.\n","out":"foo"},{"code":"use warnings; my $x; $x = $x - 4;\n","out":"-4","err":"Use of uninitialized value $x in subtraction (-) at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"use warnings; our $foo; sub foo { my $x = shift; BEGIN { $foo = \\$x }; $$foo }; [ foo(1), foo(2) ];\n","err":"Variable \"$x\" will not stay shared at (eval 558) line 1, <STDIN> line 1.\n","out":"[1,1]"},{"out":"ERROR: Undefined subroutine &main::FOO called at (eval 558) line 1, <STDIN> line 1.\n","err":"Variable \"$x\" will not stay shared at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; our $foo; sub foo { my $x = shift; BEGIN { $foo = \\$x }; ${ &{'FOO'}() } }; [ foo(1), foo(2) ];\n"},{"err":"Ambiguous call resolved as CORE::chomp(), qualify as such or use & at (eval 558) line 1, <STDIN> line 1.\nUse of uninitialized value $_ in scalar chomp at (eval 558) line 1, <STDIN> line 1.\n","out":"[0]","code":"use warnings; sub chomp { \"blah\" }; [ chomp ]\n"},{"err":"Variable \"$x\" will not stay shared at (eval 558) line 1, <STDIN> line 1.\n","out":"[1,1]","code":"use warnings; sub foo { my $x = shift; use constant FOO => \\$x; ${ &{'FOO'}() } }; [ foo(1), foo(2) ];\n"},{"code":"use warnings; sub TIEHANDLE { bless [] }; sub AUTOLOAD { print \"In autoload! $AUTOLOAD\"; 42 }; tie *FH, 'main'; [ print FH 'adfasdf' ];\n","out":"In autoload! main::PRINT","err":""},{"out":"ÃÂ¢ÃÂÃÂ´","err":"","code":"use warnings; sub z { print shift }  z('â´')\n"},{"err":"","out":"","code":"use warnings; sub z { }  z('â´')\n"},{"code":"use warnings; use experimental 'smartmatch'; \"foo\" ~~ \"Bar\"\n","out":"","err":""},{"out":"","err":"","code":"use warnings; use experimental 'smartmatch'; \"foo\" ~~ \"Bar\";\n"},{"code":"use warnings; use experimental 'smartmatch'; \"foo\" ~~ \"Bar\"; \"All ok\"\n","out":"All ok","err":"Useless use of smart match in void context at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"ERROR: Can't use an undefined value as an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n","err":"","code":"use warnings; use strict; use experimental 'postderef'; my $x; my @z = @{ $x || [] }; $x->@*\n"},{"err":"Useless use of a variable in void context at (eval 558) line 1, <STDIN> line 1.\n","out":"ERROR: Can't use an undefined value as an ARRAY reference at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnings; use strict; use experimental 'postderef'; my $x;  @{ $x || [] }; $x->@*\n"},{"err":"","out":"ERROR: Can't locate warnngs.pm:   (null): Too many open files at (eval 558) line 1, <STDIN> line 1.\nBEGIN failed--compilation aborted at (eval 558) line 1, <STDIN> line 1.\n","code":"use warnngs; my $foo = 1; my $foo_bar = 2; \"$foo\\_bar\"\n"},{"code":"; ;;;;;;;;;;;;;;;;;;v\n","out":"v","err":""},{"code":"\"$^V\";\n","err":"","out":"v5.22.1"},{"code":"$V\n","err":"","out":""},{"out":"bless( {qv => 1,original => \"v5.22.1\",version => [5,22,1]}, 'version' )","err":"","code":"$^V\n"},{"code":"$^V;\n","err":"","out":"bless( {qv => 1,version => [5,22,1],original => \"v5.22.1\"}, 'version' )"},{"code":"\"\".(v0.01)\n","out":"\u0000\u0001","err":""},{"out":"\u0000\u0001","err":"","code":"v0.01\n"},{"code":"v0.1\n","out":"\u0000\u0001","err":""},{"code":"$^V^2\n","err":"","out":"ERROR: operation not supported with version object at (eval 558) line 1, <STDIN> line 1.\n"},{"out":"v255","err":"","code":"v.255\n"},{"out":"ÃÂ ÃÂ²ÃÂ _ÃÂ ÃÂ²ÃÂ ","err":"","code":"v3232.95.3232\n"},{"code":"v5\n","out":"\u0005","err":""},{"code":"v5 ^ 2\n","err":"","out":"2"},{"out":"[*DB::args,*DB::sub]","err":"","code":"[values %DB:: ]\n"},{"err":"","out":"blah","code":"$VERSION = 'blah';\n"},{"code":"$w = 3; $h = 4; @out = ( (0) x $w ) x $h; \n","out":"12","err":""},{"code":"$w = 3; $h = 4; @out = ( (0) x $w ) x $h; \\@out\n","out":"[0,0,0,0,0,0,0,0,0,0,0,0]","err":""},{"code":"\"W\\x{200d}â\"\n","out":"WÃÂ¢ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂÃÂ","err":""},{"code":"- - 'x'\n","out":"+x","err":""},{"err":"","out":"-3.32222097054746e-13","code":"$x = 0; for (1..1000) {$x += 0.01;}; for (1..2000) {$x -= 0.005}; $x\n"},{"out":"[undef,undef,1]","err":"","code":"@x = (1, 1, 1); delete @x[@x]; \\@x\n"},{"code":"$x = (1, (2, 3), 5); \n","out":"5","err":""},{"err":"","out":"[undef,undef,3]","code":"@x = (1, 2, 3); delete @x[@x]; \\@x\n"},{"err":"","out":"ÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ","code":"\"\\x{1f31b}\\x{200D}\\x{1f31c}\"\n"},{"code":"\"\\x{1f31b}\\x{200D}\\x{1f51c}\\x{200D}\\x{1f31c}\"\n","out":"ÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ","err":""},{"err":"","out":"ÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ","code":"\"\\x{1f31c}\\x{200D}\\x{1f31b}\"\n"},{"code":"\"\\x{1F466}\\x{200D}\\x{2764}\\x{FE0F}\\x{200D}\\x{1F48B}\\x{200D}\\x{1F468}\"\n","err":"","out":"ÃÂ°ÃÂÃÂÃÂ¦ÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂ¤ÃÂ¯ÃÂ¸ÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ¨"},{"err":"","out":"ÃÂ°ÃÂÃÂÃÂ¨ÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂ¤ÃÂ¯ÃÂ¸ÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ©","code":"\"\\x{1F468}\\x{200D}\\x{2764}\\x{FE0F}\\x{200D}\\x{1F48B}\\x{200D}\\x{1F469}\"\n"},{"code":"\"\\x{1F469}\\x{200D}\\x{2764}\\x{FE0F}\\x{200D}\\x{1F48B}\\x{200D}\\x{1F468}\"\n","err":"","out":"ÃÂ°ÃÂÃÂÃÂ©ÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂ¤ÃÂ¯ÃÂ¸ÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ¨"},{"code":"\"\\x{1F469}\\x{200D}\\x{2764}\\x{FE0F}\\x{200D}\\x{1F48B}\\x{200D}\\x{1F469}\"\n","err":"","out":"ÃÂ°ÃÂÃÂÃÂ©ÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂ¤ÃÂ¯ÃÂ¸ÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ©"},{"code":"\"\\x{1F478}\\x{200D}\\x{1f31b}\"\n","err":"","out":"ÃÂ°ÃÂÃÂÃÂ¸ÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ"},{"code":"\"\\x{1F478}\\x{200D}\\x{2764}\\x{FE0F}\\x{200D}\\x{1F48B}\\x{200D}\\x{1F438}\"\n","err":"","out":"ÃÂ°ÃÂÃÂÃÂ¸ÃÂ¢ÃÂÃÂÃÂ¢ÃÂÃÂ¤ÃÂ¯ÃÂ¸ÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂ°ÃÂÃÂÃÂ¸"},{"out":"ÃÂ°ÃÂÃÂÃÂ©","err":"","code":"\"\\x{1f4a9}\"\n"},{"code":"[\"\\x{1f4a9}\"]\n","err":"","out":"[\"\\x{1f4a9}\"]"},{"err":"","out":"ÃÂ°ÃÂÃÂÃÂ","code":"\"\\x{1f51c}\"\n"},{"code":"@x = (2, 1, 2); delete @x[2, 1, 2]; \n","out":"","err":""},{"err":"","out":"[]","code":"@x = (2, 1, 2); delete @x[2, 1, 2]; \\@a\n"},{"code":"@x = (2, 1, 2); delete @x[2, 1, 2]; \\@x\n","out":"[2]","err":""},{"code":"@x = (2, 1, 2); delete @x[2, 2, 1]; \\@x\n","err":"","out":"[2]"},{"code":"@x = (2, 1, 2); delete @x[@x];\n","out":"","err":""},{"code":"@x = (2, 1, 2); delete @x[~~@x]; \\@x\n","err":"","out":"[2,1,2]"},{"out":"[]","err":"","code":"@x = (2, 1, 2); delete @x[@x]; \\@x\n"},{"err":"","out":"[4,5,6]","code":"@x = (4, 5, 6); delete @x[@x]; \\@x\n"},{"err":"","out":"ÃÂÃÂ","code":"\"\\x{749}\"\n"},{"code":"$x = []; bless $x, []; ref $x\n","err":"","out":"ERROR: Attempt to bless into a reference at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"\"\\x{D000}\"\n","out":"ÃÂ­ÃÂÃÂ","err":""},{"code":"[ 'X' =~ /(?i)x/]\n","err":"","out":"[1]"},{"code":"$_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]{1}(?![A-Z])/)\n","err":"","out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/( <-- HERE [A-Z]{1}(?![A-Z])/ at (eval 558) line 1, <STDIN> line 1.\n"},{"code":"$_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]{1}(?![A-Z]))/)\n","out":"xml_p_arser","err":""},{"err":"","out":"xmlparser","code":"$_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]{1}(?![A-Z]*))/)\n"},{"code":"$_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]{1}[^A-Z]*)/)\n","err":"","out":"x_m_l_parser"},{"err":"","out":"ERROR: Unmatched ( in regex; marked by <-- HERE in m/( <-- HERE [A-Z]+(?=[^A-Z]*)/ at (eval 558) line 1, <STDIN> line 1.\n","code":"$_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]+(?=[^A-Z]*)/)\n"},{"err":"","out":"xmlp_arser","code":"$_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]+(?=[^A-Z]*))/)\n"},{"code":"$_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]+[^A-Z]*)/)\n","out":"xmlparser","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, near \"/([A-Z]{1}(?![A-Z]))/)\"\n","code":"$_ = 'XMLParser'; [split /([A-Z]{1}(?![A-Z]))/)]\n"},{"code":"$_ = 'XMLParser'; [split /([A-Z]{1}(?![A-Z]))/]\n","out":"[\"XML\",\"P\",\"arser\"]","err":""},{"out":"[\"\",\"XMLParser\"]","err":"","code":"$_ = 'XMLParser'; [split /([A-Z]*[^A-Z]*)/]\n"},{"code":"[ 'XX' =~ /(?i)xx/]\n","out":"[1]","err":""},{"err":"","out":"[]","code":"[ 'XX' =~ /((?i)x)x/]\n"},{"code":"'XYXYXYXY foos' =~ s/(XY)*.+\n","err":"","out":"ERROR: Substitution pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n"},{"err":"","out":"XY","code":"'XYXYXYXY foos' =~ s/(XY)+?\\1.+/$1/r\n"},{"code":"'XYXYXYXY foos' =~ s/(XY)+\\1.+/$1/r\n","err":"","out":"XY"},{"out":"","err":"","code":"'XYXYXYXY foos' =~ s/(XY)+?\\1.+//r\n"},{"code":"'XYXYXYXY foos' =~ s/(XY)+\\1.+//r\n","out":"","err":""},{"code":"'XYXYXYXY foos' =~ s/(XY)+\\K\\1.+/$1/r\n","err":"","out":"XYXYXYXY"},{"code":"'XYXYXYXY foos' =~ s/(?:XY)+\\K\\1.+//r\n","out":"ERROR: Reference to nonexistent group in regex; marked by <-- HERE in m/(?:XY)+\\K\\1 <-- HERE .+/ at (eval 558) line 1, <STDIN> line 1.\n","err":""},{"out":"XYXYXY","err":"","code":"'XYXYXYXY foos' =~ s/((?:XY))+\\K\\1.+//r\n"},{"err":"","out":"XYXY","code":"'XYXYXYXY foos' =~ s/((?:XY)+)\\K\\1.+//r\n"},{"err":"","out":"ERROR: Substitution pattern not terminated at (eval 558) line 1, <STDIN> line 1.\n","code":"'XYXYXYXY foos' =~ s/(XY)*XY.+\n"},{"out":"0","err":"","code":"$x * $y // $z\n"},{"err":"","out":"\nERROR: Can't locate object method \"Some\" via package \"may\" (perhaps you forgot to load \"may\"?) at (eval 558) line 1, <STDIN> line 1.\n","code":"You know what I like about perl? It's the fact that this English sentence is perfectly parsable! Some may say: \"no way\", but I got deparse to prove it\n"},{"code":"$Ï = 42; say $Ï\n","err":"","out":"ERROR: Unrecognized character \\x80; marked by <-- HERE after tures/; $ÃÂ<-- HERE near column 93 at (eval 558) line 1, <STDIN> line 1.\n"}]}