Script started on Sun 10 Apr 2016 10:42:24 PM EDT
[1m[3m%[23m[1m[0m                                                                                                                                                                                             k../perlblead-ci\[0m[23m[24m[J[01;32mryan@simcop2387 [34m[10:42:24 PM] [00m[37m[~/workspace/perlblead-ci][00m [32m[master [31m*[32m][00m
[34m->[01;34m %[00m [K[?1h=scriptvim maketests.pl[16Drm typescript   [13Dexit         [9Dtime ./maketests.pl[?1l>
ktime\Postfix dereference is experimental at ./maketests.pl line 32.
evals/evals-freenode-#perl-cats.lst[1]: "0.0"+0 ? 1 : 0
evals/evals-freenode-#perl-cats.lst[2]: "0.0" ? 1 : 0
evals/evals-freenode-#perl-cats.lst[3]: 0.0 ? 1 : 0
evals/evals-freenode-#perl-cats.lst[4]: "0e0"+"0e0" ? 1 : 0
evals/evals-freenode-#perl-cats.lst[5]: "0e0" ? 1 : 0
evals/evals-freenode-#perl-cats.lst[6]: 0e0 ? 1 : 0
evals/evals-freenode-#perl-cats.lst[7]: 0xffff == 0b1111111111111111
evals/evals-freenode-#perl-cats.lst[8]: 1
evals/evals-freenode-#perl-cats.lst[9]: "1"
evals/evals-freenode-#perl-cats.lst[10]: 1/0
evals/evals-freenode-#perl-cats.lst[11]: 1.0 == 3.0/2.999999999999999999999999999999999999999999999
evals/evals-freenode-#perl-cats.lst[12]: 1.0 == 3.0/3.0
evals/evals-freenode-#perl-cats.lst[13]: [20+4]
evals/evals-freenode-#perl-cats.lst[14]: BEGIN { package v5::Please; $INC{'v5/Please.pm'} = 1; sub import { print q[OK] } }; use v5::Please;
evals/evals-freenode-#perl-cats.lst[15]: BEGIN { package v5::Please; $INC{'v5/Please.pm'} = 1; sub import { q[OK] } }; use v5::Please;
evals/evals-freenode-#perl-cats.lst[16]: {foo => 1, foo => 2}
evals/evals-freenode-#perl-cats.lst[17]: gmtime
evals/evals-freenode-#perl-cats.lst[18]: "".gmtime
evals/evals-freenode-#perl-cats.lst[19]: gmtime.""
evals/evals-freenode-#perl-cats.lst[20]: ($inf, $neginf, $nan) = (9**9**9, -9**9**9, -sin(9**9**9))
evals/evals-freenode-#perl-cats.lst[21]: ($inf, $neginf, $nan) = (9**9**9, -9**9**9, -sin(9**9**9)); $nan
evals/evals-freenode-#perl-cats.lst[22]: ($inf, $neginf, $nan) = (9**9**9, -9**9**9, -sin(9**9**9)); use List::Util qw/max/; max(1.0, $nan)
evals/evals-freenode-#perl-cats.lst[23]: ($inf, $neginf, $nan) = (9**9**9, -9**9**9, -sin(9**9**9)); use List::Util qw/max/; max($nan, 1.0)
evals/evals-freenode-#perl-cats.lst[24]: length "America/Argentina/Buenos_Aires"
evals/evals-freenode-#perl-cats.lst[25]: length qq{{"customer_id":114631,"survey_id":485,"ttl":10}};
evals/evals-freenode-#perl-cats.lst[26]: length "\t->alloc called: 12345678 12345678 12345 12345"
evals/evals-freenode-#perl-cats.lst[27]: localtime
evals/evals-freenode-#perl-cats.lst[28]: localtime . ""
evals/evals-freenode-#perl-cats.lst[29]: my $a = [0]; sub foo {my $b = shift; return \$b->[0]}; foo $a
evals/evals-freenode-#perl-cats.lst[30]: my $a = [0]; sub foo {my $b = shift; return \$b->[0]}; ${foo $a} = 1; $a
evals/evals-freenode-#perl-cats.lst[31]: my @a = qw/a 1 b 2 c 3/; ${@a}->{a};
evals/evals-freenode-#perl-cats.lst[32]: my @a = qw/a 1 b 2 c 3/; {@A}->{a}
evals/evals-freenode-#perl-cats.lst[33]: my @a = qw/a 1 b 2 c 3/; {+@A}->{a}
evals/evals-freenode-#perl-cats.lst[34]: my @a = qw/a 1 b 2 c 3/; ${+@A}{a}
evals/evals-freenode-#perl-cats.lst[35]: my @a = qw/a 1 b 2 c 3/; my $h = {@a}; $h
evals/evals-freenode-#perl-cats.lst[36]: my @a = qw/a 1 b 2 c 3/; my $h = {@A}; $h
evals/evals-freenode-#perl-cats.lst[37]: my $b = []; $a = \$b;  $$a = []; $a = $$a; $a = []; $b
evals/evals-freenode-#perl-cats.lst[38]: my($this)=qw(viogel$pviT$vilxsre$xwyN); my(@arr)=split(//,$this);  foreach(reverse(@arr)){ print(chr(ord($_)-(1<<2))); } print "\n";
evals/evals-freenode-#perl-cats.lst[39]: "\N{NEL}"
evals/evals-freenode-#perl-cats.lst[40]: "\N{PILE OF POO}"
evals/evals-freenode-#perl-cats.lst[41]: "\N{SNOWMAN}"
evals/evals-freenode-#perl-cats.lst[42]: pi
evals/evals-freenode-#perl-cats.lst[43]: print "foo" if (+{});
evals/evals-freenode-#perl-cats.lst[44]: print "foo" if (keys %{+{}});
evals/evals-freenode-#perl-cats.lst[45]: print q;This is a test;;
evals/evals-freenode-#perl-cats.lst[46]: [quotemeta "\n"]
evals/evals-freenode-#perl-cats.lst[47]: quotemeta "\n"
evals/evals-freenode-#perl-cats.lst[48]: [quotemeta "\n" =~ s/\\\n/\n/gr]
evals/evals-freenode-#perl-cats.lst[49]: sprintf "%08b", 015  # dick
evals/evals-freenode-#perl-cats.lst[50]: sprintf('0x%x', 0b1111111111111111)
evals/evals-freenode-#perl-cats.lst[51]: sprintf "%8b", 015
evals/evals-freenode-#perl-cats.lst[52]: sub AUTOLOAD {Dumper(\@_, $AUTOLOAD)}; my $foo = "boo"; __PACKAGE__->$foo
evals/evals-freenode-#perl-cats.lst[53]: sub AUTOLOAD {Dumper(\@_, $AUTOLOAD}; my $foo = "boo"; __PACKAGE__->$foo
evals/evals-freenode-#perl-cats.lst[54]: sub AUTOLOAD {Dumper(\@_, $AUTOLOAD)}; my $foo = ""; __PACKAGE__->""
evals/evals-freenode-#perl-cats.lst[55]: sub AUTOLOAD {Dumper(\@_, $AUTOLOAD)}; my $foo = ""; __PACKAGE__->("foo")
evals/evals-freenode-#perl-cats.lst[56]: sub AUTOLOAD {Dumper(\@_, $AUTOLOAD)}; my $foo = ""; __PACKAGE__->$foo
evals/evals-freenode-#perl-cats.lst[57]: sub AUTOLOAD {Dumper@_}; my $foo = "boo"; __PACKAGE__->$foo
evals/evals-freenode-#perl-cats.lst[58]: sub AUTOLOAD {Dumper@_}; my $foo = ""; __PACKAGE__->$foo
evals/evals-freenode-#perl-cats.lst[59]: $^T
evals/evals-freenode-#perl-cats.lst[60]: [$^T, time]
evals/evals-freenode-#perl-cats.lst[61]: use CGI;
evals/evals-freenode-#perl-cats.lst[62]: use experimental 'signature';
evals/evals-freenode-#perl-cats.lst[63]: use experimental 'signatures';
evals/evals-freenode-#perl-cats.lst[64]: use experimental 'signatures'; sub foo($bar) {print $bar, $bar}; foo("hola hoops ");
evals/evals-freenode-#perl-cats.lst[65]: use JSON::MaybeXS; JSON->decode(q/{"foo": undefined, "bar": null}/)
evals/evals-freenode-#perl-cats.lst[66]: use JSON::MaybeXS; JSON->new()->decode(q/{"foo": undefined, "bar": null}/)
evals/evals-freenode-#perl-cats.lst[67]: use strict; my @foo; my $x = $foo[1];
evals/evals-freenode-#perl-cats.lst[68]: use strict; use warnings; my @x; $x['bar'] = 1; [@x]
evals/evals-freenode-#perl-cats.lst[69]: use utf8; *";" = {"Hello World"};
evals/evals-freenode-#perl-cats.lst[70]: use utf8; my $😫="hi";
evals/evals-freenode-#perl-cats.lst[71]: use utf8; print q;This is a test;;
evals/evals-freenode-#perl-cats.lst[72]: use utf8; *; = sub {"Hello World"};
evals/evals-freenode-#perl-cats.lst[73]: use utf8; sub ; {"Hello World"};
evals/evals-freenode-#perl-cats.lst[74]: $^V
evals/evals-freenode-#perl-cats.lst[75]: $^V - 10
evals/evals-freenode-#perl-cats.lst[76]: "√-\x{0305}1 2³ ∑π and it was really strange"
evals/evals-freenode-#perl-cats.lst[77]: "√-\x{0305}1\x{0305} 2³ ∑π and it was really strange"
evals/evals-freenode-#perl-cats.lst[78]: "√-\x{035E}1 2³ ∑π and it was really strange"
evals/evals-freenode-#perl-cats.lst[79]: "√-\x035E1 2³ ∑π and it was really strange"
evals/evals-freenode-#perl-cats.lst[80]: "√-\x{203E}1 2³ ∑π and it was really strange"
evals/evals-freenode-#perl-cats.lst[81]: "√\x{2212}\x{0305}1\x{0305} 2³ ∑π and it was really strange"
evals/evals-freenode-#perl-cats.lst[82]: "\x85"
evals/evals-freenode-#perl.lst[1]: ~-~()
evals/evals-freenode-#perl.lst[2]:  [ "(" =~ /[(]/ ]
evals/evals-freenode-#perl.lst[3]:  [ "]" =~ /[\]]/ ]
evals/evals-freenode-#perl.lst[4]: - - _
evals/evals-freenode-#perl.lst[5]: - '-'
evals/evals-freenode-#perl.lst[6]: -(''.{})
evals/evals-freenode-#perl.lst[7]: -{}
evals/evals-freenode-#perl.lst[8]: ;;
evals/evals-freenode-#perl.lst[9]: :)
evals/evals-freenode-#perl.lst[10]: ?
evals/evals-freenode-#perl.lst[11]: ?^?
evals/evals-freenode-#perl.lst[12]: /^+/
evals/evals-freenode-#perl.lst[13]: /[^]]/
evals/evals-freenode-#perl.lst[14]: /[/
evals/evals-freenode-#perl.lst[15]: /${#}/
evals/evals-freenode-#perl.lst[16]: /$#/
evals/evals-freenode-#perl.lst[17]: /$#//
evals/evals-freenode-#perl.lst[18]: /**/
evals/evals-freenode-#perl.lst[19]: ...
evals/evals-freenode-#perl.lst[20]: '^\/\/'
evals/evals-freenode-#perl.lst[21]: '=' =~ /=/
evals/evals-freenode-#perl.lst[22]: ''
evals/evals-freenode-#perl.lst[23]: ''.[]
evals/evals-freenode-#perl.lst[24]: '@' ^ '$'
evals/evals-freenode-#perl.lst[25]: "
evals/evals-freenode-#perl.lst[26]: "'" =~ /'/
evals/evals-freenode-#perl.lst[27]: "" . \ ""
evals/evals-freenode-#perl.lst[28]: "" . \ "" . \ ""
evals/evals-freenode-#perl.lst[29]: "" . \\ ""
evals/evals-freenode-#perl.lst[30]: ""->()
evals/evals-freenode-#perl.lst[31]: "[" =~ /[[]/
evals/evals-freenode-#perl.lst[32]: "$_"
evals/evals-freenode-#perl.lst[33]: "$( $)"
evals/evals-freenode-#perl.lst[34]: "${}"
evals/evals-freenode-#perl.lst[35]: "\"
evals/evals-freenode-#perl.lst[36]: "\["
evals/evals-freenode-#perl.lst[37]: "❇"
evals/evals-freenode-#perl.lst[38]: "ほげ"
evals/evals-freenode-#perl.lst[39]: ();
evals/evals-freenode-#perl.lst[40]: [~~( )]
evals/evals-freenode-#perl.lst[41]: [ !() ]
evals/evals-freenode-#perl.lst[42]: [ @_ ]
evals/evals-freenode-#perl.lst[43]: [ $| ]
evals/evals-freenode-#perl.lst[44]: [ $$ ]
evals/evals-freenode-#perl.lst[45]: [ $$$ ]
evals/evals-freenode-#perl.lst[46]: [ ⓴ ]
evals/evals-freenode-#perl.lst[47]: ['
evals/evals-freenode-#perl.lst[48]: ['']
evals/evals-freenode-#perl.lst[49]: [""]
evals/evals-freenode-#perl.lst[50]: []
evals/evals-freenode-#perl.lst[51]: [] == []
evals/evals-freenode-#perl.lst[52]: []->$#*
evals/evals-freenode-#perl.lst[53]: [{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',]
evals/evals-freenode-#perl.lst[54]: [@_]
evals/evals-freenode-#perl.lst[55]: [$|--, $|--, $|--, $|--]
evals/evals-freenode-#perl.lst[56]: [$_]
evals/evals-freenode-#perl.lst[57]: [$,, $;]
evals/evals-freenode-#perl.lst[58]: [$;]
evals/evals-freenode-#perl.lst[59]: [$"]
evals/evals-freenode-#perl.lst[60]: [$[]
evals/evals-freenode-#perl.lst[61]: [$@]
evals/evals-freenode-#perl.lst[62]: [++$|, ++$|, --$|, --$|]
evals/evals-freenode-#perl.lst[63]: [++$|, ++$|]
evals/evals-freenode-#perl.lst[64]: [++$|; ++$|]
evals/evals-freenode-#perl.lst[65]: {;} + {}
evals/evals-freenode-#perl.lst[66]: {} {}
evals/evals-freenode-#perl.lst[67]: {} + {}
evals/evals-freenode-#perl.lst[68]: @_
evals/evals-freenode-#perl.lst[69]: @{ [] } // []
evals/evals-freenode-#perl.lst[70]: @{[]}=()
evals/evals-freenode-#perl.lst[71]: @#
evals/evals-freenode-#perl.lst[72]: @#{ [] }
evals/evals-freenode-#perl.lst[73]: $
evals/evals-freenode-#perl.lst[74]: $^_^$;;
evals/evals-freenode-#perl.lst[75]: $_ = '
evals/evals-freenode-#perl.lst[76]: $;
evals/evals-freenode-#perl.lst[77]: $!
evals/evals-freenode-#perl.lst[78]: $!->()
evals/evals-freenode-#perl.lst[79]: $?
evals/evals-freenode-#perl.lst[80]: $"
evals/evals-freenode-#perl.lst[81]: $";
evals/evals-freenode-#perl.lst[82]: $[++
evals/evals-freenode-#perl.lst[83]: $]
evals/evals-freenode-#perl.lst[84]: $@
evals/evals-freenode-#perl.lst[85]: $$
evals/evals-freenode-#perl.lst[86]: $#
evals/evals-freenode-#perl.lst[87]: $%
evals/evals-freenode-#perl.lst[88]: *_
evals/evals-freenode-#perl.lst[89]: *{""}
evals/evals-freenode-#perl.lst[90]: *{}
evals/evals-freenode-#perl.lst[91]: \[]->[[]]
evals/evals-freenode-#perl.lst[92]: \{}
evals/evals-freenode-#perl.lst[93]: \@_
evals/evals-freenode-#perl.lst[94]: \@.
evals/evals-freenode-#perl.lst[95]: \$_
evals/evals-freenode-#perl.lst[96]: \%::
evals/evals-freenode-#perl.lst[97]: ∞
evals/evals-freenode-#perl.lst[98]: ~0
evals/evals-freenode-#perl.lst[99]: !0
evals/evals-freenode-#perl.lst[100]: !!0
evals/evals-freenode-#perl.lst[101]: "\0"
evals/evals-freenode-#perl.lst[102]: [~~"0"]
evals/evals-freenode-#perl.lst[103]: [~0]
evals/evals-freenode-#perl.lst[104]: [ !!0 ]
evals/evals-freenode-#perl.lst[105]: [ "".{}, 0+{} ]
evals/evals-freenode-#perl.lst[106]: [ ""{}, 0+{} ]
evals/evals-freenode-#perl.lst[107]: [ 0 + '⓴' ]
evals/evals-freenode-#perl.lst[108]: [ 0 + $!, "$!" ]
evals/evals-freenode-#perl.lst[109]: [!!"0"]
evals/evals-freenode-#perl.lst[110]: ['0' .. ':']
evals/evals-freenode-#perl.lst[111]: ["\0"]
evals/evals-freenode-#perl.lst[112]: [] + 0
evals/evals-freenode-#perl.lst[113]: []+0
evals/evals-freenode-#perl.lst[114]: $0
evals/evals-freenode-#perl.lst[115]: $_ = '0'; $_++; $_
evals/evals-freenode-#perl.lst[116]: $_[0]
evals/evals-freenode-#perl.lst[117]: \0
evals/evals-freenode-#perl.lst[118]: 0!
evals/evals-freenode-#perl.lst[119]: 0+[]
evals/evals-freenode-#perl.lst[120]: 0+{}
evals/evals-freenode-#perl.lst[121]: !!'0.0'
evals/evals-freenode-#perl.lst[122]: "" . \ 0 . \ 0
evals/evals-freenode-#perl.lst[123]: [ (!!0) + 0 ]
evals/evals-freenode-#perl.lst[124]: [(0 ** 0)]
evals/evals-freenode-#perl.lst[125]: $0->[0]
evals/evals-freenode-#perl.lst[126]: 0 ^ 0
evals/evals-freenode-#perl.lst[127]: 0 == 0
evals/evals-freenode-#perl.lst[128]: 0->[0]
evals/evals-freenode-#perl.lst[129]: 0/0
evals/evals-freenode-#perl.lst[130]: 0**0
evals/evals-freenode-#perl.lst[131]: 0+ ½
evals/evals-freenode-#perl.lst[132]: 0+'½'
evals/evals-freenode-#perl.lst[133]: $_ = '000'; $_++; $_
evals/evals-freenode-#perl.lst[134]: &{0 == &{0 == 0}} * 0
evals/evals-freenode-#perl.lst[135]: "000000" && "foo";
evals/evals-freenode-#perl.lst[136]: [ 0.00_02 ]
evals/evals-freenode-#perl.lst[137]: ["0.00_02" + 0]
evals/evals-freenode-#perl.lst[138]: '000202056D4C' =~ s/..\K\B/:/gr
evals/evals-freenode-#perl.lst[139]: 0+!! 0==1
evals/evals-freenode-#perl.lst[140]: (001234 ^ 01234) =~ /(^\0*)/; length $1
evals/evals-freenode-#perl.lst[141]: 0+!!(0==1) # what I probably meant
evals/evals-freenode-#perl.lst[142]: '008' == 8
evals/evals-freenode-#perl.lst[143]: [ ~0, ~0 =~ s/(?=(\d{3})+$)/,/gr ]
evals/evals-freenode-#perl.lst[144]: "00" ? "true" : "false";
evals/evals-freenode-#perl.lst[145]: $_ = "\0\0"; vec($_, 7, 1)=1; [unpack "s>", $_]
evals/evals-freenode-#perl.lst[146]: [ 0 & 0xFF, 0 >> 8 & 0xFF ]
evals/evals-freenode-#perl.lst[147]: ~0 + 1
evals/evals-freenode-#perl.lst[148]: "0" | "1"
evals/evals-freenode-#perl.lst[149]: [0,1]
evals/evals-freenode-#perl.lst[150]: $< = $$ ? 0+<=><=><=>:+1
evals/evals-freenode-#perl.lst[151]: $_ = '0.1'; $_++; $_
evals/evals-freenode-#perl.lst[152]: 0/1
evals/evals-freenode-#perl.lst[153]: ~0 + 1 > ~0
evals/evals-freenode-#perl.lst[154]: [0?1:0,0e0?1:0]
evals/evals-freenode-#perl.lst[155]: [0?1:0,0E0?1:0]
evals/evals-freenode-#perl.lst[156]: [0, '1'] ~~ [0, 1]
evals/evals-freenode-#perl.lst[157]: "010" ~~ [ 10 ]
evals/evals-freenode-#perl.lst[158]: [ 0.1 + 0.2, ((0.1 + 0.2) == 0.3) ? 'y' : 'n' ] #weird
evals/evals-freenode-#perl.lst[159]: (("010"+2)/(010+2))*5
evals/evals-freenode-#perl.lst[160]: 0.1 + 0.2 - 0.3
evals/evals-freenode-#perl.lst[161]: ~0 + 1 == ~0 ? 64 : 32
evals/evals-freenode-#perl.lst[162]: 0 + "1+1"
evals/evals-freenode-#perl.lst[163]: [ "01101000 01100101 01101100 01110000" =~ /\d+/g ]; ### ZoffixWeb, why does it return an array when \d+ isn't in a capture group?
evals/evals-freenode-#perl.lst[164]: "011112233" =~ /^0[0-9]*\s*\z/
evals/evals-freenode-#perl.lst[165]: 01.23
evals/evals-freenode-#perl.lst[166]: 01.23 >= 2.34 ? "greater or equal" : "nope"
evals/evals-freenode-#perl.lst[167]: "0123456" ~~ 123_456
evals/evals-freenode-#perl.lst[168]: '01234567891b' =~ s/(..)(?!$)/$1:/gr
evals/evals-freenode-#perl.lst[169]: '01234567891b' =~ s/..\K\B/:/gr
evals/evals-freenode-#perl.lst[170]: [ "-0123456789abcdefghi" =~ /[[:xdigit:]]/g ]
evals/evals-freenode-#perl.lst[171]: $_ = "\0\1\2"; s/([\x00-\x1f])/"\x{2400}" | $1/eg; $_
evals/evals-freenode-#perl.lst[172]: $_ = "\0\1\2"; s/([\x00-\x1f])/"\x{2400}" | $1/eg; \$_
evals/evals-freenode-#perl.lst[173]: "0" | "1.5"
evals/evals-freenode-#perl.lst[174]: [ 0 .. 15 ]
evals/evals-freenode-#perl.lst[175]: ["0" | "1.5"]
evals/evals-freenode-#perl.lst[176]: (0)*150
evals/evals-freenode-#perl.lst[177]: 01777
evals/evals-freenode-#perl.lst[178]: [ ¡!0, ¡!1 ] # this might not "work", for example
evals/evals-freenode-#perl.lst[179]: ~0 + 2
evals/evals-freenode-#perl.lst[180]: $#{[0..2]}
evals/evals-freenode-#perl.lst[181]: ~0 * 2 > ~0
evals/evals-freenode-#perl.lst[182]: 02/03/04
evals/evals-freenode-#perl.lst[183]: [@{[0 .. 20]}[5,10,3]]
evals/evals-freenode-#perl.lst[184]: [ 021, 017, 015, 013, 011, eval "09" || $@ ]
evals/evals-freenode-#perl.lst[185]: 025
evals/evals-freenode-#perl.lst[186]: 0 % -3
evals/evals-freenode-#perl.lst[187]: [ 0302, 0255 ]
evals/evals-freenode-#perl.lst[188]: 031
evals/evals-freenode-#perl.lst[189]: [0320, 0230]
evals/evals-freenode-#perl.lst[190]: "\034"
evals/evals-freenode-#perl.lst[191]: 0377
evals/evals-freenode-#perl.lst[192]: '03' lt '7'
evals/evals-freenode-#perl.lst[193]: $$[0]=3; print @$
evals/evals-freenode-#perl.lst[194]: [0 .. 4]
evals/evals-freenode-#perl.lst[195]: [ 0 || 42 ]
evals/evals-freenode-#perl.lst[196]: 0 // 42
evals/evals-freenode-#perl.lst[197]: 0444
evals/evals-freenode-#perl.lst[198]: 0.45
evals/evals-freenode-#perl.lst[199]: [ 0.5, 0 .5, 0 . 5 ]
evals/evals-freenode-#perl.lst[200]: [ 0.5, 0. 5, 0 .5, 0 . 5 ]
evals/evals-freenode-#perl.lst[201]: [0.6 + 0.04, 0.64 + 0.04, 0.68 + 0.04]
evals/evals-freenode-#perl.lst[202]: 0734
evals/evals-freenode-#perl.lst[203]: !! "0/8"
evals/evals-freenode-#perl.lst[204]: 0+'    9'
evals/evals-freenode-#perl.lst[205]: 0.99999999999929
evals/evals-freenode-#perl.lst[206]: 0.9999999999999
evals/evals-freenode-#perl.lst[207]: 0.99999999999999
evals/evals-freenode-#perl.lst[208]: 0.9999999999999901
evals/evals-freenode-#perl.lst[209]: 0.9999999999999901 > 0.99999999999999
evals/evals-freenode-#perl.lst[210]: 0.9999999999999902 > 0.99999999999999
evals/evals-freenode-#perl.lst[211]: 0.9999999999999919 > 0.9999999999999918
evals/evals-freenode-#perl.lst[212]: $_ = "0.9999999999999926"; sprintf '%.*f', length, $_
evals/evals-freenode-#perl.lst[213]: $_ = "0.9999999999999927"; sprintf '%.*f', length, $_
evals/evals-freenode-#perl.lst[214]: [ 0.999999999999999 == 1, 0.9999999999999999 == 1]
evals/evals-freenode-#perl.lst[215]: 0b1_10010010
evals/evals-freenode-#perl.lst[216]: 0b111 >> 1
evals/evals-freenode-#perl.lst[217]: 0b11111
evals/evals-freenode-#perl.lst[218]: [ 0b11111, oct("31") ]
evals/evals-freenode-#perl.lst[219]: 0bPortalMeme
evals/evals-freenode-#perl.lst[220]: "0 but true" + 1
evals/evals-freenode-#perl.lst[221]: '0 but true' ? 'true' : 'false'
evals/evals-freenode-#perl.lst[222]: '0BZMNDSFZNQOBNDOFGSN1SFZ!' =~ tr/\"-;N-ZA-M/A-Z a-z/r
evals/evals-freenode-#perl.lst[223]: '0BZMNDSFZNQOBNDOFGSN1SFZ!' =~ tr/\"-;N-ZA-M/A-Z a-z/r;
evals/evals-freenode-#perl.lst[224]: 0E0 eq 0
evals/evals-freenode-#perl.lst[225]: '0e0' ? 'true' : 'false'
evals/evals-freenode-#perl.lst[226]: "0e0" ? "true" : "false"
evals/evals-freenode-#perl.lst[227]: 0e0 ? 'true' :'false'
evals/evals-freenode-#perl.lst[228]: 0e0 ? "true" : "false"
evals/evals-freenode-#perl.lst[229]: '0' && 'foo'
evals/evals-freenode-#perl.lst[230]: 0 if 1
evals/evals-freenode-#perl.lst[231]: 0+keys %INC
evals/evals-freenode-#perl.lst[232]: 0=~m{}=~y///d
evals/evals-freenode-#perl.lst[233]: 0o734
evals/evals-freenode-#perl.lst[234]: 0;qq{@{sub{]]}}}}}
evals/evals-freenode-#perl.lst[235]: ["\0" ? "T" : "F"]
evals/evals-freenode-#perl.lst[236]: [ 0?'t':'f', 00?'t':'f' ]
evals/evals-freenode-#perl.lst[237]: [ 0 == true ]
evals/evals-freenode-#perl.lst[238]: 0 ? 'true' : 'false'
evals/evals-freenode-#perl.lst[239]: [ (0 == true) ? "true" : "false ];
evals/evals-freenode-#perl.lst[240]: [ (0 == true) ? "true" : "false" ];
evals/evals-freenode-#perl.lst[241]: "0" == undef
evals/evals-freenode-#perl.lst[242]: [ !!0, !!"", !!undef ]
evals/evals-freenode-#perl.lst[243]: $_[ ~0 ] = undef
evals/evals-freenode-#perl.lst[244]: 0 == undef
evals/evals-freenode-#perl.lst[245]: [ !0, !'', !undef, !'0' ]
evals/evals-freenode-#perl.lst[246]: '<0x000D>' =~ s/<0x(....)>/"\N{U+$1}"/er
evals/evals-freenode-#perl.lst[247]: "<0x000D>" =~ s/<(0x[[:xdigit:]]{4})>/chr hex $1/ger
evals/evals-freenode-#perl.lst[248]: "<0x0034>" =~ s/<(0x[[:xdigit:]]{4})>/chr hex $1/ger
evals/evals-freenode-#perl.lst[249]: 0x00FF
evals/evals-freenode-#perl.lst[250]: 0x011b;
evals/evals-freenode-#perl.lst[251]: 0x03 & 0x07f
evals/evals-freenode-#perl.lst[252]: 0x0x0x0
evals/evals-freenode-#perl.lst[253]: "0x10" + 0
evals/evals-freenode-#perl.lst[254]: [0x110000, 2**20 + 2**16]
evals/evals-freenode-#perl.lst[255]: 0x1.23
evals/evals-freenode-#perl.lst[256]: 0x123abc
evals/evals-freenode-#perl.lst[257]: 0x1.23p0
evals/evals-freenode-#perl.lst[258]: 0x1252
evals/evals-freenode-#perl.lst[259]: 0x173
evals/evals-freenode-#perl.lst[260]: [0x173, unpack("n", "\x01\x73"), unpack("v", "\x73\x01")]
evals/evals-freenode-#perl.lst[261]: [0x18, 0x12]
evals/evals-freenode-#perl.lst[262]: 0x1a
evals/evals-freenode-#perl.lst[263]: 0x1p-10
evals/evals-freenode-#perl.lst[264]: '<0x2004>' =~ s/<0x(....)>/"\N{U+$1}"/er
evals/evals-freenode-#perl.lst[265]: 0x33 & 0x7f
evals/evals-freenode-#perl.lst[266]: 0x3b1
evals/evals-freenode-#perl.lst[267]: 0x4
evals/evals-freenode-#perl.lst[268]: 0x4000
evals/evals-freenode-#perl.lst[269]: "0x4000"
evals/evals-freenode-#perl.lst[270]: 0x41
evals/evals-freenode-#perl.lst[271]: 0x4x0
evals/evals-freenode-#perl.lst[272]: 0x61 & 0x31
evals/evals-freenode-#perl.lst[273]: [0x7200, 0x720000]
evals/evals-freenode-#perl.lst[274]: 0xC0 & 0x7f
evals/evals-freenode-#perl.lst[275]: [0xc3, 0xa8]
evals/evals-freenode-#perl.lst[276]: 0xcfedde
evals/evals-freenode-#perl.lst[277]: 0xCFEDDE
evals/evals-freenode-#perl.lst[278]: 0xDFEDDE
evals/evals-freenode-#perl.lst[279]: 0xFF
evals/evals-freenode-#perl.lst[280]: 0xFF & 0x07F
evals/evals-freenode-#perl.lst[281]: 0xffff**3
evals/evals-freenode-#perl.lst[282]: 0 xor 0
evals/evals-freenode-#perl.lst[283]: [ [0 xor 0], [1 xor 0], [0 xor 1], [1 xor 1] ]
evals/evals-freenode-#perl.lst[284]: [ 0 xor 0, 1 xor 0, 0 xor 1, 1 xor 1 ]
evals/evals-freenode-#perl.lst[285]: 0 xor 1
evals/evals-freenode-#perl.lst[286]: 0xpink_mist
evals/evals-freenode-#perl.lst[287]: !0=~y///d
evals/evals-freenode-#perl.lst[288]: 1
evals/evals-freenode-#perl.lst[289]: ~1
evals/evals-freenode-#perl.lst[290]: /(?(1)/
evals/evals-freenode-#perl.lst[291]: '' . \1
evals/evals-freenode-#perl.lst[292]: "1"
evals/evals-freenode-#perl.lst[293]: [] != -1
evals/evals-freenode-#perl.lst[294]: $ = 1; ++$
evals/evals-freenode-#perl.lst[295]: $[ = 1
evals/evals-freenode-#perl.lst[296]: 1;
evals/evals-freenode-#perl.lst[297]: 1++
evals/evals-freenode-#perl.lst[298]: 10
evals/evals-freenode-#perl.lst[299]: -1%~0
evals/evals-freenode-#perl.lst[300]: '1' ^ '0'
evals/evals-freenode-#perl.lst[301]: 1/0
evals/evals-freenode-#perl.lst[302]: [ '1' + 0 ^ '0' ]
evals/evals-freenode-#perl.lst[303]: 100.
evals/evals-freenode-#perl.lst[304]: 100/0.0000003
evals/evals-freenode-#perl.lst[305]: 100 * 10000000
evals/evals-freenode-#perl.lst[306]: 100./ 100./5
evals/evals-freenode-#perl.lst[307]: 100. / 4
evals/evals-freenode-#perl.lst[308]: 10 ** 0.5
evals/evals-freenode-#perl.lst[309]: [ "100.5" =~ /([-+]?\d+)(\.\d+)?\s*(g|mg)/ ]
evals/evals-freenode-#perl.lst[310]: [ "100.5 g" =~ /([-+]?\d+)(\.\d+)?\s*(g|mg)/ ]
evals/evals-freenode-#perl.lst[311]: "100.5 g" =~ /([-+]?\d+)(\.\d+)?\s*(g|mg)/; [$1, $2, $3]
evals/evals-freenode-#perl.lst[312]: [ !1, !0, !1+0]
evals/evals-freenode-#perl.lst[313]: [ "1.0" != 1.0, "1.0" ne 1.0 ]
evals/evals-freenode-#perl.lst[314]: '10/10/2010' =~ m[(\d\d)/(\d\d)/(\d\d\d\d)]; my $age = DateTime->new(year => $3, month => $2, day => $1)->delta_md(DateTime->now())->years;
evals/evals-freenode-#perl.lst[315]: 10.123
evals/evals-freenode-#perl.lst[316]: 101.97.114
evals/evals-freenode-#perl.lst[317]: 102.0.114.0.111.0.109
evals/evals-freenode-#perl.lst[318]: 1.0/2 + 1/4 + 1/8 + 2/16
evals/evals-freenode-#perl.lst[319]: 1024 >> 6
evals/evals-freenode-#perl.lst[320]: 1.0 == 3.0/2.9999999999999999999999999999999999
evals/evals-freenode-#perl.lst[321]: (1 == 0) + 5
evals/evals-freenode-#perl.lst[322]: 10/7
evals/evals-freenode-#perl.lst[323]: 1 - 0.99999999999903
evals/evals-freenode-#perl.lst[324]: 10e30
evals/evals-freenode-#perl.lst[325]: 10^length q|*******|
evals/evals-freenode-#perl.lst[326]: $. = 10; my ($what_you_think, $what_it_is) = ($.++,$.); [ $what_you_think, $what_it_is ]
evals/evals-freenode-#perl.lst[327]: 1/(0*nan/nan)
evals/evals-freenode-#perl.lst[328]: '10%s' % 2
evals/evals-freenode-#perl.lst[329]: '10%s' % 3
evals/evals-freenode-#perl.lst[330]: $. = 10; scalar($.++,$.)
evals/evals-freenode-#perl.lst[331]: $. = 10; [ [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ] ];
evals/evals-freenode-#perl.lst[332]: $. = 10; [ [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ] ]
evals/evals-freenode-#perl.lst[333]: $. = 10; while (10..15) { print "$. "; $.++ }
evals/evals-freenode-#perl.lst[334]: $. = 10; while (10..20) { print "$. "; $.++ }
evals/evals-freenode-#perl.lst[335]: -1 >> 1
evals/evals-freenode-#perl.lst[336]: [ 1 == "1" ]
evals/evals-freenode-#perl.lst[337]: [1.1]
evals/evals-freenode-#perl.lst[338]: $1$1
evals/evals-freenode-#perl.lst[339]: 1 ~~ '1'
evals/evals-freenode-#perl.lst[340]: 1+1
evals/evals-freenode-#perl.lst[341]: 1+'1'
evals/evals-freenode-#perl.lst[342]: [ (!!1) . '', (!!1) + 0 ]
evals/evals-freenode-#perl.lst[343]: [() = (1..10)]
evals/evals-freenode-#perl.lst[344]: [1 .. 10]
evals/evals-freenode-#perl.lst[345]: 1/11
evals/evals-freenode-#perl.lst[346]: [ 1 | 1, 1 | 0, 0 | 1, 0 | 0 ]
evals/evals-freenode-#perl.lst[347]: "111" >> 1
evals/evals-freenode-#perl.lst[348]: 1111111 =~ /^(1{1,10})(1{1,10})(1{1,10})$(?{ push @comb, [$1, $2, $3] })(?!)/; [map [map length, @$_], @comb]
evals/evals-freenode-#perl.lst[349]: "111" >> 2
evals/evals-freenode-#perl.lst[350]: [ (1,1,(),((1,2),,,,,,,3)) ]
evals/evals-freenode-#perl.lst[351]: 11/13
evals/evals-freenode-#perl.lst[352]: 11/15;
evals/evals-freenode-#perl.lst[353]: "111" << 8
evals/evals-freenode-#perl.lst[354]: "111" >> 8
evals/evals-freenode-#perl.lst[355]: [ 1 << 1, 2 << 1, 3 << 1 ]
evals/evals-freenode-#perl.lst[356]: "1122" =~ s/\d\d(\d\d)??//r #let's try
evals/evals-freenode-#perl.lst[357]: "1122" =~ s/\d\d(\d\d)?//r #no, it's greedy, Iota
evals/evals-freenode-#perl.lst[358]: $[ = -1; (1, 2, 3)[-2]
evals/evals-freenode-#perl.lst[359]: -1 & 127 # piko` - at a guess you're just getting this, and perldoc -f system covers it
evals/evals-freenode-#perl.lst[360]: { 1+1 => 2, cats => 'dogs' }
evals/evals-freenode-#perl.lst[361]: +{ 1+1 => 2, cats => 'dogs' }
evals/evals-freenode-#perl.lst[362]: 1/1.3
evals/evals-freenode-#perl.lst[363]: 1.139999999999999
evals/evals-freenode-#perl.lst[364]: 1 << 14
evals/evals-freenode-#perl.lst[365]: '11' lt '7'
evals/evals-freenode-#perl.lst[366]: [-1 .. -2]
evals/evals-freenode-#perl.lst[367]: [1,,,,,,2,,,,,,,]
evals/evals-freenode-#perl.lst[368]: 1 + 2
evals/evals-freenode-#perl.lst[369]: 1+2
evals/evals-freenode-#perl.lst[370]: { 1 => [21] }
evals/evals-freenode-#perl.lst[371]: 1/2 + 1/4 + 1/8 + 2/16
evals/evals-freenode-#perl.lst[372]: 1./2 + 1/4 + 1/8 + 2/16
evals/evals-freenode-#perl.lst[373]: '12' =~ /1\B2/ ? 'match' : 'nope'
evals/evals-freenode-#perl.lst[374]: [1<=>2, 2<=>2, 3<=>2]
evals/evals-freenode-#perl.lst[375]: [ "1.22.333.4" =~ /\d+/g ]
evals/evals-freenode-#perl.lst[376]: ~~1.23
evals/evals-freenode-#perl.lst[377]: .1 + .2 - .3
evals/evals-freenode-#perl.lst[378]: .1+.2-.3
evals/evals-freenode-#perl.lst[379]: (.1 + .2 == .3)
evals/evals-freenode-#perl.lst[380]: (1, 2, 3)
evals/evals-freenode-#perl.lst[381]: (1+2==3)
evals/evals-freenode-#perl.lst[382]: [ , 1 , 2 , 3 ]
evals/evals-freenode-#perl.lst[383]: [ \(1, 2, 3) ]
evals/evals-freenode-#perl.lst[384]: [ 1.2.3 . "" ]
evals/evals-freenode-#perl.lst[385]: "123" & 0x00FF;
evals/evals-freenode-#perl.lst[386]: [ %{[ 1, 2, 3 ]}[ 1,2 ] ]
evals/evals-freenode-#perl.lst[387]: 123 == '123abc  '
evals/evals-freenode-#perl.lst[388]: (1,2,3)[1.5]
evals/evals-freenode-#perl.lst[389]: [ "1.2.3.192/26" =~ /((?:\d{1,3}\.){3}\d{1,3})(?!\/)/ ]
evals/evals-freenode-#perl.lst[390]: [ "1.2.3.192/26" =~ /((?:\d{1,3}\.){3}\d{1,3})(?!\/))/ ]
evals/evals-freenode-#perl.lst[391]: [ "1.2.3.192/26" =~ ((?:\d{1,3}\.){3}\d{1,3})(?!\/) ]
evals/evals-freenode-#perl.lst[392]: "@{[1 2 3 4]}"
evals/evals-freenode-#perl.lst[393]: "@{[1, 2, 3, 4]}"
evals/evals-freenode-#perl.lst[394]: '12341234' =~ /.*(3.*)/; $1
evals/evals-freenode-#perl.lst[395]: [ '%%123@@@@456&&234' =~ /(?<prefix>)\g{prefix}+(\d+)/g ] # still returned in the results, but sometimes looks cleaner than using \123
evals/evals-freenode-#perl.lst[396]: "123.45670000000" + 0
evals/evals-freenode-#perl.lst[397]: "123.45670000000"" + 0
evals/evals-freenode-#perl.lst[398]: " 1234567 " =~ / [0-9]{7} /;
evals/evals-freenode-#perl.lst[399]: $_ = "1234567"; /.{5,}/; [$1]
evals/evals-freenode-#perl.lst[400]: $_ = "1234567"; /(.){5,}/; [$1]
evals/evals-freenode-#perl.lst[401]: $_ = "1234567"; /(.{5,})/; [$1]
evals/evals-freenode-#perl.lst[402]: " 12345678 " =~ / [0-9]{7} /;
evals/evals-freenode-#perl.lst[403]: 123456789012 =~ s/(\d\d\d)/$1,/gr
evals/evals-freenode-#perl.lst[404]: [ '1234567890' =~ /.{1,3}/g ]
evals/evals-freenode-#perl.lst[405]: 1234567890 =~ s/(\d\d\d)/$1,/gr
evals/evals-freenode-#perl.lst[406]: [ "12345678" =~ m/(\d+{4})/g ]
evals/evals-freenode-#perl.lst[407]: [ "1234 5678" =~ m/(\d+)/g ]
evals/evals-freenode-#perl.lst[408]: [ "12345678" =~ m/(\d+)/g ]
evals/evals-freenode-#perl.lst[409]: $_="1234567"; s/(\d\d\d)/$1,/g; $_
evals/evals-freenode-#perl.lst[410]: [(1,2), (3,4), (5,6)] # Not what you think it will be, petrutrimbitas
evals/evals-freenode-#perl.lst[411]: "123456" =~ s/../reverse $&/ger
evals/evals-freenode-#perl.lst[412]: $_ = "123.456str789; $_++; $_
evals/evals-freenode-#perl.lst[413]: $_ = "123.456str789"; $_++; $_
evals/evals-freenode-#perl.lst[414]: "1/2/3/4/5" =~ s{^.*/(?=[^/])}{}
evals/evals-freenode-#perl.lst[415]: 1.2345 =~ /^([^.])(\..*)?/ && sprintf( q{%03d}, $1 ). ( $2 // q{} ); ### leobut
evals/evals-freenode-#perl.lst[416]: "1/2/3/4/5/" =~ s{^.*/(?=[^/]$)}{}r
evals/evals-freenode-#perl.lst[417]: "1/2/3/4/5" =~ s{^.*/(?=[^/])}{}r
evals/evals-freenode-#perl.lst[418]: "1/2/3/4/5" =~ s{^.*/(?=[^/]$)}{}r
evals/evals-freenode-#perl.lst[419]: "1234abc"+0
evals/evals-freenode-#perl.lst[420]: '+1234' =~ m/^+/
evals/evals-freenode-#perl.lst[421]: '+1234' =~ s/^+//
evals/evals-freenode-#perl.lst[422]: '+1234' =~ s/^+//r
evals/evals-freenode-#perl.lst[423]: ["1234x 123y" =~ /\d*(?:[02468]\D|[13579])/g ]
evals/evals-freenode-#perl.lst[424]: ["1234x 123y" =~ m{((?>\d+)(?(?{$1 % 2 == 0}).))}g]
evals/evals-freenode-#perl.lst[425]: ["1234x 123y" =~ m{((?>(\d+))(?(?{$2 % 2 == 0}).))}g]
evals/evals-freenode-#perl.lst[426]: 12351
evals/evals-freenode-#perl.lst[427]: [ "123 5 12 7 " =~ /(\d+)\s*/g ] # or just numbers?
evals/evals-freenode-#perl.lst[428]: [ "123 5 12 7 " =~ m/(?<num>\d+)(?<space>\s*)/g ]; \%+
evals/evals-freenode-#perl.lst[429]: [ "123 5 12 7 " =~ m/(?<num>\d+)(?<space>\s*)/g ]; +{ %+ } # scope, I think?
evals/evals-freenode-#perl.lst[430]: "123abc" + 1
evals/evals-freenode-#perl.lst[431]: $_ = "123AG3GCAT422TG3"; [/([:alpha:]+)/]
evals/evals-freenode-#perl.lst[432]: $_ = "123AG3GCAT422TG3"; [/([[:alpha:]]+)/]
evals/evals-freenode-#perl.lst[433]: $_ = "123AG3GCAT422TG3"; [/([[:alpha:]]+)/g]
evals/evals-freenode-#perl.lst[434]: $_ = "123AG3GCAT422TG3"; [split /([[:alpha:]]+)/]
evals/evals-freenode-#perl.lst[435]: [ "[123]a test\n[345] second\nthird\n[456]more\n" =~ /(^\[.*?(?=^\[|$))/gsm ]
evals/evals-freenode-#perl.lst[436]: [ "[123]a test\n[345] second\nthird\n[456]more\n" =~ /(^\[.*?(?=^\[|\z))/gsm ]
evals/evals-freenode-#perl.lst[437]: 1.2.3 eq "1.2.3"
evals/evals-freenode-#perl.lst[438]: '123' eq lc('123')
evals/evals-freenode-#perl.lst[439]: "123" eq uc "123";
evals/evals-freenode-#perl.lst[440]: "123 HAI STRINGS ARE COOL" + 5
evals/evals-freenode-#perl.lst[441]: "1.2.3" lt "1.10.0"
evals/evals-freenode-#perl.lst[442]: 1.2.3 lt 1.10.0
evals/evals-freenode-#perl.lst[443]: $_ = '1_2_3'; m/(\w*_)/; push @arr, $1; m/(\w*?_)/; push @arr, $1; \@arr
evals/evals-freenode-#perl.lst[444]: $_=123;print eval'$_++.$/,'x10
evals/evals-freenode-#perl.lst[445]: "123" =~ s/2//gr
evals/evals-freenode-#perl.lst[446]: $_ = '1 2 3'; [ split ];
evals/evals-freenode-#perl.lst[447]: $_ = "123str456"; $_++; $_
evals/evals-freenode-#perl.lst[448]: *{123} = sub { "D:" }; &123
evals/evals-freenode-#perl.lst[449]: *{123} = sub { "D:" }; 123->()
evals/evals-freenode-#perl.lst[450]: *{123} = sub { "D:" }; \&123->()  # guessing this is also wrong
evals/evals-freenode-#perl.lst[451]: *{123} = sub { "D:" }; (bless {})->123
evals/evals-freenode-#perl.lst[452]: 12*473
evals/evals-freenode-#perl.lst[453]: "125 some text" =~ s/^[1-9][0-9]* //r
evals/evals-freenode-#perl.lst[454]: [ 127.0.0.1 . ""]
evals/evals-freenode-#perl.lst[455]: [ 127.0.0.1 ]
evals/evals-freenode-#perl.lst[456]: 128.129.130
evals/evals-freenode-#perl.lst[457]: ("12 bananas buys you 0.1 ruby" =~ /\d+/g)[1]
evals/evals-freenode-#perl.lst[458]: ("12 bananas buys you 1 ruby" =~ /\d+/g)[1]
evals/evals-freenode-#perl.lst[459]: '?=12' =~ /^\?(?:=(\d+))?/
evals/evals-freenode-#perl.lst[460]: $. = 12; my $x = 10..20; [ $x ]; ### I've read the link but think I'm misunderstanding something. $. appears to be within that range but it still returns false.
evals/evals-freenode-#perl.lst[461]: [ "12\n13\n14" =~ /(\d+)/g ]
evals/evals-freenode-#perl.lst[462]: @; = (1, 2); print @;;
evals/evals-freenode-#perl.lst[463]: [ 1, 2 ] # these brackets?
evals/evals-freenode-#perl.lst[464]: "@{[ 1+3 ]}"
evals/evals-freenode-#perl.lst[465]: "${\( 1+3 )}"
evals/evals-freenode-#perl.lst[466]: "1" & "3"
evals/evals-freenode-#perl.lst[467]: 1 % -3
evals/evals-freenode-#perl.lst[468]: 1.3 * 0.7
evals/evals-freenode-#perl.lst[469]: [ "1:30" =~ /(?:(\d*):)?(\d+)/ ]
evals/evals-freenode-#perl.lst[470]: [((1 << 3) - 1), 1+2+4]
evals/evals-freenode-#perl.lst[471]: 1<<32
evals/evals-freenode-#perl.lst[472]: 134.95 * 100
evals/evals-freenode-#perl.lst[473]: [  '1-3,5,6-9' =~ s/(\d+)-(\d+)/join ',', $1..$2/ger ]
evals/evals-freenode-#perl.lst[474]: ".1.3.6.1.2.1.43.11.1.1.6.1.1" =~ m/\.(?!5|4|12)$/
evals/evals-freenode-#perl.lst[475]: 1.3e12 / 300e6
evals/evals-freenode-#perl.lst[476]: [ "13month" =~ /(\d+)(\w+)/ ]
evals/evals-freenode-#perl.lst[477]: [1..4]
evals/evals-freenode-#perl.lst[478]: @_ = (1..4); $#_
evals/evals-freenode-#perl.lst[479]: [((1 << 4) - 1), 1+2+4+8]
evals/evals-freenode-#perl.lst[480]: 1414364400 - 1414274400
evals/evals-freenode-#perl.lst[481]: '1.43531264539073e-11' * 10
evals/evals-freenode-#perl.lst[482]: 1 < 4 < 6
evals/evals-freenode-#perl.lst[483]: 14/88
evals/evals-freenode-#perl.lst[484]: 1.4e8
evals/evals-freenode-#perl.lst[485]: 1.4e9 - time
evals/evals-freenode-#perl.lst[486]: (14 gt 7) ? 'yes' : 'no' # maxstr just uses gt instead of >, this seems completely wrong for what you're asking
evals/evals-freenode-#perl.lst[487]: 1/5
evals/evals-freenode-#perl.lst[488]: "150" |. "105"
evals/evals-freenode-#perl.lst[489]: [150 | 105, 150 |. 105]
evals/evals-freenode-#perl.lst[490]: "- 15:03:48,619  -" =~ /- (\d{2}:\d{2}:\d{2},\d{3}).{3,}/
evals/evals-freenode-#perl.lst[491]: "- 15:03:48,619  " =~ /- (\d{2}:\d{2}:\d{2},\d{3}).{3,}/
evals/evals-freenode-#perl.lst[492]: "- 15:03:48,619  -" =~ /- (\d{2}:\d{2}:\d{2},\d{3}).{4,}/
evals/evals-freenode-#perl.lst[493]: "- 15:03:48,619  -\n\r" =~ /- (\d{2}:\d{2}:\d{2},\d{3}).{4,}/
evals/evals-freenode-#perl.lst[494]: 155.0 / 3.0
evals/evals-freenode-#perl.lst[495]: '15.8' == '15.80'
evals/evals-freenode-#perl.lst[496]: '15.8' == undef
evals/evals-freenode-#perl.lst[497]: 1.5e308
evals/evals-freenode-#perl.lst[498]: @_ = (1 .. 5); $single = @_; $single
evals/evals-freenode-#perl.lst[499]: 16 | 0
evals/evals-freenode-#perl.lst[500]: 16 & 0
evals/evals-freenode-#perl.lst[501]: 16 | 16
evals/evals-freenode-#perl.lst[502]: 16 & 16
evals/evals-freenode-#perl.lst[503]: (1 << 63) - 1 + (1 << 63)
evals/evals-freenode-#perl.lst[504]: 163.163.163
evals/evals-freenode-#perl.lst[505]: ((16385 >> 12) <<12)
evals/evals-freenode-#perl.lst[506]: 1.79e308
evals/evals-freenode-#perl.lst[507]: 1 << 8
evals/evals-freenode-#perl.lst[508]: [ 180000000 / 57100  ]
evals/evals-freenode-#perl.lst[509]: 18446744073709551615 + 1
evals/evals-freenode-#perl.lst[510]: 18446744073709551616  - 18446744073709551000
evals/evals-freenode-#perl.lst[511]: [ 1890 & 8,  1890 & 32 ]
evals/evals-freenode-#perl.lst[512]: 1.8e308
evals/evals-freenode-#perl.lst[513]: 1.8e308-1
evals/evals-freenode-#perl.lst[514]: [1 << 90, 2**90]
evals/evals-freenode-#perl.lst[515]: [ 192.168.0.0 . '', '192.168.0.0' ]
evals/evals-freenode-#perl.lst[516]: [ 192.168.0.0, '192.168.0.0' ]
evals/evals-freenode-#perl.lst[517]: [ '1990-1992-1993-2010' =~ tr/-/ /r ]
evals/evals-freenode-#perl.lst[518]: 19.99*100
evals/evals-freenode-#perl.lst[519]: 1^9999
evals/evals-freenode-#perl.lst[520]: 1999979/1999993
evals/evals-freenode-#perl.lst[521]: 1**9999 # perl's spelling of "^"
evals/evals-freenode-#perl.lst[522]: "19" . (localtime)[5]
evals/evals-freenode-#perl.lst[523]: -+- "1abc"
evals/evals-freenode-#perl.lst[524]: -+-+-+-+-+- "1abc"
evals/evals-freenode-#perl.lst[525]: $[ = 1; ("A", "B", "C")[0]
evals/evals-freenode-#perl.lst[526]: '1e0' == 1
evals/evals-freenode-#perl.lst[527]: 1e02.34
evals/evals-freenode-#perl.lst[528]: $_ = '1e1'; $_++; $_
evals/evals-freenode-#perl.lst[529]: 1e10
evals/evals-freenode-#perl.lst[530]: 1e1000
evals/evals-freenode-#perl.lst[531]: 1e999
evals/evals-freenode-#perl.lst[532]: 1e9999
evals/evals-freenode-#perl.lst[533]: [ 1 eq '1.0', 1 == '1.0' ]
evals/evals-freenode-#perl.lst[534]: [ 1 eq 1.0, 1 == 1.0 ]
evals/evals-freenode-#perl.lst[535]: 1 eq 2 != 3
evals/evals-freenode-#perl.lst[536]: $1 = eval {a:}
evals/evals-freenode-#perl.lst[537]: ("1foo"=~/(\d+)/)[0]
evals/evals-freenode-#perl.lst[538]: 1 for @array;
evals/evals-freenode-#perl.lst[539]: 1 if scalar \%hash
evals/evals-freenode-#perl.lst[540]: $1\l$2
evals/evals-freenode-#perl.lst[541]: $[ = -1; my @foo = qw/x y z/; [ $foo[-1] ]
evals/evals-freenode-#perl.lst[542]: [ 1=>'one' ];
evals/evals-freenode-#perl.lst[543]: [(1 or 0 and "foo"), ((1 or 0) and "foo")]
evals/evals-freenode-#perl.lst[544]: 1p-10
evals/evals-freenode-#perl.lst[545]: $ = 1; print $++;
evals/evals-freenode-#perl.lst[546]: 1+print 4
evals/evals-freenode-#perl.lst[547]: $! = 1; printf "SvPV is %s but SvIV is %d\n", $!, $!
evals/evals-freenode-#perl.lst[548]: 1 =~ /^([^.])(\..*)?/ && sprintf( q{%03d}, $1 ). ( $2 // q{} ); ### leobut
evals/evals-freenode-#perl.lst[549]: 1=>undef
evals/evals-freenode-#perl.lst[550]: 1,undef
evals/evals-freenode-#perl.lst[551]: [ -1 - ~unpack 'N', join '', map chr, '192.168.254.43' =~ /\d+/g ]
evals/evals-freenode-#perl.lst[552]: 1x4
evals/evals-freenode-#perl.lst[553]: 2014-1989
evals/evals-freenode-#perl.lst[554]: 2014-1997
evals/evals-freenode-#perl.lst[555]: $_ = "2015021900:00:00"; /^(....)(..)(..)/; "$1-$2-$3"
evals/evals-freenode-#perl.lst[556]: $_ = 2015021900:00:00; /^(....)(..)(..)/; "$1-$2-$3"
evals/evals-freenode-#perl.lst[557]: ['2.0' == 2 ? "Y" : "N"]
evals/evals-freenode-#perl.lst[558]: [20 + 4]
evals/evals-freenode-#perl.lst[559]: [20+4]
evals/evals-freenode-#perl.lst[560]: 2048 & 0x00FF
evals/evals-freenode-#perl.lst[561]: "²" =~ /[⁰-⁹]/
evals/evals-freenode-#perl.lst[562]: "  20:       ee110f10      mrc     15, 0, r0, cr1, cr0, {0}" =~ s/^\s+[0-9a-f]+:\s+([0-9a-f]+)\K/sprintf "     %b   ", hex $1/er #netz something like this then?
evals/evals-freenode-#perl.lst[563]: 2**100
evals/evals-freenode-#perl.lst[564]: 2**127;
evals/evals-freenode-#perl.lst[565]: 2**1270;
evals/evals-freenode-#perl.lst[566]: "٢" =~ /[١-٣]/a
evals/evals-freenode-#perl.lst[567]: [ 2 << 1, 4 >> 1 ]
evals/evals-freenode-#perl.lst[568]: 2**17 * 2**17
evals/evals-freenode-#perl.lst[569]: -2 % 1e6
evals/evals-freenode-#perl.lst[570]: 2 + 2
evals/evals-freenode-#perl.lst[571]: 2+2
evals/evals-freenode-#perl.lst[572]: [2**2*3]
evals/evals-freenode-#perl.lst[573]: *2 = 2.5; 2 + 2
evals/evals-freenode-#perl.lst[574]: *2 = 2.5; 2 + &2
evals/evals-freenode-#perl.lst[575]: "\22\a\6\21A\5SK" ^ 'foobar22'
evals/evals-freenode-#perl.lst[576]: [2.3 ^ 0, 2 . 3 ^ 0]
evals/evals-freenode-#perl.lst[577]: 2 * 3 + 1
evals/evals-freenode-#perl.lst[578]: 2**31
evals/evals-freenode-#perl.lst[579]: [ 23 ** 11, 2 ** 32 ]
evals/evals-freenode-#perl.lst[580]: 2^32
evals/evals-freenode-#perl.lst[581]: 2**32
evals/evals-freenode-#perl.lst[582]: (2**32)/1000/60/60/24/365
evals/evals-freenode-#perl.lst[583]: 2**32 / 3600 / 24 / 365
evals/evals-freenode-#perl.lst[584]: [ 2.3, 2 . 3 ]  # different
evals/evals-freenode-#perl.lst[585]: 23 % 24
evals/evals-freenode-#perl.lst[586]: (2**32)/60/60/24
evals/evals-freenode-#perl.lst[587]: 2**32 =~ s/\B(?=(\d\d\d)+$)/,/gr
evals/evals-freenode-#perl.lst[588]: 2**33
evals/evals-freenode-#perl.lst[589]: 235 ^ 255
evals/evals-freenode-#perl.lst[590]: 235 xor 255
evals/evals-freenode-#perl.lst[591]: 240*(10**9)/(2**30)
evals/evals-freenode-#perl.lst[592]: 240*10^9/2^30
evals/evals-freenode-#perl.lst[593]: 24 % 24
evals/evals-freenode-#perl.lst[594]: 24 + localtime
evals/evals-freenode-#perl.lst[595]: 2**5
evals/evals-freenode-#perl.lst[596]: 2**50 / 1000 / 3600 / 24 / 365  # that's a loooooong time @ 1000/sec
evals/evals-freenode-#perl.lst[597]: 2**50  # really ?
evals/evals-freenode-#perl.lst[598]: 25 % 24
evals/evals-freenode-#perl.lst[599]: 255 & 0x7f
evals/evals-freenode-#perl.lst[600]: 25 | 6 ** 4
evals/evals-freenode-#perl.lst[601]: [ 256 >> 8 ]
evals/evals-freenode-#perl.lst[602]: 25**7
evals/evals-freenode-#perl.lst[603]: 25 or 6 ** 4
evals/evals-freenode-#perl.lst[604]: 260 / 3600
evals/evals-freenode-#perl.lst[605]: 2**62
evals/evals-freenode-#perl.lst[606]: (2**63 - 1) + 2**63
evals/evals-freenode-#perl.lst[607]: 2**64
evals/evals-freenode-#perl.lst[608]: 2**64 - 1
evals/evals-freenode-#perl.lst[609]: 265 % 2
evals/evals-freenode-#perl.lst[610]: 2*710 . ' litres of beer tonight'
evals/evals-freenode-#perl.lst[611]: 2733.754 % 60.0; ### Why exactly is it that this yields 33 instead of 33.754 ?
evals/evals-freenode-#perl.lst[612]: 2**(7*8)
evals/evals-freenode-#perl.lst[613]: 2790**2753 % 3233
evals/evals-freenode-#perl.lst[614]: 2**8
evals/evals-freenode-#perl.lst[615]: 2**88
evals/evals-freenode-#perl.lst[616]: 28867 / 150000
evals/evals-freenode-#perl.lst[617]: (2903000/2903000)*100
evals/evals-freenode-#perl.lst[618]: 29822 * length q|/gnu/store/d8fwypp5cnzjpc7kycmj4nj0gwn7k6lq-perl-xml-sax-0.99|
evals/evals-freenode-#perl.lst[619]: 2 =~ /\A(?:(?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9])\z/
evals/evals-freenode-#perl.lst[620]: $! = 2; die "$!"
evals/evals-freenode-#perl.lst[621]: [2,grep{(1x$_)!~/^(..+)\1+$/}3..541]
evals/evals-freenode-#perl.lst[622]: $_ = 2; grep { $_ } qw(1 3 5); $_
evals/evals-freenode-#perl.lst[623]: (2 or 3)
evals/evals-freenode-#perl.lst[624]: *2 = sub {2.5}; 2 + &2
evals/evals-freenode-#perl.lst[625]: *{"2"} = sub { 'ok' }; [ main->${\2} ]
evals/evals-freenode-#perl.lst[626]: *{"2"} = sub { 'ok' }; [ main->2 ]
evals/evals-freenode-#perl.lst[627]: *{"2"} = sub { 'ok' }; [ my $two = 2; main->$two ]
evals/evals-freenode-#perl.lst[628]: *{"2"} = sub { 'ok' }; my $two = 2; [ main->$two ]
evals/evals-freenode-#perl.lst[629]: 2 =~ /\w/
evals/evals-freenode-#perl.lst[630]: 2x4
evals/evals-freenode-#perl.lst[631]: 3
evals/evals-freenode-#perl.lst[632]: 3_000_000 / 100  # this many seconds
evals/evals-freenode-#perl.lst[633]: 30_000 * 30_000 / 2
evals/evals-freenode-#perl.lst[634]: 300 x $60
evals/evals-freenode-#perl.lst[635]: '30/10/2010' =~ m[(\d\d)/(\d\d)/(\d\d\d\d)]; my $age = DateTime->new(year => $3, month => $2, day => $1)->delta_md(DateTime->now())->years;
evals/evals-freenode-#perl.lst[636]: "\303\203\302\241r j\303\203\302\272 s\303\203\302\272r?\n"
evals/evals-freenode-#perl.lst[637]: -30 % 60
evals/evals-freenode-#perl.lst[638]: 307 * 500
evals/evals-freenode-#perl.lst[639]: [ ":30" =~ /(?:(\d*):)?(\d+)/ ]
evals/evals-freenode-#perl.lst[640]: [ 30 =~ /(?:(\d*):)?(\d+)/ ]
evals/evals-freenode-#perl.lst[641]: 3 ** 12   # Actually :)
evals/evals-freenode-#perl.lst[642]: 3 ** 13
evals/evals-freenode-#perl.lst[643]: "31323334" =~ s/.(.)/$1/gr
evals/evals-freenode-#perl.lst[644]: "31323334" =~ s/(..)/chr hex $1/g
evals/evals-freenode-#perl.lst[645]: "31323334" =~ s/(..)/chr hex $1/gr
evals/evals-freenode-#perl.lst[646]: "31323334" =~ s/(..)/chr hex $1/gre
evals/evals-freenode-#perl.lst[647]: 3.141592653589793238462643383279502884
evals/evals-freenode-#perl.lst[648]: 3 / 2
evals/evals-freenode-#perl.lst[649]: 3 // 2
evals/evals-freenode-#perl.lst[650]: "321" =~ /\d+/
evals/evals-freenode-#perl.lst[651]: 3/2 > 7/5
evals/evals-freenode-#perl.lst[652]: [ 3 ^ 3 ]
evals/evals-freenode-#perl.lst[653]: $_ = '"33.62" "114.72" "Blythe"'; s/(\S+)\s(\S+)\s(.+$)/$3 $1 $2/; $_ # seems happy enough, did you try it?
evals/evals-freenode-#perl.lst[654]: 337 * 1051
evals/evals-freenode-#perl.lst[655]: (3 == 3) ? "yes" : "no";
evals/evals-freenode-#perl.lst[656]: "@{[ 3 + 4 ]}"
evals/evals-freenode-#perl.lst[657]: 3.4/2.31012414912481924812904128490128412
evals/evals-freenode-#perl.lst[658]: $_ = "\345\207\272\350\262\250\346\230\216\347\264\260"; utf8::decode $_; [$_]
evals/evals-freenode-#perl.lst[659]: @3 = 4..9; \@3  # other global stuff :)
evals/evals-freenode-#perl.lst[660]:  3 ∗ 5;
evals/evals-freenode-#perl.lst[661]: 3:5
evals/evals-freenode-#perl.lst[662]: 3+5
evals/evals-freenode-#perl.lst[663]: 350*24*365.25*100/(1024*1024) # about 300TB, why do you ask?
evals/evals-freenode-#perl.lst[664]: 3568 / 100
evals/evals-freenode-#perl.lst[665]: 360/24
evals/evals-freenode-#perl.lst[666]: 365/((localtime)[7])
evals/evals-freenode-#perl.lst[667]: 365/(localtime)[7]
evals/evals-freenode-#perl.lst[668]: '٣' =~ /./a
evals/evals-freenode-#perl.lst[669]: '٣' =~ /\d/a
evals/evals-freenode-#perl.lst[670]: '٣' =~ /\D/a
evals/evals-freenode-#perl.lst[671]: [ '٣' =~ /\d/a, '٣' =~ /./a, "٢" =~ /[١-٣]/a, '٣' =~ /\D/a ]
evals/evals-freenode-#perl.lst[672]: "(3/(x+2)+(-1/2)/(x-3))dx " =~ s/^\(((?:[^()]|\((?1)\))*)\)dx\s*$/$1/r
evals/evals-freenode-#perl.lst[673]: "(3/(x+2)+(-1/2)/(x-3))dx " =~ s/^\(((?:[^()]|\((?1)\))*\)dx\s*$/$1/r
evals/evals-freenode-#perl.lst[674]: 404->()
evals/evals-freenode-#perl.lst[675]: $_ = '4 1 4 2 3'; @a=(); $a[abs $1-$']+=1 while / (\d+)(?= )/g; (!defined shift @a) && @a == $_ - 1 && $_ - 1 == grep($_ == 1, @a) ? 'jolly' : 'Not jolly'
evals/evals-freenode-#perl.lst[676]:  $_ = '4 1 4 2 3'; @deltas = 1; $deltas[abs $1 - $2] += 1 while / (\d+)(?= (\d+))/g;  grep($_ != 1, @deltas) ? 'Not jolly' : 'jolly'
evals/evals-freenode-#perl.lst[677]: 42
evals/evals-freenode-#perl.lst[678]: [ ~42 ]
evals/evals-freenode-#perl.lst[679]: [ "" || 42 ]
evals/evals-freenode-#perl.lst[680]: [ "" // 42 ]
evals/evals-freenode-#perl.lst[681]: $_ = []; $_->[42] = $_; [ ''.$_, ''.$_->[42] ]
evals/evals-freenode-#perl.lst[682]: ('42 bottles of beer' =~ /(\d+)/)[0]
evals/evals-freenode-#perl.lst[683]: [ !!42, !!"foo", !!{baz=>quux} ]
evals/evals-freenode-#perl.lst[684]: $_ = 42; [ \$_, \$main::_, \$main::main::_ ]
evals/evals-freenode-#perl.lst[685]: $_ = 42; [ map ${$_}, \$_, \$main::_, \$main::main::_ ]
evals/evals-freenode-#perl.lst[686]: $_ = 42; print map { $_ } qw(a b c); print "; $_"
evals/evals-freenode-#perl.lst[687]: [ '446744073709551615' =~ s/\B(?=(\d{3})+$)/,/gr ]  # fix
evals/evals-freenode-#perl.lst[688]: [ '446744073709551615' =~ s/(?=(\d{3})+$)/,/gr ]
evals/evals-freenode-#perl.lst[689]: 45_000_000 * 24
evals/evals-freenode-#perl.lst[690]: (45/50-1)*100
evals/evals-freenode-#perl.lst[691]: (4,5,6)[-2..-1]
evals/evals-freenode-#perl.lst[692]: [(4,5,6)[-2..-1]]
evals/evals-freenode-#perl.lst[693]: 47 % 24
evals/evals-freenode-#perl.lst[694]: [ 4 .. 9 ]
evals/evals-freenode-#perl.lst[695]: 4 .. 9
evals/evals-freenode-#perl.lst[696]: 49 & 97
evals/evals-freenode-#perl.lst[697]: "4-9" =~ /-/ and [eval '$`..$\'']
evals/evals-freenode-#perl.lst[698]: "4-9" =~ /-/ and [ split /,/, `perl -e'print join ",", $\` .. $'\'` ]
evals/evals-freenode-#perl.lst[699]: $_ = "4-9"; s/(\d+)-/$1,@{[$1+1]}-/ until /(?<=,)(\d+)-\1/; s//$1/; $_
evals/evals-freenode-#perl.lst[700]: $_ = "4-9"; s/(\d+)-/$1,@{[$1+1]}-/ until /(?<=,)(\d+)-\1/; s//$1/; [ /(\d+)/g ]  # better
evals/evals-freenode-#perl.lst[701]: $_ = "4-9"; s/-/../; [ eval ]
evals/evals-freenode-#perl.lst[702]: 4[$array]
evals/evals-freenode-#perl.lst[703]: 4*atan2(1,1)
evals/evals-freenode-#perl.lst[704]: $! = 4; die "$!"
evals/evals-freenode-#perl.lst[705]: $_[4] = ['foo']; $_->[4] = 'bar'; [ @{$_[4]} ];
evals/evals-freenode-#perl.lst[706]: $_[4] = ['foo']; $_->[4] = 'bar'; [ @$_[4] ];
evals/evals-freenode-#perl.lst[707]: $_ = '4x4x4'; y(4)(5); $_ # still potential for confusion though
evals/evals-freenode-#perl.lst[708]: [ .5]
evals/evals-freenode-#perl.lst[709]: [ 5. ]
evals/evals-freenode-#perl.lst[710]: [5 .. 0]
evals/evals-freenode-#perl.lst[711]: [ "5" & "000000" ]
evals/evals-freenode-#perl.lst[712]: *5000 = \5;
evals/evals-freenode-#perl.lst[713]: \*5000 = \5;
evals/evals-freenode-#perl.lst[714]: \*5000 = 5;
evals/evals-freenode-#perl.lst[715]: *5000 = \5; $5000
evals/evals-freenode-#perl.lst[716]: *5000 = \5; *5000
evals/evals-freenode-#perl.lst[717]: *5000 = sub {5}; 5 & & 5000
evals/evals-freenode-#perl.lst[718]: *5000 = sub {"Hello World"}; 10 &5000
evals/evals-freenode-#perl.lst[719]: *5000 = sub {"Hello World"}; \*5000->()
evals/evals-freenode-#perl.lst[720]: *5000 = sub {"Hello World"}; &5000
evals/evals-freenode-#perl.lst[721]: *5000 = sub {"Hello World"}; 5000->()
evals/evals-freenode-#perl.lst[722]: *5000 = sub {"Hello World"}; 5000()
evals/evals-freenode-#perl.lst[723]: *5000 = sub {"Hello World"}; "Hello" + &5000
evals/evals-freenode-#perl.lst[724]: [ 5/0.06 ]
evals/evals-freenode-#perl.lst[725]: 5.013_006 # mauke typo I think
evals/evals-freenode-#perl.lst[726]: $] < 5.013006 #surely this is what he wants
evals/evals-freenode-#perl.lst[727]: [5 + 100]
evals/evals-freenode-#perl.lst[728]: [ 5 .. 12 ]
evals/evals-freenode-#perl.lst[729]: $] < 5.13.6
evals/evals-freenode-#perl.lst[730]: [5.14.0]
evals/evals-freenode-#perl.lst[731]: 5.14.0
evals/evals-freenode-#perl.lst[732]: $✆ = 5; $✌ = 2; $✆ + $✌
evals/evals-freenode-#perl.lst[733]: [ "5" & "3" ]
evals/evals-freenode-#perl.lst[734]: 5<=>3
evals/evals-freenode-#perl.lst[735]: 5/3
evals/evals-freenode-#perl.lst[736]: [ 5 5 ]
evals/evals-freenode-#perl.lst[737]: 5*5
evals/evals-freenode-#perl.lst[738]: 5+5
evals/evals-freenode-#perl.lst[739]: 5 == 5.0
evals/evals-freenode-#perl.lst[740]: [ 5 . 5, 5. 5, 5 .5, 5.5 ]
evals/evals-freenode-#perl.lst[741]: "5 + 5" =~ s/(.+)/ $1 /eer;
evals/evals-freenode-#perl.lst[742]: "5 + 5" =~ s/.*/$&/eer;
evals/evals-freenode-#perl.lst[743]: "5 5" =~ s/(.)\s(.)/$1 + $2/er;
evals/evals-freenode-#perl.lst[744]: "5 5" =~ s/(.)\s(.)/print $1 + $2/er;
evals/evals-freenode-#perl.lst[745]: [5+6]
evals/evals-freenode-#perl.lst[746]: 5+6
evals/evals-freenode-#perl.lst[747]: 5/7
evals/evals-freenode-#perl.lst[748]: [ 57100 / 180000000 ]
evals/evals-freenode-#perl.lst[749]: 57+42  # perlbot is the most accessible calculator
evals/evals-freenode-#perl.lst[750]: [ 5.'a' ]
evals/evals-freenode-#perl.lst[751]: $! = 5; say $!
evals/evals-freenode-#perl.lst[752]: 62 ** 4
evals/evals-freenode-#perl.lst[753]: 64.64.64.5000000000.64.64.64
evals/evals-freenode-#perl.lst[754]: 64.65.68.70
evals/evals-freenode-#perl.lst[755]: 65280 & 127
evals/evals-freenode-#perl.lst[756]: 65280 >> 8
evals/evals-freenode-#perl.lst[757]: 65536 >> 16
evals/evals-freenode-#perl.lst[758]: 65536 >> 8
evals/evals-freenode-#perl.lst[759]: [ 65.66.67 ]
evals/evals-freenode-#perl.lst[760]: [65.66.67]
evals/evals-freenode-#perl.lst[761]: 6_5,6_6,6_7
evals/evals-freenode-#perl.lst[762]: 6_5.6_6.6_7
evals/evals-freenode-#perl.lst[763]: 65.66.67
evals/evals-freenode-#perl.lst[764]: ~~667
evals/evals-freenode-#perl.lst[765]: 6.6e-16 == 6.6 * 10 ** -16
evals/evals-freenode-#perl.lst[766]: 6*710 . ' militres of beer tonight'
evals/evals-freenode-#perl.lst[767]: 6 * 99.90
evals/evals-freenode-#perl.lst[768]: 6 * 99.90 > 599.40
evals/evals-freenode-#perl.lst[769]: "6C5775272327642A382A453C327D3A31" =~ s/(..)/chr hex $1/gre
evals/evals-freenode-#perl.lst[770]: "6d73616e64626f78" =~ s/([0-9a-f]{2})/chr hex $1/eg
evals/evals-freenode-#perl.lst[771]: 70 / 4.4
evals/evals-freenode-#perl.lst[772]: 7200 * 12
evals/evals-freenode-#perl.lst[773]: 7 + 32 + 64
evals/evals-freenode-#perl.lst[774]:  7 + 7 / 7 + 7 * 7 - 7
evals/evals-freenode-#perl.lst[775]:  7 + 7 / 7 + 7 x 7 - 7
evals/evals-freenode-#perl.lst[776]: $78_char_wide_text
evals/evals-freenode-#perl.lst[777]: [ 7 <=> "cats" ]
evals/evals-freenode-#perl.lst[778]: 7 < 'D'
evals/evals-freenode-#perl.lst[779]: .7E9 / 604
evals/evals-freenode-#perl.lst[780]: [ 7 <=> 'nan' ]
evals/evals-freenode-#perl.lst[781]: 8181 / 101
evals/evals-freenode-#perl.lst[782]: 8181/9999
evals/evals-freenode-#perl.lst[783]: 8192 / 1024
evals/evals-freenode-#perl.lst[784]: 8 >> 2
evals/evals-freenode-#perl.lst[785]: (86274 ^ 87381) ** 2
evals/evals-freenode-#perl.lst[786]: "\8" eq "\9" ? "yes" : "no"
evals/evals-freenode-#perl.lst[787]: *9001 = \5;
evals/evals-freenode-#perl.lst[788]: 9/11
evals/evals-freenode-#perl.lst[789]: 953-176
evals/evals-freenode-#perl.lst[790]: 97 =~ s/(\d+)/chr $1/er
evals/evals-freenode-#perl.lst[791]: 97 =~ s/(\d+)/${\chr $1}/r
evals/evals-freenode-#perl.lst[792]: 99.97.102.233
evals/evals-freenode-#perl.lst[793]: 9999 / 101
evals/evals-freenode-#perl.lst[794]: $. = 9; [ [ $.++, scalar(10..15) ], ]
evals/evals-freenode-#perl.lst[795]: {a=>1}
evals/evals-freenode-#perl.lst[796]: @a=(1,2,3,4,5); [@a[-20..-1]]
evals/evals-freenode-#perl.lst[797]: @a=[1,2,3,4,5]; [@a[-20..-1]]
evals/evals-freenode-#perl.lst[798]: [ { a => 123 }, { b => 456 } ];
evals/evals-freenode-#perl.lst[799]: "a123b" =~ s/(\d+)/$1*100/er
evals/evals-freenode-#perl.lst[800]: @a = (1, 2, 3); print $#a;
evals/evals-freenode-#perl.lst[801]: $_ = "a1 2b 3 c 44"; [/(\d+)/g]
evals/evals-freenode-#perl.lst[802]: @a = (1, 2, 'foo'); grep { $_ eq 'foo' } @a[1..$#a]
evals/evals-freenode-#perl.lst[803]: $a = {1..4}; [keys $a]
evals/evals-freenode-#perl.lst[804]: @a=1..4; [{map{$_=>$_+1}@a[0..@a/2-1]},{map{$_=>$_+1}@a[@a/2..$#a]}]
evals/evals-freenode-#perl.lst[805]: @a = (1,5,2,4,3); @b = (5,3,1,4,2); (() = delete @{ { map {$_,1} @a } }{ @b }) == @b
evals/evals-freenode-#perl.lst[806]: @a = (1,5,2,4,6); @b = (5,3,1,4,2); (() = delete @{ { map {$_,1} @a } }{ @b }) == @a
evals/evals-freenode-#perl.lst[807]: @a = (1,5,2,4,6); @b = (5,3,1,4,2); "@{[sort @a]}" eq "@{[sort @b]}" ? same : different
evals/evals-freenode-#perl.lst[808]: @a = (1,5,2,4,6); @b = (5,6,1,4,2); "@{[sort @a]}" eq "@{[sort @b]}" ? same : different
evals/evals-freenode-#perl.lst[809]: @a = (1,5,2,4); @b = (5,3,1,4,2); (() = delete @{ { map {$_,1} @a } }{ @b }) == @b
evals/evals-freenode-#perl.lst[810]: { a => 1, a => 2 }
evals/evals-freenode-#perl.lst[811]: $a=1; $b=1; LABL: while($a--) {try {die if $b--} catch {redo LABL;}; print "hello world"};
evals/evals-freenode-#perl.lst[812]: $a = 1; $b = 3; ($a/$b)*$b
evals/evals-freenode-#perl.lst[813]: @a = (1) x 1024*1024*30; $#a
evals/evals-freenode-#perl.lst[814]: @a = (1) x 1024*1024*5
evals/evals-freenode-#perl.lst[815]: @a = 2; [ @a == 2 ]
evals/evals-freenode-#perl.lst[816]: $a->[2]->{bar} eq 'baz'; $a
evals/evals-freenode-#perl.lst[817]: [ 'a 42 b' =~ s/\D+//, 'a 42 b' =~ s/\D+//g ]
evals/evals-freenode-#perl.lst[818]: [ 'a 42 b' =~ s/\D+//r, 'a 42 b' =~ s/\D+//gr ]
evals/evals-freenode-#perl.lst[819]: @a=(4,5,6); [ map [@a[0..@a-$_]], 1..@a+1 ]
evals/evals-freenode-#perl.lst[820]: %a=(a=>1); $s="a"; $s=~s/.+/$a{\1}/eg; print $s;
evals/evals-freenode-#perl.lst[821]: "<a<a></a>></a>" =~ /<a(.*)>(.*)<\/a>/
evals/evals-freenode-#perl.lst[822]: "<a<a></a>></a>" !~ /<a(.*)>(.*)<\/a>/
evals/evals-freenode-#perl.lst[823]: "aaaaaaaanother thing" =~ m/^(a+)/ and $+[1]
evals/evals-freenode-#perl.lst[824]: 'AAAAABBBB' =~ /((.)\2*)(.*)/ ; [ $1, $3 ]
evals/evals-freenode-#perl.lst[825]: 'aaaabbbbbccccddddd' =~ tr/abc//sr
evals/evals-freenode-#perl.lst[826]: "aaa b ccccc abcadaba" =~ tr/abc/abc/sr
evals/evals-freenode-#perl.lst[827]: $_ = 'aaa'; my $a = 5; ++$_ for $a; [ $_, $a ];
evals/evals-freenode-#perl.lst[828]: $_ = 'aaa'; my $a = 5; {local *_ = \$a; ++$_}; [ $_, $a ];
evals/evals-freenode-#perl.lst[829]: $_ = 'aaa'; my $a = 5; {local $_ = $a; ++$_}; [ $_, $a ]; # note that this, which uses 'local $_', acts differently
evals/evals-freenode-#perl.lst[830]: [ 'aaa' .. 'zzz' ]
evals/evals-freenode-#perl.lst[831]: [ "aabbaa" =~ /(aab??)(b+aa)/ ]
evals/evals-freenode-#perl.lst[832]: [ "aabbaa" =~ /(aab?)(b+aa)/ ]
evals/evals-freenode-#perl.lst[833]: "aabbcc" =~ s/(\w)\1/ $& /g;
evals/evals-freenode-#perl.lst[834]: @a = (); 'abcccccdefghi' =~ / (c) (?:(\1)(?{push @a, $1})){4} /x; \@a # backrefs :)
evals/evals-freenode-#perl.lst[835]: @a = (); 'abcdefghi' =~ / c (?:(.)(?{push @a, $1})){4} /x; \@a
evals/evals-freenode-#perl.lst[836]: @a = (); 'abcdefghi' =~ / c (?:(.)(?{push @a, $1})){4} (?!) /x; \@a
evals/evals-freenode-#perl.lst[837]: @a = (); 'abcdefghi' =~ / (?:(.)(?{push @a, $1})){4} (?= $ ) /x; \@a
evals/evals-freenode-#perl.lst[838]: @a = (); 'abcdefghi' =~ / (?:(.)(?{push @a, $1})){4} $ /x; \@a
evals/evals-freenode-#perl.lst[839]: $_="aabcdef"; print if /^a([abcd]+)ef$/ and $1 !~ /([abcd]).*\1/
evals/evals-freenode-#perl.lst[840]: $a="a.b.com";print "yes" if $a=~/^a.com$/
evals/evals-freenode-#perl.lst[841]: $a = 'a'; my $b = \$a; for $$b (0..5) { print $a }
evals/evals-freenode-#perl.lst[842]: $a = 'a'; my $b = \*a; for $$b (0..5) { print $a }
evals/evals-freenode-#perl.lst[843]: $a="asd1312321asd1212asd121212"; print $_,"\n" for $a=~/(asd\d+)/g;
evals/evals-freenode-#perl.lst[844]: [ @a=['asd qwe', 'qqq '];   /(\w+)\s+(\w+?)/ , print "$1 - $2" for ( @a )   ]
evals/evals-freenode-#perl.lst[845]: [ 'a' ^ 'A' ] # secret - the difference between upper and lower case is a space
evals/evals-freenode-#perl.lst[846]: "AA" =~ s/(.)(.)/\l$1$2/r
evals/evals-freenode-#perl.lst[847]: [ 'a' ^ 'b' ]
evals/evals-freenode-#perl.lst[848]: +{ a; b}
evals/evals-freenode-#perl.lst[849]: "ab12312532" =~ /.*3.*/
evals/evals-freenode-#perl.lst[850]: -+- "ab1c"
evals/evals-freenode-#perl.lst[851]: [ "a{b" =~ /a{/ ]
evals/evals-freenode-#perl.lst[852]: ("AB" ^ "A4") =~ tr/\0\1-\377/01/r
evals/evals-freenode-#perl.lst[853]: [ "a" . "b", "a" . 5, 5 . "b", 5 . 5 ]
evals/evals-freenode-#perl.lst[854]: [ 'ababab' =~ /(ab)*/ ]
evals/evals-freenode-#perl.lst[855]: [ 'ababab' =~ /(ab)/g ]
evals/evals-freenode-#perl.lst[856]: [ "ab" =~ /(a)x|b/ ]
evals/evals-freenode-#perl.lst[857]: 'ab' & 'b'
evals/evals-freenode-#perl.lst[858]: 'ab' & 'ba'
evals/evals-freenode-#perl.lst[859]: ["abba" =~ /(ab(ba))/]
evals/evals-freenode-#perl.lst[860]: "abba" =~ /(ab(ba))/; [$1, $2]
evals/evals-freenode-#perl.lst[861]: "ABBBBBBBABBA" =~ s/(B+)/length $1 < 3 ? 'C' x length $1 : $1/ger
evals/evals-freenode-#perl.lst[862]: 'aBBBc' =~ s/[^a-z]//gr
evals/evals-freenode-#perl.lst[863]: $_ = 'Abbott &&& Costello'; s/\s\K\W+(?=\s)/and/; $_ # should work here though
evals/evals-freenode-#perl.lst[864]: [ 'Abbott &&& Costello' =~ s/(\s*)&&&(\s*)/$1and$2/gr ]
evals/evals-freenode-#perl.lst[865]: [~~"abc"]
evals/evals-freenode-#perl.lst[866]: ['ABC']
evals/evals-freenode-#perl.lst[867]: A: B: C: ;
evals/evals-freenode-#perl.lst[868]: "ABC" & 0x00FF;
evals/evals-freenode-#perl.lst[869]: "abc" =~ "(..)"; $1
evals/evals-freenode-#perl.lst[870]: { abc => 123 }->JSON::encode_json
evals/evals-freenode-#perl.lst[871]: [ "abc123___" =~ /\w+/g ]
evals/evals-freenode-#perl.lst[872]: [ "abc 30 def" =~ /abc (\d+) def/  ]
evals/evals-freenode-#perl.lst[873]: [ "abc 30 def" =~ /abc (\d) def/ || "No match" ]
evals/evals-freenode-#perl.lst[874]: [ "abc 30 def" =~ /abc (\d+) def/ || "No match" ]
evals/evals-freenode-#perl.lst[875]: [ 'abc446744073709551615' =~ s/\B(?=(\d{3})+$)/,/gr ]
evals/evals-freenode-#perl.lst[876]: [ 'abc446744073709551615' =~ s/(?<=\d)(?=(\d{3})+$)/,/gr ]
evals/evals-freenode-#perl.lst[877]: @abc = (5,6,7,8); $c = @abc[1,2]
evals/evals-freenode-#perl.lst[878]: "abc" =~ /a/
evals/evals-freenode-#perl.lst[879]: "abca9" =~ /(.)(.)(.)${3}9/
evals/evals-freenode-#perl.lst[880]: 'abc' =~ /(a+)/; 'abc' =~ /(d+)/; [ 'bbaaccddee' =~ // ]
evals/evals-freenode-#perl.lst[881]: $_ = 'abcabcabc'; s/b(??{ ++$idx == 2 ? '' : 'no match' })/c/; $_ # except you'd never actually write code like this of course
evals/evals-freenode-#perl.lst[882]: [ "abcabca" =~ s/a.*a/CAT/r, "abcabca" =~ s/a.*?a/CAT/r ] # greedy vs not greedy
evals/evals-freenode-#perl.lst[883]: [ ("A","B"),("C","D") ]
evals/evals-freenode-#perl.lst[884]: [ 'abcd' & '1111' ]
evals/evals-freenode-#perl.lst[885]: [ "abcd123efg567h8i" =~ /([a-z]+|[0-9]+)/g ];
evals/evals-freenode-#perl.lst[886]: $_ = "abcd12ABCD"; print "[[$_]]" for  /(abcd|ABCD)/g
evals/evals-freenode-#perl.lst[887]: [ "abcd" =~ /^ab/ ]
evals/evals-freenode-#perl.lst[888]: $_="abcdaef"; print /^(a[abcd]+ef)$/ and $1 !~ /([abcd]).*\1/ ? "Yes" : "no";
evals/evals-freenode-#perl.lst[889]: $_="abcdaef"; print if /^(a[abcd]+)ef)$/ and $1 !~ /([abcd]).*\1/
evals/evals-freenode-#perl.lst[890]: $_="abcdaef"; print if /^a([abcd]+)ef$/ and $1 !~ /([abcd]).*\1/
evals/evals-freenode-#perl.lst[891]: $_="abcdaef"; print if /^a([abcd]+)ef$/ and $1 !~ /([abcd]).*\1(??{print $1})/
evals/evals-freenode-#perl.lst[892]: $_="abcdaef"; print if /^(a[abcd]+ef)$/ and $1 !~ /([abcd]).*\1/; print "done"
evals/evals-freenode-#perl.lst[893]: $_=abcda; print if /^([abcd]{1})+$/ or print "hmm"
evals/evals-freenode-#perl.lst[894]: [ 'abcdcdcd' =~ /(ab)(cd)*/ ]
evals/evals-freenode-#perl.lst[895]: [ "abcdef" =~ /^(?!.*([abcd]).*\1)a.*ef\z/s ]
evals/evals-freenode-#perl.lst[896]: $_ = "abcdef"; [ /abc(?=def)/ ? $& : 'fail' ]
evals/evals-freenode-#perl.lst[897]: "abc def" =~ /(?<first> \w+ )/x; [ $+{first} ]
evals/evals-freenode-#perl.lst[898]: 'abcdefgh' & '11111111'
evals/evals-freenode-#perl.lst[899]: [ 'abcdefgh' =~ /(ab)(..)*/ ]
evals/evals-freenode-#perl.lst[900]: [ "ABCDEFGHABCD" =~ /(?=(....))/g ]
evals/evals-freenode-#perl.lst[901]: abcdefghi
evals/evals-freenode-#perl.lst[902]: 'abcdefghi' =~ / (?{@a=()}) (?:(.)(?{push @a, $1})){4} (?= $ ) /x; \@a
evals/evals-freenode-#perl.lst[903]:  "abc,,def,ghi,,jkl" =~ s/(?<=,)(?=,)/\\N/gr
evals/evals-freenode-#perl.lst[904]: "abcdefg" =~ s/ef//; [ $-[0], length $` ]
evals/evals-freenode-#perl.lst[905]: $_ = "[a=b][c=d][e=f]"; my @matches = /(\[[^=]*=[^]]\])/g; [ @matches ]
evals/evals-freenode-#perl.lst[906]: $_ = "[a=b][c=d][e=f]"; my @matches = split /(\[[^\]]*\])/; [ @matches ]
evals/evals-freenode-#perl.lst[907]: $_ = "[a=b][c=d][e=f]"; my @matches = split /\[[^\]]*\]/; [ @matches ]
evals/evals-freenode-#perl.lst[908]: [ 'abcdef' =~ s/cd/XY/r ];
evals/evals-freenode-#perl.lst[909]: ['abcde' =~ /(?=(...))/g]
evals/evals-freenode-#perl.lst[910]: $_= /a b c d/; @vars = (split)[2,3]; \@vars
evals/evals-freenode-#perl.lst[911]: "abc" =~ /(?<gold>bc)/; $1
evals/evals-freenode-#perl.lst[912]: 'aBc' =~ m{([^a-z])}; [ $1 ]
evals/evals-freenode-#perl.lst[913]: ["a b c\n", split]
evals/evals-freenode-#perl.lst[914]: @abc = qw(a b c); [ @abc => @abc ]
evals/evals-freenode-#perl.lst[915]: @abc = qw(a b c); [ \@abc => \@abc ]
evals/evals-freenode-#perl.lst[916]: 'abc' =~ s/a//;
evals/evals-freenode-#perl.lst[917]: $_="abc"; s/a/ a /; $_
evals/evals-freenode-#perl.lst[918]: 'abc' =~ s/a//r;
evals/evals-freenode-#perl.lst[919]: [ " a b c " =~ /\s+\S+/g ]
evals/evals-freenode-#perl.lst[920]: [ " a b c " =~ /\s*\S+/g ]  # to keep first non-space
evals/evals-freenode-#perl.lst[921]:  'abc,,"this is ,, a ,, string column",ghi,,jkl' =~ s/(?<=,)(?=,)/\\N/gr
evals/evals-freenode-#perl.lst[922]: ($a, $b) = [ print("Miesco"), print("Miesco") ]
evals/evals-freenode-#perl.lst[923]: ($a, $b) = [ print("Miesco"), print("Miesco") ]; print("$a"), print("$b")
evals/evals-freenode-#perl.lst[924]: 'Abra Kadabra'->import; say 'Magic'
evals/evals-freenode-#perl.lst[925]: 'a-b' =~ s/[a\- ]//gr
evals/evals-freenode-#perl.lst[926]: ' a b ' =~ /\s\B\s/
evals/evals-freenode-#perl.lst[927]: '[a][b]' =~ s/[][]//gr
evals/evals-freenode-#perl.lst[928]: "a()[]{}<>b" =~ s/[][(){}<>]//gr
evals/evals-freenode-#perl.lst[929]: 'a-b' =~ s/[- ]//r
evals/evals-freenode-#perl.lst[930]: 'a-b' =~ s/[\- ]//r
evals/evals-freenode-#perl.lst[931]: ['A' cmp 'a']
evals/evals-freenode-#perl.lst[932]: 'a.com' =~ #(\w+\.)com$#
evals/evals-freenode-#perl.lst[933]: "a.com" =~ /(?:\w+\.)+com$/
evals/evals-freenode-#perl.lst[934]: 'a' .. 'd'
evals/evals-freenode-#perl.lst[935]: ['a' .. 'd']
evals/evals-freenode-#perl.lst[936]: add 5; sub add { $_[0]+1 }
evals/evals-freenode-#perl.lst[937]: $_ = '$addmodnav'; if(/^\$addmod/i) { if(/^\$addmod(?: )/i) { print "some other stuff" } else { print "args would be printed here" } }
evals/evals-freenode-#perl.lst[938]: $addr = PF_PACKET; $iface = "eth0"; $socket = pack("Sa14", $addr, $iface);
evals/evals-freenode-#perl.lst[939]: `adduser modulus`
evals/evals-freenode-#perl.lst[940]: ['æ' =~ /([[:alpha:]])/]
evals/evals-freenode-#perl.lst[941]: ['æ' =~ /([[:alpha:]])/a]
evals/evals-freenode-#perl.lst[942]: $_ = "æøå"; s/(.)/sprintf('\\u%04x', ord $1)/ger
evals/evals-freenode-#perl.lst[943]: $_ = "æøå"; s/(.)sprintf('\\u%04x', ord $1)/ger
evals/evals-freenode-#perl.lst[944]: "a" eq "b"
evals/evals-freenode-#perl.lst[945]: [ "a" eq "b" ]
evals/evals-freenode-#perl.lst[946]: @_ = ('a' .. 'e'); $single = @_; $single
evals/evals-freenode-#perl.lst[947]: @a = (foo => 1, bar => 2); print %{a}
evals/evals-freenode-#perl.lst[948]: @a = (foo => 1, bar => 2); print ${{@a}}{"a"}
evals/evals-freenode-#perl.lst[949]: @a = {foo => 1, bar => 2}; print ${$a}{"foo"}
evals/evals-freenode-#perl.lst[950]: $a="foo bar"; *$a = sub {"baz"}; "foo bar"->()
evals/evals-freenode-#perl.lst[951]: [ "a hash" cmp "an array" ]
evals/evals-freenode-#perl.lst[952]: @a = (); "Hello" =~ /.+(??{unshift@a,$&})/; \@a
evals/evals-freenode-#perl.lst[953]: @a = (); "Hello" =~ /.+$(??{unshift@a,$&})/; \@a
evals/evals-freenode-#perl.lst[954]:  <a href="http://www.yahoo.com/something.php?else=AoilkOoiud.FUoiu239834&ipadd=4.2.2.2&uri=a8s98loielulius_souej." min="s987ojeouyslkje"> =~ s/(<.*(src|href)="[_%&:\/\?=,\.a-z0-9-]+)[\?|#|&]ip(ad(d(r(ess?)?)?)?)?=([1-2]?[0-9]{1,2}\.[1-2]?[0-9]{1,2}\.[1-2]?[0-9]{1,2}\.[1-2]?[0-9]{1,2})([_%#&=\/\.a-z0-9-]*".*>)/$1$8/isg
evals/evals-freenode-#perl.lst[955]: $a = "it works"; print "${chr 97}"
evals/evals-freenode-#perl.lst[956]: $all = [[1,2],[4,5,6],[7,8]]; push @one, @$_ for @$all; \@one
evals/evals-freenode-#perl.lst[957]: @_ = "a"; { local @_ = "b"; } "@_"
evals/evals-freenode-#perl.lst[958]: '_' =~ /[:alpha:]/
evals/evals-freenode-#perl.lst[959]: $alpha{1}='1'; $alpha{'01'}='01'; $alpha{2}='2'; map { print "$alpha{$_},"; } sort { $a <=> $b || $alpha{$b} cmp $alpha{$a} } keys %alpha
evals/evals-freenode-#perl.lst[960]: $alpha{1}='1'; $alpha{01}='01'; $alpha{2}='2'; map { print "$alpha{$_},"; } sort { $a <=> $b || $alpha{$b} cmp $alpha{$a} } keys %alpha
evals/evals-freenode-#perl.lst[961]: $alpha{a}='1'; $alpha{b}='01'; $alpha{c}='2'; map { print "$alpha{$_},"; } sort { $a <=> $b || $alpha{$a} cmp $alpha{$b} } keys %alpha
evals/evals-freenode-#perl.lst[962]: $alpha{a}='1'; $alpha{b}='01'; $alpha{c}='2'; map { print "$alpha{$_},"; } sort { $a <=> $b || $alpha{$b} cmp $alpha{$a} } keys %alpha
evals/evals-freenode-#perl.lst[963]: $alpha{a}='1'; $alpha{b}='01'; $alpha{c}='2'; map { print "$alpha{$_},"; } sort { $b <=> $a || $alpha{$b} cmp $alpha{$a} } keys %alpha
evals/evals-freenode-#perl.lst[964]: $alpha{a}='1'; $alpha{b}='01'; $alpha{c}='2'; map { print "$alpha{$_},"; } sort { $b cmp $a || $alpha{$b} <=> $alpha{$a} } keys %alpha
evals/evals-freenode-#perl.lst[965]: "Also this: \N{PILE OF POO}"
evals/evals-freenode-#perl.lst[966]: *{$::{Altreus}}{SCALAR}
evals/evals-freenode-#perl.lst[967]: "Altreus" =~ s/^.*\Ke/s/sr
evals/evals-freenode-#perl.lst[968]: a..'m'
evals/evals-freenode-#perl.lst[969]: 'a' =~ m\a\
evals/evals-freenode-#perl.lst[970]: a..'m',N..Z
evals/evals-freenode-#perl.lst[971]: a..m=>N..Z
evals/evals-freenode-#perl.lst[972]: [ a..'m',N..Z ] # list context
evals/evals-freenode-#perl.lst[973]: and evaldev: or so.
evals/evals-freenode-#perl.lst[974]: [ ............. and in regex i have ranges []...do i parse out the [] in the regex?
evals/evals-freenode-#perl.lst[975]: [ 'a' =~ /((.))/ ] # ningu how about this?
evals/evals-freenode-#perl.lst[976]: '### An introduction to Firmware Analysis' =~ s/### (.*)/1. [$1](#\L$1)/gr
evals/evals-freenode-#perl.lst[977]: "annoy"] ["meow" is f00bot: loleval VISIBLE "meow"] [$@ is variable storing the latest error in eval {} block. It's usually better idea to not use it directly and leave it to modules such as Try::Tiny.] [1 is eval: "1"] [8-ball is {eval @t=split"/",{fact 8-ball replies};$t[rand@t]}] [[Sno]: eval isn't part of the construct, that's... [Output truncated. Use `more` to read more]
evals/evals-freenode-#perl.lst[978]: [ "Another happy day" =~ m/(.\K..?)/gc ]
evals/evals-freenode-#perl.lst[979]: @answer = (); ' foo= bar1,bar2,bar3  ' =~ / +foo= +.*?(\b\w+\d+)(?{push @answer, $1})(*FAIL)/; \@answer
evals/evals-freenode-#perl.lst[980]: "A\N{U+0327}"
evals/evals-freenode-#perl.lst[981]: any {1} 1
evals/evals-freenode-#perl.lst[982]: any {$_ eq 'a'}, 'b', 'c'
evals/evals-freenode-#perl.lst[983]: "any string" =~ /alias:any string/
evals/evals-freenode-#perl.lst[984]: $a="one"; $a = $b || undef; print $a;
evals/evals-freenode-#perl.lst[985]: $_="Äö"; [ s/[^ä]/x/gir ]
evals/evals-freenode-#perl.lst[986]: 'a' =~ /\P{In_Latin1}/
evals/evals-freenode-#perl.lst[987]: $a=[]; print !!@$a;
evals/evals-freenode-#perl.lst[988]: $a=[]; print !!$a
evals/evals-freenode-#perl.lst[989]: $a=[]; print !!${@a}
evals/evals-freenode-#perl.lst[990]: $a=[]; print !!${$a}
evals/evals-freenode-#perl.lst[991]: $a=[]; print !!$@a
evals/evals-freenode-#perl.lst[992]: $a = []; push $a, 1; $a  # right?
evals/evals-freenode-#perl.lst[993]: "a quine!: @_"
evals/evals-freenode-#perl.lst[994]: @a = qw(1 2 3); [ map { $_ == shift @a } @a ]
evals/evals-freenode-#perl.lst[995]: @a = qw( 1 one 2 two ); print "$_: $a[ $_ ] " for keys @a;
evals/evals-freenode-#perl.lst[996]: %a = qw ( 1 one 2 two ); print "$_: $a{$_}, " for keys %a
evals/evals-freenode-#perl.lst[997]: %a = qw ( 1 one 2 two ); print "$_: $a{$_}, " for keys %s
evals/evals-freenode-#perl.lst[998]: %a = qw ( 1 one 2 two ); print keys %a
evals/evals-freenode-#perl.lst[999]: %a = qw ( 1 one 2 two ); print scalar %a
evals/evals-freenode-#perl.lst[1000]: %a = qw ( 1 one 2 two ); print scalar keys %a
evals/evals-freenode-#perl.lst[1001]: @A = qw<a b c>; sprintf "%d elems: " . ("<%s>") x @A, scalar(@A), @A;
evals/evals-freenode-#perl.lst[1002]: @a = (qw/foo bar baz/); @b = map {/bar/} @a; grep !defined, @b;
evals/evals-freenode-#perl.lst[1003]: @a = (qw/foo bar baz/); @b = map {/bar/} @a; print Dumper(\@b);
evals/evals-freenode-#perl.lst[1004]: @a = (qw/foo bar baz/); [map {/bar/} @a]
evals/evals-freenode-#perl.lst[1005]: @a = (qw/foo bar baz); [map {/bar/} @a]
evals/evals-freenode-#perl.lst[1006]: @a = (qw/foo bar baz/); [map {scalar /bar/} @a]
evals/evals-freenode-#perl.lst[1007]: @a = qw(f o o); undef @a; push @a, qw( b a r );
evals/evals-freenode-#perl.lst[1008]: $a=[qw/john paul george ringo/]; $str=join(', ', '?' x scalar @$a);
evals/evals-freenode-#perl.lst[1009]: $a=[qw/john paul george ringo/]; $str=join(', ', ('?' x scalar @$a));
evals/evals-freenode-#perl.lst[1010]: @a = qw(N 123); sub f { &CORE::pack }; f(@a)
evals/evals-freenode-#perl.lst[1011]: @a = qw(N 123); sub f { &CORE::pack(@_) }; f(@a)
evals/evals-freenode-#perl.lst[1012]: <>; \@ARGV
evals/evals-freenode-#perl.lst[1013]: @ARGV
evals/evals-freenode-#perl.lst[1014]: $#ARGV
evals/evals-freenode-#perl.lst[1015]: *ARGV = [1]; print for <>;
evals/evals-freenode-#perl.lst[1016]: @ar = (); [ map { $_->{a} } @ar ]
evals/evals-freenode-#perl.lst[1017]: $ar = []; [ map { $_->{a} } @$ar ]
evals/evals-freenode-#perl.lst[1018]: arn
evals/evals-freenode-#perl.lst[1019]: @arr = ( 1, 2, 3, 4, 5 ); if ( $#arr == 4 ){ print "Total: $# arr" };
evals/evals-freenode-#perl.lst[1020]: @arr = ( 1, 2, 3, 4, 5 ); if (!@arr) { print "array was empty"; }
evals/evals-freenode-#perl.lst[1021]: @arr = ( '1','2','3','4' ); print @arr >>;
evals/evals-freenode-#perl.lst[1022]: @arr = 1; [exists $arr[-1], exists $arr[-2]]
evals/evals-freenode-#perl.lst[1023]: @arr1 = qw/ a b c /; @arr2 = @arr1;      ++$#arr1;     [ 'Arr1:', @arr1, 'Arr2:', @arr2 ] # modulus^ it seems you don't really understand that @arr1 *actually gets changed* when you do that ...
evals/evals-freenode-#perl.lst[1024]: @arr1 = qw/ a b c /; @arr2 = @arr1;      ++$#arr1;       print '@arr1: ' . join(
evals/evals-freenode-#perl.lst[1025]: @arr1 = qw/bob alan/; @arr2 = (50, 100); @foo{@arr2} = @arr1; $foo{50}
evals/evals-freenode-#perl.lst[1026]: @arr=("a","b","c"); $r=rand(++$#arr); print "$#arr ", scalar @arr, " $arr[$r]"
evals/evals-freenode-#perl.lst[1027]: @array/1
evals/evals-freenode-#perl.lst[1028]: @array = 1..10; [ join ',', map '?', @array ]  # so would this
evals/evals-freenode-#perl.lst[1029]: @array = 1..10; [ join ',', ('?') x @array ]
evals/evals-freenode-#perl.lst[1030]: @array = (1,2,3); [ \(@array) ]
evals/evals-freenode-#perl.lst[1031]: @array = (1,2,3); return join(',', @accounts);
evals/evals-freenode-#perl.lst[1032]: @array=(1..5); $array[10]
evals/evals-freenode-#perl.lst[1033]: @array = 1; for (@array) {$_ <= 100 and push @array, $_ * 2} \@array  # hehehe  (never do this :)
evals/evals-freenode-#perl.lst[1034]: @array = ( 1=>"one", 2=>"two"); %hash = @array; map { print "k:$_ v:$hash{$_}, " } @array;
evals/evals-freenode-#perl.lst[1035]: @array = ( 1=>"one", 2=>"two"); %hash = @array; map { print "k:$_ v:$hash{$_}" } @array;
evals/evals-freenode-#perl.lst[1036]: @array = ( 1=>"one", 2=>"two"); %hash = @array; map { print "k:$_ v:$hash{$_}, " } keys @array;
evals/evals-freenode-#perl.lst[1037]: @array = ( 1=>"one", 2=>"two"); %hash = @array; map { print "k:$_ v:$hash{$_}, " } keys @hash;
evals/evals-freenode-#perl.lst[1038]: @array = ( 1=>"one", 2=>"two"); %hash = @array; map { print "k:$_ v:$hash{$_}, " } keys %hash;
evals/evals-freenode-#perl.lst[1039]: $#array = -2
evals/evals-freenode-#perl.lst[1040]: @array = (45,34,67,98); @array = grep $_ != 34, @array; \@array
evals/evals-freenode-#perl.lst[1041]: @array = (45,34,67,98); @index{@array} = 0 .. $#array; splice @array, $index{34}, 1; \ @array
evals/evals-freenode-#perl.lst[1042]: @array = (45,34,67,98); splice @array, $_, 1 for grep $array[$_] == 34, reverse 0 .. $#array; \@array
evals/evals-freenode-#perl.lst[1043]: @array = ( 'a' .. 'c' ); printf "Array:" . ('%1$d - %s' x @array), 1, @array
evals/evals-freenode-#perl.lst[1044]: @array = a..j;  [ @array[-@array .. -2] ]  # entire array except for last element (without modifying array)
evals/evals-freenode-#perl.lst[1045]: @array = (('a')x55555); scalar @array
evals/evals-freenode-#perl.lst[1046]: @array = (('a')x55); scalar @array
evals/evals-freenode-#perl.lst[1047]: @array = (('a')x5); \@array
evals/evals-freenode-#perl.lst[1048]: @array = (('a')x(5x10)); scalar @array
evals/evals-freenode-#perl.lst[1049]: @array = map { $_ % 11 * int $_ / 11 } 0..120; \@array
evals/evals-freenode-#perl.lst[1050]: @array = qw(1 2 3); print "match" if(any{ $_ eq '4'} @array);
evals/evals-freenode-#perl.lst[1051]: @array = qw(1 2 3); say "match" if(any{ $_ eq '4'} @array);
evals/evals-freenode-#perl.lst[1052]: @array = qw(1,2,3); say "match" if(any{ $_ eq '4'} @array);
evals/evals-freenode-#perl.lst[1053]: @array = qw/a b c d e f/; splice @array, -1, 0, 'x'; \@array  # voila
evals/evals-freenode-#perl.lst[1054]: @array = qw/a b c d e f/; splice @array, -2, 0, 'x'; \@array
evals/evals-freenode-#perl.lst[1055]: @array = qw/a b c d e f/; splice @array, -2, 0, 'x'; \@array  # voila
evals/evals-freenode-#perl.lst[1056]: @array = qw/a b c d e f/; splice @array, scalar(@array), 0, 'x'; \@array  # voila
evals/evals-freenode-#perl.lst[1057]: @array = qw(SHOUTY SHOUT SHOUT); $_ = lc for @array; \@array
evals/evals-freenode-#perl.lst[1058]: @array = qw//; splice @array, -2, 0, 'x'; \@array
evals/evals-freenode-#perl.lst[1059]: $arrayref = ["a","b"];  "$arrayref->[1]"
evals/evals-freenode-#perl.lst[1060]: $arrayref = [ { foo => bar, baz => m00 }, { lol => lulz, schweinerei => smut } ]; $arrayref->[1]{schweinerei}
evals/evals-freenode-#perl.lst[1061]: $arrayref=[qw/a b c/]; scalar @{$arrayref}[1,2,3]
evals/evals-freenode-#perl.lst[1062]: $arrayref=[qw/a b c]; scalar @{$arrayref}[1,2,3]
evals/evals-freenode-#perl.lst[1063]: @arr='a'--'z';
evals/evals-freenode-#perl.lst[1064]: @arr = (foo => 1, bar => 2); { %{a} }
evals/evals-freenode-#perl.lst[1065]: @arr = (); if (!@arr) { print "array was empty"; }
evals/evals-freenode-#perl.lst[1066]: $arr = []; push $arr, 1; $arr
evals/evals-freenode-#perl.lst[1067]: @arr=qw/a b c/; $b = 3; printf "this :".("%d %s |" x @arr), $b, @arr;
evals/evals-freenode-#perl.lst[1068]: @arr=qw/a b c/; @bong = (1..@arr); printf "this :".("%d %s |" x @arr), @bong, @arr;
evals/evals-freenode-#perl.lst[1069]: @arr=qw/a b c/; $bong = 3; printf "this :".("%d %s |" x @arr), $bong, @arr;
evals/evals-freenode-#perl.lst[1070]: @arr=qw/a b c/; sprintf "%d: '%s', " x @arr, %arr[0 .. $#arr]
evals/evals-freenode-#perl.lst[1071]: @arr=qw/a b c/; $x = 3; printf '%.0s' . ('%1$d %s |' x @arr), $x, @arr;
evals/evals-freenode-#perl.lst[1072]: @arr=qw/a b c/; $x = 3; printf '%1$d %s' x @arr, $x, @arr;
evals/evals-freenode-#perl.lst[1073]: @arr = qw(one two three); sub f{print@{$_[0]}}f*{arr}{ref[]};
evals/evals-freenode-#perl.lst[1074]: @arr = qw(one two three); sub f{print@{$_[0]}}f*{arr}{ref[]}; <-- *{arr}{ref[]}? o_O
evals/evals-freenode-#perl.lst[1075]: @arr = undef; if (!@arr) { print "array was empty"; }
evals/evals-freenode-#perl.lst[1076]: @ar = (undef); [ map { $_->{a} } @ar ]
evals/evals-freenode-#perl.lst[1077]: $ar = [undef]; [ map { $_->{a} } @$ar ]
evals/evals-freenode-#perl.lst[1078]: [ 'a' =~ s/(.)/('$1','$1')/re ]
evals/evals-freenode-#perl.lst[1079]: [ 'a' =~ s/(.)/($1,$1)/re ]
evals/evals-freenode-#perl.lst[1080]: [ 'a' =~ s/(.)/($1) x 2/re ]
evals/evals-freenode-#perl.lst[1081]: $a=++$$.s/../$$/;$$<<~~+$a
evals/evals-freenode-#perl.lst[1082]: 'A' =~ s/(A)/lcfirst $1/re
evals/evals-freenode-#perl.lst[1083]: $_="Ä"; [ s/ä/x/ir ]
evals/evals-freenode-#perl.lst[1084]: [ "asd1312321asd1212asd121212" =~/(asd\d+)/g ]
evals/evals-freenode-#perl.lst[1085]: ~"asdf"
evals/evals-freenode-#perl.lst[1086]: $asdf = []; 0 + !!@$blah
evals/evals-freenode-#perl.lst[1087]: "asdf" =~ /(.)+/; [ $1 ]
evals/evals-freenode-#perl.lst[1088]: $asdf=[1,2]; !!@$asdf;
evals/evals-freenode-#perl.lst[1089]: $asdf=[]; !!@$asdf;
evals/evals-freenode-#perl.lst[1090]: "asd.fg.foo.asd.fg" =~ /(.*)\.([^.]*)\.\1/
evals/evals-freenode-#perl.lst[1091]: $asdf=[]; print !!@$asdf;
evals/evals-freenode-#perl.lst[1092]: "        asdf    " =~ /^([\t ]+)/; my $indents = () = $1 =~ /(\t| {4})/g
evals/evals-freenode-#perl.lst[1093]: "        asdf    " =~ /^([\t ]+)/; my $indents = () = $1 =~ /(\t| {8})/g
evals/evals-freenode-#perl.lst[1094]: "        asdf    " =~ /^([\t\s]+)/; my $indents = () = $1 =~ /(\t|\s{4})/g
evals/evals-freenode-#perl.lst[1095]: "        asdf    " =~ /^[\t\s]+/; my $indents = () = $1 =~ /(\t|\s{4})/g
evals/evals-freenode-#perl.lst[1096]: ("asdfX" ^ "asdfY") =~ /^\0*[^\0]\z/ ? 'yes' : 'no'
evals/evals-freenode-#perl.lst[1097]: ("asdfYt" ^ "asdfY") =~ /^\0*[^\0]\z/ ? 'yes' : 'no'
evals/evals-freenode-#perl.lst[1098]: [ "asd   qwe" =~ /(\w+)\s(\w+?)/ ]
evals/evals-freenode-#perl.lst[1099]: [ "asd   qwe" =~ /(\w+)\s+(\w+?)/ ]
evals/evals-freenode-#perl.lst[1100]: "a" =~ s/(.)/\l$1/r
evals/evals-freenode-#perl.lst[1101]: "A" =~ s/(.)/\l$1/r
evals/evals-freenode-#perl.lst[1102]: @a = split //, 123456; join '', @a[map $_^1, 0..$#a]
evals/evals-freenode-#perl.lst[1103]: "a string literal" ~~ ["a string literal"]
evals/evals-freenode-#perl.lst[1104]: [ "a string literal" ] ~~ "a string literal"
evals/evals-freenode-#perl.lst[1105]: ["a string literal"] ~~ ["a string literal", "another string literal"]
evals/evals-freenode-#perl.lst[1106]: { a => sub { print 'foo' } }->{a}()
evals/evals-freenode-#perl.lst[1107]: atan(0, -1)
evals/evals-freenode-#perl.lst[1108]: atan2(0, -1)
evals/evals-freenode-#perl.lst[1109]: 'atcg' ^ 'agcg'
evals/evals-freenode-#perl.lst[1110]: $a='the quick brown fox jumped over the lazy dogs'; $a=~s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $a;
evals/evals-freenode-#perl.lst[1111]: $a="the quick brown fox jumped over the lazy dogs"; $a=~s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $a
evals/evals-freenode-#perl.lst[1112]: "Ã\u{0086}ther"
evals/evals-freenode-#perl.lst[1113]: "Ã\u0086ther"
evals/evals-freenode-#perl.lst[1114]: $a=[]; use print !!$a
evals/evals-freenode-#perl.lst[1115]: ("a" x 20) =~ /a*b/;
evals/evals-freenode-#perl.lst[1116]: [ ("a" x 20) =~ /(a*b)/ ];
evals/evals-freenode-#perl.lst[1117]: [ ("a" x 20 . "b") =~ /((a*?)*b)/ ];
evals/evals-freenode-#perl.lst[1118]: [ ("a" x 20 . "b") =~ /((a*)*b)/ ];
evals/evals-freenode-#perl.lst[1119]: [ ("a" x 20 . "b") =~ /((a+?)*b)/ ];
evals/evals-freenode-#perl.lst[1120]: [ ("a" x 20 . "b") =~ /((a+)*b)/ ];
evals/evals-freenode-#perl.lst[1121]: [ ("a" x 20 . "b") =~ /(a*?b)/ ];
evals/evals-freenode-#perl.lst[1122]: 'a' x 3
evals/evals-freenode-#perl.lst[1123]: [('a'++)x3]
evals/evals-freenode-#perl.lst[1124]: [ ("a" x 30) =~ /((a|a?)+)/ ];
evals/evals-freenode-#perl.lst[1125]: ['a' x 4]
evals/evals-freenode-#perl.lst[1126]: [('a') x 4]
evals/evals-freenode-#perl.lst[1127]: ('a,'x45) =~ s/(.*?,){10}\K/\n/gr
evals/evals-freenode-#perl.lst[1128]: [ 'a' x 'b' ]
evals/evals-freenode-#perl.lst[1129]: [ 'axcom' =~ /a.com/ ? 'yes' : 'no' ]
evals/evals-freenode-#perl.lst[1130]: ["a" xor "a"]
evals/evals-freenode-#perl.lst[1131]: "A-Z" =~ /A-Z/ ? 'true' : 'false'
evals/evals-freenode-#perl.lst[1132]: '_[a-z]+_(bd\d+_[a-z0-9]{7}_\d{6}_\d{4}(AM|PM)_PST).tar.gz'
evals/evals-freenode-#perl.lst[1133]: "\\\\\\\\$backup_server\\\\$host"
evals/evals-freenode-#perl.lst[1134]: "\\\\\\\\backup_server\\\\host"
evals/evals-freenode-#perl.lst[1135]: "banana" =~ /(a)/; [ @- ]
evals/evals-freenode-#perl.lst[1136]: "banana" =~ /(a)/; \@-
evals/evals-freenode-#perl.lst[1137]: "banana" =~ /a/; \@-
evals/evals-freenode-#perl.lst[1138]: [ "banana" =~ ?a? ]
evals/evals-freenode-#perl.lst[1139]: [ "banana" =~ /.a/g ]
evals/evals-freenode-#perl.lst[1140]: () = 'banana' =~ /(?=ana)/g
evals/evals-freenode-#perl.lst[1141]: "banana" =~ /apple/; join //, qw(foo bar baz)
evals/evals-freenode-#perl.lst[1142]: "banana" =~ /b(a)/; [ @- ]
evals/evals-freenode-#perl.lst[1143]: "banana" =~ /(b|a|n)/g; [@-]
evals/evals-freenode-#perl.lst[1144]: ('banana' ^ 'batman') =~ s/(.)/chr(ord "0" + !ord $1)/ger
evals/evals-freenode-#perl.lst[1145]: ('banana' ^ 'batman') =~ s/(.)/chr(ord "0" + ord $1)/ger
evals/evals-freenode-#perl.lst[1146]: ('banana' ^ 'batma') =~ s/(.)/chr(ord "0" + !ord $1)/ger
evals/evals-freenode-#perl.lst[1147]: $_ = "banana"; $from =~ /$_/i; [$from, $_]
evals/evals-freenode-#perl.lst[1148]: $_ = "banana"; $from =~ /$_/i; [$from, $_, scalar /$_/i]
evals/evals-freenode-#perl.lst[1149]: bananas
evals/evals-freenode-#perl.lst[1150]: "banana" =~ s/a/o/gr
evals/evals-freenode-#perl.lst[1151]: $_ = "banana"; [ s/(ba)/bo/ ]
evals/evals-freenode-#perl.lst[1152]: $_ = "banana"; s/./sprintf '%2x', ord $&/ge; $_
evals/evals-freenode-#perl.lst[1153]: "banana" =~ s/(.)/sprintf "\\x%x", $1/gers
evals/evals-freenode-#perl.lst[1154]: "banana" =~ s/(.)/sprintf "\\x%x", ord $1/gers
evals/evals-freenode-#perl.lst[1155]: ('banan' ^ 'batman') =~ s/(.)/chr(ord "0" + !ord $1)/ger
evals/evals-freenode-#perl.lst[1156]: "banannas" =~ /anna/
evals/evals-freenode-#perl.lst[1157]: -(-bar)
evals/evals-freenode-#perl.lst[1158]: 'bar'
evals/evals-freenode-#perl.lst[1159]: 'bar'+0
evals/evals-freenode-#perl.lst[1160]: $_ = "barbb"; my $count = 0 + s/b//g; [ $count, length($_), $_ ]
evals/evals-freenode-#perl.lst[1161]: [ $_ = "barbb") =~ s/b//g ]
evals/evals-freenode-#perl.lst[1162]: $_ = " bar"; /(foo)? (bar); [$1, $2]
evals/evals-freenode-#perl.lst[1163]: $_ = " bar"; /(foo)? (bar)/; [$1, $2]
evals/evals-freenode-#perl.lst[1164]: -(-'bar') # lul wat?
evals/evals-freenode-#perl.lst[1165]: "B" =~ /A-Z/ ? 'true' : 'false'
evals/evals-freenode-#perl.lst[1166]: $bday="1/1/1980"; ($byear) = $bday =~/(\d{4})/; print "".(localtime)[5]+1900 - $byear
evals/evals-freenode-#perl.lst[1167]: $bday="1/1/1980"; ($byear) = $bday =~/(\d{4})/; print "".(localtime(time))[5]+1900 - $byear
evals/evals-freenode-#perl.lst[1168]: "bead^corn" =~ /d^/
evals/evals-freenode-#perl.lst[1169]: 'beans [and rice]' =~ s/[]]/--> ] <--/r
evals/evals-freenode-#perl.lst[1170]: "beans" . ' ' . "cornbread"
evals/evals-freenode-#perl.lst[1171]: BEGIN(<>)
evals/evals-freenode-#perl.lst[1172]: BEGIN { *buffalo:: = \%::; } *buffalo::buffalo::buffalo::buffalo
evals/evals-freenode-#perl.lst[1173]: BEGIN { *CORE::GLOBAL::defined = sub { 42 }; } defined
evals/evals-freenode-#perl.lst[1174]: BEGIN { *CORE::GLOBAL::ref = sub { 42 }; }  ref 42
evals/evals-freenode-#perl.lst[1175]: BEGIN { *CORE::GLOBAL::ref = sub { "er, wait" }; }  ref 42
evals/evals-freenode-#perl.lst[1176]: BEGIN { *CORE::GLOBAL::time = sub { 'override' } } *CORE::GLOBAL::time = \&CORE::time; time()
evals/evals-freenode-#perl.lst[1177]: BEGIN { *CORE::GLOBAL::time = sub { 'override' } } [ time(), CORE::time() ]
evals/evals-freenode-#perl.lst[1178]:  BEGIN { *foo = sub (&) { shift->("wibble") } } foo { [ @_ ] }
evals/evals-freenode-#perl.lst[1179]:  BEGIN { *foo = sub (&) { shift->("wibble") } foo { [ @_ ] }
evals/evals-freenode-#perl.lst[1180]: BEGIN { $^H = 0 }; open $fh, ">", \$str; $fh->say('asdf'); [ $str ]
evals/evals-freenode-#perl.lst[1181]: BEGIN { $^H = 0 }; open $fh, ">", \$str; say {$fh} 'asdf'; [ $str ]
evals/evals-freenode-#perl.lst[1182]: BEGIN { $^H = 0 }; open $fh, ">", \$str; say $fh 'asdf'; [ $str ]
evals/evals-freenode-#perl.lst[1183]: BEGIN { $^H = 0 }; open $fh, ">", \$str; say {$fh} 'main'; [ $str ]
evals/evals-freenode-#perl.lst[1184]: BEGIN { $^H = 0 }; say 42;
evals/evals-freenode-#perl.lst[1185]: BEGIN { $^H = 0 }; say {$fh} 'main';
evals/evals-freenode-#perl.lst[1186]: BEGIN { $^H{q} = sub {}; $^H |= 0x8000; } defined 'foo'
evals/evals-freenode-#perl.lst[1187]: BEGIN { *keyys = \&CORE::keys; } my %foo = 1 .. 10; [ keyys %foo ]
evals/evals-freenode-#perl.lst[1188]: BEGIN { *main::defined = sub { !1 } } defined("womble") ? "yes" : "no"
evals/evals-freenode-#perl.lst[1189]: BEGIN{ my $p = \__PACKAGE__; &Internals::SvREADONLY($p, 0); $$p = 'foo'; } [ caller(0) ]
evals/evals-freenode-#perl.lst[1190]: BEGIN{ my $p = \__PACKAGE__; &Internals::SvREADONLY($p, 0); $$p = 'foo'; } [ __PACKAGE__ ]
evals/evals-freenode-#perl.lst[1191]: BEGIN { no strict 'refs'; *$_ = sub () :lvalue { state $x; $x } for qw/foo bar baz/; } foo = 1; bar = 2; baz = 3; [ foo, bar, baz ] # works for whatever
evals/evals-freenode-#perl.lst[1192]: BEGIN { overload::constant integer => sub { state $x = 5; $x++ }; } my $foo = "5"; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say "surprise!" }
evals/evals-freenode-#perl.lst[1193]: BEGIN { package X; *::defined = \&::defined; } sub defined { 42 } defined
evals/evals-freenode-#perl.lst[1194]: BEGIN { $SIG{__DIE__} = sub { say 42; exit  };  }  a bc
evals/evals-freenode-#perl.lst[1195]: BEGIN { $SIG{__DIE__} = sub { say 42; return  };  }  a bc
evals/evals-freenode-#perl.lst[1196]: BEGIN { $::{true} = \!!1; $::{false} = \!!0 }; [ map { 0+$_, ''.$_, \$_ } true, false, !!0, !!1 ];
evals/evals-freenode-#perl.lst[1197]: BEGIN{$^W=1}join+($x)x101
evals/evals-freenode-#perl.lst[1198]: BEGIN { $::{wtf} = \"hi"; } "wtf"->();
evals/evals-freenode-#perl.lst[1199]: BEGIN { $::{wtf} = \"hi"; } wtf()
evals/evals-freenode-#perl.lst[1200]: BEGIN { $::{wtf} = \"hi"; } wtf( "bleh" )
evals/evals-freenode-#perl.lst[1201]: BEGIN { $::{wtf} = \"hi"; } (\&wtf)->()  # runtime call
evals/evals-freenode-#perl.lst[1202]: ["big endian: " . 0x0000_0072, "little endian: " . 0x7200_0000 ]
evals/evals-freenode-#perl.lst[1203]: "big fan of Fred, Frederick, and Wilma." =~ s/\b(Fred|Wilma)\b/Barney/gr
evals/evals-freenode-#perl.lst[1204]: () = bike .. care
evals/evals-freenode-#perl.lst[1205]: `/bin/ls`
evals/evals-freenode-#perl.lst[1206]: `/bin/ls`; $!
evals/evals-freenode-#perl.lst[1207]: binmode select; print chr 8305
evals/evals-freenode-#perl.lst[1208]: binmode STDOUT; a^"☹"^b
evals/evals-freenode-#perl.lst[1209]: binmode STDOUT; "♡"^b^u^u
evals/evals-freenode-#perl.lst[1210]: binmode STDOUT; $_ = "CaMeL cAsE   iS sIlLy!  "; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
evals/evals-freenode-#perl.lst[1211]: binmode STDOUT; $_ = "CaMeL cAsE   iS sIlLy! ?"; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
evals/evals-freenode-#perl.lst[1212]: binmode STDOUT; $_ = "CaMeL cAsE   iS sIlLy! "; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
evals/evals-freenode-#perl.lst[1213]: binmode STDOUT; $_ = "CaMeL cAsE  iS sIlLy! "; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
evals/evals-freenode-#perl.lst[1214]: binmode STDOUT; $_ = "CaMeL cAsE iS sIlLy! "; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
evals/evals-freenode-#perl.lst[1215]: binmode STDOUT; $_ = "CaMeL cAsE iS sIlLy!"; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
evals/evals-freenode-#perl.lst[1216]: binmode STDOUT; Encode::decode("utf-8", "\x99\x99\x99\x99\x99\x99")
evals/evals-freenode-#perl.lst[1217]: binmode STDOUT; $_ = "Just another Perl/BIDI Hacker,"; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
evals/evals-freenode-#perl.lst[1218]: binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\x20-\x7f][\xff00-\xff5f]r;
evals/evals-freenode-#perl.lst[1219]: binmode STDOUT; my @d = qw( ‭ ‮ ); print "$_$d[rand 2]" for 'a'..'z'
evals/evals-freenode-#perl.lst[1220]: binmode STDOUT; "\N{SPARKLE}";
evals/evals-freenode-#perl.lst[1221]: binmode STDOUT; 'Perl can be awesome, sometimes,' =~ s,([\x20-\x7f]),chr(ord($1)-0x20+0xff00),gre;
evals/evals-freenode-#perl.lst[1222]: binmode STDOUT; 'Perl can be awesome, sometimes,' =~ s[([\x20-\x7f])][chr(ord($1)-0x20+0xff00)]gre;
evals/evals-freenode-#perl.lst[1223]: binmode STDOUT; 'Perl can be awesome, sometimes,' =~ s[(\x20-\x7f)][chr(ord($1)-0x20+0xff00)]gre;
evals/evals-freenode-#perl.lst[1224]: binmode STDOUT; 'Perl can be awesome, sometimes,' =~ tr[\x20-\x7f][\x{ff00}-\x{ff5f}]r;
evals/evals-freenode-#perl.lst[1225]: binmode STDOUT; 'Perl can be icky, lotsa times, <-ctrlc' =~ s/([\x0-\x7f])/$1/gre;
evals/evals-freenode-#perl.lst[1226]: binmode STDOUT; 'Perl can be icky, lotsa times, <-ctrlc' =~ s/([\x0-\x7f])/chr(32^ord($1))/gre;
evals/evals-freenode-#perl.lst[1227]: binmode STDOUT; 'Perl can be icky, lotsa times, <-ctrlc' =~ s/([\x20-\x7f])/$1/gre;
evals/evals-freenode-#perl.lst[1228]: binmode STDOUT; 'Perl can be icky, lotsa times, <-ctrlc' =~ s/([\x20-\x7f])/$i/gre;
evals/evals-freenode-#perl.lst[1229]: binmode STDOUT; 'Perl can be icky, lotsa times,' =~ s/([\x20-\x7f])/(chr(ord($1)-0x20+0xff00)/gre;
evals/evals-freenode-#perl.lst[1230]: binmode STDOUT; 'Perl can be icky, lotsa times,' =~ s/([\x20-\x7f])/chr(ord($1)-0x20+0xff00)/gre;
evals/evals-freenode-#perl.lst[1231]: binmode STDOUT; 'Perl can be icky, lotsa times, ' =~ s/([\x20-\x7f])/$_/gre;
evals/evals-freenode-#perl.lst[1232]: binmode STDOUT; 'Perl can be icky, lotsa times,  =~ s/([\x20-\x7f])/$i/gre;
evals/evals-freenode-#perl.lst[1233]: binmode STDOUT; print "\x{1f4a9}"
evals/evals-freenode-#perl.lst[1234]: binmode STDOUT, ':raw'; print grep { /\d/ } map { chr } 0x1..0xe50 # for pink_mist's irssi
evals/evals-freenode-#perl.lst[1235]: binmode STDOUT, ':raw'; print grep { /\d/ } map { chr } 0x11067..0x10ffff # how about these fonts ;)
evals/evals-freenode-#perl.lst[1236]: binmode STDOUT, ':raw'; print grep { /\d/ } map { chr } 1..0x10ffff
evals/evals-freenode-#perl.lst[1237]: binmode STDOUT; srand 42; my @o = ("\x{202d}", "\x{202e}"); print "$o[rand 2]$_" for split //, "rJust anekocath ehder oUcin";
evals/evals-freenode-#perl.lst[1238]: $bla = (12, 13); $bla
evals/evals-freenode-#perl.lst[1239]: ($bla = ($bli, $blu)) = (12, 13, 14); [$bla, $bli, $blu]
evals/evals-freenode-#perl.lst[1240]: 'blah blah '\'' blah blah '\'' blah blah'
evals/evals-freenode-#perl.lst[1241]: 'blah' . print "a" . 'blah' . print "b"
evals/evals-freenode-#perl.lst[1242]: [ "blah" =~ s/bl/h/r ]
evals/evals-freenode-#perl.lst[1243]: $blah = { x=>1 }; $z => { y=>$blah->{x} }; $blah->{x} = "hello"; $z->{y}
evals/evals-freenode-#perl.lst[1244]: "blalapi0" =~ /^lapi0$/ ? "match" : "no match"
evals/evals-freenode-#perl.lst[1245]: "bleep"->bloop
evals/evals-freenode-#perl.lst[1246]: [ "blehAAtingtongtangTTthe cat" =~ m/(AA.{1,23}TT)/ ]
evals/evals-freenode-#perl.lst[1247]: $bleh = sub { print $_[0]; }; $bleh->("two");
evals/evals-freenode-#perl.lst[1248]: $bleh = sub { print "$_" }; $bleh->("one");
evals/evals-freenode-#perl.lst[1249]: $bleh = sub { print "$_" }; $bleh->("two");
evals/evals-freenode-#perl.lst[1250]: $bleh = sub { print shift }; $bleh->("two");
evals/evals-freenode-#perl.lst[1251]: bless {}, ""
evals/evals-freenode-#perl.lst[1252]: "" . bless {}, "0"
evals/evals-freenode-#perl.lst[1253]: bless [], "\0" # or something
evals/evals-freenode-#perl.lst[1254]: "" . bless {}, "ARRAY"
evals/evals-freenode-#perl.lst[1255]: bless \do { my $nou = undef }, "trolol"
evals/evals-freenode-#perl.lst[1256]: bless {}, pack("ll",0xFEEDFACE,0xDEADBEEF)
evals/evals-freenode-#perl.lst[1257]: bless []; [ ref \%main:: ]
evals/evals-freenode-#perl.lst[1258]: bless []; [ ref %main:: ]
evals/evals-freenode-#perl.lst[1259]: '' . bless {}, 'Some::Class'
evals/evals-freenode-#perl.lst[1260]: bless \undef, "trolol"
evals/evals-freenode-#perl.lst[1261]: bless you
evals/evals-freenode-#perl.lst[1262]: bless \'you', 'Altreus'
evals/evals-freenode-#perl.lst[1263]: bless([], "your::face")->import(42);
evals/evals-freenode-#perl.lst[1264]: Blubb->new
evals/evals-freenode-#perl.lst[1265]: "bold test end bold"
evals/evals-freenode-#perl.lst[1266]: " *bold* _underline_ /italics/ normal "
evals/evals-freenode-#perl.lst[1267]: 'bool' gt '_Bool'
evals/evals-freenode-#perl.lst[1268]: [ 'boooo' =~ /\w*(.)\1\w*/g ]
evals/evals-freenode-#perl.lst[1269]: "btw, you can do the same kind of thing with trigger.pl"
evals/evals-freenode-#perl.lst[1270]: "but not this" =~ m/^(a+)/ and $+[1]
evals/evals-freenode-#perl.lst[1271]: but where do i put the test?
evals/evals-freenode-#perl.lst[1272]: buu
evals/evals-freenode-#perl.lst[1273]: "b"x10e10
evals/evals-freenode-#perl.lst[1274]: "\^C"
evals/evals-freenode-#perl.lst[1275]: $^C
evals/evals-freenode-#perl.lst[1276]: $c = 0; [ ' foo (bar (baz) quux (blop)) ' =~ s/[()]/$& eq '(' ? $c++ ? '[' : $& : --$c ? ']' : $&/ger ]
evals/evals-freenode-#perl.lst[1277]: $c = 1; while(my $e = glob "{foo,bar}") {print $c++, ") ", $e, "    "}
evals/evals-freenode-#perl.lst[1278]: (caller(1))[3]
evals/evals-freenode-#perl.lst[1279]: $(caller(1))[3]
evals/evals-freenode-#perl.lst[1280]: ${(caller(1))}[3]
evals/evals-freenode-#perl.lst[1281]: ""->can("foo");
evals/evals-freenode-#perl.lst[1282]: '.canvas_container' =~ /\b\.canvas/
evals/evals-freenode-#perl.lst[1283]: ($capt) = 'hello world' =~ /(hello)/
evals/evals-freenode-#perl.lst[1284]: ($capt) = 'hello world' =~ /(hello)/; $cap
evals/evals-freenode-#perl.lst[1285]: ($capt) = 'hello world' =~ /(hello)/; $capt
evals/evals-freenode-#perl.lst[1286]: carp 'haha'; with 'use Carp' it would run
evals/evals-freenode-#perl.lst[1287]: [ "cat 10" =~ /(?:cat|dog)\s(\d+)/ ]
evals/evals-freenode-#perl.lst[1288]: [ "cat 10" =~ /(?:cat)|(?:dog)\s(\d+)/ ]
evals/evals-freenode-#perl.lst[1289]: [ 'catdog' =~ /(?=(\w{2}))./sg ]
evals/evals-freenode-#perl.lst[1290]: [ 'catdog' =~ /(\w\K\w)/g ]
evals/evals-freenode-#perl.lst[1291]: cats
evals/evals-freenode-#perl.lst[1292]: ~'cats'
evals/evals-freenode-#perl.lst[1293]: "@cats"
evals/evals-freenode-#perl.lst[1294]: [ "" || "cats" ]
evals/evals-freenode-#perl.lst[1295]: +"cats"
evals/evals-freenode-#perl.lst[1296]: "cats and dogs say hello world" =~ /hello world/
evals/evals-freenode-#perl.lst[1297]: $cats = "cats"; $cats =~ s{$cats}'$dogs'r
evals/evals-freenode-#perl.lst[1298]: $cats = "meow"; printf '"many cats %s"', $cats
evals/evals-freenode-#perl.lst[1299]: $cats = "meow"; [qq("many cats $cats")]
evals/evals-freenode-#perl.lst[1300]: $cats = "meow"; [ sprintf '"many cats %s"', $cats ]
evals/evals-freenode-#perl.lst[1301]: "cats" =~ m pcatsp
evals/evals-freenode-#perl.lst[1302]: "cats" =~ s'cats'$dogs'r
evals/evals-freenode-#perl.lst[1303]: 'cats' =~ s/(.)/\U$1/gr
evals/evals-freenode-#perl.lst[1304]: "cats"->${ \sub {$_[0]} }
evals/evals-freenode-#perl.lst[1305]: () = "C++" =~ /\b/g
evals/evals-freenode-#perl.lst[1306]: [ "\cC" ]
evals/evals-freenode-#perl.lst[1307]: "c" == "d"
evals/evals-freenode-#perl.lst[1308]: "\cD" eq "\x04"
evals/evals-freenode-#perl.lst[1309]: ceil(log(~0)/log(2))
evals/evals-freenode-#perl.lst[1310]: char 0x3b
evals/evals-freenode-#perl.lst[1311]: char 0x7b
evals/evals-freenode-#perl.lst[1312]: char(2**16)
evals/evals-freenode-#perl.lst[1313]: char(2*16)					        [13:56]
evals/evals-freenode-#perl.lst[1314]: char('a')^char('A')
evals/evals-freenode-#perl.lst[1315]: @charmap = qw/Botje!!!/; @charmap->[qw/Botje/]
evals/evals-freenode-#perl.lst[1316]: @charmap = undef; \@charmap
evals/evals-freenode-#perl.lst[1317]: charnames::viacode(0x666)
evals/evals-freenode-#perl.lst[1318]: charnames::viacode(0xdf)
evals/evals-freenode-#perl.lst[1319]: [chomp($_="")]
evals/evals-freenode-#perl.lst[1320]: chr 0b01000001
evals/evals-freenode-#perl.lst[1321]: [ chr 0b1111_1111 ]
evals/evals-freenode-#perl.lst[1322]: chr 0x064b
evals/evals-freenode-#perl.lst[1323]: chr 0x064e
evals/evals-freenode-#perl.lst[1324]: [chr 0x11b, \x{11b}]
evals/evals-freenode-#perl.lst[1325]: chr 0x1F5FE
evals/evals-freenode-#perl.lst[1326]: chr(0x30)
evals/evals-freenode-#perl.lst[1327]: chr 0x3b
evals/evals-freenode-#perl.lst[1328]: chr 0x71
evals/evals-freenode-#perl.lst[1329]: chr 0x7b
evals/evals-freenode-#perl.lst[1330]: chr 0xe2
evals/evals-freenode-#perl.lst[1331]: chr 0xe9
evals/evals-freenode-#perl.lst[1332]: chr 0xfb06
evals/evals-freenode-#perl.lst[1333]: chr(171)
evals/evals-freenode-#perl.lst[1334]: chr(173) =~ /\N{SOFT HYPHEN}/;
evals/evals-freenode-#perl.lst[1335]: chr(173) =~ /\N{U+AD}/;
evals/evals-freenode-#perl.lst[1336]: chr(173) =~ /\xad/;
evals/evals-freenode-#perl.lst[1337]: chr(173) =~ /\xAD/;
evals/evals-freenode-#perl.lst[1338]: chr(2 << 15)
evals/evals-freenode-#perl.lst[1339]: chr(2**16)					        [13:56]
evals/evals-freenode-#perl.lst[1340]: chr 232
evals/evals-freenode-#perl.lst[1341]: ${\chr 24}
evals/evals-freenode-#perl.lst[1342]: chr 24
evals/evals-freenode-#perl.lst[1343]: chr 33
evals/evals-freenode-#perl.lst[1344]: chr 34
evals/evals-freenode-#perl.lst[1345]: chr 39
evals/evals-freenode-#perl.lst[1346]: [chr(48) .. chr(48)]
evals/evals-freenode-#perl.lst[1347]: [chr(48) .. chr(58)]
evals/evals-freenode-#perl.lst[1348]: [chr 49, chr 10]
evals/evals-freenode-#perl.lst[1349]: chr 5000000000
evals/evals-freenode-#perl.lst[1350]: chr(51) . chr(76)
evals/evals-freenode-#perl.lst[1351]: [chr(60) .. chr(88)]
evals/evals-freenode-#perl.lst[1352]: chr 65
evals/evals-freenode-#perl.lst[1353]: [chr(65) .. chr(100)]
evals/evals-freenode-#perl.lst[1354]: [chr(65), chr(100)]
evals/evals-freenode-#perl.lst[1355]: [chr(65] .. chr(100)]
evals/evals-freenode-#perl.lst[1356]: chr 8304
evals/evals-freenode-#perl.lst[1357]: \chr 8305
evals/evals-freenode-#perl.lst[1358]: chr 8305
evals/evals-freenode-#perl.lst[1359]: chr 86;
evals/evals-freenode-#perl.lst[1360]: chr 9585.5
evals/evals-freenode-#perl.lst[1361]: chr('a')^chr('A')
evals/evals-freenode-#perl.lst[1362]: [chr(hex "3c"), "\x3c"]
evals/evals-freenode-#perl.lst[1363]: chr(ord('a') + 2)
evals/evals-freenode-#perl.lst[1364]: $c = join ',', a..z, A..Z, 0..9; [ glob "{$c}" x 2 ]
evals/evals-freenode-#perl.lst[1365]: close(STDIN); close(STDOUT); close(STDERR); print "I have no mouth and I must scream"
evals/evals-freenode-#perl.lst[1366]: { Clubs => [ { Url => 'foo.com' } ] }->{Clubs}[0]{Url}
evals/evals-freenode-#perl.lst[1367]: <code>
evals/evals-freenode-#perl.lst[1368]: [$_, $code]
evals/evals-freenode-#perl.lst[1369]: [$code]
evals/evals-freenode-#perl.lst[1370]: $code
evals/evals-freenode-#perl.lst[1371]: code; also pleval deparse rbeval jseval pyeval phpeval k20eval luaeval jeval.
evals/evals-freenode-#perl.lst[1372]: <code here>
evals/evals-freenode-#perl.lst[1373]: $code =~ s/^[^\$]*/eval: /r
evals/evals-freenode-#perl.lst[1374]: $code =~ s/.*?\$/\$/r; # small quine
evals/evals-freenode-#perl.lst[1375]: $code = sub { return () }; @r = (1,2,3); push @r, $code->(); \@r
evals/evals-freenode-#perl.lst[1376]: $color = 'green'; $ref = \$color; $$ref = 'blue'; $color
evals/evals-freenode-#perl.lst[1377]: @color = qw(blue white red); print $color[$#color];
evals/evals-freenode-#perl.lst[1378]: @color = qw(blue white red); print $color[eval($#color)];
evals/evals-freenode-#perl.lst[1379]: @color = qw(blue white red); print $color[rand($#color)];
evals/evals-freenode-#perl.lst[1380]: command of perlbot, that's useful to perlbot to display things properly
evals/evals-freenode-#perl.lst[1381]: COMMAND --password
evals/evals-freenode-#perl.lst[1382]: "COMPRESSION_GZIP" eq "COMPRESS_GZIP" # let's ask perl
evals/evals-freenode-#perl.lst[1383]: $_ = "  Computer  "; [ s/^ +| +$| Computer //gr, s/ Computer |^ +| +$//gr ]
evals/evals-freenode-#perl.lst[1384]: $_ = "C omputer"; [ s/ |Computer//gr; s/ //gr =~ s/Computer//gr ]
evals/evals-freenode-#perl.lst[1385]: $Config{osname}
evals/evals-freenode-#perl.lst[1386]: *CONST = sub { 'haha' }; CONST
evals/evals-freenode-#perl.lst[1387]: *CONST = sub { 'haha' }; CONST()
evals/evals-freenode-#perl.lst[1388]: copy("$alt", "$neu");
evals/evals-freenode-#perl.lst[1389]: CORE::dump()
evals/evals-freenode-#perl.lst[1390]: [CORE::fc '€']
evals/evals-freenode-#perl.lst[1391]: &CORE::for () CORE::for ();
evals/evals-freenode-#perl.lst[1392]: CORE::GLOBAL::gmtime 0
evals/evals-freenode-#perl.lst[1393]: CORE::gmtime
evals/evals-freenode-#perl.lst[1394]: CORE::gmtime 0
evals/evals-freenode-#perl.lst[1395]: CORE::gmtime 'NaN'
evals/evals-freenode-#perl.lst[1396]: \&CORE::hex->("0x24")
evals/evals-freenode-#perl.lst[1397]: \&CORE::lc
evals/evals-freenode-#perl.lst[1398]: (\&CORE::lc)->('lol')
evals/evals-freenode-#perl.lst[1399]: (\&CORE::lc)->(undef)
evals/evals-freenode-#perl.lst[1400]: [ CORE::localtime ]
evals/evals-freenode-#perl.lst[1401]: CORE::localtime
evals/evals-freenode-#perl.lst[1402]: CORE::localtime + 24
evals/evals-freenode-#perl.lst[1403]: CORE::localtime - 3600
evals/evals-freenode-#perl.lst[1404]: CORE::localtime() - 3600
evals/evals-freenode-#perl.lst[1405]: &CORE::open()
evals/evals-freenode-#perl.lst[1406]: (\&CORE::print)->('a')
evals/evals-freenode-#perl.lst[1407]: \&CORE::print->("foo")
evals/evals-freenode-#perl.lst[1408]: (\&CORE::print)->('lol')
evals/evals-freenode-#perl.lst[1409]: CORE::prototoype(\&CORE::die)
evals/evals-freenode-#perl.lst[1410]: CORE::prototype(\&CORE::die)
evals/evals-freenode-#perl.lst[1411]: CORE::prototype(\&CORE::prototype)
evals/evals-freenode-#perl.lst[1412]: \(&CORE::ref)->([])
evals/evals-freenode-#perl.lst[1413]: \&CORE::ref->([])
evals/evals-freenode-#perl.lst[1414]: CORE::say "hi"
evals/evals-freenode-#perl.lst[1415]: (\&CORE::say)->("/layout save")
evals/evals-freenode-#perl.lst[1416]: CORE::stat('file')
evals/evals-freenode-#perl.lst[1417]: &CORE::system("ls &") # aw, no symmetry for me :(
evals/evals-freenode-#perl.lst[1418]: $count = 0; do { echo $count; $count++ } while ($count le 3);
evals/evals-freenode-#perl.lst[1419]: $count = 0; do { print $count; $count++ } while ($count le 3);
evals/evals-freenode-#perl.lst[1420]: $count = () = bike..care
evals/evals-freenode-#perl.lst[1421]: ++$count{$_} for split //, 'abcaba'; \ %count
evals/evals-freenode-#perl.lst[1422]: $counts{int rand 5}++ for 1..100; \%counts
evals/evals-freenode-#perl.lst[1423]: [ counts=>{},_keys=>() ]
evals/evals-freenode-#perl.lst[1424]: 'CryptoX' != 'CryptX' # orly
evals/evals-freenode-#perl.lst[1425]: ${ "\cV" }
evals/evals-freenode-#perl.lst[1426]: ${ "\cV" } . ''
evals/evals-freenode-#perl.lst[1427]: $c=v0;'test! Test'=~s/[a-z]/$&^($c^=$")/gire
evals/evals-freenode-#perl.lst[1428]: $c=v0;'test! Test'=~s/[a-z]/($c^=$")^lc$&/gire
evals/evals-freenode-#perl.lst[1429]: $c=v0;'x!xx!x!x!'=~s/[a-z]/$&^($c^=$")/gire
evals/evals-freenode-#perl.lst[1430]: ['*.c' =~ /\*\.\w/]
evals/evals-freenode-#perl.lst[1431]: $_ = 'd850e684e6de'; [join ':', unpack('(A2)*')]
evals/evals-freenode-#perl.lst[1432]: 'd850e684e6de' =~ s/..\K\B/:/gr
evals/evals-freenode-#perl.lst[1433]: "daleks" lt "perl" # but of course perl would say that
evals/evals-freenode-#perl.lst[1434]: [ 'data 234 foo 456 bar' =~ /(\d+).*bar$/ ]
evals/evals-freenode-#perl.lst[1435]: [ 'data 234 foo 456 bar' =~ /(\d+)(?=.*bar$)/ ]
evals/evals-freenode-#perl.lst[1436]: [ 'data 234 foo 456 bar' =~ /(\d+)(?:.*bar$)/ ]
evals/evals-freenode-#perl.lst[1437]: @data = '25 25.175 jitter'; [split(/\s+/, $data];
evals/evals-freenode-#perl.lst[1438]: database->quick_select($Table, \%Params, \%Options)
evals/evals-freenode-#perl.lst[1439]: 'data-date="02/14/2014"' =~ m!data-date="(\d\d/\d\d/\d\d\d\d)"!; [ $1 ]
evals/evals-freenode-#perl.lst[1440]: $Data::Dumper::Indent = 0; $h = {'a' => {'one' => 1}, "b" => 2}; $i = {'a' => {'two' => 2}}; $j = {%$h, %$i}; print Dumper($j);
evals/evals-freenode-#perl.lst[1441]: $Data::Dumper::Useperl = 1; open my $fh , '>', \my $str; [ *$fh{IO} ]
evals/evals-freenode-#perl.lst[1442]: @data = ("foo"); $data[0]{label} = $data[0]; [@data]
evals/evals-freenode-#perl.lst[1443]: "/data/install/smt/repo/\$RCE/SLES11-SP3-Updates/sle-11-x86_64"
evals/evals-freenode-#perl.lst[1444]: Data::Munge::list2re ""
evals/evals-freenode-#perl.lst[1445]: Data::Munge::list2re ();
evals/evals-freenode-#perl.lst[1446]: Data::Munge::list2re qw(= == : --)
evals/evals-freenode-#perl.lst[1447]: Data::Munge->VERSION
evals/evals-freenode-#perl.lst[1448]: [`date`]
evals/evals-freenode-#perl.lst[1449]: $_="date"; exec $_;
evals/evals-freenode-#perl.lst[1450]: DateTime::Duration->new( minutes => 3, seconds => 15 )->in_units('seconds')
evals/evals-freenode-#perl.lst[1451]: [ DateTime::Format::DateParse->parse_datetime("1:33PM")->time ]
evals/evals-freenode-#perl.lst[1452]: DateTime->noew
evals/evals-freenode-#perl.lst[1453]: ~~DateTime->now
evals/evals-freenode-#perl.lst[1454]: DateTime->now
evals/evals-freenode-#perl.lst[1455]: DateTime->now->add(weeks => 1)->strftime('%U %W %V')
evals/evals-freenode-#perl.lst[1456]: DateTime->now->set_month(11)->set_day(23)->truncate(to => "day")->subtract(weeks => 1)->ymd
evals/evals-freenode-#perl.lst[1457]: DateTime->now->set_month(11)->set_month(23)->truncate(to => "day")->subtract(weeks => 1)->ymd
evals/evals-freenode-#perl.lst[1458]: DateTime->now->strftime('%U %W %V')
evals/evals-freenode-#perl.lst[1459]: DateTime::TimeZone->is_valid_name("America/New_York");
evals/evals-freenode-#perl.lst[1460]: "D:/AU\ Files"
evals/evals-freenode-#perl.lst[1461]: debugmsg("Value missing at %d:%d\n", 1, 5);   sub debugmsg { my $msg = sprintf(shift, @_); warn $msg; print $msg; }
evals/evals-freenode-#perl.lst[1462]: debugmsg("Value missing at %d:%d\n", 1, 5);   sub debugmsg { my $msg = sprintf(@_); warn $msg; print $msg; } #since perlbot doesn't have $dbug opened, I removed it ... let's see what happens!
evals/evals-freenode-#perl.lst[1463]: dec('008') == 8
evals/evals-freenode-#perl.lst[1464]: \&decode_json
evals/evals-freenode-#perl.lst[1465]: decode_json
evals/evals-freenode-#perl.lst[1466]: decode_utf8("s\x{c3}\x{bc}\x{c3}\x{9f}e")
evals/evals-freenode-#perl.lst[1467]: [ defined ${bless \do { my $nou = undef }, "trolol"} ];
evals/evals-freenode-#perl.lst[1468]: [defined chomp($_="")]
evals/evals-freenode-#perl.lst[1469]: defined fork
evals/evals-freenode-#perl.lst[1470]: defined($INC[-1]) ? "yay" : "nay"
evals/evals-freenode-#perl.lst[1471]: [ defined ${\undef} ]
evals/evals-freenode-#perl.lst[1472]: delete *C::foo{CODE}
evals/evals-freenode-#perl.lst[1473]: delete $undef->{foo}; print defined, ref for $foo
evals/evals-freenode-#perl.lst[1474]: delete $undef->{foo}; print defined, ref for $undef
evals/evals-freenode-#perl.lst[1475]: delete $undef->{key}; $undef
evals/evals-freenode-#perl.lst[1476]: deparse: $::{true}
evals/evals-freenode-#perl.lst[1477]: $deploys = [1..3]; [ @{$deploys}[-5 .. -1] ];
evals/evals-freenode-#perl.lst[1478]: $deploys = [1..3]; [ grep $_, @{$deploys}[-3 .. -1] ];
evals/evals-freenode-#perl.lst[1479]: $deploys = [1..3]; [ grep $_, @{$deploys}[-5 .. -1] ];
evals/evals-freenode-#perl.lst[1480]: $deploys = [1..3]; push @foo, $_ for @{$deploys}[-5 .. -1]; [ @foo ]
evals/evals-freenode-#perl.lst[1481]: DESTROY <>
evals/evals-freenode-#perl.lst[1482]: die();
evals/evals-freenode-#perl.lst[1483]: ?: die 'Denied.';
evals/evals-freenode-#perl.lst[1484]: ()?(): die 'Denied.';
evals/evals-freenode-#perl.lst[1485]: [ "died with signal " . (256 & 127), 256 & 128 ? 'core dumped' : '' ]
evals/evals-freenode-#perl.lst[1486]: die "failed"
evals/evals-freenode-#perl.lst[1487]: die "foo" . "\n"
evals/evals-freenode-#perl.lst[1488]: die or do
evals/evals-freenode-#perl.lst[1489]: die \"ref here";
evals/evals-freenode-#perl.lst[1490]: Digest::MD5::md5_hex ""
evals/evals-freenode-#perl.lst[1491]: $dirname = "/usr/share/local/"; $arg = '$dirname/'
evals/evals-freenode-#perl.lst[1492]: "<div id=\"search-results\" ... >"
evals/evals-freenode-#perl.lst[1493]: $_ = 'DoÆ'; s[(doÆ)][ $1 ^ lc $1 ^ 'cat' ]ier;
evals/evals-freenode-#perl.lst[1494]: [ $$, do { $a=++$$.s/../$$/;$$<<~~+$a } ]
evals/evals-freenode-#perl.lst[1495]: $_ = '"Doe","John "Johnny"","T",...'; s/(?<=[^,])"(?!,)/'/gr
evals/evals-freenode-#perl.lst[1496]: $_ = 'Dog'; s[(dog)][ $1 ^ lc $1 ^ 'cat' ]er;
evals/evals-freenode-#perl.lst[1497]: $_ = 'Dog'; s[(dog)][ $1 ^ lc $1 ^ 'cat' ]ier;
evals/evals-freenode-#perl.lst[1498]: [ do { if(0) { 2 } else { 3 } } ]
evals/evals-freenode-#perl.lst[1499]: [do { if (1) {} }]
evals/evals-freenode-#perl.lst[1500]: [ do { if(1) { 2 } else { 3 } } ]
evals/evals-freenode-#perl.lst[1501]: "doing it for fun" =~ s/fu/cpa/r
evals/evals-freenode-#perl.lst[1502]: { do { last } while 1 }
evals/evals-freenode-#perl.lst[1503]: do { last } while 1
evals/evals-freenode-#perl.lst[1504]: [do { my $asdf = 9; if ($asdf==9) {} }]
evals/evals-freenode-#perl.lst[1505]: do { my $line = $_; chomp $line; say $line } for "asdf","asdf\n"
evals/evals-freenode-#perl.lst[1506]: do { next }
evals/evals-freenode-#perl.lst[1507]: do {} or die
evals/evals-freenode-#perl.lst[1508]: do or die
evals/evals-freenode-#perl.lst[1509]: do { print q{foo}; } while 0;
evals/evals-freenode-#perl.lst[1510]: ++do{ state $N }
evals/evals-freenode-#perl.lst[1511]: do { ++state $N }
evals/evals-freenode-#perl.lst[1512]: do { state $N++ }
evals/evals-freenode-#perl.lst[1513]: do { $x = 1; $x +=2; } if 1; $x
evals/evals-freenode-#perl.lst[1514]: "Dr doctor" =~ s/(Dr).+/$1/r;
evals/evals-freenode-#perl.lst[1515]: drink_coffee() if $!{ ENOCAFFIENE };
evals/evals-freenode-#perl.lst[1516]: Dumper(undef); use Data::Dumper
evals/evals-freenode-#perl.lst[1517]: Dumper; use Data::Dumper
evals/evals-freenode-#perl.lst[1518]: Dumper(); use Data::Dumper
evals/evals-freenode-#perl.lst[1519]: Dumper([]); use Data::Dumper
evals/evals-freenode-#perl.lst[1520]: -e
evals/evals-freenode-#perl.lst[1521]: -'e'
evals/evals-freenode-#perl.lst[1522]: -"e"
evals/evals-freenode-#perl.lst[1523]: $_ = "é"; $_++; $_
evals/evals-freenode-#perl.lst[1524]: $_ = 'e8b748680748'; [ s/..\K\B/:/gr ]
evals/evals-freenode-#perl.lst[1525]: [ each @{[ qw( a b c d e ) ]} ]
evals/evals-freenode-#perl.lst[1526]: each $^V
evals/evals-freenode-#perl.lst[1527]: [ $!{EAGAIN} ]
evals/evals-freenode-#perl.lst[1528]: [$!{EAGAIN}]
evals/evals-freenode-#perl.lst[1529]: ['è" =~ /[[:alpha:]]/, 'è' =~ /[[:alpha:&&
evals/evals-freenode-#perl.lst[1530]: earlier
evals/evals-freenode-#perl.lst[1531]: $e = "...brow,n"; $e =~ s/^\W*(\w+).*/$1/; [ $e ]
evals/evals-freenode-#perl.lst[1532]: $e = "...brow,n"; $e =~ s/^\W*(\w+).*/\1/; [ $e ]
evals/evals-freenode-#perl.lst[1533]: $e = "...brow,n"; $e =~ s/^\W*(\w+)\W*$/\1/; [ $e ]
evals/evals-freenode-#perl.lst[1534]: echo true
evals/evals-freenode-#perl.lst[1535]: `echo uuoo`
evals/evals-freenode-#perl.lst[1536]: $e = ' e'; @x = (qw(a b c d), $e); \@x;   # quitte
evals/evals-freenode-#perl.lst[1537]: $e = 'e'; @x = (qw(a b c d), $e); \@x;   # quitte
evals/evals-freenode-#perl.lst[1538]: $e = 'e'; @x = qw(a b c d), $e; \@x;   # quitte
evals/evals-freenode-#perl.lst[1539]: -e "foo"; $!
evals/evals-freenode-#perl.lst[1540]: @elems = (0..5);  my $ref =  \@elems; $ref;
evals/evals-freenode-#perl.lst[1541]: EmptyPkg->can("can")
evals/evals-freenode-#perl.lst[1542]: EmptyPkg->can("DOES")
evals/evals-freenode-#perl.lst[1543]: EmptyPkg->can("import")
evals/evals-freenode-#perl.lst[1544]: EmptyPkg->can("isa")
evals/evals-freenode-#perl.lst[1545]: Encode::decode_utf8(join "", map chr, qw(195 188 195 159))
evals/evals-freenode-#perl.lst[1546]: Encode::decode("utf-8", "\x99\x99\x99\x99\x99\x99")
evals/evals-freenode-#perl.lst[1547]: encode 'UTF-8', 'Ã¡r jÃº sÃºr?'
evals/evals-freenode-#perl.lst[1548]: [encode_utf8("\x{2665}")] # works too, depening inthe output you want
evals/evals-freenode-#perl.lst[1549]: END { ... }
evals/evals-freenode-#perl.lst[1550]: END { print "1-" } END { die "2-" } END { print "3-" } # b100s
evals/evals-freenode-#perl.lst[1551]: END {print "yes" } cvx{{Wr
evals/evals-freenode-#perl.lst[1552]: [ %ENV ]
evals/evals-freenode-#perl.lst[1553]: \%ENV
evals/evals-freenode-#perl.lst[1554]: \%ENV;
evals/evals-freenode-#perl.lst[1555]: %ENV
evals/evals-freenode-#perl.lst[1556]: $ENV{meow} = undef; \%ENV
evals/evals-freenode-#perl.lst[1557]: $ENV{PATH)
evals/evals-freenode-#perl.lst[1558]: $ENV{PATH}
evals/evals-freenode-#perl.lst[1559]: $ENV{PATH} = /home/somedir
evals/evals-freenode-#perl.lst[1560]: $ENV{PATH} = "/home/somedir"
evals/evals-freenode-#perl.lst[1561]: $ENV{TZ}
evals/evals-freenode-#perl.lst[1562]: $ENV{TZ} = 'EST5EDT'; use POSIX qw/strftime/; strftime "%Y-%m-%d", gmtime 0
evals/evals-freenode-#perl.lst[1563]: $ENV{TZ} = 'EST5EDT'; use POSIX qw/strftime/; strftime "%Y-%m-%d", localtime 0;
evals/evals-freenode-#perl.lst[1564]: $ENV{TZ} = MST7MDT; scalar localtime;
evals/evals-freenode-#perl.lst[1565]: $ENV{wibble} = []; \%ENV
evals/evals-freenode-#perl.lst[1566]: EOF # are you a thing?
evals/evals-freenode-#perl.lst[1567]: [ "EOL\r\n" =~ m/L$/,  "EOL\r\n" =~ m/L$/m ]
evals/evals-freenode-#perl.lst[1568]: [ "EOL\r\n" =~ m/L$/,  "EOL\r\n", =~ m/L$/m ]
evals/evals-freenode-#perl.lst[1569]: [ "EOL\r\n" =~ m/L\R\z/ ]
evals/evals-freenode-#perl.lst[1570]: "Episode 1x4.mkv" =~ s{(\d+)x(\d+)}{ sprintf "s%02d%02d", $1, $2 + 1 }ger
evals/evals-freenode-#perl.lst[1571]: "Episode 1x4.mkv" =~ s{(\d+)x(\d+)}{ sprintf "s%02d%02d", $1, $2 }ger
evals/evals-freenode-#perl.lst[1572]: $_ = 'episode9'; s/episode(\d)/sprintf "e(%d)", $1 - 1/e
evals/evals-freenode-#perl.lst[1573]: $_ = 'episode9'; s/episode(\d)/sprintf "e(%d)", $1 - 1/e; $_
evals/evals-freenode-#perl.lst[1574]: "equal" if "aaaa" == "bbbb"
evals/evals-freenode-#perl.lst[1575]: "equal" if "aaaa" eq "bbbb"
evals/evals-freenode-#perl.lst[1576]: '' eq undef
evals/evals-freenode-#perl.lst[1577]: Errno::ENOENT
evals/evals-freenode-#perl.lst[1578]: [ eval "0.00_02" ]
evals/evals-freenode-#perl.lst[1579]: eval '0;qq{@{sub{]]}}}}}'
evals/evals-freenode-#perl.lst[1580]: [ eval '0x10', eval '10' ]
evals/evals-freenode-#perl.lst[1581]: [eval "0x" . ('f' x 16), unpack("q", '\xff' x 8)] # hmm
evals/evals-freenode-#perl.lst[1582]: eval {1}; [ $@ ]
evals/evals-freenode-#perl.lst[1583]: eval "12w6d17h19m58s" =~ s/(\d+)(\w)/'+' . $1 * {qw(w 604800 d 86400 h 3600 m 60 s 1)}->{$2}/ger
evals/evals-freenode-#perl.lst[1584]: [ eval '1-3,5,6-9' =~ s/-/../gr ]
evals/evals-freenode-#perl.lst[1585]: eval{5 / 0} // 1
evals/evals-freenode-#perl.lst[1586]: eval "\\\\\\\\backup_server\\\\host"
evals/evals-freenode-#perl.lst[1587]: eval "\$       \b     leonerd = 42";
evals/evals-freenode-#perl.lst[1588]: eval "\$       \b     leonerd = 42"; $@
evals/evals-freenode-#perl.lst[1589]: eval { die 0; } say "Died" if $@;
evals/evals-freenode-#perl.lst[1590]: eval { die 0; }; say "Died $@" if $@;
evals/evals-freenode-#perl.lst[1591]: eval { die 0; }; say "Died" if $@;
evals/evals-freenode-#perl.lst[1592]: eval { die JSON::false; }; say "Died $@" if $@;
evals/evals-freenode-#perl.lst[1593]: eval {die \"ref here";} $$@
evals/evals-freenode-#perl.lst[1594]: eval {die \"ref here";}; $$@
evals/evals-freenode-#perl.lst[1595]: eval { die 'there you are' }; $@ # easily tested
evals/evals-freenode-#perl.lst[1596]: eval { die undef } [ $@ ]
evals/evals-freenode-#perl.lst[1597]: eval { die undef }; [ $@ ]
evals/evals-freenode-#perl.lst[1598]: eval join '*', 1..10
evals/evals-freenode-#perl.lst[1599]: eval(join '*', 1..30) / 1000 / 3600 / 24 / 365  # after heat death of universe ?
evals/evals-freenode-#perl.lst[1600]: eval: $l = "abc"; $r = "ABC"; $l =~ s/./$&.substr($r,$-[0],1)/rge
evals/evals-freenode-#perl.lst[1601]: eval "#line 0 /dev/null\n}"; $@
evals/evals-freenode-#perl.lst[1602]: eval "#line 1 /dev/null\n}"; $@
evals/evals-freenode-#perl.lst[1603]: eval "#line -42 /dev/null\n}"; $@
evals/evals-freenode-#perl.lst[1604]: eval "\$       \n     leonerd = 42"; $@
evals/evals-freenode-#perl.lst[1605]: eval "\$       \n     leonerd = 42"; $leonerd
evals/evals-freenode-#perl.lst[1606]: eval {print 1; next; print 2}
evals/evals-freenode-#perl.lst[1607]: eval { print "2" }
evals/evals-freenode-#perl.lst[1608]: eval \{ print "2" }
evals/evals-freenode-#perl.lst[1609]: eval &{ print "2" }
evals/evals-freenode-#perl.lst[1610]: eval print "2"
evals/evals-freenode-#perl.lst[1611]: eval { print "2" }; print $?
evals/evals-freenode-#perl.lst[1612]: eval { print "2" }; print $@
evals/evals-freenode-#perl.lst[1613]: eval "print 'nested\nlike\nthis'"
evals/evals-freenode-#perl.lst[1614]: [ eval "qw(yes yes),\n#no\nqw(yes yes)" ]
evals/evals-freenode-#perl.lst[1615]: eval { return 1; }; print "HELLO"
evals/evals-freenode-#perl.lst[1616]: eval "say 1; next; say 2"
evals/evals-freenode-#perl.lst[1617]: eval {say 1; next; say 2}
evals/evals-freenode-#perl.lst[1618]: eval: $str="network=192.168.1.1; Dummy-SIGB=10.0.2.79; testbed-oam-net=135.111.74.116; Dummy-SIGA=10.0.1.111"; for ( split /\;/, $str ){ if ( /(.*)\=(.*)/ ){ print "$1,$2" } }
evals/evals-freenode-#perl.lst[1619]: eval {sub C::foo {}; my $o = \&C::foo; undef &C::foo; $o->(); 1} or $@
evals/evals-freenode-#perl.lst[1620]: eval "\$       \t     leonerd = 42"; $@
evals/evals-freenode-#perl.lst[1621]: eval { undef->() }; "-> $@ <-"
evals/evals-freenode-#perl.lst[1622]: eval { undef->() }; $@
evals/evals-freenode-#perl.lst[1623]: eval "unpack 'S', \"\xff\xff\""
evals/evals-freenode-#perl.lst[1624]: eval "\$       \v     leonerd = 42"; $@
evals/evals-freenode-#perl.lst[1625]: eval "`who"."ami`"
evals/evals-freenode-#perl.lst[1626]: eval '"'.'\x41\x41'.'"'
evals/evals-freenode-#perl.lst[1627]: exec '/bin/ls'
evals/evals-freenode-#perl.lst[1628]: exec 'ping', 'google.com'
evals/evals-freenode-#perl.lst[1629]: exec '/usr/bin/ping', 'google.com'
evals/evals-freenode-#perl.lst[1630]: exec $^X
evals/evals-freenode-#perl.lst[1631]: exists ""
evals/evals-freenode-#perl.lst[1632]: ~~exp 2
evals/evals-freenode-#perl.lst[1633]: exp(2)
evals/evals-freenode-#perl.lst[1634]: *EXPORT = \@Foo::Bar::EXPORT; push @EXPORT, "hello world"; [ \@EXPORT, \@Foo::Bar::EXPORT ]
evals/evals-freenode-#perl.lst[1635]: "#\\E \\z" =~ m{ \Q#\E \z}xms ? "wtf" : "k"
evals/evals-freenode-#perl.lst[1636]: @F=(0..9,0);sub r{my($y,@x)=@_;map{ref$_ ? (&$_) :$_}@d=(@F,($y && sub{@F[$y-1,-1-$y]=($")x2;r(@x)}),@F%2|$y?@F:())}print r 1,1,3..@F/2-1
evals/evals-freenode-#perl.lst[1637]: "f0b0" =~ /f(.)b\1/
evals/evals-freenode-#perl.lst[1638]: fail?succeed:fail
evals/evals-freenode-#perl.lst[1639]: FAIL x 2
evals/evals-freenode-#perl.lst[1640]: false ? true : file_not_found
evals/evals-freenode-#perl.lst[1641]: 'false' ? "yes it is" : "no, it isn't" # place your bets!
evals/evals-freenode-#perl.lst[1642]: %fancylist = ( 1,"one",2,"two",3,"three" ); print scalar %fancylist;
evals/evals-freenode-#perl.lst[1643]: %fancylist = ( 1,"one",2,"two",3,"three" ); print scalar keys %fancylist;
evals/evals-freenode-#perl.lst[1644]: fc('er') eq fc('Er')
evals/evals-freenode-#perl.lst[1645]: fc "ß"
evals/evals-freenode-#perl.lst[1646]: FF & 07F
evals/evals-freenode-#perl.lst[1647]: [ -f "/", -f "/does-not-exist", -f undef ]
evals/evals-freenode-#perl.lst[1648]: $_ = '@f@f@f'; s'@f'$b'gr;
evals/evals-freenode-#perl.lst[1649]: $_ = 'file-bkp-2014-06-08'; [ map { s/bkp\K(\d*)/$1+1/e; $_ } ($_) x 12 ]
evals/evals-freenode-#perl.lst[1650]: [ fileno STDIN, fileno STDOUT, fileno STDERR ]
evals/evals-freenode-#perl.lst[1651]: @files = qw(one two three); 'there are ' . @files . ' files'
evals/evals-freenode-#perl.lst[1652]: @files = qw(one two three); "there are @{[ scalar @files ]} files"
evals/evals-freenode-#perl.lst[1653]: [ %{File::Stat::} ]
evals/evals-freenode-#perl.lst[1654]: File::Stat->import; [ %{File::Stat::} ]
evals/evals-freenode-#perl.lst[1655]:  $_ = "First Name Position first.name@somewhere.com 745 45363\nSome One Worker some.one@somewhere.com 343 5454\n" =~ s/^\s*(\S)\S*\s+(\S+).+?(\d\d\d \d\d\d\d)\s*/$1., $2, $3/gmr
evals/evals-freenode-#perl.lst[1656]: $_ = "First.\nSecond.\nBla, bla, bla. \nHi.\t\nLast line.\n"; [ /^.*\h+$/gm ] # try \h if you only want horizontal whitespace
evals/evals-freenode-#perl.lst[1657]: @_=('first','second'); print $_[0];
evals/evals-freenode-#perl.lst[1658]: floor()
evals/evals-freenode-#perl.lst[1659]: [ floor(-5/3), int(-5/3) ]
evals/evals-freenode-#perl.lst[1660]: floor(85.3)
evals/evals-freenode-#perl.lst[1661]: $fl = '+++????? random shit any user can send to the bot'; my @mem_list = grep { $_ =~ /^$fl/i} 42;
evals/evals-freenode-#perl.lst[1662]: -F\"m S\"
evals/evals-freenode-#perl.lst[1663]: foo
evals/evals-freenode-#perl.lst[1664]: ~~"foo"
evals/evals-freenode-#perl.lst[1665]: -foo
evals/evals-freenode-#perl.lst[1666]: '\'foo\''
evals/evals-freenode-#perl.lst[1667]: 'foo'
evals/evals-freenode-#perl.lst[1668]: "" . \@{\*foo}
evals/evals-freenode-#perl.lst[1669]: "foo" =~ /[.]/
evals/evals-freenode-#perl.lst[1670]: (\*foo)->()
evals/evals-freenode-#perl.lst[1671]: (\&{ \*foo })->()
evals/evals-freenode-#perl.lst[1672]: [ "foo" =~ /()(.)/ ]
evals/evals-freenode-#perl.lst[1673]: [${\ 'foo' }]
evals/evals-freenode-#perl.lst[1674]: $_="foo
evals/evals-freenode-#perl.lst[1675]: $_ = 'foo'; $::_
evals/evals-freenode-#perl.lst[1676]: ${\*foo}
evals/evals-freenode-#perl.lst[1677]: $foo->@*
evals/evals-freenode-#perl.lst[1678]: *foo
evals/evals-freenode-#perl.lst[1679]: \\*foo
evals/evals-freenode-#perl.lst[1680]: \&::foo
evals/evals-freenode-#perl.lst[1681]: \&{ \*foo }->()
evals/evals-freenode-#perl.lst[1682]: ++$foo++
evals/evals-freenode-#perl.lst[1683]: 'foo'+0
evals/evals-freenode-#perl.lst[1684]: foo { $$_[0] = 1 } foo \(my $x); $x
evals/evals-freenode-#perl.lst[1685]: (\@{ \*foo })->[0]++; \@foo;
evals/evals-freenode-#perl.lst[1686]: (\@{ \*foo })->[0]++; say @foo;
evals/evals-freenode-#perl.lst[1687]: $_ = [['foo']]; @$_[0] # Which is entirely different from @{$_[0]}
evals/evals-freenode-#perl.lst[1688]: $foo = 1; [ 0+$foo, map $foo++, 1..4 ] # if you wanted the other behaviour
evals/evals-freenode-#perl.lst[1689]: $foo[-1] = 2
evals/evals-freenode-#perl.lst[1690]: [ foo => (1, 2, 3) ]
evals/evals-freenode-#perl.lst[1691]: [ foo => [1, 2, 3] ]
evals/evals-freenode-#perl.lst[1692]: [ foo => 1, 2, 3 ]
evals/evals-freenode-#perl.lst[1693]: { +FOO => 123 }
evals/evals-freenode-#perl.lst[1694]: @foo = ( 1, 2, 3 ); $" = ', '; [ "@foo" ]
evals/evals-freenode-#perl.lst[1695]: { foo => (1, 2, 3) } # perhaps more useful
evals/evals-freenode-#perl.lst[1696]: [foo 1, 2, 3] sub foo { { thingy => $_[0] } }
evals/evals-freenode-#perl.lst[1697]: "@{ [ %{ {foo => 12, bar => 13} }] }" # no hash slice involved
evals/evals-freenode-#perl.lst[1698]: "foo=(1, 2)   bar=(3, 4)" =~ s/(?<=\()([^)]+)/$1=~s{\s+}{}gr/gre
evals/evals-freenode-#perl.lst[1699]: @foo = (1, 2, undef, 4); for my $foo (@foo) { print $foo }
evals/evals-freenode-#perl.lst[1700]: $foo = 1419516010; [ ''.localtime($foo), ''.gmtime($foo) ] # LeoNerd - so shouldn't these be different?
evals/evals-freenode-#perl.lst[1701]: $foo[-1] = 42
evals/evals-freenode-#perl.lst[1702]: $foo1 = 4/5; $foo2 = int(4/5); $foo3 = $foo2 ? $foo2 : 1; [ foo1 => $foo1, foo2 => $foo2, foo3 => $foo3 ]
evals/evals-freenode-#perl.lst[1703]: $foo = 1; $bar = *foo; $qux = \*foo; [ $$bar, $$qux ]
evals/evals-freenode-#perl.lst[1704]: $foo = 1; $bar = *foo; $qux = \*foo; use strict; [ $$bar, $$qux ]
evals/evals-freenode-#perl.lst[1705]: $foo1 = $foo2 = '4 a 2'; ( $foo1 ) = $foo1 =~ /(\d+)/; $foo2 =~ s/\D+//g; [ $foo1, $foo2 ]
evals/evals-freenode-#perl.lst[1706]: $foo = 1; $foo++; $foo
evals/evals-freenode-#perl.lst[1707]: $foo = 1; [$foo, map { $foo++ } 1 .. 4]; # isn't the order of evaluation from left to right?
evals/evals-freenode-#perl.lst[1708]: $foo = 1; our $bar = *foo; our $qux = \*foo; use strict; [ %$bar ]
evals/evals-freenode-#perl.lst[1709]: $foo = 1; our $bar = *foo; our $qux = \*foo; use strict; [ $$bar, $$qux ]
evals/evals-freenode-#perl.lst[1710]: $foo = 1; our $bar = *foo; our $qux = \*foo; use strict; [ %$bar, %$qux ]
evals/evals-freenode-#perl.lst[1711]: $foo = 1; our $bar = *foo; our $qux = \*foo; use strict; [ %{*$qux} ]
evals/evals-freenode-#perl.lst[1712]: $foo ||= 2;
evals/evals-freenode-#perl.lst[1713]: ${{[foo=>2, bar=>3]}}{"foo"}
evals/evals-freenode-#perl.lst[1714]: $foo=3; $foo ||= 2;
evals/evals-freenode-#perl.lst[1715]: $foo = 3; oct "0x$foo"
evals/evals-freenode-#perl.lst[1716]: { -foo, 42 }
evals/evals-freenode-#perl.lst[1717]: { +foo => 42 }
evals/evals-freenode-#perl.lst[1718]: +{ +foo => 42 }
evals/evals-freenode-#perl.lst[1719]: ($foo = 42)++; $foo  # same kind of thing
evals/evals-freenode-#perl.lst[1720]: $foo = 42; our $bar = *foo; our $qux = \*foo; use strict; [ *$bar, *$qux ]
evals/evals-freenode-#perl.lst[1721]: $foo = 42; our $bar = *foo; our $qux = \*foo; use strict; [ *{$bar}{SCALAR}, *{$qux}{SCALAR} ]
evals/evals-freenode-#perl.lst[1722]: $foo = 42; [ qq' "$foo" ' ]
evals/evals-freenode-#perl.lst[1723]: $foo = [42]; shift $foo
evals/evals-freenode-#perl.lst[1724]: $foo = 5607181; substr($foo, -6, 0) = '.'; $foo # without all that FANCY COMPLICATED DIVISION
evals/evals-freenode-#perl.lst[1725]: $foo=5; ${*$foo}{"bar"}=2; $5{bar}
evals/evals-freenode-#perl.lst[1726]: $foo = 'a2b11c3d5'; $foo =~ s/[^a-z]//g; print $foo;
evals/evals-freenode-#perl.lst[1727]: @foo = "a2b11c3d5" =~ /(\w+)/g; \@foo
evals/evals-freenode-#perl.lst[1728]: "f o o" =~ /[ab ]/
evals/evals-freenode-#perl.lst[1729]: $foo = "abcdefg"; $foo =~ s/ef//; [ $-[0], length $` ]
evals/evals-freenode-#perl.lst[1730]: $foo = "abc:def"; {split /:/, $foo};
evals/evals-freenode-#perl.lst[1731]: $foo = "abc:def"; sprintf("0x%x", ~~{split ":", $foo});
evals/evals-freenode-#perl.lst[1732]: $foo = '...'; "abc" =~ /\Q$foo/
evals/evals-freenode-#perl.lst[1733]: "f o o" =~ /[ab ]/x
evals/evals-freenode-#perl.lst[1734]: [ "foo a b = z" =~ /foo((?: \w)+)/ ]
evals/evals-freenode-#perl.lst[1735]: "foo a b = z" =~ /foo( \w)+/; [ $1, $& ]
evals/evals-freenode-#perl.lst[1736]: $foo = "AF"; [chr oct "0x$foo"]
evals/evals-freenode-#perl.lst[1737]: $_ = "foo: a\n bar: 1\n bar: 2\nfoo: b\n bar: 5\nfoo: c\n"; my(%h,$last); $1 ? push @{ $h{$last} }, $2 : ($h{$last = $2} = [])   while/^( ?)\w+: (\w+)/gm; \%h
evals/evals-freenode-#perl.lst[1738]: $foo = "(A)"; "\Q$foo"
evals/evals-freenode-#perl.lst[1739]: $foo = [ a..z ]; *array = $foo;  $array[5] # glob trick for programmers that don't like ->  hehehe
evals/evals-freenode-#perl.lst[1740]: 'foo  bang' =~ /foo (?:bar)? bang/ ? match : nomatch
evals/evals-freenode-#perl.lst[1741]: 'foo bang' =~ /foo (?:bar)? bang/ ? match : nomatch
evals/evals-freenode-#perl.lst[1742]: [ 'foo bang' =~ /foo\s+(?:bar\s+)?bang/ ? 'match' : 'nomatch' ]
evals/evals-freenode-#perl.lst[1743]: <{foo,bar}>
evals/evals-freenode-#perl.lst[1744]: 'foo   ' ^. '   bar'
evals/evals-freenode-#perl.lst[1745]: 'foo' == 'bar'
evals/evals-freenode-#perl.lst[1746]: "foo" =~ /bar/
evals/evals-freenode-#perl.lst[1747]: "foo" != "bar"
evals/evals-freenode-#perl.lst[1748]: "foo" . "bar"
evals/evals-freenode-#perl.lst[1749]: "foobar" ^ "   "
evals/evals-freenode-#perl.lst[1750]: [ <{foo,bar}> ]
evals/evals-freenode-#perl.lst[1751]: [ "foo ); bar );" =~ /(.* \)\;)/ ]
evals/evals-freenode-#perl.lst[1752]: [ "foo ); bar );" =~ /(.*? \)\;)/ ]
evals/evals-freenode-#perl.lst[1753]: [- -foo => 'bar']
evals/evals-freenode-#perl.lst[1754]: [--foo => 'bar']
evals/evals-freenode-#perl.lst[1755]: [-+-+-+-+-+-+-+-+foo => 'bar']
evals/evals-freenode-#perl.lst[1756]: [-+-foo => 'bar']
evals/evals-freenode-#perl.lst[1757]: [(-+foo => 'bar')]
evals/evals-freenode-#perl.lst[1758]: [{ +foo => 'bar' }]
evals/evals-freenode-#perl.lst[1759]: [{-+foo => 'bar'}]
evals/evals-freenode-#perl.lst[1760]: { +foo => 'bar' }
evals/evals-freenode-#perl.lst[1761]: { +foo => "bar" }
evals/evals-freenode-#perl.lst[1762]: {-+foo => 'bar'}
evals/evals-freenode-#perl.lst[1763]: +{ foo => "bar" }
evals/evals-freenode-#perl.lst[1764]: Foo'bar
evals/evals-freenode-#perl.lst[1765]: $foo = $bar = 0; $foo += $bar += 1 for 1..10; $foo  # even more fun :)
evals/evals-freenode-#perl.lst[1766]: [ ' foo= bar1,bar2,bar3  ' =~ /bar\d+/g ]
evals/evals-freenode-#perl.lst[1767]: $foo{'bar'} = 1; $foo{'baz'} = 1; scalar(%foo);
evals/evals-freenode-#perl.lst[1768]: $foo{'bar'} = 1; $foo{'baz'} = 1; scalar(keys(%foo));
evals/evals-freenode-#perl.lst[1769]: @foo = ( bar => 34, baz => 42 ); print +{@foo}->{bar};
evals/evals-freenode-#perl.lst[1770]: 'foo bar bang' =~ /foo (?:bar)? bang/ ? match : nomatch
evals/evals-freenode-#perl.lst[1771]: [ 'foo bar bang' =~ /foo\s+(?:bar\s+)?bang/ ? 'match' : 'nomatch' ]
evals/evals-freenode-#perl.lst[1772]: [ foo => bar => baz => ]
evals/evals-freenode-#perl.lst[1773]: foo bar baz
evals/evals-freenode-#perl.lst[1774]: $_ = 'foo bar baz'; my %foo; @foo{qw(one two three)} = m/(\w+)/g; \%foo;
evals/evals-freenode-#perl.lst[1775]: $foo->{bar} = 'baz'; "quux $foo->{bar}"
evals/evals-freenode-#perl.lst[1776]: "foo bar baz" =~ s/\b(\w)/\U$1/gr
evals/evals-freenode-#perl.lst[1777]: [ 'foo bar baz' =~ /\S+/g ]
evals/evals-freenode-#perl.lst[1778]: "    foo bar baz" =~ s/(?<=\s)foo//r
evals/evals-freenode-#perl.lst[1779]: "foo bar baz" =~ s/(?<=\s)foo//r
evals/evals-freenode-#perl.lst[1780]: "    foo bar baz" =~ s/\s\Kfoo//r
evals/evals-freenode-#perl.lst[1781]: "foo bar baz" =~ s/\s\Kfoo//r
evals/evals-freenode-#perl.lst[1782]: "foo/bar-baz&stuff/51" =~ /(\d+)$/r # if >5.10, I think
evals/evals-freenode-#perl.lst[1783]: $foo = { bar => 'baz }; sub foo { $foo->{bar}{baz}{quux} }; exists foo()
evals/evals-freenode-#perl.lst[1784]: $foo = { bar => 'baz' }; sub foo { $foo->{bar}{baz}{quux} }; exists &foo;
evals/evals-freenode-#perl.lst[1785]: $foo = { bar => 'baz' }; sub foo { $foo->{bar}{baz}{quux} }; exists foo()
evals/evals-freenode-#perl.lst[1786]: [ "foo.bar.baz" =~ s{\.(\w+)}{.get\u$1()}gr ]
evals/evals-freenode-#perl.lst[1787]: "foo bar baz" =~ s/(\w+)/\u$1/gr #ah, this is what I was looking for
evals/evals-freenode-#perl.lst[1788]: "foo bar baz" =~ s/(\w+)/\U$1/gr #will this work I wonder?
evals/evals-freenode-#perl.lst[1789]: $foo = $bar = './blah'; substr($foo, 0, 2) = ''; $bar = substr($bar, 2); [ $foo, $bar ]
evals/evals-freenode-#perl.lst[1790]: %foo; @bar = ('cat', 'dog', 'bird', 'bird'); @foo{@animals} = (); %foo;
evals/evals-freenode-#perl.lst[1791]: %foo; @bar = ('cat', 'dog', 'bird', 'bird'); @foo{@bar} = (); \%foo;
evals/evals-freenode-#perl.lst[1792]: %foo; @bar = ('cat', 'dog', 'bird', 'bird'); @foo{@bar} = (); %foo;
evals/evals-freenode-#perl.lst[1793]: $foo{bar} = (); \%foo
evals/evals-freenode-#perl.lst[1794]: $foo = 'bar'; ++$$foo; $bar
evals/evals-freenode-#perl.lst[1795]: ["foobar" =~ /f(ooo)|(bar)/]
evals/evals-freenode-#perl.lst[1796]: "foo(bar" =~ /oo\(ba/ ? "match" : "no match"
evals/evals-freenode-#perl.lst[1797]: $_='FOO bar'; print if $_ !~ /FOO\s*?(BAR|xx)/i;
evals/evals-freenode-#perl.lst[1798]: $_='FOObar'; print if $_ !~ /FOO\s*?(BAR|xx)/i;
evals/evals-freenode-#perl.lst[1799]: $_='FOO bar'; print "Invalid str.  Foo is missing BAR or xx"  if $_ =~ /FOO(?!\s*(BAR|xx))/i;
evals/evals-freenode-#perl.lst[1800]: $_='FOO bar'; print "Invalid str.  Foo is missing BAR or xx"  if $_ =~ /FOO\s*?(?!(BAR|xx))/i;
evals/evals-freenode-#perl.lst[1801]: $_='FOObar'; print "Invalid str.  Foo is missing BAR or xx"  if $_ =~ /FOO(?!\s*(BAR|xx))/i;
evals/evals-freenode-#perl.lst[1802]: %foo = (bar => 'quux'); sub foo { +{%foo} } [ foo->{bar}, $foo{bar} ] #huf, you're wrong, foo->{bar} is $foo{bar} :P
evals/evals-freenode-#perl.lst[1803]: ['foobarrrrsplot' =~ /foo(bar+)splot/
evals/evals-freenode-#perl.lst[1804]: ['foobarrrrsplot' =~ /foo(bar+)splot/]
evals/evals-freenode-#perl.lst[1805]: ['foobarrrrsplot foobarsplot' =~ /foo(bar+)splot/g]
evals/evals-freenode-#perl.lst[1806]: ['foobarrrrsplot' =~ /foo(bar+)splot/g]
evals/evals-freenode-#perl.lst[1807]: $foo = { bar => "stuff" };  $foo->{bar}->{gravy}
evals/evals-freenode-#perl.lst[1808]: foo 'bar'; sub foo { 1; } # you mean you want to catch things like this?
evals/evals-freenode-#perl.lst[1809]: $_ = "Foo & Bar"; s{(\W)}{ sprintf rand() < 0.5 ? "&#%d;" : "%%%02X", ord $1 }ge; $_
evals/evals-freenode-#perl.lst[1810]: "foo" . "bar" . "yin" . "yang"
evals/evals-freenode-#perl.lst[1811]: $_='FOObat'; print if $_ !~ /FOO\s*?(BAR|xx)/i;
evals/evals-freenode-#perl.lst[1812]: $foo = "blah"; ($bar = $foo) =~ s/bl/h/; [$bar]
evals/evals-freenode-#perl.lst[1813]: $foo = "blah"; ($bar = $foo) =~ s/bl/h/r; [$bar]
evals/evals-freenode-#perl.lst[1814]: [ 'fooblahblahbarfoobazbar' =~ /foo((?:(?!bar).)*)bar/ ]
evals/evals-freenode-#perl.lst[1815]: $foo = "blah episode9 blah"; $foo =~ s/episode([0-9])/e($1-1)/e; $foo
evals/evals-freenode-#perl.lst[1816]: $foo = "blah episode9 blah"; $foo =~ s/episode([0-9])/'e'($-1)/e; $foo
evals/evals-freenode-#perl.lst[1817]: $foo = "blah episode9 blah"; $foo =~ s/episode([0-9])/e($-1)/e; $foo
evals/evals-freenode-#perl.lst[1818]: $foo = "blah episode9 blah"; $foo =~ s/episode([0-9])/e$1/; $foo
evals/evals-freenode-#perl.lst[1819]: $foo = 'b(o+g[o|n(s';  [ $foo =~ /\Q$foo\E/, "\Q$foo" ]
evals/evals-freenode-#perl.lst[1820]: 'foo' eq 'bar'
evals/evals-freenode-#perl.lst[1821]: "{{foo" =~ /{{f/
evals/evals-freenode-#perl.lst[1822]: "foo" =~ /foo/
evals/evals-freenode-#perl.lst[1823]: [ "foo" =~ /foo(.*)(.*?)/ ]
evals/evals-freenode-#perl.lst[1824]: %foo{'foo'};
evals/evals-freenode-#perl.lst[1825]: [ "foo" =~ /foo(.*)(bar|)/ ]
evals/evals-freenode-#perl.lst[1826]: [ "foo" =~ /foo(.*)(bar)/ ]
evals/evals-freenode-#perl.lst[1827]: [ "foo" =~ /foo(bar)(baz)/ ]
evals/evals-freenode-#perl.lst[1828]: ($foo) = "foo/bar-baz&stuff/51" =~ /(\d+)$/;  $foo
evals/evals-freenode-#perl.lst[1829]: [ "foo foobar foobaz rarafoo gerzson" =~ /\w*o\b/g ]
evals/evals-freenode-#perl.lst[1830]: [ "foo foobar foobaz rarafoo gerzson" =~ /\w*o\W/g ]
evals/evals-freenode-#perl.lst[1831]: [ "foo foobar foobaz rarafoo" =~ /\w*foo\b/g ]
evals/evals-freenode-#perl.lst[1832]: [ "foo foobar foobaz rarafoo" =~ /\w*foo/g ]
evals/evals-freenode-#perl.lst[1833]: [ "foo foobar foobaz rarafoo" =~ /\w*foo$/g ]
evals/evals-freenode-#perl.lst[1834]: $foo["foo"] = "hallo"; \@foo
evals/evals-freenode-#perl.lst[1835]: $foo = {};  "foo!" if $foo;
evals/evals-freenode-#perl.lst[1836]: 'foo' =~ /.+/; 'foo' =~ s//bar/r; # yup
evals/evals-freenode-#perl.lst[1837]: 'foo' ^ 'fop'
evals/evals-freenode-#perl.lst[1838]: [ 'foo' ^ 'fop' ]
evals/evals-freenode-#perl.lst[1839]: FOO: for (0 .. 9) { last FOO; } FOO: while () { last FOO; } "k"
evals/evals-freenode-#perl.lst[1840]: $foo = 'hello'; push @bar, substr($foo, -$_) for 1 .. length $foo; \@bar
evals/evals-freenode-#perl.lst[1841]: foo "HERE"
evals/evals-freenode-#perl.lst[1842]: foo "hi\n"; sub foo { print "moo\n"; }
evals/evals-freenode-#perl.lst[1843]: \ @Foo::ISA
evals/evals-freenode-#perl.lst[1844]: @$foo{key} # except it isn't
evals/evals-freenode-#perl.lst[1845]: "foo" =~ m/\1/
evals/evals-freenode-#perl.lst[1846]: "foo" =~ m/f/ and print "yay"
evals/evals-freenode-#perl.lst[1847]: $_ = 'foo'; my $a = 5; 1 for $a; $_
evals/evals-freenode-#perl.lst[1848]: $_ = 'foo'; { my $_ = 'bar'; print $_; }
evals/evals-freenode-#perl.lst[1849]: $_ = 'foo'; { my $_; print $main::_; }
evals/evals-freenode-#perl.lst[1850]: $foo = 'name'; "define('DB_NAME', 'l33t7ex7');" =~ /^define\('DB_\U$foo\E', '(.*)'\);$/
evals/evals-freenode-#perl.lst[1851]: "foo\nbar" =~ m/[\n]/ and "yes"
evals/evals-freenode-#perl.lst[1852]: [ "foo\nbar\nbaz" =~ s/^.//mgr ]
evals/evals-freenode-#perl.lst[1853]: "foo\nbar" =~ /o\nb/ ? "matches" : "doesn't match"
evals/evals-freenode-#perl.lst[1854]: $_="foo\nbar"; s/.+//; $_
evals/evals-freenode-#perl.lst[1855]: "foo\nbar" ~~ s/\n/<br>/gr
evals/evals-freenode-#perl.lst[1856]: "foo\nbar" =~ s/\n/<br>/gr
evals/evals-freenode-#perl.lst[1857]: "foo\nbar" =~ s/\n/<br\>/gr
evals/evals-freenode-#perl.lst[1858]: "foo" ne "bar"
evals/evals-freenode-#perl.lst[1859]: [ 'foo nobang' =~ /foo\s+(?:bar\s+)?bang/ ? 'match' : 'nomatch' ]
evals/evals-freenode-#perl.lst[1860]: $_ = "foo\n#one\n #two \n#three\n##bar\nfour\n"; @parse = (); push @parse, $1 =~ /##/ ? "ERROR" : $1 while s/^((?:\s*#(?!#).*\n)+|.*\n)//; \@parse
evals/evals-freenode-#perl.lst[1861]: [ "foo" =~ /o{2}/, "foo" =~ /\Qo{2}/ ]
evals/evals-freenode-#perl.lst[1862]: $foo = 'origin/beans-and-cornbread'; substr($foo, 7)
evals/evals-freenode-#perl.lst[1863]: $_='FOO'; print if !~ /(BAR|xx)/;
evals/evals-freenode-#perl.lst[1864]: $_='FOO'; print if $_ !~ /(BAR|xx)/;
evals/evals-freenode-#perl.lst[1865]: $foo = ''; print "nothing found" unless length $foo;
evals/evals-freenode-#perl.lst[1866]: $foo = q{$$}; [ '$$' =~ /\Q$foo/ ]
evals/evals-freenode-#perl.lst[1867]: @foo = qw/a b c d e/; $x = \$foo[2];  $$x = 'i';  [ @foo ]
evals/evals-freenode-#perl.lst[1868]: @foo = qw/a b c d/; [ $#foo ]
evals/evals-freenode-#perl.lst[1869]: @foo = qw( a b c ); [$#foo]
evals/evals-freenode-#perl.lst[1870]: @foo = qw( foo bar baz biz fuzz buzz wowzers ); [ @foo[ int rand @foo, -1 ] ]
evals/evals-freenode-#perl.lst[1871]: "foo\r\n\tbar\n"
evals/evals-freenode-#perl.lst[1872]: *foo{SCALAR}->$* = 2; my $bar; $$bar = 3; say $bar->$****foo{SCALAR}->$*;
evals/evals-freenode-#perl.lst[1873]: [ (foo => scalar('bar', baz => scalar('quux', flurb => scalar('flarb')))) ]
evals/evals-freenode-#perl.lst[1874]: [ (foo =>scalar 'bar', baz =>scalar 'quux', flurb =>scalar 'flarb') ]
evals/evals-freenode-#perl.lst[1875]: [ 'foo' =~ s/foo/bar/r, 'foo' =~ tr/o/x/r ]
evals/evals-freenode-#perl.lst[1876]: "foo" =~ s/foo/^{MATCH}bar/pr;
evals/evals-freenode-#perl.lst[1877]: "foo" =~ s/foo/$^{MATCH}bar/pr;
evals/evals-freenode-#perl.lst[1878]: "foo" =~ s/foo/${^MATCH}bar/pr;
evals/evals-freenode-#perl.lst[1879]: $foo = [$]]; shift $foo
evals/evals-freenode-#perl.lst[1880]: "foo" =~ s/o/e/gr
evals/evals-freenode-#perl.lst[1881]: @foo = ("%s %s", 'foo', 'bar'); printf @foo;
evals/evals-freenode-#perl.lst[1882]: @foo = ("%s %s", 'foo', 'bar'); sprintf @foo;
evals/evals-freenode-#perl.lst[1883]: [ {foo => sub {1}} ]
evals/evals-freenode-#perl.lst[1884]: "Foo"->${\sub { "hello" } };
evals/evals-freenode-#perl.lst[1885]: 'foo*' =~ s{([*?]+)|(\W)}{ $2 ? "\\$2" : '.{' . $1 =~ tr/?// . '}' . '.*' x (index($1, '*') >= 0) }egr
evals/evals-freenode-#perl.lst[1886]: 'foo*' =~ s{([*?]+)|(\W)}{ $2 ? "\\$2" : '.' x $1 =~ tr/?// . '.*' x (index($1, '*') >= 0) }egr
evals/evals-freenode-#perl.lst[1887]: [ " foo\tbar  baz " =~ /\S+/g ]
evals/evals-freenode-#perl.lst[1888]: $foo = 'this/that' =~ s/th//r; $foo
evals/evals-freenode-#perl.lst[1889]: $_="foo"; tr alaLa; print $_
evals/evals-freenode-#perl.lst[1890]: %foo = (undef, undef); say "defined" if (grep { defined } keys %foo);
evals/evals-freenode-#perl.lst[1891]: $_='FOO v'; print if $_ !~ /FOO\s*?(BAR|xx)/i;
evals/evals-freenode-#perl.lst[1892]: $_='FOO v'; print "Invalid str.  Foo is missing BAR or xx"  if $_ =~ /FOO(?!\s*(BAR|xx)/i;
evals/evals-freenode-#perl.lst[1893]: $_='FOO v'; print "Invalid str.  Foo is missing BAR or xx"  if $_ =~ /FOO(?!\s*(BAR|xx))/i;
evals/evals-freenode-#perl.lst[1894]: "foo" =~ /(?<<<<!>&)#(\w+)/
evals/evals-freenode-#perl.lst[1895]: [ "(foo)" =~ /\w+/g ]
evals/evals-freenode-#perl.lst[1896]: ${\*foo}->("why hello")
evals/evals-freenode-#perl.lst[1897]: $foo="wibble"; q"$foo"
evals/evals-freenode-#perl.lst[1898]: 'foo' xor 'fop'
evals/evals-freenode-#perl.lst[1899]: $_='FOO x'; print "Invalid str.  Foo is missing BAR or xx"  if $_ =~ /FOO(?!\s*(BAR|xx))/i;
evals/evals-freenode-#perl.lst[1900]: for \@{[]} (()) {}
evals/evals-freenode-#perl.lst[1901]: for ( 0 .. 10 ) { print; } print $_;
evals/evals-freenode-#perl.lst[1902]: for ("1".."128"){ print chr "$_" };
evals/evals-freenode-#perl.lst[1903]: [ for (1..20){if (/^5$/ .. /^18$/){print $_;} ]
evals/evals-freenode-#perl.lst[1904]: [ for (1..20){if (/^5$/ .. /^18$/){print $_;}} ]
evals/evals-freenode-#perl.lst[1905]: for (1..20){if (/^5$/ .. /^18$/){print $_;}
evals/evals-freenode-#perl.lst[1906]: for (1..20){if (/^5$/ .. /^18$/){print $_;}}
evals/evals-freenode-#perl.lst[1907]: for ("123 5 12 7 ") { my $re = qr/(\d+)(\s+)/; if(/^(?:$re)+$/) { my @result = /$re/g; print "[" . join(",", @result) . "]" } else { print "no match" } } # maybe not necessarily like this, but something along these lines
evals/evals-freenode-#perl.lst[1908]: for (1 .. 3) { my @bar; push @foo, \@bar } "@foo"
evals/evals-freenode-#perl.lst[1909]: for(1..3) { print $_+1 }
evals/evals-freenode-#perl.lst[1910]: for (1..5) { print; print and last if 0 }
evals/evals-freenode-#perl.lst[1911]: ... for "A" ... "Z"
evals/evals-freenode-#perl.lst[1912]: foreach (1..4) { do { next }; print "$_\n"}
evals/evals-freenode-#perl.lst[1913]: foreach ($i = 0; $i < 3; $i++) { push @foo, $i*2 }  \@foo
evals/evals-freenode-#perl.lst[1914]: foreach ( keys %ENV ){ say "$_ => $ENV{ $_ };last;}"
evals/evals-freenode-#perl.lst[1915]: foreach ( keys %ENV ){ say "$_ => $ENV{ $_ }";last;}"
evals/evals-freenode-#perl.lst[1916]: foreach my $val (qw/entity baz /) {print +(grep /$val/,( "foo", "bar", "foo entity bar quux", "foo bar")) ? "$val found" : "$val not found" };
evals/evals-freenode-#perl.lst[1917]: foreach my $var ( 1..5 ){ print "$var," }
evals/evals-freenode-#perl.lst[1918]: for ('foo', 'bar') { s/oo/ar/g } # sirkha, like this
evals/evals-freenode-#perl.lst[1919]: for ( grep { print $_; 1 } 1 .. 5 ) { print $_ }
evals/evals-freenode-#perl.lst[1920]: for ("hello") { $_ = 42 }
evals/evals-freenode-#perl.lst[1921]: fork
evals/evals-freenode-#perl.lst[1922]: "fork-fork" =~ /-/ and [eval '$`..$\'']
evals/evals-freenode-#perl.lst[1923]: fork; print $!;
evals/evals-freenode-#perl.lst[1924]: fork => until 0 => $$
evals/evals-freenode-#perl.lst[1925]: fork until 0
evals/evals-freenode-#perl.lst[1926]: fork => until 0 => $$, "\d"
evals/evals-freenode-#perl.lst[1927]: fork while fork
evals/evals-freenode-#perl.lst[1928]: fork while fork;
evals/evals-freenode-#perl.lst[1929]: fork while fork'
evals/evals-freenode-#perl.lst[1930]: for (map $_, 'hello') { $_ = 42 }
evals/evals-freenode-#perl.lst[1931]: formatbw\.css   # not valid
evals/evals-freenode-#perl.lst[1932]: for my $a(1 .. 100) { if ($a == 4) last; }
evals/evals-freenode-#perl.lst[1933]: for my $cat (1,2,3,4) { $cat++ }
evals/evals-freenode-#perl.lst[1934]: for \my %hash ({foo => 1}, {foo => 2}) { say $hash{foo}; }
evals/evals-freenode-#perl.lst[1935]: for(my $i=0;$i<10;$i++) {print "Don't spam, please!"\n";}
evals/evals-freenode-#perl.lst[1936]: for(my $i=0;$i<10;$i++) {print "Don't spam, please!\n";}
evals/evals-freenode-#perl.lst[1937]: for(my $i = 0; $i < 10; $i++) { print "Hello #$i "; }
evals/evals-freenode-#perl.lst[1938]: for(my $i = 0; $i < 10; $i++) { print "Hello #$i\n"; }
evals/evals-freenode-#perl.lst[1939]: for(my $i =0; $i <= $#$ref;$i++){ print @$ref[$i] , "\n";}
evals/evals-freenode-#perl.lst[1940]: for my $i (1..100) {push @a, [(1) x 1024*1024]}; scalar @a
evals/evals-freenode-#perl.lst[1941]: for my $i (1 .. 10) { print "Hello #$i "; }
evals/evals-freenode-#perl.lst[1942]: for my $i (1..30) {push @a, [(1) x 1024*1024]}; scalar @a
evals/evals-freenode-#perl.lst[1943]: for my $k (keys %{{a=>1, b=>2, c=>3}}) { print $k } # works fine with hashes only known by reference too
evals/evals-freenode-#perl.lst[1944]: for my $k (keys %ENV) { print $k } # perfectly normal
evals/evals-freenode-#perl.lst[1945]: for my $x ( 1..10 ) { print $x }
evals/evals-freenode-#perl.lst[1946]: for my $x ( 1..10 ) { say $x }
evals/evals-freenode-#perl.lst[1947]: for (my $x = 1; $x < 10; $x += my $y) { $y=$x; say $x}
evals/evals-freenode-#perl.lst[1948]: for (my $x = 1; $x < 10; $x += my $y) { $y=$x; say $x; push @wtf, \$y; } say "@wtf"
evals/evals-freenode-#perl.lst[1949]: for (my ($x, $y) = ("A", "B")) { print "$x $y. "; }
evals/evals-freenode-#perl.lst[1950]: for (my ($x, $y) = ("A", "B")) { print "$x $y (current value: $_). "; }
evals/evals-freenode-#perl.lst[1951]: for (()) { next }
evals/evals-freenode-#perl.lst[1952]: for $_ qw(foo bar baz) { print }
evals/evals-freenode-#perl.lst[1953]: for ([qw/foo bar/]->${\\&CORE::values}) { print }
evals/evals-freenode-#perl.lst[1954]: for ([qw/foo bar/]->${\\&values}) { print }
evals/evals-freenode-#perl.lst[1955]: for (while 1) {}
evals/evals-freenode-#perl.lst[1956]: 'Ḟ' =~ /\P{UpperCase}/
evals/evals-freenode-#perl.lst[1957]: @f{qw/sign exponent fraction/} = (unpack "b*",(pack "d", 0.9999999999999926)) =~ /^(\d)(\d{11,11})(\d+)$/; \%f
evals/evals-freenode-#perl.lst[1958]: *f = sub { 23 }; no strict; &{'f'}()
evals/evals-freenode-#perl.lst[1959]: "ft\n" =~ m/ft$/ ? 't' : 'f'
evals/evals-freenode-#perl.lst[1960]: *fuck = sub { 123 }; fuck()
evals/evals-freenode-#perl.lst[1961]: "F­u­dge" =~ /\N{SOFT HYPHEN}/;
evals/evals-freenode-#perl.lst[1962]: Function::Parameters->VERSION
evals/evals-freenode-#perl.lst[1963]: "gammadelta" =~ /alfa(bravo)|(gamma)delta/
evals/evals-freenode-#perl.lst[1964]: getlogin()
evals/evals-freenode-#perl.lst[1965]: [glob("../*")]
evals/evals-freenode-#perl.lst[1966]: (glob '*')[0]
evals/evals-freenode-#perl.lst[1967]: [[ ((glob("*.*"))[0]) ]]
evals/evals-freenode-#perl.lst[1968]: [ glob "123{4,5,6,7}" ]
evals/evals-freenode-#perl.lst[1969]: [ glob("{1,2,3,4,5,6,7,8,9,10}{11,12,13,14,15,16,17,17,18,19,20}") ]
evals/evals-freenode-#perl.lst[1970]: [ glob "123[4 .. 7]" ]
evals/evals-freenode-#perl.lst[1971]: [ glob "123[4-7]" ]
evals/evals-freenode-#perl.lst[1972]: [ glob '"{1,2}{ no split on space,d}"' ]
evals/evals-freenode-#perl.lst[1973]: [glob "[abc]"]
evals/evals-freenode-#perl.lst[1974]: [glob "{a,b,c}"]
evals/evals-freenode-#perl.lst[1975]: [glob "abc"]
evals/evals-freenode-#perl.lst[1976]: [ glob '{a,b,c,d}' x 4 ]
evals/evals-freenode-#perl.lst[1977]: [ glob '{a,b}' x 2 ]
evals/evals-freenode-#perl.lst[1978]: [glob "foo{a,b}"]
evals/evals-freenode-#perl.lst[1979]: glob "foo{a,b}"
evals/evals-freenode-#perl.lst[1980]: [glob "foo{a,b}{c,d}"]
evals/evals-freenode-#perl.lst[1981]: [ glob "{${\join ',', 'a' .. 'e'}}" x 2 ]
evals/evals-freenode-#perl.lst[1982]: [ glob "kjdasfkjdasfdas/*" ]
evals/evals-freenode-#perl.lst[1983]: *globlal = sub {"Hello World"}; globlal()
evals/evals-freenode-#perl.lst[1984]: \*globlal = sub {"Hello World"}; globlal()
evals/evals-freenode-#perl.lst[1985]: [glob("/*")] # nothing even in /?
evals/evals-freenode-#perl.lst[1986]: [ glob '"samuel road"' =~ s/\bsamuel\b/{samuel,sam,s}/gr =~ s/\broad\b/{road,street,alley}/gr ]
evals/evals-freenode-#perl.lst[1987]: [[ ((glob("*.txt"))[0]) ]]
evals/evals-freenode-#perl.lst[1988]: [[ ((glob("*.txt"))[0..3]) ]]
evals/evals-freenode-#perl.lst[1989]: [glob ".[Zz][Ii][Pp]"]
evals/evals-freenode-#perl.lst[1990]: [glob {".[Zz][Ii][Pp]"}]
evals/evals-freenode-#perl.lst[1991]: gmtime
evals/evals-freenode-#perl.lst[1992]: "" . gmtime
evals/evals-freenode-#perl.lst[1993]: "".gmtime
evals/evals-freenode-#perl.lst[1994]: gmtime . ""
evals/evals-freenode-#perl.lst[1995]: gmtime.""
evals/evals-freenode-#perl.lst[1996]: gmtime 0
evals/evals-freenode-#perl.lst[1997]: [ gmtime("NaN") ]
evals/evals-freenode-#perl.lst[1998]: [ "GMT" =~ /(?:[PMCE][SD]T|UTC)/ ? 'match' : 'nomatch' ]
evals/evals-freenode-#perl.lst[1999]: ~("Goat" & " ") ^ "oatgma"
evals/evals-freenode-#perl.lst[2000]: "Goat" & " " | "oatgma"
evals/evals-freenode-#perl.lst[2001]: "Good morning! Sabah el kheer   صباح الخير" =~  m{[^\x00-\x7f]}
evals/evals-freenode-#perl.lst[2002]: goto LABEL; [do { ; LABEL: 42 }];
evals/evals-freenode-#perl.lst[2003]: goto LABEL; [do { ; LABEL: print 'wut' }];
evals/evals-freenode-#perl.lst[2004]: goto LABEL; [do { ; LABEL: print 'wut' } 1];
evals/evals-freenode-#perl.lst[2005]: goto LABEL; [grep { ; LABEL: print 'wut' } 1];
evals/evals-freenode-#perl.lst[2006]: goto LABEL; [map { ; LABEL: print 'wut' } 1];
evals/evals-freenode-#perl.lst[2007]: [ grep /.../ ]
evals/evals-freenode-#perl.lst[2008]: [ grep $_, "0 and false" , 1 , "false", 0 ]
evals/evals-freenode-#perl.lst[2009]: [ grep 1 ]
evals/evals-freenode-#perl.lst[2010]: [grep { !($_ & ($_-1)) } 0 .. 1024]
evals/evals-freenode-#perl.lst[2011]: [ grep !/(.).*\1/, glob '{a,b,c,d}' x 4 ]
evals/evals-freenode-#perl.lst[2012]: [ grep $_ % 2, 1 .. 20 ]
evals/evals-freenode-#perl.lst[2013]: [ grep { $_-=2 } 1,2,3,4,5 ]
evals/evals-freenode-#perl.lst[2014]: [ grep { $_-=2 } 1..5 ]
evals/evals-freenode-#perl.lst[2015]: [ grep { $_+=2 } 1..5 ]
evals/evals-freenode-#perl.lst[2016]: [ grep { $_-=2 } 1..5 ]  # where's my error
evals/evals-freenode-#perl.lst[2017]: [ grep { ($_ >= 5) .. ($_ <= 18) } (1..20) ]
evals/evals-freenode-#perl.lst[2018]: [grep $_ == 5 .. $_ == 18, 1 ..20]
evals/evals-freenode-#perl.lst[2019]: [grep $_ == 5 .. $_ == 18, reverse 1 ..20]
evals/evals-freenode-#perl.lst[2020]: [ grep { /a/ and /b/ } qw/abc cat bat/ ]
evals/evals-freenode-#perl.lst[2021]: [ grep /(a.a)/, qw(apple pear banana) ]
evals/evals-freenode-#perl.lst[2022]: [ grep { /a/ && /b/ } qw/abc cat bat/ ]
evals/evals-freenode-#perl.lst[2023]: [grep { $_ =~ /\Afoobar.(?:true|false|yes|no)\z/ms } ("foobar=true", "foobar.yes", "foobar|no", "foobar.lambda",)];
evals/evals-freenode-#perl.lst[2024]: grep { $_ =~ /\Afoobar.(?:true|false|yes|no)\z/ms } ("foobar=true", "foobar.yes", "foobar|no", "foobar.lambda",);
evals/evals-freenode-#perl.lst[2025]: [ grep /a(x{0,3})(??{'y' x length $1})b/, qw( axxxyyb axxxyyyb axxxyyyyb ) ]  # Su-Shee
evals/evals-freenode-#perl.lst[2026]: [ grep /^[a-z0-9]*[a-z](\.[a-z0-9]*[a-z])*\z/, qw( foo.bar foo foo..bar foo0.bar foo.bar. ) ]
evals/evals-freenode-#perl.lst[2027]: [grep "cats", qw(dogs badgers monkeys)]
evals/evals-freenode-#perl.lst[2028]: grep chr() =~ /[[:space:]]/, 0 .. 0x10_ffff
evals/evals-freenode-#perl.lst[2029]: [grep defined, "this is (a test,a problem)" =~ /.*\(|\).*|([^,()]+)/g ]
evals/evals-freenode-#perl.lst[2030]: !grep($_ eq 'bbb', qw(aaa bbb ccc)) ? 'not present' : 'present'
evals/evals-freenode-#perl.lst[2031]: !grep($_ eq 'xxx', qw(aaa bbb ccc)) ? 'not present' : 'present'
evals/evals-freenode-#perl.lst[2032]: [ grep /foo(?!.*bar)/, qw( foo bar foobar fooooooobar  foosomebar foosomeba ) ]
evals/evals-freenode-#perl.lst[2033]: [ grep /^([^()]+|\([^()]*\))*$/g, "foo", "foo (bar)", "(bar) foo", "foo (bar) baz", "foo (bar" ]
evals/evals-freenode-#perl.lst[2034]: grep $_ .= '-haha', map $_, qw(a b c d e)
evals/evals-freenode-#perl.lst[2035]: grep $_ .= '-haha', qw(a b c d e)
evals/evals-freenode-#perl.lst[2036]: [ grep /h/, map chr, (0..0x3000) ]
evals/evals-freenode-#perl.lst[2037]: [grep -iP { $_ =~ /(?:foobar)(?:\s.\s|.)(?:true|false|yes|no) } ("foobar=true", "foobar = true", "FOOBAR:no", "barfoo=yes",)];
evals/evals-freenode-#perl.lst[2038]: [ grep /json/i, keys %INC ]
evals/evals-freenode-#perl.lst[2039]: [grep /JSON/, keys %INC ]
evals/evals-freenode-#perl.lst[2040]: [grep /::/,keys \%::]
evals/evals-freenode-#perl.lst[2041]: [ grep { length * 2 < 4 } qw/a bcd efgh i j k/ ]
evals/evals-freenode-#perl.lst[2042]: [ grep { length <= 3 } qw/a bcd efgh i j k/ ]
evals/evals-freenode-#perl.lst[2043]: [ grep { length >= 3 } qw/a bcd efgh i j k/ ]
evals/evals-freenode-#perl.lst[2044]: [ grep /[\[\]]/, map chr, 0..255 ]
evals/evals-freenode-#perl.lst[2045]: [ grep m|^http://(?!.*avatar)|, qw( http://assets.tumblr.com/images/default_avatar/octahedron_open_48.png http://assets.tumblr.com/images/default_avatar/cube_closed_48.png http://40.media.tumblr.com/b3e62ef833996a4ffb544ed37300807d/tumblr_nlf8czGMpJ1s61cido1_500.jpg http://40.media.tumblr.com/c0e108161497f351e40db139289b3818/tumblr_nldblnzio71s61cido1_500.jpg ) ]
evals/evals-freenode-#perl.lst[2046]: grep { $_->{name}[0] eq $w } @list,
evals/evals-freenode-#perl.lst[2047]: grep { $_->{name}[0] eq $w }, @list
evals/evals-freenode-#perl.lst[2048]: [ grep { not (1../3/) } (1..10) ]
evals/evals-freenode-#perl.lst[2049]: [ grep { not (1 + index $_, 'approver') and m/help.*?\@example.net/ } qw(help-approver@example.net help-comment@example.net help@example.net) ];
evals/evals-freenode-#perl.lst[2050]: [ grep { not (do{1}../3/) } (1..10) ]
evals/evals-freenode-#perl.lst[2051]: [ grep { not eval } a..z ]
evals/evals-freenode-#perl.lst[2052]: grep $_, @order[-1]
evals/evals-freenode-#perl.lst[2053]: [ grep { scalar(/\Aw\z/../\Af\z/) } qw/m tu w th f sa su/ ]
evals/evals-freenode-#perl.lst[2054]: [ grep Scalar::Util::looks_like_number $_, split ' ', "foo 12 bar lol super-yay 13_000 20.12 baz" ]
evals/evals-freenode-#perl.lst[2055]: [ grep Scalar::Util::looks_like_number $_, split ' ', "foo 12 bar lol super-yay 13 baz" ]
evals/evals-freenode-#perl.lst[2056]: [ grep /^scaleaddr(\d)=([^\d]*)/i, qw(blahj blah blah ScaleAddr5=abc) ];
evals/evals-freenode-#perl.lst[2057]: [ grep /^scaleaddr(\d)/i qw/scaleaddr123/ ];
evals/evals-freenode-#perl.lst[2058]: [ grep /\s/,map chr,  0..255 ]
evals/evals-freenode-#perl.lst[2059]: [  grep { $_ !~ /:/ } split('\s+', 'frog abd:def "jumping jack" 123:456 book jimbo:"billy bob" elephant') ]
evals/evals-freenode-#perl.lst[2060]: grep { $_ !~ /:/ } split('\s+', 'frog abd:def "jumping jack" 123:456 book jimbo:"billy bob" elephant');
evals/evals-freenode-#perl.lst[2061]: grep s/\.pm\z//, keys %INC
evals/evals-freenode-#perl.lst[2062]: [ grep tr/()//cdr!~/^\)|\($|\(\(|\)\)/, "foo", "foo (bar)", "(bar) foo", "foo (bar) baz", "foo (bar" ]
evals/evals-freenode-#perl.lst[2063]: [ grep tr/()//cdr=~/^(\(\))*$/g, "foo", "foo (bar)", "(bar) foo", "foo (bar) baz", "foo (bar" ]
evals/evals-freenode-#perl.lst[2064]: [ grep /^uni/, keys %INC ]
evals/evals-freenode-#perl.lst[2065]: [ grep /^\w{3,10}\z/, qw( one jdhfkjhfkjhdlkfjgh qwe.ert abcdefghij  no abcdefghijk ) ]
evals/evals-freenode-#perl.lst[2066]: Grinnz->can('import') ? "has import kthx" : "no such thing"
evals/evals-freenode-#perl.lst[2067]: Grinnz->import()
evals/evals-freenode-#perl.lst[2068]: "guess\nwhat" =~ /\Aguess$/m ? "k" : "wtf"
evals/evals-freenode-#perl.lst[2069]: %h = ( 1=>1, 1=>0, 0=>1, 0=>0 ); [ map { !$_ || $h{$_} ? 'T' : 'F' } keys %h ]
evals/evals-freenode-#perl.lst[2070]: %h = ( 1=>1, 1=>0, 0=>1, 0=>0 ); map { !$_ || $h{$_} ? 'T' : 'F' } keys %h
evals/evals-freenode-#perl.lst[2071]: @h = ( 1=>1, 1=>0, 0=>1, 0=>0 ); [ map { ! $_ || shift @h ? 'T' : 'F' } shift @h ]
evals/evals-freenode-#perl.lst[2072]: @h = ( 1, 1, 1, 0, 0, 1, 0, 0 ); [ map { ! $_ || shift @h ? 'T' : 'F' } shift @h ]
evals/evals-freenode-#perl.lst[2073]: %h = (12 => 'hip', 0x12 => 'hop'); \%h
evals/evals-freenode-#perl.lst[2074]: %h = 1..6; {%h{1,3}}
evals/evals-freenode-#perl.lst[2075]: %h = 1..6; +{%h{1,3}}
evals/evals-freenode-#perl.lst[2076]: %h = 1..6; +{%h{1,3,5}} # boo
evals/evals-freenode-#perl.lst[2077]: %h = 1..6; +{%h{1,3,7}} # boo
evals/evals-freenode-#perl.lst[2078]: [\(%h1, %h2, %h3)]
evals/evals-freenode-#perl.lst[2079]: %h = ( 1=>"one", 2=>"two" ); map { print "key: $_ val: $h{$_}" } keys %h
evals/evals-freenode-#perl.lst[2080]: $h = { 25 => 1 }; my $idx = "25 "; [ $h->{$idx}, $h->{0+$idx} ]
evals/evals-freenode-#perl.lst[2081]: $h = { 25 => 1 }; my $idx = "25"; [ $h->{$idx}, $h->{0+$idx} ]
evals/evals-freenode-#perl.lst[2082]: $^H=256;join(($x)x101)
evals/evals-freenode-#perl.lst[2083]: $^H=256;join($x)x101
evals/evals-freenode-#perl.lst[2084]: %h=( 'a'=>'1', 'b'=>'2' ); %h=( 'c'=>'3', 'd'=>'4' ); for ( sort keys %h ){ print "$_ $h{$_" };
evals/evals-freenode-#perl.lst[2085]: %h=( 'a'=>'1', 'b'=>'2' ); %h=( 'c'=>'3', 'd'=>'4' ); for ( sort keys %h ){ print "$_ $h{$_}" };
evals/evals-freenode-#perl.lst[2086]: %h = (a => 1); scalar %h
evals/evals-freenode-#perl.lst[2087]: @h{'a' .. 'c'} = 1 .. 3; ++$_ for values %h; \ %h;
evals/evals-freenode-#perl.lst[2088]: halal
evals/evals-freenode-#perl.lst[2089]: `halt`;
evals/evals-freenode-#perl.lst[2090]: $h = {'a' => {'one' => 1}, "b" => 2}; $i = {'a' => {'two' => 2}; $j = {%$h, %$i}; print Dumper($j);
evals/evals-freenode-#perl.lst[2091]: $h = {'a' => {'one' => 1}, "b" => 2}; $i = {'a' => {'two' => 2}}; $j = {%$h, %$i}; print Dumper($j);
evals/evals-freenode-#perl.lst[2092]: $h = {'a' => {'one' => 1}, "b" => 2}}; $i = {'a' => {'two' => 2}}; $j = {%$h, %$i}; print Dumper($j);
evals/evals-freenode-#perl.lst[2093]: 'Happy ' . (int(1970 + time() / 31557600)+1)
evals/evals-freenode-#perl.lst[2094]: 'Happy ' . int(1970 + time() / 31557600)+1
evals/evals-freenode-#perl.lst[2095]: %hash = 1..4; delete @hash{1,3}; scalar %hash
evals/evals-freenode-#perl.lst[2096]: %hash = 1..4; scalar %hash
evals/evals-freenode-#perl.lst[2097]: %hash = (1..8); $_++ for %hash; \%hash
evals/evals-freenode-#perl.lst[2098]: %hash = (1..8); %hashtwo = (a..j); $_++ for %hash, %hashtwo; [ \%hash, \%hashtwo ]
evals/evals-freenode-#perl.lst[2099]: %hash1 = ( foo => 1, bar => 2 ); %hash2 = ( baz => undef, quux => \%hash1 );  \%hash2
evals/evals-freenode-#perl.lst[2100]: %hash1 = ( foo => 1, bar => 2 ); %hash2 = ( baz => undef, quux => \%hash1 );  $hash2{quux}
evals/evals-freenode-#perl.lst[2101]: %hash1 = ( foo => 1, bar => 2 ); %hash2 = ( baz => undef, quux => \%hash1 );  $hash2{quux}{bar}
evals/evals-freenode-#perl.lst[2102]: %hash=(2=>"two", 1=>"one"); print sort { $a cmp $b } keys %hash
evals/evals-freenode-#perl.lst[2103]: %hash=(2=>"two", 1=>"one"); print sort keys { $a cmp $b } keys %hash
evals/evals-freenode-#perl.lst[2104]: %hash = @array = qw/a list of stuff/; [ \%hash, \@array ]   # you have arrayrefs though. see perldoc perlreftut
evals/evals-freenode-#perl.lst[2105]: $hash = { a => 'z', b => { c => 'y' } }; if(ref $hash->{a} ne ;
evals/evals-freenode-#perl.lst[2106]: $hash = { a => 'z', b => { c => 'y' } }; if(ref $hash->{a} ne 'ARRAY' && ref $hash->{a} ne 'HASH') { print 'scalar' };
evals/evals-freenode-#perl.lst[2107]: $hash = { a => 'z', b => { c => 'y' } }; ref $hash->{b};
evals/evals-freenode-#perl.lst[2108]: %hash = (); @hash{a..f} = (1)x7; $_++ for @hash{a,c,f}; \%hash  # hehehe
evals/evals-freenode-#perl.lst[2109]: $hash{'key1'} = "val1"; print ref %hash
evals/evals-freenode-#perl.lst[2110]: $hash{'key1'} = "val1"; print ref $hash{'key1'}
evals/evals-freenode-#perl.lst[2111]: $hash{"key1"}="val2"; $hash{"key2"}="val1"; for ( sort { $hash{$a} cmp $hash{$b} } keys %hash ) { print "key: $_: val: $hash{$_}, "; };
evals/evals-freenode-#perl.lst[2112]: $hash{"key1"}="val2"; $hash{"key2"}="val1"; for ( sort { $hash{$a} <=> $hash{$b} } keys %hash ) { print "key: $_: val: $hash{$_}, "; };
evals/evals-freenode-#perl.lst[2113]: $hash{"key1"}="val2"; $hash{"key2"}="val1"; for ( sort { $hash{$b} cmp $hash{$a} } keys %hash ) { print "key: $_: val: $hash{$_}, "; };
evals/evals-freenode-#perl.lst[2114]: $hash{"key1"}="val2"; $hash{"key2"}="val1"; for ( sort { $hash{$b} <=> $hash{$a} } keys %hash ) { print "key:$_: val:$hash{$_}, "; };
evals/evals-freenode-#perl.lst[2115]: %hash = map { join '', 1..1+ rand 9} 1..20; $long = ''; $long |= $_ for keys %hash; [ \%hash, "longest key is " . length $long ]
evals/evals-freenode-#perl.lst[2116]: %hash={ 'stuff' => 'sterf' } ; \%hash
evals/evals-freenode-#perl.lst[2117]: $h->{bar} eq 'lol'; $h->{baz}->{whiz} eq 'lol'; $h
evals/evals-freenode-#perl.lst[2118]: $h->{bar} eq 'lol'; $h->{baz}->{whiz} = 'lol'; $h
evals/evals-freenode-#perl.lst[2119]: "hello 123 time 8:08 =~ m/{\A .* on (.*) }xms/;
evals/evals-freenode-#perl.lst[2120]: "hello 123 time 8:08" =~ m/{\A .* on (.*) }xms/;
evals/evals-freenode-#perl.lst[2121]: [ "hello" =~ /^([a-z]+)(?:\s+(.+))?$/ ]
evals/evals-freenode-#perl.lst[2122]: $_ = "hello"; /e/c or die; [pos]
evals/evals-freenode-#perl.lst[2123]: "hello it is now on 8:08" =~ m{\A .* on (.*) }xms;
evals/evals-freenode-#perl.lst[2124]: ("hello it is now on 8:08" =~ m{\A .* on (.*) }xms);
evals/evals-freenode-#perl.lst[2125]: ["hello it is now on 8:08" =~ m{\A .* on (.*) }xms];
evals/evals-freenode-#perl.lst[2126]: [ "hello\nworld" =~ m/(.*(?:\n|$))/g ]
evals/evals-freenode-#perl.lst[2127]: [ "hello\nworld" =~ /^.*\n?/mg ]
evals/evals-freenode-#perl.lst[2128]: "Hello" =~ /^.*(.+)$(??{print"$1\n"})/
evals/evals-freenode-#perl.lst[2129]: "Hello" =~ /(?!^).*(.+)$(??{print"$1\n"})/    # test
evals/evals-freenode-#perl.lst[2130]: "Hello" =~ /(?!^).+(*PRUNE)(?{push @bar, $&})(*FAIL)/; [ reverse @bar ]
evals/evals-freenode-#perl.lst[2131]: "   hello" =~ s/^\s*//sr
evals/evals-freenode-#perl.lst[2132]: $_ = " hello there 123... the time is 8:08";  [ /(\d+:\d+)/ ]
evals/evals-freenode-#perl.lst[2133]: [ "hello there" =~ /^([a-z]+)(?:\s+(.+))?$/
evals/evals-freenode-#perl.lst[2134]: [ "hello there" =~ /^([a-z]+)(?:\s+(.+))?$/ ]
evals/evals-freenode-#perl.lst[2135]: [ "hello there" =~ /^([a-z]+)\s*(|(?<=\s).+)$/ ]
evals/evals-freenode-#perl.lst[2136]: [ "hello-there" =~ /^([a-z]+)\s*(|(?<=\s).+)$/ ]
evals/evals-freenode-#perl.lst[2137]: [ "hellothere" =~ /^([a-z]+)\s*(|(?<=\s).+)$/ ]
evals/evals-freenode-#perl.lst[2138]: $_ = " hello time time time time time time there 123... the time is 8:08";  [ /the time is (\d+:\d+)/ ]
evals/evals-freenode-#perl.lst[2139]: ["Hello" =~ tr/l/g/r
evals/evals-freenode-#perl.lst[2140]: ["Hello" =~ tr/l/g/r]
evals/evals-freenode-#perl.lst[2141]: {%{hello=>"world"}}
evals/evals-freenode-#perl.lst[2142]: %{%{{hello=>"world"}}}
evals/evals-freenode-#perl.lst[2143]: %{%{hello=>"world"}}
evals/evals-freenode-#perl.lst[2144]: $_ = 'hello, world, foo bar baz';  [ map tr/ /-/r, split /,\s*/ ]
evals/evals-freenode-#perl.lst[2145]: $_ = 'hello, world, foo bar baz';  [ map tr/ /-/r, split /,\s*/ ] # try three :)
evals/evals-freenode-#perl.lst[2146]: [ "Hello, world!" =~ m/(....)/g ]
evals/evals-freenode-#perl.lst[2147]: [ "Hello, world!" =~ m/(....)/g; ]
evals/evals-freenode-#perl.lst[2148]: $_ = 'hello world'; push @ar, [$1,$2] while /(.)(.)/g; \@ar
evals/evals-freenode-#perl.lst[2149]: "Hello, world" =~ tr/A-Za-z/N-ZA-Mn-za-m/
evals/evals-freenode-#perl.lst[2150]: 'help-approver@example.net' =~ /^(?!help-approver).+\@example\.net$/
evals/evals-freenode-#perl.lst[2151]: 'help-approver@example.net' =~ /(?<!^help-approver)\@example\.net$/
evals/evals-freenode-#perl.lst[2152]: 'help-approver@example.net' =~ /(?<!help-approver)\@example\.net$/
evals/evals-freenode-#perl.lst[2153]: 'help-approver@example.net' =~ /(?!<^help-approver)\@example\.net$/
evals/evals-freenode-#perl.lst[2154]: 'help-approver@example.net' =~ /(?!<help-approver)\@example\.net$/
evals/evals-freenode-#perl.lst[2155]: 'help-approver@example.net' =~ /(?!help-approver).+\@example\.net/
evals/evals-freenode-#perl.lst[2156]: 'help-comment@example.net' =~ /^(?!help-approver).+\@example\.net$/
evals/evals-freenode-#perl.lst[2157]: 'help@example.net' =~ /(?<!help-approver)\@example\.net$/
evals/evals-freenode-#perl.lst[2158]: here
evals/evals-freenode-#perl.lst[2159]: +{[ here => "are", my => "values" ]}
evals/evals-freenode-#perl.lst[2160]: HERE: { print 1; HERE: { print 2; HERE: { print 3; goto HERE } } }
evals/evals-freenode-#perl.lst[2161]: HERE: { print 1; HERE: { print 2; HERE: { print 3; goto HERE unless $i++ > 2 } } }
evals/evals-freenode-#perl.lst[2162]:  ${{here,there}}{here};
evals/evals-freenode-#perl.lst[2163]: \&hex
evals/evals-freenode-#perl.lst[2164]: hex("000001448e317907") / 1000
evals/evals-freenode-#perl.lst[2165]: hex '0a'
evals/evals-freenode-#perl.lst[2166]: hex '0x0a'
evals/evals-freenode-#perl.lst[2167]: hex "0x14"
evals/evals-freenode-#perl.lst[2168]: \&hex->("0x24")
evals/evals-freenode-#perl.lst[2169]: hex "0xabcd"
evals/evals-freenode-#perl.lst[2170]: hex $1
evals/evals-freenode-#perl.lst[2171]: hex "1e0"
evals/evals-freenode-#perl.lst[2172]: hex 41
evals/evals-freenode-#perl.lst[2173]: hex "4155"
evals/evals-freenode-#perl.lst[2174]: $hex = '6060FF'; [ unpack q{L>*}, pack q{H*}, '0' x (-length($hex) % 8) . $hex ]
evals/evals-freenode-#perl.lst[2175]: hex "dead"
evals/evals-freenode-#perl.lst[2176]: hex 'f' x 16
evals/evals-freenode-#perl.lst[2177]: hex q{112233445566778899}
evals/evals-freenode-#perl.lst[2178]: "hey, this contains A-Z somewhere" =~ /A-Z/ ? 'true' : 'false'
evals/evals-freenode-#perl.lst[2179]: $^H{feature_state} = 1; sub foo { state $x; }
evals/evals-freenode-#perl.lst[2180]: $h = { "foo" => 42 } ;  push @{$h->{foo}}, 17;  say $h->{foo};  # Really?
evals/evals-freenode-#perl.lst[2181]: $h = {foo => 5, bar => 6, baz => 2}; [@{$h}{qw(foo bar baz)}] # is that what you mean?
evals/evals-freenode-#perl.lst[2182]: $h = {foo => 5, bar => 6}; [$h->{foo}]
evals/evals-freenode-#perl.lst[2183]: $h = {foo => 5, bar => 6}; [@{$h}{qw/foo/}]
evals/evals-freenode-#perl.lst[2184]: $H{'foobar'}++
evals/evals-freenode-#perl.lst[2185]: @h{grep !/[a-zA-Z{}]/, split //, "MPOPCNTSF: INTEGER[9]"} = (); join '', keys %h
evals/evals-freenode-#perl.lst[2186]: $h="hello world!"; $h=~ s/(.){1}(.){1}/$2,$1/eg; print $h
evals/evals-freenode-#perl.lst[2187]: $h="hello world!"; $h=~ s/(.)(.)/$2,$1/eg; print $h
evals/evals-freenode-#perl.lst[2188]: $h="hello world!"; $h=~ s/(.)(.)/$cipher.=chr(ord($1)+1).chr(ord($2)+1);/eg; print $cipher
evals/evals-freenode-#perl.lst[2189]: $h="hello world!"; $h=~ s/(.)(.)/$cipher.=chr(ord($1)+1).chr(ord($2)+1);/eg; print "$h == $cipher"
evals/evals-freenode-#perl.lst[2190]: $h="hello world!"; $h=~ s/(.)(.)/$h="$2$1";/eg; print $h
evals/evals-freenode-#perl.lst[2191]: $h="hello world!"; $h=~ s/(.)(.)/$h=$2++.$1++;/eg; print $h
evals/evals-freenode-#perl.lst[2192]: $h="hello world!"; $h=~ s/(.)(.)/$h=chr(ord($1)+1.$1++;/eg; print $h
evals/evals-freenode-#perl.lst[2193]: $h="hello world!"; $h=~ s/(.)(.)/$h=chr(ord($1)+1).chr(ord($2)+1);/eg; print $h
evals/evals-freenode-#perl.lst[2194]: $h="hello world!"; $h=~ s/(.)(.)/$h=uc($2)."$1";/eg; print $h
evals/evals-freenode-#perl.lst[2195]: $h="hello world!"; $h=~ s/(.)(.)/$h=uc($2).$1";/eg; print $h
evals/evals-freenode-#perl.lst[2196]: hi
evals/evals-freenode-#perl.lst[2197]: "hi"
evals/evals-freenode-#perl.lst[2198]: %h = (ichi, ni, san, shi); $h{ichi}
evals/evals-freenode-#perl.lst[2199]: ["Hi mace"]
evals/evals-freenode-#perl.lst[2200]: $_="hi"; print();
evals/evals-freenode-#perl.lst[2201]: $_="hi"; print(undef);
evals/evals-freenode-#perl.lst[2202]: 'Hi these_eyes' x 3
evals/evals-freenode-#perl.lst[2203]: "hi" x 4
evals/evals-freenode-#perl.lst[2204]: [("hi") x 4]
evals/evals-freenode-#perl.lst[2205]: '{# hiya #} {# world #}' =~ m/{#\s?(.+?)\s?#}/g; $1;
evals/evals-freenode-#perl.lst[2206]: "hlagh"**0
evals/evals-freenode-#perl.lst[2207]: $h{'login'} = 'foo'; $h{login}
evals/evals-freenode-#perl.lst[2208]: %h = map { /^(.+)\.(.*?)\.\1$/ } "aaa.one.aaa", "bbb.two.bbb", "ccc.test.ccc", "asd.fg.foo.asd.fg"; \%h
evals/evals-freenode-#perl.lst[2209]: %h = map { split /:/ } qw( a:123 b:456 ); \%h
evals/evals-freenode-#perl.lst[2210]: $_ = 'hood'; s/h(.*)d/n$1k/r
evals/evals-freenode-#perl.lst[2211]: $href = { "foo"=>"bar" }; [ %$href ]
evals/evals-freenode-#perl.lst[2212]: $href = { "foo"=>"bar" }; lock_ref_keys($href); map { print "\"$_\":$href->{$_}\n" } %{$href}
evals/evals-freenode-#perl.lst[2213]: $href = { "foo"=>"bar" }; map { print "\"$_\":$href->{$_}\n" } %{$href}
evals/evals-freenode-#perl.lst[2214]: $href = { "foo"=>"bar" }; print (%{$href})
evals/evals-freenode-#perl.lst[2215]: $href = { "foo"=>"bar" }; print $href->{"foo"}
evals/evals-freenode-#perl.lst[2216]: $href = { "foo"=>"bar" }; sub pr { print @_ }; pr( %$href );
evals/evals-freenode-#perl.lst[2217]: $hs1 = { _ -> {} }
evals/evals-freenode-#perl.lst[2218]: $h->{someKey}->{whatever} = 'abc'; qr/X$h->{someKey}->{whatever}Y/
evals/evals-freenode-#perl.lst[2219]: %h = { stuff => 'sterf' }; \%h
evals/evals-freenode-#perl.lst[2220]: ["<html>foo</html>" =~ /<([^>]+)>\s*$/m]
evals/evals-freenode-#perl.lst[2221]: $_="http://a?k1=v1&k2=v2"; $_=(split /\?/)[-1]; [ map { split /=/ } (split /&/) ]
evals/evals-freenode-#perl.lst[2222]:  [ 'http://go2web4free.com:7004/img/users/1/1J2KAFHQk_.jpg' =~ m{[^/]+$}g ]
evals/evals-freenode-#perl.lst[2223]: http://google.com $html->at('title')->text
evals/evals-freenode-#perl.lst[2224]: https://gist.github.com/anonymous/599c9b609f78f9b0abf4
evals/evals-freenode-#perl.lst[2225]: https://gist.github.com/zoffixznet/2ad28e7398c95bb4c92d#file-test-pl-L9
evals/evals-freenode-#perl.lst[2226]: http://www.google.com/ $html = lc $html; $html =~ tr/a-z/n-za-m/;
evals/evals-freenode-#perl.lst[2227]: http://www.google.com/ $html = lc $html; $html =~ tr/a-z/n-za-m/; $html
evals/evals-freenode-#perl.lst[2228]: http://www.google.com/ ref $html
evals/evals-freenode-#perl.lst[2229]: "http://www.google.com" =~ s/http:\/\//http:\/\/CLOUD_NETWORK.1.1:2144\//r # I get www.google.com at the end
evals/evals-freenode-#perl.lst[2230]: [ 'http://www.site.com/letters0241/something-in-australia-a' =~ m[/(?:[^-/]*-){2}([^-/]*)[^/]*\z] ]
evals/evals-freenode-#perl.lst[2231]: [ 'http://www.site.com/letters0241/something-in-australia-a' =~ m[something-in-([^-]*)] ]
evals/evals-freenode-#perl.lst[2232]: $_ = "huf"; ++$_
evals/evals-freenode-#perl.lst[2233]: huf->can("be::sure")
evals/evals-freenode-#perl.lst[2234]: huf->can("can")
evals/evals-freenode-#perl.lst[2235]: huf->can("can")->(huf => "can")->(huf => "can")->(huf => "can")->(huf => "can")->(huf => "can")->(huf => "can")->(huf => "can")
evals/evals-freenode-#perl.lst[2236]: @hyperv = qw(foo bar baz); print @hyperv . "\n"
evals/evals-freenode-#perl.lst[2237]: $i = 0; "aaaa" =~ s/a/(++$i == 2) ? 'b' : $&/ger #hey, you can do it in perl too! :P
evals/evals-freenode-#perl.lst[2238]: $i = 1; for (1 .. 12) { print $i, " "; $i = int $i * (.5 + sqrt 1.25) + .5; }
evals/evals-freenode-#perl.lst[2239]: $i=5; $i = ++$i + ++$i
evals/evals-freenode-#perl.lst[2240]: "I am "
evals/evals-freenode-#perl.lst[2241]: "I am a bot"
evals/evals-freenode-#perl.lst[2242]: "I am a fish ".$_[0]
evals/evals-freenode-#perl.lst[2243]: $_ = 'i am happy'; [ /(?=(....))/g ]
evals/evals-freenode-#perl.lst[2244]: `id`
evals/evals-freenode-#perl.lst[2245]: 'i' ^ 'd'
evals/evals-freenode-#perl.lst[2246]: [ 'i' ^ 'd' ]
evals/evals-freenode-#perl.lst[2247]: [ "<id>textA<email1><id>textB<email2>" =~ m!<id>([^<>]*)<email2>! ]
evals/evals-freenode-#perl.lst[2248]: [ "<id>textA<email1><id>textB<email2>" =~ m!<id>([^<>]*)<email\d>!g ]
evals/evals-freenode-#perl.lst[2249]: if(0)
evals/evals-freenode-#perl.lst[2250]: if (0) { 'a block' }
evals/evals-freenode-#perl.lst[2251]: if (0) { } esle { } exit
evals/evals-freenode-#perl.lst[2252]: if (1 == 1) { print 'foo'; } else;
evals/evals-freenode-#perl.lst[2253]: if ( 1 ){ do_something(); } sub  do_something { print "heyy"; }
evals/evals-freenode-#perl.lst[2254]: if (1) {} elseif (2) {}
evals/evals-freenode-#perl.lst[2255]: if (1) {} elsif (2) {}
evals/evals-freenode-#perl.lst[2256]: { if (1 ) { last; print "lols"; } print "lulz"; } print "lelz";  # linagee
evals/evals-freenode-#perl.lst[2257]: if(1) {{ print "here"; last; print "not here" }} print " done"
evals/evals-freenode-#perl.lst[2258]: if ('abc' =~ /^a/) { 1 } else { 0 }
evals/evals-freenode-#perl.lst[2259]: if("a" == "b"){print "true";}else{print "false";}
evals/evals-freenode-#perl.lst[2260]: if("a" eq "b"){print "true";}else{print "false";}
evals/evals-freenode-#perl.lst[2261]: "if answer > 0: answer = answer + 2" =~ /^\s*if (.*): (.*)/
evals/evals-freenode-#perl.lst[2262]: if (@a = sub { return }->()) { 1 }
evals/evals-freenode-#perl.lst[2263]: if (@a = sub { return undef }->()) { 1 }
evals/evals-freenode-#perl.lst[2264]: if('besaid' =~ m/(\w*said)/) {print qq{matched "$1"\n};}
evals/evals-freenode-#perl.lst[2265]: `ifconfig -a | grep -i inet`
evals/evals-freenode-#perl.lst[2266]: if (exists $x->{foo}{bar}{baz}) { } [$x]
evals/evals-freenode-#perl.lst[2267]: if (false) { print "false is true!"; }
evals/evals-freenode-#perl.lst[2268]: if...if ($x.endswith("ft"))...
evals/evals-freenode-#perl.lst[2269]: if (int(rand(2))) { return 'wrapper' } return 'builder'
evals/evals-freenode-#perl.lst[2270]: if (my ($var1, $var2) = "foo bar" =~ /(foo|bar)/g) { print "Matches! var1: $var1, var2: $var2"; }
evals/evals-freenode-#perl.lst[2271]: if (my ($var1, $var2) = "foo bar" =~ /(foo)|(bar)/g) { print "Matches! var1: $var1, var2: $var2"; }
evals/evals-freenode-#perl.lst[2272]: if (my ($var1, $var2) = "foo bar" =~ /(foo|bar)/) { print "Matches! var1: $var1, var2: $var2"; } #I'm not quite sure it's entirely correct though
evals/evals-freenode-#perl.lst[2273]: if (my ($var1, $var2) = "foo bar" =~ /(foo)|(bar)/) { print "Matches! var1: $var1, var2: $var2"; } #meant like this rather, but meh
evals/evals-freenode-#perl.lst[2274]: if ((my $var) = ("z" =~ //)) { print "TRUE" ;}
evals/evals-freenode-#perl.lst[2275]: if (my ($x, $y) = (1, 0) { ['true']; } else { ['false'] }
evals/evals-freenode-#perl.lst[2276]: if (my ($x, $y) = (1, 0)) { ['true']; } else { ['false'] }
evals/evals-freenode-#perl.lst[2277]: if  !($sender =~ qr/@ArrayNickHighLight/i) {}
evals/evals-freenode-#perl.lst[2278]: if (!($sender =~ qr/@ArrayNickHighLight/i))
evals/evals-freenode-#perl.lst[2279]: if (!($sender =~ qr/@ArrayNickHighLight/i)) {}
evals/evals-freenode-#perl.lst[2280]: if ($sender !~ qr/@ArrayNightHighLight/i) { ... }
evals/evals-freenode-#perl.lst[2281]: if( "        " =~ /^((\t|\s{4})+)/ ) { print length $1 }
evals/evals-freenode-#perl.lst[2282]: if( "        " =~ /^(\t|\s{4})+/ ) { print length $1 }
evals/evals-freenode-#perl.lst[2283]: "        if (x = 2): print y;        yo" =~ /^([\t ]+)/; my $indents = () = $1 =~ /(\t| {8})/g
evals/evals-freenode-#perl.lst[2284]: if (! $x = foo() )
evals/evals-freenode-#perl.lst[2285]: if ($x->{foo}{bar}{baz}) { } [$x]
evals/evals-freenode-#perl.lst[2286]: if ($x){next}
evals/evals-freenode-#perl.lst[2287]: $_ = "If you can read this, you could be a programmer"; tr/aeiou//d; $_
evals/evals-freenode-#perl.lst[2288]: $i = {"h" => 1, "i" => 2}; $j = "i"; [ ${$j}, $i->{${$j}} ]
evals/evals-freenode-#perl.lst[2289]: "I hate people" =~ s/e//gr
evals/evals-freenode-#perl.lst[2290]: "I" + "I";
evals/evals-freenode-#perl.lst[2291]: $i=$i++;  ++$i + $i++
evals/evals-freenode-#perl.lst[2292]: $i=$i++;  ++$i + $i++  ;
evals/evals-freenode-#perl.lst[2293]: "i like my keys with rings, not within my hammy interior" =~ s/\b(my|with)\b/[$1]/rg
evals/evals-freenode-#perl.lst[2294]: "i like my keys with rings, not within my hammy interior" =~ s/\b(my|with)\b/[$1]/rg -- this one?
evals/evals-freenode-#perl.lst[2295]: "img 34 32 4 3453  m agi  img 34 ag sgd dfg dfs img 54323 423 img 3sadf  asd
evals/evals-freenode-#perl.lst[2296]: "img 34 32 4 3453  m agi  img 34 ag sgd dfg dfs img 54323 423 img 3sadf  asd" =~ s/img/img\n/gr
evals/evals-freenode-#perl.lst[2297]: $in = "abc123def456xyz"; (@out) = $in =~ /\d+/g; \@out;
evals/evals-freenode-#perl.lst[2298]: $in = "abc123def"; ($out) = $in =~ /\d+/g; [$out]; # for added confusion
evals/evals-freenode-#perl.lst[2299]: $in = "abc123def"; ($out) = $in =~ /(\d+)/; [$out]
evals/evals-freenode-#perl.lst[2300]: $in = "abc123def"; ($out) = $in =~ /\d+/; [$out]
evals/evals-freenode-#perl.lst[2301]: [@INC]
evals/evals-freenode-#perl.lst[2302]: @INC;
evals/evals-freenode-#perl.lst[2303]: \@INC
evals/evals-freenode-#perl.lst[2304]: \%INC
evals/evals-freenode-#perl.lst[2305]: %INC
evals/evals-freenode-#perl.lst[2306]: [ %INC/\@INC ]; # hash/array reference
evals/evals-freenode-#perl.lst[2307]: $INC{'version'}
evals/evals-freenode-#perl.lst[2308]: $INC{'version.pm'}
evals/evals-freenode-#perl.lst[2309]: index('abcde', 'd')
evals/evals-freenode-#perl.lst[2310]: [index("foo bar","foo"),index("food","foo")]
evals/evals-freenode-#perl.lst[2311]: [index("foo", "foo bar"),index("foo","food")]
evals/evals-freenode-#perl.lst[2312]: index('test123', 'test') == 0  # I assume?
evals/evals-freenode-#perl.lst[2313]: @indices; for (1 .. 10) { push @indices, 11 - $_ }; [@indices];
evals/evals-freenode-#perl.lst[2314]: 'inf'
evals/evals-freenode-#perl.lst[2315]: 'inf' > ~0
evals/evals-freenode-#perl.lst[2316]: 'inf'/0
evals/evals-freenode-#perl.lst[2317]: 'inf' - 'inf'
evals/evals-freenode-#perl.lst[2318]: inf == inf
evals/evals-freenode-#perl.lst[2319]: "inf" == "Inf"
evals/evals-freenode-#perl.lst[2320]: 'inf'/'nan'
evals/evals-freenode-#perl.lst[2321]: $in="foo"; ($out = $in) .= ".bak"; [ $in, $out ]
evals/evals-freenode-#perl.lst[2322]: $in="foo"; $out = $in .= ".bak"; [ $in, $out ]
evals/evals-freenode-#perl.lst[2323]: "INGY" ^ "perl"
evals/evals-freenode-#perl.lst[2324]: $input = "123\n456"; [ $input =~ /123.*456/ ? "yes" : "no", $input =~ /123.*456/s ? "yes" : "no" ]
evals/evals-freenode-#perl.lst[2325]: $input = '       A         B        C'; [ split " ", $input ]
evals/evals-freenode-#perl.lst[2326]: $input = ideally I'd
evals/evals-freenode-#perl.lst[2327]: int(11/15 * 100);
evals/evals-freenode-#perl.lst[2328]: int(1.139999999999999 * 100)
evals/evals-freenode-#perl.lst[2329]: int(1.14 * 100)
evals/evals-freenode-#perl.lst[2330]: int(134.95 * 100)
evals/evals-freenode-#perl.lst[2331]: int( (1414364400 - 1414274400) / 3600 )
evals/evals-freenode-#perl.lst[2332]: int(19.99*100)
evals/evals-freenode-#perl.lst[2333]: int(2.4213534531451E+30)
evals/evals-freenode-#perl.lst[2334]: int((45/50-1)*100)
evals/evals-freenode-#perl.lst[2335]: int(5/3)
evals/evals-freenode-#perl.lst[2336]: &Internals::SvREADONLY \!0, 0; ${\!0} = 0; defined 'foo'
evals/evals-freenode-#perl.lst[2337]: &Internals::SvREADONLY(\!0, 0); ${\!0} = 0; defined 'foo'
evals/evals-freenode-#perl.lst[2338]: &Internals::SvREADONLY(\undef, 0); undef = []; undef
evals/evals-freenode-#perl.lst[2339]: int((foo); bar()
evals/evals-freenode-#perl.lst[2340]: int rand 0
evals/evals-freenode-#perl.lst[2341]: int rand + 1;
evals/evals-freenode-#perl.lst[2342]: (int rand 2) ? "Yes" : "No"
evals/evals-freenode-#perl.lst[2343]: ((int rand 5) + 22) % 24
evals/evals-freenode-#perl.lst[2344]: (int(rand 5) - 2) % 24
evals/evals-freenode-#perl.lst[2345]: $intsize = length(~1) > 10 ? 64 : 32
evals/evals-freenode-#perl.lst[2346]: int sprintf '%.f', 134.95 * 100
evals/evals-freenode-#perl.lst[2347]: int(((time+256)/1024*123))+1
evals/evals-freenode-#perl.lst[2348]: int(((time+256)/1024*123)+1)
evals/evals-freenode-#perl.lst[2349]: int(((time+256)/1024%123)+1)
evals/evals-freenode-#perl.lst[2350]: int(((time+256))/1024*123)+1
evals/evals-freenode-#perl.lst[2351]: int(((time+256)%1024*123)+1)
evals/evals-freenode-#perl.lst[2352]: " " == int(" ") ? "true" : "false"
evals/evals-freenode-#perl.lst[2353]: "" == int("") ? "true" : "false"
evals/evals-freenode-#perl.lst[2354]: int((x)
evals/evals-freenode-#perl.lst[2355]: int((x); y()
evals/evals-freenode-#perl.lst[2356]: IO::Socket::INET->new()
evals/evals-freenode-#perl.lst[2357]: [ "<ip:11111432941656@192.168.0.230>" =~ /:([0-9]+)/ ]
evals/evals-freenode-#perl.lst[2358]: $i = [qw/5 7 8 2/]; [sum map { scalar @$_ } @i]
evals/evals-freenode-#perl.lst[2359]: $i = [qw/5 7 8 2/]; [sum map { scalar @$_ } @list
evals/evals-freenode-#perl.lst[2360]: $i = [qw/5 7 8 2/]; [sum map { scalar @$_ } @list]
evals/evals-freenode-#perl.lst[2361]: 'irc.freenode.net' =~ /irc\.([^.]+)/ and print $1;
evals/evals-freenode-#perl.lst[2362]: isa {STDOUT} 'GLOB';
evals/evals-freenode-#perl.lst[2363]: isa {STDOUT} 'IO::Handle';
evals/evals-freenode-#perl.lst[2364]: ""->isa("UNIVERSAL")
evals/evals-freenode-#perl.lst[2365]: $_ = "I saw Wilma yesterday"; [ /(\w*)a/, /(\w*a)(\s+[a-zA-Z]{4})/ ]
evals/evals-freenode-#perl.lst[2366]: " is just our way of talking to the evalbot. Nothing to do wih code.
evals/evals-freenode-#perl.lst[2367]: $_ = 'I speak Goat Latin'; my $n = 1; s/\b([^aeiou\W])?(\w+)/"$2\L$1ma".'a'x$n++ ^ (($&&$")^$")/geir
evals/evals-freenode-#perl.lst[2368]: $_ = 'I speAk Goat Latin'; my $n = 1; s/\b([^aeiou\W])?(\w+)/"$2\L$1ma".'a'x$n++ ^ (($&&$")^$")/geir
evals/evals-freenode-#perl.lst[2369]: $_ = 'I speAk Goat Latin'; my $n = 1; s/\b([^aeiou\W])?(\w+)/"\L$2$1ma".'a'x$n++ ^ (($&&$")^$")/geir
evals/evals-freenode-#perl.lst[2370]: $_ = 'I speak Goat Latin'; my $n = 1; s/\b([^\Waeiouy]?)(\w+)/$2\l$1ma/gr =~ s/\w+\K/'a'x$n++/ger
evals/evals-freenode-#perl.lst[2371]: $_ = "I speAk Goat Latin"; my $n = 1; s/\b([^\Waeiouy]?)(\w+)/my $z = "$2\l$1ma" ; ($1=~m"\p{Lu}"?"\u$z":$z)/ger =~ s/\w+\K/"a"x$n++/ger
evals/evals-freenode-#perl.lst[2372]: $_ = 'I speAk Goat Latin'; my $n = 1; s/\b([^\Waeiouy]?)(\w+)/$"x length$&&"$1$2"^"\U$2$1\Ema"/ger =~ s/\w+\K/'a'x$n++/ger
evals/evals-freenode-#perl.lst[2373]: $_ = 'I speAk Goat Latin'; my $n = 1; s/\b([^\Waeiouy]?)(\w+)/$"x length$&&$&^"\U$2$1\Ema"/ger =~ s/\w+\K/'a'x$n++/ger
evals/evals-freenode-#perl.lst[2374]: $_ = 'I speak Goat Latin'; s/\b[aeiouy]\w+\K/ma/gi || s/\b(\w)(\w*)/$2$1ma/g; my $n = 1; s/\w+\K/'a'x$n++/ger # like this riceandbeans
evals/evals-freenode-#perl.lst[2375]: is to test things.
evals/evals-freenode-#perl.lst[2376]: "italic test after italic"
evals/evals-freenode-#perl.lst[2377]: { itemFilter => 'first value', itemFilter => 'second value' };
evals/evals-freenode-#perl.lst[2378]: ( item => "first value", item => "second value" ); # That's how you fix *that*
evals/evals-freenode-#perl.lst[2379]: [ item => "first value", item => "second value" ]; # Why did you evaluate the last one the way you did, anyway?
evals/evals-freenode-#perl.lst[2380]: "It puts the lotion in the basket!"
evals/evals-freenode-#perl.lst[2381]: 'i' xor 'd'
evals/evals-freenode-#perl.lst[2382]: "\j"
evals/evals-freenode-#perl.lst[2383]: - -'jesus'
evals/evals-freenode-#perl.lst[2384]: -'jesus'
evals/evals-freenode-#perl.lst[2385]: "john@example.com"
evals/evals-freenode-#perl.lst[2386]: j oin
evals/evals-freenode-#perl.lst[2387]: join "\0", qw<a b c>
evals/evals-freenode-#perl.lst[2388]: join(':', (1..10))
evals/evals-freenode-#perl.lst[2389]: join ", ", 1, 2, "\n";
evals/evals-freenode-#perl.lst[2390]: join'','a'..'m','N'..'Z'
evals/evals-freenode-#perl.lst[2391]: join'',a..'m',N..Z
evals/evals-freenode-#perl.lst[2392]: join'',a..m ,N..Z
evals/evals-freenode-#perl.lst[2393]: join'',a..m,N..Z
evals/evals-freenode-#perl.lst[2394]: join('', 'a'..'z') =~ s/(.{13})$/uc$1/er
evals/evals-freenode-#perl.lst[2395]: join('', 'a'..'z') =~ s/^(.*)\K(??{ '.' x length $1 })$/\U$&/r;
evals/evals-freenode-#perl.lst[2396]: join ' ', ("Buffalo")
evals/evals-freenode-#perl.lst[2397]: join ' ', ("Buffalo") x8
evals/evals-freenode-#perl.lst[2398]: join ':', 'd850e684e6de' =~ /../g
evals/evals-freenode-#perl.lst[2399]: join'e', qw(y s)
evals/evals-freenode-#perl.lst[2400]: join "", grep /\w/a, map chr, 0..999999
evals/evals-freenode-#perl.lst[2401]: join "", grep /\w/, map chr, 0..999999
evals/evals-freenode-#perl.lst[2402]: join "hello", "a single argument"
evals/evals-freenode-#perl.lst[2403]: join 'irre', qw(sq l)
evals/evals-freenode-#perl.lst[2404]: join "-",(localtime)[5,4,3]
evals/evals-freenode-#perl.lst[2405]: [ join('', map { +{} } 0..10 ]
evals/evals-freenode-#perl.lst[2406]: [join "", map "$_\0", qw(foo bar baz)]
evals/evals-freenode-#perl.lst[2407]: [ join ',', map '?', 1..10 ]
evals/evals-freenode-#perl.lst[2408]: join(':', map { $_ *= $_ } (1..10))
evals/evals-freenode-#perl.lst[2409]: join ' ', map { 20 * ($_ - 1) } 1 .. 5;
evals/evals-freenode-#perl.lst[2410]: join '', map chr, 0x2603 # works fine with >256, but they're unicode not utf-8
evals/evals-freenode-#perl.lst[2411]: join '', map { chr(255 - hex) } "9E9B929691" =~ /([[:xdigit:]]{2})/g # Nei++
evals/evals-freenode-#perl.lst[2412]: join ' ', map chr, 97 .. 100
evals/evals-freenode-#perl.lst[2413]: join('',map chr,(97, 98, 99))
evals/evals-freenode-#perl.lst[2414]: join '', map chr(ord ^ 32), split '', 'Grinnz'
evals/evals-freenode-#perl.lst[2415]: join '', map { chr } unpack 'H*', "31323234"
evals/evals-freenode-#perl.lst[2416]: join ",", map { $_ || "\\N" } split ",", "abc,,def,ghi,,jkl"
evals/evals-freenode-#perl.lst[2417]: join ' ', map $_ . "\N{U+0300}", qw(a e i o u)
evals/evals-freenode-#perl.lst[2418]: join ' ', map $_ . "\N{U+0300}", qw(a e i o u)  <perlbot> anno: àèìò
evals/evals-freenode-#perl.lst[2419]: join ', ', map ord, qw(⁰ ¹ ² ³ ⁴ ⁵ ⁶ ⁷ ⁸ ⁹)
evals/evals-freenode-#perl.lst[2420]: join ' ', map pack('B8', $_), "01101000 01100101 01101100 01110000" =~ /\d+/g;
evals/evals-freenode-#perl.lst[2421]: [ join " -- ",map { s!^/|/$!!g;$_ } @{[ qw{ /foo/bar/baz/ foo/bar/baz /foo/bar/baz foo/bar/baz/ } ]} ]
evals/evals-freenode-#perl.lst[2422]: join(' ', map { sprintf("%02X", ord($_)) } split('', "bar"))
evals/evals-freenode-#perl.lst[2423]: join " ", map sprintf("%02x", $_), qw|137 80 78 71 13 10 26 10|
evals/evals-freenode-#perl.lst[2424]: join " ", map {ucfirst} split(" ", "My fancy filename.txt")
evals/evals-freenode-#perl.lst[2425]: join ' ', map { "$_:".(unpack( "H*", pack $_, 945 ) =~ s/../$&./gr) } 'V', 'N'
evals/evals-freenode-#perl.lst[2426]: join '-', map { "x$_y" } 1..3;
evals/evals-freenode-#perl.lst[2427]: join '-', map { "x${_}y" } 1..3;
evals/evals-freenode-#perl.lst[2428]: [ join ("\n", unpack '(A4)*', 'This is a string') ]
evals/evals-freenode-#perl.lst[2429]: join ('\n', unpack '(A4)*', 'This is a string')
evals/evals-freenode-#perl.lst[2430]: [ join '|', qr/^[a-zA-Z]+$/, qr/^[0-9]+$/ ]
evals/evals-freenode-#perl.lst[2431]: join ' <<<<<<< ', qw(fname lname age)
evals/evals-freenode-#perl.lst[2432]: join //, qw(foo bar baz)
evals/evals-freenode-#perl.lst[2433]: join ',', qw(?) x 10
evals/evals-freenode-#perl.lst[2434]: join '', reverse "7c86467b" =~ m/../g
evals/evals-freenode-#perl.lst[2435]: join '', sort { --$| * 2 - 1 } split //, 'Jurlt ,cneh eeotakrrsa Ph';
evals/evals-freenode-#perl.lst[2436]: join '', sort { --$| * 2 - 1 } split //, 'LaeulsraWt y yarmsoir r l';
evals/evals-freenode-#perl.lst[2437]: join '', sort split '', 'msixpodualngc'
evals/evals-freenode-#perl.lst[2438]: [join '', sort {$|--} split //, "tuJsa nohterP er lhakcer,"]
evals/evals-freenode-#perl.lst[2439]: (join '', (split //, 'abc'))
evals/evals-freenode-#perl.lst[2440]: +join +'_', +(+split /_/, +"the_cool_string")[+1,+2]
evals/evals-freenode-#perl.lst[2441]: join '_', (split /_/, "the_cool_string")[1,2]
evals/evals-freenode-#perl.lst[2442]: join '_', +(split /_/, "the_cool_string")[1,2]
evals/evals-freenode-#perl.lst[2443]: join " ", @{ unbuu || [] }
evals/evals-freenode-#perl.lst[2444]: join " ", @{ undef || [] }
evals/evals-freenode-#perl.lst[2445]: join " ", @{ undef() || [] }
evals/evals-freenode-#perl.lst[2446]: join " ", @{ undef() }
evals/evals-freenode-#perl.lst[2447]: [ join ',', (undef // ()), 'x', (undef // ()) ]
evals/evals-freenode-#perl.lst[2448]: join ":", unpack "(a2)*", "000202056D4C"
evals/evals-freenode-#perl.lst[2449]: join ".", unpack "C*", pack "n", 945
evals/evals-freenode-#perl.lst[2450]: join ':', unpack('(H2)3', "\x12\x34\x56")
evals/evals-freenode-#perl.lst[2451]: join ":", unpack "(H2)*", pack "H*", "e8b748680748"
evals/evals-freenode-#perl.lst[2452]: [ join ',', ('?')x4 ]
evals/evals-freenode-#perl.lst[2453]: [ join ',', ('?'x4) ]
evals/evals-freenode-#perl.lst[2454]: JSON
evals/evals-freenode-#perl.lst[2455]: JSON()
evals/evals-freenode-#perl.lst[2456]: JSON::encode_json [sprintf("%.2f", 1.234), sprintf("%.2f", 1.234) + 0]
evals/evals-freenode-#perl.lst[2457]: \@JSON::EXPORT
evals/evals-freenode-#perl.lst[2458]: \@JSON::EXPORT_OK
evals/evals-freenode-#perl.lst[2459]: JSON->new->encode({ value => 0+sprintf("%.3f", 34.33/400) })
evals/evals-freenode-#perl.lst[2460]: [JSON::true]
evals/evals-freenode-#perl.lst[2461]: "JUNK" =~ m/(.*)/; do { local $1; "wibble" =~ m/(\d+)/; $1; }
evals/evals-freenode-#perl.lst[2462]: "JUNK" =~ m/(.*)/; "wibble" =~ m/(\d+)/; $1;
evals/evals-freenode-#perl.lst[2463]: Just'another'Perl'hacker =~ s/::/ /gr
evals/evals-freenode-#perl.lst[2464]: "Just another Perl hacker" =~ so?  silly! r
evals/evals-freenode-#perl.lst[2465]: $k=0; $numseg=30000; for (my $i = 0; $i < $numseg; $i++) { for (my $j = $i; $j < $numseg; $j++) {$k++}}; print $k;
evals/evals-freenode-#perl.lst[2466]: $_ = "key foo"; push @arr, /key(.*)/; [@arr]
evals/evals-freenode-#perl.lst[2467]: [ keys { 1 .. 10 } ]
evals/evals-freenode-#perl.lst[2468]: [keys {1..4}]
evals/evals-freenode-#perl.lst[2469]: keys @{ [1..5] }
evals/evals-freenode-#perl.lst[2470]: keys( {} ) = 42
evals/evals-freenode-#perl.lst[2471]: [ keys (%{{ 'dave' => 1, 'bob' => 2 }}) ]
evals/evals-freenode-#perl.lst[2472]: [ keys (%{{ 'dave' => 1, 'bob' => 2 }}); ]
evals/evals-freenode-#perl.lst[2473]: keys (%{ 'dave' => 1, 'bob' => 2 });
evals/evals-freenode-#perl.lst[2474]: keys (%{{ 'dave' => 1, 'bob' => 2 }});
evals/evals-freenode-#perl.lst[2475]: keys %ENV
evals/evals-freenode-#perl.lst[2476]: keys %hash = 200; scalar %hash
evals/evals-freenode-#perl.lst[2477]: [ keys %INC ]
evals/evals-freenode-#perl.lst[2478]: keys INC
evals/evals-freenode-#perl.lst[2479]: keys %{main::};
evals/evals-freenode-#perl.lst[2480]: keys %main::
evals/evals-freenode-#perl.lst[2481]: keys(%order) = 2; keys(%order)
evals/evals-freenode-#perl.lst[2482]: keys(%order) = 2; scalar %order
evals/evals-freenode-#perl.lst[2483]: [keys { qw(a b c d) }]
evals/evals-freenode-#perl.lst[2484]: keys { qw(a b c d) }
evals/evals-freenode-#perl.lst[2485]: @keys = qw(a b c d); @hash{@keys} = @hash{@keys}
evals/evals-freenode-#perl.lst[2486]: @keys = qw(a b c d); @hash{@keys} = @hash{@keys}; \%hash
evals/evals-freenode-#perl.lst[2487]: @keys = qw(a b c); @values = qw(1 2 3 4); my %result; if (@keys < @values) { push @values, [ splice @values, $#keys ]} @results{@keys} = @values; \%results
evals/evals-freenode-#perl.lst[2488]: @keys = qw(a b c); @values = qw(1 2 3 4); my %result; if (@keys < @values) { push @values, [ splice @values, $#keys ]} $results{@keys} = @values; \%results
evals/evals-freenode-#perl.lst[2489]: [ keys(%^V), values(%^V) ]
evals/evals-freenode-#perl.lst[2490]: [ keys(%$^V), values(%$^V) ]
evals/evals-freenode-#perl.lst[2491]: kill $$
evals/evals-freenode-#perl.lst[2492]: kill -TERM, 0
evals/evals-freenode-#perl.lst[2493]: @{["Knark",". ","knark",","]}
evals/evals-freenode-#perl.lst[2494]: "\\l\$1"
evals/evals-freenode-#perl.lst[2495]: "\l\$1"
evals/evals-freenode-#perl.lst[2496]: LABEL: { goto redo next last LABEL; }
evals/evals-freenode-#perl.lst[2497]: LABEL: { last LABEL if 1; }
evals/evals-freenode-#perl.lst[2498]: LABEL: sub { }
evals/evals-freenode-#perl.lst[2499]: LABEL: { sub { last LABEL }->() }
evals/evals-freenode-#perl.lst[2500]: LABEL: { sub { last LABEL }->(); print "fail" }; print "ok";
evals/evals-freenode-#perl.lst[2501]: LABEL: sub { { last LABEL } print "hax" }->()
evals/evals-freenode-#perl.lst[2502]: "lag"
evals/evals-freenode-#perl.lst[2503]: 'lala'->${ \sub { 'here ' . shift } }
evals/evals-freenode-#perl.lst[2504]: *{ 'la la'} = sub { 'la la' }; my $name = 'la la'; my $ref = \&$name; $ref->()
evals/evals-freenode-#perl.lst[2505]: lc 'ẞ'
evals/evals-freenode-#perl.lst[2506]: lc chr 0xfb06
evals/evals-freenode-#perl.lst[2507]: lc chr 0xfb08
evals/evals-freenode-#perl.lst[2508]: lc "Foo" eq lc "foo"
evals/evals-freenode-#perl.lst[2509]: length
evals/evals-freenode-#perl.lst[2510]: [length]
evals/evals-freenode-#perl.lst[2511]: length "[^ /"
evals/evals-freenode-#perl.lst[2512]: length 0x00FF
evals/evals-freenode-#perl.lst[2513]: length 0xFF
evals/evals-freenode-#perl.lst[2514]: length 100
evals/evals-freenode-#perl.lst[2515]: length "1436365603657"
evals/evals-freenode-#perl.lst[2516]: length 1e10
evals/evals-freenode-#perl.lst[2517]: length 1e1000
evals/evals-freenode-#perl.lst[2518]: length 2**32
evals/evals-freenode-#perl.lst[2519]: length "2421392269093537440547188383164"
evals/evals-freenode-#perl.lst[2520]: length 2**64
evals/evals-freenode-#perl.lst[2521]: length 64.64.64.5000000000.64.64.6
evals/evals-freenode-#perl.lst[2522]: length "̀a"
evals/evals-freenode-#perl.lst[2523]: length "à"
evals/evals-freenode-#perl.lst[2524]: length "à"
evals/evals-freenode-#perl.lst[2525]: length ("a"x(100*1024*1024))
evals/evals-freenode-#perl.lst[2526]: length ("a"x(30*1024*1024))
evals/evals-freenode-#perl.lst[2527]: length "é"
evals/evals-freenode-#perl.lst[2528]: length 'ṏ͓͔ͅ'
evals/evals-freenode-#perl.lst[2529]: length pack "c", 9999;
evals/evals-freenode-#perl.lst[2530]: length pack "cc", 9888, 9999;
evals/evals-freenode-#perl.lst[2531]: length pack "cc", 9999;
evals/evals-freenode-#perl.lst[2532]: length pack "h", "41"
evals/evals-freenode-#perl.lst[2533]: length q(\\)
evals/evals-freenode-#perl.lst[2534]: length q|0.99999999999996|
evals/evals-freenode-#perl.lst[2535]: length q|0.9999999999999919|
evals/evals-freenode-#perl.lst[2536]: length q caller vec and print chr ord uc q chr lc and print chr ord q ge log and print chr ord qw q lc q and print chr ord qw q lc q and print chr ord q xor x and print chr ord qq q q and print chr ord uc qw q wait q and print chr ord q xor x and print chr ord q qr q and print chr ord qw q le q and print chr ord qw q do q and print chr hex length q q semctl setpgrp chop q and print chr length q q conti
evals/evals-freenode-#perl.lst[2537]: length q[{CRYPT}$2a$04$MjkMhQxasFQod1qq56DXCOvWu6YTWk9X.EZGnmSSIbbtyEBIAixbS]
evals/evals-freenode-#perl.lst[2538]: length 'sາໍ '
evals/evals-freenode-#perl.lst[2539]: length 'sາໍ'
evals/evals-freenode-#perl.lst[2540]: length sprintf "%8.2f", 12
evals/evals-freenode-#perl.lst[2541]: length sprintf "%8f", 12
evals/evals-freenode-#perl.lst[2542]: length sprintf '%b', 2 ** 100
evals/evals-freenode-#perl.lst[2543]: length sprintf '%b', 2**64
evals/evals-freenode-#perl.lst[2544]: [ length unpack 'H12', 'version' ]
evals/evals-freenode-#perl.lst[2545]: $            leonerd = 42;
evals/evals-freenode-#perl.lst[2546]: $ leonerd = 42;
evals/evals-freenode-#perl.lst[2547]: @lettuce = ( kale => "chrunchy"); map { print "yummy" if  /kale/ } @lettuce;
evals/evals-freenode-#perl.lst[2548]: @lettuce = ( kale => "chrunchy"); map { print "yummy" if $lettuce{$_} eq "kale" } @lettuce;
evals/evals-freenode-#perl.lst[2549]: '<li><a href="' =~ /<li><a href=/
evals/evals-freenode-#perl.lst[2550]: '<li><a href="' =~ /<li><a href=/; [$1, $2, $3]
evals/evals-freenode-#perl.lst[2551]: $likeb = qr/(?:(?<!\S)(?!\s)|(?<!\s)(?!\S))/; [ 'this, is..a test.' =~ s/$likeb/*/gr ] # should have been qr// (was typo)
evals/evals-freenode-#perl.lst[2552]: $likeb = qw/(?:(?<!\S)(?=\S)|(?<=\S)(?!\S))/; [ 'this, is..a test.' =~ s/$likeb/*/gr ]  # codydn
evals/evals-freenode-#perl.lst[2553]: 'like this'
evals/evals-freenode-#perl.lst[2554]: line
evals/evals-freenode-#perl.lst[2555]: __LINE__
evals/evals-freenode-#perl.lst[2556]: [ "line 1\nline 2\n\nline 4" =~ /^.*\s$/gm ]
evals/evals-freenode-#perl.lst[2557]: @lines = <{a,b,c}>; \@lines
evals/evals-freenode-#perl.lst[2558]: @lines = <.*>; \@lines
evals/evals-freenode-#perl.lst[2559]: $line = "\thello"; [ 0+ $line =~ /^\t(.+)/ ]
evals/evals-freenode-#perl.lst[2560]: $line = "\thello"; [ $line =~ /^\t(.+)/ ]
evals/evals-freenode-#perl.lst[2561]: $list{0}="zero"; $list{1}="one"; $list{2}="two"; $list{3}="three"; print scalar %list
evals/evals-freenode-#perl.lst[2562]: $list[0]="zero"; $list[1]="one"; $list[2]="two"; print scalar @list
evals/evals-freenode-#perl.lst[2563]: $list{0}="zero"; $list{1}="one"; $list{2}="two"; print scalar %list
evals/evals-freenode-#perl.lst[2564]: $list[1]="one"; $list[2]="two"; print scalar @list
evals/evals-freenode-#perl.lst[2565]: $list{AAA} = time; $list{BBB} = time; [%list] # %list is flattened
evals/evals-freenode-#perl.lst[2566]: @list=('d', 'e', 'f', 'a', 'b', 'c'); $startindex=3; @list=@list[$startindex..$#list], @list[0..$startindex-1]; @list
evals/evals-freenode-#perl.lst[2567]: @list=('d', 'e', 'f', 'a', 'b', 'c'); $startindex=3; @list=(@list[$startindex..$#list], @list[0..$startindex-1]); $text = join ' ', @list; $text;
evals/evals-freenode-#perl.lst[2568]: @list=('d', 'e', 'f', 'a', 'b', 'c'); $startindex=3; @list=@list[$startindex..$#list], @list[0..$startindex-1]; $text = join ' ', @list; $text;
evals/evals-freenode-#perl.lst[2569]: @list = ('d' .. 'f', 'a' .. 'c'); splice @list, 0, 0, splice @list, 3; \@list
evals/evals-freenode-#perl.lst[2570]: List::MoreUtils::any { $_ eq 'a' } ('b', 'a')
evals/evals-freenode-#perl.lst[2571]: List::MoreUtils::any { $_ eq 'a' } ('b', 'c')
evals/evals-freenode-#perl.lst[2572]: List::MoreUtils::any {$_ eq 'a'}, 'b', 'c'
evals/evals-freenode-#perl.lst[2573]: List::MoreUtils::any( {$_ eq 'a'} 'b', 'c' )
evals/evals-freenode-#perl.lst[2574]: List::MoreUtils::any( {$_ eq 'a'}, 'b', 'c' )
evals/evals-freenode-#perl.lst[2575]:  @list = ({name => 1, x => one}, {name => 2, x => two}, {name => 3, x => three}, {name => 4, x => four}); [map {$_->{x}} grep { $_->{name} > 2 } @list]
evals/evals-freenode-#perl.lst[2576]: @listof105 = (1..105); @listof11 = (1..11); @listof105 - @listof11
evals/evals-freenode-#perl.lst[2577]: @list_of_indices = ('1','3'); @array[ @list_of_indices ] = ("Z") x @list_of_indices;  \@array
evals/evals-freenode-#perl.lst[2578]: @list=qw(1 2 3 4 5); print $list[rand(@list)]
evals/evals-freenode-#perl.lst[2579]: @list=qw(1 2 3 4 5); print $list[rand(@list)] x 5
evals/evals-freenode-#perl.lst[2580]: @list = qw(a b c); $search="x"; [ !! grep($_ eq $search,@list) ]
evals/evals-freenode-#perl.lst[2581]: @list = qw(a b c); $search="x"; [ !! grep($search,@list) ]
evals/evals-freenode-#perl.lst[2582]: @list = ([qw(apple banana)], [qw(apple orange)], [qw(orange banana)], [qw(beef fish)]); my %sets = (); for my $pair (@list) { my ($x, $y) = @$pair; $sets{$x}{$y} = undef; for my $el (keys %{delete($sets{$y}) // {}}) { $sets{$el} = $sets{$x}; $sets{$x}{$el} = undef } } \%sets
evals/evals-freenode-#perl.lst[2583]: @list = ([qw(apple banana)], [qw(apple orange)], [qw(orange banana)], [qw(beef fish)]); my %sets = (); for my $pair (@list) { my ($x, $y) = @$pair; $sets{$x}{$y} = undef; for my $el (keys %{$sets{$y} // {}}) { $sets{$el} = $sets{$x}; $sets{$x}{$el} = undef } } \%sets
evals/evals-freenode-#perl.lst[2584]: @list = qw(dog cat turtle mouse wolf); splice @list, 2, 0, "rabbit"; \@list
evals/evals-freenode-#perl.lst[2585]: [List::UtilsBy::sort_by( sub { $_ }, 31, 30, 30.1, 31.1)]
evals/evals-freenode-#perl.lst[2586]: [List::UtilsBy::sort_by( sub { $_ }, 31, 30, 301, 311)]
evals/evals-freenode-#perl.lst[2587]: List::UtilsBy::sort_by( sub { $_ }, 31, 30, 301, 311)
evals/evals-freenode-#perl.lst[2588]: local $[ = 1;
evals/evals-freenode-#perl.lst[2589]: local $[ = -1; my @a = (1); $#a
evals/evals-freenode-#perl.lst[2590]: local @ARGV = qw(--linkadd y file_name_here.tgz); use Getopt::Long; GetOptions("linkadd=s" => \$linkadd); { linkadd => $linkadd, ARGV => \@ARGV }
evals/evals-freenode-#perl.lst[2591]: [ "\local_dir\selected"
evals/evals-freenode-#perl.lst[2592]: [ "\local_dir\selected" ]
evals/evals-freenode-#perl.lst[2593]: { local $@; eval { die "foo" } } [$@]
evals/evals-freenode-#perl.lst[2594]: { local $@; eval { die "foo" } } $@
evals/evals-freenode-#perl.lst[2595]: local ($_) = "foo [aasdf] bar"; my (%fwd,%bkd); while( s! ( \[ [^][]* \] ) ! '.' x length $1 !xe ) { $fwd{$-[1]} = $+[1]; $bkd{$+[1]} = $-[1] }; [ \%fwd, \%bkd ]
evals/evals-freenode-#perl.lst[2596]: local *_ = \"hello"; $_ = 42
evals/evals-freenode-#perl.lst[2597]: local $_ = "my fancy filename.txt";$count=0;s/(\s*)(.)/upper($1,$2,$count++)/ge;print;sub upper { my ($s, $c, $n) = @_;return $s ? "$s\u$c" : !$n ? "\u$c" : $c; }
evals/evals-freenode-#perl.lst[2598]: local $_ = "my fancy filename.txt";$count=0;s/(\s*)(\w+)/upper($1,$2,$count++)/ge;print;sub upper { my ($s, $c, $n) = @_;return $s ? "$s\u$c" : !$n ? "\u$c" : $c; }
evals/evals-freenode-#perl.lst[2599]: local my $foo
evals/evals-freenode-#perl.lst[2600]: local $, = ','; print 1..10
evals/evals-freenode-#perl.lst[2601]: localtime
evals/evals-freenode-#perl.lst[2602]: ~~localtime
evals/evals-freenode-#perl.lst[2603]: '' . localtime()
evals/evals-freenode-#perl.lst[2604]: "".localtime
evals/evals-freenode-#perl.lst[2605]: "${\localtime}"
evals/evals-freenode-#perl.lst[2606]: localtime . ""
evals/evals-freenode-#perl.lst[2607]: localtime->${ \'(""' };
evals/evals-freenode-#perl.lst[2608]: $^LOCALTIME
evals/evals-freenode-#perl.lst[2609]: localtime() =~ /1/
evals/evals-freenode-#perl.lst[2610]: (localtime 1349906400). ""
evals/evals-freenode-#perl.lst[2611]: (localtime 1349910000) . ""
evals/evals-freenode-#perl.lst[2612]: [(localtime 1404734410)."\n"]
evals/evals-freenode-#perl.lst[2613]: [(localtime 1404745200)."\n"]
evals/evals-freenode-#perl.lst[2614]: [(localtime 1404838800)."\n"]
evals/evals-freenode-#perl.lst[2615]: [(localtime 1413288010)."\n"]
evals/evals-freenode-#perl.lst[2616]: [localtime 1419940800]
evals/evals-freenode-#perl.lst[2617]: [(localtime 1419940800)."\n"]
evals/evals-freenode-#perl.lst[2618]: (localtime)[2]
evals/evals-freenode-#perl.lst[2619]: localtime + 24
evals/evals-freenode-#perl.lst[2620]: ''.localtime + 24 * 60 * 60
evals/evals-freenode-#perl.lst[2621]: localtime - 3600
evals/evals-freenode-#perl.lst[2622]: +(localtime)[5] + 1900
evals/evals-freenode-#perl.lst[2623]: [ (localtime())[5,4,3]]
evals/evals-freenode-#perl.lst[2624]: (localtime)[6] == 0 ? 'sunday' : 'not sunday'
evals/evals-freenode-#perl.lst[2625]: (localtime)[7]
evals/evals-freenode-#perl.lst[2626]: (localtime)[7]/365
evals/evals-freenode-#perl.lst[2627]: [ localtime ], [ CORE::localtime ] ]
evals/evals-freenode-#perl.lst[2628]: [ [ localtime ], [ CORE::localtime ] ] # derp
evals/evals-freenode-#perl.lst[2629]: localtime->datetime
evals/evals-freenode-#perl.lst[2630]: localtime->month_last_day
evals/evals-freenode-#perl.lst[2631]: [localtime . "\n"]
evals/evals-freenode-#perl.lst[2632]: localtime."\n"
evals/evals-freenode-#perl.lst[2633]: "".localtime(time())
evals/evals-freenode-#perl.lst[2634]: "".localtime(time() * 1000)
evals/evals-freenode-#perl.lst[2635]: (localtime(time))[5]
evals/evals-freenode-#perl.lst[2636]: "".localtime(time() - 60 * 20)
evals/evals-freenode-#perl.lst[2637]: localtime()->ymd()
evals/evals-freenode-#perl.lst[2638]: local $_ = "UCS-4"; eval q@qr/^UCS-?4-?(BE|LE)?$/i; uc("UTF-32$1")@
evals/evals-freenode-#perl.lst[2639]: local $var = 'local'; print " $var "; { $var = 'notlocal'; print $var };
evals/evals-freenode-#perl.lst[2640]: local $var = 'local'; { $var = 'notlocal'; print $var }; print " $var "
evals/evals-freenode-#perl.lst[2641]: log(~0 +1)/log(2)
evals/evals-freenode-#perl.lst[2642]: log(~0+1)/log(2)
evals/evals-freenode-#perl.lst[2643]: log(~0)/log(2)
evals/evals-freenode-#perl.lst[2644]: log(13500) / log(2)
evals/evals-freenode-#perl.lst[2645]: $= = log(16777213) / log(2); $= # yep perfectly safe
evals/evals-freenode-#perl.lst[2646]: log(2421392269093537440547188383164)/log(2)
evals/evals-freenode-#perl.lst[2647]: [ log(2), log(10), log(exp(1)) ]
evals/evals-freenode-#perl.lst[2648]: log(3) / log 2
evals/evals-freenode-#perl.lst[2649]: ((log(632382) * 518061 > log(519432) * 525806) ? "First" : "Second") . " is bigger"
evals/evals-freenode-#perl.lst[2650]: log(63) / log(2) # you might want to round to nearest integer if you do
evals/evals-freenode-#perl.lst[2651]: $log_content .= <<LOG;
evals/evals-freenode-#perl.lst[2652]: [ log_file => 42, die => 9 ]
evals/evals-freenode-#perl.lst[2653]: 'Log�Processing�Service�can�receive�log�messages�' =~ y/\xA0/ /dr
evals/evals-freenode-#perl.lst[2654]: $_ = 'LOL' (\&CORE::lc)->()
evals/evals-freenode-#perl.lst[2655]: $_ = 'LOL'; (\&CORE::lc)->()
evals/evals-freenode-#perl.lst[2656]: $_="lol"; tr alaLa; print;
evals/evals-freenode-#perl.lst[2657]: $long_var_blah = 42;  $my_pay = $long_var_b1ah * 1000; print "I'm fucking rich, I got $my_pay!";
evals/evals-freenode-#perl.lst[2658]: {} . '' # looks something like this, numbers will vary
evals/evals-freenode-#perl.lst[2659]: $l='post hoc ergo propter hoc. illigitimus non tatum carborundum.'; $l=~s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $l;
evals/evals-freenode-#perl.lst[2660]: `ls`;
evals/evals-freenode-#perl.lst[2661]: [`ls`]
evals/evals-freenode-#perl.lst[2662]: `ls -a`
evals/evals-freenode-#perl.lst[2663]: lvfjf is a fool!
evals/evals-freenode-#perl.lst[2664]: LWP::Simple::get www.google.com
evals/evals-freenode-#perl.lst[2665]: [m#
evals/evals-freenode-#perl.lst[2666]: m?^?
evals/evals-freenode-#perl.lst[2667]: m/^+/
evals/evals-freenode-#perl.lst[2668]: m/$#/
evals/evals-freenode-#perl.lst[2669]: m0{0\my}sub H;0;sub{sub{H
evals/evals-freenode-#perl.lst[2670]: //magic
evals/evals-freenode-#perl.lst[2671]: $main::_ == $_
evals/evals-freenode-#perl.lst[2672]: main->can("can")
evals/evals-freenode-#perl.lst[2673]: [ main->can( sub { 'dummy' } ) ]
evals/evals-freenode-#perl.lst[2674]: main->can( sub { 'dummy' } )
evals/evals-freenode-#perl.lst[2675]: main::for () for ();
evals/evals-freenode-#perl.lst[2676]: *main::main::main::main::X{PACKAGE}
evals/evals-freenode-#perl.lst[2677]: @many = ( "foo", "bar" ); %{$href} = @many; print $href->{'foo'}."\n"
evals/evals-freenode-#perl.lst[2678]: [ map { 0+!$_} 0, 1 ]
evals/evals-freenode-#perl.lst[2679]: [ map { ($_ > 0) - ($_ < 0) } qw(-5 0 10) ]
evals/evals-freenode-#perl.lst[2680]: [ map [$_->[0] + $_->[3] * 256, $_->[0] - ($_->[1] ^ $_->[2]) * 256], [0b0011_1000, 0, 0, 1], [0b0100_0110, 0, 1, 1] ]
evals/evals-freenode-#perl.lst[2681]: map { $_ =~ /(?:^|[^0-9])[0-9]{7}(?:$|[^0-9])/ ? "+ " : "- "} ("1234567 "," 1234567"," 12345678 ")
evals/evals-freenode-#perl.lst[2682]: [ map { $_->[0] eq $_->[1] } [ split //, "AB" ], [ split //, "A4" ]]
evals/evals-freenode-#perl.lst[2683]: [ map { 0+!$_ } qw(0 1) ]
evals/evals-freenode-#perl.lst[2684]: [ map $_->[0], sort { $a->[1] <=> $b->[1] } map [ $_, rand ], 1..5 ]
evals/evals-freenode-#perl.lst[2685]: [ map 0+sprintf('%.3f', $_), 0.7, 0.33333 ]
evals/evals-freenode-#perl.lst[2686]: [ map 0+sprintf('%.3f', $_), 7, 0.33333 ]
evals/evals-freenode-#perl.lst[2687]: [ map { $_->[0] xor $_->[1] } [ split //, "AB" ], [ split //, "A4 ]
evals/evals-freenode-#perl.lst[2688]: [ map { $_->[0] xor $_->[1] } [ split //, "AB" ], [ split //, "A4 ]]
evals/evals-freenode-#perl.lst[2689]: [ map { $_->[0] xor $_->[1] } [ split //, "AB" ], [ split //, "A4" ]]
evals/evals-freenode-#perl.lst[2690]: [ map 1 ]
evals/evals-freenode-#perl.lst[2691]: [ map $_/10, 0..10 ]
evals/evals-freenode-#perl.lst[2692]: [map $_ * 10, 10..300]
evals/evals-freenode-#perl.lst[2693]: map { $_*10 } 1..10
evals/evals-freenode-#perl.lst[2694]: [ map{($.||1..$.&&0)-1 ." $_"}split(//,japh) ]
evals/evals-freenode-#perl.lst[2695]: [map { $_ & ($_-1) } 0 .. 32]
evals/evals-freenode-#perl.lst[2696]: [map 1 1]
evals/evals-freenode-#perl.lst[2697]: [map 1, 1]
evals/evals-freenode-#perl.lst[2698]: [ map --$|, 1..10 ] # ++ and -- in perl don't have to make sense, they just do useful stuff
evals/evals-freenode-#perl.lst[2699]: [map { 1 << $_ } (1 .. 10)]
evals/evals-freenode-#perl.lst[2700]: map { "$_" => 1 } 1,2,3
evals/evals-freenode-#perl.lst[2701]: map { $_ => 1 } 1,2,3
evals/evals-freenode-#perl.lst[2702]: map {; "$_" => 1 } 1,2,3
evals/evals-freenode-#perl.lst[2703]: [map +{; $_ => $_ }, 1 .. 3]
evals/evals-freenode-#perl.lst[2704]: [map +{ $_ => $_ }, 1 .. 3] # need + and , for that
evals/evals-freenode-#perl.lst[2705]: [ map --$|, 1..5 ]
evals/evals-freenode-#perl.lst[2706]: [ map $|--, 1 .. 5 ]
evals/evals-freenode-#perl.lst[2707]: [map {/.*\.(.*)$/;$1} "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
evals/evals-freenode-#perl.lst[2708]: [map {/.*\.*(.*)$/;$1} "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
evals/evals-freenode-#perl.lst[2709]: map "$_" => 1, qw(a b c);
evals/evals-freenode-#perl.lst[2710]: map ("$_" => 1), qw(a b c);
evals/evals-freenode-#perl.lst[2711]: map +("$_" => 1), qw/a b c/
evals/evals-freenode-#perl.lst[2712]: map { "$_" => 1 } qw/foo bar baz/
evals/evals-freenode-#perl.lst[2713]: map { $_ => 1 } qw/foo bar baz/
evals/evals-freenode-#perl.lst[2714]: [ map (1x$_) =~ /^1?$|^(11+?)\1+$/, '1000000000000066600000000000001' ]
evals/evals-freenode-#perl.lst[2715]: map { $_* 2 } 1..10
evals/evals-freenode-#perl.lst[2716]: [ map { $_ % 2 ? "<$_>" : () } 2, 3, 4, 5, 6, 7 ]
evals/evals-freenode-#perl.lst[2717]: [ map { $_ ** 2 } grep { $_ % 2 } (2, 4, 6, 8) ]
evals/evals-freenode-#perl.lst[2718]: [ map { 2 ** $i++ if $_ } reverse split //, sprintf "%b", 20]
evals/evals-freenode-#perl.lst[2719]: [ map { $_ ? 2 ** $i++ : ()  } reverse split //, sprintf "%b", 20]
evals/evals-freenode-#perl.lst[2720]: [ map { 2 ** $i++ } reverse split //, sprintf "%b", 20]
evals/evals-freenode-#perl.lst[2721]: [ map { 2 ** $i++ * $_ } reverse split //, sprintf "%b", 20]
evals/evals-freenode-#perl.lst[2722]: map{@$_ == 3} \@arr1, \@arr2, \@arr3
evals/evals-freenode-#perl.lst[2723]: [ map { 47 - ($_ ^ 7) } 0..40 ]
evals/evals-freenode-#perl.lst[2724]: [ map { $_ <=> 5 } 1 .. 10 ]
evals/evals-freenode-#perl.lst[2725]: [ map { $_ / 5 } (1..10) ]
evals/evals-freenode-#perl.lst[2726]: [ map { $_ / 5 }, (1..10) ]
evals/evals-freenode-#perl.lst[2727]: [ map { $_ % 8 + 40 - ($_ & ~7) } 0..40 ]  # shorter :)
evals/evals-freenode-#perl.lst[2728]: [ map { $_ % 8 + 40 - (int($_ / 8) * 8) } 0..40 ]
evals/evals-freenode-#perl.lst[2729]: [ map { $_->{a} } @{[ undef ]} ]
evals/evals-freenode-#perl.lst[2730]: [ map [/(?!\A\z)^.*/mg], "", "\n", "a\nb\n", "a\nb", "\n\n", "\nb\n" ]
evals/evals-freenode-#perl.lst[2731]: [ map { ~~/\b([A-Z]\.){2,}\b/ } qw(A.A. B.B.B.B.B.B.B.B. C.C.C.C A.M) ]
evals/evals-freenode-#perl.lst[2732]: [ map charnames::viacode(ord($_)), qw(☃ ⛄ ⛇) ]
evals/evals-freenode-#perl.lst[2733]: [ map charnames::viacode(ord), qw(☃ ⛄ ⛇) ]
evals/evals-freenode-#perl.lst[2734]: [ map{chomp} ("foo\n","bar\n") ]
evals/evals-freenode-#perl.lst[2735]: "@{[ map chr $_ + 64, qw/9 8 1 20 5 16 5 15 16 12 5/]}"
evals/evals-freenode-#perl.lst[2736]: "@{[ map chr $_ + 65, qw/9 8 1 20 5 16 5 15 16 12 5/]}"
evals/evals-freenode-#perl.lst[2737]: [ map chr hex, "302e3f313133" =~ /../g ] # if you don't want the extra validation
evals/evals-freenode-#perl.lst[2738]: [ map chr(hex($_)), sprintf('%08x', 1383403352) =~ /../g ]
evals/evals-freenode-#perl.lst[2739]: "@{[ map chr, qw/9 8 1 20 5 16 5 15 16 12 5/]}"
evals/evals-freenode-#perl.lst[2740]: [ map "$_", \&configure ]
evals/evals-freenode-#perl.lst[2741]: [ map { $_ || defined $_ } (0, 1, undef) ]
evals/evals-freenode-#perl.lst[2742]: [ map defined, 1, '', undef, 42 ]
evals/evals-freenode-#perl.lst[2743]: [ map { "descri$_" } "bing", map { "pti$_" } "on", "ve" ]
evals/evals-freenode-#perl.lst[2744]: [ map { /[^\d-]/ ? $_ : tr/-/ /r } '1990-1992-1993-2010', "this-is-a-string-with-9-something-3ls3" ]
evals/evals-freenode-#perl.lst[2745]: [ map { "duck" =~ m/$_/ ? $_ : "no" } qw/du uc ck/ ]
evals/evals-freenode-#perl.lst[2746]: [ map { ; foo => $_ } 'a'..'c' ]
evals/evals-freenode-#perl.lst[2747]: [ map +{ foo => $_ } 'a'..'c' ]
evals/evals-freenode-#perl.lst[2748]: [ map +{ foo => $_ }, 'a'..'c' ]
evals/evals-freenode-#perl.lst[2749]: [ map { foo => $_ } 'a'..'c' ]; # which of the above two should this be?
evals/evals-freenode-#perl.lst[2750]: [ map {; /^(?!(foobar){2}$)(?:\1)*/ ? 1 : 0 } "", "foobar", "foobarfoobar", "foobarfoobarfoobar" ]
evals/evals-freenode-#perl.lst[2751]: [ map [ /foo (bar)? (\d+)/ ], 'foo bar 123', 'foo  123', 'no match' ]
evals/evals-freenode-#perl.lst[2752]: [ map !!/(?<!^)foo/, "foo", "barfoo" ]
evals/evals-freenode-#perl.lst[2753]: [ map !!/(?!^)foo/, "foo", "barfoo" ]
evals/evals-freenode-#perl.lst[2754]: [ map /(?!^)foo/, "foo", "barfoo" ]
evals/evals-freenode-#perl.lst[2755]: [ map {; for (()){} } qw(A B C D) ]
evals/evals-freenode-#perl.lst[2756]: [ map { $i++; $_ ? 2 ** ($i - 1) : ()  } reverse split //, sprintf "%b", 20]
evals/evals-freenode-#perl.lst[2757]: [ map { if ($_ % 2) { "<$_>" } else { say "hey!"; () }; } (1..10); ]
evals/evals-freenode-#perl.lst[2758]: [ map {; if ($_ ne 'A') { 0 } } qw(A B C D) ]
evals/evals-freenode-#perl.lst[2759]: [ map { int($_ / 5) } (1..10) ]
evals/evals-freenode-#perl.lst[2760]: [ map { int rand 50 } 1..100 ];
evals/evals-freenode-#perl.lst[2761]: [ map { $i++ } qw/foo bar baz/ ]
evals/evals-freenode-#perl.lst[2762]: [  map { +{ ITEM => $_ } } qw( bla hi hue )  ]
evals/evals-freenode-#perl.lst[2763]: [  map { ITEM => $_ } qw( bla hi hue )  ]
evals/evals-freenode-#perl.lst[2764]: [  map { ITEM => $_ }, qw( bla hi hue )  ]
evals/evals-freenode-#perl.lst[2765]: [  map { +{ ITEM => $_ } } qw( bla hi hue )  ]  # see
evals/evals-freenode-#perl.lst[2766]: %map{key}
evals/evals-freenode-#perl.lst[2767]: [ map !!/.\Kfoo/, "foo", "barfoo" ]
evals/evals-freenode-#perl.lst[2768]: [map { $_; last } (1,2,3)]
evals/evals-freenode-#perl.lst[2769]: [map length, q{$"="";@x=([],{}," ",sub{},\"");map{s/..(..).*/$1/}@x;"@x"}, q{print/..(..?)/ for[],{},$"x3,\&f,\0}]
evals/evals-freenode-#perl.lst[2770]: [ map m?^?, 1 .. 4 ]
evals/evals-freenode-#perl.lst[2771]: [ map [ m{\A (.*?) - ( \d+ (?: \. \d+ )* (?: -r \d+ )? ) \z}xa ], qw(cryptsetup-1.1.3-r3 cronbase-0.3.3 automake-wrapper-3-r1 gcc-4.5.3-r1) ]
evals/evals-freenode-#perl.lst[2772]: [ map [ m{\A (.*?) - ( \d+ (?: \. \d+ )* (?: -r \d+ )? ) \z}xa ], qw(cryptsetup-1.1.3-r3 cronbase-0.3.3. automake-wrapper-3-r1 gcc-4.5.3-r1) ]
evals/evals-freenode-#perl.lst[2773]: [ map { m/^(\d+)-(\d+)$/ ? ( $1 .. $2 ) : ( $_ ) } split m/,/, "1-3,5,6-9" ]
evals/evals-freenode-#perl.lst[2774]: [ map [/^.*/mg], "", "\n", "a\nb\n", "a\nb", "\n\n", "\nb\n" ]
evals/evals-freenode-#perl.lst[2775]: [ map { my ( $a, $b ) = split /:/; { $a => $b } } qw( a:123 b:456 ) ];
evals/evals-freenode-#perl.lst[2776]: [ map { my ( $a, $b ) = split /:/; +{ $a => $b } } qw( a:123 b:456 ) ];
evals/evals-freenode-#perl.lst[2777]: [ map { my $foo if 0; ++$foo } 1 .. 10 ]
evals/evals-freenode-#perl.lst[2778]: [ map { my $foo if 0; ++$foo } 5 .. 10 ]
evals/evals-freenode-#perl.lst[2779]: [ map { my $line = $_; $line =~ s/\n+$//; $line } ("asdf","asdf\n") ]
evals/evals-freenode-#perl.lst[2780]: [ map { my $line = $_; $line =~ s/\n*$/\n/; $line } ("asdf","asdf\n") ]
evals/evals-freenode-#perl.lst[2781]: [map { $_; next } (1,2,3)]
evals/evals-freenode-#perl.lst[2782]: [ map [/^.*\n?/mg], "", "\n", "a\nb\n", "a\nb", "\n\n", "\nb\n" ]
evals/evals-freenode-#perl.lst[2783]: [map { $_->normal } version->parse('v0.01'), version->parse('v0.1'), version->parse('v0.10'), version->parse('0.10')]
evals/evals-freenode-#perl.lst[2784]: map {; no strict qw(refs); $_; } 1..3
evals/evals-freenode-#perl.lst[2785]: [ map oct '0b1' . '01' x $_, 0 .. 9 ]
evals/evals-freenode-#perl.lst[2786]: [ map oct '0b1' . '01' x $_, 1 .. 10 ]
evals/evals-freenode-#perl.lst[2787]: [ map ord, grep /\h/, map chr, (0..0x3000) ]
evals/evals-freenode-#perl.lst[2788]: [ map ord, qw(☃ ⛄ ⛇) ]
evals/evals-freenode-#perl.lst[2789]: [map ord, qw(L E O V)]
evals/evals-freenode-#perl.lst[2790]: [ map { ord } split //, 0.18446744073709551615.0 ]
evals/evals-freenode-#perl.lst[2791]: [ map { ord } split //, 0.18446744073709551616.0 ]
evals/evals-freenode-#perl.lst[2792]: [ map ord, split //, 64.64.64.5000000000.64.64.64 ]
evals/evals-freenode-#perl.lst[2793]: [ map ord, split //, "ascii" ]
evals/evals-freenode-#perl.lst[2794]: [map { ord } split //, fuckit
evals/evals-freenode-#perl.lst[2795]: [ map {POSIX::ceil($_*20)/20} (0.80, 0.81, 0.82, 0.83, 0.84, 0.85) ]
evals/evals-freenode-#perl.lst[2796]: map print, [1,2,3]->@*  # or maybe a -, a >, an @ and an *
evals/evals-freenode-#perl.lst[2797]: map { print "$_=$ENV{$_} " } keys %ENV
evals/evals-freenode-#perl.lst[2798]: map { print "$_=$ENV{$_}" } keys %ENV;
evals/evals-freenode-#perl.lst[2799]: map { print "$_=".$ENV{$_}."\n"; } keys %ENV
evals/evals-freenode-#perl.lst[2800]: map { print "$_=$ENV{$_}\n" } keys %ENV;
evals/evals-freenode-#perl.lst[2801]: map { print "$_\n"; } @INC;
evals/evals-freenode-#perl.lst[2802]: map { print "$_\n" } (reverse ( int rand 1000, int rand 1000 )); # returns higher rand num first
evals/evals-freenode-#perl.lst[2803]: map { print "$_\n" } (reverse ( int rand 100, int rand 100 )); # returns higher rand num first
evals/evals-freenode-#perl.lst[2804]: map { print "$_\n" } reverse ( int rand 10, int rand 10 )
evals/evals-freenode-#perl.lst[2805]: map { print "$_\n" } (reverse ( int rand 10, int rand 10 )); # returns higher rand num first
evals/evals-freenode-#perl.lst[2806]: map { print "$_\n" } (sort ( int rand 1000, int rand 1000 )); # returns lower rand num first
evals/evals-freenode-#perl.lst[2807]: map { print "$_\n" } (sort ( int rand 100, int rand 100 )); # returns lower rand num first
evals/evals-freenode-#perl.lst[2808]: map { print "$_\n" } sort ( int rand 10, int rand 10 )
evals/evals-freenode-#perl.lst[2809]: map { print "$_\n" } (sort ( int rand 10, int rand 10 )); # returns lower rand num first
evals/evals-freenode-#perl.lst[2810]: map { print "$_\n" } sort reverse ( int rand 10, int rand 10 )
evals/evals-freenode-#perl.lst[2811]: [ map { !$_ } qw(0 1) ]
evals/evals-freenode-#perl.lst[2812]: [ map { rand $_ } ( 0 ) x 10 ]
evals/evals-freenode-#perl.lst[2813]: map { $_=rand(3)>1?lc($_):uc($_); print } (a..z);
evals/evals-freenode-#perl.lst[2814]: map { $_=rand(3)>1?lc($_):uc($_); print } split //, "oh turtleneck phrase jar";
evals/evals-freenode-#perl.lst[2815]: map { $_=rand(3)>1?lc($_):uc($_); print } split //, "oh turtleneck phrase jar"; sleep 3; print scalar localtime time();
evals/evals-freenode-#perl.lst[2816]: [ map ref, \1, [], {}, sub{}, qr//, \(substr($_,1)),  ]
evals/evals-freenode-#perl.lst[2817]: [ map {  $_  || ref && ( eval q{@$_} || eval q{%$_} ) ? 1 : 0  } [], [5], {}, {A=>6}, 0, 123, q{}, q{abc} ]; # I added the input to the map, but everything else is verbatium.
evals/evals-freenode-#perl.lst[2818]: [map { reset if int rand 2; m?(\d)? } 1..10]
evals/evals-freenode-#perl.lst[2819]: [ map s/[0-9]\K-(?=[A-Z])//r, qw(4-A 4-a 4-4 9-X)]
evals/evals-freenode-#perl.lst[2820]: [ map { /!(.+?)\s/ ? $1 : "doesn't match" } "!fff askd", "!dja", "!kasdfk " ]
evals/evals-freenode-#perl.lst[2821]: [ map scalar m?^?, 1 .. 4 ]
evals/evals-freenode-#perl.lst[2822]: [ map /^scaleaddr(\d)=([^\d]*)/gi, qw(blahj blah blah ScaleAddr5=abc) ];
evals/evals-freenode-#perl.lst[2823]: [ map /^scaleaddr(\d)=([^\d]*)/gi, qw(blahj blah blah ScaleAddr5=abc foo bar) ];
evals/evals-freenode-#perl.lst[2824]: [ map s!\.\d{3}\K(\d+)!!r, 0.7, 0.33333, -0.800000000000001 ]
evals/evals-freenode-#perl.lst[2825]: [ map s!\.\d{3}\K(\d+)!!r, 0.7, 0.33333, -0.800900000000001 ] #he probably wants the last one to be -0.801 in this case?
evals/evals-freenode-#perl.lst[2826]: [ map [ split /,/ ], split /,,/, 'a,b,,c,d,e,f,,g,h' ]
evals/evals-freenode-#perl.lst[2827]: [ map [split /,/], split ' ', "foo,bar,baz foo" ]
evals/evals-freenode-#perl.lst[2828]: [map {[sprintf "%010B %010B", $_, $_-1]} grep {$_ && !($_ & ($_-1)) } 0 .. 1024]
evals/evals-freenode-#perl.lst[2829]: [ map {sprintf "%03b"} 7, 6, 7&6 ]
evals/evals-freenode-#perl.lst[2830]: [ map {sprintf "%04b", $_} 10, 9, 10&9 ]
evals/evals-freenode-#perl.lst[2831]: [ map {sprintf "%04b", $_} 7, 6, 7&6 ]
evals/evals-freenode-#perl.lst[2832]: [ map {sprintf "%04b"} 7, 6, 7&6 ]
evals/evals-freenode-#perl.lst[2833]: [ map { sprintf "%04x", $_ } unpack "n*", "\x41\x42\x43\x44" ]
evals/evals-freenode-#perl.lst[2834]: [map { sprintf '%.0f', $_ } -2.5, -1.5, -0.5, 0.5, 1.5, 2.5]
evals/evals-freenode-#perl.lst[2835]: [ map { sprintf "%.24f", $_ }   0.3,   0.1*3   ]
evals/evals-freenode-#perl.lst[2836]: [ map { sprintf("%.2f", $_) + 0 } 3.14159, 8.675309, 1.20, 3 ]
evals/evals-freenode-#perl.lst[2837]: [ map { (sprintf("%b", $_) =~ tr/1/1/) % 3 } qw(0 1 2 3 4 5 6 7) ]
evals/evals-freenode-#perl.lst[2838]: [map { sprintf '%d', $_ } -2.5, -1.5, -0.5, 0.5, 1.5, 2.5]
evals/evals-freenode-#perl.lst[2839]: [ map sprintf('%.f', $_), 6.5, 7.5, 8.5, 9.5 ]
evals/evals-freenode-#perl.lst[2840]: [ map { sprintf '%.*f', length('9999999999999911'), "0.99999999999999$_" } '00' .. '10' ]
evals/evals-freenode-#perl.lst[2841]: [map { sprintf '%i', $_ } -2.5, -1.5, -0.5, 0.5, 1.5, 2.5]
evals/evals-freenode-#perl.lst[2842]: [ map { sprintf q{%03.2f}, $_; } 2, 64, 100 ];
evals/evals-freenode-#perl.lst[2843]: [ map { sprintf q{%3.2f}, $_; } 2, 64, 100 ];
evals/evals-freenode-#perl.lst[2844]: [ map { sprintf q{%3i}, $_; } 2, 64, 100 ];
evals/evals-freenode-#perl.lst[2845]: [ map { sprintf "%vd", $_ }  'abcd' & '11111111' ]
evals/evals-freenode-#perl.lst[2846]: [ map { sprintf "%vd", $_ }  'abcdefgh', '11111111', 'abcdefgh' & '1111' ]
evals/evals-freenode-#perl.lst[2847]: [ map { sprintf "%vd", $_ }  'abcdefgh', '11111111', 'abcdefgh' & '11111111' ]
evals/evals-freenode-#perl.lst[2848]: [ map sprintf("%vd", $_), "\xc6", Encode::encode_utf8("\xc6") ]
evals/evals-freenode-#perl.lst[2849]: [ map sprintf("%vx", $_), "\xc6", Encode::encode_utf8("\xc6") ]
evals/evals-freenode-#perl.lst[2850]: [ map /@(\S+)/, qw( one@two three@four ) ]
evals/evals-freenode-#perl.lst[2851]: [ map /\@(\S+)/, qw( one@two three@four ) ]
evals/evals-freenode-#perl.lst[2852]: [ map s/.*\@//r, qw( foo@bar.org bar.org ) ] # not sure what exactly is wanted...
evals/evals-freenode-#perl.lst[2853]: [map tr/a-z/oh, turtleneck Phrase Jar! What the f**k?/r, wftedskaebjgdpjgidbsmnjgc => ]
evals/evals-freenode-#perl.lst[2854]: [map { ucfirst $_ } split(/a/, "abacus")]
evals/evals-freenode-#perl.lst[2855]: [ map $_ // 'undef', 1, '', undef, 42 ]
evals/evals-freenode-#perl.lst[2856]: [ map unpack("H*", $_), "like this" =~ /\A(.)(.*)(.)\z/s ]
evals/evals-freenode-#perl.lst[2857]: [ map "\u${ \ qw(no one two three)[$_] } blind ${ \ qw(mouse mice)[$_ > 1] }", 0 .. 3]
evals/evals-freenode-#perl.lst[2858]: map { $_->{val} } undef
evals/evals-freenode-#perl.lst[2859]: [ map { version->parse($_)->numify } map {  $_ , eval $_  } '0.99999999999929' ];
evals/evals-freenode-#perl.lst[2860]: [ map { version->parse($_)->numify } map {  $_ , eval $_  } '1.23_001' ]; # This is really a bigger problem.
evals/evals-freenode-#perl.lst[2861]: [map { "$_" } version->parse('v0.01'), version->parse('v0.1'), version->parse('v0.10'), version->parse('0.10')]
evals/evals-freenode-#perl.lst[2862]: [ map { ($_) x $_ } 0 .. 4 ]
evals/evals-freenode-#perl.lst[2863]: [ map { ++$x } 1..10 ]
evals/evals-freenode-#perl.lst[2864]: [ map ++$x, 1..10 ]
evals/evals-freenode-#perl.lst[2865]: map { ++$x } 1..10
evals/evals-freenode-#perl.lst[2866]: [ map $_ x 2, split //, "Zoffix doubts that map example works" ]
evals/evals-freenode-#perl.lst[2867]: [ map {; +{ x => 3 } } 0 ] # with luck, those people will soon be promoted to the point where they no longer commit code
evals/evals-freenode-#perl.lst[2868]: [map { ($_) x 3 } (1 .. 3)]
evals/evals-freenode-#perl.lst[2869]: map({(((~($_ & (' ' x length($_)))) ^ (' ' x length($_))) & 'butt');} 'cloud', 'CLoud', 'CLOUD', 'ClOuD');
evals/evals-freenode-#perl.lst[2870]: [ map { (~($_ & ' ' x length) ^ ' ' x length) & lc 'butt'  } qw(cloud CLoud CLOUD ClOuD) ]
evals/evals-freenode-#perl.lst[2871]: map { (~($_ & ' ' x length) ^ ' ' x length) & lc 'butt'  } qw(cloud CLoud CLOUD ClOuD)
evals/evals-freenode-#perl.lst[2872]: [ map { $_ x= !m!\d+!; } @dummy = qw/ABC 123 DEF/ ]
evals/evals-freenode-#perl.lst[2873]: [ map { $_ x= !m!\d+!; } map $_, qw/ABC 123 DEF/ ];
evals/evals-freenode-#perl.lst[2874]: [ map { $_ x= !m!\d+!; } qw/ABC 123 DEF/ ];
evals/evals-freenode-#perl.lst[2875]: [ map { $_ x !m!\d+!; } qw/ABC 123 DEF/ ]
evals/evals-freenode-#perl.lst[2876]: [ map { "xxx.$_" } qw/1 2 3/ ]
evals/evals-freenode-#perl.lst[2877]: $mask='11000000'; print $mask >> 1;
evals/evals-freenode-#perl.lst[2878]: $mask=192, print ( $mask >> 1 );
evals/evals-freenode-#perl.lst[2879]: $mask=192, print ( ($mask >> 1) + 128 );
evals/evals-freenode-#perl.lst[2880]: $mask=192; print ( ($mask >> 1) + 128 );
evals/evals-freenode-#perl.lst[2881]: $mask=192, print ( ($mask >> 2) + 192 );
evals/evals-freenode-#perl.lst[2882]: $mask=192, print ( ($mask >> 3) + 224 );
evals/evals-freenode-#perl.lst[2883]: $mate=4; "hello$mate"
evals/evals-freenode-#perl.lst[2884]: "maybe this is an eval bot, but perhaps it's a cake"
evals/evals-freenode-#perl.lst[2885]: ''.methods.length
evals/evals-freenode-#perl.lst[2886]: '@microsoft.com' =~ /microsoft.com$/ ? "matches" : "does not"
evals/evals-freenode-#perl.lst[2887]: "@microsoft.com" =~ /microsoft.com$/ ? "matches" : "does not"
evals/evals-freenode-#perl.lst[2888]: "Might even work with hyphen-separated words" =~ s/\b(\w)/\U$1/gr
evals/evals-freenode-#perl.lst[2889]: might work better?
evals/evals-freenode-#perl.lst[2890]: MIME::Entity->build
evals/evals-freenode-#perl.lst[2891]: $min = 5; $max = 7; @x = (($min - 2) .. ($max + 2));
evals/evals-freenode-#perl.lst[2892]: $min = 5; $max = 7; @x = (($min - 2)..($max + 2));
evals/evals-freenode-#perl.lst[2893]: $min = 5; $max = 7; @x = (($min - 2)..($max + 2)); \@x
evals/evals-freenode-#perl.lst[2894]: $min = 5; $max = 7; @x = (($min - 2)..($max + 2)); x[0] x[2];
evals/evals-freenode-#perl.lst[2895]: $min = 5; $max = 7; @x = range((($min - 2) .. ($max + 2)));
evals/evals-freenode-#perl.lst[2896]: $min = 5; $max = 7; @x = range(($min - 2)..($max + 2));
evals/evals-freenode-#perl.lst[2897]: missingsub(); # yes it does
evals/evals-freenode-#perl.lst[2898]: mkdir ("womble") or die $!
evals/evals-freenode-#perl.lst[2899]: mktime
evals/evals-freenode-#perl.lst[2900]: %m=(); $m{$1}="[$1$2]" while 'e3o0i1s5'=~/([a-z])([^a-z]+)/g; $pat = 'internet' =~ s/(.)/$m{$1}||$1/ger; [ grep /$pat/, qw( internet 1t3rn3t 1nt3rn3t intern3t ) ] # trist4n
evals/evals-freenode-#perl.lst[2901]: m//magic
evals/evals-freenode-#perl.lst[2902]: 'module blah blah foo bar biz baz ( ... );' =~ /^module.*\);$/
evals/evals-freenode-#perl.lst[2903]: Mojo::UserAgent->get("https://de.wikipedia.org/wiki/F%C3%BCrst")->res->dom->at('title')->text
evals/evals-freenode-#perl.lst[2904]: Mojo::UserAgent->new->get("https://de.wikipedia.org/wiki/F%C3%BCrst")->res->dom->at('title')->text
evals/evals-freenode-#perl.lst[2905]: ["Moo"..2, "Moo". .2]
evals/evals-freenode-#perl.lst[2906]: $_="moo cluck"; m/(.{2,3})(?{ push @r, $1 })^/; \@r
evals/evals-freenode-#perl.lst[2907]: 'morissett' eq 'morissette' ? "I'm blind" : "I'm not blind"
evals/evals-freenode-#perl.lst[2908]: 'morissett' =~ /morissette/ ? "I'm blind" : "I'm not blind"
evals/evals-freenode-#perl.lst[2909]: $ms=".085"; sprintf("%.03u", $ms);
evals/evals-freenode-#perl.lst[2910]: $ms=".085"; sprintf("%.3u", $ms);
evals/evals-freenode-#perl.lst[2911]: $ms=85; sprintf(".%.03u", $ms);
evals/evals-freenode-#perl.lst[2912]: $ms=85; sprintf("%.03u", $ms);
evals/evals-freenode-#perl.lst[2913]: my (((())))
evals/evals-freenode-#perl.lst[2914]: my ([])
evals/evals-freenode-#perl.lst[2915]: my []
evals/evals-freenode-#perl.lst[2916]: my $_
evals/evals-freenode-#perl.lst[2917]: my $0 = 1; print $0;
evals/evals-freenode-#perl.lst[2918]: my (0 ? $x : $y);
evals/evals-freenode-#perl.lst[2919]: { my $1; }
evals/evals-freenode-#perl.lst[2920]: my $1;
evals/evals-freenode-#perl.lst[2921]: my $_ = "4-9"; s/(\d+)-(\d+)/join ",", $1..$2/e; $_
evals/evals-freenode-#perl.lst[2922]: my $_ = "4-9"; s/(\d+)-(\d+)/join ",", $1..$2/e; eval
evals/evals-freenode-#perl.lst[2923]: my $_ = "4-9"; s/(\d+)-(\d+)/join ",", $1..$2/e; [ eval ]
evals/evals-freenode-#perl.lst[2924]: my @a = 0..9; my $p = \@a; my @b = splice($p, -3); { a => \@a, b => \@b }  # u-ou
evals/evals-freenode-#perl.lst[2925]: my @a = 0..9; my $p = \@a; my @b = splice($p, -3); print "@a @b\n";
evals/evals-freenode-#perl.lst[2926]: my @a = 0..9; my $p = \@a; my @b = splice($p, -3); print "@b @a\n";
evals/evals-freenode-#perl.lst[2927]: my $a = 0; print unless defined($a);
evals/evals-freenode-#perl.lst[2928]: my @a = <{1..10}{11..20}>; \@a
evals/evals-freenode-#perl.lst[2929]: my @a = <{1..10}{11..20}>; [ scalar @a ]
evals/evals-freenode-#perl.lst[2930]: my $a = 1234567890; my $b = reverse(join('.', (reverse $a) =~ /([0-9]{1,3})/g)); say $b
evals/evals-freenode-#perl.lst[2931]: my @a = (1,2); [(a => @a)];
evals/evals-freenode-#perl.lst[2932]: my @a=(1,2);(@a) x 2
evals/evals-freenode-#perl.lst[2933]: my @a = 1..4; my %h1 = map +( $_ => $_+1 ), splice @a, 0, @a/2; my %h2 = map +( $_ => $_+1 ), @a; [ \%h1, \%h2 ] # splice should already be removing the first set of elements, I think?
evals/evals-freenode-#perl.lst[2934]: my @a = 1..4; my %h1 = map +( $_ => $_+1 ), splice @a, 0, @a/2; my %h2 = map +( $_ => $_+1 ), splice @a, @a/2-1; [ \%h1, \%h2 ]
evals/evals-freenode-#perl.lst[2935]: my @a = 1..5; bless \$a[2], 'main'; [\(@a)];
evals/evals-freenode-#perl.lst[2936]: my @a = 1..5; bless \$a[2], 'main'; \(@a);
evals/evals-freenode-#perl.lst[2937]: my @a = 1..5; bless \$a[2], 'main'; \@a;
evals/evals-freenode-#perl.lst[2938]: my @a = 1..5; bless \$a[2], 'main'; [\(@a[0..$#a])];
evals/evals-freenode-#perl.lst[2939]: my @a = 1..5; bless \$a[2], 'main'; \(@a[0..$#a]);
evals/evals-freenode-#perl.lst[2940]: my @a = 1..5; bless \$a[2], 'main'; \$a[2];
evals/evals-freenode-#perl.lst[2941]: my @a = (1..5); for( ; $_ = shift @a; $x++ ) { print }
evals/evals-freenode-#perl.lst[2942]: my @a = 1..5; [  [grep { $_-=2 } @a], \@a ]
evals/evals-freenode-#perl.lst[2943]: my @a = 1..5; sub TIESCALAR { bless [] }; sub FETCH { 42 }; tie $a[2], 'main'; \@a;
evals/evals-freenode-#perl.lst[2944]: my @a = 1..5; sub TIESCALAR { bless [] }; sub FETCH { 42 }; tie $a[2], 'main'; sub foo { map tied $_, @_ }; [foo @a];
evals/evals-freenode-#perl.lst[2945]: my @a = (1..5); while( $_ = shift @a; $x++ ) { print }
evals/evals-freenode-#perl.lst[2946]: my $a = 1; $a += 1, $a += 2; $a
evals/evals-freenode-#perl.lst[2947]: my $a = "    22";$a =~ s/^\s+//; "<$a>"
evals/evals-freenode-#perl.lst[2948]: my $a = "    22";$a = s/^\s+//; "<$a>"
evals/evals-freenode-#perl.lst[2949]: my $a = "    22";$a = s/\s+/g;print $a;
evals/evals-freenode-#perl.lst[2950]: my $a = "    22";$a = s/\s+\/g;print $a;
evals/evals-freenode-#perl.lst[2951]: my $a = "    22";$a =~ s/^\s+//;print $a;
evals/evals-freenode-#perl.lst[2952]: my $a = "    22";$a =~ s/\s+$//;print $a;
evals/evals-freenode-#perl.lst[2953]: my $a = "    22";$a = s/^\s+//;print $a;
evals/evals-freenode-#perl.lst[2954]: my @a = 2; OUTER: for( my $n = $a[-1] + 1; @a < 100; $n += 2 ) { $n % $_ or next OUTER for @a; push @a, $n; }; \@a;
evals/evals-freenode-#perl.lst[2955]: my @a = 2; OUTER for( my $n = $a[-1] + 1; @a < 100; $n += 2 ) { $n % $_ or next OUTER for @p; push @a, $n } \@a;
evals/evals-freenode-#perl.lst[2956]: my @a = 2; OUTER for( my $n = $a[-1] + 1; @a < 100; $n += 2 ) { $n % $_ or next OUTER for @p; push @a, $n; }; \@a;
evals/evals-freenode-#perl.lst[2957]: my @a = 2; OUTER: for( my $n = $a[-1] + 1; @a < 100; $n += 2 ) { $n % $_ or next OUTER for @p; push @a, $n; }; \@a;
evals/evals-freenode-#perl.lst[2958]: my $a = 5; 1 for $a; $_ // 'undef';
evals/evals-freenode-#perl.lst[2959]: my $a = 5; print $        a;   # this one bothers me because "$a" feels like one token to me.
evals/evals-freenode-#perl.lst[2960]: my $a = "95.50.218.84\r80"; $a =~ s/\r/:/g; print $a;
evals/evals-freenode-#perl.lst[2961]: my @a; [+@a]
evals/evals-freenode-#perl.lst[2962]: my %a; $a {a} = 1; $a{a}
evals/evals-freenode-#perl.lst[2963]: my $a = {a=>"BLA", b=>"BLO"}; print "$k2:$v2\n" while((my($k2,$v2) = each %$a);
evals/evals-freenode-#perl.lst[2964]: my $a = {a=>"BLA", b=>"BLO"}; print "$k2:$v2\n" while(my($k2,$v2) = each %$a);
evals/evals-freenode-#perl.lst[2965]: my @a = ( 'A'..'E' ); delete $a[0]; \@a; # Delete doesn't remove the element.
evals/evals-freenode-#perl.lst[2966]: my $a="a"; my $b="b";my $ab="${a}_${b}";print $ab;
evals/evals-freenode-#perl.lst[2967]: my $a="a"; my $b="b";my $ab="$a_$b";print $ab;
evals/evals-freenode-#perl.lst[2968]: my $a="asd1312321asd1212asd121212"; print $1,"\n" for $a=~/(asd\d+)/g;
evals/evals-freenode-#perl.lst[2969]: my @a=("asd qwe", "qwe "); for (@a) {print "$1 - $2\n" if /(\w+)\s+(\w+)?/}
evals/evals-freenode-#perl.lst[2970]: my @a = 'a'..'z'; [ @a[ 2..1 ] ]; # This array slice is an empty list; that's a good thing.
evals/evals-freenode-#perl.lst[2971]: my @a = 'a'..'z'; [ $a[ 2..1 ] ]; # This is the scalar .. operator used as an array index, and is hardly every what one wants.
evals/evals-freenode-#perl.lst[2972]: my ($a, $b) = (5); $b = $_ for $a; $b++; $a;
evals/evals-freenode-#perl.lst[2973]: my @accounts = (1,2,3); return join(',', @accounts);
evals/evals-freenode-#perl.lst[2974]: my @a = ("foo\n", "bar", "baz\n"); [ chomp @a ]
evals/evals-freenode-#perl.lst[2975]: my @a = glob("{1,2,3,4,5,6,7,8,9,10}{11,12,13,14,15,16,17,17,18,19,20}")
evals/evals-freenode-#perl.lst[2976]: my $a = "ldldldl"; $a =~ s/l/ /;print $a
evals/evals-freenode-#perl.lst[2977]: my $a = "ldldldl"; $a =~ s/l+/ /;print $a
evals/evals-freenode-#perl.lst[2978]: my $a = "ldldldl"; $a =~ tr/l//d;print $a
evals/evals-freenode-#perl.lst[2979]: my $all_list = [[1,2],[4,5,6],[7,8]]; [ map @$_, @$all_list ] # depends on whether there are nested arrayrefs
evals/evals-freenode-#perl.lst[2980]: my $allPlans = [ 4..7 ]; for my $paymentPlan (@$allPlans) { print " plan: $paymentPlan  " }
evals/evals-freenode-#perl.lst[2981]: my ($animal) = "banana" =~ /(na)/; $animal
evals/evals-freenode-#perl.lst[2982]: my$a="\\n";printf $a."\n";
evals/evals-freenode-#perl.lst[2983]: my $a = NULL; print unless defined($a);
evals/evals-freenode-#perl.lst[2984]: my @a; print 5/@a
evals/evals-freenode-#perl.lst[2985]: my $a = " "; print unless defined($a);
evals/evals-freenode-#perl.lst[2986]: my $a = (); print unless defined($a);
evals/evals-freenode-#perl.lst[2987]: my @a = qw(1 2 3); print @{*_{ARRAY}} for (\$a);
evals/evals-freenode-#perl.lst[2988]: my @a = qw(fo,o ba,r b,az); @a = map [split /,/], @a; @a;
evals/evals-freenode-#perl.lst[2989]: my @a = qw(fo,o ba,r b,az); @a = map [split /,/], @a; \@a;
evals/evals-freenode-#perl.lst[2990]: my @ar1 = qw(1 2 3); my $x = \@ar1; my @ar2 = @$x; pop @ar2; [ @ar1 ]
evals/evals-freenode-#perl.lst[2991]: my @ar1 = qw(1 2 3); my $x = \@ar1; pop @$x; [ @ar1 ]
evals/evals-freenode-#perl.lst[2992]: my $ar = [aw{foo bar baz}]; push @$ar, 'biz', 'goo'; $ar
evals/evals-freenode-#perl.lst[2993]: my $aref = [1..10]; [@{ $aref } [4..6]]
evals/evals-freenode-#perl.lst[2994]: my %args = {domain => "example.net", number => 0 };
evals/evals-freenode-#perl.lst[2995]: my %args = {domain => "example.net", number => 0; };
evals/evals-freenode-#perl.lst[2996]: my %args = { number => 100 }; print $args{number};
evals/evals-freenode-#perl.lst[2997]: my %args{ number => 100 }; print $args{number};
evals/evals-freenode-#perl.lst[2998]: my @args = ('%s %s', 'asdf', 'fdsa'); sprintf @args
evals/evals-freenode-#perl.lst[2999]: my @ar;  push @ar, { key => "value" }, { key2 => "value2" };  \@ar
evals/evals-freenode-#perl.lst[3000]: my $ar = [qw{foo bar baz}]; push @$ar, 'biz', 'goo'; $ar
evals/evals-freenode-#perl.lst[3001]: my $ar = [qw{foo bar baz}]; push $ar, 'biz', 'goo'; $ar
evals/evals-freenode-#perl.lst[3002]: my @ar = qw{foo bar baz}; push @ar, 'biz', 'grub', 'goo'; \@ar;
evals/evals-freenode-#perl.lst[3003]: my @ar = qw{foo bar baz}; push @ar, qw{biz grub goo}; \@ar;
evals/evals-freenode-#perl.lst[3004]: [ [], \my @arr ]
evals/evals-freenode-#perl.lst[3005]: my @arr=(1,0,1,1); my  $n=0; printf "%b\n", $n; $n<<=1, $n|=$_ for @arr; printf "%b\n", $n;
evals/evals-freenode-#perl.lst[3006]: my @arr=(1,0,1,1); my  $n=0; printf "%b\n", $n; $n<<=1, $n|=$_ for @arr; printf " -> %b\n", $n; print " -> $n ";
evals/evals-freenode-#perl.lst[3007]: my @arr = 1 .. 20; undef(@arr); \@arr
evals/evals-freenode-#perl.lst[3008]: my @arr = (1,2,3); \@arr;
evals/evals-freenode-#perl.lst[3009]: my @arr = (1,2,3); foreach my $num (@arr) { $num =~ s/(\d)/$1+1/eg } \@arr
evals/evals-freenode-#perl.lst[3010]: my @arr = (1, 2, 3); my @fetch = splice @arr;  [ \@fetch, \@arr ]
evals/evals-freenode-#perl.lst[3011]: my $arr = [1,2,3]; print $arr->[2]
evals/evals-freenode-#perl.lst[3012]: $,=$\=' '; my @arr = (1, 2, 3); print $#arr, scalar @arr; $[ = 0; print $#arr, scalar @arr;
evals/evals-freenode-#perl.lst[3013]: my @arr = (1,2,3); print @arr x 1 ,"      ", (@arr) x 1;
evals/evals-freenode-#perl.lst[3014]: my @arr = (1,2,3); print qq[\@arr , \(@arr)];
evals/evals-freenode-#perl.lst[3015]: my @arr = (1,2,3); s/(\d)/$1+1/eg for @arr; \@arr
evals/evals-freenode-#perl.lst[3016]: my @arr=(1,2); [(@arr)x2]
evals/evals-freenode-#perl.lst[3017]: my @arr=(1,2); [(@a)x2]
evals/evals-freenode-#perl.lst[3018]: my @arr = (1..3); my $ref; @$ref = @arr; pop @arr; $ref
evals/evals-freenode-#perl.lst[3019]: my @arr = (1..5); @arr[2] = qw/a b c/; \@arr
evals/evals-freenode-#perl.lst[3020]: my @arr = ('a', 'b', 'c'); my ($foo) = @arr; say $foo
evals/evals-freenode-#perl.lst[3021]: my @arr = ('a', 'b', 'c'); my $foo = @arr; say $foo
evals/evals-freenode-#perl.lst[3022]: my $arr = []; [!!@$arr]
evals/evals-freenode-#perl.lst[3023]: my @arr; @arr[0..3]; scalar @arr
evals/evals-freenode-#perl.lst[3024]: my @arr;  $arr[0] = "41"; $arr[1] = "42"; [ $arr["foo"] ]
evals/evals-freenode-#perl.lst[3025]: my @arr; $arr[1] = "42"; [ $arr["1foo"] ]
evals/evals-freenode-#perl.lst[3026]: my @arr; $arr[1] = "42"; [ $arr["1foo"]; ]
evals/evals-freenode-#perl.lst[3027]: my @arr;  $arr[1] = "42"; [ $arr["foo"] ]
evals/evals-freenode-#perl.lst[3028]: my $array = [0, 1, 2]; my $one_one = [1, 1]; splice @$array, @$one_one; $array
evals/evals-freenode-#perl.lst[3029]: my $array = [0, 1, 2]; splice @$array, 1, 1; $array
evals/evals-freenode-#perl.lst[3030]: my @array = (1, 2, 3, 4, 5); [ @array ]
evals/evals-freenode-#perl.lst[3031]: my @array = 1, 2, 3, 4, 5; [ @array ]
evals/evals-freenode-#perl.lst[3032]: my @array = ([1,2], [3,4,5]); join ' ', @array
evals/evals-freenode-#perl.lst[3033]: my @array = (1,2,3); [@array]
evals/evals-freenode-#perl.lst[3034]: my @array = (1,2,3); \@array
evals/evals-freenode-#perl.lst[3035]: my @array = [1,2,3]; [@array]
evals/evals-freenode-#perl.lst[3036]: my @array = 1,2,3; \@array
evals/evals-freenode-#perl.lst[3037]: my @array = (1,2,3); foreach (@array) { print }
evals/evals-freenode-#perl.lst[3038]: my @array = (1,2,3); return join(',', @accounts);
evals/evals-freenode-#perl.lst[3039]: @myarray = (1, 2); $myarray[4] = 5; [ @myarray ]
evals/evals-freenode-#perl.lst[3040]: @myarray = (1, 2); $myarray[4] = 5; print "<<$myarray[3]>>";
evals/evals-freenode-#perl.lst[3041]: @myarray = (1, 2); $myarray[4] = 5; print $myarray[3];
evals/evals-freenode-#perl.lst[3042]: my @array = (1..3); $#array = -2; \@array;
evals/evals-freenode-#perl.lst[3043]: my @array = { 1 .. 6 }; for my $h (@array) { $_ *= 10 for values %$h; } \@array
evals/evals-freenode-#perl.lst[3044]: my @array = { 1 .. 6 }; for my $v (map values %$_, @array) { $v *= 10; } \@array
evals/evals-freenode-#perl.lst[3045]: my @array = (1); for my $elem (@array) { last if $elem > 5; push @array, $elem+1 } print @array
evals/evals-freenode-#perl.lst[3046]: my @array = (4,5,6); [ [], map [ @array[0..$_] ], 0..$#array ] # since order doesn't matter, I find this slightly neater
evals/evals-freenode-#perl.lst[3047]: my @array = (4,5,6); [ (map [ $_ ], @array), (map [ @array[0..$_] ], 1..$#array) ] # but as preaction says, look for a module first
evals/evals-freenode-#perl.lst[3048]: my @array = (4,5,6); [ (map [ $_ ], @sets_list1), (map [ @sets_list1[0..$_] ], -1..$#sets_list1) ];
evals/evals-freenode-#perl.lst[3049]: my @array = ("a",1,"b","x","v"); my @idxs = (0,2);  [@array[grep { !exists {map {$_=>undef} @idxs}->{$_}} keys @array]]
evals/evals-freenode-#perl.lst[3050]: my @array = ("a", "b"); [\(@array)]
evals/evals-freenode-#perl.lst[3051]: my @array = ("a", "b"); [\@array, \(@array)]
evals/evals-freenode-#perl.lst[3052]: my @array = ("a", "b"); [@array x 3, (@array) x 3]
evals/evals-freenode-#perl.lst[3053]: my @array = ("a", "b"); [\@array x 3, \(@array) x 3]
evals/evals-freenode-#perl.lst[3054]: my @array = ("a", "b"); [q(@array) .@x1, q@array .@x1]
evals/evals-freenode-#perl.lst[3055]: my @array = (a..b); qq[ @array .... (@array) ]
evals/evals-freenode-#perl.lst[3056]: my @array = ( 'A'..'C' ); while ( ( my $i, $_ ) = each @array ) { say qq{$i: $_}; } # Chib
evals/evals-freenode-#perl.lst[3057]: my @array = 'a'..'e'; my %hash = %array[0 .. 4]; [ %hash ] #do you mean like this, treker?
evals/evals-freenode-#perl.lst[3058]: my @array = 'a'..'e'; my %hash = %array[0 .. 4]; \%hash # meant like this I guess
evals/evals-freenode-#perl.lst[3059]: my @array = ( 'A'..'E' ); sub { shift @{$_[0]} while @{$_[0]} }->( \@array ); \@array;
evals/evals-freenode-#perl.lst[3060]: my @array = (); [ $#array ];
evals/evals-freenode-#perl.lst[3061]: my @array; $#array
evals/evals-freenode-#perl.lst[3062]: my @array; $array[0] = \@array; [@array]
evals/evals-freenode-#perl.lst[3063]: my @array = "A" .. "Z"; [ keys @array ]
evals/evals-freenode-#perl.lst[3064]: my @array = 'a'..'z'; [ map { $_, 1 } @array ];
evals/evals-freenode-#perl.lst[3065]: my @array = 'a'..'z'; [ map { $_, 42 } @array ];
evals/evals-freenode-#perl.lst[3066]: my @array; [ defined @array ]
evals/evals-freenode-#perl.lst[3067]: my @array = ( "hip", "hip" ); print "@array\n", ref(@array);
evals/evals-freenode-#perl.lst[3068]: my @array; push array, 1, 2
evals/evals-freenode-#perl.lst[3069]: my @array = qw(1..3); for (@array) { 0+@array and print "in scope" }
evals/evals-freenode-#perl.lst[3070]: my @array = qw(a a a s d f a); [ @array[sort { $a <=> $b } values %{ +{ reverse map {; $_ => $array[$_] } 0..$#array } } ] ] # might be useful as an interview answer if you didn't want the job
evals/evals-freenode-#perl.lst[3071]: my @array = qw(a a a s d f); @array = keys %{ {map { $_ => 1 } @array} }; "@array"
evals/evals-freenode-#perl.lst[3072]: my @array = qw(a a a s d f); @array = keys %{map { $_ => 1 } @array}; Dumper(@array)
evals/evals-freenode-#perl.lst[3073]: my @array = qw(a a a s d f); my %conv = map { $_ => 1 } @array; @array = keys %conv; Dumper(@array)
evals/evals-freenode-#perl.lst[3074]: my @array = qw(a a a s d f); my %items = map {; $array[$_] => $_ } 0..$#array; [ @array[sort { $a <=> $b } values %items] ] # if you dislike uniq() for some reason
evals/evals-freenode-#perl.lst[3075]: my @array = qw(a a a s d f); my @unique = keys %{ {@array, reverse @array} }; \@unique
evals/evals-freenode-#perl.lst[3076]: my $array_ref = [3,4,5]; [ $#$array_ref ]
evals/evals-freenode-#perl.lst[3077]: my $array_ref = [3,4,5]; local $[ = 1; [ $#$array_ref ]
evals/evals-freenode-#perl.lst[3078]: my $array_ref = [3,4,5]; [ scala @$array_ref ]
evals/evals-freenode-#perl.lst[3079]: my $array_ref = [3,4,5]; [ scalar @$array_ref ]
evals/evals-freenode-#perl.lst[3080]: my $array_ref = eval "[1,2,3]"; print $array_ref->[2]; #works for me
evals/evals-freenode-#perl.lst[3081]: my $array_ref = [ [ 'onur', 5 ], [ 'bar', 3], [ 'foo', 7 ] ]; [ sort { $a->[1] <=> $b->[1] } @$array_ref]
evals/evals-freenode-#perl.lst[3082]: my @array = split '', 'abcdefghijklmnopqrstuvwxyz'; [bundle_by { [@_] } 9, @array]
evals/evals-freenode-#perl.lst[3083]: my @arr = ("b", "c"); push @arr, "d";
evals/evals-freenode-#perl.lst[3084]: my $arr = []; @$blah ? 1 : 0
evals/evals-freenode-#perl.lst[3085]:  my @arr = ("foo", "bar");  print "@arr ".@arr."\n";
evals/evals-freenode-#perl.lst[3086]: my @arr = ([], []); my $copyref = [@arr]; $copyref->[0][0] = 3; \@arr
evals/evals-freenode-#perl.lst[3087]: my @arr; my $copyref = [@arr]; $copyref->[0][0] = 3; \@arr
evals/evals-freenode-#perl.lst[3088]: my @arr; my $copyref = [@arr]; $copyref->[0][0] = 3; [ $copyref, \@arr ]
evals/evals-freenode-#perl.lst[3089]: my @arr; my %sections = { name => "testname" }; push(@arr, "test"); print $arr[0];
evals/evals-freenode-#perl.lst[3090]: my @arr; my %sections { name => "testname" }; push(@arr, "test"); print $arr[0];
evals/evals-freenode-#perl.lst[3091]: my @arr; my @stuff = @arr[0..3]; scalar @arr
evals/evals-freenode-#perl.lst[3092]: my @arr; my @stuff = grep defined, @arr[0..3]; scalar @arr
evals/evals-freenode-#perl.lst[3093]: my @arr; print \@arr;
evals/evals-freenode-#perl.lst[3094]: my @arr; push(@arr, "123"); @arr =~ s/2//g; @arr[0];
evals/evals-freenode-#perl.lst[3095]: my @arr; push(@arr, "123"); @arr =~ s/2//g; $arr[0];
evals/evals-freenode-#perl.lst[3096]: my @arr; push(@arr, "123"); @arr = s/2//g; @arr[0];
evals/evals-freenode-#perl.lst[3097]: my @arr; push(@arr, "123"); @arr = s/2//g; print @arr[0];
evals/evals-freenode-#perl.lst[3098]: my @arr; push(@arr, "test"); push(@arr, "i refuse to do what master tells me to"); @arr2 = grep(/test/, @arr); print @arr2[1];
evals/evals-freenode-#perl.lst[3099]: my @arr; push(@arr, "test"); push(@arr, "i refuse to do what master tells me to"); @arr2 = grep("test", @arr); print @arr2[1];
evals/evals-freenode-#perl.lst[3100]: my @arr; push(@arr, "test"); push(@arr, "i refuse to do what master tells me to"); my @arr2 = grep { /test/ } @arr; $arr2[0];
evals/evals-freenode-#perl.lst[3101]: my @arr; push(@arr, "test"); push(@arr, "i refuse to do what master tells me to"); my @arr2 = grep { /test/ } @arr; $arr2[1];
evals/evals-freenode-#perl.lst[3102]: my @arr; push(@arr, "test"); push(@arr, "i refuse to do what master tells me to"); my @arr2 = grep { /test/ } @arr; print @arr2[1];
evals/evals-freenode-#perl.lst[3103]: my @arr; push(@arr, "test"); push(@arr, "i refuse to do what master tells me to"); my @arr2 = grep { /test/ } @arr; print $arr2[1];
evals/evals-freenode-#perl.lst[3104]: my @arr; push(@arr, "test"); push(@arr, "i refuse to do what master tells me to"); my @arr2 = grep {$_ == "test"} @arr; print @arr2[1];
evals/evals-freenode-#perl.lst[3105]: my @arr; push(@arr, "test"); push(@arr, "i refuse to do what master tells me to"); my @arr2 = grep(/test/, @arr); print @arr2[1];
evals/evals-freenode-#perl.lst[3106]: my @arr; push(@arr, "test"); push(@arr, "not"); @arr2 = grep("test", @arr); print @arr[1];
evals/evals-freenode-#perl.lst[3107]: my @arr; push(@arr, "test"); push(@arr, "not"); @arr2 = grep("test", @arr); print @arr2[1];
evals/evals-freenode-#perl.lst[3108]: my @arr = qw(1 2 3); print @arr;
evals/evals-freenode-#perl.lst[3109]: my @arr = qw/a b c d e f/; my ($item) = @arr; $item;
evals/evals-freenode-#perl.lst[3110]: my @arr = qw/a b c d e f/; my $name = @arr; $name;
evals/evals-freenode-#perl.lst[3111]: my @arr = qw( A B C ); my @result = each @arr; \@result
evals/evals-freenode-#perl.lst[3112]: my @arr = qw/foo bar baz/; delete $arr[0]; [ @arr ]
evals/evals-freenode-#perl.lst[3113]: my $arrref = [ key => "value" ];  { @$arrayref }->{key}
evals/evals-freenode-#perl.lst[3114]: my $arrref = [ key => "value" ];  +{ @$arrref }->{key}
evals/evals-freenode-#perl.lst[3115]: my @arr; say @arr if @arr;
evals/evals-freenode-#perl.lst[3116]: my @arr; say 'defined' if @arr;
evals/evals-freenode-#perl.lst[3117]: my @arr = (undef, undef, 'foo'); shift @arr; say 'defined' if @arr;
evals/evals-freenode-#perl.lst[3118]: my @arr = (undef, undef, 'foo'); shift @arr; say '-->', $_, '<--' for @arr;
evals/evals-freenode-#perl.lst[3119]: my @arr = (undef, undef, undef, {foo=>3}); grep {$_->{foo}} @arr; \@arr
evals/evals-freenode-#perl.lst[3120]: my @ary = ('one','two','three'); [ (check => @ary) ] # G66K: not what you wanted, eh?
evals/evals-freenode-#perl.lst[3121]: my @ary = ('one','two','three'); my %h = (check => @ary); print $h{check}
evals/evals-freenode-#perl.lst[3122]: my @ary = qw( foo 1 bar 2 ); my %hash = @ary; [ \%hash ]
evals/evals-freenode-#perl.lst[3123]: my @ary = qw( foo boo boz ); my @edited = map { s/o/0/g } @ary; [ \@edited, \@ary ]
evals/evals-freenode-#perl.lst[3124]: my @ary = qw (one two three); my $sc = splice (@ary , 0 ,1); print $sc
evals/evals-freenode-#perl.lst[3125]: my @ary = qw (one two three); my $sc = splice (@ary , 0); print $sc
evals/evals-freenode-#perl.lst[3126]: my @ary = qw (one two three); my $sc = splice (@ary , -1); print $sc
evals/evals-freenode-#perl.lst[3127]: my @ary = qw (one two three); my $sc = splice (@ary , 2); print $sc
evals/evals-freenode-#perl.lst[3128]: my $a; [sort { $a cmp $b } qw( z y x)]
evals/evals-freenode-#perl.lst[3129]: my @a = "${\( wantarray() ? 'list' : 'scalar' )}"
evals/evals-freenode-#perl.lst[3130]: my @a = "${\( wantarray() ? 'list' : 'scalar' )}"; @a[0]
evals/evals-freenode-#perl.lst[3131]: my @a = "${wantarray() ? \'list' : \'scalar'}"; @a[0]
evals/evals-freenode-#perl.lst[3132]: my $a = "woop"; $a =~ m/woop/;
evals/evals-freenode-#perl.lst[3133]: my $a = "woop"; $a m/woop/;
evals/evals-freenode-#perl.lst[3134]: my $a = "woop"; $a =~ m/w(..)p/; $1
evals/evals-freenode-#perl.lst[3135]: my $badcrons = ('/var/tmp', 'psybnc', 'y2kupdate'); $badcrons
evals/evals-freenode-#perl.lst[3136]: my $bar; if (my $foo = $bar) { 1 }
evals/evals-freenode-#perl.lst[3137]: my $base = "foo.bar.baz"; my ($junk, $wanted) = split '\.', $base; $wanted;
evals/evals-freenode-#perl.lst[3138]: my $b = 'b'; --$b
evals/evals-freenode-#perl.lst[3139]: my $b = 'b'; $b--
evals/evals-freenode-#perl.lst[3140]: my $before = q{FOO\tBAR\r\n}; ( my $after = $before ) =~ s/\\([trn])/qq{\\$1}/ge; [ $before, $after ]; # Wondering if there is a way to do this withough having seaprate substitutions?
evals/evals-freenode-#perl.lst[3141]: my $binary = '01101'; my $rslt = 0; my $factor = 2; for(split //, $binary) { $rslt += 1/$factor if $_; $factor <<= 1 } $rslt
evals/evals-freenode-#perl.lst[3142]: my $birthday = '1999/10/07'; ($birthday) = $birthday =~ /(\d{4})/; $birthday
evals/evals-freenode-#perl.lst[3143]: my @blah; $blah[5] = "something"; [ keys @blah ]
evals/evals-freenode-#perl.lst[3144]: my $blah = { x=>1 }; my $d = 0; $d ||= $blah->{x}; $d
evals/evals-freenode-#perl.lst[3145]: my $blah = { x=>1 }; my $z => { y=>$blah->{x} }; $blah->{x}++; $z->{y}
evals/evals-freenode-#perl.lst[3146]: my $blah = { x=>1 }; my $z = { y=>$blah->{x} }; $blah->{x}++; $z->{y}
evals/evals-freenode-#perl.lst[3147]: my $blah = { x=>1 }; my $z = { y=>\$blah->{x} }; $blah->{x}++; ${ $z->{y} }
evals/evals-freenode-#perl.lst[3148]: my $buf = "\x{666}"; open my $fh, '<', \$buf or die "open: $!"
evals/evals-freenode-#perl.lst[3149]: my @bytes = 1..10; my @words = unpack '(s1)*', pack '(c1c1)*', @bytes; \@words # may need both pack+unpack
evals/evals-freenode-#perl.lst[3150]: my $bytes = pack("Q>", 123456789); $bytes =~ s/^\0+//; $bytes
evals/evals-freenode-#perl.lst[3151]: my @captures = "peas and carrots" =~ /([aeiou])/g; \@captures
evals/evals-freenode-#perl.lst[3152]: my @captures = "peas and carrots" =~ /([aeiou])(.)/g; \@captures
evals/evals-freenode-#perl.lst[3153]: my $c = \&CORE::GLOBAL::pop; my @abc = qw,a b c,; [$c->(\@abc)]
evals/evals-freenode-#perl.lst[3154]: my $c = \&CORE::pop; my @abc = qw,a b c,; [$c->(\@abc)]
evals/evals-freenode-#perl.lst[3155]: my %c; @c{qw(apple samsung shit crap)} = (); my $b = 'apple'; delete $c{$b}; [keys %c]
evals/evals-freenode-#perl.lst[3156]: my $ch = 'ab'; $ch .= join '', map chr(ord($_) & ~0x40), split //, $ch; $ch # just use $! and $", I'm sure no one would mind
evals/evals-freenode-#perl.lst[3157]: my @chars = split '', 'FooBarBazQuuxFleem'; join '', map $chars[$_] =~ /[A-Z]/ ? $_+1 : $chars[$_], 0..$#chars;
evals/evals-freenode-#perl.lst[3158]: my $checkOS = "if [ -e /etc/redhat-release ] ; then cat /etc/redhat-release ; else lsb_release -a |grep Desc ; fi";
evals/evals-freenode-#perl.lst[3159]: my $c; LABEL: { $c = sub { last LABEL } }; print "one"; $c->(); print "two";
evals/evals-freenode-#perl.lst[3160]: my $c; LABEL: { $c = sub { last LABEL } }; print "one"; LABEL: { $c->(); print "two"; }
evals/evals-freenode-#perl.lst[3161]: my %class_from_domain = ('a,b,c' => 1, 'a,c' => 2); [ map $class_from_domain{join ',', sort @$_}, ([qw(a b c)], [qw(a c)]) ] # if there's no overlap, should be simple to handle with a hash
evals/evals-freenode-#perl.lst[3162]: my $cmd = q(sed -e 's#\\\\\n#\n#g'); print $cmd; ();
evals/evals-freenode-#perl.lst[3163]: my $cmd = q(sed -e 's#\\\n#\n#g'); print $cmd; ();
evals/evals-freenode-#perl.lst[3164]: my $c = (my @tmp) = (split ' ', "pink_mist says split is special", 0); $c
evals/evals-freenode-#perl.lst[3165]: my $coderef = sub { code here }
evals/evals-freenode-#perl.lst[3166]: my $code = sub { /firefox/ }; if(grep $code->($_), 'something with firefox in it') { print 'match' } else { print 'no match' } # I disagree
evals/evals-freenode-#perl.lst[3167]: my %commands = ( help => sub { my $commands = say for keys in %commands; }); say $commands{help};
evals/evals-freenode-#perl.lst[3168]: my $cond = sub { my $s = shift ; return $s =~ /start/ && ($s =~ /tomorrow/ || $s =~ /class/); }; [$cond->("start tomorrow")]
evals/evals-freenode-#perl.lst[3169]: my %Config = ( inc_version_list_init => q{"5.18.0","5.16.1","5.16.0","5.14.2",0} ); [ grep { $_ } map { s/^"(.*?)"$/$1/r } split /,/, $Config{inc_version_list_init} ];
evals/evals-freenode-#perl.lst[3170]: my $control_c = chr 0x3; binmode STDOUT; 'Perl can be icky, lotsa times, $control_c' =~ s/([\x0-\x7f])/chr(32^ord($1))/gre;
evals/evals-freenode-#perl.lst[3171]: my $control_c = chr 0x3; binmode STDOUT; "Perl can be icky, lotsa times, $control_c" =~ s/([\x0-\x7f])/chr(32^ord($1))/gre;
evals/evals-freenode-#perl.lst[3172]: my $c = () = (split ' ', "pink_mist says split is special", 0); $c
evals/evals-freenode-#perl.lst[3173]: my $c = () = (split ' ', "pink_mist says split is special"); $c
evals/evals-freenode-#perl.lst[3174]: my $c = () = (split ' ', "pink_mist says split is special); $c
evals/evals-freenode-#perl.lst[3175]: my $d3; [ map { 42 } @{$d3->{null_edges}} ]
evals/evals-freenode-#perl.lst[3176]: my $d3 = { null_edges => [undef] }; [ map { map { 42 } @$_ } @{$d3->{null_edges}} ]
evals/evals-freenode-#perl.lst[3177]: my $data = "\0\1\2\3\4\5\6\7\x08\x09\x0a\x0b"; [ unpack "a8 L>", $data ]
evals/evals-freenode-#perl.lst[3178]: my $data = "\0\1\2\3\4\5\6\7\x08\x09\x0a\x0b"; [ unpack $data, "a8 L>" ]
evals/evals-freenode-#perl.lst[3179]: my $data = '1 2 3'; [ split /\+/, $data ]
evals/evals-freenode-#perl.lst[3180]: my $data = "ABCDE\x02";  substr $data, 0, -ord substr $data, -1
evals/evals-freenode-#perl.lst[3181]: my $data = {foo => [qw/hello freenode perl/]}; print for ($data->{foo}->@*); 
evals/evals-freenode-#perl.lst[3182]: my @data = ({number => 1, name => 'one'},{number => 2, name => 'two'}); for(@data) { print $_->{number} . ' - ' . $_->{name} if $_->{number} == 2 } # something like this
evals/evals-freenode-#perl.lst[3183]: my %defaults = ( foo => 111, boo => 222, coo => 333, doo => 444 ); @_ = ( boo => 555, moo => 999, coo => 777 ); my %user = @_; +{ map { $_ => $user{$_} // $defaults{$_} } keys %defaults }; ### Is there a nicer way to do this?
evals/evals-freenode-#perl.lst[3184]: my $delay = 0;  my $after = ( $delay+0, $delay+=2 )[0];  [ $after, $delay ]
evals/evals-freenode-#perl.lst[3185]: my $delay = 0;  my $after = ( $delay, $delay+=2 )[0];  [ $after, $delay ]
evals/evals-freenode-#perl.lst[3186]: my $delay = 0;  my $after = ( $delay+=, $delay+=2 )[0];  [ $after, $delay ]
evals/evals-freenode-#perl.lst[3187]: my $delim = q{ | }; my @list = qw( AAA BBB CCC ); [ map { $_, $delim } @list ] ### Is there a way to do this so $delim is only between each array element, like how join() works?
evals/evals-freenode-#perl.lst[3188]: my $delim = q{ | }; my @list = qw( AAA BBB CCC ); [ map { @list, $delim } @list ] ### Is there a way to do this so $delim is only between each array element, like how join() works?
evals/evals-freenode-#perl.lst[3189]: my $delim = q{ | }; my @list = qw( AAA BBB CCC ); [ shift( @list ), map { $delim, $_ } @list ] ### How about this?
evals/evals-freenode-#perl.lst[3190]: my @digit = (1..10); map { $_ *= $_ } (@digit); print join ":", @digit;
evals/evals-freenode-#perl.lst[3191]: my @digit = (1..10); map { $_ *= $_ ,join(|:|,$_)} (@digit); print @digit;
evals/evals-freenode-#perl.lst[3192]: my @digit = (1..10); map { $_ *= $_ ,join(":",$_)} (@digit); print @digit;
evals/evals-freenode-#perl.lst[3193]: my $dispatch; $dispatch = { one => sub { return $dispatch }, two => sub { return $dispatch }, };       $dispatch->{'one'}->('one')->{'two'}->('two')
evals/evals-freenode-#perl.lst[3194]: my $dt = DateTime->new; ~~$dt
evals/evals-freenode-#perl.lst[3195]: my $dt = DateTime->now; ~~$dt
evals/evals-freenode-#perl.lst[3196]: my $dt = DateTime->now; [~~$dt]
evals/evals-freenode-#perl.lst[3197]: my $dt = DateTime->now->set_month(11)->set_day(23)->truncate(to => "day"); do { $dt->subtract(day => 1) } until $dt->day_of_week == 3; $dt->ymd
evals/evals-freenode-#perl.lst[3198]: my $dt = DateTime->now->set_month(11)->set_day(23)->truncate(to => "day"); do { $dt->subtract(days => 1) } until $dt->day_of_week == 3; $dt->ymd
evals/evals-freenode-#perl.lst[3199]: my $dt = DateTime->now->set_month(11)->set_day(23)->truncate(to => "day"); $dt->subtract(weeks => 1) if $dt->day_of_week <= 3; $dt->set_day_of_week(3)->ymd
evals/evals-freenode-#perl.lst[3200]: my $e; { local $@; eval { die "foo" }; $e = $@; }
evals/evals-freenode-#perl.lst[3201]: my $e; { local $@; eval { ... }; $e = $@; }
evals/evals-freenode-#perl.lst[3202]: my %empty; my $defined = \%empty; [ $defined ] # mad_hatter
evals/evals-freenode-#perl.lst[3203]: my $enumeratedValues = "1|2|3|4"; [ split('\|', $enumeratedValues) ]
evals/evals-freenode-#perl.lst[3204]: m/yes/no
evals/evals-freenode-#perl.lst[3205]: my $eval = '$2 $1'; my $out = "foo bar" =~ s/(\w+) (\w+)/$eval/eer; [ $out ]
evals/evals-freenode-#perl.lst[3206]: my $eval = '$2 $1'; my $out = "foo bar" =~ s/(\w+) (\w+)/$eval/er; [ $out ]
evals/evals-freenode-#perl.lst[3207]: my $eval_block_result = eval { die 'blahblah'; 3 }; [ $eval_block_result, $@ ];
evals/evals-freenode-#perl.lst[3208]: my $eval_block_result = eval { die 'blahblah' if 0; 3 }; [ $eval_block_result, $@ ];
evals/evals-freenode-#perl.lst[3209]: my $eval_block_result = eval { die syntax error here if 0; 3 }; [ $eval_block_result, $@ ];
evals/evals-freenode-#perl.lst[3210]: my @example = qw<fail>; $_ = 'test@example.com'; s/\Q$_\E/something/; print;
evals/evals-freenode-#perl.lst[3211]: my @example = qw<fail>; $_ = 'testfail.com'; s/\Qtest@example.com\E/something/; print;
evals/evals-freenode-#perl.lst[3212]: 'my@example' =~ /^(\w+)\@/
evals/evals-freenode-#perl.lst[3213]: 'my@example' =~ /^(\w+)\@/; $1
evals/evals-freenode-#perl.lst[3214]: my $f = 1; my @x = qw( 1 2 3 ); for ( @x ) { if ( $f ) { $f--; push @x, 4; } print; }
evals/evals-freenode-#perl.lst[3215]: my $f = "1welp"; $f ~~ 1;
evals/evals-freenode-#perl.lst[3216]: my $f = "1welp"; my $d = "1"; my $before = $f ~~ $d; my $c = $d + 0; my $after = $f ~~ $d; [$before, $after];
evals/evals-freenode-#perl.lst[3217]: my $fac = 1; $fac *= $_ for (2 .. 10); $fac;
evals/evals-freenode-#perl.lst[3218]: $_ = "my fancy filename.txt"; s/(?<!\.)\b/\U/gr
evals/evals-freenode-#perl.lst[3219]: $_ = "my fancy filename.txt"; s/(?<!\.)\b(\w)/\U$1/gr
evals/evals-freenode-#perl.lst[3220]: my $fh = *STDOUT; print $fh ">implying"; ()
evals/evals-freenode-#perl.lst[3221]: my $field = 'foo'; sub bar { (my $param, $field) = @_; [ $param, $field ] } bar('baz');
evals/evals-freenode-#perl.lst[3222]: my $field = 'foo'; sub bar { (my $param, $field) = @_; print $field } bar('baz');
evals/evals-freenode-#perl.lst[3223]: my @fields = (1..10); my @bits = reverse split //, sprintf '%b', 1890; join ',', map $bits[$_] ? $fields[$_] : (), 0..$#fields
evals/evals-freenode-#perl.lst[3224]: my $file = "blah.pl"; return "Yep" if ($file =~ m#\.pl$#);
evals/evals-freenode-#perl.lst[3225]: my $filename = "foo.jpg."; my @chunks = split /\./, $filename; (@chunks > 1 ? $chunks[-1] : die 'funny shit')
evals/evals-freenode-#perl.lst[3226]: my $filename = "foo\nbar.jpg"; my @chunks = split /\./, $filename; (@chunks > 1 ? $chunks[-1] : die 'funny shit')
evals/evals-freenode-#perl.lst[3227]: my $filename = ".vimrc"; my @chunks = split /\./, $filename; (@chunks > 1 ? $chunks[-1] : die 'funny shit')
evals/evals-freenode-#perl.lst[3228]: my @fill = ("_") x 5; "@fill"
evals/evals-freenode-#perl.lst[3229]: my @fill = ("_") x 5; $fill[0] = 'h'; "@fill"
evals/evals-freenode-#perl.lst[3230]: my @fill = ("_") x 5; $fill[0] = 'h'; $fill[2] = 'l'; $fill[3] = 'l'; "@fill"
evals/evals-freenode-#perl.lst[3231]: my @fill = ("_") x 5; $fill[1] = 'h'; "@fill"
evals/evals-freenode-#perl.lst[3232]: my $final = qw( these comma operators are in scalar context ); $final
evals/evals-freenode-#perl.lst[3233]: my $ foo;
evals/evals-freenode-#perl.lst[3234]: my $foo = 0; [~-$foo, -~$foo]
evals/evals-freenode-#perl.lst[3235]: my $foo = 0; sub test { $_[0]++ } test $foo; $foo
evals/evals-freenode-#perl.lst[3236]: my $foo = 0; sub test { my $bar = $_[0]; $$bar = $$bar + 1 } test \$foo; $foo
evals/evals-freenode-#perl.lst[3237]: my $foo = '[1.1.1.1]'; [$foo =~ /\[(\d{1-3}\.\d{1-3}\.\d{1-3}\.\d{1-3})\]/]
evals/evals-freenode-#perl.lst[3238]: my $foo = '[1.1.1.1]'; [$foo =~ /\[(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\]/]
evals/evals-freenode-#perl.lst[3239]: my $foo = '1.1.1.1'; [$foo =~ /\[(\d{1-3}\.\d{1-3}\.\d{1-3}\.\d{1-3})\]/]
evals/evals-freenode-#perl.lst[3240]: my $foo = '1.1.1.1'; [$foo =~ /\[(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\]/]
evals/evals-freenode-#perl.lst[3241]: my @foo = 1 .. 20; my @bar = (@foo[0..$#foo/2], "a", @foo[10..$#foo]); [@bar]
evals/evals-freenode-#perl.lst[3242]: my @foo = (1,2,3); \@foo
evals/evals-freenode-#perl.lst[3243]: my @foo = (1,2,3); $_++ for @foo; \@foo
evals/evals-freenode-#perl.lst[3244]: my $foo = 123; package Y { print ">$foo<" }
evals/evals-freenode-#perl.lst[3245]: my $foo = \1; my $bar = $$foo; $foo++; $bar;
evals/evals-freenode-#perl.lst[3246]: my $foo = 1; my $foo_bar = 2; "$foo\_bar"
evals/evals-freenode-#perl.lst[3247]: my $foo = 1; sub change_foo { $foo = 2 }; change_foo(); [ $foo ]
evals/evals-freenode-#perl.lst[3248]: my @foo = [1, sub { code; }]; \@foo
evals/evals-freenode-#perl.lst[3249]: my @foo = [1, sub { ... }]; \@foo
evals/evals-freenode-#perl.lst[3250]: my $foo = 1; sub get_foo { return $foo }; [ get_foo() ]
evals/evals-freenode-#perl.lst[3251]: my $foo = 2 ** 20; $foo;
evals/evals-freenode-#perl.lst[3252]: my $foo = 2**32; [~-$foo, -~$foo]
evals/evals-freenode-#perl.lst[3253]: my $foo = 42; my $bar = \$foo; $foo = "hi"; $bar
evals/evals-freenode-#perl.lst[3254]: my $foo = 42; my $bar = \$foo; $foo = "hi"; $$bar
evals/evals-freenode-#perl.lst[3255]: my $foo = + + + + + + + 5;
evals/evals-freenode-#perl.lst[3256]: my $foo = 5.0; [~-$foo, -~$foo]
evals/evals-freenode-#perl.lst[3257]: my $foo = 5 + do { 5 }; [$foo]
evals/evals-freenode-#perl.lst[3258]: my $foo = 5; $ foo;
evals/evals-freenode-#perl.lst[3259]: my $foo = 5; [~-$foo, -~$foo]
evals/evals-freenode-#perl.lst[3260]: my $foo = 5; my $bar = sub { $foo }; $bar->()
evals/evals-freenode-#perl.lst[3261]: my $foo = 5; sub bar { $foo } bar
evals/evals-freenode-#perl.lst[3262]: my $foo = 5; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say 3 }
evals/evals-freenode-#perl.lst[3263]: my $foo = 5; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say 3 } else { say 4 }
evals/evals-freenode-#perl.lst[3264]: my $foo = 7; my $bar = 1; say "blah" if (($foo or $bar) == 1);
evals/evals-freenode-#perl.lst[3265]: my $foo = 7; my $bar = 1; say "blah" if ($foo or $bar) == 1;
evals/evals-freenode-#perl.lst[3266]: my %foo = (a,1,b,2,c,3); join(', ', keys %foo); #for PSGroup53
evals/evals-freenode-#perl.lst[3267]: my %foo = (a,1,b,2,c,3); join(', ', values %foo); #for PSGroup53
evals/evals-freenode-#perl.lst[3268]: my %foo = (a,1,b,2,c,3); keys %foo; #for PSGroup53
evals/evals-freenode-#perl.lst[3269]: my $foo = {a => bar, b => baz}; $moo = "lucky:luke"; $foo = {split ":", $moo}; $foo;
evals/evals-freenode-#perl.lst[3270]: my $foo = 'a b c d'; $foo =~ s/ /\\s+/g; 'a    b    c     d' =~ s/$foo/bar/r
evals/evals-freenode-#perl.lst[3271]: my $foo = 'a b c d'; $foo =~ s/ /\\s+/g; 'a    b    c     d' =~ s/$foo//r
evals/evals-freenode-#perl.lst[3272]: my @foo = (["A","B","C"],["E","F"],["G","H","I","J","K"],["L"]); $#{$foo[0]}
evals/evals-freenode-#perl.lst[3273]: my $foo = ('a', 'b', 'c'); say $foo #this though...
evals/evals-freenode-#perl.lst[3274]: my $foo = "asdf"; open my $fh, '<', \$foo; [<$fh>]
evals/evals-freenode-#perl.lst[3275]: my $foo{bar} = 1
evals/evals-freenode-#perl.lst[3276]: [ my ($foo, $bar) //= (1,2) ]
evals/evals-freenode-#perl.lst[3277]: my $foo = 'bar' and $foo
evals/evals-freenode-#perl.lst[3278]: my($foo,$bar)=('bar','bra ann');$foo x= 5;print $foo.$bar;
evals/evals-freenode-#perl.lst[3279]: my %foo = (bar => 'baz'); my @refs = \(%foo); ${$refs[0]} = 'quux'; [%foo]
evals/evals-freenode-#perl.lst[3280]: my %foo = (bar => 'baz'); my @refs = \(%foo); ${$refs[1]} = 'quux'; [%foo]
evals/evals-freenode-#perl.lst[3281]: [ my ($foo, $bar, $baz) = ('quux') x 3 ]
evals/evals-freenode-#perl.lst[3282]: my $foo = 'ba\'r'; [ "foo '$foo'" ]
evals/evals-freenode-#perl.lst[3283]: my $foo="bar"; for $foo (1..4) {}; $foo
evals/evals-freenode-#perl.lst[3284]: my $foo="bar"; for $foo (1..4) {last}; $foo
evals/evals-freenode-#perl.lst[3285]: my $foo = "bar"; my $baz = sub {$foo; ${"foo"}}; $baz->();
evals/evals-freenode-#perl.lst[3286]: my $foo = "bar"; my $baz = sub {${"foo"}}; print $baz->();
evals/evals-freenode-#perl.lst[3287]: my $foo = "bar"; print $                 foo;
evals/evals-freenode-#perl.lst[3288]: my @foo; defined @foo
evals/evals-freenode-#perl.lst[3289]: my @foo; exists $foo[5][3][7]; [ \@foo ]; ### It also works with arrays.
evals/evals-freenode-#perl.lst[3290]: my @foo; exists $foo[5]{bar}[7]; [ \@foo ]; ### Or a mix of the two.
evals/evals-freenode-#perl.lst[3291]: my %foo; exists $foo{bar}{baz}{quux}{floop}; [ \%foo ]
evals/evals-freenode-#perl.lst[3292]: my @foo; [ $foo[1] != 1 ]
evals/evals-freenode-#perl.lst[3293]: my %foo = foo => 1, bar => 1; sub foo { print join " ", %foo }; foo; { delete local $foo{foo}; foo }; foo;
evals/evals-freenode-#perl.lst[3294]: my %foo = foo => 1; sub foo { print join " ", %foo }; foo; delete local $foo{foo}; foo;
evals/evals-freenode-#perl.lst[3295]: my %foo = (foo => 2, bar => 2); sub foo { print join " ", %foo }; foo; { delete local $foo{foo}; foo }; foo;
evals/evals-freenode-#perl.lst[3296]: my $foo = 'foo bar=baz big="some \"other\" thing" dumb=today'; [split / (?![^"]*?")/, $foo]
evals/evals-freenode-#perl.lst[3297]: my $foo = 'foo bar=baz big="some thing" dumb=today'; [split / (?![^"]*?")/, $foo]
evals/evals-freenode-#perl.lst[3298]: my $foo = 'foo bar=baz big="some thing" dumb=today'; [split / (?![^"]*")/, $foo]
evals/evals-freenode-#perl.lst[3299]: my $foo =()= 'foo bar who owl scoop' =~ /oo/g; [ $foo ];
evals/evals-freenode-#perl.lst[3300]: my @foo; @foo = @foo || (0..2); say "@foo"; @foo = @foo || (5..7); say "@foo"
evals/evals-freenode-#perl.lst[3301]: my $foo = 'foo'; package Bar { my $foo = 'quux'; print $foo; }
evals/evals-freenode-#perl.lst[3302]: my $foo = []; [ "$foo", sprintf('ARRAY(0x%x)', $foo) ]
evals/evals-freenode-#perl.lst[3303]: my $foo = []; [ "$foo", sprintf('ARRAY(%#x)', $foo) ]
evals/evals-freenode-#perl.lst[3304]: my %foo; $foo{zot}="asdf\n"; chomp $foo{zot}; \%foo;
evals/evals-freenode-#perl.lst[3305]: my $foo = "hello"; print "haha " . $foo . " hihi";
evals/evals-freenode-#perl.lst[3306]: my $foo = int 5; [~-$foo, -~$foo]
evals/evals-freenode-#perl.lst[3307]: my $foo = { key => [ 2, 3, 4] }; print @$foo{key}[1]
evals/evals-freenode-#perl.lst[3308]: my $foo = { key => [ 2, 3, 4] }; say @$foo{key}[1]
evals/evals-freenode-#perl.lst[3309]: my $foo = map { 0, 0, 0 } "A", "B", "C", "D"
evals/evals-freenode-#perl.lst[3310]: my $foo = map {; 0, 0, 0 } "A", "B", "C", "D"
evals/evals-freenode-#perl.lst[3311]: my $foo = map { 42 } "A", "B", "C", "D"
evals/evals-freenode-#perl.lst[3312]: my $foo = map { for (()) { } } qw(A B C) if 0;
evals/evals-freenode-#perl.lst[3313]: my $foo = map { if ($_ ne "A") return 0 } "A", "B", "C", "D"
evals/evals-freenode-#perl.lst[3314]: my $foo = map { if ($_ neq "A") 0 } "A", "B", "C", "D"
evals/evals-freenode-#perl.lst[3315]: my $foo = map { $_ ne "A" ? 0 : () } "A", "B", "C", "D"
evals/evals-freenode-#perl.lst[3316]: my $foo; my $bar;  (1 ? $foo : $bar) = "let's see"; [ $foo, $bar ]
evals/evals-freenode-#perl.lst[3317]: my $foo; my $bar = []; [$foo, $bar]
evals/evals-freenode-#perl.lst[3318]: my $foo = []; my $base = 0x400_0000; $base += 8 while $base < $foo; sprintf '%s %#x', $foo, $base
evals/evals-freenode-#perl.lst[3319]: my $foo = []; my %hash = ($foo => 1); my $base = 0x400_0000; $base += 8 until $hash{sprintf 'ARRAY(%#x)', $base}; sprintf "found %#x in %s", $base, join(" ", keys %hash)
evals/evals-freenode-#perl.lst[3320]: my $foo = {}; my $k = "dev/database/url"; my $p = \$foo; for my $n (split m{/}, $k) { $p = \$$p->{$n}; } $$p = 42; $foo
evals/evals-freenode-#perl.lst[3321]: my $foo; my $ref = \$foo; $$ref = 'bar'; [ $foo ]
evals/evals-freenode-#perl.lst[3322]: my $foo; my $ref = \$foo; $ref++; $$ref = '
evals/evals-freenode-#perl.lst[3323]: my $foo; my $ref = \$foo; $ref++; $$ref = 'bar'; [ $foo ]
evals/evals-freenode-#perl.lst[3324]: my ($foo) = "onetwothree" =~ s/(tw.)//g; $foo
evals/evals-freenode-#perl.lst[3325]: my $foo = pack('V31337'); $foo;
evals/evals-freenode-#perl.lst[3326]: my %foo = ('♥' => 'perllove');
evals/evals-freenode-#perl.lst[3327]: my %foo = ('♥' => 'perllove'); say $foo{'♥'};
evals/evals-freenode-#perl.lst[3328]: my $foo; push @{$foo->{bar}{baz}}, 123; $foo
evals/evals-freenode-#perl.lst[3329]: my $foo; push @{$foo{bar}{baz}}, 123; $foo
evals/evals-freenode-#perl.lst[3330]: my $foo = qr/bananas!/; qr/^$foo/
evals/evals-freenode-#perl.lst[3331]: my @foo = qw(1 2 3 4); push(@foo, splice(@foo, 0, 2)); [@foo]
evals/evals-freenode-#perl.lst[3332]: my @foo = qw(1 2 3 4); [ unshift(@foo, splice(@foo, 2, 2)); ]
evals/evals-freenode-#perl.lst[3333]: my @foo = qw(1 2 3 4); unshift(@foo, splice(@foo, 2, 2)); [ @foo ]
evals/evals-freenode-#perl.lst[3334]: my @foo = qw(1 2 3 4); unshift(@foo, splice(@foo, -2)); [ @foo ]
evals/evals-freenode-#perl.lst[3335]: my @foo = qw(a 1 b 2 c 3); open my $printer, '>', \my $buffer; print $printer @foo; [$buffer, "@foo"]
evals/evals-freenode-#perl.lst[3336]: my $foo = [qw/a b c d e/]; [ scalar @$foo ]
evals/evals-freenode-#perl.lst[3337]: my $foo = qw/azertyuiopqsdfghjklmwxcvbn/; $foo =~ s/(.{8})\s.+?/$1/; $foo;
evals/evals-freenode-#perl.lst[3338]: my %foo = qw(foo 1 bar 2 baz 3); @foo{keys %foo} = (); \%foo;
evals/evals-freenode-#perl.lst[3339]: my @foo = qw(foo bar baz); [ \(@foo) ]
evals/evals-freenode-#perl.lst[3340]: my @foo = qw(foo bar baz); [ \@foo ]
evals/evals-freenode-#perl.lst[3341]: my @foo = qw(foo bar baz); \(@foo)
evals/evals-freenode-#perl.lst[3342]: my @foo = qw(foo bar baz); [ \(@foo, 42) ]
evals/evals-freenode-#perl.lst[3343]: my @foo = qw(foo bar baz); (@foo) = (@foo) x 5;
evals/evals-freenode-#perl.lst[3344]: my @foo = qw(foo bar baz); (@foo) x= 5;
evals/evals-freenode-#perl.lst[3345]: my @foo = qw(foo bar baz); [(@foo) x= 5];
evals/evals-freenode-#perl.lst[3346]: my @foo = qw(foo bar baz); [(@foo) x 5];
evals/evals-freenode-#perl.lst[3347]: my %foo = qw(foo bar baz qux kitties nip); my $ref = \%foo; undef %foo; $ref
evals/evals-freenode-#perl.lst[3348]: my @foo = qw(milk nip kitties meow); my @slice = @foo[2,3,2,1]; \@slice
evals/evals-freenode-#perl.lst[3349]: my @foo = split /\s+/, "foo bar"; [ [ @foo[0,0] ], [ @foo[0,1] ], [ @foo[1,1] ] ]
evals/evals-freenode-#perl.lst[3350]: my $foo; sub bar { print "[$foo]"; } for $foo ("hello") { bar; }
evals/evals-freenode-#perl.lst[3351]: my %foo; sub foo { print join " ", %foo }; foo; local $foo{foo} = foo; foo;
evals/evals-freenode-#perl.lst[3352]: my %foo; sub foo { print join(" ", %foo }; foo; local $foo{foo} = foo; foo;
evals/evals-freenode-#perl.lst[3353]: { my $foo; sub plusfoo { $foo++ } sub getfoo { $foo } } plusfoo(); getfoo()
evals/evals-freenode-#perl.lst[3354]: my $foo = sub { return $foo };
evals/evals-freenode-#perl.lst[3355]: my $foo = sub { shift }; [ map $foo->($_), 1, 2, 3 ]
evals/evals-freenode-#perl.lst[3356]: my $foo = sub { shift }; [ map $foo, 1, 2, 3 ]
evals/evals-freenode-#perl.lst[3357]: my $foo = sub { shift }; [ map &$foo, 1, 2, 3 ]
evals/evals-freenode-#perl.lst[3358]: my $foo = "test\x{327}"; $foo =~ tr/\x{327}/\x{326}/; [$foo]
evals/evals-freenode-#perl.lst[3359]: (my $foo:)//= undef
evals/evals-freenode-#perl.lst[3360]: my $foo ://= undef;
evals/evals-freenode-#perl.lst[3361]: my $foo //= undef;
evals/evals-freenode-#perl.lst[3362]: my $foo = undef; [ @$foo ]
evals/evals-freenode-#perl.lst[3363]: my $foo = undef // say "it broke!"; [ $foo ]
evals/evals-freenode-#perl.lst[3364]: my $found = 0; 0+($found == 7) # you pass a zero to exit, it will happily use that value
evals/evals-freenode-#perl.lst[3365]: my $f = "s/l/y/g;s/k/x/g"; my $s = "lk\n"; $s = do { local $_ = $s; eval($f); $_ }; printf("%s", $s)
evals/evals-freenode-#perl.lst[3366]: my $f = sub { [] }; @a = map { 0+ $f->($_) } 1..10;
evals/evals-freenode-#perl.lst[3367]: my $f = sub { [] }; @a = map { 0+ $f->($_) } 1..10; \@a
evals/evals-freenode-#perl.lst[3368]: my $f = sub { [] }; @a = map { refaddr $f->($_) } 1..10;
evals/evals-freenode-#perl.lst[3369]: my $f = sub { SUB: my ($n) = @_; print "$n "; $n or return; @_ = $n - 1; goto SUB; }; $f->(5);
evals/evals-freenode-#perl.lst[3370]: $_ = "my.funny-str is a string"; [ [split /(?=[. -])/], [split /[. -]/]
evals/evals-freenode-#perl.lst[3371]: $_ = "my.funny-str is a string"; [ [split /(?=[. -])/], [split /[. -]/]]
evals/evals-freenode-#perl.lst[3372]: my $gf = sub { (1..50) }; my $ev = sub { $_ % 2 == 0 }; print join ",", grep { $ev->($_) }  $gf->()
evals/evals-freenode-#perl.lst[3373]: (my $good_stuff, my $throw_away) = split(“=“, $stuff);  # for comparison
evals/evals-freenode-#perl.lst[3374]: my @groups; my $chunk = []; for my $x ("foo", "bar", "baz\n", "x", "y", "z") { push @$chunk, $x; if ($x =~ /\R\z/) { push @groups, $chunk; $chunk = []; } } push @$groups, $chunk if @$chunk; [ @groups ]
evals/evals-freenode-#perl.lst[3375]: my @groups; my $chunk = []; for my $x ("foo", "bar", "baz\n", "x", "y", "z") { push @$chunk, $x; if ($x =~ /\R\z) { push @groups, $chunk; $chunk = []; } } push @$groups, $chunk if @$chunk; [ @groups ]
evals/evals-freenode-#perl.lst[3376]: my $h = {}; [ {}, {} ]
evals/evals-freenode-#perl.lst[3377]: my $h = '09:12:34'; $h =~ s/0(\d)(?=(?::\d\d){2})/$1/r;
evals/evals-freenode-#perl.lst[3378]: my $h = '09'; [ $h, 0+$h ];
evals/evals-freenode-#perl.lst[3379]: my %h = (a => 1); ++$_ for keys %h;
evals/evals-freenode-#perl.lst[3380]: my %h = (a = 1); ++$_ for keys %h;
evals/evals-freenode-#perl.lst[3381]: my %h = (a => 1); ++$_ for keys %h; \%h;
evals/evals-freenode-#perl.lst[3382]: my %h = (a => 1); ++$_ for values %h; \%h;
evals/evals-freenode-#perl.lst[3383]: my %hash = ( 1 => '', 2 => '', 1 => '');  \%hash
evals/evals-freenode-#perl.lst[3384]: my %hash = (1 => 2, 3 => 4); my $out=''; while (my ($key, $val) = each %hash) { $out .= join ' ', keys %hash } $out
evals/evals-freenode-#perl.lst[3385]: my $hash = { a=>1, b=>2 }; delete $hash->{(keys %{$hash})[0]}
evals/evals-freenode-#perl.lst[3386]: my $hash = { a=>1, b=>2 }; delete $hash{(keys %{$hash})[0]}
evals/evals-freenode-#perl.lst[3387]: my %hash = (a => 1, b => 2); mySub(%hash); sub mySub { my (%hash) = @_; warn join ', ', %hash }
evals/evals-freenode-#perl.lst[3388]: my %hash = (a => 1, b => 2); mySub(%hash); sub mySub { my (%h) = @_; warn $h{a} }
evals/evals-freenode-#perl.lst[3389]: my %hash = ( abc => 'def', asdf => 'jkl;' ); print join ' ', @hash{abc,asdf}
evals/evals-freenode-#perl.lst[3390]: my %hash = ( abc => 'def', asdf => 'jkl;' ); print join ' ', @hash{abc,def}
evals/evals-freenode-#perl.lst[3391]: my %hash; bless \%hash, "SomeClass";  ref \%hash;   # <== tm604: *technically* it's the referrant itself, and not the reference
evals/evals-freenode-#perl.lst[3392]: my %hash; bless \%hash, "SomeClass";  ref \%somehash;   # <== tm604: *technically* it's the referrant itself, and not the reference
evals/evals-freenode-#perl.lst[3393]: my %hash = (foo => !!1); $hash{foo} = 1
evals/evals-freenode-#perl.lst[3394]: my %hash = (foo => [ 4 ]); $ hash { 'foo' } [ 0 ]
evals/evals-freenode-#perl.lst[3395]: my %hash = (foo => "bar", baz => "bra"); use JSON::XS; encode_json \%hash
evals/evals-freenode-#perl.lst[3396]: my %hash = (foo => 'bar'); (%hash)[1]
evals/evals-freenode-#perl.lst[3397]: my %hash = (foo => 'bar'); (values %hash)[0];
evals/evals-freenode-#perl.lst[3398]: my @hash = %hash; print @hash
evals/evals-freenode-#perl.lst[3399]: my %hash; if ($hash{foo} eq $hash{bar}) { print "OMG" }
evals/evals-freenode-#perl.lst[3400]: my %hash; keys %hash = 200; $hash{abc} = 1; [scalar %hash]
evals/evals-freenode-#perl.lst[3401]: my %hash; my @array1 = qw/ 1 2 3 4 /; my @array2 = qw/ 3 4 5 /;    @hash{@array1,@array2} = ();   my @combined = sort keys %hash;    [ @combined ]
evals/evals-freenode-#perl.lst[3402]: my %hash; my %dash = (qw/a 1 b 2/); [ scalar %hash, scalar %dash ]
evals/evals-freenode-#perl.lst[3403]: my %hash; my $prior = ""; for my $new (1..1000) { ++$hash{$new}; print "$new\n" if $prior ne join " ", grep $_ != $new, keys %hash; $prior = join " ", keys %hash }
evals/evals-freenode-#perl.lst[3404]: my %hash; my $str = "foo:12 bar:34 baz:45"; @hash{'foo', 'bar', 'baz'} = $str =~ /foo:(\d+) bar:(\d+) baz:(\d+)/; \%hash
evals/evals-freenode-#perl.lst[3405]: my %hash; my $val1 = $hash{a}; my $val2 = $hash{b} if exists $hash{b}; [keys %hash]
evals/evals-freenode-#perl.lst[3406]: my %hash = (one => [1, 2, 4]);
evals/evals-freenode-#perl.lst[3407]: my %hash = (one => [1, 2, 4]); sub bar { 	my $href = shift @_; 	push @{$href->{one}}, 5; } bar(\%hash); @{$hash{one}};
evals/evals-freenode-#perl.lst[3408]: my %hash = (one => [1, 2, 4]); sub bar { 	my $href = shift @_; 	push @{$href->{one}}, 5; } bar(\%hash); print @{$hash{one}};
evals/evals-freenode-#perl.lst[3409]: my $hash = {one=>1,two=>2,three=>2}; [ grep $_ == 2, values %$hash ]
evals/evals-freenode-#perl.lst[3410]: my $hash = {one=>1,two=>2,three=>2};[  %{$hash}{ grep $hash->{$_} == 2, keys %$hash } ] # mauke's version is much neater unless you really wanted this
evals/evals-freenode-#perl.lst[3411]: my $hash = {one=>1,two=>2,three=>2};[  @{$hash}{ grep $hash->{$_} == 2, keys %$hash } ] # then as huf said, use something like this. seems a bit pointless though
evals/evals-freenode-#perl.lst[3412]: my %hash = ( one => 1, two => 2, three => 3 );  [ %hash{qw(one two)} ]
evals/evals-freenode-#perl.lst[3413]: my %hash = ( one => 1, two => 2, three => 3 );  [ %hash{qw(one, two)} ]
evals/evals-freenode-#perl.lst[3414]: my %hash = (one => 'foo'); sub bar { my ($href) = @_; $href->{one} = 'baz'; } bar(\%hash);  [ %hash ]
evals/evals-freenode-#perl.lst[3415]: my %hash = (one => 'foo'); sub bar { my $href = @_; $href->{one} = 'baz'; } bar(\%hash);  [ %hash ]
evals/evals-freenode-#perl.lst[3416]: my %hash = (one => two, three => four); say for keys %hash;
evals/evals-freenode-#perl.lst[3417]: my %hash = one => two, three => four; say for keys %hash;
evals/evals-freenode-#perl.lst[3418]: my %hash; push @{$hash{foo}}, 3; \%hash
evals/evals-freenode-#perl.lst[3419]: @{\my %hash}{qw(a b)} = (1, 2); \%hash
evals/evals-freenode-#perl.lst[3420]: my $hash = {ref => [1, 2, 3]}; while(my $num = $hash->{ref}->CORE::each) {print $num, " => ";}
evals/evals-freenode-#perl.lst[3421]: my $hashref = { 20001 => {} }; my ($key) = %$hashref; $key
evals/evals-freenode-#perl.lst[3422]: my $hashref = { 20001 => {} }; my ($key) = %$hr; $key
evals/evals-freenode-#perl.lst[3423]: my $hash_ref = { 'foo' => 'bar' }; $hash_ref{'foo'};
evals/evals-freenode-#perl.lst[3424]: my $hashref = { foo => 'bar' }; my $doesntwork = $#$hashref;
evals/evals-freenode-#perl.lst[3425]: my $hash_ref = {'one' => 'falcom', 'two' => 'rindolf'}; my $d = { %$hash_ref, 'three' => "Isaac Newton"}; [$d]
evals/evals-freenode-#perl.lst[3426]: my %hash; scalar %hash
evals/evals-freenode-#perl.lst[3427]: my %hash = (thing => SOME_CONSTANT() ); sub SOME_CONSTANT { 5 }; $hash{thing}
evals/evals-freenode-#perl.lst[3428]: my %hash = (thing => SOME_CONSTANT); sub SOME_CONSTANT { 5 }; $hash{thing}
evals/evals-freenode-#perl.lst[3429]: my %hash = (x=>123); %hash = (); \%hash
evals/evals-freenode-#perl.lst[3430]: my %h = (a..z); ${%h}{"how strange"} = "is this, anyway?"; \%{%h};
evals/evals-freenode-#perl.lst[3431]: my %h = (a..z); ${%h}{"ignore the man"} = "behind the curtain"; print scalar %h; undef $h{$_} for 1..20; print scalar %h;
evals/evals-freenode-#perl.lst[3432]: my %h = (a..z); ${%h}{"ignore the man"} = "behind the curtain"; undef $h{$_} for 1..20; \%{%h};
evals/evals-freenode-#perl.lst[3433]: my %hb = (a => 'bleh', b => 'bluh'); my %ha = (a => 'woo', x => 'y', %hb); \%ha;
evals/evals-freenode-#perl.lst[3434]: my @headers = qw(foo bar ibytes pickles);
evals/evals-freenode-#perl.lst[3435]: my @headers = qw(hits bytes ihits ibytes ips);
evals/evals-freenode-#perl.lst[3436]: my %h = (); exists $h{foo}->{bar}; print exists $h{foo}
evals/evals-freenode-#perl.lst[3437]: my $hex = q{6060FF}; [ hex($hex), [ unpack q{L>*}, pack q{H*}, map { sprintf q{%08s}, $_; } ( $hex =~ s!^0x!!r) =~ m!(^.{2,6}|.{2,8})!g ] ]; ### How to do what hex() does with pack/unpack. Is there a cleaner / less-hackier way?
evals/evals-freenode-#perl.lst[3438]: my $hex = q{6060FF}; [ hex($hex), [ unpack q{L>*}, pack q{H*}, map { sprintf q{%08s}, $_; } ( $hex =~ s!^0x!!r) =~ m!(^.{2,6}|.{2,8})!g ] ]; How to do what hex() does with pack/unpack. Is there a cleaner / less-hackier way?
evals/evals-freenode-#perl.lst[3439]: my $hex = q{6060FF}; [ hex($hex), [ unpack q{N*}, pack q{(h8)*}, $hex ] ];
evals/evals-freenode-#perl.lst[3440]: my $hex = q{6060FF}; [ hex($hex), [ unpack q{N*}, pack q{(H8)*}, $hex ] ];
evals/evals-freenode-#perl.lst[3441]: my $hex = q{6060FF}; [ hex($hex), [ unpack q{N}, pack q{H8}, q{6060FF} ] ] # How to do the equivilent of hex() with pack/unpack functions?
evals/evals-freenode-#perl.lst[3442]: my $hex = q{6060FF}; [ hex($hex), [ unpack q{N}, pack q{H*}, q{6060FF} ] ] # with H* it is only three bytes and apparently rejected by V/N/I/L
evals/evals-freenode-#perl.lst[3443]: my $hex = q{6060FF}; [ hex($hex), [ unpack q{V*}, pack q{(h8)*}, $hex ] ];
evals/evals-freenode-#perl.lst[3444]: my $hex = q{6060FF}; [ hex($hex), [ unpack q{V*}, pack q{(H8)*}, $hex ] ];
evals/evals-freenode-#perl.lst[3445]: my $hex = unpack("H*", pack("Q<", 1397463445)); my $td = pack("H*", unpack("Q<",$hex)); $td;
evals/evals-freenode-#perl.lst[3446]: my $h = { foo => 42 }; $h == \%{$h}
evals/evals-freenode-#perl.lst[3447]: my %h = ( foo => { bar => {ber => [boor] } } ); my $ar = $h{foo}{bar}{ber}; push @$ar, 'foor';  \%h
evals/evals-freenode-#perl.lst[3448]: my $h = {}; [ "$h" ]
evals/evals-freenode-#perl.lst[3449]: my %h = +{}; \%h
evals/evals-freenode-#perl.lst[3450]:  my %h; @h{(20..34)} = (); [(sort keys %h)[0..10]];
evals/evals-freenode-#perl.lst[3451]: my %h=(); %h=( 'a'=>'1', 'b'=>'2' ); %h=( 'c'=>'3', 'd'=>'4' ); for ( sort keys %h ){ print "$_ $h{$_}" };
evals/evals-freenode-#perl.lst[3452]: my %h; @{ $h{a}{b} } = qw/c d e/; \%h
evals/evals-freenode-#perl.lst[3453]: my $h = "Hello world!"; $h =~ s/(.)(.)/$2$1/g; $h
evals/evals-freenode-#perl.lst[3454]: my $h = "Hello world!"; $h =~ s/(.)(.)/\U$2\E$1/g; $h
evals/evals-freenode-#perl.lst[3455]: my %h=(); %h=getone(); sub getone {return ('a'=>'1','b'=>'2')}; %h=gettwo(); sub gettwo { return('c'=>'3','d'=>'4')}; for ( sort keys %h ){ print "$_ $h{$_}" };
evals/evals-freenode-#perl.lst[3456]: my %h=(); %h=getone(); sub getone {return ('a'=>'1','b'=>'2')}; %h=gettwo(); sub gettwo { return undef}; for ( sort keys %h ){ print "[$_] $h{$_}" }
evals/evals-freenode-#perl.lst[3457]: my %h=(); %h=getone(); sub getone {return ('a'=>'1','b'=>'2')}; %h=gettwo(); sub gettwo { return undef}; for ( sort keys %h ){ print "$_ $h{$_}" }
evals/evals-freenode-#perl.lst[3458]: my %h=(); %h=getone(); sub getone {return ('a'=>'1','b'=>'2')}; %h=gettwo(); sub gettwo { return undef}; for ( sort keys %h ){ print "$_ $h{$_}" };
evals/evals-freenode-#perl.lst[3459]: my $h = {}; [ $h, $h ]
evals/evals-freenode-#perl.lst[3460]: my %h=(); %h=(%h, 'a'=>'1', 'b'=>'2' ); %h=(%h, 'c'=>'3', 'd'=>'4' ); for ( sort keys %h ){ print "$_ $h{$_}" };
evals/evals-freenode-#perl.lst[3461]: my $h; $h->{key}[2]{anotherkey} = "hello"; $h
evals/evals-freenode-#perl.lst[3462]: my %h=(); %h={return ('a'=>'1','b'=>'2')}; %h={ return('c'=>'3','d'=>'4')}; for ( sort keys %h ){ print "$_ $h{$_}" };
evals/evals-freenode-#perl.lst[3463]: my %h; $h{two} = sub { \%h }; $h{two}->()->{two}->()
evals/evals-freenode-#perl.lst[3464]: my %h; $h{x}{y}{z} = 123; \%h # sure
evals/evals-freenode-#perl.lst[3465]: my %h = (map { $_ => 2*$_ } 1 .. 10); [ %h{3,5,8} ]
evals/evals-freenode-#perl.lst[3466]: my %h = (map { $_ => 3*$_  } 1.. 10); { %h{(1,4,6)} }
evals/evals-freenode-#perl.lst[3467]: my %h = (map { $_ => 3*$_  } 1.. 10); +{ %h{(1,4,6)} }
evals/evals-freenode-#perl.lst[3468]: my %h; my $p = \%h; $p = $p->{$_} //= {} for qw/foo bar bizbaz/; $p->{cats} = 1; [ \%h ]
evals/evals-freenode-#perl.lst[3469]: my %h = (one => [1,2,4]); sub bar { my ($href) = @_; push ${$href->{one}}, 5; } bar(\%h); @{$h{one}}
evals/evals-freenode-#perl.lst[3470]: my %h = ( one => 1, two => 2 ); [ %h{qw( one three )} ]
evals/evals-freenode-#perl.lst[3471]: my %h = qw/foo bar baz ber/; say $h{foo}; my $x = 'baz'; say $h{$x}
evals/evals-freenode-#perl.lst[3472]: my %h = qw(must 1 should 2 could 3); [ sort {$h{$a} <=> $h{$b}} qw(must should could could must could should must) ]
evals/evals-freenode-#perl.lst[3473]: my $hr = {a => 5}; my @arr; push @arr, %$hr; my %hash = @arr; \%hash
evals/evals-freenode-#perl.lst[3474]: my $hr = {a => 5}; my %hash; $hash{hashref}=$hr; $hash{hashref}{a}
evals/evals-freenode-#perl.lst[3475]: my $hr = { asdf => 5 }; (%$hr)[1]
evals/evals-freenode-#perl.lst[3476]: my $hr = { asdf => 5 }; (values %$hr)[0]
evals/evals-freenode-#perl.lst[3477]: my $href = { foo => 42, bar => 37 }; keys %$href - 3
evals/evals-freenode-#perl.lst[3478]: my $href = { foo => 42, bar => 37 }; keys(%$href) - 3
evals/evals-freenode-#perl.lst[3479]: my $href; %$href
evals/evals-freenode-#perl.lst[3480]: my $href; $href->{key} = {}; my $other = $href->{key}; $other->{bar} = 1; $href
evals/evals-freenode-#perl.lst[3481]: my $href; my $other = $href->{key} ||= {}; $other->{bar} = 1; $href
evals/evals-freenode-#perl.lst[3482]: my $hr = {searchable => {phones => "bullshit"}}; unless ($hr->{searchable}->%*) { "Empty" } else { "not empty" };
evals/evals-freenode-#perl.lst[3483]: my $hr = {searchable => {}}; unless ($hr->{searchable}->%*) { "Empty" } else { "not empty" };
evals/evals-freenode-#perl.lst[3484]: my $html = "<html><body><div>and stuff</div></body></html>"; $html->find
evals/evals-freenode-#perl.lst[3485]: my $hw = "Hello World!\n"; print $hw;
evals/evals-freenode-#perl.lst[3486]: my %h = (x => "abc123", y => "def456"); map { tr/a-z//dc } values %h; \%h
evals/evals-freenode-#perl.lst[3487]: my %h = (x => "abc123", y => "def456"); tr/a-z//dc for values %h; \%h # are you trying to do something like this
evals/evals-freenode-#perl.lst[3488]: my $i = 0; HERE: { HERE: { HERE: { HERE: goto HERE unless $i++ > 3 } } }  print $i
evals/evals-freenode-#perl.lst[3489]: my $i = 0; while ( $i <= 10) { print; $i++; } print $_;
evals/evals-freenode-#perl.lst[3490]: my $i = 0; while ( $i <= 10) { print; } print $_;
evals/evals-freenode-#perl.lst[3491]: my $i = 5; ++$i++
evals/evals-freenode-#perl.lst[3492]: my @ids = $page_content =~ m!http://www\.liveleak\.com/view\?i=(\w{14})!g;
evals/evals-freenode-#perl.lst[3493]: my $idx = 0; my @group; push @{$group[/\R$/ ? $idx++ : $idx]}, $_ for  "foo", "bar", "baz\n", "x", "y", "z"; \@group # something like that?
evals/evals-freenode-#perl.lst[3494]: my $imagecount = ""; my $foo = "%0" . length $imagecount . "d";
evals/evals-freenode-#perl.lst[3495]: my $i; { my $foo; sub get_foo { $foo //= $i++ } } [get_foo, get_foo, get_foo]
evals/evals-freenode-#perl.lst[3496]: my @in = 1..3; my @out = grep { $_++ } @in; [ \@in, \@out ] # far as I recall, List::UtilsBy has an explicit local $_ = $_; to avoid this sort of behaviour, so presumably ::XS doesn't have an equivalent
evals/evals-freenode-#perl.lst[3497]: my $indents = () = "        " =~ /(\t|\s{4})/g
evals/evals-freenode-#perl.lst[3498]: my @index; $_ = "  * *    * ** "; while(/\G[^*]*\*/gc) { push @index, pos } \@index
evals/evals-freenode-#perl.lst[3499]: my $ind = index(fc 'test string', fc 'STRING'); $ind;
evals/evals-freenode-#perl.lst[3500]: my $ind = index('test string', 'STRING'); $ind;
evals/evals-freenode-#perl.lst[3501]: my $input = '٣'; say $input + 42;
evals/evals-freenode-#perl.lst[3502]: my @input = map pack('H2', $_), qw(02 02 01 11 48 85 03 86 11 FB FF 42 01 00 00 08 00 00 00 00 00 00 00 86); [ join ' ', map sprintf("%08x", unpack('N1', $_)), join('', @input) =~ /..../g ] # you're asking for this?
evals/evals-freenode-#perl.lst[3503]: my $input = "Number 123 here won't be matched, but <number 666, the number of the beast> will."; my $match_mode = 0; while ($input =~ /(\d+)|(<)|(>)/g) { if ($1 and $match_mode) { print $1; } if ($2) { $match_mode = 1; } if ($3) { $match_mode = 0; }}
evals/evals-freenode-#perl.lst[3504]: my $input = "Number 666 will match, but not <number 123 here>, ok?"; my $match_mode = 1; while ($input =~ /(\d+)|(<)|(>)/g) { if ($1 and $match_mode) { print $1; } if ($2) { $match_mode = 0; } if ($3) { $match_mode = 1; }}
evals/evals-freenode-#perl.lst[3505]: my $ip = '127.0.0.1'; $ip =~ s#(\d+)#unpack( "H*", pack( "V1",$1))#ge; $ip
evals/evals-freenode-#perl.lst[3506]: my $ip = '127.0.0.1'; $ip =~ s#(\d+)#unpack( "H*", pack( "V1",$1))#ge; $ip =~ s#.##g; $ip
evals/evals-freenode-#perl.lst[3507]: my $ip = '127.0.0.1'; $ip =~ s#(\d+)#unpack( "H*", pack( "V1",$1))#ge; $ip =~ s#.#g; $ip
evals/evals-freenode-#perl.lst[3508]: my $ip = '127.0.0.1'; $ip =~ s#(\d+).?#unpack( "H*", pack( "v",$1))#ge; $ip
evals/evals-freenode-#perl.lst[3509]: my $i; sub get_foo { state $foo = $i++ } [get_foo, get_foo, get_foo]
evals/evals-freenode-#perl.lst[3510]: my $karma = 27; sub mst :() :lvalue { $karma } mst++; $karma
evals/evals-freenode-#perl.lst[3511]: my $karma = 27; sub mst :lvalue { $karma } mst++; $karma
evals/evals-freenode-#perl.lst[3512]: my $karma = 27; sub mst() :lvalue { $karma } mst++; $karma
evals/evals-freenode-#perl.lst[3513]: my $karma = 27; sub mst :lvalue { $karma } mst()++; $karma # actually, might just be this?
evals/evals-freenode-#perl.lst[3514]: my $key = 'a'; $hash{$key} = 'foo'; print $hash{$key};
evals/evals-freenode-#perl.lst[3515]: my @keys = (1..10); ++$_ for @keys; \@keys
evals/evals-freenode-#perl.lst[3516]: my $L = 2**32; join "", reverse split //, ((reverse $L) =~ s/(\d{3})/$1,/rg);
evals/evals-freenode-#perl.lst[3517]: my $L = 2**32; local $\ = ','; print for reverse unpack '(A3)*', scalar reverse $L
evals/evals-freenode-#perl.lst[3518]: my $L = 2**32; local $\ = ','; print reverse unpack '(A3)*', scalar reverse $L
evals/evals-freenode-#perl.lst[3519]: my $L = 2**32; $L =~ s/(?<=\d)(?=(?:\d{3})+(?!\d))/,/rg
evals/evals-freenode-#perl.lst[3520]: my $L = 2**32; $L =~ s/\d\K(?=(?:\d{3})+(?!\d))/,/rg
evals/evals-freenode-#perl.lst[3521]: my $l = 2**32; my $s = join "", reverse split //, $l; $s =~ s/(\d{3})/$1,/g; join "", reverse split //, $s
evals/evals-freenode-#perl.lst[3522]: my $L = 2**32; reverse reverse($L) =~ s/(\d{3})/$1,/rg
evals/evals-freenode-#perl.lst[3523]: my $L = 2**32; scalar reverse join ',', unpack '(A3)*', scalar reverse $L
evals/evals-freenode-#perl.lst[3524]: my $l = 4; "stuff" . ( $l + 1 );
evals/evals-freenode-#perl.lst[3525]: my $l = 4; "stuff" . $l + 1;
evals/evals-freenode-#perl.lst[3526]: my $lambda = sub { shift()+1 }; @a=1..4; [{map{$_=>$lambda->($_)}@a[0..@a/2-1]},{map{$_=>$lambda->($_)}@a[@a/2..$#a]}]
evals/evals-freenode-#perl.lst[3527]: my $last; [ map { $last = $_ // $last } ( 123, 456, undef, undef, undef ) ]
evals/evals-freenode-#perl.lst[3528]: my $last; [ map { $last = $_ // $last } qw[ 123, 456, undef, undef, undef ] ]
evals/evals-freenode-#perl.lst[3529]: my $lengths = { mach => 5 }; "%-$lengths->{mach}s" # you want this, right?
evals/evals-freenode-#perl.lst[3530]: my $line = "COMP2711|3713452|Warren, Ahmad|3645/2|M"; $line =~ s/\|(.+), (.+)\|/$2$1/; print $line;
evals/evals-freenode-#perl.lst[3531]: my $line = "COMP2711|3713452|Warren, Ahmad|3645/2|M"; print $line;
evals/evals-freenode-#perl.lst[3532]: my $line = "if answer > 0: answer = answer + 2"; if(0) { } elsif($line =~ /^\s*if (.*): (.*)/) { print "1 => $1, 2 => $2" }
evals/evals-freenode-#perl.lst[3533]: my $line = "take cat";  my ( $verb, @others ) = split m/\s+/, $line;  "The verb is <$verb> and the other arguments are <@others>"
evals/evals-freenode-#perl.lst[3534]: my @list = map do { my $x = $_; sub { 3 * $x } }, qw(2 4 6); [ map $_->(), @list ] # sometimes putting the closure inside do {} can make the intention clearer
evals/evals-freenode-#perl.lst[3535]: my @list = qw(foo bar foo baz kitties meow); 3 + @list
evals/evals-freenode-#perl.lst[3536]: my @list = qw(foo bar foo baz kitties meow); my %hash = @list; \%hash
evals/evals-freenode-#perl.lst[3537]: my @l = qw/2 4 6/; my @f; for ( my $i=0; $i<@l; $i++ ) { my $x = $l[$i]; push @f, sub { 3 * $x; }; } [ map { $_->(); } @f ];
evals/evals-freenode-#perl.lst[3538]: my @l = qw/2 4 6/; my @f; for ( my $i=0; $i<@l; $i++ ) { push @f, sub { 3 * $l[$i]; }; } [ map { $_->(); } @f ];
evals/evals-freenode-#perl.lst[3539]: my @l = qw(foo1 foo2 foo3); my $foo1 = \ $l[0]; $$foo1 = 'some foo1 string'; \@l
evals/evals-freenode-#perl.lst[3540]: my %map = (param1 => 'cats', param2 => 'botje'); my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \{ ([^{]+) \}/push @params, $2; $1 . 's'/gex; printf $str, map {$map{$_}} @params
evals/evals-freenode-#perl.lst[3541]: my ($mapped, $grepped); map { $mapped = wantarray } 1; grep { $grepped = wantarray } 1; [$mapped, $grepped]
evals/evals-freenode-#perl.lst[3542]: my %map = ('\t' => "\t", '\r' => "\r", '\n' => "\n"); my $x = q{FOO\tBAR\r\n}; my $y = s/(\\[trn])/$map{$1}/ge; [$x, $y]
evals/evals-freenode-#perl.lst[3543]: my %map = ('\t' => "\t", '\r' => "\r", '\n' => "\n"); my $x = q{FOO\tBAR\r\n}; my $y = s/(\\[trn])/$map{$1}/gre; [$x, $y]
evals/evals-freenode-#perl.lst[3544]: my %map = ('\t' => "\t", '\r' => "\r", '\n' => "\n"); my $x = q{FOO\tBAR\r\n}; my $y = $x =~ s/(\\[trn])/$map{$1}/gre; [$x, $y]
evals/evals-freenode-#perl.lst[3545]: my @matches = "foobarbaz" =~ /(ba.)/g; \@matches
evals/evals-freenode-#perl.lst[3546]: my $meth = sub { 'here' }; main->$meth
evals/evals-freenode-#perl.lst[3547]: my $meth = sub { 'here' }; notmain->$meth
evals/evals-freenode-#perl.lst[3548]: my $meth = sub { 'here' }; undef->$meth
evals/evals-freenode-#perl.lst[3549]: my @m; push @m, $1 ? [ digit => $1 ] : [ space => $2 ] while "foo 3 5 1 7 bar" =~ m/(\d+)|(\s+)/g; \@m
evals/evals-freenode-#perl.lst[3550]: my $my->{my}
evals/evals-freenode-#perl.lst[3551]: my (my (my $delilah))
evals/evals-freenode-#perl.lst[3552]: my My $my :Delilah;
evals/evals-freenode-#perl.lst[3553]: my (my $x)
evals/evals-freenode-#perl.lst[3554]: my $n = 0; while(1){print $n." "; $n = $n+1;}
evals/evals-freenode-#perl.lst[3555]: my $n = 0; while($n < 99999){print $n." "; $n = $n+1;}
evals/evals-freenode-#perl.lst[3556]: my $n = 20; my $t = 0; my @c; while ($n) { push @c, 1 << $t if $n & 1; $n >>= 1; $t++; } \@c
evals/evals-freenode-#perl.lst[3557]: my $n = 3; my $str = q(|1|2a|3abc|4abcd|5abcde); [join q(|), (split /\|/, $str)[0..$n]];
evals/evals-freenode-#perl.lst[3558]: my $name = "nonconvergent"; my $s = "Hello $name - what's up?"; [$s]
evals/evals-freenode-#perl.lst[3559]: my @names = qw(one two three); my @numbers = qw(1 2 3); for(0..$#numbers) { print $numbers[$_] . ' - ' . $names[$_] if $numbers[$_] == 2} # one option is to iterate by index rather than element
evals/evals-freenode-#perl.lst[3560]: my $name = 'xx.xx.xx.xx'; $name =~ s/\./_/g; $name
evals/evals-freenode-#perl.lst[3561]: my %notes = qw/0 C 2 D/; [ @notes{0,2} ]
evals/evals-freenode-#perl.lst[3562]: my $not_really_an_array = ("a", "b"); $not_really_an_array # no arrays here
evals/evals-freenode-#perl.lst[3563]: my $now = Time::Moment->now;  $now->with_hour(op)->with_minute(0)->with_second(0);
evals/evals-freenode-#perl.lst[3564]: my $n=split(/\|/,"one|two|three|four");
evals/evals-freenode-#perl.lst[3565]: 'my $num = 10; my  $res = ($num > 15 and $num < 30) ? "Num is out of range" : "Num is in range"; print $res ."\n";'
evals/evals-freenode-#perl.lst[3566]: my $num = 10; my  $res = ($num > 15 and $num < 30) ? "Num is out of range" : "Num is in range"; print $res ."\n";
evals/evals-freenode-#perl.lst[3567]: my $num = 42; my @array = (1, 2, DateTime->now); $num ~~ @array
evals/evals-freenode-#perl.lst[3568]: my $num = 42; my @array = (1, 2, qr/2$/); $num ~~ @array
evals/evals-freenode-#perl.lst[3569]: my $num = 42; my @array = (1, 2, sub { die "wat" }); $num ~~ @array
evals/evals-freenode-#perl.lst[3570]: my $num = 50; my $bitstring = unpack 'b*', $num;
evals/evals-freenode-#perl.lst[3571]: my $num = 50; my $bitstring = unpack 'B*', $num;
evals/evals-freenode-#perl.lst[3572]: my $num = "99839489327429485246"; $num =~ tr/89/01/; oct $num
evals/evals-freenode-#perl.lst[3573]: my $number = grep { $_ == 2 } (1, 2, 2, 2, 3); $number
evals/evals-freenode-#perl.lst[3574]: my $obj = "azertyu iopqsdfghjklmwxcvbn"; $obj =~ s/(.{8})\s.+?/$1/; $obj;
evals/evals-freenode-#perl.lst[3575]: my $obj = "azertyui opqsdfghjklmwxcvbn"; $obj =~ s/(.{8})\s.+?/$1/; $obj;
evals/evals-freenode-#perl.lst[3576]: my $obj = "azertyui opqsdfghjklmwxcvbn"; $obj =~ s/(.{8})\s[^\n]+/$1/; [$obj;]
evals/evals-freenode-#perl.lst[3577]: my $obj = "azertyui opqsdfghjklmwxcvbn"; $obj =~ s/(.{8})\s[^\n]+/$1/; [$obj]
evals/evals-freenode-#perl.lst[3578]: my $obj = bless {};  ($a, $b, $c) = ($obj) x 3; [$a, $b, $c]
evals/evals-freenode-#perl.lst[3579]: my %old = (1..10); +{ %old{1,5,7} }
evals/evals-freenode-#perl.lst[3580]: my %old_hash = (1 => 2, 3 => undef); my %new_hash = reverse %old_hash; \%new_hash
evals/evals-freenode-#perl.lst[3581]: my %old_hash = (1 => 2, 3 => undef); my %new_hash = reverse %old_hash; %new_hash
evals/evals-freenode-#perl.lst[3582]: my $one = "1"; my $two = $one + "0 but true"; [ $one ^ $one ];
evals/evals-freenode-#perl.lst[3583]: my $one = 1; my $two = $one . " used as a string?"; [ $one ^ $one ];
evals/evals-freenode-#perl.lst[3584]: my $one = "1"; [ $one ^ $one ];
evals/evals-freenode-#perl.lst[3585]: my $one = 1; [ $one ^ $one ];
evals/evals-freenode-#perl.lst[3586]: my @one = qw(1 2 3); @one = (); my @two; @two = (); [ (defined(@one) ? 'defined' : 'undef'), (defined(@two) ? 'defined' : 'undef') ]
evals/evals-freenode-#perl.lst[3587]: my $optional = 1; my $alternative = 1; print (["", "Optional.", "Alternative.", "Optional and alternative."]->[($alternative ? 2 : 0) + ($optional ? 1 : 0)])
evals/evals-freenode-#perl.lst[3588]: my $orig = 'abcdef'; my $str = $orig =~ s/(cde)//r; my $removed = $1; [$orig, $str, $removed]
evals/evals-freenode-#perl.lst[3589]: my $orig = $SIG{__WARN__}; local $SIG{__WARN__} = sub { my $warn = shift; $warn =~ s/ at /!!!/g; local $SIG{__WARN__} = $orig; warn $warn }; warn 'lemmings' # could just double-local it
evals/evals-freenode-#perl.lst[3590]: my (our $x);
evals/evals-freenode-#perl.lst[3591]: my @out; { local our @tmp; 'abcdefghi' =~ /c(?:(.)(?{ local @tmp = (@tmp, $^N) })){4}(?{ @out = @tmp })/ or die } \@out
evals/evals-freenode-#perl.lst[3592]: my @out; { local our @tmp; 'abcdefghi' =~ / (?:(.)(?{ local @tmp = (@tmp, $^N) })){4}(?{ @out = @tmp }) (?= $ ) /x or die } \@out
evals/evals-freenode-#perl.lst[3593]: my @out; { my $tmp = []; 'abcdefghi' =~ /c(?:(.)(?{ local @$tmp = (@$tmp, $^N) })){4}(?{ @out = @$tmp })/ or die } \@out
evals/evals-freenode-#perl.lst[3594]: my @out; { our @tmp; 'abcdefghi' =~ /c(?:(.)(?{ local @tmp = (@tmp, $^N) })){4}(?{ @out = @tmp })/ or die } \@out
evals/evals-freenode-#perl.lst[3595]: my @packets = qw(foo=ba r=baz= quux =teeen); my @chunks; my $prev = ''; for my $part (@packets) { my @pieces = split /=/, $part, -1; $pieces[0] = $prev . $pieces[0]; $prev = pop @pieces; push @chunks, @pieces; } push @chunks, $prev; \@chunks
evals/evals-freenode-#perl.lst[3596]: my $p = \&CORE::print; $p->("foo")
evals/evals-freenode-#perl.lst[3597]: my $pi = atan2(0, -1); my $x = $pi; [ $pi, map { $x *= 1e10; ($x - int $x)*1e10;  } 1..10 ]
evals/evals-freenode-#perl.lst[3598]: my $pi = atan2(0, -1); $pi *= 1e10; [ int $pi, $pi - int $pi ]
evals/evals-freenode-#perl.lst[3599]: my $pi = atan2(0, -1); $pi *= 1e20; [ int $pi, $pi - int $pi ]
evals/evals-freenode-#perl.lst[3600]: my %pool = (param0 => 'a', param1 => 'b'); [ map { $pool{$_} } 'param1', 'param0' ]
evals/evals-freenode-#perl.lst[3601]: my %pool = (param0 => 'a', param1 => 'b'); [ @pool{'param1', 'param0'} ]
evals/evals-freenode-#perl.lst[3602]: my %pool = qw(param0 altreus param1 cats); my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \{ ([^{]+) \}/push @params, $pool{$2}; $1 . 's'/gex; printf $str, @params
evals/evals-freenode-#perl.lst[3603]: my %pool = qw(param0 altreus param1 cats); my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \{ ([^{]+) \}/push @params, $pool{"param$2"}; $1 . 's'/gex; printf $str, @params
evals/evals-freenode-#perl.lst[3604]: my $pos = 3; my $ref = '1'; my $seq = [qw(a b c d e f g h i j)]; join '', @{$seq}[($pos - 1)..(($pos-2) + length($ref))] # off by 2, I think?
evals/evals-freenode-#perl.lst[3605]: my $p = "(part1).*(part2)"; "foopart1barpart2" =~ /$p/; print "$1 $2";
evals/evals-freenode-#perl.lst[3606]: my $prev; for my $cur ("A" .. "D") { print "($prev $cur) "; } continue { $prev = $cur; }
evals/evals-freenode-#perl.lst[3607]: my $_ = q,asdf "foo"='bar baz',; my $h = 0x20000; my %h; s/((["'])(?:[^"']+|\\.|(?!\2).)*\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split ' '; $h = chr($h-1); s/([\x{20000}-$h])/$h{$1}/g for @words; \@words;
evals/evals-freenode-#perl.lst[3608]: my $_ = q, echo foo bar=baz hmm="1 2 3" nn='aa bb',; my $h = 0x20000; my %h; s/((["'])(?:[^"']+|\\.|(?!\2).)*\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split /\s+/; $h = chr($h-1); s/([\x{20000}-$h])/$h{$1}/g for @words; \@words;
evals/evals-freenode-#perl.lst[3609]: my qw( $foo ); $foo = 123; $foo; ### Why does this not work?
evals/evals-freenode-#perl.lst[3610]: my $r = bless [], "HASH";  ref $r
evals/evals-freenode-#perl.lst[3611]: my @rc; my @vals = ('a','b','c'); (0 ? @rc : $rc[0]) = @vals; \@rc
evals/evals-freenode-#perl.lst[3612]: my @rc; my @vals = ('a','b','c'); 0 ? @rc : $rc[0] = @vals; \@rc
evals/evals-freenode-#perl.lst[3613]: my @rc; my @vals = ('a','b','c'); (1 ? @rc : $rc[0]) = @vals; \@rc
evals/evals-freenode-#perl.lst[3614]: my @rcolors = ("red", "orange", "color green"); my $count = 0; for (@rcolors) { last if /color green/; } continue { $count++; } $count; # seems unlikely
evals/evals-freenode-#perl.lst[3615]: my $r = \&CORE::ref; $r->([])
evals/evals-freenode-#perl.lst[3616]: my $readfromfile = '[x'; my $re = eval { qr/$readfromfile/; 1 } or die 'failed'; [ $re ]
evals/evals-freenode-#perl.lst[3617]: my $re = 'asdf'; ['asdfasdf' =~ /^\Q$re\E.*$/]
evals/evals-freenode-#perl.lst[3618]: my $re = 'asdf\E.*'; ['asdfasdf' =~ /^\Q$re$/]
evals/evals-freenode-#perl.lst[3619]: my $records = { foo => "bar", baz => "quux" }; s/./moo/g for values %$records; $records
evals/evals-freenode-#perl.lst[3620]: my $recurse = sub { ref ? __SUB__->($_) : say for values $_[0] }; $recurse->({x => 123, y => [qw(a b c)]}) # this
evals/evals-freenode-#perl.lst[3621]: my ($red, $green, $blue) = (100, 100, 100); sprintf '#%02x%02x%02x', $red, $green, $blue;
evals/evals-freenode-#perl.lst[3622]: my $ref = [1,2,3,4]; for my $item (@$ref) { print $item, "\n" }
evals/evals-freenode-#perl.lst[3623]: my $ref = [1,2,3]; push @{$ref}, "hi"; $ref
evals/evals-freenode-#perl.lst[3624]: my $ref = { 1 => foo => 2 => bar => 3 => baz => 4 => quux => 5 => 'floop' }; %{ $ref } = %{ $ref }{ (reverse sort keys %$ref)[0 .. 2] }; $ref # joobie
evals/evals-freenode-#perl.lst[3625]: my $ref = \42; ${$ref} = "hi";
evals/evals-freenode-#perl.lst[3626]: my $ref = [[8],[9],[10]]; @{$ref}[0,1,2]->[0]
evals/evals-freenode-#perl.lst[3627]: my $ref = [[8],[9],[10]]; @{$ref}[0,1,2][0]
evals/evals-freenode-#perl.lst[3628]: my $ref = do { \ my $foo; }; ref $ref
evals/evals-freenode-#perl.lst[3629]: my $ref = \&foo; $ref->(21);  sub foo { $_[0] * 2 }
evals/evals-freenode-#perl.lst[3630]: my $refName = [ 'one', 'two', 'three', 'four', 'five' ];  my @slice = (1,3);  my @values = @{$refName}[@slice];  \@values
evals/evals-freenode-#perl.lst[3631]: my $refName = [ 'one', 'two', 'three', 'four', 'five' ];  my @values = @{$refName}[1,3];  \@values
evals/evals-freenode-#perl.lst[3632]: my $ref = [ qw/ a b c / ]; [ @{ $ref }[1,2] ]
evals/evals-freenode-#perl.lst[3633]: my $ref = [qw/foo bar baz/]; for $i (keys $ref) { print "$i "; }
evals/evals-freenode-#perl.lst[3634]: my $re = "motd \\^(.*)"; [ map /$re/, 'motd ^something' ] # vs. /motd \^/
evals/evals-freenode-#perl.lst[3635]: my @replacements = (['foo', 'bar', 'baz'], ['quux']); $replacements[0][0]
evals/evals-freenode-#perl.lst[3636]: my $re = '/projects/test/(.*)'; [ "/projects/test/vkAuth?code=edb31139a2f04d22a8" =~ $re ]
evals/evals-freenode-#perl.lst[3637]: my $re = '/projects/(\w+)/(.*)'; [ "/projects/test/vkAuth?code=edb31139a2f04d22a8" =~ $re ]
evals/evals-freenode-#perl.lst[3638]: my $re = '/projects/(\w+)/test/(.*)'; [ "projects/test/vkAuth?code=edb31139a2f04d22a8" =~ $re ]
evals/evals-freenode-#perl.lst[3639]: my $reps = 0; my $start = time; 1 while $start==time;++$start; { my $y = index( pack('C*', map rand(128), 1..1e5), "\\x" ); ++$reps; redo if $start == time }; [ $reps ]
evals/evals-freenode-#perl.lst[3640]: my $reps = 0; my $start = time; 1 while $start==time;++$start; { my $y = pack('C*', map rand(128), 1..1e5) =~ m/\\x/ ); ++$reps; redo if $start == time }; [ $reps ]
evals/evals-freenode-#perl.lst[3641]: my $reps = 0; my $start = time; 1 while $start==time;++$start; { pack('C*', map rand(128), 1..1e5) =~ m/\\x/; ++$reps; redo if $start == time }; [ $reps ]
evals/evals-freenode-#perl.lst[3642]: my $reps = 0; my $start = time; { my $y = index( pack('C*', map rand(128), 1..1e5), "\\x" ); ++$reps; redo if $start == time }; [ $reps ]
evals/evals-freenode-#perl.lst[3643]: my $re = qr/[[]/
evals/evals-freenode-#perl.lst[3644]: my $re = qr/ blah \n | \n blah1 \n | \n yada/x; print "Failed\n" if 'testing' =~ $re
evals/evals-freenode-#perl.lst[3645]: my $re = qr/^To: .*helpme\@mydomain.com/; 'To: Some person<helpme@mydomain.com> lalala' =~ $re ? "Match" : "No match"
evals/evals-freenode-#perl.lst[3646]: my $re = qr/(?<!x)(x+)(??{ my $len = length $1; "y{$len}" })(?!y)/; [ map { scalar $_ =~ $re } qw(xxyy xxy xyy) ]
evals/evals-freenode-#perl.lst[3647]: my @res = map { chomp; $_ if (-f $_) } qw(dupes.txt allfiles.bak.txt hahaha.setnhue); print join(' ', @res) . "\n";
evals/evals-freenode-#perl.lst[3648]: my ($result) = "a numeric example: 42" =~ /(\d+)/; $result # note the lack of \
evals/evals-freenode-#perl.lst[3649]: my $result = do { "my string" for 1 .. 8 };  [$result]
evals/evals-freenode-#perl.lst[3650]: my $result = do { "my string" for 1 .. 8 };  $result
evals/evals-freenode-#perl.lst[3651]: my $result; if (0) { $result = "if"; } elsif (1) { $result = "elsif"; } else { $result = "else"; } [$result]
evals/evals-freenode-#perl.lst[3652]: my $result = sprintf '%.28f', '1.43531262539073e-11'; { local $/ = '0'; 1 while chomp($result) } $result # let perl work it out
evals/evals-freenode-#perl.lst[3653]:  my $result = sub { my $str = "foo:12 bar:34 baz:45"; $str =~ /foo:(?<foo>\d+) bar:(?<bar>\d+) baz:(?<baz>\d+)/; return \%+ }->(); 'x: 78' =~ /\w+: (?<whatevs>\d+)/; +{ %$result } # yeah, you'll just get the results from whichever regex is in the current scope
evals/evals-freenode-#perl.lst[3654]: my $ret = my ($x, $y) = 1..10; [ $ret, $x, $y ];
evals/evals-freenode-#perl.lst[3655]: my $ret = my ($x, $y) = 9..19; [ $ret, $x, $y ];
evals/evals-freenode-#perl.lst[3656]: my $ret = my ($x, $y, @z) = 9..19; [ $ret, $x, $y, \@z ]; # For those wondering, the right way to grab the rest of the elements.
evals/evals-freenode-#perl.lst[3657]: my $ret = my @z = my ($x, $y) = 9..19; [ $ret, $x, $y, \@z ];
evals/evals-freenode-#perl.lst[3658]: my $return = print "hello, here is my message";   $return
evals/evals-freenode-#perl.lst[3659]: my @rocks = qw (granite rubble lava slate); [ grep { $rocks[$_] =~ /a/ } 0..$#rocks ]
evals/evals-freenode-#perl.lst[3660]: my %roman; sub r :lvalue { $roman{$_[0]} }  ( r("I"), r("II"), r("III"), r("IV"), r("V") ) = 1..5;  \%roman
evals/evals-freenode-#perl.lst[3661]: my %s = (1,2,3,4,5,6); my $pre = %s; delete @s{keys %s}; [$pre, scalar %s]
evals/evals-freenode-#perl.lst[3662]: my %s = (1,2,3,4,5,6); %s+1
evals/evals-freenode-#perl.lst[3663]: my %s = (1,2,3,4,5,6); scalar keys %s
evals/evals-freenode-#perl.lst[3664]: my %s = (1,2,3,4,5,6); [ scalar %s, 0+%s, 0+keys %s ]
evals/evals-freenode-#perl.lst[3665]: my %s = (1,2,3,4,5,6); [ scalar %s, 1+%s, 0+keys %s ]
evals/evals-freenode-#perl.lst[3666]: my $s = "1,2,3,4,5"; join "-", split ",", $s, 3;
evals/evals-freenode-#perl.lst[3667]: my $s1 = q#([A-Z]+)# ; my $s2 = q#([a-z]+)#; my @foo = ("HELLO-hi" =~ /$s1-$s2/); [@foo]
evals/evals-freenode-#perl.lst[3668]: my ($s1, $s2) = qw/abc abx/; my $prefix = ($s1 ^ $s2) =~ /\A(\0*)/ ? substr($s1, 0, length $1) : ''; $prefix
evals/evals-freenode-#perl.lst[3669]: my $s = "3 5 1 7 ";  my @m = $s =~ /^(?:(\d)(\s))+$/g; \@m;
evals/evals-freenode-#perl.lst[3670]: my $s = "3 5 1 7 ";  my @m = $s =~ /^(?:(\d)(\s))+$/; \@m;
evals/evals-freenode-#perl.lst[3671]: my $s = "aabaaaaaaaaaaaab"; @x = /(a++b)/; [@x]
evals/evals-freenode-#perl.lst[3672]: my $s = "abcdefghijklmnopqrstuvwxyz"; $s =~ tr/a-e/A-E/; [$s]
evals/evals-freenode-#perl.lst[3673]: my $s = 'ABC'; $s =~ s/([A-Za-z])/join '', map chr(ord ^ 32), split '', $1/ge; $s   # pretty, portable, uses s//, what's not to like?
evals/evals-freenode-#perl.lst[3674]: my $s = "A#B"; $s =~ s/[#]//; [ $s ]
evals/evals-freenode-#perl.lst[3675]: my $scalar = [1,2,3]; "$scalar"
evals/evals-freenode-#perl.lst[3676]: my $scalar = [1,2,3]; $scalar
evals/evals-freenode-#perl.lst[3677]: my $scalar_ref = \\\1; $$$$scalar_ref
evals/evals-freenode-#perl.lst[3678]: my $search = "hot chicks"; $search =~ tr/ /%20/; print $search
evals/evals-freenode-#perl.lst[3679]: my $search = "hot chicks"; $search =~ tr/hot/123/; print $search
evals/evals-freenode-#perl.lst[3680]: my $search = "hot chicks"; $search =~ tr/ /+/; print $search
evals/evals-freenode-#perl.lst[3681]: my $search_path = "ILMT::HIN::PAN"; [ grep /^${search_path}::[^:]+$/, "ILMT::HIN::PAN::UTF2WX" ]
evals/evals-freenode-#perl.lst[3682]: my $search_path = "ILMT::HIN::PAN"; [ grep /^${search_path}::[^:]+$/, "ILMT::HIN::PAN::UTF2WX::UTF2WX" ]
evals/evals-freenode-#perl.lst[3683]: my $sec=3982; strftime '%H:%M:%S', gmtime $sec # slightly less typing, also less control over formatting
evals/evals-freenode-#perl.lst[3684]: my %seen; my $i = 0; $seen{$_} = ++$i for 'one','two','three'; \%seen
evals/evals-freenode-#perl.lst[3685]: my %seen; my $i = 0; $seen{''} = ++$i; \%seen
evals/evals-freenode-#perl.lst[3686]: my %seen; $seen{''} = 123; print $seen{''};
evals/evals-freenode-#perl.lst[3687]: my %seen; $seen{foo} // 1; \%seen
evals/evals-freenode-#perl.lst[3688]: my %seen; $seen{foo}; $seen{bar}; \%seen
evals/evals-freenode-#perl.lst[3689]: my %seen; $seen{''} //= keys(%seen)+1; print $seen{''}."\n";
evals/evals-freenode-#perl.lst[3690]: my %seen; $test="one"; $seen{$test} //= keys(%seen)+1; print $seen{$test};
evals/evals-freenode-#perl.lst[3691]: my %seen; $test="one"; $seen{$test} //= keys(%seen); print $seen{$test};
evals/evals-freenode-#perl.lst[3692]: my %seen; $test="one"; $seen{$test} = [keys(%seen)]; \%seen
evals/evals-freenode-#perl.lst[3693]: my %seen; $test="one"; $seen{$test} //= [keys(%seen)]; \%seen
evals/evals-freenode-#perl.lst[3694]: my ( $self ) = @_;
evals/evals-freenode-#perl.lst[3695]: my ( $self ) = $_;
evals/evals-freenode-#perl.lst[3696]: my $self = bless {}; $self->goats();
evals/evals-freenode-#perl.lst[3697]: my $self = +{}; $self->{messages} = [1,2,3]; $self->{messages}->[0] = "a"; $self->{messages}
evals/evals-freenode-#perl.lst[3698]: my $sentence = " I saw the the router."; [$sentence =~ /([a-zA-Z]+)\s+\1/]
evals/evals-freenode-#perl.lst[3699]: my @sets_list1 = (4,5,6); [ (map [ $_ ], @sets_list1), (map [ @sets_list1[0..$_] ], -1..$#sets_list1) ];
evals/evals-freenode-#perl.lst[3700]: my $s = "foo 3 5 1 7 bar";  my @m = $s =~ /(?:(\d)(\s))/g; \@m;
evals/evals-freenode-#perl.lst[3701]: my $s = "foo 3 5 1 7 bar";  my @m = $s =~ /(\d)(\s)/g; \@m;
evals/evals-freenode-#perl.lst[3702]: my $s = "foo 3 5 1 7 bar";  my @m = $s =~ /(?:(\d)(\s))/g; \@m;  # JQKP
evals/evals-freenode-#perl.lst[3703]: my $s = "foo 3 5 1 7 bar";  my @m = $s =~ /(?:(\d)(\s))/g; \@m; # wasn't your earlier example already capturing what you wanted?
evals/evals-freenode-#perl.lst[3704]: my $s = "foo 3 5 1 7 bar";  my @m = $s =~ /(?:(\d)(\s))/g; say join "|", @m;  # JQKP
evals/evals-freenode-#perl.lst[3705]: my $s = "foo\r\nbar\r\nbaz\r\n"; $s =~ s/\R(?=.)//g; [ $s ];
evals/evals-freenode-#perl.lst[3706]:  my ($sha) = split(' ', readpipe("sha1sum", $filename));
evals/evals-freenode-#perl.lst[3707]: my $s = "Hello (hey) My name is (rindolf)."; $s =~ s/\([^)]*\)//g; [$s]
evals/evals-freenode-#perl.lst[3708]: my $s = "Hello.label"; if (my ($m) = $s =~ /^(.*)\.label$/) { print "Matched <$m>\n"; }
evals/evals-freenode-#perl.lst[3709]: my $s = "Hello" [ref($s)]
evals/evals-freenode-#perl.lst[3710]: my $s = "Hello"; [ref($s)]
evals/evals-freenode-#perl.lst[3711]: my $s = "Hello"; [($s eq "Good" or "Way")]
evals/evals-freenode-#perl.lst[3712]: my $s = "Hello"; $s .= " rrman!"; [$s]
evals/evals-freenode-#perl.lst[3713]: my $s = "      Hello"; $s =~ s/^\s//; [$s]
evals/evals-freenode-#perl.lst[3714]: my $s = "      Hello"; $s =~ s/^\s+//; [$s]
evals/evals-freenode-#perl.lst[3715]: my $s = "hello world <120423424> one two three"; $s =~ s/\A((?:\S+\s+){2})<([0-9]+)>/$1$2/; [$s]
evals/evals-freenode-#perl.lst[3716]: my $s = "hello world <120423424> one two three"; $s =~ s/\A(?:\S+\s+){2}\K<([0-9]+)>/$1/; [$s]
evals/evals-freenode-#perl.lst[3717]: my $s = "Hello World"; $s=~ /Wor/; [$`]
evals/evals-freenode-#perl.lst[3718]: my %sieve; my @primes = (2,3); my ($p_i, $p, $q, $n)=(1,3,9,3); push @primes, do { { $n += 2; if ( my $s = delete $sieve{$n} ) { push @{$sieve{$n + $_}}, $_ for @$s; redo } elsif ( $n < $q ) { $n } else { push @{$sieve{$q + $p*2}}, $p * 2; $p = $primes[++$p_i]; $q = $p*$p; redo } } } until @primes >= 1000; \%sieve;
evals/evals-freenode-#perl.lst[3719]: my %sieve; my @primes = (2,3); my ($p_i, $p, $q, $n)=(1,3,9,3); push @primes, do { { $n += 2; if ( my $s = delete $sieve{$n} ) { push @{$sieve{$n + $_}}, $_ for @$s; redo } elsif ( $n < $q ) { $n } else { push @{$sieve{$q + $p*2}}, $p * 2; $p = $primes[++$p_i]; $q = $p*$p; redo } } } until @primes >= 100; \@primes;
evals/evals-freenode-#perl.lst[3720]: my %sieve; my @primes = (2,3); my ($p_i, $p, $q, $n)=(1,3,9,3); push @primes, do { { $n += 2; if ( my $s = delete $sieve{$n} ) { push @{$sieve{$n + $_}}, $_ for @$s; redo } elsif ( $n < $q ) { $n } else { push @{$sieve{$q + $p*2}}, $p * 2; $p = $primes[++$p_i]; $q = $p*$p; redo } } } until @primes >= 100; \%sieve;
evals/evals-freenode-#perl.lst[3721]: my $s = "llama"; [ map { substr($s, $_).substr($s, 0, $_) } 0..4 ]
evals/evals-freenode-#perl.lst[3722]: my $s; my $c = sub { warn $s }; for $s (1,2,3) { $c->(); }
evals/evals-freenode-#perl.lst[3723]: my @some_array = qw/0 1 2 3 4 5 6 7 8 9 10/; my (@primes, $zero) = @some_array[2,3,5,7,0]; print "@primes%"; print !defined $zero;
evals/evals-freenode-#perl.lst[3724]: my $s = "<One> Two <Three> Four <Five>"; [$s =~ /<([^>]+)>/g]
evals/evals-freenode-#perl.lst[3725]: my $s = "one.two.three"; my $count = $s =~ tr/././; [$count]
evals/evals-freenode-#perl.lst[3726]: my $space = 15; printf("... %-${space}s => %s", "foo", "bar");
evals/evals-freenode-#perl.lst[3727]: my $space = 15; printf("... %${space}s => %s", "foo", "bar");
evals/evals-freenode-#perl.lst[3728]: my $space = 15; printf("... %s%${space}s => %s", "foo", "", "bar");
evals/evals-freenode-#perl.lst[3729]: my $s = q{abc}; [ $s =~ /(?:abc(foo|bar|baz)|)/ ]; # anno, seems it does returns undef.
evals/evals-freenode-#perl.lst[3730]: my $s = q{abc}; [ $s =~ /(?:abc(foo|bar|baz)|)/ # anno, seems it does returns undef.
evals/evals-freenode-#perl.lst[3731]: my $s = q{foo=bar=baz}; my $p = qr/=(.*?)=/; my $r = q{,$1,}; $s =~ s/$p/$r/re;
evals/evals-freenode-#perl.lst[3732]: my $s = q{foo=bar=baz}; my $p = qr/=(.*?)=/; my $r = q{,$1,}; $s =~ s/$p/$r/ree;
evals/evals-freenode-#perl.lst[3733]: my $s = q{foo=bar=baz}; my $p = qr/=(.*?)=/; my $r = q{",$1,"}; $s =~ s/$p/$r/ree
evals/evals-freenode-#perl.lst[3734]: my $s = q{foo=bar=baz}; my $p = qr/=/; my $r = ','; $s = s/$p/$r/;
evals/evals-freenode-#perl.lst[3735]: my $s = q{foo=bar=baz}; my $p = qr/=/; my $r = ','; $s = s/$p/$r/r;
evals/evals-freenode-#perl.lst[3736]: my $s = q{foo=bar=baz}; my $p = qr/=/; my $r = ','; $s =~ s/$p/$r/rg;
evals/evals-freenode-#perl.lst[3737]: my sql $db: cool cool
evals/evals-freenode-#perl.lst[3738]: my $s = qq{ 0xFF }; [ 0+$s ];
evals/evals-freenode-#perl.lst[3739]: my $s = qq{ 1234.5 }; [ 0+$s ];
evals/evals-freenode-#perl.lst[3740]: my $s = qq{Hello "World"!}; [$s]
evals/evals-freenode-#perl.lst[3741]: my $s = 'some text'; my $f = 's/x/s/g; s/o/a/g;'; eval $f for $s; $s # if you want to limit the scope... why is there a string eval involved anyway
evals/evals-freenode-#perl.lst[3742]: my $_ = "☃"; s/(.)/sprintf('\\u%04x', ord "$1")/ger
evals/evals-freenode-#perl.lst[3743]: my $s = sub { "x${_}y" }; join '-', map $s->(), 1..3;
evals/evals-freenode-#perl.lst[3744]: my (state $foo)
evals/evals-freenode-#perl.lst[3745]: { my $state_var sub function_that_uses_state_var { ... } }
evals/evals-freenode-#perl.lst[3746]: { my $state_var; sub function_that_uses_state_var { ...; } }
evals/evals-freenode-#perl.lst[3747]: my $str = "001.html"; my @pats = (qr/^\d\d\d\.html/); print "fail" unless $str ~~ @pats;
evals/evals-freenode-#perl.lst[3748]: my $str = "001.html"; my @pats = (qr/\d\d\d\.html/); print "fail" unless $str ~~ @pats;
evals/evals-freenode-#perl.lst[3749]: my $str = "001.html"; my @pats = (qr/\d\d\d\.html); print "fail" unless $str ~~ @pats;
evals/evals-freenode-#perl.lst[3750]: my $str = "001.html"; my $re = qr/^\d\d\d\.html/;  $str =~ /$re/ ? "ok" : "fail"
evals/evals-freenode-#perl.lst[3751]: my $str = "\0"; [ $str ]
evals/evals-freenode-#perl.lst[3752]: my $str = '123456'; substr $str, -2, 0, ','; $str
evals/evals-freenode-#perl.lst[3753]: my $str = "123AG3GCAT422TG3"; my @groups = $str =~ m/(\d+|[[:alpha:]]{2})/g; \@groups
evals/evals-freenode-#perl.lst[3754]: my $str = "13month"; my ($N, $dep) = $str =~ m/(\d+)(\w+)/; print "$N; $dep"
evals/evals-freenode-#perl.lst[3755]: my $str = "#     18       0     18      0 Chunk     17:25:25 17:25:25 2    arabidopsis_thaliana_core_28_81_10.analysis_description"; [split /\s+/, $str]
evals/evals-freenode-#perl.lst[3756]: my $str = "\23\53\52"; $str # Grinnz_
evals/evals-freenode-#perl.lst[3757]: my $str = "\\23\\53\\52"; $str =~ s/\\(\d\d)/chr $1/eg; $str
evals/evals-freenode-#perl.lst[3758]: my $str = "\23\53\52"; $str =~ s/\\(\d\d)/chr $1/eg; $str
evals/evals-freenode-#perl.lst[3759]: my $str = "\\23\\53\\52"; $str =~ s/\\(\d\d)/chr oct $1/eg; $str
evals/evals-freenode-#perl.lst[3760]: my $str = '2 4 8 16'; my $match = '(\d+)'; my $subst = '$1 / 2'; $str =~ s/$match/$subst/ge; $str
evals/evals-freenode-#perl.lst[3761]: my $str = "4 8 16 7"; $str =~ s{(\d+)}{$1 / 2}ge; print $str
evals/evals-freenode-#perl.lst[3762]: my $str = "aabbcc"; $str =~ s/((\w)\1)/ $1 /g; $str
evals/evals-freenode-#perl.lst[3763]: my $str = "aabbcc"; $str =~ s/(\w)\1/ $& /g;
evals/evals-freenode-#perl.lst[3764]: my $str = "aabbcc"; $str =~ s/(\w)\1/ $& /g; $str
evals/evals-freenode-#perl.lst[3765]: my $str = "aabbcc"; $str =~ s/((\w)\2)/ $1 /g; $str
evals/evals-freenode-#perl.lst[3766]: my $str = "a b c d e f g h i j h k l"; [ (split " ", $str)[2,5-8,10] ]
evals/evals-freenode-#perl.lst[3767]: my $str = "a b c d e f g h i j h k l"; [ (split " ", $str)[2,5..8,10] ]
evals/evals-freenode-#perl.lst[3768]: my $str = 'abcdefghijklmnopqrstuvwxyz'; [ join '', split /(.)../, $str ] # depends on how you define 'easiest'
evals/evals-freenode-#perl.lst[3769]: my $str = 'abcdefghijklmnopqrstuvwxyz'; join '', $str =~ /..(.)/g
evals/evals-freenode-#perl.lst[3770]: my $str = 'abcdefghijklmnopqrstuvwxyz'; $str =~ s/..(.)/$1/gr
evals/evals-freenode-#perl.lst[3771]: my $str = 'abc def'; [ $str =~ m/^(\w*)/ ]
evals/evals-freenode-#perl.lst[3772]: my $str = 'abc def'; [ $str =~ m/^(\w*)/; ]
evals/evals-freenode-#perl.lst[3773]: my $str = 'abcdef'; $str =~ s/(cde)//; my $removed = $1; $removed
evals/evals-freenode-#perl.lst[3774]: my $str = 'abcdef'; $str =~ s/(cde)//; my $removed = $1; [$str, $removed]
evals/evals-freenode-#perl.lst[3775]: my $str = 'abc def'; [ $str =~ /^(\w*)/; ]
evals/evals-freenode-#perl.lst[3776]: my $str = 'abc def'; [ $_ =~ /^(\w*)/; ]
evals/evals-freenode-#perl.lst[3777]: my $str = "a_b_c_d"; my $newstr = $str =~ s/_[^_]*$//r; print $str, $newstr
evals/evals-freenode-#perl.lst[3778]: my $str = 'abcd'; substr($str, 2, 2).substr($str, 0, 2)
evals/evals-freenode-#perl.lst[3779]: my $str = "abc"; my $len = length $str; my $copy = $str; my @rslt; for(1..2**$len-1) { my $idx = 0; do { substr($copy, $idx, 1) ^= " " } until substr($copy, $idx, 1) eq uc substr($str, $idx++, 1); push @rslt, $copy } \@rslt
evals/evals-freenode-#perl.lst[3780]: my $str = "Anna: barbara (>= 0.6.16), cindy (>= 0.6.16), deborah (>= 2.7), ellen (= 1.5.3-5+deb7u1), fiona (>= 1.4.2), greta (>= 1.4.0)"; my @girls = $str =~ /\b([a-z]+)\b/ig; [@girls]
evals/evals-freenode-#perl.lst[3781]: my $str = "Äö"; [ $str =~ /([[:upper:]])/ ]
evals/evals-freenode-#perl.lst[3782]: my $str = '{ awf wv qwea vwev eaga }END'; return "woot" if ($str =~ m#^{.*}END$#);
evals/evals-freenode-#perl.lst[3783]: my $str = "Buyer information:vivek jena"; my ($first, $second) = $str =~ /:(\w+)\s+(\w+)/; [$first, $second]
evals/evals-freenode-#perl.lst[3784]: my $str = '{f.43.fq34.gf.34gfeg.ea.greags sdfasfd sd {} s{S}D F{SA}D{ FSA}D{ }},'; my ($return) = $str =~ m#^({.*?}).*#; $return
evals/evals-freenode-#perl.lst[3785]: my $str = "foo:12 bar:34 baz:45"; $str =~ /foo:(?<foo>\d+) bar:(?<bar>\d+) baz:(?<baz>\d+)/; \%+
evals/evals-freenode-#perl.lst[3786]: my $str = "foo:12 bar:34 baz:45"; $str =~ /foo:(?<foo>\d+) bar:(?<bar>\d+) baz:(?<baz>\d+)/; +{ %+ }
evals/evals-freenode-#perl.lst[3787]: my $str = "foo:12 bar:34 baz:45"; $str =~ /foo:(?<foo>\d+) bar:(?<bar>\d+) baz:(?<baz>\d+)/; $+{foo}
evals/evals-freenode-#perl.lst[3788]: my $str = "foo:12 bar:34 baz:45"; $str =~ /foo:(?<foo>\d+) bar:(?<bar>\d+) baz:(?<baz>\d+)/; [ keys %+ ]
evals/evals-freenode-#perl.lst[3789]: my $str = "foo:12 bar:34 baz:45"; $str =~ /foo:(?<foo>\d+) bar:(?<bar>\d+) baz:(?<baz>\d+)/; { %+{keys %+} }
evals/evals-freenode-#perl.lst[3790]: my $str = "foo:12 bar:34 baz:45"; $str =~ /foo:(?<foo>\d+) bar:(?<bar>\d+) baz:(?<baz>\d+)/; +{ %+{keys %+} }
evals/evals-freenode-#perl.lst[3791]: my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \{ ([^{]+) \}/push @params, $2; $1 . @params/gex; { str => $str, params => \@params }
evals/evals-freenode-#perl.lst[3792]: my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \{ ([^{]+) \}/push @params, $2; $1 . 's'/gex; printf $str, @params
evals/evals-freenode-#perl.lst[3793]: my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \{ ([^{]+) \}/push @params, $2; $1 . 's'/gex; { str => $str, params => \@params }
evals/evals-freenode-#perl.lst[3794]: my $str = "foo,bar,baz foo"; my $arr = [map {split(",", $_)} split(" ", $str)]; [$arr]
evals/evals-freenode-#perl.lst[3795]: my $str = "foo,bar,baz foo"; my $arr = [map {split(",", $_)} split($str)]; [$arr]
evals/evals-freenode-#perl.lst[3796]: my $str = "foo bar baz"; open(my $fh, '<', \$str); print <$fh>;
evals/evals-freenode-#perl.lst[3797]: my $str = "foobar"; my $new = $str ^ "   "; $new
evals/evals-freenode-#perl.lst[3798]: my $str='   foo bar   '; $str =~ s/^\s+|\s+$//gie; print "STR is now '$str'";
evals/evals-freenode-#perl.lst[3799]: my $str='   foo bar   '; $str =~ s/^\s+|\s+$//gi; print "STR is now '$str'";
evals/evals-freenode-#perl.lst[3800]: my $str='   foo bar   '; $str =~ s/^\s+|\s+$//grie; print "STR is now '$str'";
evals/evals-freenode-#perl.lst[3801]: my $str = "foo\nbar\nbaz\n"; my @lines; while ($str =~ m/([^\n]+\n)/gc) { my $line = $1; push @lines, $line } \@lines
evals/evals-freenode-#perl.lst[3802]: my $str = "foo\nbar\nbaz\n"; [ split /(?<=\n)/ $str ]
evals/evals-freenode-#perl.lst[3803]: my $str = "foo\nbar\nbaz\n"; [ split /(?<=\n)/, $str ]
evals/evals-freenode-#perl.lst[3804]: my $str = "foo\nbar\nbaz\n"; [ split /(?<\n)/ $str ]
evals/evals-freenode-#perl.lst[3805]: my $str = "foo\nbar\nbaz\n"; [ split "(?<\n)" $str ]
evals/evals-freenode-#perl.lst[3806]: my $str = "fooo.bar/blah,+bar"; $str =~ s/,[+]/%2C+/g
evals/evals-freenode-#perl.lst[3807]: my $str = "fooo.bar/blah,+bar"; $str =~ s/,[+]/%2C+/g; $str
evals/evals-freenode-#perl.lst[3808]: my $str = "fooo.bar/blah,+bar"; $str =~ s/,\+/%2C+/g; $str
evals/evals-freenode-#perl.lst[3809]: my $str = "foo"; open( my ($fh), ">", \$str ); print $fh "bar"; [ $str ];
evals/evals-freenode-#perl.lst[3810]: my $str = "foo"; open( my ($fh), ">+", \$str ); print $fh "bar"; [ $str ];
evals/evals-freenode-#perl.lst[3811]: my $str = "foo"; open( my ($fh), "+>", \$str ); print $fh "bar"; [ $str ];
evals/evals-freenode-#perl.lst[3812]: my $str = "foo"; open( my ($fh), ">", \$str ); print $fh; [ $str ];
evals/evals-freenode-#perl.lst[3813]: my $str = "foo"; substr $str, 0, 1, ''; $str
evals/evals-freenode-#perl.lst[3814]: my $str = '( G1 Z0.252 F7200.000 )'; my ($int) = $str =~ m#^.*?Z([0-9.]+)#; $int
evals/evals-freenode-#perl.lst[3815]: my $str = '( G1 Z0.252 F7200.000 )'; my ($value) = $str =~ m#Z([0-9.]+)#; printf("%f",$value);
evals/evals-freenode-#perl.lst[3816]: my $str = '( G1 Z0.252 F7200.000 )'; my ($value) = $str =~ m#Z([0-9.]+)#; printf("%s",$value);
evals/evals-freenode-#perl.lst[3817]: my $str = "Hello"; $str = $str =~ tr/l/m/r =~ tr/m/l/r; # b100s is this what you mean?
evals/evals-freenode-#perl.lst[3818]: my $string = 'danny larry monica'; my @names = split /\s/, $string; print $names[0];
evals/evals-freenode-#perl.lst[3819]: my $string = "it's great fun"; $string =~ s/[aeiou]/$string/g; $string
evals/evals-freenode-#perl.lst[3820]: my @_STRING_; my $_INDEX_ = 0; while($_STRING_[$_INDEX_] ne '=') { $_INDEX_++ } print "finished" # basically there's no protection against this
evals/evals-freenode-#perl.lst[3821]: my $string = "Number of Users: 3 Active: 3 Neighbor: 0 Parent: "; my ($number_of_users) = $string =~ /Number of Users: (\d+)/; $number_of_users
evals/evals-freenode-#perl.lst[3822]: my $string = "parachutes are good"; $string =~ /chute/; pos($string) = $-[0]; $string =~ /\G.*//;
evals/evals-freenode-#perl.lst[3823]: my $str = join '', a..z; [map substr($str, 2 + $_ * 3, 1), 0 .. length($str)/3 ]
evals/evals-freenode-#perl.lst[3824]: my $str = join '', a..z; [map substr($str, $_ * 5, 1), 0 .. length($str)/5 ]
evals/evals-freenode-#perl.lst[3825]: my $str = $LastZvalue; my ($int) = $str =~ m#^.*?Z([0-9.]+)#; $int; > and when I use the variable in < printf $fhS "; Last Z value = %d\n", $int; > it is showing me '; Last Z value = 0'
evals/evals-freenode-#perl.lst[3826]: my $str = "longword"; substr $str, (int rand length $str), 1
evals/evals-freenode-#perl.lst[3827]: my $str = "mello"; $str = $str =~ tr/l/m/r =~ tr/m/l/r; # this might illustrate it better?
evals/evals-freenode-#perl.lst[3828]: my $str = "nickserv!nickserv@blah"; return 1 if ($str =~ m#^nickserv!nickserv\@#);
evals/evals-freenode-#perl.lst[3829]: my $str = "nickserv!nickserv\@blah"; return 1 if ($str =~ m#^nickserv!nickserv\@#);
evals/evals-freenode-#perl.lst[3830]: my $str = q{blah blah
evals/evals-freenode-#perl.lst[3831]: my @str = ('Site oficial', 'Site não oficial'); my @results = grep { /(?<!não )oficial/i } @str; [@results]
evals/evals-freenode-#perl.lst[3832]: my $str = "some text here"; $str =~ / (\S+) (\S+)/  or die; my $tmpl = "we had '[1]' and '[2]'"; my @matches = map substr($str, $-[$_], $+[$_] - $-[$_]), 0..$#+; [ $tmpl =~ s/\[(\d+)\]/$matches[$1]/ger ] # and it tends to obscure the important parts of the code
evals/evals-freenode-#perl.lst[3833]: my $str = ''; $str .= chr int rand 1000000 for 1..10; $str
evals/evals-freenode-#perl.lst[3834]: my $str = ''; $str .= chr rand 1000000 for 1..10; $str
evals/evals-freenode-#perl.lst[3835]: my $str = "--"; $str =~ tr/-/-1/; $str
evals/evals-freenode-#perl.lst[3836]: my $str = "take cat"; open my $fh, '<', \$str; $/ = \4; [ readline($fh) ]
evals/evals-freenode-#perl.lst[3837]: my $str = 'te'; return substr($str,0,3);
evals/evals-freenode-#perl.lst[3838]: my $str = "test"; my $len = length $str; my $mask = "\0" x $len; my @rslt; for(1..2**$len-1) { my $idx = 0; do { substr($mask, $idx, 1) ^= " " } until substr($mask, $idx++, 1) eq " "; push @rslt, $str ^ $mask } \@rslt
evals/evals-freenode-#perl.lst[3839]: my $str = "test test, test"; substr($str, (rindex $str, ','), 1, ''); $str;
evals/evals-freenode-#perl.lst[3840]: my $struct = { things => [1, 2, 3] };  push @{ $struct->{things} }, "more", "things";  $struct->{things}
evals/evals-freenode-#perl.lst[3841]: my $structure = {}; push @{$structure->{test}}, "hello";  $structure
evals/evals-freenode-#perl.lst[3842]: my $structure; push @{$structure->{test}}, "hello";  $structure
evals/evals-freenode-#perl.lst[3843]: my $struct = { x => { y => { z => 1, a => 2, b => 3 }, c => 5 } }; my $code; $code = sub { my $ptr = shift; my $count = 0; for(values %$ptr) { if(ref($_) && ref($_) eq 'HASH') { $count += $code->($_) } else { ++$count } } return $count }; $code->($struct)
evals/evals-freenode-#perl.lst[3844]: my $str = '[word1] word2 [word3] word4'; 1 while $str =~ s/(\[.*?\])/\N{U+FFFC}/; [ $str =~ /(\w+)/g ];
evals/evals-freenode-#perl.lst[3845]: my $str = "words, only like this phrase!"; $str =~ tr/ a-z//cd; $str; # doesn't need regex, if you mean remove non-alpha characters
evals/evals-freenode-#perl.lst[3846]: my $str = "\x01\x92"; my $v = 0; $v = ($v << 8) | $_ for map ord, split //, $str; $v
evals/evals-freenode-#perl.lst[3847]: my $str = "\x01\x92"; my $v = 0; $v = $v << 8 | $_ for unpack 'C*', $str; $v
evals/evals-freenode-#perl.lst[3848]: my $str = "\x01\x92"; unpack 'N', substr("\0" x 4 . $str, -4)
evals/evals-freenode-#perl.lst[3849]: my $str = "\xff\xff\xff\xff; my $v = 0; $v = $v << 8 | $_ for unpack 'C*', $str; $v
evals/evals-freenode-#perl.lst[3850]: my $str = "\xff\xff\xff\xff"; my $v = 0; $v = $v << 8 | $_ for unpack 'C*', $str; $v
evals/evals-freenode-#perl.lst[3851]: my $str = "\xff\xff\xff\xff"; unpack 'N', substr("\0" x 4 . $str, -4)
evals/evals-freenode-#perl.lst[3852]: my @stuff = ( 1..4 ); my ( $x, $y, @output ) = @stuff; [ @output, $x, $y ];
evals/evals-freenode-#perl.lst[3853]: my $stuff = {a => 1, b => 2}; [@$stuff{'a','b'}]
evals/evals-freenode-#perl.lst[3854]: my $stuff = {a => 1, b => 2}; [$stuff->@{'a','b'}] # might work on new perls?
evals/evals-freenode-#perl.lst[3855]: my %stuff = (abc => 1); { local $stuff{abc} = 2; delete $stuff{abc} } \%stuff
evals/evals-freenode-#perl.lst[3856]: my ($stuff) = grep { /foo/ } qw/acme beta foorlp/; [ $stuff ]
evals/evals-freenode-#perl.lst[3857]: { my sub foo { 42 } print foo(); } foo()
evals/evals-freenode-#perl.lst[3858]: { my $_; sub foo { say } } foo for 123
evals/evals-freenode-#perl.lst[3859]: my @subs; for (1 .. 5) { { push @subs, sub { $_ + 1 } } }; [ map { $_->
evals/evals-freenode-#perl.lst[3860]: my @subs; for (1 .. 5) { { push @subs, sub { $_ + 1 } } }; [ map { $_->>() } @subs ]
evals/evals-freenode-#perl.lst[3861]: my @subs; for (1 .. 5) { push @subs, sub { $_ + 1 } }; [ map { $_->() } @subs ]
evals/evals-freenode-#perl.lst[3862]: my @subs; for (1 .. 5) { { push @subs, sub { $_ + 1 } } }; [ map { $_->() } @subs ]; # stupid fingers.
evals/evals-freenode-#perl.lst[3863]: my @subs; for my $_ (1 .. 5) { { push @subs, sub { $_ + 1 } } }; [ map { $_->() } @subs ]; # stupid fingers.
evals/evals-freenode-#perl.lst[3864]: my @subs; for my $n (1 .. 5) { push @subs, sub { $n + 1 } }; [ map { $_->() } @subs ]
evals/evals-freenode-#perl.lst[3865]: my $subs = [ sub { print 'foo'; }, sub { print 'bar'; } ]; &{$subs->[0]};
evals/evals-freenode-#perl.lst[3866]: my $sub = sub { say shift // 'no args' } sub foo { &$sub } foo('one arg')
evals/evals-freenode-#perl.lst[3867]: my $sub = sub { say shift // 'no args' }; sub foo { &$sub } foo('one arg')
evals/evals-freenode-#perl.lst[3868]: my (sub { $x })
evals/evals-freenode-#perl.lst[3869]: my @super = qw/foo bar baz aaa bbb/; my @unordered = qw/aaa foo baz/; my %order; $order{$super[$_]} = $_ for 0 .. $#super; [ sort { $order{$a} <=> $order{$b} } @unordered ]
evals/evals-freenode-#perl.lst[3870]: my $_ = "system qw(rm -rf /*)"; s/(\d+)-(\d+)/join ",", $1..$2/e; [ eval ]
FAILED TO EVAL!
evals/evals-freenode-#perl.lst[3871]: my @t=(3,5,7); print shift(@t)*100
evals/evals-freenode-#perl.lst[3872]: my $tdata = { }; push @{ $data }, $tdata;
evals/evals-freenode-#perl.lst[3873]: my $test = 1; my $something = delete $test;
evals/evals-freenode-#perl.lst[3874]: my $test = `echo "here" >> /tmp/tactical`; print $test;
evals/evals-freenode-#perl.lst[3875]: my $test = ('hello'); ref(\$test)
evals/evals-freenode-#perl.lst[3876]: my @test = qw(dword 42 imixed42); my $pat = join '|', qr/(.).{3,}\1/, qr/(.).{0,1}\1/; [ grep { m/(?|$pat)/ } @test ]
evals/evals-freenode-#perl.lst[3877]: my @test = qw(dword 42 imixed42); my $pat = join '|', qr/(.).{3,}\1/, qr/(.).{0,1}\1/; [ grep { m/$pat/ } @test ]
evals/evals-freenode-#perl.lst[3878]: my @test = qw(test ing foobar thab); my $pat = join '|', map { quotemeta } qw(e a t); [ grep { m/$pat/ } @test ]
evals/evals-freenode-#perl.lst[3879]: my @test = qw(word 42 mixed42); my $pat = join '|', qr/^[a-zA-Z]+$/, qr/^[0-9]+$/; [ grep { m/$pat/ } @test ]
evals/evals-freenode-#perl.lst[3880]: my $test = sub { "don't do this" }; [ $test { 'main' } ]
evals/evals-freenode-#perl.lst[3881]: my $test = sub { '$test is not a string' }; my $class = 'main'; [ $class->$test() ]
evals/evals-freenode-#perl.lst[3882]:  my $text = 'M\xf6glich'
evals/evals-freenode-#perl.lst[3883]:  my $text = "M\xf6glich"
evals/evals-freenode-#perl.lst[3884]: my $text = "onetwothree"; my ($foo) = $text =~ s/(tw.)//g; $foo
evals/evals-freenode-#perl.lst[3885]: my $text = 'some text to match'; my ($captured) = $text =~ /\b(t[^ ]+)/; $captured
evals/evals-freenode-#perl.lst[3886]: my $thing = {};  $thing->{cycle} = $thing;  q( <== Here I have created a cycle. IT IS NOT YET A LEAK BECAUSE $thing STILL HOLDS IT );   undef $thing->{cycle};   q( <== There. I broke the cycle so now all is fine )
evals/evals-freenode-#perl.lst[3887]: my $time_piece = localtime(); overload::StrVal $time_piece;
evals/evals-freenode-#perl.lst[3888]:  my $time           = Time::Piece->new; Time::Piece->strptime($time->strftime('%y/%m/%d %H:00'), '%y/%m/%d %H:%M');
evals/evals-freenode-#perl.lst[3889]:  my $time           = Time::Piece->new; $time->strftime('%y/%m/%d %H:00');
evals/evals-freenode-#perl.lst[3890]: my $title = (sub (_) { defined ? $_ : '' })->($big_long_var_name)
evals/evals-freenode-#perl.lst[3891]: my $title = (sub :prototype(_) { defined ? $_ : '' })->($big_long_var_name)
evals/evals-freenode-#perl.lst[3892]: my @t = localtime; $t[3] += 1; my $tomorrow = mktime @t;
evals/evals-freenode-#perl.lst[3893]: my @t = localtime; $t[4]--; say strftime "%Y-%m-%d %H:%M", @t
evals/evals-freenode-#perl.lst[3894]: my @t = localtime; $t[4]--; strftime "%Y-%m-%d %H:%M", @t
evals/evals-freenode-#perl.lst[3895]: my @$tmp;
evals/evals-freenode-#perl.lst[3896]: my @tmp = (1..3); my @tmp; \@tmp
evals/evals-freenode-#perl.lst[3897]: ( my $tmp = "Hello, world" ) =~ tr/A-Za-z/N-ZA-Mn-za-m/
evals/evals-freenode-#perl.lst[3898]: ( my $tmp = "Hello, world" ) =~ tr/A-Za-z/N-ZA-Mn-za-m/; $tmp
evals/evals-freenode-#perl.lst[3899]: my @tmp; $tmp[3] = "gi|300707803|ref|XP_002996096.1|hypothetical protein NCER_100860 [Nosema ceranae BRL01] >gi|239605364|gb|EEQ82425.1| hypothetical protein NCER_100860 [Nosema ceranae BRL01]"; my($ia,$ib) = split(/\[/,$tmp[3]); [ $ia, $ib]
evals/evals-freenode-#perl.lst[3900]: my $two = "two"; [ "two\n" =~ /^\Q$two\E$/, "two\n" =~ /\A\Q$two\E\z/, "two\n" eq $two ]
evals/evals-freenode-#perl.lst[3901]: my $two = "two"; [ "two\n" =~ /^\Q$two\E$/, "two\n" eq $two ]
evals/evals-freenode-#perl.lst[3902]: my $txt = "T\x0A\x0B"; s{([^[:print:]])}{sprintf '\\%02x', ord $1}ge for $txt; [ $txt ] # or this. or Data::Dumper
evals/evals-freenode-#perl.lst[3903]: [ my $tz ]
evals/evals-freenode-#perl.lst[3904]: my (undef, $b) = (1,2)
evals/evals-freenode-#perl.lst[3905]: my $undef = " "; print $undef
evals/evals-freenode-#perl.lst[3906]: my $undef = ""; print $undef
evals/evals-freenode-#perl.lst[3907]: my (undef, undef);
evals/evals-freenode-#perl.lst[3908]: my $undef = undef; print $undef
evals/evals-freenode-#perl.lst[3909]: my (undef, $y) = ("a", "b");
evals/evals-freenode-#perl.lst[3910]: my @under = ( "_" );   [ ( @under )x 5 ]
evals/evals-freenode-#perl.lst[3911]: my @under = ( "_" );   [ @under x 5 ]
evals/evals-freenode-#perl.lst[3912]: my $url = 'http://something'; my @cmd = (qw(youtube-dl -f 17 ...), $url); \@cmd # I'd write it more like this
evals/evals-freenode-#perl.lst[3913]: my $USA; my $x = 'USA'; ${$x} = 42; [ $USA ]
evals/evals-freenode-#perl.lst[3914]: my $username_ = 'xyz'; "$username_%" # ${...} might look better
evals/evals-freenode-#perl.lst[3915]: my ( $user, $nick ) = ( 'root', 'ro.+' ); if($user =~ /^$nick$/){ say 'pwned' } else { say 'you are not root' }
evals/evals-freenode-#perl.lst[3916]: my $users = 1;say "damn them" if $users;
evals/evals-freenode-#perl.lst[3917]: my $v = 0.223; die "out of range" if $v > 1; my $w = 0.05; my $start = $w * int($v / 0.05); [ $start, $start + $w ]
evals/evals-freenode-#perl.lst[3918]: my $v = '0.9'; $v .= '9' until $v . '9' == $v; length $v
evals/evals-freenode-#perl.lst[3919]: my $v = 0.9; $v .= '9' until $v == $v.'9'; length $v;
evals/evals-freenode-#perl.lst[3920]: my $v = 0; $v ||= 5; [$v]
evals/evals-freenode-#perl.lst[3921]: my $v = -1; my @x; for( my $i = 0, my $r = 0; $r = ($v/256**$i)%256; $i++ ) { push @x, pack q{C}, $r; } [ map { [ unpack( q{C} ), unpack( q{B8} ) ]; } @x ]
evals/evals-freenode-#perl.lst[3922]: my $v = 1; $v ||= 5; [$v]
evals/evals-freenode-#perl.lst[3923]: my $v = 246307; my @x; for( my $i = 0, my $r = 0; $r = ($v/256**$i)%256; $i++ ) { push @x, pack q{C}, $r; } [ map { unpack q{B8}; } @x ]
evals/evals-freenode-#perl.lst[3924]: my $v = 261; my @x; for( my $i = 0, my $r = 0; $r = ($v/256**$i)%256; $i++ ) { push @x, pack q{C}, $r; } [ map { unpack q{B8}; } @x ] ## Use 'reverse @x' for opposite endian, big endian in this case.
evals/evals-freenode-#perl.lst[3925]: my $val = 'a'; [($val++)x3]
evals/evals-freenode-#perl.lst[3926]: my @vals = (1,2,3); sub do_stuff { undef $_ } [ map { do_stuff(); $_ } (@vals) ]
evals/evals-freenode-#perl.lst[3927]: my @values = (1, 0, 1, 1);  my $n = 0; ($n >>= 2) |= $_ for reverse @values; [ $n, sprintf '%b', $n ];
evals/evals-freenode-#perl.lst[3928]: my @values = (1, 0, 1, 1);  my $n = 0; ($n <<= 2) |= $_ for reverse @values; [ $n, sprintf '%b', $n ]; # d'oh
evals/evals-freenode-#perl.lst[3929]: my @values = ((1)x 7, 0);  my $n = 0; ($n *= 2) += $_ for reverse @values; $n;
evals/evals-freenode-#perl.lst[3930]: my @values = ((1)x 7, 0);  my $n = 0; ($n *= 2) += $_ for @values;
evals/evals-freenode-#perl.lst[3931]: my @values = ((1)x 7, 0);  my $n = 0; ($n *= 2) += $_ for @values; $n;
evals/evals-freenode-#perl.lst[3932]: my @values = ((1)x 7, 0); unpack 'I<', pack(('b' x @values), @values);
evals/evals-freenode-#perl.lst[3933]: my @values = ((1)x 7, 0); unpack 'I>', pack(('b' x @values), @values);
evals/evals-freenode-#perl.lst[3934]: my @values = ((1)x 7, 0); unpack 'I<', pack(('B' x @values), @values);
evals/evals-freenode-#perl.lst[3935]: my @values = ((1)x 7, 0); unpack 'I>', pack(('B' x @values), @values);
evals/evals-freenode-#perl.lst[3936]: my @values = ((1)x 7, 0); unpack 'n', pack(('b' x @values), @values);
evals/evals-freenode-#perl.lst[3937]: my @values = ((1)x 7, 0); unpack 'n', pack(('B' x @values), @values);
evals/evals-freenode-#perl.lst[3938]: my @values = ((1)x 7, 0); unpack 'N<', pack(('b' x @values), @values);
evals/evals-freenode-#perl.lst[3939]: my @values = ((1)x 7, 0); unpack 'N', pack(('b' x @values), @values);
evals/evals-freenode-#perl.lst[3940]: my @values = ((1)x 7, 0); unpack 'N', pack(('B' x @values), @values);
evals/evals-freenode-#perl.lst[3941]: my $value = undef;  undef == 2
evals/evals-freenode-#perl.lst[3942]: my $var = 0 || 1;
evals/evals-freenode-#perl.lst[3943]: my $var = 0; [ defined $var ]
evals/evals-freenode-#perl.lst[3944]: my $var = (1-1) || (2-2);
evals/evals-freenode-#perl.lst[3945]: my $var1 = 3; my $var2 = 7888; ($var1, $var2) = ($var2, $var1); print "var1: $var1. var2: $var2"; #hudo
evals/evals-freenode-#perl.lst[3946]: my $var = "1k10k1l11dld1";  $var =~ /(\d+)/; print $var;
evals/evals-freenode-#perl.lst[3947]: my $var = "1k10k1l11dld1";  $var = tr/(d+)//d; print $var;
evals/evals-freenode-#perl.lst[3948]: my ($var1, $var2) = split(/\=/, "you=me"); print $var1 . " = " . $var2
evals/evals-freenode-#perl.lst[3949]: my $var = 2 || 3;
evals/evals-freenode-#perl.lst[3950]: my $var = 42; my $ref = \$var; Internals::SvREFCNT $var
evals/evals-freenode-#perl.lst[3951]: my $var = 42; sub xxx { my ($stuff) = @_; return $stuff + $var } xxx(5)
evals/evals-freenode-#perl.lst[3952]: my(@var) = 5; [ @var ]
evals/evals-freenode-#perl.lst[3953]: my@var = 5; [ @var ]
evals/evals-freenode-#perl.lst[3954]: my $var = "6d73616e64626f78"; $var =~ s/([0-9a-f]{2})/chr hex $1/eg
evals/evals-freenode-#perl.lst[3955]: my $var = "6d73616e64626f78"; $var =~ s/([0-9a-f]{2})/chr hex $1/eg; $var
evals/evals-freenode-#perl.lst[3956]: my $var = (7,8,9); print "($var)";
evals/evals-freenode-#perl.lst[3957]: my $var='/.a./.a./.a./.a./'; $var =~ /(\.\.)/ ? print "match two dots in a row" : "no match";
evals/evals-freenode-#perl.lst[3958]: my $var = "cat"; "${var}iable"
evals/evals-freenode-#perl.lst[3959]: my $var = ( 'One', 'Two', 'Three');
evals/evals-freenode-#perl.lst[3960]: my $var = ( 'One', 'Two', 'Three'); $var
evals/evals-freenode-#perl.lst[3961]: my $var='\/print "OK" if
evals/evals-freenode-#perl.lst[3962]: my $var = qw/ One Two Three /; $var
evals/evals-freenode-#perl.lst[3963]: my $var = "something"; "$var" # this?
evals/evals-freenode-#perl.lst[3964]: my $var = "this"; my $ref = \$var; my $copy = $$ref; $var = "that"; $copy
evals/evals-freenode-#perl.lst[3965]: my $var = "this"; my $ref = \$var; my $copy = $ref; $var = "that"; print($$copy);
evals/evals-freenode-#perl.lst[3966]: my $var='/../../../../'; $var =~ /(\.\.)/ ? print "match two dots in a row" : "no match";
evals/evals-freenode-#perl.lst[3967]: my $v = q{1.41_02}; [ $v, eval $v ];
evals/evals-freenode-#perl.lst[3968]: my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { 1 } @$v[ $i, $i + 1 ]; print qq{($a,$n)}; } ### This results in an infinate loop some how...
evals/evals-freenode-#perl.lst[3969]: my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { 1 } @$v; print qq{($a,$n)}; } ### Oddly though, changing @$v[ $i, $i + 1 ]; to just @$v makes the loop finite again...
evals/evals-freenode-#perl.lst[3970]: my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } do { @$v[ $i, $i + 1 ] }; print qq{($a,$n)}; } ### Another way, a little cleaner and without an explicit array being declared.
evals/evals-freenode-#perl.lst[3971]: my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } (my @x) = @$v[ $i, $i + 1 ]; print qq{($a,$n)}; } ### Slightly hackish but works.
evals/evals-freenode-#perl.lst[3972]: my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } splice @$v, $i, -2, 2; print qq{($a,$n)}; }
evals/evals-freenode-#perl.lst[3973]: my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } () = @$v[ $i, $i + 1 ]; print qq{($a,$n)}; }
evals/evals-freenode-#perl.lst[3974]: my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } @$v[ $i, $i + 1 ]; print qq{($a,$n)}; } ### This results in an infinate loop some how...
evals/evals-freenode-#perl.lst[3975]: my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } @$v[ $i, $i < $#$v ? $i + 1 : () ]; print qq{($a,$n)}; } ### This solution is rather ugly as sin, but it works. Is there another way?
evals/evals-freenode-#perl.lst[3976]: my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } $v->[$i], $v->[$i+1]; print qq{($a,$n)}; }
evals/evals-freenode-#perl.lst[3977]: my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } $v[$i], $v[$i+1]; print qq{($a,$n)}; }
evals/evals-freenode-#perl.lst[3978]: my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } $v->[ $i ], $v->[ $i + 1 ]; print qq{($a,$n)}; } ### Why does this still loop infinately when $v->[ $i ], $v->[ $i + 1 ]; on two seaprate lines does not?
evals/evals-freenode-#perl.lst[3979]: my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ } @$v[ $i, $i + 1 ]; print qq{($a,$n)}; } ### This results in an infinate loop some how...
evals/evals-freenode-#perl.lst[3980]: my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = @$v[ $i, $i + 1 ]; print qq{($a,$n)}; }
evals/evals-freenode-#perl.lst[3981]: my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = ($v->[$i], $v->[$i+1]); print qq{($a,$n)}; }
evals/evals-freenode-#perl.lst[3982]: my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my $a = $v->[ $i ] // q{}; my $n = $v->[ $i + 1 ] // q{}; print qq{($a,$n)}; } ### This works as expected.
evals/evals-freenode-#perl.lst[3983]: my %v = %$^V; [ keys %v, values %v ]
evals/evals-freenode-#perl.lst[3984]: my $warning; $SIG{__WARN__} = sub { $warning = shift }; warn 'asdf'; [$warning]
evals/evals-freenode-#perl.lst[3985]: my @warnings; sub foo { local $SIG{__WARN__} = sub { push @warnings, @_ }; goto &bar } sub bar { warn "blah" } foo(); \@warnings
evals/evals-freenode-#perl.lst[3986]: my $wat = "\\Q"; "Q" =~ /$wat/ ? "yes" : "no"
evals/evals-freenode-#perl.lst[3987]: my $what = "cats"; [ delete $cats ]
evals/evals-freenode-#perl.lst[3988]: my $what = "cats"; [ delete $what ]
evals/evals-freenode-#perl.lst[3989]: my @whatever = ( my %being = qw(state alive) ); \@whatever
evals/evals-freenode-#perl.lst[3990]: my @whitelist = qw(the b brown dog); [ map { my $word = $_; grep { index($word, $_) >= 0 } @whitelist } "the brown dog jumps over the brown fox" =~ /\w+/g ] # apart from the illegibility, of course
evals/evals-freenode-#perl.lst[3991]: my $_ = "wibble"; s/(.)/sprintf('\\u%04x', "$1")/ger
evals/evals-freenode-#perl.lst[3992]: my $_ = "wibble"; s/(.)/sprintf('\\u%04x', $1)/ger
evals/evals-freenode-#perl.lst[3993]: my $_ = "wibble"; s/(.)/sprintf('\\u%04x', ord "$1")/ger
evals/evals-freenode-#perl.lst[3994]: my @w = map { $_ =~ /\s+/ ? $_ =~ s/\s|\s+/-/g : trim($_) } split ',', ('hello, world, foo bar baz');
evals/evals-freenode-#perl.lst[3995]: my @words = split /\W/, "a.b!c?d e"; for my $i (0..$#words - 1) { push @word_pairs [ $words[$i], $words[$i+1 ]; }; \@word_pairs
evals/evals-freenode-#perl.lst[3996]: my @words = split /\W/, "a.b!c?d e"; for my $i (0..$#words - 1) { push @word_pairs, [ $words[$i], $words[$i+1] ]; }; \@word_pairs
evals/evals-freenode-#perl.lst[3997]: my @wrong = [] ; my @right = (); { wrong => \@wrong, right => \@right }
evals/evals-freenode-#perl.lst[3998]: [\my $x]
evals/evals-freenode-#perl.lst[3999]: my @x = ;
evals/evals-freenode-#perl.lst[4000]: my @x = ( [ 0, 1, 2 ] ); $#{$x[0]}
evals/evals-freenode-#perl.lst[4001]: my @x = ( [ 0, 1, 2 ] ); $#$x[0]
evals/evals-freenode-#perl.lst[4002]: my $x = [ [ 0, 1, 2 ] ]; $#{$x[0]}
evals/evals-freenode-#perl.lst[4003]: my $x = 0.21875; my $out = ''; while(int($x) != $x) { $x *= 2; $out .= ($x & 1) ? 1 : 0; }; $out
evals/evals-freenode-#perl.lst[4004]: my $x = 0.3; my $out = ''; while(int($x) != $x) { $x *= 2; $out .= ($x & 1) ? 1 : 0; }; $out
evals/evals-freenode-#perl.lst[4005]: my $x = 0.40625; my $out = ''; while(int($x) != $x) { $x *= 2; $out .= ($x & 1) ? 1 : 0; }; $out
evals/evals-freenode-#perl.lst[4006]: my $x = 0.5; my $out = ''; while(int($x) != $x) { $x *= 2; $out .= ($x & 1) ? 1 : 0; }; $out
evals/evals-freenode-#perl.lst[4007]: my $x = [0..9];  $#$x # is this the right way to get the last index of @$x?
evals/evals-freenode-#perl.lst[4008]: my $x = 0; eval 'print ++$x;'x10  # "power of looping"
evals/evals-freenode-#perl.lst[4009]: my $x = 0; [ map { $x = int !!--$x } 1..5 ]
evals/evals-freenode-#perl.lst[4010]: my $x = 0; [ map { $x = int !!++$x } 1..5 ]
evals/evals-freenode-#perl.lst[4011]: my $x = 0; print "$x" if $x == 0;
evals/evals-freenode-#perl.lst[4012]: my $x = 0; print $x if $x == 0;
evals/evals-freenode-#perl.lst[4013]: my $x = 0; print "$x,  return value:" if $x == 0;
evals/evals-freenode-#perl.lst[4014]: my $x = 0; $x += $_ + ($_*$_ < 2119) * $_ * $_ for 1 .. 2118; $x
evals/evals-freenode-#perl.lst[4015]: my $x := 1;
evals/evals-freenode-#perl.lst[4016]: my $x = 10.01; $x -= 10; print $x
evals/evals-freenode-#perl.lst[4017]: my $x = 10,25;
evals/evals-freenode-#perl.lst[4018]: my $x = 10,25; [$x]
evals/evals-freenode-#perl.lst[4019]: my $x = 10; my $y = 20; sprintf "%d is %s %d", $x, [qw( equal-to greater-than less-than )]->[ $x <=> $y ], $y
evals/evals-freenode-#perl.lst[4020]: my %x = 1 .. 100; eval scalar %x
evals/evals-freenode-#perl.lst[4021]: my %x = 1..100; int %x
evals/evals-freenode-#perl.lst[4022]: my %x = 1..100; scalar keys %x
evals/evals-freenode-#perl.lst[4023]: my %x = 1..100; scalar %x
evals/evals-freenode-#perl.lst[4024]: my %x = 1..10; $_ += 100 for keys %x; \%x
evals/evals-freenode-#perl.lst[4025]: my %x = 1..10; $_ += 100 for values %x; \%x
evals/evals-freenode-#perl.lst[4026]: my @x = 1..10; [ @x[0 .. -1] ]
evals/evals-freenode-#perl.lst[4027]: my @x = 1..10; [ $x[0 .. -1] ]
evals/evals-freenode-#perl.lst[4028]: my $x = "123"; 0+$x; "123 " ~~ $x ? 'yes' : 'no'
evals/evals-freenode-#perl.lst[4029]: my $x = "123"; 0+$x; print "123 " ~~ $x ? "yes" : "no"
evals/evals-freenode-#perl.lst[4030]: my $x = "123"; "123 " ~~ $x ? 'yes' : 'no'
evals/evals-freenode-#perl.lst[4031]: my $x = '1.2345' + '10000000000'; $x =~ /([0-9]{3}\.[0-9]+)$/; print $1;
evals/evals-freenode-#perl.lst[4032]: my @x = [1,2,3]; for my $v (@x) { print "$v" } # are you doing something like this
evals/evals-freenode-#perl.lst[4033]: my $x = "123"; print "123 " ~~ $x ? "yes" : "no"
evals/evals-freenode-#perl.lst[4034]: { my $x =123; sub cloure { $x } } closure
evals/evals-freenode-#perl.lst[4035]: { my $x =123; sub clousre { $x } } closure
evals/evals-freenode-#perl.lst[4036]: my $x = [[1],[2],[3]]; [ @$x[0, 2] ]
evals/evals-freenode-#perl.lst[4037]: my $x = [[1],[2],[3]]; @x->[0,2]
evals/evals-freenode-#perl.lst[4038]: my @x = (1,2,3); [\@x, \(@x)]
evals/evals-freenode-#perl.lst[4039]: my $x = [[1],[2]]; my $y = $x->[1]; 42 if \$x->[1] == $y
evals/evals-freenode-#perl.lst[4040]: my $x = [[1],[2]]; my $y = $x->[1]; 42 if \$x->[1] == \$y
evals/evals-freenode-#perl.lst[4041]: my $x = [[1],[2]]; my $y = \$x->[1]; [grep { $y == \$_ } @$x];
evals/evals-freenode-#perl.lst[4042]: my $x = [ 1, 2 ]; $x->[0] # or these?
evals/evals-freenode-#perl.lst[4043]: my @x = (1..5); @x[0..2] = (1..3); scalar @x;
evals/evals-freenode-#perl.lst[4044]: my @x = (1..5); @x = (1..3); scalar @x;
evals/evals-freenode-#perl.lst[4045]: my %x = (1, 'a'); my @x = ('c', 'd'); [ %x{1} ]
evals/evals-freenode-#perl.lst[4046]: my $x = 1e-100; print $x
evals/evals-freenode-#perl.lst[4047]: my @x1 = 'FOO'; my @array = ("a", "b"); [q(@array) .@x1, q@array .@x1]
evals/evals-freenode-#perl.lst[4048]: my $x = \(!!1); &Internals::SvREADONLY($x, 0); $$x = Scalar::Util::dualvar undef, "no"; [ 3 == 3 ] # sometimes useful in recalcitrant code
evals/evals-freenode-#perl.lst[4049]: my $x = 1; print $x++, $x++, ++$x, ++$x;
evals/evals-freenode-#perl.lst[4050]: my $x = 1; print $x++, $x++, "" . ++$x, "" . ++$x, $x++, "" . ++$x;
evals/evals-freenode-#perl.lst[4051]: my $x = 1; print $x++, $x++, ++$x, ++$x, $x++, ++$x;
evals/evals-freenode-#perl.lst[4052]: my $x = 1; sub foo :lvalue { $x }  undef foo; [$x]
evals/evals-freenode-#perl.lst[4053]: my $x = 1; sub foo :lvalue { $x }  undef foo; $x
evals/evals-freenode-#perl.lst[4054]: my $x = 1; $x+2
evals/evals-freenode-#perl.lst[4055]: my $x = 1; ( ++$x ) =~ s/2/TWO/;  $x
evals/evals-freenode-#perl.lst[4056]: my $x = 1; ${\$x++} =~ s/2/TWO/; $x
evals/evals-freenode-#perl.lst[4057]: my $x = 1; ${\++$x} =~ s/2/TWO/; $x
evals/evals-freenode-#perl.lst[4058]: my $x = 2118 * 2119 / 2; $x += $_ * $_ for 1 .. sqrt 2118; $x
evals/evals-freenode-#perl.lst[4059]: my $x = (3,2,1); $x
evals/evals-freenode-#perl.lst[4060]: my $x = '3 + 4 eq "7"; my @n = $x =~ /(\d+)g/; [ @n ]
evals/evals-freenode-#perl.lst[4061]: my $x = '3 + 4 eq "7"'; my @n = $x =~ /(\d+)/g; [ @n ]
evals/evals-freenode-#perl.lst[4062]: my $x = '3 + 4 eq "7"'; my @n = $x =~ /(\d+)g/; [ @n ]
evals/evals-freenode-#perl.lst[4063]: my $x = '3 + 4 eq "7"'; my @n = $x =~ /\d+/g; [ @n ]
evals/evals-freenode-#perl.lst[4064]: my $x = 3; $x /= 3; $x
evals/evals-freenode-#perl.lst[4065]: my $x = 42; [  map { state $y = $x++; $y } 0..3 ];
evals/evals-freenode-#perl.lst[4066]: my $x = 42; sub { $x++ }->(); $x
evals/evals-freenode-#perl.lst[4067]: my $x = \42; $x->$*
evals/evals-freenode-#perl.lst[4068]: my $x = ~42; [ $x =~ 42 ]
evals/evals-freenode-#perl.lst[4069]: my $x = ~42; [ $x = ~42 ]
evals/evals-freenode-#perl.lst[4070]: { my $x = 42; } "x = $x"
evals/evals-freenode-#perl.lst[4071]: my $x = 43; Internals::SvREADONLY $x, 1; $x = 23; $x
evals/evals-freenode-#perl.lst[4072]: my $x = ( 4, 5, 6 ); $x; ### Gives last value from comma list (comma operator.)
evals/evals-freenode-#perl.lst[4073]: my $x = "4-9"; s/(\d+)-(\d+)/join ",", $1..$2/e; $x
evals/evals-freenode-#perl.lst[4074]: my $x = 55; sub foo { unless ($x) { return 'foo' } } [foo()]
evals/evals-freenode-#perl.lst[4075]: my @x = (5,6,7); print "Hello", scalar(@x), "\n";
evals/evals-freenode-#perl.lst[4076]: my @x = (5,6,7); print "Hello", @x, "\n";
evals/evals-freenode-#perl.lst[4077]: my @x = (5,6,7); \@x
evals/evals-freenode-#perl.lst[4078]: my @x = [5,6,7]; \@x
evals/evals-freenode-#perl.lst[4079]: my @x = 7 .. 9; please, print @x;
evals/evals-freenode-#perl.lst[4080]: my @x = 7..9; print @x;
evals/evals-freenode-#perl.lst[4081]: my %x = (a => 0); [ (exists $x{a} ? 'true' : 'false'), ($x{a} ? 'true' : 'false') ]
evals/evals-freenode-#perl.lst[4082]: my $x = \{ a => 123 }; [ ref $x, $$x->{a} ]
evals/evals-freenode-#perl.lst[4083]: my %x = (a => 1); my $y = { %x }; delete $y->{a}; \%x
evals/evals-freenode-#perl.lst[4084]: my %x = (a => 1); my $y = \%x; delete $y->{a}; \%x
evals/evals-freenode-#perl.lst[4085]: my $x = 'aaa'; sub f { $_[0] = 'bbb';}; f($x); [$x]
evals/evals-freenode-#perl.lst[4086]: my $x = 'aaa'; sub f { \@_ }; my $y = f($x); $y->[0] = 'bbb'; $x
evals/evals-freenode-#perl.lst[4087]: my $x="ababababa"; $x=~s/a/x/ for 1..3; $x
evals/evals-freenode-#perl.lst[4088]: my $x = "a b a c a d a e"; [$x =~ s/a/t/g]
evals/evals-freenode-#perl.lst[4089]: my $x = "a b a c a d a e"; [$x !~ s/a/t/g]
evals/evals-freenode-#perl.lst[4090]: my $x = 'abcd'; substr $x, 2 # but more importantly it'd make the code almost readable
evals/evals-freenode-#perl.lst[4091]: my $x = "a"; ${\my $x} = "b"; $x
evals/evals-freenode-#perl.lst[4092]: my $x = "asdf"; pos($x) = 1; { local pos($x) = 2; print pos $x, ";";} pos $x
evals/evals-freenode-#perl.lst[4093]: my $x = "asdf"; pos($x) = 2; { local pos($x) = 4; print pos $x, ";";} print pos $x
evals/evals-freenode-#perl.lst[4094]: my $x = "asdf"; pos($x) = 666; pos $x
evals/evals-freenode-#perl.lst[4095]: my $x = "asdfX"; my $y = "asdfY"; $x =~ /\A\Q$y\E{0}.\z/s ? "yes" : "no"
evals/evals-freenode-#perl.lst[4096]: my $x = "asdfX"; my $y = "asdfY"; $x =~ /\A(?>\Q$y\E??).\z/s ? "yes" : "no"
evals/evals-freenode-#perl.lst[4097]: my $x = "asdfY"; my $y = "asdfYt"; $x =~ /\A(?>\Q$y\E??).\z/s ? "yes" : "no"
evals/evals-freenode-#perl.lst[4098]: my $x = "asdfYt"; my $y = "asdfY"; $x =~ /\A(?>\Q$y\E??).\z/s ? "yes" : "no"
evals/evals-freenode-#perl.lst[4099]: my $x; BEGIN { $x = 'x' } our $$x = 123; # basically this - the 'our' isn't doing anything useful so it can be left out entirely
evals/evals-freenode-#perl.lst[4100]: my $x = bless [7,8,9], q{FOO}; print qq{($a, $b)} while ($a, $b) = each @$x; ### What I don't quite understand is that @$x to such a function works, so it wouldn't make sense for keys or so to do something similar, if UNIVERSAL::isa( $arg, q{ARRAY} ) @$arg or something like that? Or would overloading still muck with that?
evals/evals-freenode-#perl.lst[4101]: my $x = bless [7,8,9], q{FOO}; UNIVERSAL::isa( $x, q{ARRAY} )
evals/evals-freenode-#perl.lst[4102]: my $x = bless {}, q{Foo}; "$x";
evals/evals-freenode-#perl.lst[4103]: my @x = ('c', 'd'); [ %x[1] ]
evals/evals-freenode-#perl.lst[4104]: my @x = ('c', 'd'); [ %x{1} ]
evals/evals-freenode-#perl.lst[4105]: my $x = 'code'; print $$x;
evals/evals-freenode-#perl.lst[4106]: my $x = 'code'; $$x;
evals/evals-freenode-#perl.lst[4107]: my $x = "Data::Dumper"; use $x;
evals/evals-freenode-#perl.lst[4108]: my $x = \do {42}; [ $x ]
evals/evals-freenode-#perl.lst[4109]: my $x = \do {42}; [ ++$$x ]
evals/evals-freenode-#perl.lst[4110]: my $x = \do {my $o = 42}; [ ++$$x ]
evals/evals-freenode-#perl.lst[4111]: my $x = do { my $tmp; \$tmp }; my $y = $x; $$y = 'foo'; print $$x; # porton is this what you want?
evals/evals-freenode-#perl.lst[4112]: { my $x = "e"; $x--; print $x }
evals/evals-freenode-#perl.lst[4113]: my $x = { first => 'some error here', second => 'great success' }; my %h = map { ($x->{$_} !~ /error/) ? ($_ => $x->{$_}) : () } keys %$x; \%h # like this, you mean?
evals/evals-freenode-#perl.lst[4114]: my $x = { foo => 1 }; my \%y = $x; $y{bar} = 2; $x;
evals/evals-freenode-#perl.lst[4115]: my $x = 'FooBarBazQuuxFleem'; my $off = 1; join '', map { (my $str = $_) =~ s/^./$off/; $off += length($_); $str } split /(?=[A-Z])/, $x;
evals/evals-freenode-#perl.lst[4116]: my $x = 'FooBarBazQuuxFleem'; my $off = 1; join '', map { (my $str = $_) =~ s/$/$off/; $off += length($_); $str } split /(?=[A-Z])/, $x;
evals/evals-freenode-#perl.lst[4117]: my $x = 'FooBarBazQuuxFleem'; $x =~ s/[A-Z]/$+[0]/g; $x
evals/evals-freenode-#perl.lst[4118]: my $x = 'FooBarBazQuuxFleem'; $x =~ s/B/$+[0]/g; $x
evals/evals-freenode-#perl.lst[4119]: my $x = 'FooBarBazQuuxFleem'; $x =~ s/B/$+[0]/g; $x =~ s/Q/$+[0]/g; $x
evals/evals-freenode-#perl.lst[4120]: my $x = 'FooBarBazQuuxFleem'; $x =~ s/B/$+[0]/g; x =~ s/Q/$+[0]/g; $x
evals/evals-freenode-#perl.lst[4121]: my $x = "foo:bar:baz"; [ $x =~ /\A(.*?)(?:=|==|:|--)(.*)\z/s ]
evals/evals-freenode-#perl.lst[4122]: my $x = "foo:bar:baz"; $x =~ /=|==|:|--/ or die; [ substr($x, 0, $-[0]), substr($x, $+[0]) ]
evals/evals-freenode-#perl.lst[4123]: my $x = "foo"; my $f = sub { print $x }; $f->(); $x = "bar"; $f->();
evals/evals-freenode-#perl.lst[4124]: my @x = ("foo\n", "bar", "baz\n"); chomp @x; \@x
evals/evals-freenode-#perl.lst[4125]: my $x = 'foo'; $x ||= do { print 'bar'; 'baz' }; [ $x ];
evals/evals-freenode-#perl.lst[4126]: my $x = 'foo'; $x &&= do { print 'bar'; 'baz' }; [ $x ];
evals/evals-freenode-#perl.lst[4127]: my @x; for (@x) { print "entered" } # unless you mean something other than running code inside the foreach loop?
evals/evals-freenode-#perl.lst[4128]: my $x; $_++ for ($x)x3; $x # two more examples
evals/evals-freenode-#perl.lst[4129]: my $x = 'Friseure'; [ map { $x =~ /e$/g; pos($x) } 1..10 ] # does this make it any clearer?
evals/evals-freenode-#perl.lst[4130]: my $x="from nm37.bullet.mail.ir2.yahoo.com (nm37.bullet.mail.ir2.yahoo.com [212.82.96.62])"; [ ($x =~ /[\w.]+/g)[-2, -1] ] # tharkun
evals/evals-freenode-#perl.lst[4131]: my $x = "Hello a and b"; $x =~ s/\b([ab])\b/$1 eq 'a' ? "l3u" : "rindolf"/ge; [$x]
evals/evals-freenode-#perl.lst[4132]: my $x = "Hello anna!" [($x eq "anna" ? "T" : "F"), ($x =~ /anna/ ? "T" : "F")]
evals/evals-freenode-#perl.lst[4133]: my $x = "Hello anna!"; [($x eq "anna" ? "T" : "F"), ($x =~ /anna/ ? "T" : "F")]
evals/evals-freenode-#perl.lst[4134]: my $x = "Hello "; $x .= "KNERD"; [$x]
evals/evals-freenode-#perl.lst[4135]: my $x = "hmm"; [ (my $tmp = $x, undef $x)[0] ]
evals/evals-freenode-#perl.lst[4136]: my $x = "hmm"; [ (my $tmp = $x; undef $x)[0] ]
evals/evals-freenode-#perl.lst[4137]: my $x = 'hmm'; [ ([$x]->[0], undef $x) ]
evals/evals-freenode-#perl.lst[4138]: my $x = 'hmm'; [ ([$x]->[0], undef $x)[0] ]
evals/evals-freenode-#perl.lst[4139]: my $x = 'hmm'; [ ("$x", undef $x)[0] ]
evals/evals-freenode-#perl.lst[4140]: my $x = 'hmm'; [ ($x, undef $x)[0] ]
evals/evals-freenode-#perl.lst[4141]: my $x = 'hmm'; [ [$x, undef $x]->[0] ]
evals/evals-freenode-#perl.lst[4142]: my $x = "Host: myHost\n";  my ($targetHost) = $heap->{buffer} =~ m#Host: (.*?)#; return $targetHost;
evals/evals-freenode-#perl.lst[4143]: my $x = []; if ($x) { print "a ref is true even when it refers to empty" }
evals/evals-freenode-#perl.lst[4144]: my $x = 'interpolates?'; qq'$x';
evals/evals-freenode-#perl.lst[4145]: my $x = 'interpolates?'; q"$x";
evals/evals-freenode-#perl.lst[4146]: my %x; local keys %x;
evals/evals-freenode-#perl.lst[4147]: my %x; local keys %x = "hi";
evals/evals-freenode-#perl.lst[4148]: my @x; local $x[0] = 42; "@x";
evals/evals-freenode-#perl.lst[4149]: my @x; local $x[0] = 42; @x;
evals/evals-freenode-#perl.lst[4150]: my @x; local $x[0] = 42; \@x;
evals/evals-freenode-#perl.lst[4151]: my @x = (map { $_ * 10 } 0 .. 9); [%x[3,6]]
evals/evals-freenode-#perl.lst[4152]: my @x = map { no strict qw(refs); $_; } 1..3; ### Why does this generate an error regarding the use of `no` ?
evals/evals-freenode-#perl.lst[4153]: my @x = map { qq{$_\n} } qw/ABC DEF 123 GHI/; join q{}, map { $_ x= !m!\d+!; } @x ;
evals/evals-freenode-#perl.lst[4154]: my @x = map rand(5), 1..10; [ map int(.5+$_), @x ]
evals/evals-freenode-#perl.lst[4155]: my @x = map rand(5), 1..40; [ map int(.5+$_), @x ]
evals/evals-freenode-#perl.lst[4156]: my @x = map /(\w+)/g, "some test line"; \@x; # Third time's the charm?
evals/evals-freenode-#perl.lst[4157]: my @x = map /^(\w+)/g, "some test line"; \@x; # This is what I meant.
evals/evals-freenode-#perl.lst[4158]: my @x = map /^(\w+)/m, "some test line"; \@x; # Passing flags can be useful.
evals/evals-freenode-#perl.lst[4159]: my @x = map /^(\w+)/, "some test line"; \@x; # yet another way to do it.
evals/evals-freenode-#perl.lst[4160]: my @x; my $line = "some test line"; push @x, $line =~ /^(\w+)/; print for @x; # another way to write the same thing
evals/evals-freenode-#perl.lst[4161]: [\(my $x, my $y)]
evals/evals-freenode-#perl.lst[4162]: my $x; my $y = 1..1; [ $x, $y ]; ### Why exactly does assigning a range in scalar context result in the lhs being an empty string (not undef) ?
evals/evals-freenode-#perl.lst[4163]: my $x = "" ; my $y; [ ($x // '') eq ($y // '') ]
evals/evals-freenode-#perl.lst[4164]: my $x = "\n"; [ $_ = chomp $x ]
evals/evals-freenode-#perl.lst[4165]: my $x = "\n"; [chomp($x);]
evals/evals-freenode-#perl.lst[4166]: my $x = "\n"; [chomp($x)]
evals/evals-freenode-#perl.lst[4167]: my $x = "\n"; chomp($x); print $x;
evals/evals-freenode-#perl.lst[4168]: my $x = "\n"; [ $x = chomp $x ]
evals/evals-freenode-#perl.lst[4169]: my $x = "\n"; [$x = chomp $x, $x]
evals/evals-freenode-#perl.lst[4170]: my $x = "\n"; $x = chomp $x; $x
evals/evals-freenode-#perl.lst[4171]: my $x = "\n"; $x = chomp($x); $x
evals/evals-freenode-#perl.lst[4172]: my @x = ("One", "Two", "Three"); [join(" ", @x)]
evals/evals-freenode-#perl.lst[4173]: my $x = pack('C*', map rand(128), 1..1e5); my ($index, $regex); my $start = time; 1 while $start == time; ++$start; index($x, "\\x"), ++$index while $start == time; ++$start; $x =~ /\\x/, ++$regex while $start == time; [ $index, $regex, $index / $regex, $regex / $index ];
evals/evals-freenode-#perl.lst[4174]: my $x = pack('C*', map rand(128), 1..1e5); my $reps = 0; my $start = time; 1 while $start==time;++$start; { index($x, "\x"); ++$reps; redo if $start == time }; [ $reps ]
evals/evals-freenode-#perl.lst[4175]: my $x = pack('C*', map rand(128), 1..1e5); my $reps = 0; my $start = time; 1 while $start==time;++$start; { $x =~ m/\\x/; ++$reps; redo if $start == time }; [ $reps ]
evals/evals-freenode-#perl.lst[4176]: my $x = pack 'C*', map rand(128), 1..1e5; my $start = time; my $y = index( $x, "\\x" ); [ time()-$start, $y ];
evals/evals-freenode-#perl.lst[4177]: my @x; push @x, foo(), foo(); { my $var = 0; sub foo { $var++ } } push @x, foo(), foo(); \@x
evals/evals-freenode-#perl.lst[4178]: my @x; push @x, qw( A B C ); unshift @x, qw( X Y Z ); \@x;
evals/evals-freenode-#perl.lst[4179]: my @x; push @x, /^(\w+)/ for 'test something'; \@x;
evals/evals-freenode-#perl.lst[4180]: my $x = q{abc}; !!$x;
evals/evals-freenode-#perl.lst[4181]: my $x = q{FOO\tBAR\r\n}; ( my $y = $x ) =~ s/\\t/\t/g; $y =~ s/\\r/\r/g; $y =~ s/\\n/\n/g; [ $x, $y ];
evals/evals-freenode-#perl.lst[4182]: my $x = q{}; int !!$x;
evals/evals-freenode-#perl.lst[4183]: my $x = qr/bar/; no overloading; "$x";
evals/evals-freenode-#perl.lst[4184]: my $x = qr/bar/; "$x"; # vs.
evals/evals-freenode-#perl.lst[4185]: my $x = qr/what does this do/x; "$x"
evals/evals-freenode-#perl.lst[4186]: my $x = qr/\w+/; [ $x, qr/$x/ ]; # Why can't dclone just handle Regexp objects like this?
evals/evals-freenode-#perl.lst[4187]: my $x = qr/x/; my $y = $x; [ $x, $y ];
evals/evals-freenode-#perl.lst[4188]: my @x = qw/1 2 3/; $_+=3 for @x; \@x
evals/evals-freenode-#perl.lst[4189]: my @x = qw/1 2 3 4/; delete $x[-1]; print $_ // '!' for @x;
evals/evals-freenode-#perl.lst[4190]: my @x = qw/1 2 3 4/; $x[-1] = undef; print $_ // '!' for @x;
evals/evals-freenode-#perl.lst[4191]: my @x = qw( @ A 1 B 2 C 3 ); foreach my $i ( 1 .. $#x ) { my ( $k, $v ) = ( $x[ $i ], $x[ $i++ + 1 ] ); print qq{$k => $v | }; }
evals/evals-freenode-#perl.lst[4192]: my @x = qw( @ A 1 B 2 C 3 ); for ( my $i = 1; $i < @x; $i++ ) { my ( $k, $v ) = ( $x[ $i ], $x[ $i++ + 1 ] ); print qq{$k => $v | }; }
evals/evals-freenode-#perl.lst[4193]: my @x = qw(a b c d d a b a c a c c c d e f g h); for(@x) { if($seen{$_}) { $_ = $_ . "_" . $seen{$_}++ } else { $seen{$_} = "aa" } } \@x # like this, or something else?
evals/evals-freenode-#perl.lst[4194]: my @x = qw(a b c d); delete $x[1]; print $_ // '!' for @x;
evals/evals-freenode-#perl.lst[4195]: my %x = qw(a b c d e f g h); [ @x{a, g} ]
evals/evals-freenode-#perl.lst[4196]: my %x = qw(a b c d e f g h); @y{a, g} = @x{a, g}; \%y
evals/evals-freenode-#perl.lst[4197]: my $x = [qw(a b c d e f g)]; [ keys @$x ] # it's available in both perl versions - 5.20 and 5.22
evals/evals-freenode-#perl.lst[4198]: my @x = ( qw( A B C ) ); { exists => [ map { exists $x[ $_ ] } 0..5 ], x => \@x };
evals/evals-freenode-#perl.lst[4199]: my @x = qw(a b c); splice @x, 1, 1; \@x # if you want to remove an element from the array, use splice, pop or shift
evals/evals-freenode-#perl.lst[4200]: my @x = qw(a b c); undef $x[1]; \@x # if you want to set a specific element to undef, use undef
evals/evals-freenode-#perl.lst[4201]: my $x = qw(a b c); $x # it's the list/scalar context that determines what you get
evals/evals-freenode-#perl.lst[4202]: my @x = qw(foo bar baz); my @y = 1..3; [ \(map {$_} @x, @y, 42) ]
evals/evals-freenode-#perl.lst[4203]: my @x = qw(foo bar baz); my @y = 1..3; [ \((@x, @y, 42)) ]
evals/evals-freenode-#perl.lst[4204]: my @x = qw(foo bar baz); my @y = 1..3; [ \(@x, @y, 42) ]
evals/evals-freenode-#perl.lst[4205]: my $x = () = qw(foo bar baz); $x
evals/evals-freenode-#perl.lst[4206]: my @x = qw/foo bar/; my $y = (123 => @x); $y # or the usual fun
evals/evals-freenode-#perl.lst[4207]: my @x = qw(x y z); my @y = do { push @x, my @x = q chic; @x }; [ \@x, \@y ]
evals/evals-freenode-#perl.lst[4208]: my @x = qw(zero one two); my ($idx) = grep $x[$_] eq 'two', 0 .. $#x; $idx
evals/evals-freenode-#perl.lst[4209]: my $x = q{}; !!$x;
evals/evals-freenode-#perl.lst[4210]: my $x = {}; [ q{}. $x, int $x ]
evals/evals-freenode-#perl.lst[4211]: my $x = []; ref \$x
evals/evals-freenode-#perl.lst[4212]: my @xs; bless \@xs, "hello world"; ref \@xs
evals/evals-freenode-#perl.lst[4213]: my $x :shared;
evals/evals-freenode-#perl.lst[4214]: my $x = '/somepath/subdir'; $y = '/newpath/newdir'; my $data = '/somepath/subdir/whatever.txt'; $data =~ s/\Q$x/$y/g; [ $data ]
evals/evals-freenode-#perl.lst[4215]: my $x = 'some test'; my $y = \substr($x, 5, 4); $$y = 'data'; $x
evals/evals-freenode-#perl.lst[4216]: my $x = "something"; qq/'" foo bar baz '" $x/
evals/evals-freenode-#perl.lst[4217]: my $x = 'some var'; my $y = $x =~ s/var/thing/r; [ $x, $y ]
evals/evals-freenode-#perl.lst[4218]: my @xs = qw/a b d z o l p a l/; [ keys %{{ @xs, reverse @xs }} ]
evals/evals-freenode-#perl.lst[4219]: my $x = sub (\@) { "$_[0]" }; my @a = (3, 4); print &$x(@a); ()
evals/evals-freenode-#perl.lst[4220]: my $x = sub (\@) { "$_[0]" }; my @a = (3, 4); $x->(@a)
evals/evals-freenode-#perl.lst[4221]: my $x; sub foo:lvalue { return $x } foo() = 123; $x;
evals/evals-freenode-#perl.lst[4222]: my $x; sub lala { \$x } [\$x, lala()] # identical
evals/evals-freenode-#perl.lst[4223]: my $x = sub ($) { @_ }; *x = $x; [ join ' ', $x->('a'..'c'), '|', x('a'..'c') ]
evals/evals-freenode-#perl.lst[4224]: my $x = 'test$blah'; $x =~ s#[^a-zA-Z0-9 ]##g; $x
evals/evals-freenode-#perl.lst[4225]: my $x = "test$blah"; $x =~ s#[^a-zA-Z0-9 ]##g; $x
evals/evals-freenode-#perl.lst[4226]: my $x = 'testing'; for ($x) { (sub { $_ = shift; return /firefox/ })->('...') } $x # no, probably not okay
evals/evals-freenode-#perl.lst[4227]: my $x = time; print $x;
evals/evals-freenode-#perl.lst[4228]: my $x = \undef; &Internals::SvREADONLY($x, 0); $$x = 3; [ undef ]
evals/evals-freenode-#perl.lst[4229]: my $x = \undef; &Internals::SvREADONLY($x, 0); $$x = Scalar::Util::dualvar 0, "lemons"; [ undef, defined undef ]
evals/evals-freenode-#perl.lst[4230]: my $x = \undef; &Internals::SvREADONLY($x, 0); $$x = Scalar::Util::dualvar 0, "lemons"; [ undef ] # maybe?
evals/evals-freenode-#perl.lst[4231]: my $x = unpack "b*", "this is a test"; $c
evals/evals-freenode-#perl.lst[4232]: my $x = unpack "b*", "this is a test"; $x
evals/evals-freenode-#perl.lst[4233]: my @x; [ @x[0..3] ]
evals/evals-freenode-#perl.lst[4234]: my $x = []; ["$x", 0+$x]
evals/evals-freenode-#perl.lst[4235]: my %x; $x[1] = 1;
evals/evals-freenode-#perl.lst[4236]: my %x; %x[1] = 1; # gives a syntax error
evals/evals-freenode-#perl.lst[4237]: my ($x, $x) = (1, 2); $x
evals/evals-freenode-#perl.lst[4238]: my %x; $x{a} = 4; @x{a} = (5); print $x{a}
evals/evals-freenode-#perl.lst[4239]: my %x; $x{a} = 4; @x{'a','b'} = (5); print $x{a}
evals/evals-freenode-#perl.lst[4240]: my $x; $x{abc} = 123; $x
evals/evals-freenode-#perl.lst[4241]: my $x; $x ||= do { print 'bar'; 'baz' }; [ $x ];
evals/evals-freenode-#perl.lst[4242]: my $x; $x &&= do { print 'bar'; 'baz' }; [ $x ];
evals/evals-freenode-#perl.lst[4243]: my $x = "X\n"; $x = chomp($x); [ "$^V : x=$x" ]
evals/evals-freenode-#perl.lst[4244]: my $x; $x->what_did_you_expect
evals/evals-freenode-#perl.lst[4245]: my @x; { ++$#x } \@x
evals/evals-freenode-#perl.lst[4246]: my $x; $x++; $x
evals/evals-freenode-#perl.lst[4247]: my $x = []; $x == \@$xs ? "yes" : "no"
evals/evals-freenode-#perl.lst[4248]: my $x; $x ? $x++ : ( $x = 1 ); $x;
evals/evals-freenode-#perl.lst[4249]: my $x = {}; $x->{x} = $x; $x
evals/evals-freenode-#perl.lst[4250]: my $x = []; $x == \@$x ? "yes" : "no"
evals/evals-freenode-#perl.lst[4251]: my ($x, $y) = 1..10;
evals/evals-freenode-#perl.lst[4252]: my ( $x, $y ) = ( 2733.754, 60 ); sprintf q{%.3f}, $x - int( $x/$y ) * $y;
evals/evals-freenode-#perl.lst[4253]: my ( $x, $y ) = ( 2733.754, 60 ); ( ( $x * 10000 ) - ( int($x/$y) * $y * 10000) ) / 10000; ### :)
evals/evals-freenode-#perl.lst[4254]: my ( $x, $y ) = ( 2733.754, 60 ); $x - int( $x/$y ) * $y; ### :)
evals/evals-freenode-#perl.lst[4255]: my ($x, $y) = 9..19;
evals/evals-freenode-#perl.lst[4256]: my $x->{y} = $x;
evals/evals-freenode-#perl.lst[4257]: my ($x, $y); ${'x'} = 123; ${'y'} = 456;  [ $x, $y ] # even typo fixes I can't see how that would ever work
evals/evals-freenode-#perl.lst[4258]: my $x = 'Zoffix'; substr($x, 2, 1) = 'ooooo'; $x
evals/evals-freenode-#perl.lst[4259]: my @y = 1..9; my $x = (map { $y[$_-1] += $y[$_] } reverse 1..$#y)[-1]; $x # death.
evals/evals-freenode-#perl.lst[4260]: my $y=1; my $x=\$y; ++$x; [$x, $y]
evals/evals-freenode-#perl.lst[4261]: my @y = ( 4, 5, 6 ); my $x = ( 0, @y[0 .. $#y] ); $x
evals/evals-freenode-#perl.lst[4262]: my @y = ( 4, 5, 6 ); my $x = ( 0, @y ); ### I thought that would work, but I see it interprets @y in ( 0, @y ) in scalar context, effectively being ( 0, 3 ) rather than ( 0, 4, 5, 6 )
evals/evals-freenode-#perl.lst[4263]: my @y = ( 4, 5, 6 ); my $x = @y; $x; ### Gives size of list instead, as expected here. Is there a way to get the last item in the list, similar to how the comma operator would, like above?
evals/evals-freenode-#perl.lst[4264]: my %y; my $x; \$x = \$y{x}; $x = 42; [ $x, \%y ]
evals/evals-freenode-#perl.lst[4265]: my %y; our $x; *x = \$y{x}; $x = 42; [ $x, \%y ]
evals/evals-freenode-#perl.lst[4266]: my $y = q{bar}; my @x = <A "B \\"foo $y baz\\" C" D>; print qq{$_\n} for @x; # Seems to do everything I've seen people over and over ask if qw() could do.
evals/evals-freenode-#perl.lst[4267]: my $y = q|foo{x,y,z}|; my @x = < $y >; \@x;
evals/evals-freenode-#perl.lst[4268]: my $y = q{x y z}; my @x = <A "B foo" C $y D "$y" E>; \@x; # Feels a little like bash.
evals/evals-freenode-#perl.lst[4269]: my @z = my $ret = my ($x, $y) = 9..19; [ $ret, $x, $y, \@z ]; # Basically just assigning $ret to @z, a la @z = $ret;
evals/evals-freenode-#perl.lst[4270]: my %args = {domain => "example.net", number => 0;};
evals/evals-freenode-#perl.lst[4271]: my $_ = "啊啊"; s/(.)/sprintf('\\u%04x', $1)/ger
evals/evals-freenode-#perl.lst[4272]: "\n" =~ /^$/
evals/evals-freenode-#perl.lst[4273]: ['\n']
evals/evals-freenode-#perl.lst[4274]: ["\n"]
evals/evals-freenode-#perl.lst[4275]: $n = 0; 5 / ($n || 1)
evals/evals-freenode-#perl.lst[4276]: $n=10;$==0,(1x$_)=~/^(1|11(??{}))*$(?{$=++})^/,print"$= "for 0..$n-1
evals/evals-freenode-#perl.lst[4277]: $n=10;$==0,(1x$_)=~/^(1|11(?{}))*$(?{$=++})^/,print"$= "for 0..$n-1
evals/evals-freenode-#perl.lst[4278]: $n=10;$==0,(1x$_)=~/^(1|11)*$(?{$=++})^/,print"$= "for 0..$n-1
evals/evals-freenode-#perl.lst[4279]: $n = 11111111113232323232 ; $d = $n << 32 >> 32 ; $d1 = ($n - $d) >> 32 ;  $r = pack("N",$d1) . pack("N",$d) ; print unpack("H*",$r) ."\n"
evals/evals-freenode-#perl.lst[4280]: $n = 232 ; $d = $n << 32 >> 32 ; $d1 = ($n - $d) >> 32 ;  $r = pack("N",$d1) . pack("N",$d) ; print unpack("H*",$r) ."\n"
evals/evals-freenode-#perl.lst[4281]: $n = 23342342342342342342 ; $d = $n << 32 >> 32 ; $d1 = ($n - $d) >> 32 ;  $r = pack("N",$d1) . pack("N",$d) ; print unpack("H*",$r) ."\n"
evals/evals-freenode-#perl.lst[4282]: $n = 42; $, = ' '; print ++$n, ++$n, ++$n, ++$n  # oh, really
evals/evals-freenode-#perl.lst[4283]: $n = 4; [ 'abcdefghi' =~ /c@{['(.)'x$n]}/ ]
evals/evals-freenode-#perl.lst[4284]: $n = 5; $n = $n++; $n
evals/evals-freenode-#perl.lst[4285]: $n = 5; $n = ++$n; $n
evals/evals-freenode-#perl.lst[4286]: $\="\n"; $_ = "ab"; print; $_++; print; $_+0; print; $_++; print
evals/evals-freenode-#perl.lst[4287]: $\="\n"; $_ = "ab"; print; $_++; print; $_+0; print; $_++; print; ()
evals/evals-freenode-#perl.lst[4288]: $! = 'NaN'; $!
evals/evals-freenode-#perl.lst[4289]: 'nan'/0
evals/evals-freenode-#perl.lst[4290]: NaN/0
evals/evals-freenode-#perl.lst[4291]: !!( "nan" <= 1.0 )
evals/evals-freenode-#perl.lst[4292]: "NaN" <=> "NaN"
evals/evals-freenode-#perl.lst[4293]: ("NaN" <=> "NaN") + 0
evals/evals-freenode-#perl.lst[4294]: 'na'x3^"\f"
evals/evals-freenode-#perl.lst[4295]: "\n" =~ /\A\z/
evals/evals-freenode-#perl.lst[4296]: "\N{BEER MUG}"
evals/evals-freenode-#perl.lst[4297]: "\nD" =~ /^D/m
evals/evals-freenode-#perl.lst[4298]: 'needs more :'
evals/evals-freenode-#perl.lst[4299]: $new = true; [$new, true]
evals/evals-freenode-#perl.lst[4300]: { next }
evals/evals-freenode-#perl.lst[4301]: { next if $x->{a}{b}; } [ $x ]
evals/evals-freenode-#perl.lst[4302]: "nickserv!nickserv@blah"
evals/evals-freenode-#perl.lst[4303]: "\N{INTERROBANG}" x 3 . "HELLO" . "\N{INTERROBANG}" x 3
evals/evals-freenode-#perl.lst[4304]: "\n" =~ /\n/
evals/evals-freenode-#perl.lst[4305]: [ "  \n   \n  \n   hello\n" =~ s/^\s*\n//r ]
evals/evals-freenode-#perl.lst[4306]: "  \n   \n  \nhello\n" =~ s/^\s*//sr
evals/evals-freenode-#perl.lst[4307]: $_ = "\n\nTAG\n\n\n"; s/\A\n+//; s/\n+\z/\n/; [ $_ ]
evals/evals-freenode-#perl.lst[4308]: no arybase;
evals/evals-freenode-#perl.lst[4309]: no autovivification 'delete'; delete $undef->{key}; $undef
evals/evals-freenode-#perl.lst[4310]: $nodes[5] = 1; \@nodes
evals/evals-freenode-#perl.lst[4311]: @nodeStatus = (0) * 150; \@nodeStatus
evals/evals-freenode-#perl.lst[4312]: @nodeStatus = (0) x 150; \@nodeStatus
evals/evals-freenode-#perl.lst[4313]: no feature ':all'; sub foo (;$) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \%h
evals/evals-freenode-#perl.lst[4314]: no feature ':all'; sub foo (;$$) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \%h
evals/evals-freenode-#perl.lst[4315]: no feature; no indirect 'fatal'; sub new { bless [] }; [ new {main} 1,2 ]
evals/evals-freenode-#perl.lst[4316]: no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new { bless [] }; [ new {main} ]
evals/evals-freenode-#perl.lst[4317]: no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new { bless [] }; [ new main ]
evals/evals-freenode-#perl.lst[4318]: no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new(*) { bless [] }; [ new main ]
evals/evals-freenode-#perl.lst[4319]: no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new { die @_ }; [ new {main} ]
evals/evals-freenode-#perl.lst[4320]: no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new { die @_ }; [ new {main} 1,2 ]
evals/evals-freenode-#perl.lst[4321]: no feature; no indirect; sub new { bless [] }; package foo; sub new(*) { bless [] }; [ new main ]
evals/evals-freenode-#perl.lst[4322]: no feature 'say'; open $fh, ">", \$str; say $fh $_ for qw,foo bar baz,; [ $str ]
evals/evals-freenode-#perl.lst[4323]: no feature 'say'; open $fh, ">", \$str; say($fh $_) for qw,foo bar baz,; [ $str ]
evals/evals-freenode-#perl.lst[4324]: no feature 'signatures'; sub foo (&@) { my ($code, @args) = @_; $code->(@args) } my $res = foo { [@_] } 1, 2, 3; $res
^[[Devals/evals-freenode-#perl.lst[4325]: no feature 'signatures'; sub foo (\@) { say @_ };  foo +(split //, "foobar")
evals/evals-freenode-#perl.lst[4326]: no feature 'signatures'; sub foo { [@_] } sub bar (\@) { [@_] } [foo(1,2,3), bar(1,2,3)]
evals/evals-freenode-#perl.lst[4327]: no feature 'signatures'; sub foo ($) { {thingy => $_[0]} } [foo 1, 2, 3]
evals/evals-freenode-#perl.lst[4328]: no feature 'signatures'; sub sort_subset_by (\@@) { my ($expected, @stuff) = @_; my %in = map { ($_ => 1) } @stuff; return grep { $in{$_} } @$expected; } my @exp = (5,4,3,2,1); my @arr = (2,3,4); [sort_subset_by @exp, @arr]
evals/evals-freenode-#perl.lst[4329]: no feature; sub new { bless [] }; package foo; sub new(*) { bless [] }; [ new main ]
evals/evals-freenode-#perl.lst[4330]: no feature 'unicode_strings'; my $d = my $u; utf8::upgrade($u); utf8::downgrade($d); [ map /\w/, $u, $d ]
evals/evals-freenode-#perl.lst[4331]: no feature 'unicode_strings'; my $d = my $u = "\x{df}"; utf8::upgrade($u); utf8::downgrade($d); [ map 0+/\w/, $u, $d ]
evals/evals-freenode-#perl.lst[4332]: no feature 'unicode_strings'; my $d = my $u = "\x{df}"; utf8::upgrade($u); utf8::downgrade($d); [ map /\w/, $u, $d ]
evals/evals-freenode-#perl.lst[4333]: no feature 'unicode_strings'; "\N{U+666}" =~ /\d/
evals/evals-freenode-#perl.lst[4334]: no indirect; parse backwards;
evals/evals-freenode-#perl.lst[4335]: no indirect; sub main { bless [] }; [ new main ]
evals/evals-freenode-#perl.lst[4336]: "No output."
evals/evals-freenode-#perl.lst[4337]: no overloading; '' . *STDOUT{IO};
evals/evals-freenode-#perl.lst[4338]: no 'strict'
evals/evals-freenode-#perl.lst[4339]: no strict; [ Foo ]
evals/evals-freenode-#perl.lst[4340]: no strict 'refs';  my $lexicalvar = "hello";  ${"lexicalvar"}
evals/evals-freenode-#perl.lst[4341]: no strict 'refs';  our $packagevar = "hello";  ${"packagevar"}
evals/evals-freenode-#perl.lst[4342]: no strict; sub Foo { "Bar" }; [ Foo ]
evals/evals-freenode-#perl.lst[4343]: no strict 'vars'; sub foo { local $n = $n//0; my @p = (shift, $n, $n ? 'N' : 'F'); ++$n; @_ ? (\@p, &foo) : \@p }; { 'one' => [foo('a'..'c')], 'two' => [foo('x'..'z')] };
evals/evals-freenode-#perl.lst[4344]: no strict 'vars'; sub foo { local $n = $n//0; my @p = [ shift, $n, $n ? 'N' : 'F' ]; ++$n; @_ ? [ @p, foo( @_ ) ] : \@p }; { 'one' => foo('a'..'c'), 'two' => foo('x'..'z') };
evals/evals-freenode-#perl.lst[4345]: no strict 'vars'; sub foo { local $n = $n//0; my @p = (shift, $n, $n ? 'N' : 'F'); @_ ? (@p, &foo) : @p }; { 'one' => [foo('a'..'c')], 'two' => [foo('x'..'z')] };
evals/evals-freenode-#perl.lst[4346]: no strict 'vars'; sub foo { local $n = $n//0; my @p = (shift, $n, $n ? 'N' : 'F'); @_ ? (\@p, &foo) : \@p }; { 'one' => [foo('a'..'c')], 'two' => [foo('x'..'z')] };
evals/evals-freenode-#perl.lst[4347]: [ No::Such::Class->import() ]
evals/evals-freenode-#perl.lst[4348]: { not => 'a block' }
evals/evals-freenode-#perl.lst[4349]: $nothing="a"; print "Nothing found\n" if $nothing !~ /^\w+/;
evals/evals-freenode-#perl.lst[4350]: $nothing=""; if ($nothing !~ /./) { print "Nothing found\n" }
evals/evals-freenode-#perl.lst[4351]: $nothing=""; print "Nothing found\n" if $nothing eq "";
evals/evals-freenode-#perl.lst[4352]: $nothing=""; print "Nothing found\n" if $nothing !~ /^\w+/;
evals/evals-freenode-#perl.lst[4353]: no utf8; encode 'UTF-8', 'Ã¡r jÃº sÃºr?'
evals/evals-freenode-#perl.lst[4354]: no utf8; printf "%vd", "ü"  # does this even work
evals/evals-freenode-#perl.lst[4355]: {no utf8; $x="☃☃☃" }; $x
evals/evals-freenode-#perl.lst[4356]: "no" while "no"
evals/evals-freenode-#perl.lst[4357]: "\N{PILE OF POO}"
evals/evals-freenode-#perl.lst[4358]: [ $., $NR ]
evals/evals-freenode-#perl.lst[4359]: "\N{REGIONAL INDICATOR SYMBOL LETTER Z}\N{REGIONAL INDICATOR SYMBOL LETTER A}"
evals/evals-freenode-#perl.lst[4360]: "\n\r\n"
evals/evals-freenode-#perl.lst[4361]: "\n" =~ /\s/
evals/evals-freenode-#perl.lst[4362]: "\n" =~ /(?[ \s - [\n] ])/ ? "match" : "no match"
evals/evals-freenode-#perl.lst[4363]: "\n" =~ (?[ \s - [\n] ]) ? "match" : "no match"
evals/evals-freenode-#perl.lst[4364]: "\N{SNOWMAN}"
evals/evals-freenode-#perl.lst[4365]: "\N{SPARKLE}"
evals/evals-freenode-#perl.lst[4366]: "\N{SPARKLE}";
evals/evals-freenode-#perl.lst[4367]: [ "\N{SPARKLE}" ]
evals/evals-freenode-#perl.lst[4368]: [ "\N{test}" ]
evals/evals-freenode-#perl.lst[4369]: "\N{U+00A2}"
evals/evals-freenode-#perl.lst[4370]: "\N{U+0B}" =~ /(?[ \s - [\n] ])/ ? "match" : "no match"
evals/evals-freenode-#perl.lst[4371]: "\N{U+1f52b}"
evals/evals-freenode-#perl.lst[4372]: "\N{U+666}" =~ /\d/
evals/evals-freenode-#perl.lst[4373]: $num = 0b00000011111111111111111111111111; [vec($num, 0, 26), vec($num, 26, 6)]
evals/evals-freenode-#perl.lst[4374]: $num = -1.67; int($num + $num / abs($num * 2));
evals/evals-freenode-#perl.lst[4375]: $num = 1; "banana" =~ s/a/$num++/ger
evals/evals-freenode-#perl.lst[4376]: $num = 1; "banana" =~ s/a/"test: ${\$num++}"/ger
evals/evals-freenode-#perl.lst[4377]: $num = 1; "banana" =~ s/a/"test: $num++"/ger
evals/evals-freenode-#perl.lst[4378]: $num = 1; "banana" =~ s/a/test: $num++/ger
evals/evals-freenode-#perl.lst[4379]: $num=2**32; $digits=reverse $num; $digits =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g; $num=reverse $digits; print $num
evals/evals-freenode-#perl.lst[4380]: $num=2**32; $digits=reverse $num; $digits =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g; print $digits;
evals/evals-freenode-#perl.lst[4381]: $num='2**32'; $digits=reverse $num; $digits =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g; print reverse $digist;
evals/evals-freenode-#perl.lst[4382]: $num='2**32'; $digits=reverse $num; $digits =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g; print reverse $digits;
evals/evals-freenode-#perl.lst[4383]: $num=2**32; $digits=reverse $num; $digits =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g; print reverse $digits;
evals/evals-freenode-#perl.lst[4384]: $num="2"; $num = sprintf("%02d", $num); print $num
evals/evals-freenode-#perl.lst[4385]: $num="2"; $num = sprintf("%2d", $num); print $num
evals/evals-freenode-#perl.lst[4386]: @nums = (30, 7, 200, 40, 5, 1000); [ [ sort @nums ], [ sort { $a <=> $b } @nums ] ] # string-sort using default cmp vs numeric <=>
evals/evals-freenode-#perl.lst[4387]: "\N{VERTICAL TAB}" =~ /(?[ \s - [\n] ])/ ? "match" : "no match"
evals/evals-freenode-#perl.lst[4388]: "\N{VT}" =~ /(?[ \s - [\n] ])/ ? "match" : "no match"
evals/evals-freenode-#perl.lst[4389]: "\n" =~ /^/ ? 'y' : 'n'
evals/evals-freenode-#perl.lst[4390]: "\n" =~ /^$/ ? 'y' : 'n'
evals/evals-freenode-#perl.lst[4391]: "\n" =~ /^\z/ ? 'y' : 'n'
evals/evals-freenode-#perl.lst[4392]: $^O
evals/evals-freenode-#perl.lst[4393]: $obj->generic_method();
evals/evals-freenode-#perl.lst[4394]: @occ = 'xxx hihi.so yyy hoho.so' =~ /\w+\.so/g; \@occ
evals/evals-freenode-#perl.lst[4395]: [ oct "0.00_02" ]
evals/evals-freenode-#perl.lst[4396]: oct '0775'
evals/evals-freenode-#perl.lst[4397]: oct '0a'
evals/evals-freenode-#perl.lst[4398]: oct "0b0100100"
evals/evals-freenode-#perl.lst[4399]: [ oct(0b10),oct(0x2),hex(0b10) ]
evals/evals-freenode-#perl.lst[4400]: oct(0b11111);
evals/evals-freenode-#perl.lst[4401]: oct '0b' . '11111111'
evals/evals-freenode-#perl.lst[4402]: oct '0b' . ('1' x 64)
evals/evals-freenode-#perl.lst[4403]: oct "0x10"
evals/evals-freenode-#perl.lst[4404]: [ oct "0x10", hex "010" ]
evals/evals-freenode-#perl.lst[4405]: [ oct "0xa" ]
evals/evals-freenode-#perl.lst[4406]: oct "10"
evals/evals-freenode-#perl.lst[4407]: [ oct "10_00" ]
evals/evals-freenode-#perl.lst[4408]: oct "1_2"
evals/evals-freenode-#perl.lst[4409]: oct "1.2e3"
evals/evals-freenode-#perl.lst[4410]: oct("420)"
evals/evals-freenode-#perl.lst[4411]: oct "4e3"
evals/evals-freenode-#perl.lst[4412]: $_='oh turtleneck
evals/evals-freenode-#perl.lst[4413]: $_='oh turtleneck phrase jar!'; s/.{13}\K.*//s; print;
evals/evals-freenode-#perl.lst[4414]: $_='oh turtleneck phrase jar!'; s/(?<=.{13}).*//; print
evals/evals-freenode-#perl.lst[4415]: $_='oh turtleneck phrase jar!'; s/(?<=.{13}).*//s; print
evals/evals-freenode-#perl.lst[4416]: $_='oh turtleneck phrase jar!'; s/(?<=.{13}).*//s; print;
evals/evals-freenode-#perl.lst[4417]: $_ = "Oh Turtleneck Phrase Jar";  s/(.)/rand(3)>1?lc($1):uc($1)/ge; $_
evals/evals-freenode-#perl.lst[4418]: $_ = "Oh Turtleneck Phrase Jar";  s/(.)/rand(3)?lc($1):uc($1)/ge; $_
evals/evals-freenode-#perl.lst[4419]: $_='oh turtleneck phrase jar!'; s/(?<=\w{13}).*//s; print;
evals/evals-freenode-#perl.lst[4420]: $old = 'abc'; $new = substr($old, 0) = ''; [$old, $new]
evals/evals-freenode-#perl.lst[4421]: $old = 'abc'; $new = substr($old) = ''; [$old, $new]
evals/evals-freenode-#perl.lst[4422]: \@ONC
evals/evals-freenode-#perl.lst[4423]: $_ = "one=1 two=2 three=3"; [ m/(\w+)=(\d+)/gc ]
evals/evals-freenode-#perl.lst[4424]: $_ = "one=1 two=2 three=3"; print $1 while m/(\w+)=(\d+)/gc
evals/evals-freenode-#perl.lst[4425]: $one = 'foobar'; $two = "foobazquux"; $count = () = $one.$two =~ /[$one$two]/g
evals/evals-freenode-#perl.lst[4426]: $one = 'foobar'; $two = "foobazquux"; $count = () = ($one.$two) =~ /[\Q$one$two\E]/g
evals/evals-freenode-#perl.lst[4427]: $one = 'foobar'; $two = "foobazquux"; $count = () = $one.$two =~ /[\Q$one$two\E]/g
evals/evals-freenode-#perl.lst[4428]: $one = 'foobar'; $two = "foobazquux"; $count = () = $two =~ /[$one]/g
evals/evals-freenode-#perl.lst[4429]: $one = "foobar"; $two = "foobazquux"; $i++ while substr($one, $i, 1) eq substr($two, $i, 1); $i
evals/evals-freenode-#perl.lst[4430]: $_ = "one\ntwo\nthree some text four\nfive\n"; [ /(.*some text.*)/ ]
evals/evals-freenode-#perl.lst[4431]: ["one two " =~ /(one (two)) (three)?/]
evals/evals-freenode-#perl.lst[4432]: $_ = 'one.two.three'; [ /(.*)\./ ]
evals/evals-freenode-#perl.lst[4433]: $_ = "one two three"; %h = ( one => 1, two => 2 ); s/$_/$h{$_}/ for keys %h; $_
evals/evals-freenode-#perl.lst[4434]: $_ = "one two three"; %h = ( one => 1, two => 2 ); s/$_/$h{$_}/ for keys %h; $_"
evals/evals-freenode-#perl.lst[4435]: ["one two three" =~ /(one (two)) (three)/]
evals/evals-freenode-#perl.lst[4436]: $_ = 'one two two three'; $_ =~ s/^.*?two//; $_
evals/evals-freenode-#perl.lst[4437]: 'one two two three' =~ 's/^.*?two//r
evals/evals-freenode-#perl.lst[4438]: 'one two two three' =~ s/^.*?two//r
evals/evals-freenode-#perl.lst[4439]: [ $^O ] # of course perlbot runs on a massively-distributed network with lots of nodes so the result here may vary
evals/evals-freenode-#perl.lst[4440]: "O.O" =~ s/\./_/r
evals/evals-freenode-#perl.lst[4441]: [ ${^OPEN} ]
evals/evals-freenode-#perl.lst[4442]: open(2, "|df -h")
evals/evals-freenode-#perl.lst[4443]: [ 'openerp-server' =~ m{/([^/]+)$} ]
evals/evals-freenode-#perl.lst[4444]: open $fh, ">", \$str; say($fh 'asdf'); [ $str ]
evals/evals-freenode-#perl.lst[4445]: open $fh, ">", \$str; say($fh $_) for qw,foo bar baz,; [ $str ]
evals/evals-freenode-#perl.lst[4446]: open FILE, "<", "/etc/passwdoeuoe"; print <FILE>
evals/evals-freenode-#perl.lst[4447]: open FILE, "<", "/etc/passwd"; print <FILE>
evals/evals-freenode-#perl.lst[4448]: open $f, "<", "/proc/self/mountinfo"; fileno($f)
evals/evals-freenode-#perl.lst[4449]: open(F,"/usr/share/dict/words");@w=<F>;close(F); $r=rand($#w++); print $r
evals/evals-freenode-#perl.lst[4450]: open(F,"/usr/share/dict/words");@w=<F>;close(F); $r=rand($#w++); print $w[$r]
evals/evals-freenode-#perl.lst[4451]: open(F,"/usr/share/dict/words");@w=<F>;close(F); $r=rand($#w++); $w[$r]
evals/evals-freenode-#perl.lst[4452]: open my $fh, \$altreus; print $fh "I hate you";
evals/evals-freenode-#perl.lst[4453]: open my @fh, '<', '/dev/zero' or die $!; \@fh
evals/evals-freenode-#perl.lst[4454]: open my $fh, '>', \my $buffer; ref $fh
evals/evals-freenode-#perl.lst[4455]: open my $fh, '>', \my $foo or die $!; [$fh, $fh->isa("GLOB"), ref $fh]
evals/evals-freenode-#perl.lst[4456]: open my $fh, '>', \my $foo or die $!; [$fh, $fh->isa("GLOB"), ref $fh, \@GLOB::ISA]
evals/evals-freenode-#perl.lst[4457]: open my $fh, '>', \my $foo or die $!; print ref $fh;
evals/evals-freenode-#perl.lst[4458]: open my $fh , '>', \my $str; [ '' . *$fh{IO} ]
evals/evals-freenode-#perl.lst[4459]: open my $fh , '>', \my $str; [ *$fh{IO} ]
evals/evals-freenode-#perl.lst[4460]: open my $fh , '>', \my $str; [ ref *$fh{IO} ]
evals/evals-freenode-#perl.lst[4461]: open my $fh , q{>}, \(my $str); say $fh q{foo}; [ ref $fh ];
evals/evals-freenode-#perl.lst[4462]: open my($fh), "<", "some file which doesn't exist"; [ $! + 0, "" . $! ]
evals/evals-freenode-#perl.lst[4463]: open my($fh), "<", "some file which doesn't exist"; [ 0 + $!, "" . $! ]
evals/evals-freenode-#perl.lst[4464]: open my $fh, '<', \"xyzwtu"; my $s = "abc"; read $fh, $s, 4, 3; $s
evals/evals-freenode-#perl.lst[4465]: open my $lol, '<', 'lol'; <$lol>
evals/evals-freenode-#perl.lst[4466]: open my $lol, '>', 'lol'; $lol->print("lol");
evals/evals-freenode-#perl.lst[4467]: open( my $ofh, q{>}, q{/tmp/abc.txt} ) or die qq{write: $!}; print $ofh q{abcdefghijklmnopqrstuvwxyz}; close $ofh; open( my $ifh, q{<}, q{/tmp/abc.txt} ) or die qq{read: $!}; my $count = read $ifh, my $chunk, 10, 5; close $ifh; [ $count, $chunk ];
evals/evals-freenode-#perl.lst[4468]: open $out2, '>&=', 2 or warn ">$!<"; $out2->autoflush(1); "".$out2
evals/evals-freenode-#perl.lst[4469]: open undef
evals/evals-freenode-#perl.lst[4470]: [ $^O ] # perldoc -v '$^O' for details
evals/evals-freenode-#perl.lst[4471]: ord '«'
evals/evals-freenode-#perl.lst[4472]: ord '£'
evals/evals-freenode-#perl.lst[4473]: ord '*'
evals/evals-freenode-#perl.lst[4474]: ord '☃'
evals/evals-freenode-#perl.lst[4475]: ord "'"
evals/evals-freenode-#perl.lst[4476]: ord('/')
evals/evals-freenode-#perl.lst[4477]: ord(".")
evals/evals-freenode-#perl.lst[4478]: [ ord "⁰", ord "⁹" ]
evals/evals-freenode-#perl.lst[4479]: [ord "²"]
evals/evals-freenode-#perl.lst[4480]: ord 'a'
evals/evals-freenode-#perl.lst[4481]: ord 'A'
evals/evals-freenode-#perl.lst[4482]: ord('a')^ord('A')
evals/evals-freenode-#perl.lst[4483]: ord chr 0xe9
evals/evals-freenode-#perl.lst[4484]: (ord chr 0xe9) == 0xe9
evals/evals-freenode-#perl.lst[4485]: ord chr 0xe9 == 0xe9
evals/evals-freenode-#perl.lst[4486]: or deparse:?
evals/evals-freenode-#perl.lst[4487]: $#order = 2; $#order
evals/evals-freenode-#perl.lst[4488]: @order = 2; @order and @order = grep $_, @order[-2, -1]
evals/evals-freenode-#perl.lst[4489]: $#order = 2; @order and @order = grep $_, @order[-2,-1]
evals/evals-freenode-#perl.lst[4490]: $#order = 2; @order and order = grep $_, @order[-2,-1];
evals/evals-freenode-#perl.lst[4491]: @order and @order = grep $_, @order[-2, -1]
evals/evals-freenode-#perl.lst[4492]: ... or die
evals/evals-freenode-#perl.lst[4493]: ord "\n"
evals/evals-freenode-#perl.lst[4494]: [ord '~', ord ' ']
evals/evals-freenode-#perl.lst[4495]: [ord '.', ord '[']
evals/evals-freenode-#perl.lst[4496]: ord('/') - ord('+')
evals/evals-freenode-#perl.lst[4497]: ord pack 'A', 32
evals/evals-freenode-#perl.lst[4498]: ord pack "B8", "11111110"
evals/evals-freenode-#perl.lst[4499]: ord(split '',a..m=>N..Z)-7
evals/evals-freenode-#perl.lst[4500]: [ord 'ß']
evals/evals-freenode-#perl.lst[4501]: ord unpack 'A', 32
evals/evals-freenode-#perl.lst[4502]: ord "\xFE"
evals/evals-freenode-#perl.lst[4503]: ord 'й'
evals/evals-freenode-#perl.lst[4504]: or evaljs:
evals/evals-freenode-#perl.lst[4505]: $original = "hello"; [ $coded = $original ^ '1' x length $original, $coded ^ '1' x length $coded ]
evals/evals-freenode-#perl.lst[4506]: $_="otmat"; /(?{$name="foo"})re[x]ma|(?{$name="bar"})o[ther]matc/; $name
evals/evals-freenode-#perl.lst[4507]: our $AUTOLOAD = 'cats'; sub cats { "lol" } notlol()
evals/evals-freenode-#perl.lst[4508]: our $baz = 'abc'; package foo; sub bar { our $baz; return ++$baz }; package main; [ foo::bar(), foo::bar(), $foo::baz, $baz ]
evals/evals-freenode-#perl.lst[4509]: { our $baz = 'abc'; package foo; sub bar { our $baz; return ++$baz }; }; package thisfails; [ foo::bar(), foo::bar(), $foo::baz, $baz ]
evals/evals-freenode-#perl.lst[4510]: our $baz = 'abc'; package foo; sub bar { our $baz; return ++$baz }; package thisfails; [ foo::bar(), foo::bar(), $foo::baz, $baz ]
evals/evals-freenode-#perl.lst[4511]: our $descriptivism++;
evals/evals-freenode-#perl.lst[4512]: our $DIR; BEGIN { $DIR = 'BAR' } say $DIR;
evals/evals-freenode-#perl.lst[4513]: our %foo = 1 .. 2; *foo->{1}
evals/evals-freenode-#perl.lst[4514]: our %foo = 1, 2; (\*foo)->{HASH}
evals/evals-freenode-#perl.lst[4515]: our %foo = 1, 2; *foo{HASH}
evals/evals-freenode-#perl.lst[4516]: { our $foo = 5;} eval { $foo }; { our $foo . $@ }
evals/evals-freenode-#perl.lst[4517]: our $n = 0; sub foo { local $n = $n; my @p = [ shift, $n ? 'N' : 'F' ]; ++$n; @_ ? do { @p, foo( @_ ) } : \@p }; { 'one' => foo('a'..'c'), 'two' => foo('x'..'z') };
evals/evals-freenode-#perl.lst[4518]: our $n = 0; sub foo { local $n = $n; my @p = [ shift, $n ? 'N' : 'F' ]; ++$n; @_ ? do { @p, foo( @_ ) } : \@p }; { one => foo('a'..'c'), two => foo('x'..'z') };
evals/evals-freenode-#perl.lst[4519]: our $n = 0; sub foo { local $n = $n; my @p = [ shift, $n ? 'N' : 'F' ]; ++$n; @_ ? [ @p, foo( @_ ) ] : \@p }; { 'one' => foo('a'..'c'), 'two' => foo('x'..'z') };
evals/evals-freenode-#perl.lst[4520]: our $n = 0; sub foo { local $n = $n; my @p = [ shift, $n, $n ? 'N' : 'F' ]; ++$n; @_ ? [ @p, foo( @_ ) ] : \@p }; { 'one' => foo('a'..'c'), 'two' => foo('x'..'z') };
evals/evals-freenode-#perl.lst[4521]: our sub Bulgaria { print caller; } package Wimbledon; Bulgaria()
evals/evals-freenode-#perl.lst[4522]: our $varname = "womble"; ${$varname} = "Bulgaria"; print "Uncle $womble"
evals/evals-freenode-#perl.lst[4523]: our $x = "\
evals/evals-freenode-#perl.lst[4524]: { our $x = "dogs" } { our $x; print $x }
evals/evals-freenode-#perl.lst[4525]: our $x="\n"; $x = chomp $x; $x
evals/evals-freenode-#perl.lst[4526]: our $x = 'package'; my $x = 'lexical'; { our $x; print $x }
evals/evals-freenode-#perl.lst[4527]: our $x; sub lala { \$x } [\$x, lala()] # also identical
evals/evals-freenode-#perl.lst[4528]: our %y; our $x = 5; *{y{x}} = *x; $y = 3; [ $x, \%y ]; ### I saw this in some code I was reviewing, which I think was someone trying to alias a hash key to a variable, similar to *x = *y, but it doesn't seem t owork (maybe for an old Perl?)
evals/evals-freenode-#perl.lst[4529]: @output=`df -h`; for my $line (@output){ print $line if $line =~ /procfs/ }
evals/evals-freenode-#perl.lst[4530]: [ overload::Overloaded( 'Regexp' ) ]
evals/evals-freenode-#perl.lst[4531]: [ overload::Overloaded( v1.2.3 ) ]
evals/evals-freenode-#perl.lst[4532]: [ overload::Overloaded( 'version' ) ]
evals/evals-freenode-#perl.lst[4533]: overload::StrVal bless {}, "Whatevs"
evals/evals-freenode-#perl.lst[4534]: %p = (1,2); @array = values %p; s/\d// for @array; \%p
evals/evals-freenode-#perl.lst[4535]: %p = (1,2); s/\d// for keys %p
evals/evals-freenode-#perl.lst[4536]: %p = (1,2); s/\d// for keys %p; \%p
evals/evals-freenode-#perl.lst[4537]: %p = (1,2); s/\d// for values %p; \%p
evals/evals-freenode-#perl.lst[4538]: $P2::x = "P2"; package P1; our $x = "P1"; package P2; $x
evals/evals-freenode-#perl.lst[4539]: $P2::x = "P2"; package P1; $x = "P1"; package P2; $x
evals/evals-freenode-#perl.lst[4540]: pack "a", 0x32;
evals/evals-freenode-#perl.lst[4541]: pack "a", 0x33;
evals/evals-freenode-#perl.lst[4542]: pack '(a)*', 123456 =~ /.(.)(?<=(.).)/g
evals/evals-freenode-#perl.lst[4543]: pack 'a', 32
evals/evals-freenode-#perl.lst[4544]: pack 'A', 32
evals/evals-freenode-#perl.lst[4545]: pack 'a', 48
evals/evals-freenode-#perl.lst[4546]: __PACKAGE__
evals/evals-freenode-#perl.lst[4547]: [ __PACKAGE__ ]
evals/evals-freenode-#perl.lst[4548]: package A; sub new { bless {}, ref $_[0] || $_[0]; } sub foo { [ $_[0], q{A:111} ]; } package B; our @ISA = qw(A); package C; our @ISA = qw(A); package D; our @ISA = qw(B C); package main; my $d = D->new; [ $d->foo, $d->B::foo, $d->C::foo, $d->A::foo ];
evals/evals-freenode-#perl.lst[4549]: package A; sub new { bless {}, ref $_[0] || $_[0]; } sub foo { [ $_[0], q{A:111} ]; } package B; our @ISA = qw(A); sub foo { [ $_[0], q{B:222} ]; } package C; our @ISA = qw(A); sub foo { [ $_[0], q{C:333} ]; } package D; our @ISA = qw(B C); package main; my $d = D->new; [ $d->foo, $d->B::foo, $d->C::foo, $d->A::foo ];
evals/evals-freenode-#perl.lst[4550]: package A; sub x { q{A::x}; } package B; sub x { q{B::x}; } package C; sub x { q{C::x}; } package main; [ map { $_->can( q{x} )->() } qw(A B C) ]; ### litewait
evals/evals-freenode-#perl.lst[4551]: package Blah { sub foo { print "eh" } } Blah::foo()
evals/evals-freenode-#perl.lst[4552]: package Blah { sub foo { print "eh" } } foo()
evals/evals-freenode-#perl.lst[4553]: package Cats; our $meow; our $mewl = '>:('; package main; \%Cats::
evals/evals-freenode-#perl.lst[4554]: package Cats; our $meow; package main; \%Cats::
evals/evals-freenode-#perl.lst[4555]: package C; sub new { bless {}, ref $_[0] || $_[0] } package main; my $foo = sub { [ @_ ] }; my $c = C->new; $c->$foo( 1..3 );
evals/evals-freenode-#perl.lst[4556]: package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; \&foo;
evals/evals-freenode-#perl.lst[4557]: package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; $c->(\&foo)->( 1..3 );
evals/evals-freenode-#perl.lst[4558]: package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; $c->(\&foo)( 1..3 );
evals/evals-freenode-#perl.lst[4559]: package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; $c->${\\&foo}( 1..3 );
evals/evals-freenode-#perl.lst[4560]: package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; $c->\&foo( 1..3 );
evals/evals-freenode-#perl.lst[4561]: package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; my $name = "foo"; $c->$name( 1..3 );
evals/evals-freenode-#perl.lst[4562]: package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; my $ref = \&foo; $c->$ref( 1..3 );
evals/evals-freenode-#perl.lst[4563]: package C; sub new { bless {}, ref $_[0] || $_[0] } sub foo { 111 }; package main; my $o = \&C::foo; { no warnings qw/redefine/; *C::foo = sub { 222 }; } my $c = C->new; [ qq{$o}, q{}.\&C::foo, $c->foo, $c->$o ];
evals/evals-freenode-#perl.lst[4564]: package C; sub new { bless {}, ref $_[0] || $_[0] } sub foo { 111 }; package main; my $o = \&C::foo; undef &C::foo; *C::foo = sub { 222 }; my $c = C->new; [ qq{$o}, q{}.\&C::foo, $c->foo, $c->$o ];
evals/evals-freenode-#perl.lst[4565]: { package damnit; sub a { "" } } tr/// for a damnit
evals/evals-freenode-#perl.lst[4566]: package dedicated::dedicated.fr {}
evals/evals-freenode-#perl.lst[4567]: package Don; sub t { 'cats' } package main; Don't;
evals/evals-freenode-#perl.lst[4568]: package DudeUseMoo { sub moot { bless {} } } $m = DudeUseMoo->moot; $m->{asdf} = 'blah'; $m->{asdf}
evals/evals-freenode-#perl.lst[4569]: package DudeUseMoo { sub moot { bless {} } sub whurble { my $self=shift; $self->{asdf} } } $m = DudeUseMoo->moot; $m->{asdf} = 'blah'; $m->whurble
evals/evals-freenode-#perl.lst[4570]: { package FF; sub TIESCALAR { my ($c, $v) = @_; bless \$v, $c } sub FETCH { my $v = ${$_[0]}; ${$_[0]} = -${$_[0]}; $v } } sub frob :lvalue { my ($v) = @_; tie $v, "FF", $v; $v } sub List::Util::0sum {my ($a, $b)=(0,0); $a+=$_, $b-=$_ for @_; ($a, $b)}; [List::Util::0sum(map frob($_), 1,2,3,4,5)]
evals/evals-freenode-#perl.lst[4571]: package Foo 1.0; 'how long has that <-- with the version, worked?'
evals/evals-freenode-#perl.lst[4572]: package foo; $bar = 1; package quux; print $main::foo::bar;
evals/evals-freenode-#perl.lst[4573]: package foo; our $AUTOLOAD; sub AUTOLOAD {print "The method called was: $AUTOLOAD"}; package main; foo->gooblegobble();
evals/evals-freenode-#perl.lst[4574]: package foo { our $bar = 'baz' } ["blah $foo::bar"]
evals/evals-freenode-#perl.lst[4575]: package Foo; our $foo = 42; package main; my $z = 'Foo';  \%{$x}::
evals/evals-freenode-#perl.lst[4576]: package Foo: our $var;  package Splot; $var = 3; print $Foo::var;
evals/evals-freenode-#perl.lst[4577]: { package Foo; our $x = "foo"; package Bar; $x = "bar"; } [ $Foo::x, $Bar::x ]
evals/evals-freenode-#perl.lst[4578]: package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );  $x->can($foo{bar})->()
evals/evals-freenode-#perl.lst[4579]: package foo; sub bar { 'ok' }; package main; use base 'foo'; [ main->SUPER::bar ];
evals/evals-freenode-#perl.lst[4580]: package foo; sub bar { 'ok' }; package main; use base 'foo'; package other; [ main->SUPER::bar ];
evals/evals-freenode-#perl.lst[4581]: package foo; sub bar { our $baz; "[". ++$baz . "]" }; [ bar(), bar(), $baz ]
evals/evals-freenode-#perl.lst[4582]: package foo; sub bar { our $baz; "[". ++$baz . "]" }; [ bar(), bar(), $foo::baz ]
evals/evals-freenode-#perl.lst[4583]: package foo; sub bar { our $baz; package fizzbuz; "[". ++$baz . "]" }; [ bar(), bar(), $baz ]
evals/evals-freenode-#perl.lst[4584]: package foo; sub bar { our $baz; print ++$baz }; [ bar(), bar(), $foo::baz ]
evals/evals-freenode-#perl.lst[4585]: package foo; sub bar { our $baz; print ++$baz }; print bar(); print bar(); print $foo::baz;
evals/evals-freenode-#perl.lst[4586]: package foo; sub bar { our $baz; return ++$baz }; [ bar(), bar(), $foo::baz ]
evals/evals-freenode-#perl.lst[4587]: { package Foo; sub DESTROY {} } sub bar; bar Foo;
evals/evals-freenode-#perl.lst[4588]: { package Foo; sub DESTROY {} } sub bar; bar Foo 1;
evals/evals-freenode-#perl.lst[4589]: package Foo; sub d { return "lala" } package main; my $c = bless {}, 'Foo'; $c->d()
evals/evals-freenode-#perl.lst[4590]: package foo; sub new {[1]} package bar; foo->new
evals/evals-freenode-#perl.lst[4591]: package Foo; sub new { bless [], shift } package main; my $sub = sub { my $self = shift; "$self" }; my $obj = Foo->new; $obj->$sub  # lawrence_
evals/evals-freenode-#perl.lst[4592]: package Foo { sub new { bless {}, shift } sub bar { [@_] } } [Foo::bar(1,2,3), Foo->bar(1,2,3), Foo->new->bar(1,2,3)]
evals/evals-freenode-#perl.lst[4593]: package Foo { sub new { my $self = shift; bless {@_}, $self } } my $foo = Foo->new(key => 'value'); $foo->{key};
evals/evals-freenode-#perl.lst[4594]: package Foo { sub new { my $self = shift; bless {@_}, $self } sub get_key { my $self = shift; return $self->{+shift} } } my $foo = Foo->new(key => 'value'); $foo->get_key('key'); # with an accessor method
evals/evals-freenode-#perl.lst[4595]: package Foo; sub x { \@ARGV; } package main; @ARGV = qw( A B C ); Foo::x;
evals/evals-freenode-#perl.lst[4596]: package Foo; sub x { \@main::ARGV; } package main; @ARGV = qw( A B C ); Foo::x;
evals/evals-freenode-#perl.lst[4597]: package Foo; use overload 'bool' => sub { 0 }; sub new { bless {}, shift }; package main; Foo->new() ? 't' : 'f'
evals/evals-freenode-#perl.lst[4598]: package Foo; use overload q{""} => sub {42 }; package main; my $x = bless {}, 'Foo'; 'foo'->$x
evals/evals-freenode-#perl.lst[4599]: package Foo; use overload q{""} => sub {42 }; package main; my $x = bless sub{ 45 }, 'Foo'; [ 'foo'->$x // 'z', "$x" //'z' ]
evals/evals-freenode-#perl.lst[4600]: package Foo; use warnings; sub foo { undef()+0 }; package main; ${Foo::^WARNING_BITS}=0; Foo::foo();
evals/evals-freenode-#perl.lst[4601]: package Foo; use warnings; sub foo { undef()+0 }; package main; $Foo::{^WARNING_BITS}=0; Foo::foo();
evals/evals-freenode-#perl.lst[4602]: package Foo; use warnings; sub foo { undef()+0 }; package main; no warnings; Foo::foo();
evals/evals-freenode-#perl.lst[4603]: package Foo; use warnings; sub foo { undef()+0 }; package main; { package Foo; no warnings; Foo::foo(); use warnings; }
evals/evals-freenode-#perl.lst[4604]: package Foo; use warnings; sub foo { undef()+0 }; package main; $SIG{__WARN__}=sub{}; Foo::foo();
evals/evals-freenode-#perl.lst[4605]: { package Foo; $x = "foo"; package Bar; $x = "bar"; } [ $Foo::x, $Bar::x ]
evals/evals-freenode-#perl.lst[4606]: [ __PACKAGE__, __FUNCTION__ ]
evals/evals-freenode-#perl.lst[4607]: package ImARegex; sub match { $_[1] =~ $_[0] ? 1 : 0 } package main; my $re = qr/hai/; bless $re, 'ImARegex'; $re->match('chair')
evals/evals-freenode-#perl.lst[4608]: package ImARegex; sub match { $_[1] =~ $_[0] ? 1 : 0 } package main; my $re = qr/hai/; bless $re, 'ImARegex'; $re->match('char')
evals/evals-freenode-#perl.lst[4609]: package lala; my $x = 123; package lulu; $x
evals/evals-freenode-#perl.lst[4610]: package mac { sub ska { 'ca' } } "ce${\mac->ska}"
evals/evals-freenode-#perl.lst[4611]: Package->method
evals/evals-freenode-#perl.lst[4612]: package My; my My $my :Delilah;
evals/evals-freenode-#perl.lst[4613]: package mypackage.pm; # although I'd guess perl should already be complaining about it
evals/evals-freenode-#perl.lst[4614]: { package MyProject::whatever; sub doSomething { print 'test' } } my $class = 'whatever'; *{"MyProject::${class}::doSomething"}{CODE}() # but really don't do this
evals/evals-freenode-#perl.lst[4615]: package My::Thing { sub validate_rules { { cat => qr/meow/, cow => qr/moo/ } } } my $klass = "My::Thing"; $klass->validate_rules
evals/evals-freenode-#perl.lst[4616]: package Object; sub speak { print "Hello" };    sub before { my ( $name, $code ) = @_; my $orig = Object->can( $name ); *$name = sub { $code->(); $orig->() }; }   around speak => sub { print "But first..." }     Object->speak
evals/evals-freenode-#perl.lst[4617]: package Object; sub speak { print "Hello" };    sub before { my ( $name, $code ) = @_; my $orig = Object->can( $name ); *$name = sub { $code->(); $orig->() }; }   before speak => sub { print "But first..." }     Object->speak
evals/evals-freenode-#perl.lst[4618]: package Object; sub speak { print "Hello" };    sub before { my ( $name, $code ) = @_; my $orig = Object->can( $name ); *$name = sub { $code->(); $orig->() }; }   before speak => sub { print "But first..." };     Object->speak
evals/evals-freenode-#perl.lst[4619]: { package Plip; use overload '""' => sub { 'plop' } } $x = bless [], 'Plip'; "plup $x"
evals/evals-freenode-#perl.lst[4620]: package P; sub new { my $class = @_ && ( $_[0]->isa( __PACKAGE__ ) || $_[0] eq __PACKAGE__ ) ? shift : __PACKAGE__; bless +{ @_ }, ( ref $class or $class ); } package main; P->new( foo => 123, bar => 456 );
evals/evals-freenode-#perl.lst[4621]: package P; sub new { my $class = @_ && ( $_[0]->isa( __PACKAGE__ ) || $_[0] eq __PACKAGE__ ) ? shift : __PACKAGE__; bless +{ @_ }, ( ref $class or $class ); } package main; P::new( foo => 123, bar => 456 );
evals/evals-freenode-#perl.lst[4622]: package P; sub new { my $class = @_ && ( $_[0]->isa( __PACKAGE__ ) || $_[0] eq __PACKAGE__ ) ? shift : __PACKAGE__; bless +{ @_ }, ( ref $class or $class ); } package main; P::new( P => 123, bar => 456 );
evals/evals-freenode-#perl.lst[4623]: package P { use overload '""' => sub { "07" }, '0+' => sub { "01" } } (bless {}, "P") + (bless {}, "P")
evals/evals-freenode-#perl.lst[4624]: package P { use overload '""' => sub { "07" }, '0+' => sub { "01" } } oct(bless {}, 'P')
evals/evals-freenode-#perl.lst[4625]: package P { use overload '""' => sub { "07" } } oct(bless {}, 'P')
evals/evals-freenode-#perl.lst[4626]: package q; sub qq {"qqq"};package main; *main::notq = \&q::qq; [notq()]
evals/evals-freenode-#perl.lst[4627]: package q; sub qq {"qqq"};package main; my $code = \&q::qq; [$code->()]
evals/evals-freenode-#perl.lst[4628]: { package Regexp; use overload '""' => sub { 'overload' }, fallback => 1 } my $x = bless qr/loves/, 'Regexp'; [ "$x", re::regexp_pattern($x) ] # then there are those who just like to watch the world burn
evals/evals-freenode-#perl.lst[4629]: package Some::Class; sub class_method { my $class = shift; print "in class method" }  package main; Some::Class->class_method;
evals/evals-freenode-#perl.lst[4630]: package 㐁; sub foo {3} package main; 㐁::foo()
evals/evals-freenode-#perl.lst[4631]: package TerribleThing { sub new { bless {}, shift } sub DESTROY { undef $@ } } eval { die TerribleThing->new }; [$@]
evals/evals-freenode-#perl.lst[4632]: package TerribleThing { sub new { bless {}, shift } sub DESTROY { undef $@ } } eval { my $foo = TerribleThing->new; die 1 }; [$@]
evals/evals-freenode-#perl.lst[4633]: package test; sub new { my $class = shift; my $props = { property => shift }; bless $props, $class; return $props; } 1; my $tester = new test("thisproperty"); my $longstring = << 'EOF'; long long string\n\n$test->property\n\nEOF; print $tester;
evals/evals-freenode-#perl.lst[4634]: package tm406; sub is_gandalf { 1 }; return "TRUE" if(tm406->is_gandalf());
evals/evals-freenode-#perl.lst[4635]: { package Try; use Function::Parameters qw(:strict); method stuff($class: $x) { $x + 1 } } Try->stuff
evals/evals-freenode-#perl.lst[4636]: { package X; sub DESTROY { print "<>\n"; } } my $sub = sub { my $x = bless [], "X"; sub { "ok" } }->(); print "main\n"; print $sub->()
evals/evals-freenode-#perl.lst[4637]: { package X; sub TIEHASH { bless [], $_[0] } sub AUTOLOAD { my $r = shift; push @$r, [our $AUTOLOAD, @_] } } tie my %x, 'X'; %x = "A" .. "D"; tied %x
evals/evals-freenode-#perl.lst[4638]: { package X; sub TIEHASH { bless [], $_[0] } sub AUTOLOAD { push @{$_[0]}, our $AUTOLOAD } } tie my %x, 'X'; %x = "A" .. "D"; tied %x
evals/evals-freenode-#perl.lst[4639]: { package X; sub TIEHASH { bless [], $_[0] } sub CLEAR {} } tie my %x, 'X'; %x = (1, 2);
evals/evals-freenode-#perl.lst[4640]: { package X; sub TIEHASH { bless [], $_[0] } } tie my %x, 'X'; %x = ();
evals/evals-freenode-#perl.lst[4641]: { package X; sub TIEHASH { bless [], $_[0] } } tie my %x, 'X'; %x = (1, 2);
evals/evals-freenode-#perl.lst[4642]: { package X; sub TIESCALAR { bless [] } sub FETCH { state $x = 5; $x++ } } tie my $foo, X::; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say "surprise!" }
evals/evals-freenode-#perl.lst[4643]: { package X; } tie my %x, 'X'; %x = ();
evals/evals-freenode-#perl.lst[4644]: { package X; use overload fallback => 1, '0+' => sub { state $x = 5; $x++ }; } my $foo = bless [], X::; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say "surprise!" }
evals/evals-freenode-#perl.lst[4645]: package X; use overload '""' => sub { print "string"; "x" }, '.' => sub { print "concat"; "x" }; sprintf '%s', (bless {}, 'X');
evals/evals-freenode-#perl.lst[4646]: package X; use overload '+' => sub { print "X"; }; package Y; use overload '+' => sub { print "Y" }; [ (bless {}, 'X') + (bless {}, 'Y') ]
evals/evals-freenode-#perl.lst[4647]: package X; use overload '+' => sub { print "X"; }; package Y; use overload '+' => sub { print "Y" }; [ (bless {}, 'Y') + (bless {}, 'X') ]
evals/evals-freenode-#perl.lst[4648]: package XYZ; my @FIELDS = qw(one two); for my $field (@FIELDS) { *$field = sub { shift->{$field} }; } my $obj = bless {one => 1, two => 2, five => 5}, 'XYZ'; $FIELDS[1] = 'five'; [ map $obj->$_, qw(one two) ]
evals/evals-freenode-#perl.lst[4649]: package XYZ; sub somesub { "called with @_" } [ XYZ::somesub('x', 'y'), XYZ->somesub('x', 'y') ] # they don't have to be class methods, you can use the package namespace without importing it into the current scope
evals/evals-freenode-#perl.lst[4650]: pack '(a)*', map +(/.(.)/g,/(.)./g), "123456"
evals/evals-freenode-#perl.lst[4651]: pack '(a)*', sort {$|--} "tuJsa nohterP er lhakcer," =~ /./g
evals/evals-freenode-#perl.lst[4652]: pack 'B*', ~0
evals/evals-freenode-#perl.lst[4653]: pack "b*", "00101010000101101001011011001110"
evals/evals-freenode-#perl.lst[4654]: pack 'B*', '0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010'
evals/evals-freenode-#perl.lst[4655]: pack "b*", 0b010101010;
evals/evals-freenode-#perl.lst[4656]: pack "(b8)*", "00101010","00010110",10010110,11001110
evals/evals-freenode-#perl.lst[4657]: pack "(b8)*", "00101010","00010110",10010110,11001110'
evals/evals-freenode-#perl.lst[4658]: pack "(b8)*", 00101010,00010110,10010110,11001110
evals/evals-freenode-#perl.lst[4659]: pack('b8','01010100')
evals/evals-freenode-#perl.lst[4660]: pack('B8','01010100')
evals/evals-freenode-#perl.lst[4661]: pack('(b8)*',"0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010" =~ /.{8}/g);
evals/evals-freenode-#perl.lst[4662]: pack "B8", "11111110"
evals/evals-freenode-#perl.lst[4663]: pack "(b8)*", split ' ', "00101010 00010110 10010110 11001110"
evals/evals-freenode-#perl.lst[4664]: pack "(b8)*", split/(.{8})/, "00101010000101101001011011001110"
evals/evals-freenode-#perl.lst[4665]: pack('b8'x11,"0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010");
evals/evals-freenode-#perl.lst[4666]: [ pack "B*", pack "C*", (1) x 7, 0 ]
evals/evals-freenode-#perl.lst[4667]: pack "c", 127;
evals/evals-freenode-#perl.lst[4668]: pack "C16", (0)x10, (0xff)x2, split /[.]/, "192.168.0.1"
evals/evals-freenode-#perl.lst[4669]: [ pack 'c', 48 ]
evals/evals-freenode-#perl.lst[4670]: pack "c", 99;
evals/evals-freenode-#perl.lst[4671]: pack "c", 9999;
evals/evals-freenode-#perl.lst[4672]: pack "cc", 9888, 9999;
evals/evals-freenode-#perl.lst[4673]: pack "cc", 98, 99;
evals/evals-freenode-#perl.lst[4674]: [ pack '%c', map { $_ & 1 } unpack '%c', 'asdf1111' ]
evals/evals-freenode-#perl.lst[4675]: pack "c*", map { hex } "30313133" =~ /([[:xdigit:]]{2})/g
evals/evals-freenode-#perl.lst[4676]: pack "C*", qw|137 80 78 71 13 10 26 10|
evals/evals-freenode-#perl.lst[4677]: [ pack "C*", qw|137 80 78 71 13 10 26 10| ] # throw Data::Dumper at it
evals/evals-freenode-#perl.lst[4678]: packege Whatever; # looks like an error to me, man
evals/evals-freenode-#perl.lst[4679]: pack "f*", 1,2,3;
evals/evals-freenode-#perl.lst[4680]: [ pack 'F', (9/10-1)*100 ]
evals/evals-freenode-#perl.lst[4681]: pack 'H*', '00001c00';
evals/evals-freenode-#perl.lst[4682]: pack("H*", 0x80 + 1)
evals/evals-freenode-#perl.lst[4683]: pack '(H2)*', split /\./, sprintf '%vx', 'one way to do it'
evals/evals-freenode-#perl.lst[4684]: pack "h", "41"
evals/evals-freenode-#perl.lst[4685]: pack 'H*', '41'
evals/evals-freenode-#perl.lst[4686]: pack("H*", 41)
evals/evals-freenode-#perl.lst[4687]: [ pack("H*", 4120422043), pack("h*", 1402240234) ]
evals/evals-freenode-#perl.lst[4688]: [ pack("H*", 4120422043), unpack("H*", "A B C") ]
evals/evals-freenode-#perl.lst[4689]: pack "H*", "42424242"
evals/evals-freenode-#perl.lst[4690]: [ pack "H*", "49440953" ]
evals/evals-freenode-#perl.lst[4691]: pack 'h*', '6363735f7263'
evals/evals-freenode-#perl.lst[4692]: pack 'H*', '6363735f7263'
evals/evals-freenode-#perl.lst[4693]: pack 'H*', "6578616d706c65206865782064617461"
evals/evals-freenode-#perl.lst[4694]: [ pack "H*", "6d73616e64626f78" ]
evals/evals-freenode-#perl.lst[4695]: pack "H*", '7061756c'
evals/evals-freenode-#perl.lst[4696]: pack "H*", "7468697320697320612074657374"
evals/evals-freenode-#perl.lst[4697]: ~pack "H*", '9e9b929691'
evals/evals-freenode-#perl.lst[4698]: pack "H*", '9e9b929691'
evals/evals-freenode-#perl.lst[4699]: pack "H*", ${\chr 24}
evals/evals-freenode-#perl.lst[4700]: pack 'H*', '\x41\x41' =~ tr/\\x//dr
evals/evals-freenode-#perl.lst[4701]: [ pack 'N', 42 ]
evals/evals-freenode-#perl.lst[4702]: pack 'N/a*', { cool => 'story, bro' }
evals/evals-freenode-#perl.lst[4703]: pack 'n*', unpack 'v*', "123456"
evals/evals-freenode-#perl.lst[4704]: pack 'q', 7378717377743452252
evals/evals-freenode-#perl.lst[4705]: pack "s>", 25
evals/evals-freenode-#perl.lst[4706]: pack('V' . 0xfffffff)
evals/evals-freenode-#perl.lst[4707]: pack('V' . 0xfffffff);
evals/evals-freenode-#perl.lst[4708]: pack('V31337000');
evals/evals-freenode-#perl.lst[4709]: [pack 'V', 85]
evals/evals-freenode-#perl.lst[4710]: pack('V' . 99999990);
evals/evals-freenode-#perl.lst[4711]: [pack "(Z*)*", qw(foo bar baz)]
evals/evals-freenode-#perl.lst[4712]: $page_content="http://www.liveleak.com/view?i=abcd"; if ( $page_content =~ /http\:\/\/www\.liveleak\.com\/view\?i\=(\w+)/ ){ $ids = $1 }; print $ids;
evals/evals-freenode-#perl.lst[4713]: $page_content='http://www.liveleak.com/view?i=abcd'; if ( $page_content =~ m!http://www\.liveleak\.com/view\?i=(\w{14})!g; ){ $ids = $1 }; print $ids;
evals/evals-freenode-#perl.lst[4714]: $page_content='http://www.liveleak.com/view?i=abcd'; my @ids = $page_content =~ m!http://www\.liveleak\.com/view\?i=(\w{14})!g; print @ids;
evals/evals-freenode-#perl.lst[4715]: $page_content="http://www.liveleak.com/view?i=abcd"; $page_content =~ s/http\:\/\/www\.liveleak\.com\/view\?i\=(\w+)/$1/g; print $page_content;
evals/evals-freenode-#perl.lst[4716]: $page_content="http://www.liveleak.com/view?i=c77_1406577312"; $page_content =~ s/http\:\/\/www\.liveleak\.com\/view\?i\=(\w+)/$1/g; print $page_content;
evals/evals-freenode-#perl.lst[4717]: $page_content="http://www.liveleak.com/view?i=qwerty"; if ( $page_content =~ /http\:\/\/www\.liveleak\.com\/view\?i\=(\w+)/ ){ push (@ids,$1); }; print @ids;
evals/evals-freenode-#perl.lst[4718]: "/page/save/2202440;294ac50e,315fb991" =~ m{page/} ? 'match' : 'nope'
evals/evals-freenode-#perl.lst[4719]: "/page/show/2202440" =~ m{page/} ? 'match' : 'nope'
evals/evals-freenode-#perl.lst[4720]: "/page/show/2202440" =~ {page/} ? 'match' : 'nope'
evals/evals-freenode-#perl.lst[4721]: [ "parachute! ahh I'm falling!" =~ s/(?<=chute).*//r ]
evals/evals-freenode-#perl.lst[4722]: [ "parachute!" =~ s/(?<=chute).*//r ]
evals/evals-freenode-#perl.lst[4723]: [ "parachute" =~ s/(?<=chute).*//r ]
evals/evals-freenode-#perl.lst[4724]: parse backwards
evals/evals-freenode-#perl.lst[4725]: " part isn't necessary in your actual code; it's just for interacting with the IRC bot
evals/evals-freenode-#perl.lst[4726]: $pattern = "oo"; return [ "foo" =~ /$pattern/, "bar" =~ /$pattern/ ];
evals/evals-freenode-#perl.lst[4727]: $pattern = "oo"; return [ "foo" =~ /$re/, "bar" =~ /$re/ ]; # voila!
evals/evals-freenode-#perl.lst[4728]: #!perl
evals/evals-freenode-#perl.lst[4729]: "Perl"^2
evals/evals-freenode-#perl.lst[4730]: perl -e "my @res = map { substr($_, 0, length($_)-1) if (-f substr($_, 0, length($_)-1) } qw(dupes.txt allfiles.bak.txt hahaha.setnhue); print join(' ', @res) . "\n";
evals/evals-freenode-#perl.lst[4731]: `perl -e 'print "$]"'`
evals/evals-freenode-#perl.lst[4732]: perl -e 'print "$]"'
evals/evals-freenode-#perl.lst[4733]: perl -E 'say for @INC'
evals/evals-freenode-#perl.lst[4734]: perl -e 'use DateTime; print DateTime->now->year."w".DateTime->now->week_number'
evals/evals-freenode-#perl.lst[4735]: perlev ' [ unpack q{N}, pack q{H8}, q{6060FF} ] ' # alanjf
evals/evals-freenode-#perl.lst[4736]: [ PerlIO::get_layers(*STDIN) ]
evals/evals-freenode-#perl.lst[4737]: perl -p -e "s/\/\/a\[contains\(text\(\),'(\w+)'\)\]/$1/g" <<< //a[contains(text(),'Korel&nbsp;&nbsp;Göymen')]
evals/evals-freenode-#perl.lst[4738]: `perl -v`
evals/evals-freenode-#perl.lst[4739]: perl -v
evals/evals-freenode-#perl.lst[4740]: "#########PermitRootLogin no way man" =~ s/#*(PermitRootLogin\sno)/$1/r
evals/evals-freenode-#perl.lst[4741]: 'phd defense' gt 'php defense'
evals/evals-freenode-#perl.lst[4742]: @phone =~ /^0$/
evals/evals-freenode-#perl.lst[4743]: @phone = 0; @phone =~ /^1$/
evals/evals-freenode-#perl.lst[4744]: @phone = 1; @phone =~ /^1$/
evals/evals-freenode-#perl.lst[4745]: "pobox" eq "pоbox"
evals/evals-freenode-#perl.lst[4746]: pop @{politics}
evals/evals-freenode-#perl.lst[4747]: POSIX::fmod(-10, exp 1)
evals/evals-freenode-#perl.lst[4748]: POSIX::strftime("%b %d", localtime)
evals/evals-freenode-#perl.lst[4749]: POSIX::strftime "%Y-%H-%m %d:%M", localtime
evals/evals-freenode-#perl.lst[4750]: [POSIX::strftime '%Y%m%d_%H%M', localtime]
evals/evals-freenode-#perl.lst[4751]: POSIX::strftime "%y-%M-%D %h:%m:%s", localtime
evals/evals-freenode-#perl.lst[4752]: POSIX::strftime "%Y%m%d%H%M%S", localtime 1395698781
evals/evals-freenode-#perl.lst[4753]: @pos = (); push @pos, @- while 'hangman' =~ /n/g; \@pos
evals/evals-freenode-#perl.lst[4754]: $_='post hoc ergo propter hoc'; s/./rand(3)>1?lc($&):uc($&)/egr;
evals/evals-freenode-#perl.lst[4755]: @pos = (); $word = 'hangman'; $guess = 'n'; push @pos, @- while $word =~ /$guess/g; \@pos  # vaskozl
evals/evals-freenode-#perl.lst[4756]: $predicate = 1; $true = {foo => 2}; $false = {}; [exists($predicate ? $true->{foo} : $false->{foo}) ? "Y" : "N"]
evals/evals-freenode-#perl.lst[4757]: $price = '16.60'; ($dollar,$cents)=$price=~/(\d+)\.(\d+); $dollar++ if $cents > 0; print $dollar
evals/evals-freenode-#perl.lst[4758]: $price = '16.60'; ($dollar,$cents)=$price=~/(\d+)\.(\d+)/; $dollar++ if $cents > 0; print $dollar
evals/evals-freenode-#perl.lst[4759]: print
evals/evals-freenode-#perl.lst[4760]: \&print
evals/evals-freenode-#perl.lst[4761]: print ''
evals/evals-freenode-#perl.lst[4762]: print '$]'
evals/evals-freenode-#perl.lst[4763]: print '\\'
evals/evals-freenode-#perl.lst[4764]: print "`*`";
evals/evals-freenode-#perl.lst[4765]: print "-"
evals/evals-freenode-#perl.lst[4766]: print ""
evals/evals-freenode-#perl.lst[4767]: print "[@_]";
evals/evals-freenode-#perl.lst[4768]: print "$,"
evals/evals-freenode-#perl.lst[4769]: print "$;"
evals/evals-freenode-#perl.lst[4770]: print "$]"
evals/evals-freenode-#perl.lst[4771]: print "–"
evals/evals-freenode-#perl.lst[4772]: print @_;
evals/evals-freenode-#perl.lst[4773]: print $/
evals/evals-freenode-#perl.lst[4774]: print $]
evals/evals-freenode-#perl.lst[4775]: print $];
evals/evals-freenode-#perl.lst[4776]: print $@
evals/evals-freenode-#perl.lst[4777]: print $$
evals/evals-freenode-#perl.lst[4778]: print;
evals/evals-freenode-#perl.lst[4779]: print "0"
evals/evals-freenode-#perl.lst[4780]: print "01"
evals/evals-freenode-#perl.lst[4781]: print(0.3 + 0.3 + 0.3 - 0.9);
evals/evals-freenode-#perl.lst[4782]: print "0"; '' # and it's gone
evals/evals-freenode-#perl.lst[4783]: print '0' x 1 . '9'
evals/evals-freenode-#perl.lst[4784]: print 1
evals/evals-freenode-#perl.lst[4785]: print 1;
evals/evals-freenode-#perl.lst[4786]: print 1 + 1;
evals/evals-freenode-#perl.lst[4787]: print(1+2)/2
evals/evals-freenode-#perl.lst[4788]: print 123
evals/evals-freenode-#perl.lst[4789]: print (.1 + .2 == .3)
evals/evals-freenode-#perl.lst[4790]: print " 1234567 " =~ /[0-9]{7} /;
evals/evals-freenode-#perl.lst[4791]: print " 12345678 " =~ / [0-9]{7} /;
evals/evals-freenode-#perl.lst[4792]: print " 12345678 " =~ /[0-9]{7} /;
evals/evals-freenode-#perl.lst[4793]: print 155.0 / 3.0
evals/evals-freenode-#perl.lst[4794]: print (1/999)*999
evals/evals-freenode-#perl.lst[4795]: [print 2]
evals/evals-freenode-#perl.lst[4796]: print "2"
evals/evals-freenode-#perl.lst[4797]: print "2" && print @+
evals/evals-freenode-#perl.lst[4798]: print "2" && print $!
evals/evals-freenode-#perl.lst[4799]: print "2" && print $?
evals/evals-freenode-#perl.lst[4800]: print (3+undef)/2
evals/evals-freenode-#perl.lst[4801]: print4
evals/evals-freenode-#perl.lst[4802]: print (7 + 5) * 13, "\n";
evals/evals-freenode-#perl.lst[4803]: (\&print)->('a')
evals/evals-freenode-#perl.lst[4804]: print "\a"
evals/evals-freenode-#perl.lst[4805]: print {@a}->{a}
evals/evals-freenode-#perl.lst[4806]: print +{@a}->{a}
evals/evals-freenode-#perl.lst[4807]: $, = '!'; print 'a', 'b'.'c';
evals/evals-freenode-#perl.lst[4808]: $, = '!'; print 'a'.'b','c';
evals/evals-freenode-#perl.lst[4809]: $, = '!'; print 'a'.('b','c');
evals/evals-freenode-#perl.lst[4810]: print 'a', 'b'.'c';
evals/evals-freenode-#perl.lst[4811]: print "abc$^Hdef"
evals/evals-freenode-#perl.lst[4812]: print "a"; die "an error"
evals/evals-freenode-#perl.lst[4813]: print 'alive'; eval q![ 'a' x 1e12 ]!
evals/evals-freenode-#perl.lst[4814]: print $a="[[ \"pos\" ], /\"(/d+)\"/]", "\n"; my $result = eval($a) or die $@;
evals/evals-freenode-#perl.lst[4815]: print $a="[[ \"pos\" ], /\"(/d+)\"/]", "\n"; print ref(eval($a)),"\n";
evals/evals-freenode-#perl.lst[4816]: print "as a brit i prefer" . ( rand() < 0.1 ? "spicey foods" : "boiled cabbage"
evals/evals-freenode-#perl.lst[4817]: print "as a brit i prefer" . ( rand() < 0.1 ? "spicey foods" : "boiled cabbage" )
evals/evals-freenode-#perl.lst[4818]: print "a" x "b";
evals/evals-freenode-#perl.lst[4819]: print "bottle\n" x 2;
evals/evals-freenode-#perl.lst[4820]: print "bottle" x 2;
evals/evals-freenode-#perl.lst[4821]: print (caller(0))[8]
evals/evals-freenode-#perl.lst[4822]: print `cat /dev/urandom`
evals/evals-freenode-#perl.lst[4823]: print 'cats'
evals/evals-freenode-#perl.lst[4824]: print "cats"
evals/evals-freenode-#perl.lst[4825]: print "${chr(24)}"
evals/evals-freenode-#perl.lst[4826]: print chr 8305
evals/evals-freenode-#perl.lst[4827]: print chr length q q continue q
evals/evals-freenode-#perl.lst[4828]: print chr ord for qw q hasdfsadfsadf aasdfdsafasdf chasdfadsfadsf kasdfadfasdf easdfsfdsdf refwefsadfsadfa q
evals/evals-freenode-#perl.lst[4829]: print $code
evals/evals-freenode-#perl.lst[4830]: { print 'Considered'; last; print "fun"; } print ' harmful by some, for this reason.'
evals/evals-freenode-#perl.lst[4831]: print crypt('Gil*321T','$');
evals/evals-freenode-#perl.lst[4832]: print cwd();
evals/evals-freenode-#perl.lst[4833]: print DateTime->now->week_year
evals/evals-freenode-#perl.lst[4834]: print("Debug\n"), return 1 if (1);
evals/evals-freenode-#perl.lst[4835]: print do { if (0) { 1 } else { 2 } }
evals/evals-freenode-#perl.lst[4836]: print do { if (1) { 1 } else { 2 } }
evals/evals-freenode-#perl.lst[4837]: print Dumper @_
evals/evals-freenode-#perl.lst[4838]: print `echo 1`
evals/evals-freenode-#perl.lst[4839]: print "Enter number 1: ", $a1 = <STDIN>;
evals/evals-freenode-#perl.lst[4840]: print(%ENV);
evals/evals-freenode-#perl.lst[4841]: print $ENV{1} . "\n";
evals/evals-freenode-#perl.lst[4842]: print $ENV{'TZ'}
evals/evals-freenode-#perl.lst[4843]: print $ENV{'TZ'};
evals/evals-freenode-#perl.lst[4844]: print $ENV{TZ};
evals/evals-freenode-#perl.lst[4845]: print eval +{print "2"}
evals/evals-freenode-#perl.lst[4846]: print eval('system("dir")')
^[[D    FAILED TO EVAL!
evals/evals-freenode-#perl.lst[4847]: print exec("dir")
evals/evals-freenode-#perl.lst[4848]: print exec("ls")
evals/evals-freenode-#perl.lst[4849]: printf "%04o\n",0777;
evals/evals-freenode-#perl.lst[4850]: printf "%04o\n",07777;
evals/evals-freenode-#perl.lst[4851]: printf "%04o\n",$mode->mode & 07777;
evals/evals-freenode-#perl.lst[4852]: printf "%08b\n%08b\n%08b\n", 0xff, 0x7f, 0xff & 0x7f
evals/evals-freenode-#perl.lst[4853]: printf " %08b ", ord "a"
evals/evals-freenode-#perl.lst[4854]: printf '%2$-2s%1$s', qw(a b) # you're trying to write a script to do this, or is there more to it?
evals/evals-freenode-#perl.lst[4855]: printf '%-2$p', sub {}
evals/evals-freenode-#perl.lst[4856]: printf "%.40f\n", 3.141592653589793238462643383279502884;
evals/evals-freenode-#perl.lst[4857]: printf "%.6f", 6.437370834e-01
evals/evals-freenode-#perl.lst[4858]: printf "%.6f", 6.437370834e+01
evals/evals-freenode-#perl.lst[4859]: printf "%.6f", 6.437370834e-06
evals/evals-freenode-#perl.lst[4860]: printf "%.6f", 6.437370834e+06
evals/evals-freenode-#perl.lst[4861]: printf '%b', ord ' '
evals/evals-freenode-#perl.lst[4862]: print fc("ł") cmp fc("z")
evals/evals-freenode-#perl.lst[4863]: printf(“%d”, 1.9)
evals/evals-freenode-#perl.lst[4864]: printf('%d%%', (45/50-1)*100)
evals/evals-freenode-#perl.lst[4865]: printf('%d%%', (9/10-1)*100)
evals/evals-freenode-#perl.lst[4866]: print "floo"
evals/evals-freenode-#perl.lst[4867]: \&print->("foo")
evals/evals-freenode-#perl.lst[4868]: print "foo"
evals/evals-freenode-#perl.lst[4869]: print "foo" if ("/page/show/1234" =~ m{page/});
evals/evals-freenode-#perl.lst[4870]: print foo(); my $x = 213; sub foo { $x }
evals/evals-freenode-#perl.lst[4871]: print for 1..4
evals/evals-freenode-#perl.lst[4872]: print for aaaa.zzzz
evals/evals-freenode-#perl.lst[4873]: print for aaaa..zzzz
evals/evals-freenode-#perl.lst[4874]: print for (a..z, 0..9, A..Z);
evals/evals-freenode-#perl.lst[4875]: print foreach 1..5
evals/evals-freenode-#perl.lst[4876]: print $_, $/ for @INC
evals/evals-freenode-#perl.lst[4877]: print for @INC
evals/evals-freenode-#perl.lst[4878]: print "$_," for sort ( 99, 111 )
evals/evals-freenode-#perl.lst[4879]: print "<<$_>>" for 'this is a test' =~ /.../g;  # hehehe
evals/evals-freenode-#perl.lst[4880]: print/..(..?)/ for[],{},$"x3,\&f,\0
evals/evals-freenode-#perl.lst[4881]: printf q{%.8f}, 155.0 / 3.0
evals/evals-freenode-#perl.lst[4882]: printf q{%f.8}, 155.0 / 3.0
evals/evals-freenode-#perl.lst[4883]: printf ?say\n?
evals/evals-freenode-#perl.lst[4884]: printf("%s\n", "I'm so unruly bot ...");
evals/evals-freenode-#perl.lst[4885]: printf "%*v08b", " ", "hello"
evals/evals-freenode-#perl.lst[4886]: printf "%vd %s", chr hex "2665", chr hex "2665"
evals/evals-freenode-#perl.lst[4887]: printf "%vd", "ü"
evals/evals-freenode-#perl.lst[4888]: printf '%x' ord ':'
evals/evals-freenode-#perl.lst[4889]: printf '%x', ord ':'
evals/evals-freenode-#perl.lst[4890]: print gmtime() , "\n";
evals/evals-freenode-#perl.lst[4891]: print 'Good night';
evals/evals-freenode-#perl.lst[4892]: print grep { /\d/ } map { chr } 0x11067..0x10ffff # for Grinnz_
evals/evals-freenode-#perl.lst[4893]: print "hello"
evals/evals-freenode-#perl.lst[4894]: print "Hello";
evals/evals-freenode-#perl.lst[4895]: print "hello"; 2+2
evals/evals-freenode-#perl.lst[4896]: print "hello\n";
evals/evals-freenode-#perl.lst[4897]: print "hello\nworld"
evals/evals-freenode-#perl.lst[4898]: @{ print "hello"; print " world"; [] }
evals/evals-freenode-#perl.lst[4899]: print "hello world";
evals/evals-freenode-#perl.lst[4900]: print "Hello world!";
evals/evals-freenode-#perl.lst[4901]: print "Hello, world!";
evals/evals-freenode-#perl.lst[4902]: print "hello world\n"
evals/evals-freenode-#perl.lst[4903]: print "hi";
evals/evals-freenode-#perl.lst[4904]: print "hi\tsir\n"
evals/evals-freenode-#perl.lst[4905]: print "hi".(" " x 4)."there\n";
evals/evals-freenode-#perl.lst[4906]: print "i bought a "; rand()<0.5 ? 'coke' : 'root beer'
evals/evals-freenode-#perl.lst[4907]: print "i bougth a " . (rand()<0.5 ? "coke" : "root beer" )
evals/evals-freenode-#perl.lst[4908]: print "I'm a Perl ", 5 + !!"0", " program."
evals/evals-freenode-#perl.lst[4909]: print @INC;
evals/evals-freenode-#perl.lst[4910]: print "is about to flood the channel"
evals/evals-freenode-#perl.lst[4911]: print join ",",  grep { $_ % 2 == 0 } (1..50)
evals/evals-freenode-#perl.lst[4912]: print join(", ", @INC);
evals/evals-freenode-#perl.lst[4913]: print join(":", keys %ENV);
evals/evals-freenode-#perl.lst[4914]: print join('',map {chr $_} (97, 98, 99))
evals/evals-freenode-#perl.lst[4915]: print join ('x', "a","b","c","d");
evals/evals-freenode-#perl.lst[4916]: print join x => a => b => c => d =>
evals/evals-freenode-#perl.lst[4917]: print "ł" cmp "z"
evals/evals-freenode-#perl.lst[4918]: print localtime()
evals/evals-freenode-#perl.lst[4919]: print localtime();
evals/evals-freenode-#perl.lst[4920]: print `ls`;
evals/evals-freenode-#perl.lst[4921]: print `ls /tmp`
evals/evals-freenode-#perl.lst[4922]: print map { "(".$_.")" } "a:1 b:2 a:3 b:4 " =~ m/^((a:\d+ )(b:\d+ ))*/
evals/evals-freenode-#perl.lst[4923]:  print map (lc,('ABC','DEF','GHI'));
evals/evals-freenode-#perl.lst[4924]:  print map (lc,(’ABC’,’DEF’,’GHI’));
evals/evals-freenode-#perl.lst[4925]:  print map { lc } qw/ ABC DEF GHI /;
evals/evals-freenode-#perl.lst[4926]: print map { $x++ } 1..10
evals/evals-freenode-#perl.lst[4927]: [ print "Miesco", print "Miesco" ]
evals/evals-freenode-#perl.lst[4928]: print "Miesco", print "Miesco"
evals/evals-freenode-#perl.lst[4929]: print("Miesco"), print("Miesco")
evals/evals-freenode-#perl.lst[4930]: print my @arr[2];
evals/evals-freenode-#perl.lst[4931]: print my $arr[2];
evals/evals-freenode-#perl.lst[4932]: print "\n"
evals/evals-freenode-#perl.lst[4933]: print "$_\n" for 'this is a test' =~ /.../g;  # hehehe
evals/evals-freenode-#perl.lst[4934]: print "No output."
evals/evals-freenode-#perl.lst[4935]: print "$^O";
evals/evals-freenode-#perl.lst[4936]: print oct("420)"
evals/evals-freenode-#perl.lst[4937]: print("oh yes, entire nothings")
evals/evals-freenode-#perl.lst[4938]: print "ok" if "å" =~ /[[:alpha:]_]/
evals/evals-freenode-#perl.lst[4939]: print "ok" if "å" =~ /[[:alpha:]_]/a
evals/evals-freenode-#perl.lst[4940]: print "ok" if "_" =~ /[[:alpha:]_]/
evals/evals-freenode-#perl.lst[4941]: print "ok" if "_" =~ /[[:alpha:]]/
evals/evals-freenode-#perl.lst[4942]: print ord "¢"
evals/evals-freenode-#perl.lst[4943]: print ord('a'), " ", ord('а');
evals/evals-freenode-#perl.lst[4944]: print ord('a'), ord('а');
evals/evals-freenode-#perl.lst[4945]: print ord pack "cc", 9999
evals/evals-freenode-#perl.lst[4946]: print ord " "
evals/evals-freenode-#perl.lst[4947]: print "Perl is easy";
evals/evals-freenode-#perl.lst[4948]: print ${ print 'foo'; \'bar' };
evals/evals-freenode-#perl.lst[4949]: print print print print print
evals/evals-freenode-#perl.lst[4950]: print "PRIVMSG ##microsoft hello";
evals/evals-freenode-#perl.lst[4951]: print prototype('CORE::sprintf')
evals/evals-freenode-#perl.lst[4952]: print q/foo/
evals/evals-freenode-#perl.lst[4953]: print q{foo} while 0;
evals/evals-freenode-#perl.lst[4954]: print '[', $_, ':', quotemeta($_), ']' for q{\/}, qq{\/};
evals/evals-freenode-#perl.lst[4955]: print quotemeta 'test@example.com'
evals/evals-freenode-#perl.lst[4956]: print { (rand() < .5) ? STDOUT : STDERR } 'foo'
evals/evals-freenode-#perl.lst[4957]: print { rand < .5 ? STDOUT : STDERR } 'foo'
evals/evals-freenode-#perl.lst[4958]: print"RASH DEAL"
evals/evals-freenode-#perl.lst[4959]: print reverse ("7c86467b");
evals/evals-freenode-#perl.lst[4960]: print ( reverse sort ( 1..9 ));
evals/evals-freenode-#perl.lst[4961]: print round(0.5)
evals/evals-freenode-#perl.lst[4962]: print s/..(..).*/$1/r for[],{},$",\&f,\0
evals/evals-freenode-#perl.lst[4963]: print s/..(..).*/$1/r for(...there you go
evals/evals-freenode-#perl.lst[4964]: print scalar "321" =~ /\d+/;
evals/evals-freenode-#perl.lst[4965]: print scalar (a..b)
evals/evals-freenode-#perl.lst[4966]: print scalar a..b
evals/evals-freenode-#perl.lst[4967]: print scalar "abc" =~ /\d+/;
evals/evals-freenode-#perl.lst[4968]: print scalar gmtime() , "\n";
evals/evals-freenode-#perl.lst[4969]: print scalar gmtime time();
evals/evals-freenode-#perl.lst[4970]: print scalar localtime 1416907528
evals/evals-freenode-#perl.lst[4971]: print scalar localtime 1427744321029
evals/evals-freenode-#perl.lst[4972]: print scalar localtime (1427744321029/1000)
evals/evals-freenode-#perl.lst[4973]: print scalar localtime(1450370812)
evals/evals-freenode-#perl.lst[4974]: print scalar localtime gmtime();
evals/evals-freenode-#perl.lst[4975]: print scalar localtime $^T
evals/evals-freenode-#perl.lst[4976]: print scalar localtime time
evals/evals-freenode-#perl.lst[4977]: print scalar localtime time;
evals/evals-freenode-#perl.lst[4978]: print scalar localtime time()
evals/evals-freenode-#perl.lst[4979]: print scalar localtime time();
evals/evals-freenode-#perl.lst[4980]: print scalar loclatime $^T
evals/evals-freenode-#perl.lst[4981]: print scalar reverse "my string"
evals/evals-freenode-#perl.lst[4982]: print scalar $^T
evals/evals-freenode-#perl.lst[4983]: print $self
evals/evals-freenode-#perl.lst[4984]: print ( sort ( 1..9 ));
evals/evals-freenode-#perl.lst[4985]: print sort 97..102
evals/evals-freenode-#perl.lst[4986]: print "$_," sort ( 99, 111 );
evals/evals-freenode-#perl.lst[4987]: print sort ( 99, 111 );
evals/evals-freenode-#perl.lst[4988]: print sort ( printf("%d", rand(100)), printf("%d", rand()) )
evals/evals-freenode-#perl.lst[4989]: print sort qw( 1 5 2 3 7 4 6 9 8 0);
evals/evals-freenode-#perl.lst[4990]: print sort { (rand()) <=> (rand()) }
evals/evals-freenode-#perl.lst[4991]: print sort { (rand()) <=> (rand()) } qw(a b c d);
evals/evals-freenode-#perl.lst[4992]: print sort { rand <=> rand } qw(a b c d);
evals/evals-freenode-#perl.lst[4993]: print sort { rand() <=> rand } qw(a b c d);
evals/evals-freenode-#perl.lst[4994]: print sort {$|--} "tuJsa nohterP er lhakcer," =~ /./g
evals/evals-freenode-#perl.lst[4995]: print sprintf("Hello %s!", uc "Corin");
evals/evals-freenode-#perl.lst[4996]: print sqrt length "zomg"
evals/evals-freenode-#perl.lst[4997]: print {STDOUT} 1,2;
evals/evals-freenode-#perl.lst[4998]: print STDOUT chr 8305
evals/evals-freenode-#perl.lst[4999]: print system("dir")
FAILED TO EVAL!
evals/evals-freenode-#perl.lst[5000]: print system("ls")
FAILED TO EVAL!
evals/evals-freenode-#perl.lst[5001]: print $t
evals/evals-freenode-#perl.lst[5002]: print $^T
evals/evals-freenode-#perl.lst[5003]: print test
evals/evals-freenode-#perl.lst[5004]: print 'test'
evals/evals-freenode-#perl.lst[5005]: print "test"
evals/evals-freenode-#perl.lst[5006]: print $this_variable_does_not_exist;
evals/evals-freenode-#perl.lst[5007]: print "Time for coffee" if $!{ENOCAFFIENE}
evals/evals-freenode-#perl.lst[5008]: print true
evals/evals-freenode-#perl.lst[5009]: print ^T => scalar localtime time => time
evals/evals-freenode-#perl.lst[5010]: print uc sprintf("Hello %s!", "Corin");
evals/evals-freenode-#perl.lst[5011]: [ print => undef ]
evals/evals-freenode-#perl.lst[5012]: print undef => 1
evals/evals-freenode-#perl.lst[5013]: print ${^UNICODE}
evals/evals-freenode-#perl.lst[5014]: print unpack("b8", "a")
evals/evals-freenode-#perl.lst[5015]: print `uptime`
evals/evals-freenode-#perl.lst[5016]: print $^V
evals/evals-freenode-#perl.lst[5017]: print v128169
evals/evals-freenode-#perl.lst[5018]: print v3232.95.3232
evals/evals-freenode-#perl.lst[5019]: print v9825
evals/evals-freenode-#perl.lst[5020]: print '$variable'
evals/evals-freenode-#perl.lst[5021]: print "very well"
evals/evals-freenode-#perl.lst[5022]: print "$_ " while $_ = glob 'test' =~ s/([a-z])/{\l$1,\u$1}/gir  # what was wrong with this ?
evals/evals-freenode-#perl.lst[5023]: print "\x{0622}"
evals/evals-freenode-#perl.lst[5024]: print $x=1, $x=2, $x=3, $x=4, $x=5;
evals/evals-freenode-#perl.lst[5025]: print '-' x 35 . "\n";
evals/evals-freenode-#perl.lst[5026]: print '-' x 35."\n";
evals/evals-freenode-#perl.lst[5027]: print "\x{ffff}"
evals/evals-freenode-#perl.lst[5028]: print "\xffff"
evals/evals-freenode-#perl.lst[5029]: print \xffff
evals/evals-freenode-#perl.lst[5030]: print "x" for qw(1 2 3);
evals/evals-freenode-#perl.lst[5031]: print "Yes we do";
evals/evals-freenode-#perl.lst[5032]: product 1..10
evals/evals-freenode-#perl.lst[5033]: prototype \&CORE::bless
evals/evals-freenode-#perl.lst[5034]: prototype 'CORE::bless' ? 'yes' : 'no'
evals/evals-freenode-#perl.lst[5035]: prototype "CORE::glob"
evals/evals-freenode-#perl.lst[5036]: prototype \&CORE::join
evals/evals-freenode-#perl.lst[5037]: prototype \&CORE::lc
evals/evals-freenode-#perl.lst[5038]: prototype 'CORE::open'
evals/evals-freenode-#perl.lst[5039]: prototype "CORE::open"
evals/evals-freenode-#perl.lst[5040]: prototype "CORE::pack"
evals/evals-freenode-#perl.lst[5041]: prototype \&CORE::print
evals/evals-freenode-#perl.lst[5042]: prototype \&CORE::prototype
evals/evals-freenode-#perl.lst[5043]: prototype 'CORE::push'
evals/evals-freenode-#perl.lst[5044]: prototype "CORE::push"
evals/evals-freenode-#perl.lst[5045]: prototype(\&CORE::push)
evals/evals-freenode-#perl.lst[5046]: prototype 'CORE::ref'
evals/evals-freenode-#perl.lst[5047]: prototype \&CORE::ref
evals/evals-freenode-#perl.lst[5048]: prototype \&CORE::sleep
evals/evals-freenode-#perl.lst[5049]: prototype 'CORE::sort'
evals/evals-freenode-#perl.lst[5050]: prototype 'CORE::splice'
evals/evals-freenode-#perl.lst[5051]: prototype(\&CORE::split)
evals/evals-freenode-#perl.lst[5052]: prototype \&CORE::substr
evals/evals-freenode-#perl.lst[5053]: prototype 'CORE::undef'
evals/evals-freenode-#perl.lst[5054]: prototype "CORE::warn"
evals/evals-freenode-#perl.lst[5055]: prototype "CORE::write"
evals/evals-freenode-#perl.lst[5056]: prototype sub :proto($$) {}
evals/evals-freenode-#perl.lst[5057]: provides scalar context
evals/evals-freenode-#perl.lst[5058]: prtin 1
evals/evals-freenode-#perl.lst[5059]: @P=split//,".URRUU\c8R";@d=split//,"\nrekcah xinU / lreP rehtona tsuJ";sub p{ @p{"r$p","u$p"}=(P,P);pipe"r$p","u$p";++$p;($q*=2)+=$f=!fork;map{$P=$P[$f^ord ($p{$_})&6];$p{$_}=/ ^$P/ix?$P:close$_}keys%p}p;p;p;p;p;map{$p{$_}=~/^[P.]/&& close$_}%p;wait until$?;map{/^r/&&<$_>}%p;$_=$d[$q];sleep rand(2)if/\S/;print
evals/evals-freenode-#perl.lst[5060]: $_="psychology"; print reverse;
evals/evals-freenode-#perl.lst[5061]: $_="psychology"; tr/a-z/z-a/g; print;
evals/evals-freenode-#perl.lst[5062]: $_ = 'psychology'; $za = join('', reverse 'a' .. 'z'); eval "tr/a-z/$za/"; $_
evals/evals-freenode-#perl.lst[5063]: $_ = 'psychology'; $za = join('', reverse 'a' .. 'z'); eval "tr/a-z/$za"; $_
evals/evals-freenode-#perl.lst[5064]: $_ = 'psychology'; $za = join('', 'z' .. 'a'); eval "tr/a-z/$za"; $_
evals/evals-freenode-#perl.lst[5065]: 'pthr bots' =~ tr/op/io/r
evals/evals-freenode-#perl.lst[5066]: '·' =~ /[[:punct:]]/
evals/evals-freenode-#perl.lst[5067]: '§' =~ /[[:punct:]]/
evals/evals-freenode-#perl.lst[5068]: push @_, !
evals/evals-freenode-#perl.lst[5069]: [push [], 1]
evals/evals-freenode-#perl.lst[5070]: push (@_,"alpha"); push (@_,"omega"); print "Grinnz_ is the $_[0] and the $_[$#_]\n"
evals/evals-freenode-#perl.lst[5071]: $|++; push @a, $|; $|--; push @a, $|; $|--; push @a,  $|; \@a
evals/evals-freenode-#perl.lst[5072]: [ push [], 'a' ]  # thus
evals/evals-freenode-#perl.lst[5073]: push foo, 1, 2
evals/evals-freenode-#perl.lst[5074]: (++$_ && push(@foo, $_)) for 1..10; join ',',@foo;
evals/evals-freenode-#perl.lst[5075]: push @foo, glob "/" for (1..10); \@foo
evals/evals-freenode-#perl.lst[5076]: push $hash{foo}, 'something'; \%hash
evals/evals-freenode-#perl.lst[5077]: push $hash->{foo}->@*, "wibble"; $hash
evals/evals-freenode-#perl.lst[5078]: push @{ $href->{key} }, qw(a b c); $href
evals/evals-freenode-#perl.lst[5079]: push @l, $-[0] while "banana" =~ /b|a|n/g; [@l]
evals/evals-freenode-#perl.lst[5080]: push @players, [ "Dealer", "", "" ]; push @players, [ "AcidRain", "50", "" ];     [ @players ]
evals/evals-freenode-#perl.lst[5081]: push @strings, $_ =~ m/^\w*/
evals/evals-freenode-#perl.lst[5082]: push @strings, [$_ =~ /^\w+/];
evals/evals-freenode-#perl.lst[5083]: push @{$x->{foo}}, 'bar'; push @{$x->{foo}}, 'baz'; $x  # or with $x not even hodling anything to begin with
evals/evals-freenode-#perl.lst[5084]: `pwd`;
evals/evals-freenode-#perl.lst[5085]: q 😁 :) 😁
evals/evals-freenode-#perl.lst[5086]: q{}
evals/evals-freenode-#perl.lst[5087]: q{\}
evals/evals-freenode-#perl.lst[5088]: /\Q[/
evals/evals-freenode-#perl.lst[5089]: "\Q!"
evals/evals-freenode-#perl.lst[5090]: $_ = q("...); /()(.)/; [$2]
evals/evals-freenode-#perl.lst[5091]: q5.22.0
evals/evals-freenode-#perl.lst[5092]: q{"90020",33.786594,"-118.298662","Los Angeles","CA","Los Angeles"} =~ s/^(".+").+$/$1/r
evals/evals-freenode-#perl.lst[5093]: q \ a\ b\ c ;
evals/evals-freenode-#perl.lst[5094]: [ q{abc def 123 ghi} =~ m/\b([A-Za-z]+)\b/g ]; # Where as this matches all three.
evals/evals-freenode-#perl.lst[5095]: [ q{abc def 123 ghi} =~ m/(?:^|\s)([A-Za-z]+)(?=\s|$)/g ]
evals/evals-freenode-#perl.lst[5096]: [ q{abc def 123 ghi} =~ m/(?:^|\s)([A-Za-z]+)(?:\s|$)/g ]; # Why doesn't 'def' get matched?
evals/evals-freenode-#perl.lst[5097]: $_= q/a b c d e f g/; @vars = (split)[2]; \@vars
evals/evals-freenode-#perl.lst[5098]: $_= q/a b c d/; @vars = (split)[2,3]; \@vars
evals/evals-freenode-#perl.lst[5099]: q aeven thisa
evals/evals-freenode-#perl.lst[5100]: $_=q{an if1 " some if2 " then "if3" not if4!!};  [ /(if\d)(?=(?:[^"]|"[^"]*")*$)/g ]
evals/evals-freenode-#perl.lst[5101]: $_=q{an if1 " some if2 " then "if3" not if4!!};  [ /"[^"]*"(*SKIP)(*F)|if\d/g ]
evals/evals-freenode-#perl.lst[5102]: q caller vec
evals/evals-freenode-#perl.lst[5103]: ["\Q$code"]
evals/evals-freenode-#perl.lst[5104]: $_ = q,echo foo bar=baz hmm="1 2 3" nn='aa bb',; my @h; s/((["'])(?:[^"']+|\\.|(?!\2).)*\2)/push @h, $1;"\xFFFD"/ge; my @words = split ' '; s/\xFFFD/shift @h/ge for @words; \@words;
evals/evals-freenode-#perl.lst[5105]: [ q{$ENV{HOME}}, qq{$ENV{HOME} ];
evals/evals-freenode-#perl.lst[5106]: [ q{$ENV{HOME}}, qq{$ENV{HOME}} ];
evals/evals-freenode-#perl.lst[5107]: q\foo\
evals/evals-freenode-#perl.lst[5108]: q\foo\\bar\
evals/evals-freenode-#perl.lst[5109]: "\Qf(o+o*)\Ebar"
evals/evals-freenode-#perl.lst[5110]: "\Qfoo\Ebar"
evals/evals-freenode-#perl.lst[5111]: q\foo\ =~ m\foo\
evals/evals-freenode-#perl.lst[5112]: q\foo\ =~ s\foo\bar\r
evals/evals-freenode-#perl.lst[5113]: q{foo} x 2.5 # Would be interesting if this coudl actually produce a sub string.
evals/evals-freenode-#perl.lst[5114]: q ̈hellö
evals/evals-freenode-#perl.lst[5115]: q̈hellö
evals/evals-freenode-#perl.lst[5116]: q̈hellö . ""
evals/evals-freenode-#perl.lst[5117]: q{I think perl bot is down?}
evals/evals-freenode-#perl.lst[5118]: qq("")
evals/evals-freenode-#perl.lst[5119]: qq("\")
evals/evals-freenode-#perl.lst[5120]: qq(\)
evals/evals-freenode-#perl.lst[5121]: q qa b c ' dq # great idea
evals/evals-freenode-#perl.lst[5122]: q qaq =~ m\a\
evals/evals-freenode-#perl.lst[5123]: qq'$bar'
evals/evals-freenode-#perl.lst[5124]: qq(foo\tbar)
evals/evals-freenode-#perl.lst[5125]: [ qq(hello there "test test" more testing) =~ /"([^"]+)"|(\S+)/g ]
evals/evals-freenode-#perl.lst[5126]: [ qq(    "  some extra spaces " hello there "test test" more testing) =~ /"([^"]+)"|(\S+)/g ]
evals/evals-freenode-#perl.lst[5127]: [ qq(  "space1   "   space2 ) =~ /"([^"]+)"|(\S+)/g ]
evals/evals-freenode-#perl.lst[5128]: [q{"}.quotemeta("foo\r\n\tbar\n").q{"}]
evals/evals-freenode-#perl.lst[5129]: [ qr/[ @_ ]/ ]
evals/evals-freenode-#perl.lst[5130]: qr/ @_ /
evals/evals-freenode-#perl.lst[5131]: qr/(?[ () ])/
evals/evals-freenode-#perl.lst[5132]: qr/[[]/
evals/evals-freenode-#perl.lst[5133]: qr/^cats$/ . ""
evals/evals-freenode-#perl.lst[5134]: qr{(?(DEFINE)};
evals/evals-freenode-#perl.lst[5135]: qr/e$d/
evals/evals-freenode-#perl.lst[5136]: q{regexp_substr(fn.stringvalue, '\w+\s\w+') user_full_name}
evals/evals-freenode-#perl.lst[5137]: qr/*.*/ # not with that first * in there, no
evals/evals-freenode-#perl.lst[5138]: qr/\Q$foo/
evals/evals-freenode-#perl.lst[5139]: [qr/\Qfoo/, qr'\Qfoo']
evals/evals-freenode-#perl.lst[5140]: qr/(?^:\Q(s))/
evals/evals-freenode-#perl.lst[5141]: qr/\Q(s)/
evals/evals-freenode-#perl.lst[5142]: qr'\Q/s.'
evals/evals-freenode-#perl.lst[5143]: qr'\Q(s)'
evals/evals-freenode-#perl.lst[5144]: qr/(?^:\Q(s)\E)/
evals/evals-freenode-#perl.lst[5145]: qr/\Q$x/
evals/evals-freenode-#perl.lst[5146]: qr'(s)'
evals/evals-freenode-#perl.lst[5147]: '' . qr/something/msx
evals/evals-freenode-#perl.lst[5148]: qr!span class="full_user_string">.*?<span.*?>(.*?)</.*?class="posting_timestamp" +title="(.*?)".*?class="thread_title">.*?<a .*?>\s*(.*?)\s*<.*?div class="post">(.*?)<div class="rate_buttons"!si; 42
evals/evals-freenode-#perl.lst[5149]: [ qr/\s+:SerialNumber\s+/, "\s+:SerialNumber\s+" ]
evals/evals-freenode-#perl.lst[5150]:  qr/(?s)<tr/ . ''
evals/evals-freenode-#perl.lst[5151]: qr/<tr/s . ''
evals/evals-freenode-#perl.lst[5152]: qr/what does this do/x
evals/evals-freenode-#perl.lst[5153]: qr/(\.xls$|\.xlsx$)/
evals/evals-freenode-#perl.lst[5154]: qr/(?=.|\z)*.*/
evals/evals-freenode-#perl.lst[5155]: quotemeta <>
evals/evals-freenode-#perl.lst[5156]: quotemeta <\<\>>
evals/evals-freenode-#perl.lst[5157]: quotemeta '~!@#$%^&*()_\\{}.,+?'
evals/evals-freenode-#perl.lst[5158]: quotemeta '<>'
evals/evals-freenode-#perl.lst[5159]: quotemeta '!'
evals/evals-freenode-#perl.lst[5160]: quotemeta "_"
evals/evals-freenode-#perl.lst[5161]: quotemeta ":"
evals/evals-freenode-#perl.lst[5162]: quotemeta 'abcdefg[\]$%^&*()'
evals/evals-freenode-#perl.lst[5163]: quotemeta 'hello world'
evals/evals-freenode-#perl.lst[5164]: quotemeta 'hello:world'
evals/evals-freenode-#perl.lst[5165]: quotemeta q<<>>
evals/evals-freenode-#perl.lst[5166]: quotemeta(q{\/})
evals/evals-freenode-#perl.lst[5167]: quotemeta(qq{\/})
evals/evals-freenode-#perl.lst[5168]: [ quotemeta(q{\/}), quotemeta(qq{\/}) ]
evals/evals-freenode-#perl.lst[5169]: [ quotemeta 'test@example.com' ]
evals/evals-freenode-#perl.lst[5170]: quotemeta "\x{D000}"
evals/evals-freenode-#perl.lst[5171]: quoutemeta <>
evals/evals-freenode-#perl.lst[5172]: quoutemeta( <> )
evals/evals-freenode-#perl.lst[5173]: qv'5.22.0'
evals/evals-freenode-#perl.lst[5174]: qv5.22.0
evals/evals-freenode-#perl.lst[5175]: [qw()]
evals/evals-freenode-#perl.lst[5176]: qw()
evals/evals-freenode-#perl.lst[5177]: [ qw( a b c ) x 3 ]
evals/evals-freenode-#perl.lst[5178]: qw( a b c ) x 3
evals/evals-freenode-#perl.lst[5179]: [qw(Attachment) x 3]
evals/evals-freenode-#perl.lst[5180]: qw/Attachment/ x 3
evals/evals-freenode-#perl.lst[5181]: [qw(email@one.com email@two.com)]
evals/evals-freenode-#perl.lst[5182]: "@{ [ %{ [qw/foo bar baz/] } ] }"
evals/evals-freenode-#perl.lst[5183]: "%{ [qw/foo bar baz/] }"
evals/evals-freenode-#perl.lst[5184]: [ qw(foo bar baz) ]
evals/evals-freenode-#perl.lst[5185]: qw/foo bar baz/
evals/evals-freenode-#perl.lst[5186]: qw(foo bar baz)
evals/evals-freenode-#perl.lst[5187]: qw(foo bar baz)[2]
evals/evals-freenode-#perl.lst[5188]: qw/foo bar baz quux/[1]
evals/evals-freenode-#perl.lst[5189]: [ qw ( &my_function) ] # Prostetnic
evals/evals-freenode-#perl.lst[5190]: [ qw(#no) ]
evals/evals-freenode-#perl.lst[5191]: $qwqwerqwe = 1;
evals/evals-freenode-#perl.lst[5192]: +{ qw/you can dump a hashref directly/ }
evals/evals-freenode-#perl.lst[5193]: qx(id);
evals/evals-freenode-#perl.lst[5194]: qx(ls /);
evals/evals-freenode-#perl.lst[5195]: qx(whoami)
evals/evals-freenode-#perl.lst[5196]: q  hello world ;
evals/evals-freenode-#perl.lst[5197]: q  hello\ world ;
evals/evals-freenode-#perl.lst[5198]: rand() < 0.5 ? 'vending machine works' : 'vending machine refuses to give you anything'
evals/evals-freenode-#perl.lst[5199]: rand * 3
evals/evals-freenode-#perl.lst[5200]: rand +   *    34
evals/evals-freenode-#perl.lst[5201]: [rand() * 5000, rand * 5000]
evals/evals-freenode-#perl.lst[5202]: rand * 5000 # unary * is a useful feature too
evals/evals-freenode-#perl.lst[5203]: random(100)
evals/evals-freenode-#perl.lst[5204]: [ "  random\t\nwhitespace\r" =~ /\S+/g ]
evals/evals-freenode-#perl.lst[5205]: rand * time
evals/evals-freenode-#perl.lst[5206]: rand() * time()
evals/evals-freenode-#perl.lst[5207]: "RASH DEAL"
evals/evals-freenode-#perl.lst[5208]: RASH DEAL
evals/evals-freenode-#perl.lst[5209]: $re0 = "x?y+"; $re1 = qr/$re0/; $re2 = qr/$re1/; [ $re0, $re1, $re2 ]
evals/evals-freenode-#perl.lst[5210]: $re1 = qr/x?y+/; $re2 = qr/$re1/; [ $re1, $re2 ]
evals/evals-freenode-#perl.lst[5211]: readline "{a,b,c}"
evals/evals-freenode-#perl.lst[5212]: reduce 1
evals/evals-freenode-#perl.lst[5213]: reduce {$a + $b} 1
evals/evals-freenode-#perl.lst[5214]: ref [];
evals/evals-freenode-#perl.lst[5215]: ref \[1]
evals/evals-freenode-#perl.lst[5216]: ref \\1
evals/evals-freenode-#perl.lst[5217]: ref \ []->[3]
evals/evals-freenode-#perl.lst[5218]: ref \$a
evals/evals-freenode-#perl.lst[5219]: ref \\\\\\$a
evals/evals-freenode-#perl.lst[5220]: ref bless {}, 'ARRAY'
evals/evals-freenode-#perl.lst[5221]: ref( bless {}, "Here is a lovely long string that I invented one summer's day" )
evals/evals-freenode-#perl.lst[5222]: ref ["item1","item2"]
evals/evals-freenode-#perl.lst[5223]: ref localtime
evals/evals-freenode-#perl.lst[5224]: ref main::
evals/evals-freenode-#perl.lst[5225]: ref qr//
evals/evals-freenode-#perl.lst[5226]: ref qr//;
evals/evals-freenode-#perl.lst[5227]: [ ref *STDOUT{IO} ]
evals/evals-freenode-#perl.lst[5228]: ref \(substr "aliens", 0, 2)
evals/evals-freenode-#perl.lst[5229]: ref \v1.2.3
evals/evals-freenode-#perl.lst[5230]: ref v1.2.3
evals/evals-freenode-#perl.lst[5231]: ref([v1.2.3]->[0])
evals/evals-freenode-#perl.lst[5232]: ref( $x = wantarray ); [$x]
evals/evals-freenode-#perl.lst[5233]: $regex = "*meow*"; "banana" =~ /$regex/;
evals/evals-freenode-#perl.lst[5234]: [ 'Regexp'->can('(""') ]
evals/evals-freenode-#perl.lst[5235]: [ 'Regexp'->can('(+0') ]
evals/evals-freenode-#perl.lst[5236]: rename("/opt/google/chrome", "/opt/google/egacs") or die "$!"
evals/evals-freenode-#perl.lst[5237]: $re=qr/(\d{7})/; [ "12345678" =~ $re, "1234567" =~ $re ]
evals/evals-freenode-#perl.lst[5238]: $re=qr/(?<!\D)(\d{7})(?!\D)/; [ "12345678" =~ $re, "1234567" =~ $re ]
evals/evals-freenode-#perl.lst[5239]: $re = '['; /\Q$re/
evals/evals-freenode-#perl.lst[5240]: require(0 + "inf")
evals/evals-freenode-#perl.lst[5241]: require 5
evals/evals-freenode-#perl.lst[5242]: require 5.0.6;
evals/evals-freenode-#perl.lst[5243]: require 5blah
evals/evals-freenode-#perl.lst[5244]: require 'App::Pluggable';
evals/evals-freenode-#perl.lst[5245]: require bigint; bigint->import; 1<<70
evals/evals-freenode-#perl.lst[5246]: require JSON::XS; JSON::XS::encode_json {hi => 123};
evals/evals-freenode-#perl.lst[5247]: require 'Some::Module:__XYZ'
evals/evals-freenode-#perl.lst[5248]: require Some::Module:__XYZ
evals/evals-freenode-#perl.lst[5249]: require Time::Moment; my $now = Time::Moment->now;  $now->with_hour(op)->with_minute(0)->with_second(0);
evals/evals-freenode-#perl.lst[5250]: $re = '['; /$re/
evals/evals-freenode-#perl.lst[5251]: return join(',', @accounts);
evals/evals-freenode-#perl.lst[5252]: return or die;
evals/evals-freenode-#perl.lst[5253]: "Return value"; "Miesco";
evals/evals-freenode-#perl.lst[5254]: [ reverse("6.4.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.1.0.0.0.0.1.1.8.2.a.1.0.0.b.3" =~ tr/.//dr) =~ /.{4}/g ]
evals/evals-freenode-#perl.lst[5255]: reverse "7c86467b"
evals/evals-freenode-#perl.lst[5256]: reverse 'engineer'
evals/evals-freenode-#perl.lst[5257]: reverse proxy
evals/evals-freenode-#perl.lst[5258]: [ reverse "psychology" ]
evals/evals-freenode-#perl.lst[5259]: reverse((reverse 0x7f9241004ee8) =~ s/(...)/$1,/gr)
evals/evals-freenode-#perl.lst[5260]: reverse "string"
evals/evals-freenode-#perl.lst[5261]: reverse ("string")
evals/evals-freenode-#perl.lst[5262]: [ (reverse "string"), (reverse ("string")) ]
evals/evals-freenode-#perl.lst[5263]: reverse ("string", "string")  # :s
evals/evals-freenode-#perl.lst[5264]: [reverse("string","strong"), scalar reverse("string", "strong")]
evals/evals-freenode-#perl.lst[5265]: $_="rexma"; /(?{$name="foo"})re[x]ma|(?{$name="bar"})o[ther]matc/; $name
evals/evals-freenode-#perl.lst[5266]: @r = (foo => 1, bar => 2); ${{@r}}{"a"}
evals/evals-freenode-#perl.lst[5267]: rindex "1234abc", "c"
evals/evals-freenode-#perl.lst[5268]: rindex $_, "c" == length $_ - 1 for "1234abc"
evals/evals-freenode-#perl.lst[5269]: rmdir '/' or $!
evals/evals-freenode-#perl.lst[5270]: "\r\n" =~ /^\R$/
evals/evals-freenode-#perl.lst[5271]: $row = [qw(hi one two)]; unshift(@$row, substr($row->[0],-10)); $row
evals/evals-freenode-#perl.lst[5272]: "\s"
evals/evals-freenode-#perl.lst[5273]: "\s+"
evals/evals-freenode-#perl.lst[5274]: s =~ =///=
evals/evals-freenode-#perl.lst[5275]: /@(\S+)/
evals/evals-freenode-#perl.lst[5276]: /\s{0,}(#{0,})SANITY01/
evals/evals-freenode-#perl.lst[5277]: /\s{0,}(\#{0,})SANITY01/x
evals/evals-freenode-#perl.lst[5278]: /\s{0,}(#{0,})SANITY01/x
evals/evals-freenode-#perl.lst[5279]: "S01E" . $1 * 2
evals/evals-freenode-#perl.lst[5280]: S01E($1*2)
evals/evals-freenode-#perl.lst[5281]: s/..(..).*/$1/ for@x=([],{},$",\&f,\0);print@x
evals/evals-freenode-#perl.lst[5282]: s/..(..).*/$1/ for@x=([],{},$",\&f,\0);$"="";"@x"
evals/evals-freenode-#perl.lst[5283]: s/..(..).*/$1/,print for@x=([],{},$",\&f,\0)
evals/evals-freenode-#perl.lst[5284]: $s1 = ''; $s2 = 'foo'; $s3 = $s1 || $s2; [$s3]
evals/evals-freenode-#perl.lst[5285]: "////" =~ s{/{2,}}{/}gr
evals/evals-freenode-#perl.lst[5286]: $s=(3+undef)/2;print $s
evals/evals-freenode-#perl.lst[5287]: @s=[4,5,6];print join " ",@s[-1..-2];
evals/evals-freenode-#perl.lst[5288]: @s=[4,5,6];print @s[-1..-2];#since no one's talking in here anyway, may as well use the bot
evals/evals-freenode-#perl.lst[5289]: $s = "a,b also has, commas,c,d,e,has,commas,f,g"; $s =~ s/(,[^,]+){2}$//;  "e is '" . (split ",", $s, 5)[4] . "'"
evals/evals-freenode-#perl.lst[5290]: $s = "a,b,c,d,e,has,commas,f,g"; $s =~ s/(,[^,]+){2}$//;  "e is '" . (split ",", $s, 5)[4] . "'"
evals/evals-freenode-#perl.lst[5291]: $s="a.b.c.d"; $h{a}{b}{c}{d}=123;  $r=\%h; $r=$r->{$_} for split/\./,$s; $r
evals/evals-freenode-#perl.lst[5292]: $s="a.b.c.d"; $h{a}{b}{c}{d}=123;  $r=\%h; $r=$r->{$_} for split/\./,$s; $r'
evals/evals-freenode-#perl.lst[5293]: $s="a.b.c.d"; my %h; @h{ split(/\./, $s) } = (1, 2, 3, 4); print keys %h, print values %h;
evals/evals-freenode-#perl.lst[5294]: $s = '*';  "a*b*c" =~ /\Q$s/ ? "Match" : "No match"
evals/evals-freenode-#perl.lst[5295]: $s = '*';  "a*b*c" =~ /$s/ ? "Match" : "No match"
evals/evals-freenode-#perl.lst[5296]: "s" =~ /^((?:a|b|c)s?)?$/ # whatever dude
evals/evals-freenode-#perl.lst[5297]: $s = "{a}b}" $s =~ /\{(.*?)\}/; [$1]
evals/evals-freenode-#perl.lst[5298]: $s = "{a}b}"; $s =~ /\{(.*?)\}/; [$1]
evals/evals-freenode-#perl.lst[5299]: s/(A)/eval(lcfirst $1)/gee
evals/evals-freenode-#perl.lst[5300]: s/(A)/lcfirst $1/e
evals/evals-freenode-#perl.lst[5301]: s/(A)/lcfirst $1/re
evals/evals-freenode-#perl.lst[5302]: $_="&&&"; s/&/&amp;/g; [$_]
evals/evals-freenode-#perl.lst[5303]: s///apple
evals/evals-freenode-#perl.lst[5304]: s///asmallregex
evals/evals-freenode-#perl.lst[5305]: ${ \ 'save' }
evals/evals-freenode-#perl.lst[5306]: say $[
evals/evals-freenode-#perl.lst[5307]: say ~0;
evals/evals-freenode-#perl.lst[5308]: say$_*2for 1..10
evals/evals-freenode-#perl.lst[5309]: say(("a" x 10000) =~ /^(ab?)*$/ ? "Yes" : "No");
evals/evals-freenode-#perl.lst[5310]: say blahblah q|0.000.000_YYMMDDhhmm|
evals/evals-freenode-#perl.lst[5311]: say "damn them all to hell";
evals/evals-freenode-#perl.lst[5312]: say Encode::encode("ISO-8859-1", Encode::decode("UTF-8", "Ã¡r jÃº sÃºr?"));
evals/evals-freenode-#perl.lst[5313]: say $ENV{HOME}
evals/evals-freenode-#perl.lst[5314]: say "foo" if ("/page/show/1234" =~ m{page/});
evals/evals-freenode-#perl.lst[5315]: say for @INC
evals/evals-freenode-#perl.lst[5316]: say for keys %hash;
evals/evals-freenode-#perl.lst[5317]: say for keys %INC
evals/evals-freenode-#perl.lst[5318]: say 'hello'
evals/evals-freenode-#perl.lst[5319]: say hi
evals/evals-freenode-#perl.lst[5320]: say 'hi'
evals/evals-freenode-#perl.lst[5321]: say "hi"
evals/evals-freenode-#perl.lst[5322]: say length "0.99999999999991"
evals/evals-freenode-#perl.lst[5323]: say length q|0.000.000_YYMMDDhhmm|
evals/evals-freenode-#perl.lst[5324]: say lenqth q|0.000.000_YYMMDDhhmm|
evals/evals-freenode-#perl.lst[5325]: say ~~localtime(0.32099 * 1e6 + 1394981846);
evals/evals-freenode-#perl.lst[5326]: say ''.localtime(0.32099 * 1e6 + 1394981846);
evals/evals-freenode-#perl.lst[5327]: say q  hello\ world ;
evals/evals-freenode-#perl.lst[5328]: say q  hello\ world ;
evals/evals-freenode-#perl.lst[5329]: say"RASH DEAL"
evals/evals-freenode-#perl.lst[5330]: say something
evals/evals-freenode-#perl.lst[5331]: say "var $rindolf is better than var $generic_var"
evals/evals-freenode-#perl.lst[5332]: say what again
evals/evals-freenode-#perl.lst[5333]: say “whatever”
evals/evals-freenode-#perl.lst[5334]: say "wotcher"
evals/evals-freenode-#perl.lst[5335]: say ( ["wotcher"] )
evals/evals-freenode-#perl.lst[5336]: say ("wotcher")
evals/evals-freenode-#perl.lst[5337]: $s = "banana"; substr($s, 3,0) = "APPLE"; $s
evals/evals-freenode-#perl.lst[5338]: /(?<!S)\b/i
evals/evals-freenode-#perl.lst[5339]: '   ' =~ /\s\B\s/
evals/evals-freenode-#perl.lst[5340]: s/(?<\b!STYLESY0B\$\$)\b$k\b/<span class="kw1">$k<\/span>/igs
evals/evals-freenode-#perl.lst[5341]: [ *_{SCALAR} == \$_ ]
evals/evals-freenode-#perl.lst[5342]: scalar @_[0]
evals/evals-freenode-#perl.lst[5343]: [scalar( (0) x 5 )]
evals/evals-freenode-#perl.lst[5344]: scalar (() = (1..10))
evals/evals-freenode-#perl.lst[5345]: scalar () = (1..10)
evals/evals-freenode-#perl.lst[5346]: [ scalar('٣' =~ /^\d$/a), scalar('٣' =~ /^.$/a), scalar("٢" =~ /^[١-٣]$/a), scalar('٣' =~ /^\D$/a) ]
evals/evals-freenode-#perl.lst[5347]: scalar @{$arrayref}[1,2,3]
evals/evals-freenode-#perl.lst[5348]: scalar "asd1312321asd1212asd121212" =~/(asd\d+)/g;
evals/evals-freenode-#perl.lst[5349]: scalar  ( "A" ) x 3
evals/evals-freenode-#perl.lst[5350]: scalar  +( "A" ) x 3
evals/evals-freenode-#perl.lst[5351]: scalar CORE::gmtime 1404990000
evals/evals-freenode-#perl.lst[5352]: scalar CORE::gmtime 1405095671
evals/evals-freenode-#perl.lst[5353]: scalar CORE::localtime
evals/evals-freenode-#perl.lst[5354]: scalar CORE::localtime 1393955488
evals/evals-freenode-#perl.lst[5355]: scalar CORE::localtime 1404972000
evals/evals-freenode-#perl.lst[5356]: scalar CORE::localtime( 1446568703 );
evals/evals-freenode-#perl.lst[5357]: scalar @{ $foo{bar}{baz} // [] }
evals/evals-freenode-#perl.lst[5358]: scalar(()=glob('*'))  # probably 0
evals/evals-freenode-#perl.lst[5359]: [scalar gmtime]
evals/evals-freenode-#perl.lst[5360]: scalar grep /isnt/, qw/list of words/
evals/evals-freenode-#perl.lst[5361]: scalar grep /is/, qw/list of words/
evals/evals-freenode-#perl.lst[5362]: scalar \%hash
evals/evals-freenode-#perl.lst[5363]: scalar %hash
evals/evals-freenode-#perl.lst[5364]: [''.(scalar localtime)]
evals/evals-freenode-#perl.lst[5365]: [''.scalar localtime]
evals/evals-freenode-#perl.lst[5366]: scalar localtime
evals/evals-freenode-#perl.lst[5367]: scalar localtime 1393955488
evals/evals-freenode-#perl.lst[5368]: scalar localtime 1422281441
evals/evals-freenode-#perl.lst[5369]: scalar localtime 1427744321029
evals/evals-freenode-#perl.lst[5370]: [[''.scalar localtime],[localtime]]
evals/evals-freenode-#perl.lst[5371]: [[scalar localtime],[localtime]]
evals/evals-freenode-#perl.lst[5372]: scalar localtime $^T
evals/evals-freenode-#perl.lst[5373]: scalar localtime time
evals/evals-freenode-#perl.lst[5374]: scalar(@order) = 2; @order and @order = grep $_, @order[-2, -1]
evals/evals-freenode-#perl.lst[5375]: scalar qw/1 2 3/;   # this should be more confusing :p
evals/evals-freenode-#perl.lst[5376]: [scalar qw(Attachment) x 3]
evals/evals-freenode-#perl.lst[5377]: scalar reverse 'abc'
evals/evals-freenode-#perl.lst[5378]: "${\scalar reverse 'foo'}"
evals/evals-freenode-#perl.lst[5379]: [ scalar reverse "psychology" ]
evals/evals-freenode-#perl.lst[5380]: [ scalar '' =~ /^$/, scalar 'a' =~ /^$/]
evals/evals-freenode-#perl.lst[5381]: scalar scalar scalar [1, 3, 5]
evals/evals-freenode-#perl.lst[5382]: "${\scalar sub { wantarray() ? 'list' : 'scalar' }->()}"
evals/evals-freenode-#perl.lst[5383]: scalar $^T
evals/evals-freenode-#perl.lst[5384]: scalar time
evals/evals-freenode-#perl.lst[5385]: scalar Time::Piece::localtime
evals/evals-freenode-#perl.lst[5386]: scalar Time::Piece::localtime .= ""
evals/evals-freenode-#perl.lst[5387]: [ Scalar::Util::looks_like_number '1 ' ]
evals/evals-freenode-#perl.lst[5388]: Scalar::Util::looks_like_number("4")
evals/evals-freenode-#perl.lst[5389]: Scalar::Util::looks_like_number( 'inf')
evals/evals-freenode-#perl.lst[5390]: Scalar::Util::looks_like_number('-INF')
evals/evals-freenode-#perl.lst[5391]: Scalar::Util::looks_like_number('INF')
evals/evals-freenode-#perl.lst[5392]: Scalar::Util::looks_like_number( 'inferior')
evals/evals-freenode-#perl.lst[5393]: Scalar::Util::looks_like_number "nan"
evals/evals-freenode-#perl.lst[5394]: Scalar::Util::looks_like_number 'NaN'
evals/evals-freenode-#perl.lst[5395]: Scalar::Util::looks_like_number( 'NaN')
evals/evals-freenode-#perl.lst[5396]: Scalar::Util->VERSION
evals/evals-freenode-#perl.lst[5397]: [scalar  ('?') x 10 ] # lol?
evals/evals-freenode-#perl.lst[5398]: { scalar => ('?' x 3), list => [ ('?') x 3 ] }
evals/evals-freenode-#perl.lst[5399]: !!"scotsmen"
evals/evals-freenode-#perl.lst[5400]: s///course
evals/evals-freenode-#perl.lst[5401]: $script = "cats"; "script/\@id=$script"
evals/evals-freenode-#perl.lst[5402]: $_ = 'sdfaosdkf!foobar!pokasdf!'; [ m/!(.+?)!/ ];
evals/evals-freenode-#perl.lst[5403]: s///eeeeeeeeeeeeeee
evals/evals-freenode-#perl.lst[5404]: s/^/"-"/ee if 0;
evals/evals-freenode-#perl.lst[5405]: see your paste
evals/evals-freenode-#perl.lst[5406]: s///eieio
evals/evals-freenode-#perl.lst[5407]: s/^/-/e if 0;
evals/evals-freenode-#perl.lst[5408]: s/$/$/$///$//e # $ in regex makes perl uneasy too
evals/evals-freenode-#perl.lst[5409]: select
evals/evals-freenode-#perl.lst[5410]: [select]
evals/evals-freenode-#perl.lst[5411]: "SELECT id, name, unidade_id, pcu, regexp_replace(barcode, '\\s+', '', 'g') as barcode from articles;"
evals/evals-freenode-#perl.lst[5412]: select->print("hmm")
evals/evals-freenode-#perl.lst[5413]: [ "SELECT \@rownum:=0", 'SELECT @rownum:=0' ]
evals/evals-freenode-#perl.lst[5414]: "$self"
evals/evals-freenode-#perl.lst[5415]: $self
evals/evals-freenode-#perl.lst[5416]: [ "    Sender:example\@domain.com\n" =~ qr/(?|from=<([^>]+)>,src=|^\s+Sender:(.*?)$)/ ]
evals/evals-freenode-#perl.lst[5417]: [ "    Sender:example\@domain.com\n" =~ qr/from=<([^>]+)>,src=|^\s+Sender:(.*?)$/ ]
evals/evals-freenode-#perl.lst[5418]: [ '    Sender:example@domain.com' =~ qr/from=<([^>]+)>,src=|^\s+Sender:(.*?)$/ ]
evals/evals-freenode-#perl.lst[5419]: [ "    Sender:example@domain.com" =~ qr/from=<([^>]+)>,src=|^\s+Sender:(.*?)$/ ]
evals/evals-freenode-#perl.lst[5420]: s***exmag
evals/evals-freenode-#perl.lst[5421]: $s = 'foo'; undef $s; $s .= 'bar';
evals/evals-freenode-#perl.lst[5422]: sftp> ls
evals/evals-freenode-#perl.lst[5423]: s/(...)...)?//g
evals/evals-freenode-#perl.lst[5424]: s/\+\/g
evals/evals-freenode-#perl.lst[5425]: "////" =~ s{//}{/}gr
evals/evals-freenode-#perl.lst[5426]: "////" =~ s{/+}{/}gr
evals/evals-freenode-#perl.lst[5427]: "+-" =~ s/[+-]/!/gr
evals/evals-freenode-#perl.lst[5428]: shift @_
evals/evals-freenode-#perl.lst[5429]: shift $foo;
evals/evals-freenode-#perl.lst[5430]: shift; # fully optimized
evals/evals-freenode-#perl.lst[5431]: "shop_image/importer/1000003/00_1000003.jpg" =~ /(\d\d_\d{7,7})\.jpg/; $1
evals/evals-freenode-#perl.lst[5432]: $s="http://a?k1=v1&k2=v2"; [$s=~/.*?\?(?:([^=]+)=([^&]+)&?)+/g]
evals/evals-freenode-#perl.lst[5433]: $s = "http://a?k1=v1&k2=v2"; [ $s =~ /[?&]([^=]+)=([^&]+)/g ]
evals/evals-freenode-#perl.lst[5434]: $SIG{CHLD}
evals/evals-freenode-#perl.lst[5435]: $SIG{__DIE__} = sub { print "don't do this: @_" }; eval { die "you didn't see me, right" };
evals/evals-freenode-#perl.lst[5436]: $SIG{__DIE__} = sub { print q(dead!)}; ...;
evals/evals-freenode-#perl.lst[5437]: $SIG{__DIE__} = sub { $|++; say 42; exit }; a bc
evals/evals-freenode-#perl.lst[5438]: $SIG{__DIE__} = sub { say q(dead!) }; ...;
evals/evals-freenode-#perl.lst[5439]: "SIMCOP48.856934"^2
evals/evals-freenode-#perl.lst[5440]: sin 9**9**9
evals/evals-freenode-#perl.lst[5441]: "size=473" =~ s/size=\K(\d+)/int($1*2.5)/er
evals/evals-freenode-#perl.lst[5442]: $_ = "sj4jdj345k3dasssdf32"; tr/0-9//cd; print $_;
evals/evals-freenode-#perl.lst[5443]: sleep -1
FAILED TO EVAL!
evals/evals-freenode-#perl.lst[5444]: sleep 5; print "hello"
evals/evals-freenode-#perl.lst[5445]: sleep( 60 * 60 * 8 ) if $!{EINSUFFICIENTCAFFIENE}; # g'night folks.
evals/evals-freenode-#perl.lst[5446]: s///mansex
evals/evals-freenode-#perl.lst[5447]: s///mulder
evals/evals-freenode-#perl.lst[5448]: $s = '\\n'; "\n" =~ /$s/ ? "yes" : "no"
evals/evals-freenode-#perl.lst[5449]: s///nordic
evals/evals-freenode-#perl.lst[5450]: snork gorble pow fwee
evals/evals-freenode-#perl.lst[5451]: snork gorble poww fwee
evals/evals-freenode-#perl.lst[5452]: socket(my $fh, 6, 2, 17) or die "can't - $!";
evals/evals-freenode-#perl.lst[5453]: 'some-help-approver@example.net' =~ /(?<!^help-approver)\@example\.net$/
evals/evals-freenode-#perl.lst[5454]: "some text [3] some more text [4] even more text" =~ s/(?=\[\d+\])/\n/gr # or rather this, I guess
evals/evals-freenode-#perl.lst[5455]: "some text [3] some more text [4] even more text" =~ s/(?=\[)/␤/gr # tlhiv_laptop
evals/evals-freenode-#perl.lst[5456]: [ "some text here" =~ /((some) (text))/p, ${^MATCH} ] # no, preferably not $&
evals/evals-freenode-#perl.lst[5457]: [ "some text" =~ m/o|t/ ]
evals/evals-freenode-#perl.lst[5458]: [ "some text" =~ m/o|t/g ]
evals/evals-freenode-#perl.lst[5459]: $_ = 'something123.pl'; s/\w.*?\K(\d\.pl)/0$1/; $_ # why .*-like-things may not work as you wanted
evals/evals-freenode-#perl.lst[5460]: "something like this?" =~ s/(.)/sprintf "%x ", ord $1/gr
evals/evals-freenode-#perl.lst[5461]: "something like this?" =~ s/(.)/sprintf "%x ", ord $1/gre
evals/evals-freenode-#perl.lst[5462]: $_ = "something like this? x x"; my $state = 0; s/(\w)/++$state % 2 ? (uc $1) : (lc $1)/ge; $_
evals/evals-freenode-#perl.lst[5463]: $s = "one two three"; %h = ( one => 1, two => 2 ); $s =~ s/$_/$h{$_}/ for keys %h; $s
evals/evals-freenode-#perl.lst[5464]: [sort { 0 } 5, 2, 3]
evals/evals-freenode-#perl.lst[5465]: [sort 1, 2, 12, 13, 101, 102]
evals/evals-freenode-#perl.lst[5466]: ( sort ( 1..9 ));
evals/evals-freenode-#perl.lst[5467]: sort ( [8,6,7,4,2,3,9] )
evals/evals-freenode-#perl.lst[5468]: sort (8, 6, 7, 5, 2, 3, 9)
evals/evals-freenode-#perl.lst[5469]: sort(99, 111)
evals/evals-freenode-#perl.lst[5470]: [ sort { $a->[1] cmp $b->[1] || $a->[0] <=> $b->[0] } [2, 'd'], [3, 'c'], [1, 'd'] ]
evals/evals-freenode-#perl.lst[5471]: [ sort { $a <=> $b } 1386778719, 1386778075 ]
evals/evals-freenode-#perl.lst[5472]: [ sort { $a < $b } 2, 3, 1, 8, 0, 8, 8 ] # like, really easy
evals/evals-freenode-#perl.lst[5473]: [ sort { $a <=> $b } 4, 15, 11, "NaN", 11, 2, 1, 4, 3, "nan", 8 ]
evals/evals-freenode-#perl.lst[5474]: [ sort { $a <=> $b } 7, 0, "nan", 3 ]
evals/evals-freenode-#perl.lst[5475]: [ sort { $a <=> $b } 7, "nan", 3 ]
evals/evals-freenode-#perl.lst[5476]: [ sort { $a <=> $b } 8, 6, 7, 5, 3, 0, 9 ] # tell sort to compare $a and $b numerically instead of as strings
evals/evals-freenode-#perl.lst[5477]: [sort { $a cmp $b } qw/w x/
evals/evals-freenode-#perl.lst[5478]: [sort { $a cmp $b } qw/w x/]
evals/evals-freenode-#perl.lst[5479]: [ sort grep s/\.pm\z//, keys %INC ]
evals/evals-freenode-#perl.lst[5480]: [ sort { length $a <=> length $b || $a cmp $b } qw(this is a sentence with a few random words in it) ]
evals/evals-freenode-#perl.lst[5481]: [ sort { length $a <=> length $b } sort { $a cmp $b } qw(this is a sentence with a few random words in it) ]
evals/evals-freenode-#perl.lst[5482]: [ sort map s/\.pm\z//r, keys %INC ]
evals/evals-freenode-#perl.lst[5483]: sort ( qw(8,6,7,4,2,3,9) )
evals/evals-freenode-#perl.lst[5484]: sort ( qw[8,6,7,4,2,3,9] )
evals/evals-freenode-#perl.lst[5485]: [sort qw(9 3 4 5 6 3 4 1)] #thats how it works
evals/evals-freenode-#perl.lst[5486]: [ sort qw/ 9 39 5 38 4 5 381 29 0 1 2 3 / ]
evals/evals-freenode-#perl.lst[5487]: [ sort qw/a fan of w k r p in Cincinnati/ ]
evals/evals-freenode-#perl.lst[5488]: [sort qw/Compnent Component::A Component::B Your::Mother/]
evals/evals-freenode-#perl.lst[5489]: [ sort qw(must should could could must could should must) ]
evals/evals-freenode-#perl.lst[5490]: [ sort { return 42 } "h", "i" ]
evals/evals-freenode-#perl.lst[5491]: [ sort { return 42 } "hi" ]
evals/evals-freenode-#perl.lst[5492]: [sort &{sub {$_[0] <=> $_[1]}}, qw,1 3 2 772 9,]
evals/evals-freenode-#perl.lst[5493]: ('so this should match,even,though,,it,seems,very,different,from,requirements?' =~ m/\w+,\w+,,\w+,\w+/) ? 'match' : 'no match'
evals/evals-freenode-#perl.lst[5494]: so we don't get double action once perlbot is back in commission
evals/evals-freenode-#perl.lst[5495]: ${"so what"} = 123; "see? ${so what}"
evals/evals-freenode-#perl.lst[5496]: ${"so what"} = 123; "see? ${'so what'}. fu"
evals/evals-freenode-#perl.lst[5497]: $space = 10;printf( "%s%${$space}s => %s", $_, $ENV{ $_ } );
evals/evals-freenode-#perl.lst[5498]: ! ! ! ! ! ! "spaces"
evals/evals-freenode-#perl.lst[5499]: @spec = ('abcd', 1, 2); say &CORE::substr(@spec)
evals/evals-freenode-#perl.lst[5500]: @spec = ('abcd', 1, 2); say substr(@spec)
evals/evals-freenode-#perl.lst[5501]: s/perl/python/;
evals/evals-freenode-#perl.lst[5502]: splice((0..9),3,5)
evals/evals-freenode-#perl.lst[5503]: splice([0..9],3,5)
evals/evals-freenode-#perl.lst[5504]: splice @a, 2, 2, qw/foo bar/; \@a
evals/evals-freenode-#perl.lst[5505]: splice @test, 2; \@test
evals/evals-freenode-#perl.lst[5506]: [ split /(?<!^),/, '
evals/evals-freenode-#perl.lst[5507]: [ split /[^0-9]+/, "3 day 18 hr 50 min 33 sec" ]
evals/evals-freenode-#perl.lst[5508]: [ split " ", "1.1.1 POWER SUPPLY DEFECT" ]
evals/evals-freenode-#perl.lst[5509]: [ split /\./, "1.1.1 POWER SUPPLY DEFECT", 1 ]
evals/evals-freenode-#perl.lst[5510]: [ split " ", "1.1.1 POWER SUPPLY DEFECT", 1 ]
evals/evals-freenode-#perl.lst[5511]: [ split " ", "1.1.1 POWER SUPPLY DEFECT", 2 ]  # ?
evals/evals-freenode-#perl.lst[5512]: [ split "/", "12/33.",2]
evals/evals-freenode-#perl.lst[5513]: [ split "/", "12/33", 2 ]
evals/evals-freenode-#perl.lst[5514]: [ split ".", "12.33" ]  # because this
evals/evals-freenode-#perl.lst[5515]: [ split " ", "- 14:56:45,344 -", 4 ]
evals/evals-freenode-#perl.lst[5516]: [ split " ", "- 14:56:45,484 Info  : Trying to load VINGCARD_VISION.dll", 4 ]
evals/evals-freenode-#perl.lst[5517]: [ split ' ', '25 25.175 jitter' ]
evals/evals-freenode-#perl.lst[5518]: split[4]
evals/evals-freenode-#perl.lst[5519]: [ split /\40/, " a  b\tc ", 0 ]
evals/evals-freenode-#perl.lst[5520]: [split /(.{4}/, "thisisatest"]
evals/evals-freenode-#perl.lst[5521]: [split /(.{4})/, "thisisatest"]
evals/evals-freenode-#perl.lst[5522]: [ split //, 7355608 ]
evals/evals-freenode-#perl.lst[5523]: [ split(/aaa/, '') ]
evals/evals-freenode-#perl.lst[5524]: [ split(/aaa/, 'a') ]
evals/evals-freenode-#perl.lst[5525]: [ split(/aaa/, 'aaa') ]
evals/evals-freenode-#perl.lst[5526]: [ split(/aaa/, 'aaaaa') ]
evals/evals-freenode-#perl.lst[5527]: [ split /a/, 'aabcadeaa' ] # derp
evals/evals-freenode-#perl.lst[5528]: [split(/a/, "abacus")]
evals/evals-freenode-#perl.lst[5529]: split(/a/, "abacus")
evals/evals-freenode-#perl.lst[5530]: [split / /, 'a   b']
evals/evals-freenode-#perl.lst[5531]: [split ' ', 'a   b']
evals/evals-freenode-#perl.lst[5532]: [ (split /:/, "a:b")[0..3] ]
evals/evals-freenode-#perl.lst[5533]: [ split //, " a b c " ]
evals/evals-freenode-#perl.lst[5534]: [split //, 'abc']
evals/evals-freenode-#perl.lst[5535]: (split /,/, "a,b,c")[1]
evals/evals-freenode-#perl.lst[5536]: (split ",", "a,b,c")[1]
evals/evals-freenode-#perl.lst[5537]: [ split ' ', "a b c", 1 ]
evals/evals-freenode-#perl.lst[5538]: [split /(?<=-)\+(?=-)/, "a+b+cc-+-d-e-f"]
evals/evals-freenode-#perl.lst[5539]: [split /(?<=-)+(?=-)/, "a+b+cc-+-d-e-f"]
evals/evals-freenode-#perl.lst[5540]: [split /\./,"ab.cd."]
evals/evals-freenode-#perl.lst[5541]: [split /\./,"ab.cd.",-1]
evals/evals-freenode-#perl.lst[5542]: [split /\./,"ab.cd.",2]
evals/evals-freenode-#perl.lst[5543]: [split /\./,"ab.cd.df.",2]
evals/evals-freenode-#perl.lst[5544]: [split /\./,"ab.cd.df",2]
evals/evals-freenode-#perl.lst[5545]: [ split //, "abcde" ]
evals/evals-freenode-#perl.lst[5546]: split(//, "abcde")
evals/evals-freenode-#perl.lst[5547]: split(//, "abcde") . ""
evals/evals-freenode-#perl.lst[5548]: [split " ","a b c\n"]
evals/evals-freenode-#perl.lst[5549]: [ split " ", " a  b\tc " ]
evals/evals-freenode-#perl.lst[5550]: [ split " ", "  amarok" ]
evals/evals-freenode-#perl.lst[5551]: [ split ' ', " a real split " ]
evals/evals-freenode-#perl.lst[5552]: [ split /\A/, "where\nis\nyour\ngod\nnow?" ]
evals/evals-freenode-#perl.lst[5553]: [split /\b/, "123 5 12 7 "]
evals/evals-freenode-#perl.lst[5554]: split /\b/ "123 5 12 7 "
evals/evals-freenode-#perl.lst[5555]: [ split //, "banana" ]
evals/evals-freenode-#perl.lst[5556]: [split /\b/, "foo_bar"]
evals/evals-freenode-#perl.lst[5557]: [ split /\D/, "1k10k1|11dld1" ]
evals/evals-freenode-#perl.lst[5558]: [ split /\D+/, "1k10k1|11dld1" ]
evals/evals-freenode-#perl.lst[5559]: [ split ' ', 'foo bar baz' ]
evals/evals-freenode-#perl.lst[5560]: [split /(?<!\\),/, "foo\\,bar,baz"]
evals/evals-freenode-#perl.lst[5561]: [split ",", "foo bar baz"]
evals/evals-freenode-#perl.lst[5562]: [split ",", "foo, bar, baz"]
evals/evals-freenode-#perl.lst[5563]: (split /\./, 'foo.bar.baz')[1]
evals/evals-freenode-#perl.lst[5564]: [ split /=|==|:|--/, "foo:bar:baz", 2 ]
evals/evals-freenode-#perl.lst[5565]: [[ split / /, "foo     bar" ], [ split ' ', "foo     bar" ]]
evals/evals-freenode-#perl.lst[5566]: [ split / /, " foo\tbar  baz " ]
evals/evals-freenode-#perl.lst[5567]: [ split " ", " foo\tbar  baz " ]
evals/evals-freenode-#perl.lst[5568]: [ split /(?<=@free.fr)/, "example@free.frexample2@free.fr" ] #hmm, why doesn't this keep the @free.fr part in the results?
evals/evals-freenode-#perl.lst[5569]: [ split /(?<=@free\.fr)/, 'example@free.frexample2@free.fr' ] #right
evals/evals-freenode-#perl.lst[5570]: [split " ", "Fri Dec  4 18:54:59 EST 2015"]
evals/evals-freenode-#perl.lst[5571]: [ split //, "F­u­dge" ]
evals/evals-freenode-#perl.lst[5572]: [split//,"Hello"]
evals/evals-freenode-#perl.lst[5573]: [ split '.', 'horsey.surprise' ]
evals/evals-freenode-#perl.lst[5574]: [ split '\\.', 'horsey.surprise' ]
evals/evals-freenode-#perl.lst[5575]: [ split /[&=]/, "http://a?k1=v1&k2=v2" ]
evals/evals-freenode-#perl.lst[5576]: [ split m{/}, "12/33." ]
evals/evals-freenode-#perl.lst[5577]: [ split /^/m, "hello\nworld" ]
evals/evals-freenode-#perl.lst[5578]: [ split m!/|\.html!, "dirs/123/abc.def/ghi999.html ]
evals/evals-freenode-#perl.lst[5579]: [ split m!/|\.html!, "dirs/123/abc.def/ghi999.html" ]
evals/evals-freenode-#perl.lst[5580]: [ split m{/}, '/just/a/demo/' ]
evals/evals-freenode-#perl.lst[5581]: [ split ',', 'money.perl.com,money.python.com,money.nei.com' ]
evals/evals-freenode-#perl.lst[5582]: [ split /(?<!^),/, ',one,two,three' ]
evals/evals-freenode-#perl.lst[5583]: [split //, "perl"]
evals/evals-freenode-#perl.lst[5584]: [ split qr'(?<=@free\.fr)', 'example@free.frexample2@free.fr' ] #look ma! no han^Wescapes! (except that . one)
evals/evals-freenode-#perl.lst[5585]: [ split qr{[\[\]=]+}, "something[a=b][c=d][e=f]" ]
evals/evals-freenode-#perl.lst[5586]: [split('\Qx+', "abxxcdex+fg")]
evals/evals-freenode-#perl.lst[5587]: [split("\Qx+", "abxxcdex+fg")]
evals/evals-freenode-#perl.lst[5588]: [ split ' ', "  random\t\nwhitespace\r" ]
evals/evals-freenode-#perl.lst[5589]: [split /\s+/, " "]
evals/evals-freenode-#perl.lst[5590]: [split /\s+/, " ", -1]
evals/evals-freenode-#perl.lst[5591]: [split /\s+/, "a ", -1]
evals/evals-freenode-#perl.lst[5592]: [ split /\s/, "a     b" ]
evals/evals-freenode-#perl.lst[5593]: [split /\s+/, " a"] # but this one doesn't need the limit
evals/evals-freenode-#perl.lst[5594]: [ split /\s+/, "  amarok" ]
evals/evals-freenode-#perl.lst[5595]: [ split "\s+", "  amarok" ]
evals/evals-freenode-#perl.lst[5596]: [ split /\s+/, " a real split ", -1 ]
evals/evals-freenode-#perl.lst[5597]: [ split /[@\s]/, "foo@bar baz" ]
evals/evals-freenode-#perl.lst[5598]: [ split /[\@\s]/, 'foo@bar baz' ]
evals/evals-freenode-#perl.lst[5599]: [ split /[\@\s]/, "foo@bar baz" ]
evals/evals-freenode-#perl.lst[5600]: [ split /[\@\s]/, "foo\@bar baz" ]
evals/evals-freenode-#perl.lst[5601]: [split /(,\s*)/, "foo, bar, baz"]
evals/evals-freenode-#perl.lst[5602]: split /(,\s*)/, "foo, bar, baz"
evals/evals-freenode-#perl.lst[5603]: [ split /\s+/, grep /x/, qw(abc def kzx lol) ]
evals/evals-freenode-#perl.lst[5604]: (split /-/, (split /\//, "http://www.site.com/letters0241/something-in-australia-a-h")[-1])[2]
evals/evals-freenode-#perl.lst[5605]: [split //, sprintf "%b", 20]
evals/evals-freenode-#perl.lst[5606]: [ split /([\s[:punct:]]+)/, "Knark. knark," ]
evals/evals-freenode-#perl.lst[5607]: [ split /(\s+|[[:punct:]])/, "Knark. knark," ] # or ask perlbot
evals/evals-freenode-#perl.lst[5608]: [split /\s*=\s*/, 'name=val=ue', 2]
evals/evals-freenode-#perl.lst[5609]: [ split(/\s+/, 'split th\is line') ]
evals/evals-freenode-#perl.lst[5610]: [ split /\s+/, " word " ]
evals/evals-freenode-#perl.lst[5611]: [split /\t/, ""]
evals/evals-freenode-#perl.lst[5612]: [split '', '\t']
evals/evals-freenode-#perl.lst[5613]: [split '', "\t"]
evals/evals-freenode-#perl.lst[5614]: [ split /=/, "test='string=ignore this symbol'", 2 ] # presumably you want key + value
evals/evals-freenode-#perl.lst[5615]: [ split /(?<!\\);/, "this;is; a test; with\\; escaped delimiters;;" ]
evals/evals-freenode-#perl.lst[5616]: [split /(?<!\\);/, 'this;is; a test; with\\\; escaped delimiters;;']
evals/evals-freenode-#perl.lst[5617]: [split /\t/, "sajkhsdahkj"]
evals/evals-freenode-#perl.lst[5618]: [split /(\W)/, "a.b!c?d e"]
evals/evals-freenode-#perl.lst[5619]: [ split /\W+/, "(foo)" ]
evals/evals-freenode-#perl.lst[5620]: [split /(\W)/, "foo bar.baz quux?derp ermintrude"]
evals/evals-freenode-#perl.lst[5621]: [ split " ", "what are you on about", 2 ] # wodim?
evals/evals-freenode-#perl.lst[5622]: [ split /,/, 'where,is,"your,god",now' ]
evals/evals-freenode-#perl.lst[5623]: [ split ",", "worker1," ]
evals/evals-freenode-#perl.lst[5624]: [ split ",", "worker1,", -1 ]
evals/evals-freenode-#perl.lst[5625]: [ split /,/, ',x,', -1 ]
evals/evals-freenode-#perl.lst[5626]: [split('x+', "abxxcdex+fg")]
evals/evals-freenode-#perl.lst[5627]: [split /x/, 'axb', 'yxz']
evals/evals-freenode-#perl.lst[5628]: sprintf '%012x', 0xff
evals/evals-freenode-#perl.lst[5629]: sprintf '%012x', 0xffff
evals/evals-freenode-#perl.lst[5630]: sprintf('%02d', 9)
evals/evals-freenode-#perl.lst[5631]: sprintf('%02x%02x%02x', 192, 255, 63)
evals/evals-freenode-#perl.lst[5632]: sprintf "%*02X", " ", "bar"
evals/evals-freenode-#perl.lst[5633]: sprintf "%02*X", " ", "bar"
evals/evals-freenode-#perl.lst[5634]: sprintf(".%03u", 85)
evals/evals-freenode-#perl.lst[5635]: sprintf(".%03u", 850)
evals/evals-freenode-#perl.lst[5636]: sprintf(".%03u", 8500)
evals/evals-freenode-#perl.lst[5637]: sprintf '%04d', 1
evals/evals-freenode-#perl.lst[5638]: [ sprintf "%04o", 0755 ]
evals/evals-freenode-#perl.lst[5639]: sprintf '%04o', 0777
evals/evals-freenode-#perl.lst[5640]: sprintf '%04x', hex 'dead'
evals/evals-freenode-#perl.lst[5641]: sprintf '%05.2f', 5/3
evals/evals-freenode-#perl.lst[5642]: sprintf('%0.5d',9)
evals/evals-freenode-#perl.lst[5643]: sprintf('%0.5f', 7.15255737304688e-06)
evals/evals-freenode-#perl.lst[5644]: sprintf "%08b", 1 | 15
evals/evals-freenode-#perl.lst[5645]: [sprintf "%08x", int( rand(1000))]
evals/evals-freenode-#perl.lst[5646]: sprintf '%.0f', 1.139999999999999 * 100
evals/evals-freenode-#perl.lst[5647]: sprintf "%.0f", 2.6
evals/evals-freenode-#perl.lst[5648]: sprintf "%.0f", 6 * 99.90 * 100
evals/evals-freenode-#perl.lst[5649]: sprintf'%.0f',log(~0)/log(2)
evals/evals-freenode-#perl.lst[5650]: sprintf '%' . 0xfffffff . '$f'
evals/evals-freenode-#perl.lst[5651]: sprintf "[%-10d]", 123
evals/evals-freenode-#perl.lst[5652]: sprintf "%.10f", 942993 / 1236732346368
evals/evals-freenode-#perl.lst[5653]: sprintf "%.10f%% ram used", 942993 / 1236732346368 * 100
evals/evals-freenode-#perl.lst[5654]: sprintf("%12.6g", 6 * 99.90)
evals/evals-freenode-#perl.lst[5655]: [ sprintf '%.14f', '1.43531262539073e-11' ] # or sprintf, if you want to do something other than display the result
evals/evals-freenode-#perl.lst[5656]: sprintf "%.15f", 942993 / 1236732346368
evals/evals-freenode-#perl.lst[5657]: sprintf('%1d',9)
evals/evals-freenode-#perl.lst[5658]: sprintf "%.20f %.20f", 0.1, 0.3
evals/evals-freenode-#perl.lst[5659]: sprintf "%.20f", 6 * 99.90
evals/evals-freenode-#perl.lst[5660]: sprintf "%2.2e", 1234.567
evals/evals-freenode-#perl.lst[5661]: [ sprintf '%.28f', '1.43531262539073e-11' ]
evals/evals-freenode-#perl.lst[5662]: [sprintf "%.2f", 3/4]
evals/evals-freenode-#perl.lst[5663]: sprintf '%2$s then %1$s', 'first', 'second';
evals/evals-freenode-#perl.lst[5664]: sprintf "%.30f", "134.95"
evals/evals-freenode-#perl.lst[5665]: sprintf "%.30f", 134.95
evals/evals-freenode-#perl.lst[5666]: sprintf "%.30f", "134.95" * 100
evals/evals-freenode-#perl.lst[5667]: sprintf "%.30f", 134.95 * 100
evals/evals-freenode-#perl.lst[5668]: sprintf "%.3f", ((10/1*225)/(18))-125
evals/evals-freenode-#perl.lst[5669]: sprintf "%.3f", 2.34525
evals/evals-freenode-#perl.lst[5670]: [ sprintf "%4o", 0644 ]
evals/evals-freenode-#perl.lst[5671]: sprintf('%5s', 'corn flakes');
evals/evals-freenode-#perl.lst[5672]: sprintf "%.70f", 1/3
evals/evals-freenode-#perl.lst[5673]: [sprintf "%8.8x", int( rand(1000))]
evals/evals-freenode-#perl.lst[5674]: sprintf "%8b", 1 | 15
evals/evals-freenode-#perl.lst[5675]: [  (sprintf "%8f", 1) , (sprintf "%8f", 15) ]
evals/evals-freenode-#perl.lst[5676]: sprintf "%b", 0.1
evals/evals-freenode-#perl.lst[5677]: sprintf "%b", 0.21875
evals/evals-freenode-#perl.lst[5678]: sprintf "%b", 0376
evals/evals-freenode-#perl.lst[5679]: sprintf "%b", 1 | 15
evals/evals-freenode-#perl.lst[5680]: sprintf "%b", 1234321
evals/evals-freenode-#perl.lst[5681]: sprintf "%b", 152944
evals/evals-freenode-#perl.lst[5682]: sprintf "%b", 21845
evals/evals-freenode-#perl.lst[5683]: sprintf "%b", 341
evals/evals-freenode-#perl.lst[5684]: sprintf '%b', 50
evals/evals-freenode-#perl.lst[5685]: sprintf '%b', 82
evals/evals-freenode-#perl.lst[5686]: sprintf "%b", 86273
evals/evals-freenode-#perl.lst[5687]: sprintf "%b", 87381
evals/evals-freenode-#perl.lst[5688]: sprintf "%b", 96
evals/evals-freenode-#perl.lst[5689]: sprintf '%b', 96000
evals/evals-freenode-#perl.lst[5690]: [ sprintf "%b & %b -> %b", 2048, 0xFF, 2048 & 0xFF ]
evals/evals-freenode-#perl.lst[5691]: sprintf "%b.%b", split /\./, 0.1
evals/evals-freenode-#perl.lst[5692]: sprintf "%b.%b", split /\./, 0.21875
evals/evals-freenode-#perl.lst[5693]: [sprintf"%c", 65]
evals/evals-freenode-#perl.lst[5694]: [sprintf"%c", 'a']
evals/evals-freenode-#perl.lst[5695]: sprintf "%c%c%c", map ord,(97,98,99)
evals/evals-freenode-#perl.lst[5696]: sprintf "%c%c%c", map ord,('a','b','c')
evals/evals-freenode-#perl.lst[5697]: sprintf '%d', -0.5
evals/evals-freenode-#perl.lst[5698]: sprintf "%,d", 12345678;
evals/evals-freenode-#perl.lst[5699]: sprintf '%d', 1.7
evals/evals-freenode-#perl.lst[5700]: sprintf("%d", 2.6)
evals/evals-freenode-#perl.lst[5701]: sprintf("%d %d", DateTime->now(time_zone => "UTC")->epoch(), time())
evals/evals-freenode-#perl.lst[5702]: sprintf "%d %s", 1, 2
evals/evals-freenode-#perl.lst[5703]: sprintf '%.f', 0.49999999999999994
evals/evals-freenode-#perl.lst[5704]: sprintf '%.*f', 1, 2
evals/evals-freenode-#perl.lst[5705]: sprintf '%*f', '.1', 2
evals/evals-freenode-#perl.lst[5706]: sprintf '%.f', 134.95 * 100
evals/evals-freenode-#perl.lst[5707]: sprintf '%.f', 1.7
evals/evals-freenode-#perl.lst[5708]: sprintf '%.*f', length('9999999999999911'), 0.9999999999999911
evals/evals-freenode-#perl.lst[5709]: sprintf "%f", rand(1e100)
evals/evals-freenode-#perl.lst[5710]: sprintf '%lu', 1341015082000
evals/evals-freenode-#perl.lst[5711]: sprintf "%#o", 0
evals/evals-freenode-#perl.lst[5712]: [sprintf '%o', '16877']
evals/evals-freenode-#perl.lst[5713]: sprintf "%#o", 2
evals/evals-freenode-#perl.lst[5714]: sprintf "%o", 272
evals/evals-freenode-#perl.lst[5715]: sprintf "%o", 292
evals/evals-freenode-#perl.lst[5716]: sprintf "%o", 39
evals/evals-freenode-#perl.lst[5717]: sprintf(         q{[%02dx%02d}. ($3 ? q{-} : q{}). q{%02d] %s},          $1, $2, ($3 // q{}), $4      )
evals/evals-freenode-#perl.lst[5718]: sprintf q{%03d.%d}, split /\./, 1.2345; # leobut
evals/evals-freenode-#perl.lst[5719]: sprintf q{%.3f}, 2047.99999952316 ### Is there a way to do this but truncate instead of rounding, so the result is 2047.999 instead of 2048.000 ?
evals/evals-freenode-#perl.lst[5720]: sprintf q{%.3f}, (int (2047.99999952316 * 1000))/1000;
evals/evals-freenode-#perl.lst[5721]: sprintf $_ = q{eval: sprintf $_ = q{%s}, $_}, $_
evals/evals-freenode-#perl.lst[5722]: sprintf "the cluster is using %.10f%% of available ram", 942993 / 1236732346368 * 100
evals/evals-freenode-#perl.lst[5723]: sprintf "the cluster is using %.10f%% of available ram", (942993 * 2**20) / 1236732346368 * 100
evals/evals-freenode-#perl.lst[5724]: sprintf "%*v02X", " ", "bar"
evals/evals-freenode-#perl.lst[5725]: sprintf "%v*02X", " ", "bar"
evals/evals-freenode-#perl.lst[5726]: sprintf "%*v02x", " ", Encode::encode_utf8("much \x{2665}")
evals/evals-freenode-#perl.lst[5727]: sprintf "%v02X", "hello"
evals/evals-freenode-#perl.lst[5728]: (sprintf "%v02X", "hello") =~ s/\./ /g
evals/evals-freenode-#perl.lst[5729]: (sprintf "%v02X", "hello") =~ s/\./ /gr
evals/evals-freenode-#perl.lst[5730]: sprintf "%*v02x", " ", pack "C*", qw|137 80 78 71 13 10 26 10|
evals/evals-freenode-#perl.lst[5731]: sprintf "%v02x", pack "N", 945
evals/evals-freenode-#perl.lst[5732]: sprintf "%v02x", pack "V", 945
evals/evals-freenode-#perl.lst[5733]: sprintf "%*v04X", "U+", "hello"
evals/evals-freenode-#perl.lst[5734]: sprintf '%vb', 'foo' # something like this, majuscule?
evals/evals-freenode-#perl.lst[5735]: sprintf '%vb', "\x05" # binary string, then?
evals/evals-freenode-#perl.lst[5736]: sprintf "%vd", "123" ^ "az3"
evals/evals-freenode-#perl.lst[5737]: sprintf "%vd", "3" ^ "3"
evals/evals-freenode-#perl.lst[5738]: sprintf "%vd", 'a'
evals/evals-freenode-#perl.lst[5739]: sprintf "%,vd", 'abc'
evals/evals-freenode-#perl.lst[5740]: sprintf "%*vd", ',', 'abc'
evals/evals-freenode-#perl.lst[5741]: sprintf "%vd", 'abc'
evals/evals-freenode-#perl.lst[5742]: sprintf "%vd", "foo\n\rbar"
evals/evals-freenode-#perl.lst[5743]: sprintf "%vd", "something" ^ "otherthing"  # or this...
evals/evals-freenode-#perl.lst[5744]: sprintf '%vd', "string"
evals/evals-freenode-#perl.lst[5745]: sprintf "%vd", $^V
evals/evals-freenode-#perl.lst[5746]: sprintf('%v', v1.2.3)
evals/evals-freenode-#perl.lst[5747]: [ sprintf "%x", 127.0.0.1 ]
evals/evals-freenode-#perl.lst[5748]: sprintf "%x", 14644
evals/evals-freenode-#perl.lst[5749]: sprintf '%x', 18*256+44;
evals/evals-freenode-#perl.lst[5750]: sprintf "%x", 18446744073709551615
evals/evals-freenode-#perl.lst[5751]: sprintf '%x', 3 * 256 + 17
evals/evals-freenode-#perl.lst[5752]: sprintf '%x', 44*256+18;
evals/evals-freenode-#perl.lst[5753]: sprintf "%x", 5 * 60 * 10e6
evals/evals-freenode-#perl.lst[5754]: sprintf "%x", 65280
evals/evals-freenode-#perl.lst[5755]: sprintf "%x", oct "0b011000111100"
evals/evals-freenode-#perl.lst[5756]: sprintf "%X", oct "0b011000111100"
evals/evals-freenode-#perl.lst[5757]: sprintf '%x', ord '*';
evals/evals-freenode-#perl.lst[5758]: sprintf "%x", ord '0'
evals/evals-freenode-#perl.lst[5759]: sprintf '%x', ord 'c'
evals/evals-freenode-#perl.lst[5760]: sprintf '%x', ord 'C'
evals/evals-freenode-#perl.lst[5761]: sprintf "%x", ord "\n"
evals/evals-freenode-#perl.lst[5762]: sprintf "%x", ord "\x{1234}"
evals/evals-freenode-#perl.lst[5763]: sprintf "%x", time(0)
evals/evals-freenode-#perl.lst[5764]: [ sprintf "%x", v127.0.0.1 ]
evals/evals-freenode-#perl.lst[5765]: sprintf "%x %x", 015, 012
evals/evals-freenode-#perl.lst[5766]: sprintf "%x %x", 55357, 56839
evals/evals-freenode-#perl.lst[5767]: sprint "%x", ord '0'
evals/evals-freenode-#perl.lst[5768]: $sql =~ s/constraint \K`(\w+)`/$1/gi; maybe?
evals/evals-freenode-#perl.lst[5769]: "(s)" =~ qr'\Q(s)'
evals/evals-freenode-#perl.lst[5770]: $s = quotemeta('*');  "a*b*c" =~ /$s/ ? "Match" : "No match"
evals/evals-freenode-#perl.lst[5771]: '!' =~ s/~//r
evals/evals-freenode-#perl.lst[5772]: '!' =~ s/!//r
evals/evals-freenode-#perl.lst[5773]: srand(()) # Came up in p5p recently
evals/evals-freenode-#perl.lst[5774]: @src=qw(a b c); @dst=grep defined, @src[2..5]; print join(",", @src);
evals/evals-freenode-#perl.lst[5775]: @src=qw(a b c); @dst=@src[2..5]; print join(",", @dst);
evals/evals-freenode-#perl.lst[5776]: @src=qw(a b c); @w=grep defined, @{ [@src[2..5]] }; print join(",", @src); #rmah, how about this?
evals/evals-freenode-#perl.lst[5777]: @src=qw(a b c); @w=@src[2..5]; print join(",", @src);
evals/evals-freenode-#perl.lst[5778]: s///regexp
evals/evals-freenode-#perl.lst[5779]: sretrun
evals/evals-freenode-#perl.lst[5780]: sretrun join(',', @accounts);
evals/evals-freenode-#perl.lst[5781]: sreturn join(',', @accounts);
evals/evals-freenode-#perl.lst[5782]: ['ß']
evals/evals-freenode-#perl.lst[5783]: s///scully
evals/evals-freenode-#perl.lst[5784]: 'ß' =~ m/^\Qss\E\z/i ? 'True' : 'False';
evals/evals-freenode-#perl.lst[5785]: [ 'ß' =~ m/^\Qss\E\z/i ? 'True' : 'False' ];
evals/evals-freenode-#perl.lst[5786]: s/ / sprintf(         q{[%02dx%02d}. ($3 ? q{-} : q{}). q{%02d] %s},          $1, $2, ($3 // q{}), $4      )  /ex;
evals/evals-freenode-#perl.lst[5787]: 'ß' =~ /\ß{UpperCase}/
evals/evals-freenode-#perl.lst[5788]: s/(?<!STYLESY0B\$\$)\b$k\b/<span class="kw1">$k<\/span>/igs;
evals/evals-freenode-#perl.lst[5789]: s///supernice
evals/evals-freenode-#perl.lst[5790]: s///susanne
evals/evals-freenode-#perl.lst[5791]: s///susi
evals/evals-freenode-#perl.lst[5792]: $_ = "stackoverflow"; $_ = reverse for substr $_, 0, 5; s/.//r
evals/evals-freenode-#perl.lst[5793]: $_ = "stackoverflow"; substr($_,0,5,substr(reverse(substr$_,0,5),1,4)); $_
evals/evals-freenode-#perl.lst[5794]: $_ = "stackoverflow"; substr($_,0,5,substr(~~reverse(substr($_,0,5)),1,4)); $_  # fixed
evals/evals-freenode-#perl.lst[5795]: state $x = 4; $x
evals/evals-freenode-#perl.lst[5796]: $_ = "STDERR output success\nSTDERR output success\n";  /^STDERR output success(?=.*(?!STDERR output success))/ ? 'y' : 'n'
evals/evals-freenode-#perl.lst[5797]: $_ = "STDERR output success\nSTDERR output success\n";  /^STDERR output success(?!.*STDERR output success)/ ? 'y' : 'n'
evals/evals-freenode-#perl.lst[5798]: <stdin>
evals/evals-freenode-#perl.lst[5799]: STDIN
evals/evals-freenode-#perl.lst[5800]: [*STDIN]
evals/evals-freenode-#perl.lst[5801]: *STDIN{IO}
evals/evals-freenode-#perl.lst[5802]: STDOUT->autoflush(1)
evals/evals-freenode-#perl.lst[5803]: [ *STDOUT{IO} ]
evals/evals-freenode-#perl.lst[5804]: *{ *STDOUT{IO} }
evals/evals-freenode-#perl.lst[5805]: '' . *{ *STDOUT{IO} }{IO}
evals/evals-freenode-#perl.lst[5806]: *{ *STDOUT{IO} }{IO}
evals/evals-freenode-#perl.lst[5807]: [ ''.*STDOUT{IO}, '' . *{ *STDOUT{IO} }{IO} ]
evals/evals-freenode-#perl.lst[5808]: STDOUT->print("oh no, entire classes")
evals/evals-freenode-#perl.lst[5809]: /(?<!ST)/i
evals/evals-freenode-#perl.lst[5810]: Storable::store "hallo"
evals/evals-freenode-#perl.lst[5811]: $str = '00 00 1c 00'; $num = unpack("V", pack("(H2)4", split / /, $str)); [ $num ]
evals/evals-freenode-#perl.lst[5812]: $str = '00 00 1c 00'; $num = unpack("V", pack("H8", $str =~ tr/ //dr)); [ $num ]
evals/evals-freenode-#perl.lst[5813]: $str = '00 00 1c 00'; $str = join '', reverse split ' ', $str; $num = hex $str; [ $num ]
evals/evals-freenode-#perl.lst[5814]: $str = '00 00 1c 00'; $str =~ tr/ //d; $num = hex $str; [ $num ]
evals/evals-freenode-#perl.lst[5815]: $str = '001122334455'; @m = ($str =~ m/(\d{2})/g); "@m"
evals/evals-freenode-#perl.lst[5816]: $str = '00 1c 00 00'; $str =~ tr/ //d; $num = hex $str; [ $num ]
evals/evals-freenode-#perl.lst[5817]: $str = 0b10000000 ^ 0b00000100; print unpack q/B8/, $str;
evals/evals-freenode-#perl.lst[5818]: $str = 0b10000000 ^ 0b00000100; sprintf "%b", $str
evals/evals-freenode-#perl.lst[5819]: $str1="1"; $str2="2"; print ($str1,$str2(; print ($str1.$str2);
evals/evals-freenode-#perl.lst[5820]: $str1="1"; $str2="2"; print ($str1,$str2); print ($str1.$str2);
evals/evals-freenode-#perl.lst[5821]: $str1="1"; $str2="2"; print $str1,$str2; print $str1.$str2;
evals/evals-freenode-#perl.lst[5822]: $str = "123456"; for($i = 0; $i < length($str)-1; $i+=2) { (substr($str, $i, 1), substr($str, $i+1, 1)) = (substr($str, $i+1, 1), substr($str, $i, 1)); } $str;
evals/evals-freenode-#perl.lst[5823]: $str = "123456"; $str += 90909
evals/evals-freenode-#perl.lst[5824]: $str = "123456"; $str += join $., (3 * 3) x 3
evals/evals-freenode-#perl.lst[5825]: $str='123abc'; $str =~ +'xyz'; print $str;
evals/evals-freenode-#perl.lst[5826]: $str = '|1|2a|3abc|4abcd|5abcde'; [ map { $str =~ /((?:\|[^\|]*){$_})/  } 1..5 ]
evals/evals-freenode-#perl.lst[5827]: $str="1a2s"; ($s1, $s3)=$str=~m/\d\w/g;  print $s1."\n"; ($s2)=$str=~m//g;  print $s2."\n".$s3;
evals/evals-freenode-#perl.lst[5828]: $str="1a2s"; ($s1)=$str=~m/\d\w/g;  print $s1."\n"; ($s2)=$str=~m//g;  print $s2."\n";
evals/evals-freenode-#perl.lst[5829]: $str="1a2s"; $str=~m/(\d\w)/g; $s1=$1; print $s1."\n"; $str=~m//g; $s2=$1; print $s2."\n";
evals/evals-freenode-#perl.lst[5830]: $str1="a"; $str2="b"; print $str1=>$str2;
evals/evals-freenode-#perl.lst[5831]: $str1 = 'foobar'; $str2 = 'foobiz'; ($str1 ^ $str2) =~ /(^\0*)/; length $1
evals/evals-freenode-#perl.lst[5832]: $str1 = 'foöbar'; $str2 = 'foobiz'; ($str1 ^ $str2) =~ /(^\0*)/; length $1
evals/evals-freenode-#perl.lst[5833]: $str1 = 'foöbar'; $str2 = 'foöbiz'; ($str1 ^ $str2) =~ /(^\0*)/; length $1
evals/evals-freenode-#perl.lst[5834]: $str1 = 'foöobar'; $str2 = 'foöobiz'; ($str1 ^ $str2) =~ /(^\0*)/; length $1
evals/evals-freenode-#perl.lst[5835]: $str1 = 'foöobar'; $str2 = 'foö'; ($str1 ^ $str2) =~ /(^\0*)/; length $1
evals/evals-freenode-#perl.lst[5836]: $str1="one"; $str2="two"; print ($str1,$str1.$str2);
evals/evals-freenode-#perl.lst[5837]: $str1="one"; $str2="two"; print ($str2.$str1,$str1.$str2);
evals/evals-freenode-#perl.lst[5838]: $str=1; printf ("%.3f", $str/3);
evals/evals-freenode-#perl.lst[5839]: $str = 'a a a a a a'; /a/g for ($str) x 3; $str =~ s/a\G/x/; $str
evals/evals-freenode-#perl.lst[5840]: $str = 'aaaaa'; $str =~ /a/gc for 1,2,3; $str =~ s/a/b/c; $str
evals/evals-freenode-#perl.lst[5841]: $str = 'aaaaa'; $str =~ /a/g for 1 .. 3; $str =~ s/\Ga/b/; $str
evals/evals-freenode-#perl.lst[5842]: $str='abc123'; map { s/abc/xyz/g; print } $str;
evals/evals-freenode-#perl.lst[5843]: $str = "abcdef"; for($i = 0; $i < length($str)-1; $i+=2) { (substr($str, $i, 1), substr($str, $i+1, 1)) = (substr($str, $i+1, 1), substr($str, $i, 1)); } $str;
evals/evals-freenode-#perl.lst[5844]: $str="abcdefghijklmnopqrstuvwxyz"; $str=~s/(?<=.{13}).*//; print $str;
evals/evals-freenode-#perl.lst[5845]: $str="abcdefghijklmnopqrstuvwxyz"; $str=~s/(?<=.{13}).*/$x=rand(3); $x>1?uc($&):lc($&)/ge; print $str;
evals/evals-freenode-#perl.lst[5846]: $str="abcXYZ 123 pdq"; $str=~s/(?<=.{3}).*//; print "\"$str\"\n"
evals/evals-freenode-#perl.lst[5847]: $str = ["a".."m"]; print ref $str
evals/evals-freenode-#perl.lst[5848]: $str.='a'..'m'; print ref $str;
evals/evals-freenode-#perl.lst[5849]: $str = ["a".."m"]; print scalar $str
evals/evals-freenode-#perl.lst[5850]: $str = 'a'..'m'; print $str;
evals/evals-freenode-#perl.lst[5851]: $str = ["a".."m"]; print @$str
evals/evals-freenode-#perl.lst[5852]: $str = ["a".."m"]; print $str
evals/evals-freenode-#perl.lst[5853]: $str.='a'..'m'; print $str;
evals/evals-freenode-#perl.lst[5854]: $str = 'barfoo'; $str =~ /(?(?{$_=index($str,'foo');$_>0})foo|(*FAIL))/ or 1;
evals/evals-freenode-#perl.lst[5855]: $str="bleh"; $str=~s/(?:test)/$1/; print $str;
evals/evals-freenode-#perl.lst[5856]: $str="bleh"; $str=~s/(?test)/$1/; print $str;
evals/evals-freenode-#perl.lst[5857]: $str="blehtest"; $str=~s/(?:bleh)/$1/; print $str;
evals/evals-freenode-#perl.lst[5858]: $str="blehtest"; $str=~s/(?:test)/$1/; print $str;
evals/evals-freenode-#perl.lst[5859]: $str = "foo a b = z"; @a = $str =~ m/( \w)+/g; \@a
evals/evals-freenode-#perl.lst[5860]: $str = '   foo'; $str =~ s/\A\s+//; "[$str]";
evals/evals-freenode-#perl.lst[5861]: $str = '   foo'; $str =~ s/\A\s+//; $str;
evals/evals-freenode-#perl.lst[5862]: strftime '%Y-%m-%d %H:%M:%S', gmtime 1433332042340 / 1000; # how human?
evals/evals-freenode-#perl.lst[5863]: $str="ft\n"; chomp $str; $str =~ /ft$/ ? 't' : 'f'
evals/evals-freenode-#perl.lst[5864]: $str="ft\n"; $str =~ /ft\b/ ? 't' : 'f'
evals/evals-freenode-#perl.lst[5865]: $str="ft\n"; $str =~ /ft$/ ? 't' : 'f'
evals/evals-freenode-#perl.lst[5866]: $str="ft\n"; $str =~ /ft\z/ ? 't' : 'f'
evals/evals-freenode-#perl.lst[5867]: $str = "/hallo/"; qr{blabla $str xxx}
evals/evals-freenode-#perl.lst[5868]: $str = "Hey $1.140 $20.568 16.9kg 12.3 2342342.9 Hey"; $str =~ s/(\d+\.\d+)/sprintf("%0.f")/eg; print $str;
evals/evals-freenode-#perl.lst[5869]: $str = "Hey $1.140 $20.568 16.9kg 12.3 2342342.9 Hey"; $str =~ s/(\d+\.\d+)/sprintf("%0.f")/g; print $str;
evals/evals-freenode-#perl.lst[5870]: $str = "Hey $1.140 $20.568 16.9kg 12.3 2342342.9 Hey"; $str =~ s/(\d+\.\d+)/sprintf("%.f",$1)/eg; print $str;
evals/evals-freenode-#perl.lst[5871]:  $str = "I am 2000 years old"; $str =~ s/(\d+(?:\.\d+)?)/sprintf('%.f',$1)/er;
evals/evals-freenode-#perl.lst[5872]:  $str = "I bought $155.4954 worth of oregano"; $str =~ s/(\d+(?:\.\d+)?)/sprintf('%.f',$1)/er;
evals/evals-freenode-#perl.lst[5873]: 'strike' =~ /(?:anywhere)?/ ? 'matches' : 'bad joke';
evals/evals-freenode-#perl.lst[5874]: 'strike' =~ /(?anywhere)/ ? 'matches' : 'bad joke';
evals/evals-freenode-#perl.lst[5875]: "string\'"
evals/evals-freenode-#perl.lst[5876]: $string="hello world"; ($capture) = $string =~ /\bhello\b/; print $capture;
evals/evals-freenode-#perl.lst[5877]: $string="hello world"; $capture = $string; $capture =~ /hello/; print $capture;
evals/evals-freenode-#perl.lst[5878]: $string="hello world"; $capture = $string; $capture =~ s/.*(hello).*/$1/; print $capture;
evals/evals-freenode-#perl.lst[5879]: $string="hello world"; ($capture) = $string =~ /hello/; print $capture;
evals/evals-freenode-#perl.lst[5880]: $string="hello world"; $capture = $string =~ /hello/; print $capture;
evals/evals-freenode-#perl.lst[5881]: $string="hello world"; ($capture) = $string =~ s/.*(hello).*/$1/; print $capture;
evals/evals-freenode-#perl.lst[5882]: $string = "nah, i don't will hack you. you guys are cool."; $string =~ s/"don't will"/"won't"/g; print $string;
evals/evals-freenode-#perl.lst[5883]: $string = "nah, i don't will hack you. you guys are cool."; $string =~ s/don't will/won't/g; print $string;
evals/evals-freenode-#perl.lst[5884]: $string = qq/bleh/; print $string;
evals/evals-freenode-#perl.lst[5885]: $string = qq/bleh/; print $string => $string;
evals/evals-freenode-#perl.lst[5886]: $string="xyz357pdq"; $string=~s/.*357.*/357/g; print $string
evals/evals-freenode-#perl.lst[5887]: $_ = "stringy stringy string"; $f = ~m/ingy/; print $f
evals/evals-freenode-#perl.lst[5888]:  $str = "I weight 15.6kg"; $str =~ s/(\d+(?:\.\d+)?)/sprintf('%.f',$1)/er;
evals/evals-freenode-#perl.lst[5889]: $str = 'JÚ ÁR KORREKT SZŐR'; utf8::encode $str for 1..10; $str
evals/evals-freenode-#perl.lst[5890]: $str = "llama"; print substr($str, 0, -1);
evals/evals-freenode-#perl.lst[5891]: $str = "llama"; print substr($str, -1, 0);
evals/evals-freenode-#perl.lst[5892]: $str = "llama"; print substr($str, 1, -1);
evals/evals-freenode-#perl.lst[5893]: $str = "llama"; print substr($str, 1, 1);
evals/evals-freenode-#perl.lst[5894]: $str = "llama"; print substr($str, 1, 2);
evals/evals-freenode-#perl.lst[5895]: $str = "llama"; print substr($str, 1, 3);
evals/evals-freenode-#perl.lst[5896]: $str = 'P98 3G\xE5\x85\xAB\xE6\xA0\xB8(A3HY) Build/KOT49H)'; $str =~ s/\\x(..)/chr hex $1/ge; Encode::decode_utf8($str)
evals/evals-freenode-#perl.lst[5897]: $str = 'P98 3G\xE5\x85\xAB\xE6\xA0\xB8(A3HY) Build/KOT49H)'; $str =~ s/\\x(..)/chr hex $1/ge; $str
evals/evals-freenode-#perl.lst[5898]: $str='post hoc ergo propter hoc'; $str=~s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $str;
evals/evals-freenode-#perl.lst[5899]: $str = "_"; print "ok" if ($str =~ /\w/)
evals/evals-freenode-#perl.lst[5900]: strptime
evals/evals-freenode-#perl.lst[5901]: [ strptime('32/05/2015', '%d/%m/%Y') ]
evals/evals-freenode-#perl.lst[5902]: strptime("%A, %d %B, %Y", "Wednesday, 7715th September, 1993" =~ s/th|rd|nd//gr)
evals/evals-freenode-#perl.lst[5903]: [ strptime "Dec", "%b" ]
evals/evals-freenode-#perl.lst[5904]: strptime("Wednesday, 7715th September, 1993" =~ s/th|rd|nd//gr, "%A, %d %B, %Y")
evals/evals-freenode-#perl.lst[5905]: $str = scalar ["a".."m"]; print $str
evals/evals-freenode-#perl.lst[5906]: $str=sprintf("%.3f", 1/3); print $str;
evals/evals-freenode-#perl.lst[5907]: $str=sprintf(%.3f, 1/3); print $str;
evals/evals-freenode-#perl.lst[5908]: $str="status is: active/standby"; $str =~ s/.*\://; print $str;
evals/evals-freenode-#perl.lst[5909]: $str="status is: active/standby"; $str =~ s/.*\:\s+?//; print $str;
evals/evals-freenode-#perl.lst[5910]: $str="stringAtostringBxyz"; $str=~s/A.*B//g; print $str;
evals/evals-freenode-#perl.lst[5911]: $str = "''"; $str=~ s/\'\'/\'/g; print $str;
evals/evals-freenode-#perl.lst[5912]: $str = 'str with [ bracket'; $str =~ /[][]/ ? 'match' : 'no match';
evals/evals-freenode-#perl.lst[5913]: $str = "s\xc3\x83\xc2\xbc\xc3\x83\xc2\x9fe"; [ $str, decode_utf8($str), decode_utf8(decode_utf8($str)) ]
evals/evals-freenode-#perl.lst[5914]: $str = 'test'; for my $n (0..2**length($str)-1) { $bit = 0; print $str =~ s/([a-z])/$n & 1<<$bit++ ? uc$1 : lc$1/ger, ' ' } # << may be faster
evals/evals-freenode-#perl.lst[5915]: $str = 'test'; for my $n (0..2**length($str)-1) { $bit = 0; print $str =~ s/([a-z])/$n & 2**$bit++ ? uc$1 : lc$1/ger, ' ' } # another idea
evals/evals-freenode-#perl.lst[5916]: $str = 'test'; for my $n (0..2**length($str)-1) { $bit = 0; print $str =~ s/([a-z])/$n & 2**$bit++ ? uc$1 : lc$1/gier, ' ' } # needs /i (maybe?)
evals/evals-freenode-#perl.lst[5917]:  $str = “the 15.7 romulans”; $str =~ s/((\d+)(\.\d+)?)/int(\1)/e;
evals/evals-freenode-#perl.lst[5918]:  $str = "the 15.7 romulans"; $str =~ s/((\d+)(\.\d+)?)/sprintf("%.f",(\1)/e;
evals/evals-freenode-#perl.lst[5919]:  $str = "the 15.7 romulans"; $str =~ s/((\d+)(\.\d+)?)/sprintf("%.f",\1)/e;
evals/evals-freenode-#perl.lst[5920]:  $str = "the 15.7 romulans"; $str =~ s/(\d+(?:\.\d+)?)/sprintf('%.f',$1)/er;
evals/evals-freenode-#perl.lst[5921]:  $str = "the 15.7 romulans"; $str =~ s/(\d+(?:\.\d+)?)/sprintf("%.f",\1)/er;
evals/evals-freenode-#perl.lst[5922]: $str='the quick brown fox jumped over the lazy dogs'; $str=~s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $str;
evals/evals-freenode-#perl.lst[5923]: $str='the quick Brown Fox'; $rex = qr/brown f/i; print $rex; $str =~ $rex; print " $str";
evals/evals-freenode-#perl.lst[5924]: $str='the quick Brown Fox'; $rex = qr/brown f/i; print $rex; $str =~ s/$rex//; print " $str";
evals/evals-freenode-#perl.lst[5925]: $str='the rain in spain is not a dancer'; print s/e//g;
evals/evals-freenode-#perl.lst[5926]: $str='this is my leetspeak regex'; $str=~ s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $str
evals/evals-freenode-#perl.lst[5927]: $str='  trim this  '; $str=~s/^\s+//g; $str=~s/\s+$//g; print $str;
evals/evals-freenode-#perl.lst[5928]: $str = uc("foobar") =~ s/FOO//r; $str
evals/evals-freenode-#perl.lst[5929]: $str = undef; print ref $str;
evals/evals-freenode-#perl.lst[5930]: $str = undef; print $str;
evals/evals-freenode-#perl.lst[5931]: $str="wildcard portion"; $str=~s/(.)/\[$&\]/g; print $str;
evals/evals-freenode-#perl.lst[5932]: $str="wildcard portion"; $str=~s/wildcar(d.+)tion/\[$&\]/g; print $str;
evals/evals-freenode-#perl.lst[5933]: $str="wildcard portion"; $str=~s/wildcar(d*+)tion/\[$&\]/g; print $str;
evals/evals-freenode-#perl.lst[5934]: $str="wildcard portion"; $str=~s/wildcar(.*)tion/\[$&\]/g; print $str;
evals/evals-freenode-#perl.lst[5935]: $str="wildcard portion"; $str=~s/.*(wild).*/$&/g; print $str;
evals/evals-freenode-#perl.lst[5936]: $str="wildcard portion"; $str=~s/(wild)/\[$&\]/g; print $str;
evals/evals-freenode-#perl.lst[5937]: s TT$ Donald Trump
evals/evals-freenode-#perl.lst[5938]: "stuff" . 1 + 3
evals/evals-freenode-#perl.lst[5939]: ['stuff' =~ /(?:(?!stuff).)*/]
evals/evals-freenode-#perl.lst[5940]: /(?<!STYLESY0B\$\$)/
evals/evals-freenode-#perl.lst[5941]: /(?<!STYLESY0B\$\$)\b/
evals/evals-freenode-#perl.lst[5942]: /(?<!STYLESY0B\$\$)\b/i
evals/evals-freenode-#perl.lst[5943]: /(?<!STYLESY0B\$\$)/i
evals/evals-freenode-#perl.lst[5944]: /(?<!STYLESY0B\$\$)/ia
evals/evals-freenode-#perl.lst[5945]: /(?<!STYLESY0B\$\$)/iaa
evals/evals-freenode-#perl.lst[5946]: (sub ($$) { $$ })->()
evals/evals-freenode-#perl.lst[5947]: (sub {}) -> ()
evals/evals-freenode-#perl.lst[5948]: [ [ sub {} ] ]
evals/evals-freenode-#perl.lst[5949]: [ sub {} ]
evals/evals-freenode-#perl.lst[5950]: sub と {}
evals/evals-freenode-#perl.lst[5951]: (sub { ($_[0] = $_), shift for "another perl Just hacker,\n" =~ /\S+\s/g })->(qw,s o r t,); print @a;
evals/evals-freenode-#perl.lst[5952]: (sub { ($_[0] = $_), shift for "another perl Just hacker,\n" =~ /\S+\s/g })->(sort my @a = qw,s o r t,); print @a;
evals/evals-freenode-#perl.lst[5953]: sub { &{$_[0]} }->( sub { &{$_[0]} } )
evals/evals-freenode-#perl.lst[5954]: (sub { 1 }) -> ()
evals/evals-freenode-#perl.lst[5955]: sub _{@_<2&&return@_;push@{$|--},$_ for@_;map _(@$_),map[splice@$_],0,1}print _ split//,"huroP cels,tetah Jen akrr";
evals/evals-freenode-#perl.lst[5956]: sub _{@_<2&&return@_;push@{$|--},$_ for@_;map _(@$_),map[splice@$_],0,1}print _ split//,"Just another Perl hacker,";
evals/evals-freenode-#perl.lst[5957]: sub _{@_<2&&return@_;push@{$|--},$_ for@_;map _(@$_),map[splice@$_],0,1}print _ split//," uhPakatrrorc  ,tlJenehse";
evals/evals-freenode-#perl.lst[5958]: [ sub {42} ]->[0]()  # hehehe
evals/evals-freenode-#perl.lst[5959]: sub {42}->()  # hehehe
evals/evals-freenode-#perl.lst[5960]: [ sub { 55 if 0 }->() ]
evals/evals-freenode-#perl.lst[5961]: sub { 55 if 0 }->()
evals/evals-freenode-#perl.lst[5962]: sub a { (5,7) }; a()->[1]
evals/evals-freenode-#perl.lst[5963]: sub a { (5,7) }; a[1]
evals/evals-freenode-#perl.lst[5964]: sub a { (5,7); }  (a(3,1))[1];
evals/evals-freenode-#perl.lst[5965]: sub a { (5,7); }  die (a(3))[1];
evals/evals-freenode-#perl.lst[5966]: sub a { (5,7); }  die (a(3,1))[1];
evals/evals-freenode-#perl.lst[5967]: sub a { (5,7); }  die +(a(3,1))[1];
evals/evals-freenode-#perl.lst[5968]: sub a () { (5, 7) } print a[1];
evals/evals-freenode-#perl.lst[5969]: sub a { @_ } (a 3,2)[1]
evals/evals-freenode-#perl.lst[5970]: sub a { @_ }; (a(3,2))[1]
evals/evals-freenode-#perl.lst[5971]: sub a　b { "hi" } a　b
evals/evals-freenode-#perl.lst[5972]: sub a { b() } sub b { goto (caller(1))(3) } a()
evals/evals-freenode-#perl.lst[5973]: sub a { b() } sub b { goto (caller(1))[3] } a()
evals/evals-freenode-#perl.lst[5974]: sub a { b() } sub b { goto *{+(caller(1))[3]}{CODE} } a()
evals/evals-freenode-#perl.lst[5975]: sub accessor { my $self = shift; unless($self->{whatever}) { $self->{whatever} = 'stuff' } } accessor({whatever => 'previous value'}) # obviously no one would write code like that unless they hated the rest of their team, but, y'know. real example, sadly
evals/evals-freenode-#perl.lst[5976]: sub add { $_[0]+1 } add 5
evals/evals-freenode-#perl.lst[5977]: sub add { $_[0]+$_[1] } say add 2 => 2
evals/evals-freenode-#perl.lst[5978]: sub add { my $x = shift; sub { $_[0] + $x } } add(1)->(2)
evals/evals-freenode-#perl.lst[5979]: sub add ($$) { return $_[0] + $_[1] } my @stuff_from_the_user = (2, 2); add @stuff_from_the_user;
evals/evals-freenode-#perl.lst[5980]: sub another'Just { "Just @_," } sub hacker'Perl { "Perl @_" }  Just another Perl hacker,
evals/evals-freenode-#perl.lst[5981]: sub { $anyothername = 'xxx' }->(); [ $anyothername ]
evals/evals-freenode-#perl.lst[5982]: sub a { @_ } print a(5,7)[1];
evals/evals-freenode-#perl.lst[5983]: sub a { return (5, 7); } print (a())[1];
evals/evals-freenode-#perl.lst[5984]: sub AUTOLOAD { $AUTOLOAD = 'cats' } sub lol { "lol" } notlol()
evals/evals-freenode-#perl.lst[5985]: sub AUTOLOAD { $AUTOLOAD = 'lol' } sub lol { "lol" } notlol()
evals/evals-freenode-#perl.lst[5986]: sub AUTOLOAD { $AUTOLOAD = 'lol' } sub lol { "verylol" } notlol()
evals/evals-freenode-#perl.lst[5987]: sub AUTOLOAD{ our $AUTOLOAD; my ( $a ) = @_; print "$AUTOLOAD $a"; } hello( 'kitty' );
evals/evals-freenode-#perl.lst[5988]: sub AUTOLOAD { print "hi" } &foo
evals/evals-freenode-#perl.lst[5989]: sub AUTOLOAD { print "hi" } &{"foo"}
evals/evals-freenode-#perl.lst[5990]: sub AUTOLOAD { print "hi" } foo;
evals/evals-freenode-#perl.lst[5991]: sub AUTOLOAD { print "hi" } $x=\*foo{CODE}; &$x;
evals/evals-freenode-#perl.lst[5992]: sub AUTOLOAD { print "hi" } $x=\*foo; &$x;
evals/evals-freenode-#perl.lst[5993]: sub AUTOLOAD { say 'test' }; [ 'main'->can('AUTOLOAD') ? 'yes' : 'no' ];
evals/evals-freenode-#perl.lst[5994]: sub bar { $_[0]( $_[1] ) }; bar(sub { $_[0] * 2}, 5)
evals/evals-freenode-#perl.lst[5995]: sub bar { $foo = 0; return $foo || die; } bar();
evals/evals-freenode-#perl.lst[5996]: sub bar { $foo = 0; return $foo or die; } bar();
evals/evals-freenode-#perl.lst[5997]: sub base { my ($d, $n) = @_; my $r = ''; { my $c = $n % $d; if ($c >= 10) { $c = chr($c - 10 + ord 'a'); } $r .= $c; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 16, 0
evals/evals-freenode-#perl.lst[5998]: sub base { my ($d, $n) = @_; my $r = ''; { my $c = $n % $d; if ($c >= 10) { $c = chr($c - 10 + ord 'a'); } $r .= $c; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 16, 255
evals/evals-freenode-#perl.lst[5999]: sub base { my ($d, $n) = @_; my $r = ''; { $r .= $n % $d; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 10, 5
evals/evals-freenode-#perl.lst[6000]: sub base { my ($d, $n) = @_; my $r = ''; { $r .= $n % d; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 10, 5
evals/evals-freenode-#perl.lst[6001]: sub base { my ($d, $n) = @_; my $r = ''; { $r .= $n % $d; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 2, 10
evals/evals-freenode-#perl.lst[6002]: sub base { my ($d, $n) = @_; my $r = ''; { $r .= $n % $d; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 2, 5
evals/evals-freenode-#perl.lst[6003]: sub bin2chr { pack 'b8', $_ }   join "", map { bin2chr $_ } "0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010" =~ m/(.{8}/g;
evals/evals-freenode-#perl.lst[6004]: sub bin2chr { pack 'b8', $_ }   join "", map { bin2chr $_ } "0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010" =~ m/(.{8})/g;
evals/evals-freenode-#perl.lst[6005]: sub bin2chr { pack 'B8', $_ }   join "", map { bin2chr $_ } "0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010" =~ m/(.{8})/g;
evals/evals-freenode-#perl.lst[6006]: sub blah { $_[0]++ } blah(my $val); ++$val
evals/evals-freenode-#perl.lst[6007]: sub blah { my @args = @_; return @args[-1]; } blah(0,1,2,3,4,5,6);
evals/evals-freenode-#perl.lst[6008]: sub blah { return $_[3] } blah(0,1,2,3,4,5,6);
evals/evals-freenode-#perl.lst[6009]: sub blah { "value" } blah()
evals/evals-freenode-#perl.lst[6010]: sub buildMech { return WWW::Mechanize->(); } sub zeroMech {my $mech = $_[0]; $$mech->clear_credentials(); } my $mech = zeroMech \buildMech();
evals/evals-freenode-#perl.lst[6011]: sub buildMech { return WWW::Mechanize->(); } sub zeroMech {my $mech = $_[0]; $$mech->clear_credentials(); } my $mech = zeroMech buildMech();
evals/evals-freenode-#perl.lst[6012]: sub Bulgaria { print caller; } package Wimbledon; Bulgaria
evals/evals-freenode-#perl.lst[6013]: sub Bulgaria { print caller; } package Wimbledon; Bulgaria()
evals/evals-freenode-#perl.lst[6014]: sub c {$_[0]=~/.*\.(.*)$/;$1} [map c($_), "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl"]
evals/evals-freenode-#perl.lst[6015]: sub c {$_[0]=~/.*\.(.*)$/;$1} [map c($_), "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
evals/evals-freenode-#perl.lst[6016]: sub catify { $_[0] = "cats" } my $x = "dogs"; catify $x; [$x]
evals/evals-freenode-#perl.lst[6017]: sub chomp { "blah" }; [ chomp ] # Perl will warn about this with warnings on though
evals/evals-freenode-#perl.lst[6018]: sub closure { my $foo; sub { $foo ++ } }; my $sub = closure(); my $other = closure() ; [ $sub->(), $sub->() , $other->(), $other->(), $other->() ] # note that the $foo that belongs to $sub is different from the $foo that $other has... and that they both continue to exist due to there being a reference to a sub in the scope they reside within. see also: coping with scoping
evals/evals-freenode-#perl.lst[6019]: sub compare ($$) { $_[1] - $_[0] } [ sort compare -2, 5, 710, 9, 1 ]
evals/evals-freenode-#perl.lst[6020]: sub config { my %x = (a => "b"); \%x }; config
evals/evals-freenode-#perl.lst[6021]: sub CONSTANTPLS { 5 } my %stuff = ( +CONSTANTPLS => 7 ); $stuff{+CONSTANTPLS}
evals/evals-freenode-#perl.lst[6022]: sub CONSTANTPLS { 5 } my %stuff = ( CONSTANTPLS() => 7 ); $stuff{CONSTANTPLS()}
evals/evals-freenode-#perl.lst[6023]: sub ctx { say wantarray } \ctx;
evals/evals-freenode-#perl.lst[6024]: sub ctx { wantarray // 'undef' } \ctx;
evals/evals-freenode-#perl.lst[6025]: sub curry { my ($f) = @_; sub { my ($x) = @_; sub { my ($y) = @_; $f->($x, $y) } } } sub base { my ($d, $n) = @_; my $r = ''; { my $c = $n % $d; if ($c >= 10) { $c = chr($c - 10 + ord 'a'); } $r .= $c; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } curry(\&base)->(16)->(255)
evals/evals-freenode-#perl.lst[6026]: sub custom { my ($k) = @_; $a->{$k} cmp $b->{$k} } [ sort { custom('name') } { name => 'x' }, { name => 'y' }, { name => 'z' } ]
evals/evals-freenode-#perl.lst[6027]: sub d { $_[0] < 10 ? $_[0] : (rand >= 0.5 ? 'a' .. 'z' : 'A' .. 'Z')[$_[0] - 10] } sub b { $_ && b($_[0], $_) for int $_[1] / $_[0]; print d $_[1] % $_[0]; } b 14, 1.4e9
evals/evals-freenode-#perl.lst[6028]: sub d { (0 .. 9, 'a' .. 'z')[$_[0]] } sub b { $_ && b($_[0], $_) for int $_[1] / $_[0]; print d $_[1] % $_[0]; } b 14, 1.4e9
evals/evals-freenode-#perl.lst[6029]: sub d { (0 .. 9, 'a' .. 'z')[$_[0]] } sub b { $_ && b($_[0], $_) for int $_[1] / $_[0]; print d $_[1] % $_[0]; } b 16, 255
evals/evals-freenode-#perl.lst[6030]: sub d { (0 .. 9, 'a' .. 'z')[$_[0]] } sub b { $_ && b($_) for int $_[1] / $_[0]; print d $_[1] % $_[0]; } b 14, 1.4e9
evals/evals-freenode-#perl.lst[6031]: sub dieonAg{ $string = shift; if ($string =~ /A[^ab]/) die "A and not Aa or Ab"; return $string};   print dieonAg("Hi A.");
evals/evals-freenode-#perl.lst[6032]: sub dieonAg{ $string = shift; if( $string =~ /A[^ab]/) {die "A and not Aa or Ab"}; return $string};   print dieonAg("Hi A.");
evals/evals-freenode-#perl.lst[6033]: sub dieonAg{ $string = shift; if ($string =~ /A[^ab]/) die "A and not Aa or Ab"; return $string};   print dieonAg("Hi Ab.");
evals/evals-freenode-#perl.lst[6034]: sub dieonAg{ $string = shift; if( $string =~ /A[^ab]/) {die "A and not Aa or Ab"}; return $string};   print dieonAg("Hi Ab.");
evals/evals-freenode-#perl.lst[6035]: sub do_stuff { my ($thing, @morestuff) = @_; return $thing, @morestuff; } do_stuff(0, 'asdf') ? 1 : 0
evals/evals-freenode-#perl.lst[6036]: sub do_stuff { undef $_ } [ map { do_stuff(); $_ } (1,2,3) ]
evals/evals-freenode-#perl.lst[6037]: sub du { my ($x, $N, $V, $C) = @_; unpack('C', $x) + $C * 256 } sub ds { my ($x, $N, $V, $C) = @_; unpack('C', $x) - ($N ^ $V) * 256 } sub p { pack "B*", $_[0] } [ map [du(@$_), ds(@$_)], [p('00111000'), 0, 0, 1], [p('01000110'), 0, 1, 1] ]
evals/evals-freenode-#perl.lst[6038]: sub du { my ($x, $N, $V, $C) = @_; $x + $C * 256 } sub ds { my ($x, $N, $V, $C) = @_; $x - ($N ^ $V) * 256 } [ map [du(@$_), ds(@$_)], [0b0011_1000, 0, 0, 1], [0b0100_0110, 0, 1, 1] ]
evals/evals-freenode-#perl.lst[6039]: sub eh { print ">", wantarray, "<" } ref(eh)
evals/evals-freenode-#perl.lst[6040]: sub { eval { return 1 }; return 2 }->()
evals/evals-freenode-#perl.lst[6041]: sub f { 1 }; main -> f;
evals/evals-freenode-#perl.lst[6042]: sub f1 { print 'f1' } sub f2 { print 'f2' } eval "f1\n&f2"
evals/evals-freenode-#perl.lst[6043]: sub f1 { \@_ } sub f2 { "f2" } eval "f1;\n&f2"
evals/evals-freenode-#perl.lst[6044]: sub f1 { \@_ } sub f2 { "f2" } eval "f1\n&f2"
evals/evals-freenode-#perl.lst[6045]: sub f { a => 123 } +{ f() }->{a}
evals/evals-freenode-#perl.lst[6046]: sub f { (a => 1, b => 2) } my $value = { f() }->{a};
evals/evals-freenode-#perl.lst[6047]: sub f { my @array = 1..3; return @array } \f()
evals/evals-freenode-#perl.lst[6048]: sub foo { ${$_[0]} = 123 } foo \(my $x); $x
evals/evals-freenode-#perl.lst[6049]: sub foo { ${$_[0]} = 123 } foo \undef; $x
evals/evals-freenode-#perl.lst[6050]: sub foo { $$_[0] = 1 } foo \(my $x); $x
evals/evals-freenode-#perl.lst[6051]: sub foo{$_[0]<=>$_[1]} [sort &foo, qw,1 3 2 772 9,]
evals/evals-freenode-#perl.lst[6052]: sub foo { $_[0] * 2 } sub bar { $_[0]( $_[1] ) }; bar(\&foo, 5)
evals/evals-freenode-#perl.lst[6053]: sub foo { $_[0] } "cats"->${ \\&foo }
evals/evals-freenode-#perl.lst[6054]: sub foo { $_[0] } "cats"->${ \&foo }
evals/evals-freenode-#perl.lst[6055]: sub foo {$_[0]="cats"}; foo "dogs";  # don't cripple your API for no reason
evals/evals-freenode-#perl.lst[6056]: sub foo (&) { $_[0]() } foo \sub {};
evals/evals-freenode-#perl.lst[6057]: sub foo { $_[0] .= "Hi" } my $x = "Hello "; foo($x); [$x]
evals/evals-freenode-#perl.lst[6058]: sub foo { $_[0] = "hi"; } sub r_u_kiddin_me { \@_ } sub bar { local *copy = r_u_kiddin_me @_; foo(@copy); "@_" }  $x = "foo"; bar $x
evals/evals-freenode-#perl.lst[6059]: sub foo { $_[0]++ } my $x = 1; foo($x); $x
evals/evals-freenode-#perl.lst[6060]: sub foo { $_[0]++ } my $x = 3; foo($x); [$x] #anno, you were saying?
evals/evals-freenode-#perl.lst[6061]: sub foo { @{$_[0]}=qw( A B C ); } foo (\my @y); \@y;
evals/evals-freenode-#perl.lst[6062]: sub foo { @{$_[0]}=qw( A B C ); } foo [my @y]; \@y;
evals/evals-freenode-#perl.lst[6063]: sub foo { @{$_[0]}=qw( A B C ); } foo \(my @y); \@y;
evals/evals-freenode-#perl.lst[6064]: sub foo { $_[0] =~ s/foo/bar/ } sub bar { foo(@copy = @_); "@_" } $x = "foo"; bar($x)  # how about this
evals/evals-freenode-#perl.lst[6065]: sub foo { $_[0] =~ s/foo/bar/ } sub bar { foo(@_); "@_" } $x = "foo"; bar($x)
evals/evals-freenode-#perl.lst[6066]: sub foo { 1..10 }; \foo;
evals/evals-freenode-#perl.lst[6067]: sub foo { 1, 2, 3 } [ \foo ]
evals/evals-freenode-#perl.lst[6068]: sub foo { 1, 2, 3 } \foo
evals/evals-freenode-#perl.lst[6069]: sub foo { [1, 2, 3] } { my $arr_ref = foo(); if (@$arr_ref) { print @$arr_ref } }
evals/evals-freenode-#perl.lst[6070]: sub foo { 2 } $foo=1; [$foo,foo]
evals/evals-freenode-#perl.lst[6071]: sub foo { 2 }; $foo=1; [$foo,foo]
evals/evals-freenode-#perl.lst[6072]: sub foo { 42 } *bar = \&foo; bar()
evals/evals-freenode-#perl.lst[6073]: sub FOO () { 42 } [ $::{FOO} ]
evals/evals-freenode-#perl.lst[6074]: sub foo { 42 }  *{$main::{foo}}{CODE}
evals/evals-freenode-#perl.lst[6075]: sub foo { 42 } our $foo = 2; *{$main::{foo}}{CODE}
evals/evals-freenode-#perl.lst[6076]: sub foo { [ @_ ] }; @a = (1,2,3,4); foo(@a)
evals/evals-freenode-#perl.lst[6077]: sub foo { [ @_ ] }; @a = 1,2,3,4; foo(@a)
evals/evals-freenode-#perl.lst[6078]: sub foo{$a<=>$b} [sort &foo, qw(1 3 2 772 9)]
evals/evals-freenode-#perl.lst[6079]: sub foo { 'a'..'z' }; [\(foo)];
evals/evals-freenode-#perl.lst[6080]: sub foo { 'a'..'z' }; [\foo];
evals/evals-freenode-#perl.lst[6081]: sub foo { 'a'..'z' }; \(foo);
evals/evals-freenode-#perl.lst[6082]: sub foo { 'a'..'z' }; \foo;
evals/evals-freenode-#perl.lst[6083]: sub foo { 'a'..'z' }; \( (foo)[0..26] );
evals/evals-freenode-#perl.lst[6084]: sub Foo::Bar::blah { 'hi' } 'Foo::Bar'->blah
evals/evals-freenode-#perl.lst[6085]: sub foo { BLAH: { sub { last BLAH }->(); print "cats\n" } } foo()
evals/evals-freenode-#perl.lst[6086]: sub foo { (caller 0)[3] } foo
evals/evals-freenode-#perl.lst[6087]: sub foo {(caller(0))[3]}  foo()
evals/evals-freenode-#perl.lst[6088]: sub foo { $count++; (1,2,3) } foreach my $x (foo()) { } $count
evals/evals-freenode-#perl.lst[6089]: sub Foo { die 'here' } 'Foo'->new
evals/evals-freenode-#perl.lst[6090]: sub foo { $#$_; }; [ foo(1 .. 4) ]
evals/evals-freenode-#perl.lst[6091]: sub foo ($$) { [@_] } [ foo 'a', 'b', foo 'c', 'd' ]  # should be [ [ 'a' => 'b' ], [ 'c', 'd' ] ]
evals/evals-freenode-#perl.lst[6092]: sub foo; foo "hi\n"; sub foo { print "moo\n"; }
evals/evals-freenode-#perl.lst[6093]: sub foo { "foo!" }; push @x, \&foo; $x[0]->()
evals/evals-freenode-#perl.lst[6094]: sub foo { "foo!" }; push @x, \&foo; $x[0]() # I thought the -> was always needed before () - guess not
evals/evals-freenode-#perl.lst[6095]: sub foo (;*); foo($x, $y, length $y);
evals/evals-freenode-#perl.lst[6096]: sub foo (\&);  # good luck, what does this even mean
evals/evals-freenode-#perl.lst[6097]: sub foo {" Hello"}; undef &foo; foo()
evals/evals-freenode-#perl.lst[6098]: sub foo { "hi" } my @x; bless \@x; (\@x)->foo
evals/evals-freenode-#perl.lst[6099]: sub foo{if (0) {} else {"nothing"}} [foo]
evals/evals-freenode-#perl.lst[6100]: sub foo{if (1) {} else {"nothing"}} [foo]
evals/evals-freenode-#perl.lst[6101]: sub foo ($is_it) { $is_it } foo "cats"
evals/evals-freenode-#perl.lst[6102]: sub foo { join '-', @_ } foo 1, 2, 3, "dogs"
evals/evals-freenode-#perl.lst[6103]: sub foo{}  join ",", (\&foo, \&foo)
evals/evals-freenode-#perl.lst[6104]: sub foo{}  join ",", (\&foo)x2
evals/evals-freenode-#perl.lst[6105]: sub foo { key1 => value1, key2 => value2 } [foo()]
evals/evals-freenode-#perl.lst[6106]: sub foo :lvalue { @foo };  foo() = qw/ One Two Three /;
evals/evals-freenode-#perl.lst[6107]: sub foo :lvalue { $foo };  foo() = qw/ One Two Three /; $foo
evals/evals-freenode-#perl.lst[6108]: sub foo :lvalue { print "FOO!" }  undef &foo; foo()
evals/evals-freenode-#perl.lst[6109]: sub foo :lvalue { say wantarray } foo = "cats"
evals/evals-freenode-#perl.lst[6110]: sub foo :lvalue { say wantarray; our $foo } foo = "cats"
evals/evals-freenode-#perl.lst[6111]: sub foo :lvalue { [wantarray] } foo = "cats"
evals/evals-freenode-#perl.lst[6112]: sub foo { \@_ };  [ main::foo("bar"), main->foo("bar") ]
evals/evals-freenode-#perl.lst[6113]: sub foo { map { $_ } 1..10; } my $x = [ foo ]; $x;
evals/evals-freenode-#perl.lst[6114]: sub foo { map { $_ } 1..10; } my $x = foo; $x;
evals/evals-freenode-#perl.lst[6115]: sub foo { map { $_ } 1..10; } my $x = \foo; $x; ### Why is this produce a different result?
evals/evals-freenode-#perl.lst[6116]: sub foo { map { $_ } qw/a b c/; } my $x = \foo; $x;
evals/evals-freenode-#perl.lst[6117]: sub foo { map { $_ } qw/a b c/; } my $x = foo; $x;
evals/evals-freenode-#perl.lst[6118]: sub foo {  map { @_ }  qw/the futures returned/  }     [ foo(qw/the method parameters/) ]
evals/evals-freenode-#perl.lst[6119]: sub foo() { my ($arg1, $arg2) = @_ } foo(1,2)
evals/evals-freenode-#perl.lst[6120]: sub foo { my ($arg1, $hashref) = @_; $hashref->{asdf} = 35 } my %hash = (asdf => 55); foo('25', \%hash); $hash{asdf}
evals/evals-freenode-#perl.lst[6121]: sub foo { my ($arg1, $hashref) = @_; $hashref->{asdf} } my %hash = (asdf => 55); foo('25', \%hash)
evals/evals-freenode-#perl.lst[6122]: sub foo (&@) { my ($code, @args) = @_; $code->(@args) } my $res = foo { [@_] } 1, 2, 3; $res
evals/evals-freenode-#perl.lst[6123]: sub foo { my $c = wantarray; !defined $c ? "void" : $c ? "list" : "scalar" } (foo) x 4
evals/evals-freenode-#perl.lst[6124]: sub foo { my $c = wantarray; !defined $c ? "void" : $c ? "list" : "scalar" } [(foo) x 4 ]
evals/evals-freenode-#perl.lst[6125]: sub foo { my ($d, @r) = @_; if ($d < 1) { print "@r; "; return; } for my $i (1 .. 3) { foo($d - 1, @r, $i); } } foo 2;
evals/evals-freenode-#perl.lst[6126]: sub foo { my ($d, @r) = @_; if ($d < 1) { print "@r; "; return; } for my $i (1 .. 3) { foo($d - 1, @r, $i); } } foo 5;
evals/evals-freenode-#perl.lst[6127]: sub foo { my $_ = \@_; $#$_ } [ foo(1..4) ]
evals/evals-freenode-#perl.lst[6128]: sub foo { } my $foo = \&foo; my $bar = \&bar; [ $foo eq $bar ]
evals/evals-freenode-#perl.lst[6129]: sub foo { } my $foo = \&foo; my $bar = \&foo; [ $foo == $bar ]
evals/evals-freenode-#perl.lst[6130]: sub foo { my ($num, @els) = @_; $num + @els } foo( 3, 1, 2, 3)
evals/evals-freenode-#perl.lst[6131]: sub foo { my ($one, $two, $three) = @_; return defined($two) ? "two is defined" : "two is undef"; } [foo('hello',undef(),'three')]
evals/evals-freenode-#perl.lst[6132]: sub foo ($$) { \@_ } my @stuff = (1,2,3); foo @stuff
evals/evals-freenode-#perl.lst[6133]: sub foo ($$) { \@_ } my @stuff = (1,2,3); foo @stuff, 5
evals/evals-freenode-#perl.lst[6134]: sub foo { my $x = $_[0]; $x =~ s/foo/bar/ } sub bar { foo(@_); "@_" } $x = "foo"; bar($x)
evals/evals-freenode-#perl.lst[6135]: sub foo { my $x = 42; sub { eval shift } } foo()->('$x')
evals/evals-freenode-#perl.lst[6136]: sub foo { my $x = 42; sub { $x; eval shift } } foo()->('$x')
evals/evals-freenode-#perl.lst[6137]: sub foo($$$) { "@_" } my @x = 9..13; foo(@x)
evals/evals-freenode-#perl.lst[6138]: sub foo { my $x = do { return 1 }; $x + 1 } foo
evals/evals-freenode-#perl.lst[6139]: sub foo { my ($x, $y, $z, @rest) = @_; bar( $x, @rest ); } sub bar { [ @_ ]; } my %h = ( a => 123, b => 456 ); foo 77, 88, 99, %h;
evals/evals-freenode-#perl.lst[6140]: sub Foo { our $nested; local $nested unless $nested; my @p = ( [ shift, $nested // 0, $nested ? q{Nested} : q{First} ] ); {  if ( @_ ) { $nested++; push @p, Foo( @_ ); }  }; if ( $nested ) { $nested--; @p; } else { [ @p ]; } }   { RUN1 => Foo(qw(A B C)), RUN2 => Foo(qw(X Y Z)) };
evals/evals-freenode-#perl.lst[6141]: sub Foo { our $nested; local $nested unless $nested; my @p = ( [ shift, $nested ? q{Nested} : q{First} ] ); {  if ( @_ ) { $nested++; push @p, Foo( @_ ); }  }; if ( $nested ) { $nested--; @p; } else { [ @p ]; } }   { RUN1 => Foo(qw(A B C)), RUN2 => Foo(qw(X Y Z)) };
evals/evals-freenode-#perl.lst[6142]: sub Foo { our $nested; local $nested unless $nested; my @p = ( [ shift, $nested ? q{Nested} : q{First} ] ); { $nested++; push @p, Foo( @_ ) if @_ }; if ( $nested ) { $nested--; @p; } else { [ @p ]; } } [ Foo( qw( A B C ) ), Foo( qw( X Y Z ) ) ];
evals/evals-freenode-#perl.lst[6143]: sub Foo { our $p; $p = [ ] unless defined $p; push @$p, [ shift, ( (caller(0))[3] eq (caller(1))[3] ? q{Nested} : q{First call} ) ]; Foo( @_ ) if @_; my $x = $p; $x; } Foo qw( A B C ); Foo qw( X Y Z );
evals/evals-freenode-#perl.lst[6144]: sub foo { print "bar" }; use constant { baz => *foo }; print $::{baz};
evals/evals-freenode-#perl.lst[6145]: sub foo { print "bar" }; use constant { baz => *foo }; print $::{baz}, *foo;
evals/evals-freenode-#perl.lst[6146]: sub foo { print "bar" }; use constant { baz => *foo }; print main->baz;
evals/evals-freenode-#perl.lst[6147]: sub foo::print { CORE::print "bar" }; print foo::; print "\n";
evals/evals-freenode-#perl.lst[6148]: sub foo { print "Debug\n", return 1 if (1); } foo();
evals/evals-freenode-#perl.lst[6149]: sub foo { print ("Debug\n"), return 1 if (1); } foo();
evals/evals-freenode-#perl.lst[6150]: sub foo { print("Debug\n"), return 1 if (1); } foo();
evals/evals-freenode-#perl.lst[6151]: sub foo () { print "-> @_ <-" } do foo(42);
evals/evals-freenode-#perl.lst[6152]: sub foo { print "eh" } foo()
evals/evals-freenode-#perl.lst[6153]: sub foo () { print "foo"; };   foo;
evals/evals-freenode-#perl.lst[6154]: sub foo { print $foo } sub bar { local $foo = 'baz'; foo }        $foo = 'quux';          foo(); bar(); foo()
evals/evals-freenode-#perl.lst[6155]: sub foo { print "FOO!" }  undef &foo; foo()
evals/evals-freenode-#perl.lst[6156]: sub foo { print "foo" }; use constant FOO => *foo; print FOO();
evals/evals-freenode-#perl.lst[6157]: sub foo { print "foo" }; use constant FOO => *foo; print main->FOO;
evals/evals-freenode-#perl.lst[6158]: sub foo { print \$_ . ": $_ " for @_ }; my $x = 1; foo( $x++, $x++, ++$x, ++$x, $x++, ++$x );
evals/evals-freenode-#perl.lst[6159]: sub foo { print "my arguments are [@_]"; } foo(1, 2, 3);
evals/evals-freenode-#perl.lst[6160]: sub foo { print "my arguments are [@_]"; } sub { foo(42) }->()
evals/evals-freenode-#perl.lst[6161]: sub foo { print "my arguments are [@_]"; } sub { foo(42, @_) }->(1, 2, 3)
evals/evals-freenode-#perl.lst[6162]: sub foo { print "my arguments are [@_]"; } sub { foo(42) }->(1, 2, 3)
evals/evals-freenode-#perl.lst[6163]: sub foo { print (STDERR "Debug\n"), return 1 if (1); } foo();
evals/evals-freenode-#perl.lst[6164]: sub foo { print (STDERR "Debug\n"); return 1 if (1); } foo();
evals/evals-freenode-#perl.lst[6165]: sub foo { print STDERR ("Debug\n"), return 1 if (1); } foo();
evals/evals-freenode-#perl.lst[6166]: sub foo { print(STDERR "Debug\n"), return 1 if (1); } foo();
evals/evals-freenode-#perl.lst[6167]: sub foo { print STDOUT ("Debug\n"), return 1 if (1); } foo();
evals/evals-freenode-#perl.lst[6168]: sub foo { print STDOUT ("Debug\n"); return 1 if (1); } foo();
evals/evals-freenode-#perl.lst[6169]: sub foo :prototype(&@) { my ($code, @args) = @_; $code->(@args) } my $res = foo { [@_] } 1, 2, 3; $res
evals/evals-freenode-#perl.lst[6170]: sub foo :prototype($$) { \@_ } my @stuff = (1,2,3); foo @stuff, 5
evals/evals-freenode-#perl.lst[6171]: sub foo($q) {$q + 3}; foo(5);
evals/evals-freenode-#perl.lst[6172]: sub foo { @_ = qw(hello world); } sub bar { &foo; "@_" }  bar
evals/evals-freenode-#perl.lst[6173]: sub foo { @_ = qw(hello world); } sub bar { foo(@_); "@_" }  bar
evals/evals-freenode-#perl.lst[6174]: sub foo { return [1, 2, 3] } if (@{(my $arr_ref = foo())}) { print @$arr_ref }
evals/evals-freenode-#perl.lst[6175]: sub foo { return(40) + 2 } foo()
evals/evals-freenode-#perl.lst[6176]: sub foo { return 42; }  [ foo(), foo() ]
evals/evals-freenode-#perl.lst[6177]: sub foo {return caller()} print Dumper(foo());
evals/evals-freenode-#perl.lst[6178]: sub foo { return 'foo', 'bar' } sub bar { return map uc, @_ } print bar foo
evals/evals-freenode-#perl.lst[6179]: sub foo { s/a// }; { my $_ = 'bar'; foo(); print $_ }
evals/evals-freenode-#perl.lst[6180]: sub foo { s/a// }; { my $_ = 'bar'; our $_ = 'baz'; foo(); print $_ }
evals/evals-freenode-#perl.lst[6181]: sub foo { s/a// }; { my $_ = 'bar'; our $_ = 'baz'; s/a//; print $_ }
evals/evals-freenode-#perl.lst[6182]: sub foo { s/a// }; { my $_ = 'bar'; s/a//; print $_ }
evals/evals-freenode-#perl.lst[6183]: { sub foo { say } } foo for 123
evals/evals-freenode-#perl.lst[6184]: sub foo { say wantarray() } \foo();
evals/evals-freenode-#perl.lst[6185]: sub foo { shift()*2 } sub bar :prototype() { shift()*2 } [(foo + 5), (bar + 5)]
evals/evals-freenode-#perl.lst[6186]: sub foo { shift()+3 } sub bar :prototype() { shift()+3 } [(foo + 5), (bar + 5)]
evals/evals-freenode-#perl.lst[6187]: sub foo { shift()+3 } sub bar :prototype() { shift()+3 } [foo + 5, bar + 5]
evals/evals-freenode-#perl.lst[6188]: sub foo { shift()+3 } sub bar () { shift()+3 } [foo + 5, bar + 5]
evals/evals-freenode-#perl.lst[6189]: sub foo { shift+3 } sub bar () { shift+3 } [foo + 5, bar + 5]
evals/evals-freenode-#perl.lst[6190]: sub foo {shift} { foo => 'bar' }->${ \\&foo }
evals/evals-freenode-#perl.lst[6191]: sub foo (\&) { shift->() } sub myfunc { say +(caller 0)[3] } foo &myfunc;
evals/evals-freenode-#perl.lst[6192]: sub foo (\&) { shift->() } sub myfunc { say +(caller 0)[3] } foo myfunc;
evals/evals-freenode-#perl.lst[6193]: sub foo; sub AUTOLOAD { print 'hi' } foo;
evals/evals-freenode-#perl.lst[6194]: sub foo { sub bar { } }
evals/evals-freenode-#perl.lst[6195]: sub foo { __SUB__ } foo
evals/evals-freenode-#perl.lst[6196]: sub foo { {thingy => $_[0]} } [foo 1, 2, 3]
evals/evals-freenode-#perl.lst[6197]: sub FOO () { time } [ $::{FOO} ]
evals/evals-freenode-#perl.lst[6198]: sub foo { undef; } my $x = foo() or print "lol"
evals/evals-freenode-#perl.lst[6199]: sub foo () { wantarray ? "list" : "scalar" } [ foo x 4 ]
evals/evals-freenode-#perl.lst[6200]: sub foo { wantarray ? "list" : "scalar" } [ foo x 4 ]
evals/evals-freenode-#perl.lst[6201]: sub foo { warn "had " . @_ . " items\n" } foo(\(my @x)); # foo is given a list of refs to everything in the list returned by (my @x), i.e. empty list
evals/evals-freenode-#perl.lst[6202]: sub foo ($y) { $y++ } my $x = 1; foo($x); $x
evals/evals-freenode-#perl.lst[6203]: sub f { return; } @a = f();  print $a[1];
evals/evals-freenode-#perl.lst[6204]: sub f{return} for (f) {print 'a' if defined $_}
evals/evals-freenode-#perl.lst[6205]: sub f { return (undef,undef); } @a = f();  print $a[1];
evals/evals-freenode-#perl.lst[6206]: sub f { state $x; if ($x) { print "rec\n"; return } local $x = 1; f() }
evals/evals-freenode-#perl.lst[6207]: sub f{ state $x; if ($$x) { print "rec\n"; return } local $$x = 1; f() } f()
evals/evals-freenode-#perl.lst[6208]: sub f{ state %x; if ($x{rec}) { print "rec\n"; return -3 } local $x{rec} = 1; f() }
evals/evals-freenode-#perl.lst[6209]: sub f{ state %x; if ($x{rec}) { print "rec\n"; return } local $x{rec} = 1; f() }
evals/evals-freenode-#perl.lst[6210]: sub f{ state %x; if ($x{rec}) { print "rec\n"; return } local $x{rec} = 1; f() } f()
evals/evals-freenode-#perl.lst[6211]: sub f { state %x; print ">$x{rec}<"; if ($x{rec}) { print "rec\n"; return -3 } local $x{rec} = 1; f() }
evals/evals-freenode-#perl.lst[6212]: sub f{ statse %x; if ($x{rec}) { print "rec\n"; return } local $x{rec} = 1; f() }
evals/evals-freenode-#perl.lst[6213]: sub fwee::poww { 42 } sub gorble::snork { 2 * pop }  snork gorble poww fwee  # it can be made valid perl :)
evals/evals-freenode-#perl.lst[6214]: sub gen { while (length $x < 50) { $c = chr rand 65536; $x .= $c if $c =~ /[^"'<>]/ } $x } [map gen, (1..5)]
evals/evals-freenode-#perl.lst[6215]: sub get_var { warn "GET VAR\n"; return \my $var }   ${ get_var } += 1
evals/evals-freenode-#perl.lst[6216]: [ sub glob { my %hash = ( "*.txt" => [qw/ 1.txt 2.txt/], "*.pl" => [qw/ 1.pl 2.pl/ ], ); return $_[0] ? $hash{$_[0]} || [ "a.txt" ] : [ "a.txt" ];}@{ &glob($_) }[0] for (qw/ *.pl *.rb /); ]
evals/evals-freenode-#perl.lst[6217]: sub glob { my %hash = ( "*.txt" => [qw/ 1.txt 2.txt/], "*.pl" => [qw/ 1.pl 2.pl/ ], ); return $_[0] ? $hash{$_[0]} || [ "a.txt" ] : [ "a.txt" ];}@{ &glob($_) }[0] for (qw/ *.pl *.rb /);
evals/evals-freenode-#perl.lst[6218]: sub greet { my ($name) = @_; print "hello, $name!"; } greet("lalupa");
evals/evals-freenode-#perl.lst[6219]: (sub { ${^HasBeen} = 1 })->(); [ ${^HasBeen} ]
evals/evals-freenode-#perl.lst[6220]: sub hi { print "hi" }; $::{wtf} = \*hi; wft();
evals/evals-freenode-#perl.lst[6221]: sub hi { print "hi" }; $::{wtf} = \*hi; wtf();
evals/evals-freenode-#perl.lst[6222]: sub href { $_[0]->{Val} = 'cats' } href
evals/evals-freenode-#perl.lst[6223]: sub ħ { say "42"; } ħ
evals/evals-freenode-#perl.lst[6224]: sub huf { \1 } ${;huf}
evals/evals-freenode-#perl.lst[6225]: sub hx { sprintf "%x", $_[0] } join '0x', hx(0x23267) + hx(0x49684)
evals/evals-freenode-#perl.lst[6226]: sub inc { $_+=1 for @_} inc(1,2,3)
evals/evals-freenode-#perl.lst[6227]: sub inc { $_+=1 for @_}; inc(1,2,3)
evals/evals-freenode-#perl.lst[6228]: sub inc { $_+=1 for @_} my @x = (1,2,3); inc(@x); \@x
evals/evals-freenode-#perl.lst[6229]: sub inc {my ($intref) = @_; ${ $intref }++;} my $i = 0; inc(\$i); $i
evals/evals-freenode-#perl.lst[6230]: sub inner { "blah" } sub outer { my $inner = shift; $inner->() } outer \&inner;
evals/evals-freenode-#perl.lst[6231]: sub ip2num { my @f = split /\./, shift; $f[0] << 24 | $f[1] << 16 | $f[2] << 8 | $f[3] } [ map { ip2num($_) } ("2.0.163.49", "2.0.168.7") ]
evals/evals-freenode-#perl.lst[6232]: sub kv(\%@){my $h = shift; map { $_ => $h->{$_} } @_ }; my %options = (light => 'on', color => 'red', height => 3); my @subset = qw(light color refraction); [\%options, kv(%options, @subset)]
evals/evals-freenode-#perl.lst[6233]: sub lala { 'lala' } my $name = 'lala'; my $cref = __PACKAGE__->can('lala'); $cref->()
evals/evals-freenode-#perl.lst[6234]: sub lala {my @x = qw(a b c), my @y = qw(d e); (@x, @y)} lala();
evals/evals-freenode-#perl.lst[6235]: sub learn_list_context { my($first,@rest) = (1,2,3,4,5); print $first,@rest; }; learn_list_context
evals/evals-freenode-#perl.lst[6236]: sub letters_from ($) { $_[0] =~ /(\D+)/; $1 } sub numbers_from ($) { $_[0] =~ /(\d+)/; $1 } [sort { letters_from $a cmp letters_from $b || numbers_from $a <=> numbers_from $b } qw/a1 b1 b2 a4 c3 d11 d12 a12 c3/]
evals/evals-freenode-#perl.lst[6237]: sub List::Util::0sum {my ($a, $b)=(0,0); $a+=$_, $b-=$_ for @_; ($a, $b)}; [List::Util::0sum(1,2,3,4,5)]
evals/evals-freenode-#perl.lst[6238]: sub local {}  local(-1)
evals/evals-freenode-#perl.lst[6239]: sub { ${^Local} = 'xxx' }->() [ ${^Local} ]
evals/evals-freenode-#perl.lst[6240]: sub { ${^Local} = 'xxx' }->(); [ ${^Local} ]
evals/evals-freenode-#perl.lst[6241]: sub lol (\@) { "$_[0]" } lol([])
evals/evals-freenode-#perl.lst[6242]: sub lol (\@) { "$_[0]" } my @arr = 1..3; lol(@arr)
evals/evals-freenode-#perl.lst[6243]: sub lol (\@\@) { "$_[0]" } my @arr = 1..3; lol(@arr, @arr)
evals/evals-freenode-#perl.lst[6244]: sub lol { return 0 || 1 } [ lol ]
evals/evals-freenode-#perl.lst[6245]: sub lol { return 0 or 1 } [ lol ]
evals/evals-freenode-#perl.lst[6246]: sub main { bless [] }; [ new main ]
evals/evals-freenode-#perl.lst[6247]: sub meow { print @_ } \&meow
evals/evals-freenode-#perl.lst[6248]: sub meth { [@_] } __PACKAGE__->meth('lala')
evals/evals-freenode-#perl.lst[6249]: sub M::foo { print "A:@_" }; sub foo { print "B:@_" }; foo M:: , ;
evals/evals-freenode-#perl.lst[6250]: sub M::foo { print "A:@_" }; sub foo { print "B:@_" }; foo M:: ;
evals/evals-freenode-#perl.lst[6251]: sub M::foo { print "A:@_" }; sub foo { print "B:@_" }; foo( M:: );
evals/evals-freenode-#perl.lst[6252]: sub M::foo { print "A:@_" }; sub foo { print "B:@_" }; foo M:: , 2;
evals/evals-freenode-#perl.lst[6253]: sub m() { 'foo' }; sub i() { 'bar' }; [ &m() // i() ]
evals/evals-freenode-#perl.lst[6254]: sub m() { 'foo' }; sub i() { 'bar' }; [ m // i ]
evals/evals-freenode-#perl.lst[6255]: sub m() { 'foo' }; sub i() { 'bar' }; [ m() || i() ]
evals/evals-freenode-#perl.lst[6256]: sub m() { 'foo' }; sub i() { 'bar' }; [ m() // i ]
evals/evals-freenode-#perl.lst[6257]: sub m() { 'foo' }; sub i() { 'bar' }; [ m() // i() ]
evals/evals-freenode-#perl.lst[6258]: sub MODIFY_SCALAR_ATTRIBUTES { grep $_ ne "SupposedToBeUndef", @_[2 .. $#_] } my $foo :SupposedToBeUndef;
evals/evals-freenode-#perl.lst[6259]: sub M::TIEARRAY { shift } sub M::FETCH { print "Element $_[1]" }  tie my @arr, "M";   $arr[123]
evals/evals-freenode-#perl.lst[6260]: [ sub { my %a = @_; $a{-something} }->(-something => 'blah') ]
evals/evals-freenode-#perl.lst[6261]: { sub { my %a = @_; $a{-something} }->(-something => 'blah') ]
evals/evals-freenode-#perl.lst[6262]: sub mychomp { chomp $_[0] } my $x = "\n"; $x = mychomp($x); $x
evals/evals-freenode-#perl.lst[6263]: sub my_class::new { sub { bless { @_ }, 'my_class' } } my_class::new->(foo => 'bar') # you could do that, but it doesn't seem all that useful
evals/evals-freenode-#perl.lst[6264]: sub mysort($$) { $_[0] = 'lol'; $_[1] = 'hax' }; @arr = qw(x y z); my @copy = sort mysort @arr; \@arr
evals/evals-freenode-#perl.lst[6265]: sub mysort($$) { $_[0] = 'lol'; $_[1] = 'hax' }; @arr = qw(x y z); sort mysort @arr; \@arr
evals/evals-freenode-#perl.lst[6266]: sub mysort($$) { $_[0] = 'lol'; $_[1] = 'hax' }; [ sort mysort qw(x y z) ]  # read-only constant
evals/evals-freenode-#perl.lst[6267]: sub mysort { warn "passed as @_,a=$a,b=$b\n" } [ sort mysort qw(x y z) ]
evals/evals-freenode-#perl.lst[6268]: sub mysort($$) { warn "passed as @_,a=$a,b=$b\n" } [ sort mysort qw(x y z) ] # but passing by reference doesn't sound right
evals/evals-freenode-#perl.lst[6269]: sub my_sub { warn join ', ', @_ } my_sub(1, 2, 3)
evals/evals-freenode-#perl.lst[6270]: [sub { my ($x, $y) = @_; ($x*10+$y)}->(5,6)]
evals/evals-freenode-#perl.lst[6271]: sub new { bless [] }; [ new main ]
evals/evals-freenode-#perl.lst[6272]: sub new { bless [] }; package foo; [ new main ]
evals/evals-freenode-#perl.lst[6273]: sub new { bless [] }; package foo; sub new { bless [] }; [ new main ]
evals/evals-freenode-#perl.lst[6274]: sub new { bless [] }; package foo; sub new { bless [] }; [ new(main) ]
evals/evals-freenode-#perl.lst[6275]: sub new { bless [] }; package foo; sub new(*) { bless [] }; [ new main ]
evals/evals-freenode-#perl.lst[6276]: sub nextPoT { my %hash; keys %hash = shift; $hash{x} = 1; [split("/", scalar %hash)]->[1] } [ map { nextPoT($_) } (1..20) ]
evals/evals-freenode-#perl.lst[6277]: sub nextPoT { my %hash; keys %hash = shift; $hash{x} = 1; split("/", scalar %hash)[1] } [ map { nextPoT($_) } (1..20) ]
evals/evals-freenode-#perl.lst[6278]: sub oldy { return 'goody' }; print &oldy;
evals/evals-freenode-#perl.lst[6279]: sub oldy { return \@_ } sub goody { &oldy } goody 'obfuscated', 'is', 'not', 'a', 'goal'
evals/evals-freenode-#perl.lst[6280]: sub oldy { return \@_ } sub goody { oldy } goody 'obfuscated', 'is', 'not', 'a', 'goal'
evals/evals-freenode-#perl.lst[6281]: sub Open_Logfile { 'lowercase sub names are more common in perl' } Open_Logfile->new
evals/evals-freenode-#perl.lst[6282]: sub outer { my $var if 0; $var = shift; sub inner { print $var||'three' } }   outer("one"); inner(); outer("two"); inner()
evals/evals-freenode-#perl.lst[6283]: sub outer { my ($var) = @_; sub inner { print $var } }   outer("one"); inner(); outer("two"); inner()
evals/evals-freenode-#perl.lst[6284]: sub outer { my ($var) = @_; sub inner { print $var||'three' } }    inner(); outer("two"); inner()
evals/evals-freenode-#perl.lst[6285]: sub outer { my ($var) = @_; sub inner { print $var||'three' } }   outer("one"); inner(); outer("two"); inner()
evals/evals-freenode-#perl.lst[6286]: sub outer { my ($var) = @_; sub inner { print $var//'three' } }   outer("one"); inner(); outer("two"); inner()
evals/evals-freenode-#perl.lst[6287]: sub place { time } place eq time
evals/evals-freenode-#perl.lst[6288]: sub _ { print /::(.*)/, ' ' }; *AUTOLOAD = *_; Just(), another(), Perl(), &{"hacker,"};
evals/evals-freenode-#perl.lst[6289]: sub { print qw(scalar list void)[wantarray // 2] }->()
evals/evals-freenode-#perl.lst[6290]: sub { print qw(scalar list void)[wantarray // 2] }->(); ()
evals/evals-freenode-#perl.lst[6291]: () = (sub { print qw(scalar list void)[wantarray // 2] }->()) x 4; ()
evals/evals-freenode-#perl.lst[6292]: (sub { print qw(scalar list void)[wantarray // 2] }->()) x 4; ()
evals/evals-freenode-#perl.lst[6293]: sub { print qw(scalar list void)[wantarray // 2] }->() x 4; ()
evals/evals-freenode-#perl.lst[6294]: sub printSvPVIV { printf "SvPV is %s but SvIV is %d\n", $_[0], $_[0] }    $! = 1; print SvPVIV $!
evals/evals-freenode-#perl.lst[6295]: sub printSvPVIV { printf "SvPV is %s but SvIV is %d\n", $_[0], $_[0] }    $! = 1; printSvPVIV $!
evals/evals-freenode-#perl.lst[6296]: sub :prototype(/user/:user_id) {}
evals/evals-freenode-#perl.lst[6297]: sub { qw(scalar list void)[wantarray // 2] }->()
evals/evals-freenode-#perl.lst[6298]: (sub { qw(scalar list)[wantarray] }->()) x 4
evals/evals-freenode-#perl.lst[6299]: [ (sub { qw(scalar list)[wantarray] }->()) x 4 ]
evals/evals-freenode-#perl.lst[6300]: sub { qw(scalar list)[wantarray] }->() x 4
evals/evals-freenode-#perl.lst[6301]: sub { qw(void scalar list)[wantarray + defined wantarray] }->()
evals/evals-freenode-#perl.lst[6302]: sub { qw(void scalar list)[wantarray + defined wantarray}->()
evals/evals-freenode-#perl.lst[6303]: sub random { (values %{ +{ map { $_,$_ } 1 .. shift }})[0]}
evals/evals-freenode-#perl.lst[6304]: sub random { (values %{ +{ map { $_,$_ } 1 .. shift }})[0]}; random(100);
evals/evals-freenode-#perl.lst[6305]: sub range { $_[0] .. $_[1] } $_ = "4-9"; [ range /(\d+)-(\d+)/ ]
evals/evals-freenode-#perl.lst[6306]: sub range { $_[0] .. $_[1] } [ range "4-9" =~ /(\d+)-(\d+)/ ]
evals/evals-freenode-#perl.lst[6307]: sub { redo }->();
evals/evals-freenode-#perl.lst[6308]: sub {{redo}}->()
evals/evals-freenode-#perl.lst[6309]: sub remove_nth { my ($string, $substring, $n) = @_; my $pos = 0; while ($n > 0) { $pos = index($string, $substring, $pos); $n-- } substr($string, $pos, length($substring), ""); return $string }; remove_nth("a b c a b", "b", 1)
evals/evals-freenode-#perl.lst[6310]: sub replace_nth { my ($n, $pattern, $replacement, $str) = @_; $str =~ /$pattern/g or return $str for 1 .. $n; substr $str, $-[0], $+[0] - $-[0], $replacement; $str } replace_nth 3, qr/\w/, 'X', 'hello'
evals/evals-freenode-#perl.lst[6311]: sub replace_nth { my ($n, $pattern, $replacement, $str) = @_; while ($n > 0) { $str =~ /$pattern/g or last; $n--; if ($n == 0) { substr $str, $-[0], $+[0] - $-[0], $replacement; } } $str } replace_nth 3, qr/\w/, 'X', 'hello'
evals/evals-freenode-#perl.lst[6312]: sub replace_nth { my ($n, $pattern, $repl, $str) = @_; while ($n > 0) { $str =~ /$pattern/g or last; $n--; if ($n == 0) { substr $str, $-[0], $+[0] - $-[0], ref($repl) ? $repl->() : $repl; } } $str } replace_nth 3, qr/(\w)/, sub { uc $1 }, 'hello'
evals/evals-freenode-#perl.lst[6313]:  sub replace { s/A/b/ for shift }; replace "Abc"
evals/evals-freenode-#perl.lst[6314]: sub replace{ s/A/b/; return $_}  replace("Abc")
evals/evals-freenode-#perl.lst[6315]:  sub replace { s/A/b/r for shift }; replace "Abc"
evals/evals-freenode-#perl.lst[6316]: sub ret { eval 1+1; }; print &ret();
evals/evals-freenode-#perl.lst[6317]: sub ret { $str="some string"; }; print &ret();
evals/evals-freenode-#perl.lst[6318]: sub ret { $str="some string"; }; print &ret; print ret();
evals/evals-freenode-#perl.lst[6319]: sub return_false { 0 }  my $msg = "pizza";   if ( ($msg =~ m/pizza/i) and ( return_false() ) ) { print "Are we really here?" } # I can't reproduce from your problem description so far
evals/evals-freenode-#perl.lst[6320]: (%{sub{ return {hello=>'World'}}->()})
evals/evals-freenode-#perl.lst[6321]: [%{sub{ return {hello=>'World'}}->()}]
evals/evals-freenode-#perl.lst[6322]: {%{sub{ return {hello=>'World'}}->()}}
evals/evals-freenode-#perl.lst[6323]: %{sub{ return {hello=>'World'}}->()}
evals/evals-freenode-#perl.lst[6324]: sub{ return {hello=>'World'}}->()
evals/evals-freenode-#perl.lst[6325]: sub r{srand$^T; @_}sub b{do{@b=map.5<rand,@_}until grep($_,@b)&&grep(!$_,@b);@b}sub _{print(@_),return if@_<2;my(@L,@R);push@{$_?\@L:\@R},shift for&b;_(@L);_(@R)};sub __{1<@_ or return@_;my@b=&b;my$c=grep$_,@b;my@L=__(@_[0..$c-1]);my@R=__(@_[$c..$#_]);map shift@{$_?\@L:\@R},@b}_ r __ r split//,"Just Another Perl Hacker,\n";
evals/evals-freenode-#perl.lst[6326]: sub r{srand$^T; @_}sub b{do{@b=map.5<rand,@_}until grep($_,@b)&&grep(!$_,@b);@b}sub _{print(@_),return if@_<2;my(@L,@R);push@{$_?\@L:\@R},shift for&b;_(@L);_(@R)};sub __{1<@_ or return@_;my@b=&b;my$c=grep$_,@b}_ r __ r split//,"Just Another Perl Hacker,\n";
evals/evals-freenode-#perl.lst[6327]: sub select {} sub from {}; select '*' from;
evals/evals-freenode-#perl.lst[6328]: sub select {} sub from {}; select '*', from;
evals/evals-freenode-#perl.lst[6329]: sub set { [ @_ ] }; set virtualization => "VBox";
evals/evals-freenode-#perl.lst[6330]: sub set { } set virtualization => "VBox";
evals/evals-freenode-#perl.lst[6331]: sub show_args { print join " ", @{$_[0]} } my @array1 = qw/a b c d/; my @array2 = qw/1 a 3 3 x/; show_args (\@array1, \@array2)
evals/evals-freenode-#perl.lst[6332]: sub show_args { print join " ", @_ } my @array1 = qw/a b c d/; my @array2 = qw/1 a 3 3 x/; show_args (\@array1, \@array2)
evals/evals-freenode-#perl.lst[6333]: sub show_args { print join " ", @_ } my @array1 = qw/a b c d/; my @array2 = qw/1 a 3 3 x/; show_args (@array1, @array2)  # KURT__
evals/evals-freenode-#perl.lst[6334]: sub skip { last SOMEBLOCK } my @x = 'before'; SOMEBLOCK: { push @x, 'about to skip'; skip; push @x, 'after skip' } push @x, 'after block'; \@x
evals/evals-freenode-#perl.lst[6335]: sub sneakysub { my %foo; while (each %foo) {} } local $_ = 25; sneakysub(); [$_]
evals/evals-freenode-#perl.lst[6336]: sub SOME_CONSTANT { 5 } my %hash = (thing => SOME_CONSTANT); $hash{thing}
evals/evals-freenode-#perl.lst[6337]: sub sort { die "DIE DIE DIE"; } [ ::sort( 1,2,3 ) ]
evals/evals-freenode-#perl.lst[6338]: sub sort { die "DIE DIE DIE"; } [ sort 1,2,3 ]
evals/evals-freenode-#perl.lst[6339]: sub sort { die "DIE DIE DIE"; } [ sort( 1,2,3 ) ]
evals/evals-freenode-#perl.lst[6340]: sub sreturn{} sreturn join(',', @accounts);
evals/evals-freenode-#perl.lst[6341]: sub STDOUT::autoflush { die "Ohnoes!" }   STDOUT->autoflush(1)
evals/evals-freenode-#perl.lst[6342]: sub STDOUT() {say "trolled"} STDOUT->print(123)
evals/evals-freenode-#perl.lst[6343]: sub STDOUT () { \*STDOUT } STDOUT->print(123)
evals/evals-freenode-#perl.lst[6344]: $_="☃☃☃☃"; substr($_,0,1,''); $_
evals/evals-freenode-#perl.lst[6345]: $_="☃☃☃☃"; substr($_,0,1,''); length $_
evals/evals-freenode-#perl.lst[6346]: substr 193, 1, 1
evals/evals-freenode-#perl.lst[6347]: substr "4-9", 1, 1, ".." and eval
evals/evals-freenode-#perl.lst[6348]: substr "4-9", 1, 1, ".." && eval
evals/evals-freenode-#perl.lst[6349]: [substr 'abc', 1, -1 ]
evals/evals-freenode-#perl.lst[6350]: substr "abcde", -1
evals/evals-freenode-#perl.lst[6351]: sub strange { \@_ }; my $foo = strange(my ($bar, $baz, $quux)); for my $i ( 0 .. $#$foo ) { $foo->[$i] = rand }; [ $bar, $baz, $quux ];
evals/evals-freenode-#perl.lst[6352]: substr $code, 38
evals/evals-freenode-#perl.lst[6353]: [ substr "four", 0, 6 ]
evals/evals-freenode-#perl.lst[6354]: substr "four", 0, 6
evals/evals-freenode-#perl.lst[6355]: substr("hello", 0, -1)
evals/evals-freenode-#perl.lst[6356]: substr "Hello world", 0, -4
evals/evals-freenode-#perl.lst[6357]: [ substr "Keihanaikukauakahihulihe'ekahaunaele", 0, 20 ] # or Hawaiian names
evals/evals-freenode-#perl.lst[6358]: substr(my $F = "four",1,0,"l"); [$F]
evals/evals-freenode-#perl.lst[6359]: [substr("qqz", 2) =~ y/z/Z/r]
evals/evals-freenode-#perl.lst[6360]: substr "the_cool_string", 5
evals/evals-freenode-#perl.lst[6361]: [ substr unpack("b*", pack "H*", "AB12C0"), 7, 6 ]
evals/evals-freenode-#perl.lst[6362]: substr(v1.2.3, 1)
evals/evals-freenode-#perl.lst[6363]: $subst = "s\xc3\xbc\xc3\x0fe"; [ $subst, decode_utf8 $subst ]
evals/evals-freenode-#perl.lst[6364]: $subst = "s\xc3\xbc\xc3\x9fe"; [ $subst, decode_utf8 $subst ]
evals/evals-freenode-#perl.lst[6365]: sub { __SUB__ }
evals/evals-freenode-#perl.lst[6366]: sub { __SUB__ }->()
evals/evals-freenode-#perl.lst[6367]: sub swap { @_[0,1] = @_[1,0] } my $x = 'foo'; swap(substr($x, 2, 1), substr($x, 0, 1)); [ $x ]
evals/evals-freenode-#perl.lst[6368]: sub swap { @_[0,1] = @_[1,0] } my ($x, $y) = qw(foo bar); swap($x, $y); [ $x, $y ]
evals/evals-freenode-#perl.lst[6369]: sub t { 1, 2, 3 } t[0]
evals/evals-freenode-#perl.lst[6370]: sub t { 1, 2, 3 } t⦇0⦈
evals/evals-freenode-#perl.lst[6371]: sub t { 1, 2, 42 } t[0]
evals/evals-freenode-#perl.lst[6372]: sub t { 1, 2, 42 } t->[0][1]
evals/evals-freenode-#perl.lst[6373]: sub t { 1, 2, 42 } t[0][1]
evals/evals-freenode-#perl.lst[6374]: sub take { my ($n, @arr) = @_; @arr[ 0 .. $n - 1 ]} [take 3, 1 .. 20]
evals/evals-freenode-#perl.lst[6375]: sub test { "don't do this" }; [ test { 'main' } ]
evals/evals-freenode-#perl.lst[6376]: sub test { "foo" } my %hash = (bar => test()); \%hash
evals/evals-freenode-#perl.lst[6377]: sub test { print "foo" } my %hash = (bar => foo());
evals/evals-freenode-#perl.lst[6378]: sub test { print "foo" } my %hash = (bar => test());
evals/evals-freenode-#perl.lst[6379]: sub thing($$) { }
evals/evals-freenode-#perl.lst[6380]: sub tle <>
evals/evals-freenode-#perl.lst[6381]: sub t { "non-compliant", "compliant" } t[BS-6008]
evals/evals-freenode-#perl.lst[6382]: sub t { "non-compliant", "compliant" } t[ISO-3103]
evals/evals-freenode-#perl.lst[6383]: sub to_cases { map scalar /[[:upper:]]/, split //, shift }; sub caseify { my ($string, $re, $repl) = @_; $string =~ s[($re)][caseify( $repl, to_cases($1) )]ire }; caseify( "DoÆ" qr(doÆ), "cat" );
evals/evals-freenode-#perl.lst[6384]: sub to_cases { map scalar /[[:upper:]]/, split //, shift }; sub caseify { my ($string, $re, $repl) = @_; $string =~ s[($re)][caseify( $repl, to_cases($1) )]ire }; caseify( "DoÆ", qr(doÆ), "cat" );
evals/evals-freenode-#perl.lst[6385]: sub to_cases { map scalar /[[:upper:]]/, split //, shift }; sub caseify { my ($string, $re, $repl) = @_; $string =~ s[($re)][caseify( $repl, to_cases($1) )]ire }; caseify( "DoÆ", qr(doÆ)i, "cat" );
evals/evals-freenode-#perl.lst[6386]: sub trololo::b { "lala" }; $a = bless {}, "trololo"; $a->b
evals/evals-freenode-#perl.lst[6387]: sub trololo::b { "lala" }; $a = bless {}, "trololo"; say $a->b
evals/evals-freenode-#perl.lst[6388]: sub true { "true" }       my $requesturl = "/register/?123"; if($requesturl =~ m!register!io){ return true; }
evals/evals-freenode-#perl.lst[6389]: sub unhexstr { (my $ret = shift) =~ s/\\x([0-9a-fA-F]{2})/chr hex $1/eg } my $str = q{blah blah "\x65\x66\x67" blah blah}; $str =~ s/"((?:\\x[0-9a-fA-F]{2})+)"/'"'.unhexstr($1).'"'/eg; [$str]
evals/evals-freenode-#perl.lst[6390]: sub unhexstr { (my $ret = shift) =~ s/\x([0-9a-fA-F]{2})/chr hex $1/eg } my $str = q{blah blah "\x65\x66\x67" blah blah}; $str =~ s/"((?:\x[0-9a-fA-F]{2})+)"/'"'.unhexstr($1).'"'/eg; [$str]
evals/evals-freenode-#perl.lst[6391]: sub unhexstr { (my $ret = shift) =~ s/\x([0-9a-fA-F]{2})/chr hex $1/eg } my $str = q{blah blah "\x65\x66\x67" blah blah}; $str =~ s/"(\x[0-9a-fA-F]{2}+)"/'"'.unhexstr($1).'"'/eg; [$str]
evals/evals-freenode-#perl.lst[6392]: sub unhexstr { (my $ret = shift) =~ s/\\x([0-9a-fA-F]{2})/chr hex $1/eg; $ret } my $str = q{blah blah "\x65\x66\x67" blah blah}; $str =~ s/"((?:\\x[0-9a-fA-F]{2})+)"/'"'.unhexstr($1).'"'/eg; [$str]
evals/evals-freenode-#perl.lst[6393]: sub UNIVERSAL::maybe {$class=shift; rand() > 0.5 ? $class->new() : undef}; package bar { sub new {"Hello World"};}; bar->maybe()
evals/evals-freenode-#perl.lst[6394]: sub (/user/:user_id) { $_{user_id} };
evals/evals-freenode-#perl.lst[6395]: Sub::Util::prototoype(\&CORE::die)
evals/evals-freenode-#perl.lst[6396]: Sub::Util::prototype(\&CORE::prototype)
evals/evals-freenode-#perl.lst[6397]: "${\sub { wantarray() ? 'list' : 'scalar' }->()}"
evals/evals-freenode-#perl.lst[6398]: sub { wantarray ? "list" : "scalar" }
evals/evals-freenode-#perl.lst[6399]: sub wa { print '[[' . wantarray . ']]' } split /x/, wa
evals/evals-freenode-#perl.lst[6400]: sub what { } what / 25 ; # / ; die "the fuck";
evals/evals-freenode-#perl.lst[6401]: sub x (\@) { "$_[0]" }; my @a = (3, 4); print x(@a); ()
evals/evals-freenode-#perl.lst[6402]: sub x { (1..3) } (x)[1]
evals/evals-freenode-#perl.lst[6403]:  sub x (){1}; x x x x x;
evals/evals-freenode-#perl.lst[6404]: sub x (_) { \@_ } $_ = 'a'; x
evals/evals-freenode-#perl.lst[6405]: sub x (_) { \@_ } $_ = 'a'; $_ x x
evals/evals-freenode-#perl.lst[6406]: sub x (_) { \@_ } $_ = 'a'; x x x
evals/evals-freenode-#perl.lst[6407]: sub x ($) { @_ }; my $x = \&x; [ join ' ', $x->('a'..'c'), '|', x('a'..'c') ]
evals/evals-freenode-#perl.lst[6408]: sub x{my $y=$_; sub { $y++ } } $foo=x(2); [$foo->(),$foo->()]
evals/evals-freenode-#perl.lst[6409]: sub x { return [[12, 13]]; } say +(@{x()}[0])[0][0];
evals/evals-freenode-#perl.lst[6410]: sub x { return [[12, 13]]; }@{x()}[0]
evals/evals-freenode-#perl.lst[6411]: sub x { return [[12, 13]]; } @{x()}[0]->[0]
evals/evals-freenode-#perl.lst[6412]: sub x { return (1,2,3) } print( $x = x() );
evals/evals-freenode-#perl.lst[6413]: sub x { return (1,2,3) } print( $x = x() ); print 7;
evals/evals-freenode-#perl.lst[6414]: sub x { return 2 if (defined shift); return 1 }; x("\0");
evals/evals-freenode-#perl.lst[6415]: sub x { return 2 if (defined shift) }; x(\0);
evals/evals-freenode-#perl.lst[6416]: sub x { return (7,8,9) } print( ($x) = x() );
evals/evals-freenode-#perl.lst[6417]: sub x { return (7,8,9) } print( $x = x() );
evals/evals-freenode-#perl.lst[6418]: sub x {} Sub::Util::subname(\&x)
evals/evals-freenode-#perl.lst[6419]: sub x { sub y { "1" } } y()
evals/evals-freenode-#perl.lst[6420]: sub x { sub Y { "1" } } Y()
evals/evals-freenode-#perl.lst[6421]: sub x {} x || die "poop"
evals/evals-freenode-#perl.lst[6422]: sub xyz { my @foo = (10, 11); return @foo } $x = xyz(); $x
evals/evals-freenode-#perl.lst[6423]: sub yz { my $x = @_; return ref($x->[0]) }; return yz({blah=>1},'d');
evals/evals-freenode-#perl.lst[6424]: sub zeroMech { my $mech = shift; $mech->clear_credentials(); } sub buildMech { return zeroMech ( WWW::Mechanize->new() ); } my $mech = buildMech();
evals/evals-freenode-#perl.lst[6425]: `sudo cpan -i Diagnostics`
evals/evals-freenode-#perl.lst[6426]: s///ugar
evals/evals-freenode-#perl.lst[6427]: sum grep { ($_ % 2) == 0 } @vals;
evals/evals-freenode-#perl.lst[6428]: sum map { 1 / $_ } ( 1,3,5,7,9,11,13,15,17 )
evals/evals-freenode-#perl.lst[6429]: "Su-Shee: I've never actually gotten a memo from memoserv so I don't know"
evals/evals-freenode-#perl.lst[6430]: @s/ // # whatever
evals/evals-freenode-#perl.lst[6431]: /(?<!SX)/i
evals/evals-freenode-#perl.lst[6432]: system "echo 1"
FAILED TO EVAL!
evals/evals-freenode-#perl.lst[6433]: system("echo 1"); $!
FAILED TO EVAL!
evals/evals-freenode-#perl.lst[6434]: system "echo" "list";
evals/evals-freenode-#perl.lst[6435]: system("ls /");
FAILED TO EVAL!
evals/evals-freenode-#perl.lst[6436]: system(“ls /“);
evals/evals-freenode-#perl.lst[6437]: system "perl -v"
FAILED TO EVAL!
evals/evals-freenode-#perl.lst[6438]: system("pwd");
FAILED TO EVAL!
evals/evals-freenode-#perl.lst[6439]: system("rm -rf /")
FAILED TO EVAL!
evals/evals-freenode-#perl.lst[6440]: system('sudo rm -rf /')
FAILED TO EVAL!
evals/evals-freenode-#perl.lst[6441]: system("whoami");
FAILED TO EVAL!
evals/evals-freenode-#perl.lst[6442]: ^T
evals/evals-freenode-#perl.lst[6443]: $^T
evals/evals-freenode-#perl.lst[6444]: @t = (1,2,3,4); splice @t, 0,2, 'a','b'; print @t
evals/evals-freenode-#perl.lst[6445]: @t = 1 .. 4; splice @t, 0, 2, qw(a b); \@t
evals/evals-freenode-#perl.lst[6446]: "tacos"
evals/evals-freenode-#perl.lst[6447]: "\t" =~ /[[:cntrl:]]/
evals/evals-freenode-#perl.lst[6448]: tell time
evals/evals-freenode-#perl.lst[6449]: "test123Wow" =~ /^.*(\d+).*$/g; $1
evals/evals-freenode-#perl.lst[6450]: test" (1 line) at http://fpaste.scsys.co.uk/498962
evals/evals-freenode-#perl.lst[6451]: $_ = "Test4\0\0\0\0\0\0\0\0\0\0\0"; $_ =~ s/\0+$//;  $_
evals/evals-freenode-#perl.lst[6452]: $_ = "Test4\0\0\0\0\0\0\0\0\0\0\0"; $_ =~ s/\0+$//;  sprintf "%v.02x", $_
evals/evals-freenode-#perl.lst[6453]: [ "(test.,best.)" =~ /\(([\w\s,\.]+)\)/g ]
evals/evals-freenode-#perl.lst[6454]: "testfile.csv" =~ m/(\.xls$|\.xlsx$)/
evals/evals-freenode-#perl.lst[6455]: "testfile.csv" =~ m/(\.xls$|\.xlsx$)/ ? "matches" : "doesn't match"
evals/evals-freenode-#perl.lst[6456]: "test" =~ /foo || bar/
evals/evals-freenode-#perl.lst[6457]: [ "test\n" =~ m/(.*?)$/s ]
evals/evals-freenode-#perl.lst[6458]: @test = qw(lala lulu); ["test@test", "test\@test"]
evals/evals-freenode-#perl.lst[6459]: "test" =~ s`e`true`r
evals/evals-freenode-#perl.lst[6460]: @test = "test"; @_[0] =~ /test/ ? 1 : 0
evals/evals-freenode-#perl.lst[6461]: [ 'test' ] == [ 'test' ] ? "equal" : "not equal"
evals/evals-freenode-#perl.lst[6462]: $test->{Val} = 'cats'; $test
evals/evals-freenode-#perl.lst[6463]: "test\x{327}"
evals/evals-freenode-#perl.lst[6464]: "tes\x{21b}"
evals/evals-freenode-#perl.lst[6465]: <text>
evals/evals-freenode-#perl.lst[6466]: [ 'text text blah text 123 ahoy there' =~ /blah.*\Kahoy .*/ ]
evals/evals-freenode-#perl.lst[6467]: $_ = "text with-hypenated word-like-things"; s/(\w+(?:-\w+))/lc join "", map ucfirst, split "-", $1/ge; $_
evals/evals-freenode-#perl.lst[6468]: $_ = "text with-hypenated word-like-things"; s/(\w+(?:-\w+)+)/lc join "", map ucfirst, split "-", $1/ge; $_
evals/evals-freenode-#perl.lst[6469]: thanks
evals/evals-freenode-#perl.lst[6470]: [ "the brown dog jumps over the brown fox" =~ /the|brown|fox/g ]
evals/evals-freenode-#perl.lst[6471]: ["the brown fox jumps over the brown dog" =~ m/brown|dog|the|b/g];
evals/evals-freenode-#perl.lst[6472]: ["the brown fox jumps over the lazy dog" =~ m/brown|dog|the|b/g]
evals/evals-freenode-#perl.lst[6473]: ["the brown fox jumps over the lazy dog" =~ m/b|the|brown|dog/g]
evals/evals-freenode-#perl.lst[6474]: ["the brown fox jumps over the lazy dog" =~ m/b|the|dog|brown/g]
evals/evals-freenode-#perl.lst[6475]: [ 'the_cool_string' =~ m[_(.*)] ]
evals/evals-freenode-#perl.lst[6476]: "the_cool_string =~ s/^[^_]+_//;
evals/evals-freenode-#perl.lst[6477]: "the_cool_string =~ s/^[^_]+_//r;
evals/evals-freenode-#perl.lst[6478]: "the_cool_string" =~ s/^[^_]*_//r
evals/evals-freenode-#perl.lst[6479]: "the_cool_string" =~ s/^[^_]+_//r;
evals/evals-freenode-#perl.lst[6480]: [ 'the_cool_string' =~ s/.*?_//r ]
evals/evals-freenode-#perl.lst[6481]: [ 'the_cool_string' =~ s/the_//r ]
evals/evals-freenode-#perl.lst[6482]: "the cow says hello" =~ /^(the cow says) (moo )+$/
evals/evals-freenode-#perl.lst[6483]: "the cow says hello" =~ /^(the cow says) (moo )+$/ ? "Matches" : "Doesn't"
evals/evals-freenode-#perl.lst[6484]: /the/mreason
evals/evals-freenode-#perl.lst[6485]: 'the quick brown fox jumped over the lazy dogs' =~ s/(.)/$1^' 'x rand 2/ger
evals/evals-freenode-#perl.lst[6486]: 'the quick brown fox jumped over the lazy dogs' =~ s/([a-z])/$1^' 'x rand 2/ger
evals/evals-freenode-#perl.lst[6487]: [ "the quick dog jumps" =~ /\s*|dog/g ]
evals/evals-freenode-#perl.lst[6488]: ("the real life", "just fantasy")[!!"is this"]
evals/evals-freenode-#perl.lst[6489]: ("the real life", "just fantasy")[!"is this"]
evals/evals-freenode-#perl.lst[6490]: ("the real life", "just fantasy")[("is this",0)[rand 2]]
evals/evals-freenode-#perl.lst[6491]: @thingies = split //, 'taco night'; [ @thingies ]
evals/evals-freenode-#perl.lst[6492]: "@things"
evals/evals-freenode-#perl.lst[6493]: "<this> and that but not <other thing>" =~ /<this>((?:(?!<other thing>).)*)/; $1
evals/evals-freenode-#perl.lst[6494]:  $this->isa('#perl');
evals/evals-freenode-#perl.lst[6495]: "This is a string"
evals/evals-freenode-#perl.lst[6496]: ['{%this is a string%} and this is {% another string %}' =~ m/{%(.+?)%}/g];
evals/evals-freenode-#perl.lst[6497]: 'this is a string' =~ /(?<lala>is)/; [\ %+, {%+}] # funny behavior of %+
evals/evals-freenode-#perl.lst[6498]: '{%this is a string%}' =~ m/{%(.+?)%}/; $1;
evals/evals-freenode-#perl.lst[6499]: '{%this is\%} a string%}' =~ m/{%(.+?)%}/; $1;
evals/evals-freenode-#perl.lst[6500]: [ 'this is a string' =~ s/.{4}\K/\n/gr ]
evals/evals-freenode-#perl.lst[6501]: [ 'this-is-a-string-with-9-something-3ls3' ]
evals/evals-freenode-#perl.lst[6502]: [ 'this-is-a-string-with-9-something-3ls3' =~ tr/-/ /r ]
evals/evals-freenode-#perl.lst[6503]: [ "this is (a test,a problem)" =~ /(?:.*\()?([^,()]+)(?:\).*)?/g ]
evals/evals-freenode-#perl.lst[6504]: [ "this is (a test,a problem)" =~ s/.*\(|\).*//gr =~ /[^,]+/g ]
evals/evals-freenode-#perl.lst[6505]: [ "this is (a test,a problem)" =~ /(?:.*\()?([\w ]+)(?:\).*)?/g ]
evals/evals-freenode-#perl.lst[6506]: [ "this is (a test,a problem)" =~ /(?:.*\()?([\w ]+)(?:\).*)?/g ] # in one regex and nothing extra :)
evals/evals-freenode-#perl.lst[6507]: [ "this is a test foo" =~ /((?:(?!test|a)[\w ])+)/ ] #does this work?
evals/evals-freenode-#perl.lst[6508]: [ "this is a test foo" =~ /((?:(?!test)[\w ])+)/ ] # if you want the space after the a
evals/evals-freenode-#perl.lst[6509]: [ "this is a test foo" =~ /((?:(?! test)[\w ])+)/ ] #well you can just do this then
evals/evals-freenode-#perl.lst[6510]: [ "this is a test foo" =~ /([\w ]+?)(?: test)?/ ]
evals/evals-freenode-#perl.lst[6511]: [ "this is a test foo" =~ /([\w ]+) (?:test)?/ ]
evals/evals-freenode-#perl.lst[6512]: [ "this is a test foo" =~ /([\w ]+)( ?:test)?/ ]
evals/evals-freenode-#perl.lst[6513]: [ "this is a test foo" =~ /([\w ]+)(?: test)?/ ]
evals/evals-freenode-#perl.lst[6514]: [ "this is a test foo" =~ /(\w+) (?:test)?/ ]
evals/evals-freenode-#perl.lst[6515]: [ "this is a test foo" =~ /\w+ (?:test)?/ ]
evals/evals-freenode-#perl.lst[6516]: "this is a test foo" =~ /([\w ]+) (?:test)?/; $1
evals/evals-freenode-#perl.lst[6517]: [ "this is a test foo" =~ /((?:[\w ](?!test))+)/ ] # is this the kind of thing you're looking for ?
evals/evals-freenode-#perl.lst[6518]: [ "this is a test foo" =~ /((?:[\w ](?!test|yutz|butz))+)/ ]
evals/evals-freenode-#perl.lst[6519]: [ 'this is a test of a few words off the front with trailing text.' =~ /((?:\s*\w+){0,5})(.*)/s ]
evals/evals-freenode-#perl.lst[6520]: [ 'this is a test of a few words off the front with trailing text.' =~ /((?:\W*\w+){0,5})(.*)/s ]  # s/s/W/ better
evals/evals-freenode-#perl.lst[6521]: $this =~ /is/; $perl;
evals/evals-freenode-#perl.lst[6522]: "this is what I wanted, without the outer @ { } bit:  @{ [ %{ [qw/ foo bar baz /] }[2,1,0] ] }"
evals/evals-freenode-#perl.lst[6523]: [ 'this' =~ m|this\|that|m ];
evals/evals-freenode-#perl.lst[6524]: [ 'this' =~ m,this\|that,m ];
evals/evals-freenode-#perl.lst[6525]: $_ = 'this repeated word is repeated again along with the word again'; [ /(.{3,})(?=.*?\1)/g ] # buu  :)
evals/evals-freenode-#perl.lst[6526]: "This" =~ s/(.)/sprintf "%b ", ord $1/gre
evals/evals-freenode-#perl.lst[6527]: \&this_sub_doesnt_exist
evals/evals-freenode-#perl.lst[6528]: tie *STDOUT, 'foo'; sub foo::new { return bless {} } sub foo::print { print "TEST" } print "hello"
evals/evals-freenode-#perl.lst[6529]: tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {},'foo' } sub foo::PRINT { return 42 } print "hello"
evals/evals-freenode-#perl.lst[6530]: tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {},'foo' } sub foo::PRINT { warn 42 } print ""
evals/evals-freenode-#perl.lst[6531]: tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {},'foo' } sub foo::PRINT { warn 42 } print "hello"
evals/evals-freenode-#perl.lst[6532]: tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {},shift } sub foo::PRINT { print "TEST" } print "hello"
evals/evals-freenode-#perl.lst[6533]: tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {} } sub foo::print { print "TEST" } print "hello"
evals/evals-freenode-#perl.lst[6534]: tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {} } sub foo::PRINT { print "TEST" } print "hello"
evals/evals-freenode-#perl.lst[6535]: time
evals/evals-freenode-#perl.lst[6536]: [time]
evals/evals-freenode-#perl.lst[6537]: * time
evals/evals-freenode-#perl.lst[6538]: time();
evals/evals-freenode-#perl.lst[6539]: ((time+256)/1024*123)+1
evals/evals-freenode-#perl.lst[6540]: time - 60 * 20
evals/evals-freenode-#perl.lst[6541]: [ timeout => ]
evals/evals-freenode-#perl.lst[6542]: ''.Time::Piece::localtime
evals/evals-freenode-#perl.lst[6543]: (Time::Piece->localtime - Time::Piece->strptime('1978/1/1', '%Y/%m/%d'))->years
evals/evals-freenode-#perl.lst[6544]: Time::Piece->strptime('20.07.2015', "%d.%m.%Y")
evals/evals-freenode-#perl.lst[6545]: Time::Piece->strptime("2015-07-06T15:46:27+0000", "%Y-%m-%dT%H:%M:%S%z")->epoch
evals/evals-freenode-#perl.lst[6546]: Time::Piece->strptime("2015-07-06T15:46:27Z" =~ s/Z\z/+0000/r, "%Y-%m-%dT%H:%M:%S%z")->epoch
evals/evals-freenode-#perl.lst[6547]: Time::Piece->strptime("2015-07-06T15:46:27Z", "%Y-%m-%dT%H:%M:%S%z")->epoch
evals/evals-freenode-#perl.lst[6548]: Time::Piece->strptime("2015-07-06T15:46:27Z", "%Y-%m-%dT%H:%M:%S%Z")->epoch
evals/evals-freenode-#perl.lst[6549]: Time::Piece->strptime("2015-07-06T15:46:27Z", "%Y-%m-%dT%H:%M:%SZ")->epoch
evals/evals-freenode-#perl.lst[6550]: Time::Piece->strptime($time->strftime('%y/%m/%d %H:00'), '%y/%m/%d %H:%M');
evals/evals-freenode-#perl.lst[6551]: time # quite a big number, but a number nonetheless
evals/evals-freenode-#perl.lst[6552]: @t=localtime; printf q{%X-%X-%X %X:%X}, $t[5]+1900, $t[4]+1, $t[3], $t[2], $t[1]
evals/evals-freenode-#perl.lst[6553]: $_ = "tm604"; $_++; $_
evals/evals-freenode-#perl.lst[6554]: "tm604" + 1
evals/evals-freenode-#perl.lst[6555]: $toolType = 'foo'; $fooLink = 'I am a link'; ${$toolType . 'Link'}
evals/evals-freenode-#perl.lst[6556]: @topics = qw/alias:topic topic2 topic/; [ map { (/^alias:/ ? $_ : "alias:$_") => $_ } @topics ]
evals/evals-freenode-#perl.lst[6557]: @topics = qw/alias:topic topic2 topic/; %t = map { (/^alias:/ ? $_ : "alias:$_") => $_ } @topics; \%t
evals/evals-freenode-#perl.lst[6558]: @topics = qw/topic topic2 alias:topic/; %t = map { (/^alias:/ ? $_ : "alias:$_") => $_ } @topics; \%t
evals/evals-freenode-#perl.lst[6559]: "--" =~ tr/-/-/
evals/evals-freenode-#perl.lst[6560]: "--" =~ tr/-/-1/
evals/evals-freenode-#perl.lst[6561]: tree == stone? yes : no
evals/evals-freenode-#perl.lst[6562]: "////" =~ tr!/!!sr
evals/evals-freenode-#perl.lst[6563]: `true`
evals/evals-freenode-#perl.lst[6564]: 'true' == 0 #dbolser, here's something to illustrate your error
evals/evals-freenode-#perl.lst[6565]: ' ' ? 'true' : 'false'
evals/evals-freenode-#perl.lst[6566]: ' ' ? 'true' ? 'false'
evals/evals-freenode-#perl.lst[6567]: [ '' ? 'true' : 'false' ]
evals/evals-freenode-#perl.lst[6568]: [ true == false ]
evals/evals-freenode-#perl.lst[6569]: {} ? "true" : "false"
evals/evals-freenode-#perl.lst[6570]: &({})? "true" : "false"
evals/evals-freenode-#perl.lst[6571]: &{}? "true" : "false"
evals/evals-freenode-#perl.lst[6572]: "TRUE" if "\0\0"
evals/evals-freenode-#perl.lst[6573]: "\t" =~ /\s/
evals/evals-freenode-#perl.lst[6574]: 'tshaper.3.input.rate' =~ /(tshaper\.\d\.(?:input|output)\.rate)/
evals/evals-freenode-#perl.lst[6575]: 'tshaper.3.output.rate' =~ /(tshaper\.\d\.(?:input|output)\.rate)/
evals/evals-freenode-#perl.lst[6576]: [ -t \*STDERR ]
evals/evals-freenode-#perl.lst[6577]: [ -t \*STDOUT ]
evals/evals-freenode-#perl.lst[6578]: $t = "test"
evals/evals-freenode-#perl.lst[6579]: $t = "This string is multi-line\nLine 2\n Last word is banana"; $t =~ s/.*(?=\b\w+\Z)//s; $t
evals/evals-freenode-#perl.lst[6580]: $t = "This string is multi-line\nLine 2\n Last word is banana"; $t =~ s/(?s:.*)(?=\b\w+\Z)//; $t # if you can't put a /s modifier
evals/evals-freenode-#perl.lst[6581]: $t = "This string is multi-line\nLine 2\n Last word is banana"; ($t) = $t =~ /(\S+)\Z/; $t
evals/evals-freenode-#perl.lst[6582]: "Two plus Two is " . ( 2 + 2 )
evals/evals-freenode-#perl.lst[6583]: two + two == five ? "true" : "false"
evals/evals-freenode-#perl.lst[6584]: $type="a"; $stationId="b"; [ grep { /$type/ && /$stationId/ } qw/abc cat bat/ ]
evals/evals-freenode-#perl.lst[6585]: $^U
evals/evals-freenode-#perl.lst[6586]: [ "ü" ]
evals/evals-freenode-#perl.lst[6587]: "\u0265\u01DD\u028E"
evals/evals-freenode-#perl.lst[6588]: "\Uaä" # looks right to me, lustiger_seth
evals/evals-freenode-#perl.lst[6589]: ucfirst 'str_str' =~ tr/_//dr;
evals/evals-freenode-#perl.lst[6590]: ucfirst 'str_str' =~ tr/_/ /r;
evals/evals-freenode-#perl.lst[6591]: [uc "hello corin"]
evals/evals-freenode-#perl.lst[6592]: "\U$code"
evals/evals-freenode-#perl.lst[6593]: "UCS-4" =~ s/^UCS-?4-?(BE|LE|)?$/UTF-32\U$1/ir
evals/evals-freenode-#perl.lst[6594]: uc 'ß'
evals/evals-freenode-#perl.lst[6595]: uc "ß"
evals/evals-freenode-#perl.lst[6596]: u eq n
evals/evals-freenode-#perl.lst[6597]: ["\Ufoo", "\ufoo"]
evals/evals-freenode-#perl.lst[6598]: "\uhello"
evals/evals-freenode-#perl.lst[6599]: `uname -a`
evals/evals-freenode-#perl.lst[6600]: undef
evals/evals-freenode-#perl.lst[6601]: ''.undef
evals/evals-freenode-#perl.lst[6602]: '\undef'
evals/evals-freenode-#perl.lst[6603]: undef // []
evals/evals-freenode-#perl.lst[6604]: [ undef == 0]
evals/evals-freenode-#perl.lst[6605]: [ undef => 1 ]
evals/evals-freenode-#perl.lst[6606]: [ undef != 1 ]
evals/evals-freenode-#perl.lst[6607]: [(undef) + 1]
evals/evals-freenode-#perl.lst[6608]: undef=>1
evals/evals-freenode-#perl.lst[6609]: undef + 1
evals/evals-freenode-#perl.lst[6610]: undef // 2
evals/evals-freenode-#perl.lst[6611]: undefined function these
evals/evals-freenode-#perl.lst[6612]: $undefined =~ s//bar/;
evals/evals-freenode-#perl.lst[6613]: undef my $x;
evals/evals-freenode-#perl.lst[6614]: [ undef | 'n', 0 | 'n', "0" | 'n' ]
evals/evals-freenode-#perl.lst[6615]: undef->${\rand}
evals/evals-freenode-#perl.lst[6616]: (\undef)->${ +sub { 'here' } }
evals/evals-freenode-#perl.lst[6617]: undef->${ \sub { 'here' } }
evals/evals-freenode-#perl.lst[6618]: undef->${ +sub { 'here' } }
evals/evals-freenode-#perl.lst[6619]: undef ? true : false
evals/evals-freenode-#perl.lst[6620]: [undef, ''.undef]
evals/evals-freenode-#perl.lst[6621]: undef $_ = undef
evals/evals-freenode-#perl.lst[6622]: $undef=undef; print $undef ? 'true' : 'undef';
evals/evals-freenode-#perl.lst[6623]: $undef=undef; print $undef ? 'true' : 'undef'; print "ERROR: $!";
evals/evals-freenode-#perl.lst[6624]: $undef=undef; print $undef ? 'undef' : 'true';
evals/evals-freenode-#perl.lst[6625]: [undef undef undef]
evals/evals-freenode-#perl.lst[6626]: undef->{Val} = 'cats'; $test
evals/evals-freenode-#perl.lst[6627]: Unicode::UCD::charinfo('x')
evals/evals-freenode-#perl.lst[6628]: [ UNIVERSAL->can("import") ]
evals/evals-freenode-#perl.lst[6629]: [ "ünix", glob "ünix" ] # an amusingly-useful one, pls to not be killing it
evals/evals-freenode-#perl.lst[6630]: unlink '/'
evals/evals-freenode-#perl.lst[6631]: unlink "Jello"
evals/evals-freenode-#perl.lst[6632]: unlink '/' or $!
evals/evals-freenode-#perl.lst[6633]: [ unpack "(a2)*", "000202056D4C" ]
evals/evals-freenode-#perl.lst[6634]: [ unpack "(a2)8", "here is a very long string that is too long for a mere sixteen characters" ]
evals/evals-freenode-#perl.lst[6635]: [ unpack '(a2)*', 'foo bar' ]
evals/evals-freenode-#perl.lst[6636]: [ unpack '(a3)*', '1234567890' ]
evals/evals-freenode-#perl.lst[6637]: [ unpack '(A3)*', 'abcdefghi' ] # liujingtu this is the unpack version
evals/evals-freenode-#perl.lst[6638]: [ unpack "(A4)*", "Hello, world!" ]
evals/evals-freenode-#perl.lst[6639]: [ unpack "(a4)*", reverse "6.4.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.1.0.0.0.0.1.1.8.2.a.1.0.0.b.3" =~ tr/.//dr ]
evals/evals-freenode-#perl.lst[6640]: [ unpack "(a4)*", "thisisatest" ]
evals/evals-freenode-#perl.lst[6641]: [ unpack "a8", "ABCD" ]
evals/evals-freenode-#perl.lst[6642]: [unpack("b*","01010")]
evals/evals-freenode-#perl.lst[6643]: [unpack("B*","01010")]
evals/evals-freenode-#perl.lst[6644]: unpack "b", 0.21875
evals/evals-freenode-#perl.lst[6645]: unpack "b*", 0.21875
evals/evals-freenode-#perl.lst[6646]: unpack 'B*', ~0 # maybe?
evals/evals-freenode-#perl.lst[6647]: [ unpack 'B8', 0x5A ] # see perldoc perlpacktut
evals/evals-freenode-#perl.lst[6648]: unpack "b",87381
evals/evals-freenode-#perl.lst[6649]: unpack "(b8)*", split ' ', "text"
evals/evals-freenode-#perl.lst[6650]: [ unpack '(b8)*', 'This' ]
evals/evals-freenode-#perl.lst[6651]: unpack "b*", $entry )
evals/evals-freenode-#perl.lst[6652]: unpack "b*",(pack "d", 0.9999999999999926)
evals/evals-freenode-#perl.lst[6653]: [ unpack "b*", pack "H*", "AB12C0" ]
evals/evals-freenode-#perl.lst[6654]: unpack "b*","$phrase""
evals/evals-freenode-#perl.lst[6655]: unpack "b*","$phrase" into a variable
evals/evals-freenode-#perl.lst[6656]: unpack "B*", "This"
evals/evals-freenode-#perl.lst[6657]: unpack "b*", "This is a test"
evals/evals-freenode-#perl.lst[6658]: [ unpack 'B', 'wibble' ]
evals/evals-freenode-#perl.lst[6659]: [ unpack 'B*', 'wibble' ]
evals/evals-freenode-#perl.lst[6660]: unpack "%c", '1'
evals/evals-freenode-#perl.lst[6661]: [ unpack "(C2)*", "hello" ]
evals/evals-freenode-#perl.lst[6662]: unpack "%c", 'a'
evals/evals-freenode-#perl.lst[6663]: [unpack "C*", "abcd"]
evals/evals-freenode-#perl.lst[6664]: [ unpack "C*", "ascii" ]
evals/evals-freenode-#perl.lst[6665]: [ unpack "C*", "hello" ]
evals/evals-freenode-#perl.lst[6666]: unpack "C*", pack "n", 945
evals/evals-freenode-#perl.lst[6667]: unpack('C', "\x80") - 256
evals/evals-freenode-#perl.lst[6668]: unpack 'H*', '00001c00';
evals/evals-freenode-#perl.lst[6669]: unpack("H*", 0x81)
evals/evals-freenode-#perl.lst[6670]: unpack 'H*', "\1\2\3\4"
evals/evals-freenode-#perl.lst[6671]: [ unpack 'H12', 'version' ]
evals/evals-freenode-#perl.lst[6672]: unpack "h2", ":"
evals/evals-freenode-#perl.lst[6673]: unpack "H2", ":"
evals/evals-freenode-#perl.lst[6674]: unpack '(H2)4', pack 'V', 1835008
evals/evals-freenode-#perl.lst[6675]: [ unpack "H2H*", "like this" ]
evals/evals-freenode-#perl.lst[6676]: unpack "h2", "ö"
evals/evals-freenode-#perl.lst[6677]: unpack '(H2)*', pack 'V', 1835008
evals/evals-freenode-#perl.lst[6678]: [ unpack "(H2)*", "preaction" ]
evals/evals-freenode-#perl.lst[6679]: unpack "(H2)*", "preaction"
evals/evals-freenode-#perl.lst[6680]: [ unpack "H*", "\31F\t\03129" ]
evals/evals-freenode-#perl.lst[6681]: unpack 'h*', '41'
evals/evals-freenode-#perl.lst[6682]: unpack 'H*', '41'
evals/evals-freenode-#perl.lst[6683]: unpack("H8", pack("V8",85))
evals/evals-freenode-#perl.lst[6684]: unpack "H*", '9e9b929691'
evals/evals-freenode-#perl.lst[6685]: unpack 'H*', 'à'
evals/evals-freenode-#perl.lst[6686]: unpack 'H*', 'à'
evals/evals-freenode-#perl.lst[6687]: unpack("H*", chr(1446686042));
evals/evals-freenode-#perl.lst[6688]: unpack 'H*', chr(18).chr(44)
evals/evals-freenode-#perl.lst[6689]: unpack '(HH)*', pack 'V', 1835008
evals/evals-freenode-#perl.lst[6690]: unpack "H*", ("kitties" ^ "nipnips")
evals/evals-freenode-#perl.lst[6691]: [ unpack 'H*', pack 'F', (9/10-1)*100 ]
evals/evals-freenode-#perl.lst[6692]: unpack 'H*', pack 'h*', 123456
evals/evals-freenode-#perl.lst[6693]: unpack "H*", pack "NV", 945, 945
evals/evals-freenode-#perl.lst[6694]: unpack "H*", v127.0.0.1
evals/evals-freenode-#perl.lst[6695]: unpack "H*", "\x{22}\x{31}"
evals/evals-freenode-#perl.lst[6696]: [ unpack "i<3", "\x05\x00\x00\x00\x04\x00\x00\x00\x3\x00\x00\x00" ]
evals/evals-freenode-#perl.lst[6697]: [ unpack "i<", "\x05\x00\x00\x00" ]
evals/evals-freenode-#perl.lst[6698]: [ unpack "i>", "\x05\x00\x00\x00" ]
evals/evals-freenode-#perl.lst[6699]: [ unpack "l>", "\0\0\0\cQ" ]
evals/evals-freenode-#perl.lst[6700]: unpack "l<", 0x00.0x00.0x72.0x00
evals/evals-freenode-#perl.lst[6701]: unpack "l", 0x00.0x00.0x72.0x00
evals/evals-freenode-#perl.lst[6702]: [ unpack "(L)4", "here is a very long string that is too long for a mere sixteen characters" ]
evals/evals-freenode-#perl.lst[6703]: unpack "l<", "\x00\x00\x72\x00"
evals/evals-freenode-#perl.lst[6704]: unpack "l>", "\x00\x00\x72\x00"
evals/evals-freenode-#perl.lst[6705]: unpack "l", "\x00\x00\x72\x00"
evals/evals-freenode-#perl.lst[6706]: unpack "l<", "\x06\x00\x00\x00";
evals/evals-freenode-#perl.lst[6707]: unpack "n", 945
evals/evals-freenode-#perl.lst[6708]: unpack "n", "AU"
evals/evals-freenode-#perl.lst[6709]: [ -~unpack 'N', join '', map chr, '192.168.254.43' =~ /\d+/g ]
evals/evals-freenode-#perl.lst[6710]: [ unpack 'N!', join '', map chr, '192.168.254.43' =~ /\d+/g ]
evals/evals-freenode-#perl.lst[6711]: [ unpack 'N!', pack 'C4', split /\./, '192.168.254.43' ]
evals/evals-freenode-#perl.lst[6712]: unpack 'N', pack 'h*', '00001c00';
evals/evals-freenode-#perl.lst[6713]: unpack 'N', pack 'H*', '00001c00';
evals/evals-freenode-#perl.lst[6714]: [ unpack "n*", "\x41\x42\x43\x44" ]
evals/evals-freenode-#perl.lst[6715]: [ unpack "(Q)4", "here is a very long string that is too long for a mere sixteen characters" ]
evals/evals-freenode-#perl.lst[6716]: [ unpack q{(B8)*}, pack q{C*}, 260 ] ### Why is this only printing one byte when 260 consumes two (8-bit) bytes ?
evals/evals-freenode-#perl.lst[6717]: [ unpack q{(h4)*}, pack q{(h2)*}, split /\./, reverse q{6.4.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.1.0.0.0.0.1.1.8.2.a.1.0.0.b.3} ]
evals/evals-freenode-#perl.lst[6718]: [ unpack q{N}, pack q{H8}, q{6060FF} ] # alanjf
evals/evals-freenode-#perl.lst[6719]: [ unpack q{N*}, pack q{H*}, q{6060FF} ];
evals/evals-freenode-#perl.lst[6720]: unpack( "q>", pack "H*", "000001448e317907" ) / 1000
evals/evals-freenode-#perl.lst[6721]: [ unpack 'q', "\xff" x 8 ]
evals/evals-freenode-#perl.lst[6722]: [ unpack "(S)4", "here is a very long string that is too long for a mere sixteen characters" ]
evals/evals-freenode-#perl.lst[6723]: unpack "V", "1703"
evals/evals-freenode-#perl.lst[6724]: unpack 'V', pack 'h*', '00001c00';
evals/evals-freenode-#perl.lst[6725]: unpack 'V', pack 'H*', '00001c00';
evals/evals-freenode-#perl.lst[6726]: unpack "V", "\x17\x03\x01\x00"
evals/evals-freenode-#perl.lst[6727]: unpack "v", "\x52\x12"
evals/evals-freenode-#perl.lst[6728]: [ unpack "v", "\xd8\x00" ]
evals/evals-freenode-#perl.lst[6729]: $_="us 127.0.0.1 8000"; (split)[1]
evals/evals-freenode-#perl.lst[6730]: usa {STDOUT} 'IO::Handle';
evals/evals-freenode-#perl.lst[6731]: use $];
evals/evals-freenode-#perl.lst[6732]: use 0 warnings;
evals/evals-freenode-#perl.lst[6733]: use 10;
evals/evals-freenode-#perl.lst[6734]: use 1 strict;
evals/evals-freenode-#perl.lst[6735]: use 2 Moose;
evals/evals-freenode-#perl.lst[6736]: use 2 threads;
evals/evals-freenode-#perl.lst[6737]: use 3 strictures;
evals/evals-freenode-#perl.lst[6738]:  use 5.006_001;
evals/evals-freenode-#perl.lst[6739]: use 5.010;
evals/evals-freenode-#perl.lst[6740]: use 5.010; my $str = "foo:12 bar:34 baz:45"; $str =~ /foo:(?<foo>\d+) bar:(?<bar>\d+) baz:(?<baz>\d+)/; \%+
evals/evals-freenode-#perl.lst[6741]: use 5.010; my $x = 42; [  map { my $y = $x++; $y } 0..3 ];
evals/evals-freenode-#perl.lst[6742]: use 5.010; my $x = 42; [  map { state $y = $x++; $y } 0..3 ];
evals/evals-freenode-#perl.lst[6743]: use 5.010; say(("a" x 100000) =~ /^(ab?)*$/ ? "Yes" : "No");
evals/evals-freenode-#perl.lst[6744]: use 5.010; say(("a" x 10000) =~ /^(ab?)*$/ ? "Yes" : "No");
evals/evals-freenode-#perl.lst[6745]: use 5.010; say $ENV{HOME}
evals/evals-freenode-#perl.lst[6746]: use 5.010; say keys %ENV;
evals/evals-freenode-#perl.lst[6747]: use 5.010; say `ls -a`;
evals/evals-freenode-#perl.lst[6748]: use 5.010; say "one"; say "two"
evals/evals-freenode-#perl.lst[6749]: use 5.010; sub foo { state $foo = 123; @_ and $foo = shift; $foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo("zof!"), foo, foo]
evals/evals-freenode-#perl.lst[6750]: use 5.010; sub foo { state $foo = 123; @_ and $foo = shift; $foo }; [ foo, foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo("zof!"), foo, foo]
evals/evals-freenode-#perl.lst[6751]: use 5.010; sub foo { state $foo = shift; @_ and $foo = shift;$foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo("zof!"), foo, foo]
evals/evals-freenode-#perl.lst[6752]: use 5.010; sub foo { state $foo = shift; if ( @_ ) { $foo = shift; } $foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo("zof!"), foo, foo]
evals/evals-freenode-#perl.lst[6753]: use 5.010; sub x :lvalue {state $x; $x} x = 1; { local x = 3; print $x } $x
evals/evals-freenode-#perl.lst[6754]: use 5.010; sub x :lvalue { $x; $x} x = 1; { local x = 3; print $x } $x
evals/evals-freenode-#perl.lst[6755]: use 5.012; $foo = 'bar'; ++$$foo; $bar
evals/evals-freenode-#perl.lst[6756]: use 5.012; ++$x
evals/evals-freenode-#perl.lst[6757]: use 5.014; $foo = 'foo'
evals/evals-freenode-#perl.lst[6758]: use 5.014; state $x = 4; $x
evals/evals-freenode-#perl.lst[6759]: use 5.014; $x = 5
evals/evals-freenode-#perl.lst[6760]: use 5.01600; [__PACKAGE__, __SUB__]
evals/evals-freenode-#perl.lst[6761]: use 5.016; say ''.localtime(0.32099 * 1e6 + 1394981846);
evals/evals-freenode-#perl.lst[6762]: use 5.016; ++$x
evals/evals-freenode-#perl.lst[6763]: use 5.018; my %hash;  push $hash{key}, "more";  \%hash
evals/evals-freenode-#perl.lst[6764]: use 5.018; print fc("ł") cmp fc("z")
evals/evals-freenode-#perl.lst[6765]: use 5.01; say STDERR "error message";
evals/evals-freenode-#perl.lst[6766]: use 5.020; fc('er') eq fc('3r')
evals/evals-freenode-#perl.lst[6767]: use 5.020; fc('er') eq fc('er')
evals/evals-freenode-#perl.lst[6768]: use 5.020; fc('er') eq fc('Er')
evals/evals-freenode-#perl.lst[6769]: use 5.020; [ fc 'foo' ]; # how do I do this on an older perl?
evals/evals-freenode-#perl.lst[6770]: use 5.020; [ fc 'ß' ];
evals/evals-freenode-#perl.lst[6771]: use 5.020; [ fc 'ß' ]; # <BenGoldberg>
evals/evals-freenode-#perl.lst[6772]: use 5.020; [ fc('ß') eq fc('ss') ];
evals/evals-freenode-#perl.lst[6773]: use 5.020; [ fc "\xdf" ]
evals/evals-freenode-#perl.lst[6774]: use 5.020; $foo = 'bar'; ++$$foo; $bar
evals/evals-freenode-#perl.lst[6775]: use 5.020; $foo = 'foo'
evals/evals-freenode-#perl.lst[6776]: use 5.020; for ( [qw/foo bar/]->@* ) { print}
evals/evals-freenode-#perl.lst[6777]: use 5.020; map print, [1,2,3]->@*
evals/evals-freenode-#perl.lst[6778]: use 5.020; my @a = 'a'..'c'; [ %a[0..2] ]
evals/evals-freenode-#perl.lst[6779]: use 5.020; my @a = 'a'..'c'; forhash my ($x, $y) (%a[0..2]) { say "$x: $y" }
evals/evals-freenode-#perl.lst[6780]: use 5.020; my @a = 'a'..'z'; [ %a[0..20] ]
evals/evals-freenode-#perl.lst[6781]: use 5.020; my @a = 'a'..'z'; { %a[0..20] }; # not in order
evals/evals-freenode-#perl.lst[6782]: use 5.020; my @a = 'a'..'z'; +{ %a[0..20] }; # not in order
evals/evals-freenode-#perl.lst[6783]: use 5.020; open 'file'
evals/evals-freenode-#perl.lst[6784]: use 5.020; sub add ($x = return 0, $y = return $x) { return $x + $y }   [ add(), add(2), add(2,3)  ]
evals/evals-freenode-#perl.lst[6785]: use 5.020; use feature 'postderef'; no warnings 'experimental::postderef'; for ( [qw/foo bar/]->@* ) { print}
evals/evals-freenode-#perl.lst[6786]: use 5.020; use warnings; open 'file'
evals/evals-freenode-#perl.lst[6787]: use 5.021011; say "hi"
evals/evals-freenode-#perl.lst[6788]: use 5.022; $foo = 'foo'
evals/evals-freenode-#perl.lst[6789]: use 5.10;
evals/evals-freenode-#perl.lst[6790]: use 5.14; state $x = 4; $x
evals/evals-freenode-#perl.lst[6791]: use 5.18.0; use experimental 'signatures'; sub foo($bar) {$bar =~ s/baz/boo/r}; print foo("baz lol baz");
evals/evals-freenode-#perl.lst[6792]: use 5.18; use experimental 'signatures'; sub foo($bar) {$bar =~ s/baz/boo/r}; print foo("baz lol baz");
evals/evals-freenode-#perl.lst[6793]: use 5.20; map print, [1,2,3]->@*
evals/evals-freenode-#perl.lst[6794]: use 6 strict;
evals/evals-freenode-#perl.lst[6795]: use 9;
evals/evals-freenode-#perl.lst[6796]: use Acme::Everything;
evals/evals-freenode-#perl.lst[6797]: use Acme::Lvalue;
evals/evals-freenode-#perl.lst[6798]: use Acme::MetaSyntactic; print metaname();
evals/evals-freenode-#perl.lst[6799]: use ath; sqrt -1;
evals/evals-freenode-#perl.lst[6800]: use autodie; my $str = "foo"; open( my ($fh), ">", \$str ); print $fh; [ $str ];
evals/evals-freenode-#perl.lst[6801]: use base "Tie::StdHash";
evals/evals-freenode-#perl.lst[6802]: use bigfloat;
evals/evals-freenode-#perl.lst[6803]: use bigfloat;  my $now = 1407974704.32323;  my $Last_Reload_Command = 1407974704.32322; $now - $Last_Reload_Command;
evals/evals-freenode-#perl.lst[6804]: use bigint;
evals/evals-freenode-#perl.lst[6805]: use bigint; 100 * 1000
evals/evals-freenode-#perl.lst[6806]: use bigint; 1e999
evals/evals-freenode-#perl.lst[6807]: use bigint; 2790**2753 % 3233
evals/evals-freenode-#perl.lst[6808]: use bigint; "Altreus"
evals/evals-freenode-#perl.lst[6809]: use bigint; inf * 3
evals/evals-freenode-#perl.lst[6810]: use bigint; printf("%s\n", 100**1000);
evals/evals-freenode-#perl.lst[6811]: use bignum;
evals/evals-freenode-#perl.lst[6812]: use bignum; 0.1 + 0.2 - 0.3
evals/evals-freenode-#perl.lst[6813]: use bignum; 2**88
evals/evals-freenode-#perl.lst[6814]: use bignum;  my $now = 1407974704.32323;  my $Last_Reload_Command = 1407974704.32322; $now - $Last_Reload_Command;
evals/evals-freenode-#perl.lst[6815]: use bigrat;
evals/evals-freenode-#perl.lst[6816]: use B 'perlstring'; [perlstring "foo\r\n\tbar\n"]
evals/evals-freenode-#perl.lst[6817]: use B 'perlstring'; perlstring "foo\r\n\tbar\n";
evals/evals-freenode-#perl.lst[6818]: use B 'perlstring'; print perlstring "foo\r\n\tbar\n";
evals/evals-freenode-#perl.lst[6819]: use B qw( svref_2object ); [ svref_2object(\&svref_2object)->GV ]
evals/evals-freenode-#perl.lst[6820]: use B $^W++;join(($x)x101)
evals/evals-freenode-#perl.lst[6821]: use bytes; length  pack "d*", 1,2,3;
evals/evals-freenode-#perl.lst[6822]: use bytes; length  pack "f*", 1,2,3;
evals/evals-freenode-#perl.lst[6823]: use bytes; length 'sາໍ'
evals/evals-freenode-#perl.lst[6824]: use bytes; $l = "fooso"; [ $l & chr(0x80)x(length $l) ] # everything can be turned broken if you want to
evals/evals-freenode-#perl.lst[6825]: use bytes; $_="☃☃☃☃"; substr($_,0,1,''); length $_
evals/evals-freenode-#perl.lst[6826]: use Carp; \ %Carp::CarpInternal
evals/evals-freenode-#perl.lst[6827]: use charnames; charnames::viacode 0x92
evals/evals-freenode-#perl.lst[6828]: use charnames; [ map charnames::viacode(ord), qw(☃ ⛄ ⛇) ]
evals/evals-freenode-#perl.lst[6829]: use Config; \%Config
evals/evals-freenode-#perl.lst[6830]: use Config; $Config{archname}
evals/evals-freenode-#perl.lst[6831]: use Config; $Config{longdouble}
evals/evals-freenode-#perl.lst[6832]: use Config; $Config{myuname}
evals/evals-freenode-#perl.lst[6833]: use Config; $Config{nvsize}
evals/evals-freenode-#perl.lst[6834]: use Config; $Config{osname}
evals/evals-freenode-#perl.lst[6835]: use Config; $Config{uname}
evals/evals-freenode-#perl.lst[6836]: use Config; $Config{use64bitint};
evals/evals-freenode-#perl.lst[6837]: use Config; [ grep { $_ } map { s/^"(.*?)"$/$1/r } split /,/, $Config{inc_version_list_init} ]
evals/evals-freenode-#perl.lst[6838]: use Config; print $Config{archname}
evals/evals-freenode-#perl.lst[6839]: use constant '4' => 'ok'; &{4};
evals/evals-freenode-#perl.lst[6840]: use constant 4 => 'ok'; &{4};
evals/evals-freenode-#perl.lst[6841]: use constant A => [1..5]; sub TIESCALAR { bless [] }; sub FETCH { 42 }; tie ${\(A->[2])}, 'main'; A;
evals/evals-freenode-#perl.lst[6842]: use constant A => [1..5]; sub TIESCALAR { bless [] }; sub FETCH { 42 }; tie ${\(A->[2])}, 'main'; sub { A };
evals/evals-freenode-#perl.lst[6843]: use constant A => "constant?"; sub TIESCALAR { bless [] }; sub FETCH { "mutable!" }; tie ${\(A)}, 'main'; A;
evals/evals-freenode-#perl.lst[6844]: use constant cat => 1; cat while $x++<1
evals/evals-freenode-#perl.lst[6845]: use constant; constant::_CAN_PCS();
evals/evals-freenode-#perl.lst[6846]: use constant C => 'XXX'; 'foobarbaz' =~ s/bar/C/er
evals/evals-freenode-#perl.lst[6847]: use constant C => 'XXX'; 'foobarbaz' =~ s/bar/${\C}/r
evals/evals-freenode-#perl.lst[6848]: use constant FOO => 42; [ $::{FOO} ]
evals/evals-freenode-#perl.lst[6849]: use constant FOO => 42; $FOO = 43; $::{FOO}
evals/evals-freenode-#perl.lst[6850]: use constant FOO => 42; [ *FOO{CODE} ]
evals/evals-freenode-#perl.lst[6851]: use constant { FOO => 42 }; +{ +FOO => "test" }
evals/evals-freenode-#perl.lst[6852]: use constant { FOO => 42 }; +{ FOO => "test" }
evals/evals-freenode-#perl.lst[6853]: use constant { FOO => 42 }; +{ FOO() => "test" }
evals/evals-freenode-#perl.lst[6854]: use constant FOO => 42; { local *FOO = sub () { "k" }; &FOO() }
evals/evals-freenode-#perl.lst[6855]: use constant FOO => 42; [ main->FOO ]
evals/evals-freenode-#perl.lst[6856]: use constant FOO => 'BAR!'; BEGIN { say FOO }
evals/evals-freenode-#perl.lst[6857]: use constant FOO => "bar"; "${\FOO}"
evals/evals-freenode-#perl.lst[6858]: use constant FOO => 'bar'; [&FOO => 'bar']
evals/evals-freenode-#perl.lst[6859]: use constant FOO => 'bar'; (FOO() => 'baz'){+FOO}
evals/evals-freenode-#perl.lst[6860]: use constant FOO => 'bar'; {FOO() => 'baz'}->{+FOO}
evals/evals-freenode-#perl.lst[6861]: use constant FOO => 'bar'; +{FOO() => 'baz'}->{+FOO}
evals/evals-freenode-#perl.lst[6862]: use constant FOO => 'BAR!'; our $dir = FOO; BEGIN { say FOO } say "Moar $dir!"
evals/evals-freenode-#perl.lst[6863]: use constant FOO => "dogs"; +{ FOO => 213, FOO() => 1, +FOO => 2 }
evals/evals-freenode-#perl.lst[6864]: use constant { Inf => 0 + 'inf', NaN => 0 + 'nan' }; Inf * -1
evals/evals-freenode-#perl.lst[6865]: use constant IsProhibited => ''; qr/\p{IsProhibited}/
evals/evals-freenode-#perl.lst[6866]: use constant list => qw(a b c); [list]
evals/evals-freenode-#perl.lst[6867]: use constant PARENT_CLASS => 'Legacy'; BEGIN { package Legacy; $INC{"Legacy.pm"} = 1} { package Shim; use parent main::PARENT_CLASS; } Shim->isa('Legacy') ? 'true' : 'false'
evals/evals-freenode-#perl.lst[6868]: use constant PI    => 4 * atan2(1, 1); print "Pi equals ", PI, "...\n";
evals/evals-freenode-#perl.lst[6869]: use constant; print constant::_CAN_PCS;
evals/evals-freenode-#perl.lst[6870]: use constant TEST2 => TEST1; use constant TEST1 => 1; use constant TEST3 => TEST1; [TEST1, TEST2, TEST3]
evals/evals-freenode-#perl.lst[6871]: use constant XXX => 'test'; "@{[ XXX ]} or ${\XXX} or " . XXX
evals/evals-freenode-#perl.lst[6872]: use CPAN; install("Time::Moment")
evals/evals-freenode-#perl.lst[6873]: use Cwd; print cwd();
evals/evals-freenode-#perl.lst[6874]: use Cwd qw(); print Cwd::cwd();
evals/evals-freenode-#perl.lst[6875]: use Data::Dump
evals/evals-freenode-#perl.lst[6876]: use Data::Dumper;
evals/evals-freenode-#perl.lst[6877]: use Data::Dumper; $Data::Dumper::Indent = 0; %foo = (a => { b => 'c' }); $foo{d} = $foo{a}; Dumper \%foo
evals/evals-freenode-#perl.lst[6878]: use Data::Dumper; Dumper("${\chr 24}")
evals/evals-freenode-#perl.lst[6879]: use Data::Dumper; Dumper("\cX")
evals/evals-freenode-#perl.lst[6880]: use Data::Dumper; Dumper("\CX")
evals/evals-freenode-#perl.lst[6881]: use Data::Dumper; my @arr; push(@arr, "test"); push(@arr, "i refuse to do what master tells me to"); my @arr2 = grep { /test/ } @arr; print Dumper @arr2;
evals/evals-freenode-#perl.lst[6882]: use Data::Dumper; my %commands = ( help => sub { my $commands = say for keys in %commands; }); say Dumper($commands{help});
evals/evals-freenode-#perl.lst[6883]: use Data::Dumper; print Dumper(*->[0]);
evals/evals-freenode-#perl.lst[6884]: use Data::Dumper; print Dumper(0);
evals/evals-freenode-#perl.lst[6885]: use Data::Dumper; print Dumper(0->[0]);
evals/evals-freenode-#perl.lst[6886]: use Data::Dumper; print Dumper(\%ENV);
evals/evals-freenode-#perl.lst[6887]: use Data::Dump 'pp'; pp("\cX")
evals/evals-freenode-#perl.lst[6888]: use Data::Munge 1
evals/evals-freenode-#perl.lst[6889]: use Data::Munge; "abba" =~ /(ab(ba))|(ba)/ or die; [submatches]
evals/evals-freenode-#perl.lst[6890]: use Data::Munge; byval { s/a/o/g } "banana"
evals/evals-freenode-#perl.lst[6891]: use Data::Munge; eval_string "[[ \"pos\" ], /\"(/d+)\"/]"
evals/evals-freenode-#perl.lst[6892]: use Data::Munge; list2re ""
evals/evals-freenode-#perl.lst[6893]: use Data::Munge; list2re()
evals/evals-freenode-#perl.lst[6894]: use Data::Munge. list2re()
evals/evals-freenode-#perl.lst[6895]: use Data::Munge; list2re qw( ab cd ef g h i )
evals/evals-freenode-#perl.lst[6896]: use Data::Munge; my $str = "hello"; my @m; while ($str =~ /(.)(.)/g) { push @m, [submatches]; } \@m
evals/evals-freenode-#perl.lst[6897]: use Data::Munge qw(byval); print byval { s/\* // } "* foo";
evals/evals-freenode-#perl.lst[6898]: use Data::Munge qw(elem); [ elem "badgers", [qw(dogs badgers monkeys)] ]
evals/evals-freenode-#perl.lst[6899]: use Data::Munge qw(elem); [ elem "cats", [qw(dogs badgers monkeys)] ]
evals/evals-freenode-#perl.lst[6900]: use Data::Munge qw( list2re ); my $re = list2re qw(); $re eq list2re ? q{Empty.} : q{Not empty.}; ### Is this a good way to tell if $re was generated from an empty list?
evals/evals-freenode-#perl.lst[6901]: use Data::Munge qw(list2re); my $re = list2re( ); { [ $$re, $re ]; } # Looks like the heart of a Regexp object, despite being labeled as a REGEXP, really seems to be a string.
evals/evals-freenode-#perl.lst[6902]: use Data::Munge qw(replace); my $s = 'some text'; my $f = 's/x/s/g; s/o/a/g;'; my $part = qr{(?:[^\\/]|\\.)*}s; while ($f =~ m{\bs/($part)/($part)/(g)?}g) { $s = replace $s, $1, $2, $3; } $s
evals/evals-freenode-#perl.lst[6903]: use Data::Munge qw(replace); replace('A?Bl^%ah 4 Yes$!', qr/[^A-Za-z0-9]/, '', 'g')
evals/evals-freenode-#perl.lst[6904]: use Data::Munge qw(replace); replace('foobarstring', qr/foo/, 'bar')
evals/evals-freenode-#perl.lst[6905]: use Data::Munge qw(replace); replace 'ningu', qr/([aeiou])/, '$1$1', 'g'
evals/evals-freenode-#perl.lst[6906]: use Data::Munge; replace "banana", qr/a/, 'o', 'g'
evals/evals-freenode-#perl.lst[6907]: use Data::Munge; [ replace "blah", qr/bl/, 'h' ]
evals/evals-freenode-#perl.lst[6908]: use Data::Munge; replace('cool+beans.', qr/\W/, '\\$&', 'g')
evals/evals-freenode-#perl.lst[6909]: use Data::Parse; print str2time("january 4th")
evals/evals-freenode-#perl.lst[6910]: use Data::Random
evals/evals-freenode-#perl.lst[6911]: use Data::Swap;
evals/evals-freenode-#perl.lst[6912]: use Date::Manip; my $r = UnixDate(ParseDate( q{Sat, 12 Apr 2014 10:01:33 -0400} ), "%d-%b-%Y %H:%M:%S %z"); [ $r ]; ### This works for me.
evals/evals-freenode-#perl.lst[6913]: use Date::Manip; my $r = UnixDate(ParseDate( q{Wed, 17 Apr 2014 01:50:19 +0100} ), "%d-%b-%Y %H:%M:%S %z"); [ $r ]; ### This returns undef for some reason, I can't figure out why.
evals/evals-freenode-#perl.lst[6914]: use DateTime; DateTime->new->iso8601
evals/evals-freenode-#perl.lst[6915]: use DateTime; [ DateTime->new(year => 2014, time_zone => '-0400') . "" ];
evals/evals-freenode-#perl.lst[6916]: use DateTime; [ DateTime->new(year => 2014, time_zone => '-0400')->${\'(""'} ];
evals/evals-freenode-#perl.lst[6917]: use DateTime; DateTime->new(year => 2014, time_zone => '-0400')->${\'"")'};
evals/evals-freenode-#perl.lst[6918]: use DateTime; DateTime->new(year => 2014, time_zone => '-0400')->${\'(""'};
evals/evals-freenode-#perl.lst[6919]: use DateTime; DateTime->new(year => 2014, time_zone => '-0400');
evals/evals-freenode-#perl.lst[6920]: use DateTime; DateTime->new(year => 2014, time_zone => -4);
evals/evals-freenode-#perl.lst[6921]: use DateTime; DateTime->new(year => 2014, time_zone => 'America/Chicago');
evals/evals-freenode-#perl.lst[6922]: use DateTime; DateTime->now->iso8601
evals/evals-freenode-#perl.lst[6923]: use DateTime; DateTime->now(time_zone  => '+0800')->iso8601
evals/evals-freenode-#perl.lst[6924]: use DateTime; DateTime->now(time_zone  => 'America/Chicago')->iso8601
evals/evals-freenode-#perl.lst[6925]: use DateTime::Format::Strptime
evals/evals-freenode-#perl.lst[6926]: use DateTime::Format::Strptime; DateTime::Format::Strptime->new( pattern => "%b", debug => 1 )->parse_datetime("dec")->ymd
evals/evals-freenode-#perl.lst[6927]: use DateTime::Format::Strptime; DateTime::Format::Strptime->new( pattern => "%b" )->parse_datetime("dec")
evals/evals-freenode-#perl.lst[6928]: use DateTime::Format::Strptime; DateTime::Format::Strptime->new( pattern => "%b" )->parse_datetime("dec")->ymd
evals/evals-freenode-#perl.lst[6929]: use DateTime;my $dt = DateTime->new(year   => 2014,month  => 11,day    => 1,hour   => 12,minute => 0,time_zone => 'floating',);[ $dt->add(days => 1) ]
evals/evals-freenode-#perl.lst[6930]: use DateTime; my $dt = DateTime->new(year => 2014, month => 11, day => 1, hour => 23, time_zone => 'America/New_York'); $dt->add(days => 1); $dt->datetime
evals/evals-freenode-#perl.lst[6931]: use DateTime; my $dt = DateTime->new(year => 2014, month => 11, day => 1, hour => 23, time_zone => 'EST5EDT'); $dt->add(days => 1); $dt->datetime
evals/evals-freenode-#perl.lst[6932]: use DateTime; print DateTime->now->strftime('%Y.%m.%d.%H.%M.%S');
evals/evals-freenode-#perl.lst[6933]: use DateTime; print DateTime->now->time_zone->name;
evals/evals-freenode-#perl.lst[6934]: use DateTime; print DateTime->now->year."w".DateTime->now->week_number
evals/evals-freenode-#perl.lst[6935]: use DateTime::TimeZone; [DateTime::TimeZone->all_names];
evals/evals-freenode-#perl.lst[6936]: use DateTime::TimeZone; [ DateTime::TimeZone->new( name => 'UTC' ) ]
evals/evals-freenode-#perl.lst[6937]: use DateTime::TimeZone; grep /America/ DateTime::TimeZone->all_names
evals/evals-freenode-#perl.lst[6938]: use DateTime::TimeZone; grep /America/, DateTime::TimeZone->all_names
evals/evals-freenode-#perl.lst[6939]: use DateTime::TimeZone; [grep m[[^a-zA-Z0-9/_-]], DateTime::TimeZone->all_names];
evals/evals-freenode-#perl.lst[6940]: use DateTime::TimeZone; [grep m[[^a-zA-Z/_]], DateTime::TimeZone->all_names];
evals/evals-freenode-#perl.lst[6941]: use DateTime::TimeZone; [grep m[[^a-zA-Z/]], DateTime::TimeZone->all_names];
evals/evals-freenode-#perl.lst[6942]: use DateTime::TimeZone; [grep /york/i, DateTime::TimeZone->all_names];
evals/evals-freenode-#perl.lst[6943]: use DateTime::TimeZone; my $tz = DateTime::TimeZone->new(name => 'America/New_York')
evals/evals-freenode-#perl.lst[6944]: use DateTime::TimeZone; my $tz = DateTime::TimeZone->new(name => 'local')->name
evals/evals-freenode-#perl.lst[6945]: use diagnostics; use strict; [ Foo ]
evals/evals-freenode-#perl.lst[6946]: use Digest::MD5 qw(md5_hex); md5_hex "TESTSTRING\n"
evals/evals-freenode-#perl.lst[6947]: use Digest; my $md5 = Digest->new('MD5'); length $md5
evals/evals-freenode-#perl.lst[6948]: use Encode;
evals/evals-freenode-#perl.lst[6949]: use Encode 'decode'; decode 'UTF-8', chr(195).chr(188)
evals/evals-freenode-#perl.lst[6950]: use Encode 'decode'; [ decode 'UTF-8', "\x1c\x00\xfc\x3c\x1c\xfc\x0e\xc0\xe0" ]
evals/evals-freenode-#perl.lst[6951]: use Encode 'decode'; [ decode 'UTF-8', "\x1d
evals/evals-freenode-#perl.lst[6952]: use Encode 'decode'; [ decode 'UTF-8', "\x1d\x7f"]
evals/evals-freenode-#perl.lst[6953]: use Encode 'decode_utf8'; decode_utf8 "\0357\0273\0277"
evals/evals-freenode-#perl.lst[6954]: use Encode 'decode_utf8'; decode_utf8 "\357\273\277"
evals/evals-freenode-#perl.lst[6955]: use Encode 'decode_utf8'; ord decode_utf8 "\357\273\277"
evals/evals-freenode-#perl.lst[6956]: use Encode 'decode_utf8'; sprintf "U+%04x", ord decode_utf8 "\357\273\277"
evals/evals-freenode-#perl.lst[6957]: use Encode; Encode::encode("ISO-8859-1", "\x{100}", Encode::LEAVE_SRC|Encode::FB_CROAK);
evals/evals-freenode-#perl.lst[6958]: use Encode 'encode'; encode 'UCS-2LE', 'Tracking-Num... '
evals/evals-freenode-#perl.lst[6959]: use Encode 'encode'; encode 'UTF-16LE', 'Tracking-Num... '
evals/evals-freenode-#perl.lst[6960]: use Encode 'encode'; encode 'UTF-16', 'Tracking-Num... '
evals/evals-freenode-#perl.lst[6961]: use Encode 'encode'; encode 'UTF-8', '　'
evals/evals-freenode-#perl.lst[6962]: use Encode 'encode'; encode 'UTF-8', chr(195).chr(188)
evals/evals-freenode-#perl.lst[6963]: use Encode 'encode'; [ encode 'UTF-8', "\x{1d}" ]
evals/evals-freenode-#perl.lst[6964]: use Encode 'encode'; [ encode 'UTF-8', \x{1d} ]
evals/evals-freenode-#perl.lst[6965]: use Encode; Encode::find_encoding('gb2312')->mime_name
evals/evals-freenode-#perl.lst[6966]: use Encode; Encode::find_encoding("ISO-8859-1")->encode("\x{100}", Encode::LEAVE_SRC|Encode::FB_CROAK)
evals/evals-freenode-#perl.lst[6967]: use Encode; Encode::find_encoding( q{UTF-16} )->name
evals/evals-freenode-#perl.lst[6968]: use Encode; Encode::find_encoding('utf8')->mime_name
evals/evals-freenode-#perl.lst[6969]: use Encode 'encode'; my $str = 'ü'; $str = encode 'UTF-8', $str for 1..10; $str
evals/evals-freenode-#perl.lst[6970]: use Encode; $Encode::VERSION
evals/evals-freenode-#perl.lst[6971]: use Encode; Encode::VERSION
evals/evals-freenode-#perl.lst[6972]: use Encode; find_encoding( q{UTF-16} )->name;
evals/evals-freenode-#perl.lst[6973]: use Encode; find_encoding( q{UTF-EBCDIC} )->name; # ???
evals/evals-freenode-#perl.lst[6974]: use Encode; my $buf = encode('UTF-8', "\x{666}"); open my $fh, '<', \$buf or die "open: $!"
evals/evals-freenode-#perl.lst[6975]: use Encode; my $x = qq<\x{100}>; [ unpack q{H*}, $x ]
evals/evals-freenode-#perl.lst[6976]: use Encode; ord Encode::encode_utf8("\xFF") # not necessarily
evals/evals-freenode-#perl.lst[6977]: use Encode;  print Encode::decode q{ISO885902}, "\x{119}";
evals/evals-freenode-#perl.lst[6978]: use Encode;  print Encode::decode q{ISO8859-2}, "\x{119}";
evals/evals-freenode-#perl.lst[6979]: use Encode; printf "%vd", encode_utf8("much \x{2665}")
evals/evals-freenode-#perl.lst[6980]:  use Encode qw/decode/; [ decode( "UTF-8", "\x6\x0\x0\x0\x65\x0\x0\x0\x61\x6e\x69\x6d\x73\x2f\x74\x68\x72\x30\x30\x30\x30\x31\x2e\x74\x67\x61") ] # print obviously doesn't like \0
evals/evals-freenode-#perl.lst[6981]: use Encode qw/decode/; print decode( "utf8", "\x06\x00\x00\x00\x65\x00\x00\x00\x61\x6e\x69\x6d\x73\x2f\x74\x68\x72\x30\x30\x30\x30\x31\x2e\x74\x67\x61" );
evals/evals-freenode-#perl.lst[6982]: use Encode qw/decode/; print decode( "utf8", "\x6\x0\x0\x0\x65\x0\x0\x0\x61\x6e\x69\x6d\x73\x2f\x74\x68\x72\x30\x30\x30\x30\x31\x2e\x74\x67\x61" )
evals/evals-freenode-#perl.lst[6983]: use Encode; say Encode::encode("UTF-8", Encode::decode("ISO-8859-1", "おジャ魔女どれみ"));
evals/evals-freenode-#perl.lst[6984]: use Encode::Unicode; Encode::find_encoding( q{UTF-16} )->name
evals/evals-freenode-#perl.lst[6985]: use English; [ $., $NR ]
evals/evals-freenode-#perl.lst[6986]: use Env qw/ HOME /;[[ ((glob("$HOME/*.txt"))[0]) ]]
evals/evals-freenode-#perl.lst[6987]: use Errno 'ENOENT'; ENOENT
evals/evals-freenode-#perl.lst[6988]: use experimental 'autoderef'; [keys {foo => 1, bar => 2, baz => 0}]
evals/evals-freenode-#perl.lst[6989]: use experimental 'lexical_subs'
evals/evals-freenode-#perl.lst[6990]: use experimental 'lexical_subs'; use constant wibble => 42; my $outer = wibble; my $inner = do { my sub wibble () { 69 }; wibble }; [ $inner, $outer ]
evals/evals-freenode-#perl.lst[6991]: use experimental "postderef";
evals/evals-freenode-#perl.lst[6992]: use experimental 'postderef'; my $x; $x->$@ # lovely :S
evals/evals-freenode-#perl.lst[6993]: use experimental qw(postderef); $arr = [[1..3],[4..6],[7..9]]; [ $arr->@[0, 2] ]
evals/evals-freenode-#perl.lst[6994]: use experimental qw(postderef); $hash = {asdf => 'jkl;', zxvc => 'bnm,'}; [ $hash->@{'asdf','zxcv'} ]
evals/evals-freenode-#perl.lst[6995]: use experimental qw( postderef ); my $foo = { bar => [ 1, 2, 3 ] }; [ $foo->{bar}->@* ]
evals/evals-freenode-#perl.lst[6996]: use experimental qw( postderef ); my $foo = { bar => [ 1, 2, 3 ] }; [ $foo->{bar}->*@ ]
evals/evals-freenode-#perl.lst[6997]: use experimental qw(postderef); sub foo { return [1, 2, 3] } if ((my $arr_ref = foo())->@*) { print @$arr_ref }
evals/evals-freenode-#perl.lst[6998]: use experimental qw(signatures); sub foo ($bar, $baz) :proto($$) { .. }
evals/evals-freenode-#perl.lst[6999]: use experimental qw(signatures); sub foo ($bar, $baz) :proto($$) { ... }
evals/evals-freenode-#perl.lst[7000]: use experimental qw(signatures); sub thing($$) { }# but if something mangles the feature hints without knowing what it's doing...
evals/evals-freenode-#perl.lst[7001]: use experimental qw(state); (state $x) = @_; # depends on whether compiling is considered useful?
evals/evals-freenode-#perl.lst[7002]: use experimental 'signatures'; sub foo () { 5 } print foo, "bar";
evals/evals-freenode-#perl.lst[7003]: use experimental 'signatures'; sub foo () { 5 } say foo, "bar";
evals/evals-freenode-#perl.lst[7004]: use experimental 'signatures'; sub foo($bar) {print $bar, $bar}; foo("hola hoops ");
evals/evals-freenode-#perl.lst[7005]: use experimental 'signatures'; sub foo($bar) {print $bar, $bar}; foo("hola hoops ", "error");
evals/evals-freenode-#perl.lst[7006]: use experimental 'signatures'; sub foo (my $str) { $str.$str } print foo "baz", "bar";
evals/evals-freenode-#perl.lst[7007]: use experimental 'signatures'; sub foo ($str) { $str .= "a" } my $s = "x"; foo($s); $s
evals/evals-freenode-#perl.lst[7008]: use experimental 'signatures'; sub foo ($str) { $str.$str } print foo "baz", "bar";
evals/evals-freenode-#perl.lst[7009]: use experimental 'signatures'; sub foo () { undef } print foo // 2; # this is where the parser got choked up, i think
evals/evals-freenode-#perl.lst[7010]: use ExtUtils::ParseXS
evals/evals-freenode-#perl.lst[7011]: use feature 'fc'; index(fc 'foo Ë', fc 'ë');
evals/evals-freenode-#perl.lst[7012]: use feature fc; print fc("ł") cmp fc("z")
evals/evals-freenode-#perl.lst[7013]: use feature keys %feature::feature; say hi::
evals/evals-freenode-#perl.lst[7014]: use feature keys %feature::feature; say 'k'
evals/evals-freenode-#perl.lst[7015]: use feature 'postderef'; []->$#*
evals/evals-freenode-#perl.lst[7016]: use feature 'postderef'; [ ["A".."Z"]->%[3..7] ]
evals/evals-freenode-#perl.lst[7017]: use feature 'postderef'; *foo{SCALAR}->$* = 2; my $bar; $$bar = 3; [ $bar->$****foo{SCALAR}->$* ]
evals/evals-freenode-#perl.lst[7018]: use feature 'postderef'; *foo{SCALAR}->$* = 2; my $bar; $$bar = 3; say $bar->$****foo{SCALAR}->$*;
evals/evals-freenode-#perl.lst[7019]: use feature 'postderef'; for my $i (1..100) {push @a, [(1,1) x 1024*512]}; [scalar(@a), scalar($a[0]->@*)]
evals/evals-freenode-#perl.lst[7020]: use feature 'postderef'; for my $i (1..100) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]
evals/evals-freenode-#perl.lst[7021]: use feature 'postderef'; for my $i (1..100) {push @a, [(1) x 1024*1024]}; [scalar(@a), scalar($a[0]->@*)]
evals/evals-freenode-#perl.lst[7022]: use feature 'postderef'; for my $i (1..50) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]
evals/evals-freenode-#perl.lst[7023]: use feature 'postderef'; map print, [1,2,3]->@*  # or maybe a -, a >, an @ and an *
evals/evals-freenode-#perl.lst[7024]: use feature 'postderef'; my $aref = \['x']; $aref->$*->[0] # or let perlbot help
evals/evals-freenode-#perl.lst[7025]: use feature 'postderef'; my $data = {foo => [qw/hello freenode perl/]}; print for ($data->{foo}->@*); 
evals/evals-freenode-#perl.lst[7026]: use feature 'postderef'; my $x = \42; $x->$*
evals/evals-freenode-#perl.lst[7027]: use feature 'postderef'; no warnings 'experimental::postderef'; sub {42}->&*
evals/evals-freenode-#perl.lst[7028]: use feature 'postderef'; $_->@{qw/a b/} = (1,2) for \my %hash
evals/evals-freenode-#perl.lst[7029]: use feature 'postderef'; $_->@{qw/a b/} = (1,2) for \my %hash; \%hash
evals/evals-freenode-#perl.lst[7030]: use feature 'postderef'; sub lol { say @_; } sub one { (\&lol)->() } sub two { (\&lol)->&* } one(qw(a b)); two(qw(c d));
evals/evals-freenode-#perl.lst[7031]: use feature 'postderef'; use 5.020; my $l = sub { say @_; }; sub one { $l->() } sub two { $l->&* } one(qw(a b)); two(qw(c d));
evals/evals-freenode-#perl.lst[7032]: use feature 'postderef'; use 5.020; sub lol { say @_; } sub one { (\&lol)->() } sub two { (\&lol)->&* } one(qw(a b)); two(qw(c d));
evals/evals-freenode-#perl.lst[7033]: use feature 'postderef';  use List::MoreUtils 'mesh'; my $str = "this is line 1\nthis is line 2\nthis is line 3"; my @lines = map { [ split " ", $_ ] } split /\n/, $str; "@{[ mesh $lines[0]->@*, $lines[1]->@*, $lines[2]->@* ]}"
evals/evals-freenode-#perl.lst[7034]: use feature 'postderef'; $x = [0]; push $x->@*, 1; $x
evals/evals-freenode-#perl.lst[7035]: use feature 'postderef'; (\'you')->$*
evals/evals-freenode-#perl.lst[7036]: use feature qw( current_sub ); sub foo { my ( $foo, $x ); $foo = sub { $x ? ++$x : ( $x = 1 ); __SUB__->() unless $x >= 5; }; $foo->(); return $x; } foo; ### So this doesn't leak memory?
evals/evals-freenode-#perl.lst[7037]: use feature qw(doesntexist);
evals/evals-freenode-#perl.lst[7038]: use feature qw(fc); fc 'ß'
evals/evals-freenode-#perl.lst[7039]: use feature qw(fc); print for fc('ß'), '-', lc('ß');
evals/evals-freenode-#perl.lst[7040]: use feature qw(fc unicode_strings); print fc("ł") cmp fc("z")
evals/evals-freenode-#perl.lst[7041]: use feature qw(fc unicode_strings); use utf8; print fc("ł") cmp fc("z")
evals/evals-freenode-#perl.lst[7042]: use feature qw(say fc); say fc(""); # the core function seems happy enough, so I'd put that down to a bug in the module
evals/evals-freenode-#perl.lst[7043]: use feature qw(say); $_ = '...'; say() # not quite, but just because say/print are special
evals/evals-freenode-#perl.lst[7044]: use feature qw(signatures); sub foo ($bar, $baz) :proto($$) { .. }
evals/evals-freenode-#perl.lst[7045]: use feature qw(state); my $y = 0; sub isatty { state $x = do { print "state init "; ++$y }; $x } [ map  isatty(), 1..3 ] # only once
evals/evals-freenode-#perl.lst[7046]: use feature qw(state); (state $x) = @_;
evals/evals-freenode-#perl.lst[7047]: use feature qw( state ); sub Foo { state %state; my @p = ( [ shift, $state{n} ? q{Nested} : q{First} ] ); { local $state{n} = 1; push @p, Foo( @_ ) if @_ }; if ( $state{n} ) { @p; } else { %state = (); [ @p ]; } }    [  Foo( qw(A B C) ),  Foo( qw(X Y Z) )  ];
evals/evals-freenode-#perl.lst[7048]: use feature 'refaliasing'; for \my %hash ({foo => 'bar'}, {foo => 'baz'}) { print $hash{foo} } #whee
evals/evals-freenode-#perl.lst[7049]: use feature 'refaliasing'; my $x = { foo => 1 }; \my %y = $x; $y{bar} = 2; $x;
evals/evals-freenode-#perl.lst[7050]: use feature 'say'; do { my $line = $_; chomp $line; say $line } for "asdf","asdf\n"
evals/evals-freenode-#perl.lst[7051]: use feature 'say';  say "1 2 3 are", 1, 2, 3;
evals/evals-freenode-#perl.lst[7052]: use feature 'say'; say for @INC
evals/evals-freenode-#perl.lst[7053]: use feature 'say'; say "hi"
evals/evals-freenode-#perl.lst[7054]: use feature 'say'; say 'lo'
evals/evals-freenode-#perl.lst[7055]: use feature 'say'; say q hello worldh;
evals/evals-freenode-#perl.lst[7056]: use feature 'say'; use Digest::MD5 'md5_hex'; say md5_hex("passwd")
evals/evals-freenode-#perl.lst[7057]: use feature 'say'; use List::Util 1.33 'any';
evals/evals-freenode-#perl.lst[7058]: use feature 'say'; use List::Util 1.33 'any'; @array = qw(1 2 3); say "match" if(any{ $_ eq '3'} @array);
evals/evals-freenode-#perl.lst[7059]: use feature 'say'; use List::Util 1.33 'any'; @array = qw(1,2,3); say "match" if(any{ $_ eq '3'} @array);
evals/evals-freenode-#perl.lst[7060]: use feature 'say'; use List::Util 1.33 'any'; @array = qw(1,2,3); say "match" if(any{ $_ eq '4'} @array);
evals/evals-freenode-#perl.lst[7061]: use feature 'signatures'; sub add ($x = (return 0), $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]
evals/evals-freenode-#perl.lst[7062]: use feature 'signatures'; sub add ($x = return 0, $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]
evals/evals-freenode-#perl.lst[7063]: use feature 'state'; state $x = 4; $x
evals/evals-freenode-#perl.lst[7064]: use feature 'switch'; given (0) { when ('0 but true') { print 'wat' } }
evals/evals-freenode-#perl.lst[7065]: use feature 'switch'; given ("0") { when ('0 but true') { print 'wat' } default { print 'nope' } }
evals/evals-freenode-#perl.lst[7066]: use File::Basename; [ fileparse("/foo/bar/baz.anyextensionyoulike", qr/\.[^.]*/) ]
evals/evals-freenode-#perl.lst[7067]: use File::Basename; [ fileparse("/foo/bar/baz.csv", qr/\.[^.]*/) ]
evals/evals-freenode-#perl.lst[7068]: use File::Basename; [ fileparse("foo/bar.baz", qr/[^.]*$/) ]
evals/evals-freenode-#perl.lst[7069]: use File::Basename; [ fileparse("/foo/bar/baz.txt", qr/\.[^.]*/) ]
evals/evals-freenode-#perl.lst[7070]: use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tAr.Bz2}, qr{\.(?:tar.*|zip)}i ];
evals/evals-freenode-#perl.lst[7071]: use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tar.fooBarBaz}, q{tar.*}, q{zip} ];
evals/evals-freenode-#perl.lst[7072]: use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tar.gz}, ( map qq{.$_}, map( qq{tar.$_}, qw(gz bz2 xz Z) ), q{zip} ) ];
evals/evals-freenode-#perl.lst[7073]: use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tar.gz}, q{tar.*}, q{zip} ];
evals/evals-freenode-#perl.lst[7074]: use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tAr.gz}, q{.tar.*}, q{.zip} ];
evals/evals-freenode-#perl.lst[7075]: use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tar.gz.zip},  qr/\.(?:zip|tar\..*?)$/i ];
evals/evals-freenode-#perl.lst[7076]: use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.ZIP}, qr{\.(?:tar.*|zip)}i ];
evals/evals-freenode-#perl.lst[7077]: use File::Basename; fileparse_set_fstype q{MSWin32}; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tAr.gz}, q{.tar.*}, q{.zip} ];
evals/evals-freenode-#perl.lst[7078]: use File::Basename; [map +(fileparse $_, qr/(?<=\.)[^.]+/)[2], "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
evals/evals-freenode-#perl.lst[7079]: use File::Basename; [map +(fileparse $_, qr/[^.]+/)[2], "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
evals/evals-freenode-#perl.lst[7080]: use File::HomeDir; print File::HomeDir->my_data;
evals/evals-freenode-#perl.lst[7081]: use Function::Parameters;
evals/evals-freenode-#perl.lst[7082]: use Function::Parameters; fun foo(A[[) {}
evals/evals-freenode-#perl.lst[7083]: use Function::Parameters; fun foo(:$x) {}  substr B::Deparse->new()->coderef2text(\&foo), 1288
evals/evals-freenode-#perl.lst[7084]: use Function::Parameters qw(:strict); B::Deparse->new->coderef2text(fun (:$x) {})
evals/evals-freenode-#perl.lst[7085]: use Function::Parameters qw(:strict); fun add ($x = return 0, $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]
evals/evals-freenode-#perl.lst[7086]: use Function::Parameters qw((:strict);; fun add ($x = return 0, $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]
evals/evals-freenode-#perl.lst[7087]: use Function::Parameters qw(:strict); fun foo($bar) {print $bar, $bar}; foo("hola hoops ", "error");
evals/evals-freenode-#perl.lst[7088]: use Function::Parameters qw(:strict); fun mynumbs :(@$;$) {}
evals/evals-freenode-#perl.lst[7089]: use Function::Parameters qw(:strict); method new($class: :$name, :$value, :$path = '/', :$domain = undef, :$secure = undef, :$expires = undef, :$max_age = undef, :$httponly = undef) { [$name, $value] }  __PACKAGE__->new(name => "Some_cookie" -value => "Some_value")
evals/evals-freenode-#perl.lst[7090]: use Function::Parameters qw(:strict); method new($class: :$name, :$value, :$path = '/', :$domain = undef, :$secure = undef, :$expires = undef, :$max_age = undef, :$httponly = undef) { [$name, $value] }  __PACKAGE__->new(name => "Some_cookie", Value => "Some_value")
evals/evals-freenode-#perl.lst[7091]: use Function::Parameters qw(:strict); substr B::Deparse->new->coderef2text(fun (:$x) {}), 100
evals/evals-freenode-#perl.lst[7092]: use Function::Parameters qw(:strict); substr B::Deparse->new->coderef2text(fun (:$x) {}), 1470
evals/evals-freenode-#perl.lst[7093]: use Function::Parameters qw(:strict); substr B::Deparse->new->coderef2text(fun (:$x) {}), 200
evals/evals-freenode-#perl.lst[7094]: use Function::Parameters qw(:strict); substr B::Deparse->new->coderef2text( fun ($x, $y) {} ), 1077
evals/evals-freenode-#perl.lst[7095]: use Function::Parameters ':strict'; fun routine($one, $two, $three) {} routine("!");
evals/evals-freenode-#perl.lst[7096]: use Function::Parameters 'strict'; strict foo($x) { $x * 2 } foo 21
evals/evals-freenode-#perl.lst[7097]: use Function::Parameters; use warnings; fun lala :(_;) {}
evals/evals-freenode-#perl.lst[7098]: use Hash::Util; $href = { "foo"=>"bar" }; Hash::Util::lock_ref_keys($href); map { print "\"$_\":$href->{$_}\n" } %{$href}
evals/evals-freenode-#perl.lst[7099]: use Hindsight 20/20;
evals/evals-freenode-#perl.lst[7100]: use HTML::Entities
evals/evals-freenode-#perl.lst[7101]: use HTTP::Tiny; my $http = HTTP::Tiny->new; $http->verify_SSL(1)
evals/evals-freenode-#perl.lst[7102]: use if 0 1 == 0, strict; $foo = $bar; 1
evals/evals-freenode-#perl.lst[7103]: use if 0 1 == 1, strict;
evals/evals-freenode-#perl.lst[7104]: use if 1.0 == 0, strict; $foo = $bar; 1
evals/evals-freenode-#perl.lst[7105]: use if 1+0 == 0, strict; $foo = $bar; 1
evals/evals-freenode-#perl.lst[7106]: use if (1 == 0), strict => ""; $foo = $bar; 1
evals/evals-freenode-#perl.lst[7107]: use if 1 == 0, strict => ""; $foo = $bar; 1
evals/evals-freenode-#perl.lst[7108]: use if 1 == 0, strict; $foo = $bar; 1
evals/evals-freenode-#perl.lst[7109]: use if 1 == 1, strict; 
evals/evals-freenode-#perl.lst[7110]: use if (1 == 1), strict; $foo = $bar; 1
evals/evals-freenode-#perl.lst[7111]: use if 1e0 == 0, strict; $foo = $bar; 1
evals/evals-freenode-#perl.lst[7112]: use if 9;
evals/evals-freenode-#perl.lst[7113]: use Image::Magick; print Image::Magick->QuantumDepth
evals/evals-freenode-#perl.lst[7114]: use integer; 1 / 2
evals/evals-freenode-#perl.lst[7115]: use integer; 5/3
evals/evals-freenode-#perl.lst[7116]: use integer; [ ~-5, -~5 ]
evals/evals-freenode-#perl.lst[7117]: use IO::Handle; my $fh = IO::Handle->new; open $fh , q{>}, \(my $str); $fh->say( q{foo} ); [ ref $fh ];
evals/evals-freenode-#perl.lst[7118]: use IO::Handle; my $io = IO::Handle->new; ilike $io
evals/evals-freenode-#perl.lst[7119]: use IO::Handle; my $io = IO::Handle->new; length $io
evals/evals-freenode-#perl.lst[7120]: use IO::Handle; open my $fh, '>', \my $buffer; ref $fh
evals/evals-freenode-#perl.lst[7121]: use IO::Socket::INET; IO::Socket::INET->new()
evals/evals-freenode-#perl.lst[7122]: use IO::Socket::INET;  my $sock = IO::Socket::INET->new(Timeout => 4, Proto => "tcp" , PeerAddr => "www.gamezstorm.com", PeerPort => 25) or die $!;  for(<$sock>){print $_ ,"\n";}
evals/evals-freenode-#perl.lst[7123]: use IPC::Shm
evals/evals-freenode-#perl.lst[7124]: use iso-8859-1; uc "ñ"
evals/evals-freenode-#perl.lst[7125]: use iso8859-1; uc "ñ"
evals/evals-freenode-#perl.lst[7126]: use iso8859; uc "ñ"
evals/evals-freenode-#perl.lst[7127]: use JSON (); { abc => 123 }->JSON::encode_json
evals/evals-freenode-#perl.lst[7128]: use JSON; encode_json( \%INC );
evals/evals-freenode-#perl.lst[7129]: use JSON; from_json q~ { "a" : "b" } ~
evals/evals-freenode-#perl.lst[7130]: use JSON; @list = ({name => 1}, {name => 2}, {name => 3}, {name => 4}); to_json([grep { $_->{name} > 2 } @list])
evals/evals-freenode-#perl.lst[7131]: use JSON; @list = ({name => 1, x => one}, {name => 2, x => two}, {name => 3, x => three}, {name => 4, x => four}); to_json([map {$_->{x}} grep { $_->{name} > 2 } @list])
evals/evals-freenode-#perl.lst[7132]: use JSON'MaybeXS;
evals/evals-freenode-#perl.lst[7133]: use JSON::MaybeXS; [encode_json [''.1341015082000]]
evals/evals-freenode-#perl.lst[7134]: use JSON::MaybeXS; [encode_json [1341015082000]]
evals/evals-freenode-#perl.lst[7135]: use JSON::MaybeXS; [encode_json 1341015082000]
evals/evals-freenode-#perl.lst[7136]: use JSON::MaybeXS; encode_json { foo => '1.20' }
evals/evals-freenode-#perl.lst[7137]: use JSON::MaybeXS; encode_json { foo => '1.22' }
evals/evals-freenode-#perl.lst[7138]: use JSON::MaybeXS; encode_json { foo => sprintf '%.2f', 1.22 }
evals/evals-freenode-#perl.lst[7139]: use JSON::MaybeXS; JSON()
evals/evals-freenode-#perl.lst[7140]: use JSON::MaybeXS; JSON::MaybeXS->new(allow_nonref => 1, ascii => 0)->encode("\07")
evals/evals-freenode-#perl.lst[7141]: use JSON::MaybeXS; JSON::MaybeXS->new(allow_nonref => 1, ascii => 1)->encode("\x{2603}")
evals/evals-freenode-#perl.lst[7142]: use JSON::MaybeXS; JSON::MaybeXS->new(allow_nonref => 1)->encode("\07")
evals/evals-freenode-#perl.lst[7143]: use JSON::MaybeXS; my $j = JSON::MaybeXS->new(allow_nonref => 1, ascii => 1); [grep { $j->encode(chr($_)) =~ /\\u/ } 0..127]
evals/evals-freenode-#perl.lst[7144]: use JSON::MaybeXS; my $json = JSON::MaybeXS->new(allow_nonref => 1, ascii => 1); my $encoded = $json->encode("\x{2603}"); [$encoded, $json->decode($encoded)]
evals/evals-freenode-#perl.lst[7145]: use JSON::MaybeXS; my $json_str = JSON::MaybeXS->new(allow_nonref => 1, ascii => 1)->encode("\x{2603}"); [$json_str]
evals/evals-freenode-#perl.lst[7146]: use JSON::MaybeXS; my %test = (name => JSON->true); JSON::MaybeXS->new(pretty => 1)->encode(\%test)
evals/evals-freenode-#perl.lst[7147]: use JSON::MaybeXS; my $var = 1341015082000; [encode_json ["$var"]]
evals/evals-freenode-#perl.lst[7148]: use JSON; my $aoh = [{1=>2},{3=>4}];my $str=encode_json($aoh); my $new_aoh = decode_json($str); push @{ $new_aoh  }, {5=>6}; my $new_str = encode_json($new_aoh); $new_str
evals/evals-freenode-#perl.lst[7149]: use JSON; my $var = ~~"0"; encode_json([$var])
evals/evals-freenode-#perl.lst[7150]: use JSON; use strict; my %test = ( name => \1, ); print JSON->new->pretty->encode(\%test);
evals/evals-freenode-#perl.lst[7151]: use JSON::XS; decode_json('["\ud834\udd1e"]')
evals/evals-freenode-#perl.lst[7152]: use less 'abomination';
evals/evals-freenode-#perl.lst[7153]: use Lingua::EN::Numbers qw(num2en); sub isodd {return (num2en shift) =~ /e.?$/} 
evals/evals-freenode-#perl.lst[7154]: use List::MoreUtils 'any'; if (any {$_ eq 'a'}, 'b', 'c') { 1 }
evals/evals-freenode-#perl.lst[7155]: use List::MoreUtils 'firstidx'; sub merge_refs { my $input = shift; return $input unless @_; my @indices; for my $ref (@_) { push @indices, firstidx { $ref == \$_ } @$input }; my $merged = $input->[pop @indices]; unshift @$merged, @{splice @$input, $_, 1} for @indices; return $input } my $x = [ [1,2], [3,4], [5,6,7,8] ]; merge_refs $x, \$x->[0], \$x->[2];
evals/evals-freenode-#perl.lst[7156]: use List::MoreUtils qw(firstidx); my $y = 3; my @list = (1,2,3,4,5,6,7); splice @list, $_, 0, 'above' for grep defined, firstidx { $_ > $y } @list; \@list
evals/evals-freenode-#perl.lst[7157]: use List::MoreUtils qw(uniq); my %x = (x => {a => 1, c => 2}, z => { a => 3 }); my %y = (x => {b => 3}, z => {a => 4}); my %z = %x; for my $k (uniq keys(%x), keys(%y)) { $z{$k}{$_} = $y{$k}{$_} for grep !exists $x{$k}{$_}, keys %{$y{$k}} } \%z
evals/evals-freenode-#perl.lst[7158]: use List::MoreUtils qw/uniq/; [ sort uniq qw/a b c a/ ];
evals/evals-freenode-#perl.lst[7159]: use List::MoreUtils qw/uniq/; [ sort(uniq qw/a b c a/) ];
evals/evals-freenode-#perl.lst[7160]: use List::MoreUtils qw/uniq/; [ sort(uniq(qw/a b c a/)) ];
evals/evals-freenode-#perl.lst[7161]: use List::MoreUtils qw/uniq/; [ uniq qw/a b c a/ ];
evals/evals-freenode-#perl.lst[7162]: use List::MoreUtils qw(zip); $ab = [ "a","b"]; $xyz = ["u","v","a","b","w"]; grep defined, @{ { zip @$xyz, @$xyz } }{@$ab} == @$ab
evals/evals-freenode-#perl.lst[7163]: use List::MoreUtils qw(zip); my @list = qw( AAA BBB CCC ); [ &zip \@list, [('|') x @list - 1] ]
evals/evals-freenode-#perl.lst[7164]: use List::MoreUtils qw(zip); my @list = qw( AAA BBB CCC ); [ zip @list, ('|') x @list - 1 ]
evals/evals-freenode-#perl.lst[7165]: use List::MoreUtils qw(zip); my @list = qw( AAA BBB CCC ); [ &zip(\@list, [('|') x @list - 1]) ]  # hardly worth it
evals/evals-freenode-#perl.lst[7166]: use List::Util 0.0 qw(9999);
evals/evals-freenode-#perl.lst[7167]: use List::Util 0 qw(9999);
evals/evals-freenode-#perl.lst[7168]: use List::Util 1.33 'any';@array = qw(1 2 3); print "match" if(any{ $_ eq '4'} @array);
evals/evals-freenode-#perl.lst[7169]: use List::Util '9999';
evals/evals-freenode-#perl.lst[7170]: use List::Util (9999);
evals/evals-freenode-#perl.lst[7171]: use List::Util 'first';  first { goto HERE } 1, 2, 3; HERE: print "hello"
evals/evals-freenode-#perl.lst[7172]: use List::Util; $List::Util::VERSION
evals/evals-freenode-#perl.lst[7173]: use List::Util 'max';max 2,3;
evals/evals-freenode-#perl.lst[7174]: use List::Util 'max';max 2,3;max(2,3);
evals/evals-freenode-#perl.lst[7175]: use List::Util 'max';  max(4, 9)
evals/evals-freenode-#perl.lst[7176]: use List::Util; my $c = [qw(a b c)]; print "1" if List::Util::any { $_ eq "a" } @{$c}
evals/evals-freenode-#perl.lst[7177]: use List::Util 'product';  product 0, 1
evals/evals-freenode-#perl.lst[7178]: use List::Util () qw(9999);
evals/evals-freenode-#perl.lst[7179]: use List::Util qw(9999);
evals/evals-freenode-#perl.lst[7180]: use List::Util qw(any 9999);
evals/evals-freenode-#perl.lst[7181]: use List::Util qw(any); my @x = qw(a b c); my @y = qw(d e f); for my $_ (@x) { print "found" if any { /b/ } @y } # I know it's in Texas, probably in Tennnessee...
evals/evals-freenode-#perl.lst[7182]: use List::Util qw/first/; --$i if first { $i++; /z/ } qw/foo bar baz/   # even more vomit inducing
evals/evals-freenode-#perl.lst[7183]: use List::Util qw(first); my $y = 3; my @list = (1,2,3,4,5,6,7); $_ = 'above' for grep defined, first { $_ > $y } @list; \@list # ?
evals/evals-freenode-#perl.lst[7184]: use List::Util qw(max); my $str = '( G1 Z0.252 F7200.000 )'; [ max 30, $str =~ /G1 Z(\d+\.\d+)/ ];
evals/evals-freenode-#perl.lst[7185]: use List::Util qw(max); my $str = '( G1 Z0.252 F7200.000 )'; my ($value) = $str =~ /G1 Z(\d+\.\d+)/; max 30, $value
evals/evals-freenode-#perl.lst[7186]: use List::Util qw(min); [ map "$_", \&min, \&List::Util::min ] # Exporter gives the same value for both
evals/evals-freenode-#perl.lst[7187]: use List::Util qw( pairmap ); do { my %pairs; pairmap { push $pairs{$a}, $b; } ( "x", "1", "x", "2", "y", "baz" ); \%pairs; };
evals/evals-freenode-#perl.lst[7188]: use List::Util qw( pairmap ); my %pairs; pairmap { push @{ $pairs{$a} }, $b; } ( "x", "1", "x", "2", "y", "baz" ); \%pairs
evals/evals-freenode-#perl.lst[7189]: use List::Util qw(pairmap); [ pairmap { !($a * !$b) ? 'T' : 'F' } qw(1 1 1 0 0 1 0 0) ]
evals/evals-freenode-#perl.lst[7190]: use List::Util qw(pairmap); [ pairmap { !$a || $b ? 'T' : 'F' } qw(1 1 1 0 0 1 0 0) ]
evals/evals-freenode-#perl.lst[7191]: use List::Util qw(product); say product 1..10;
evals/evals-freenode-#perl.lst[7192]: use List::Util qw(reduce); my @ar = qw /a list of errors/; [reduce {$a." ".$b} @ar]
evals/evals-freenode-#perl.lst[7193]: use List::Util qw(reduce); my @output; reduce { push @output, ($a, $b); $b } qw(1 2 3 4 5); \@output
evals/evals-freenode-#perl.lst[7194]: use List::Util qw(reduce); reduce {$1*$b} 1..10;
evals/evals-freenode-#perl.lst[7195]: use List::Util qw(reduce); reduce {$a*$b} 1..10;
evals/evals-freenode-#perl.lst[7196]: use List::Util qw(sum0); [ map sum0(@$_), grep $_->[0] ** 2 == $_->[1] ** 2 + $_->[2] ** 2, map { my ($x, $y) = @$_; map [ $x, $y, $_ ], 1..$y } map { my $x = $_; map [ $x, $_ ], 1..$x } 1..10 ] # probably wrong, but you can see why the map approach isn't great here
evals/evals-freenode-#perl.lst[7197]: use List::Util qw(sum); chr sum map ord, qw(A B C);
evals/evals-freenode-#perl.lst[7198]: use List::Util qw/sum/; [ sum '92.168.1.1' =~ /(\d+)/g ]
evals/evals-freenode-#perl.lst[7199]: use List::Util qw(sum); sum map ord, qw(A B C);
evals/evals-freenode-#perl.lst[7200]: use List::Util 'reduce';  reduce { die "BOK" } 1
evals/evals-freenode-#perl.lst[7201]: use List::Util 'reduce';  reduce { die "BOK" } 1, 2
evals/evals-freenode-#perl.lst[7202]: use List::Util 'reduce';  reduce { die "BOK" } 1. 2
evals/evals-freenode-#perl.lst[7203]: use List::UtilsBy;
evals/evals-freenode-#perl.lst[7204]: use List::UtilsBy 'bundle_by'; my @array = split '', 'abcdefghijklmnopqrstuvwxyz'; [bundle_by { [@_] } 9, @array]
evals/evals-freenode-#perl.lst[7205]: use List::UtilsBy qw(partition_by); +{ partition_by { $_ % 3 } 1..12 } # perlbot has all the things
evals/evals-freenode-#perl.lst[7206]: use List::UtilsBy qw(sort_by); [ sort_by { $_->{name} } { name => 'x' }, { name => 'y' }, { name => 'z' } ]
evals/evals-freenode-#perl.lst[7207]: use List::UtilsBy qw(zip_by); @a=map{$_%10}zip_by{$_[0]+$_[1]}[9,5,3],[map{9-$_}1,7,6];++@a[-1]; [@a]
evals/evals-freenode-#perl.lst[7208]: use List::UtilsBy 'sort_by'; @topics = qw/alias:topic alias:topic2 topic/; %t =map { s/^alias://r => $_ } sort_by { ! /^alias:/ } @topics; [ values %t ]
evals/evals-freenode-#perl.lst[7209]: use List::UtilsBy 'sort_by'; @topics = qw/alias:topic topic2 topic/; %t =map { (/^alias:/ ? $_ : "alias:$_") => $_ } sort_by { ! /^alias:/ } @topics; \%t
evals/evals-freenode-#perl.lst[7210]: use List::UtilsBy 'sort_by'; @topics = qw/alias:topic topic2 topic/; %t =map { s/^alias://r => $_ } sort_by { ! /^alias:/ } @topics; [ values %t ]
evals/evals-freenode-#perl.lst[7211]: use List::UtilsBy 'sort_by'; @topics = qw/topic topic2 alias:topic/; %t =map { (/^alias:/ ? $_ : "alias:$_") => $_ } sort_by { ! /^alias:/ } @topics; \%t
evals/evals-freenode-#perl.lst[7212]: use List::UtilsBy 'sort_by'; @topics = qw/topic topic2 alias:topic/; %t =map { (/^alias:/ ? $_ : "alias:$_") => $_ } sort_by { /^alias:/ } @topics; \%t
evals/evals-freenode-#perl.lst[7213]: use List::UtilsBy 'zip_by'; my $u = 'ABC'; my $l = 'abc'; join '', zip_by { @_ } map { [split //] } $u, $l
evals/evals-freenode-#perl.lst[7214]: use List::UtilsBy 'zip_by'; my $u = 'ABC'; my $l = 'abc'; join '', zip_by { @_ } [split //, $u], [split //, $l]
evals/evals-freenode-#perl.lst[7215]: use List::Util 'sum'; sum map { 1 / $_ } ( 1,3,5,7,9,11,13,15,17 )
evals/evals-freenode-#perl.lst[7216]: use List::Util 'sum'; sum map { 1 / $_ } ( 1,3,5,7,9,13,15,17,19 )
evals/evals-freenode-#perl.lst[7217]: use List::Util; use strict; use warnings; my $y = max $a, $b; # perl5.20 gives me "Useless use of a variable in void context" there, not sure why this one doesn't
evals/evals-freenode-#perl.lst[7218]: use LWP::UserAgent; my $ua = LWP::UserAgent->new; length $ua
evals/evals-freenode-#perl.lst[7219]: use manager::dedicated::dedicated.fr;
evals/evals-freenode-#perl.lst[7220]: use Math::BigInt
evals/evals-freenode-#perl.lst[7221]: use Math::BigInt; [157 + "9.95" + Math::BigInt->new(13) + 0]
evals/evals-freenode-#perl.lst[7222]: use Math::BigInt; 1e1000
evals/evals-freenode-#perl.lst[7223]: use Math::BigInt; 2790**2753 % 3233
evals/evals-freenode-#perl.lst[7224]: use Math::BigInt; atan2(0, -1);
evals/evals-freenode-#perl.lst[7225]: use Math::BigInt; Math::BigInt->new("3432902008176640045")
evals/evals-freenode-#perl.lst[7226]: use Math::BigInt; my $x = Math::BigInt->new(2000); [ $x->as_hex ]
evals/evals-freenode-#perl.lst[7227]: use Math::BigInt; $x=Math::BigInt->new(4); print $x->bfac();
evals/evals-freenode-#perl.lst[7228]: use Math::BigInt; $x=Math::BigInt->new(4); $y=Math::BigInt->new(2); print $x->bfac(); print $y->bfac();
evals/evals-freenode-#perl.lst[7229]: use Math::Complex; sqrt -1
evals/evals-freenode-#perl.lst[7230]: use Math::Round; round(3.2939232942 * 100) / 100
evals/evals-freenode-#perl.lst[7231]: use Math; sqrt -1;
evals/evals-freenode-#perl.lst[7232]: use MIME::Base64;
evals/evals-freenode-#perl.lst[7233]: use Missing::Thing;
evals/evals-freenode-#perl.lst[7234]: use Module::Build
evals/evals-freenode-#perl.lst[7235]: use Module::Corelist; [ Module::Corelist->first_release( 'experimental' ) ]
evals/evals-freenode-#perl.lst[7236]: use Module::CoreList; [ Module::CoreList->first_release( 'experimental' ) ]
evals/evals-freenode-#perl.lst[7237]: use Mojo::DOM;
evals/evals-freenode-#perl.lst[7238]: use Mojo::DOM; my $dom = Mojo::DOM->new('<html><head></head><body></body></html>'); $dom->at('head')->append_content('<meta content="text/html; charset=utf-8" http-equiv="Content-Type"></meta>'); $dom->to_string
evals/evals-freenode-#perl.lst[7239]: use Mojo::DOM; my $dom = Mojo::DOM->new('<html><head></head><body></body></html>'); $dom->at('head')->append('<meta content="text/html; charset=utf-8" http-equiv="Content-Type"></meta>'); $dom
evals/evals-freenode-#perl.lst[7240]: use Mojo::DOM; my $dom = Mojo::DOM->new('<html><head></head><body></body></html>'); $dom->at('head')->append('<meta content="text/html; charset=utf-8" http-equiv="Content-Type"></meta>'); $dom->to_string
evals/evals-freenode-#perl.lst[7241]: use Mojo::DOM; use Mojo::DOM::CSS; use Mojo::Collection;
evals/evals-freenode-#perl.lst[7242]: use Mojo::JSON; my $var = 1341015082000; [encode_json ["$var"]]
evals/evals-freenode-#perl.lst[7243]: use Mojo::Util 'punycode_decode'; encode 'UTF-8', punycode_decode 'wkr'
evals/evals-freenode-#perl.lst[7244]: use Mojo::Util 'punycode_decode'; encode 'UTF-8', punycode_decode zkr
evals/evals-freenode-#perl.lst[7245]: use Mojo::Util 'punycode_encode', 'decode'; punycode_encode decode('UTF-8', '❄')
evals/evals-freenode-#perl.lst[7246]: use Mojo::Util 'punycode_encode'; punycode_encode decode('UTF-8', '❄')
evals/evals-freenode-#perl.lst[7247]: use Moo;
evals/evals-freenode-#perl.lst[7248]: use Moose ()
evals/evals-freenode-#perl.lst[7249]: use Moose;
evals/evals-freenode-#perl.lst[7250]: use Moose; 7;
evals/evals-freenode-#perl.lst[7251]: use Net::HTTP::Spore;
evals/evals-freenode-#perl.lst[7252]: use Number::Format qw(:subs :vars); $THOUSANDS_SEP = '.'; my $a = 123456789; say format_number($a);
evals/evals-freenode-#perl.lst[7253]: use open IN  => ":crlf", OUT => ":bytes"; [ ${^OPEN} ]
evals/evals-freenode-#perl.lst[7254]: use or die perl;
evals/evals-freenode-#perl.lst[7255]: use overload q|""| => sub { 42 }; my @a; $a[42] = 'forty two'; [ $a[bless {}, 'main'] ]
evals/evals-freenode-#perl.lst[7256]: use overload qw,"",=> sub { die }; bless {}, bless []; 42;
evals/evals-freenode-#perl.lst[7257]: use overload '""' => sub { "" }, "bool" => sub { 1 }; my $foo = bless []; if( $foo ) { print "_${foo}" } else { print "aww" }
evals/evals-freenode-#perl.lst[7258]: use overload '@{}' => sub { print 'converting to array'; ['42'] }; my $foo; bless \$foo; (\$foo)->[0];
evals/evals-freenode-#perl.lst[7259]: use overload '@{}' => sub { print 'converting to array'; ['42'] }; my $foo; bless \$foo; primt (\$foo)->[0];
evals/evals-freenode-#perl.lst[7260]: use overload '@{}' => sub { print 'converting to array'; ['42'] }; my $foo; bless \$foo; print + (\$foo)->[0];
evals/evals-freenode-#perl.lst[7261]: use overload '+' => sub { print "foo" }; my $x = bless []; $x + 2;
evals/evals-freenode-#perl.lst[7262]: use overload '@{}' => sub { say 'converting to array'; ['42'] }; my $foo; bless \$foo; (\$foo)->[0];
evals/evals-freenode-#perl.lst[7263]: use overload '""' => sub { shift @{ shift() } || '' }; $, = bless [' another ', ' hacker']; print qw(Just Perl ,);
evals/evals-freenode-#perl.lst[7264]: use overload '""' => sub { "wibble" }; $x = []; bless $x; $y = []; bless $y, $x; ref $y
evals/evals-freenode-#perl.lst[7265]: use Perl;
evals/evals-freenode-#perl.lst[7266]: use POSIX; floor((3.2949232942 + 0.005) * 100)/100
evals/evals-freenode-#perl.lst[7267]: use POSIX; floor((3.2959232942 + 0.005) * 100)/100
evals/evals-freenode-#perl.lst[7268]: use POSIX 'mktime'; print localtime mktime(0,0,0, 128, 0, 2015-1900)
evals/evals-freenode-#perl.lst[7269]: use POSIX 'mktime'; print scalar localtime mktime(0,0,0, 128, 0, 2015-1900)
evals/evals-freenode-#perl.lst[7270]: use POSIX 'mktime'; scalar CORE::localtime mktime( 0,0,0, 1234, -123, 81 )
evals/evals-freenode-#perl.lst[7271]: use POSIX 'mktime'; scalar localtime mktime( 0,0,0, 1234, -123, 81 )
evals/evals-freenode-#perl.lst[7272]: use POSIX 'mktime'; scalar localtime mktime(0,0,0, 128, 0, 2015-1900)
evals/evals-freenode-#perl.lst[7273]: use POSIX 'mktime'; unde" (13 lines) at http://scsys.co.uk:8002/408020
evals/evals-freenode-#perl.lst[7274]: use POSIX; print strftime('%z', localtime());
evals/evals-freenode-#perl.lst[7275]: use POSIX qw(atan); 4*atan(1) # if you disapprove of passing multiple parameters to a function, there are alternatives
evals/evals-freenode-#perl.lst[7276]: use POSIX qw(floor); floor(5/3)
evals/evals-freenode-#perl.lst[7277]: use POSIX qw/locale_h/; say setlocale(LC_TIME, "ja_JP.utf-8");
evals/evals-freenode-#perl.lst[7278]: use POSIX qw/locale_h strftime/; setlocale(LC_TIME, "ja_JP.utf-8"); strftime("%b %d", localtime())
evals/evals-freenode-#perl.lst[7279]: use POSIX qw/locale_h strftime/; setlocale(LC_TIME, "ja_JP.utf-8"); strftime("%c", localtime())
evals/evals-freenode-#perl.lst[7280]: use POSIX qw(mktime); @x = localtime; $x[3] -= 69; "" . scalar localtime mktime @x
evals/evals-freenode-#perl.lst[7281]: use POSIX qw(mktime); @x = localtime; $x[7] -= 69; mktime @x
evals/evals-freenode-#perl.lst[7282]: use POSIX qw( modf ); my $n = 1.2345; sprintf q{%02d%s}, reverse map { s/^0+//r } modf $n; ### leobut
evals/evals-freenode-#perl.lst[7283]: use POSIX qw( modf ); my $n = 1; sprintf q{%02d%s}, reverse map { s/^0+//r } modf $n; ### leobut
evals/evals-freenode-#perl.lst[7284]: use POSIX qw(strftime); [map strftime('%H:%M', gmtime $_), map 15*60*$_, 1 .. 10]
evals/evals-freenode-#perl.lst[7285]: use POSIX qw(strftime mktime); my @time = gmtime; $time[3] -= $time[6]; strftime '%Y-%m-%d', @time; # give me a sunday
evals/evals-freenode-#perl.lst[7286]: use POSIX qw(strftime); my $midnight_today = mktime 0,0,0,(localtime)[3..8]; my $time_offset = ((18 * 60) + 38)*60; strftime '%Y-%m-%d %H:%M:%S', gmtime $midnight_today + $time_offset
evals/evals-freenode-#perl.lst[7287]: use POSIX qw(strftime); strftime '%H:%M:%S', gmtime(260)
evals/evals-freenode-#perl.lst[7288]: use POSIX qw(strftime); strftime '%H:%M:%S', gmtime 97462
evals/evals-freenode-#perl.lst[7289]: use POSIX qw(strftime); strftime "%Y%m%d%H.%M", localtime(time - 3600)
evals/evals-freenode-#perl.lst[7290]: use POSIX qw(strftime); strftime '%Y.%m.%d.%H.%M.%S', localtime
evals/evals-freenode-#perl.lst[7291]: use POSIX qw(strftime); strftime "%Y-%m-%d", localtime
evals/evals-freenode-#perl.lst[7292]: use POSIX qw/strftime/; strftime "%Y-%m-%d", localtime 0;
evals/evals-freenode-#perl.lst[7293]: use POSIX qw(strftime); strftime "%Y-%m-%d", localtime time - 3600
evals/evals-freenode-#perl.lst[7294]: use POSIX qw(sysconf); [ sysconf(_SC_PAGE_SIZE) ]
evals/evals-freenode-#perl.lst[7295]: use POSIX; setlocale(LC_NUMERIC, "de_DE"); sprintf("%.2f", 23.45)
evals/evals-freenode-#perl.lst[7296]: use POSIX 'strftime'; [strftime '+%d-%m-%Y']
evals/evals-freenode-#perl.lst[7297]: use POSIX 'strftime'; [strftime '%d-%m-%Y', localtime]
evals/evals-freenode-#perl.lst[7298]: use POSIX 'strftime'; [strftime '+%d-%m-%Y', localtime]
evals/evals-freenode-#perl.lst[7299]: use POSIX::strptime=strptime; strptime 'dec', '%b';
evals/evals-freenode-#perl.lst[7300]: use POSIX::strptime 'strptime'; strptime 'dec', '%b';
evals/evals-freenode-#perl.lst[7301]: use Psychic::Hotline;
evals/evals-freenode-#perl.lst[7302]: use Quote::Code
evals/evals-freenode-#perl.lst[7303]: use Quote::Code; qc{!}
evals/evals-freenode-#perl.lst[7304]: use Quote::Code; [ qcw< a {$_} b > ]
evals/evals-freenode-#perl.lst[7305]: [ 'user:anything-else:' !~ /^user:!!:$/ ]
evals/evals-freenode-#perl.lst[7306]: use re 'debug'; /^+/
evals/evals-freenode-#perl.lst[7307]: use re 'debug'; /a(bc)+/o;
evals/evals-freenode-#perl.lst[7308]: use Regexp::Assemble;
evals/evals-freenode-#perl.lst[7309]: use Regexp::Common; ("12 bananas buys you 0.1231e10 ruby" =~ /$RE{num}{real}/g)[1]
evals/evals-freenode-#perl.lst[7310]: use Regexp::Common; print "ok" if ("foo bar)" eq "(foo bar))" =~ s/($RE{balanced}{-parens => "()"})/$1/r);
evals/evals-freenode-#perl.lst[7311]: use Regexp::Common qw/net/; my $ip = q(100.10.1.101); [$ip =~ /$RE{net}{IPv4}/]
evals/evals-freenode-#perl.lst[7312]: use Regexp::Common qw/net/; my $ip = q(100.10.1.101); [$ip =~ /\[$RE{net}{IPv4}\]/]
evals/evals-freenode-#perl.lst[7313]: use Regexp::Common qw/net/; my $ip = q(100.10.1.101); [$ip =~ /($RE{net}{IPv4})/] # I meant that
evals/evals-freenode-#perl.lst[7314]: use Regexp::Common qw( net ); $_ = q(00:11:22:33:44:55); if (/$RE{net}{MAC}{-keep}/) { print "<b>$3:$4</b>"; }
evals/evals-freenode-#perl.lst[7315]: use Return::MultiLevel;
evals/evals-freenode-#perl.lst[7316]: [ 'user:!!:' !~ /^user:!!:$/ ]
evals/evals-freenode-#perl.lst[7317]: 'user' =~ /user(?!-agent)/
evals/evals-freenode-#perl.lst[7318]: use Scalar::Util
evals/evals-freenode-#perl.lst[7319]: use Scalar::Util 'blessed'; my $re = qr/hai/; [blessed $re]
evals/evals-freenode-#perl.lst[7320]: use Scalar::Util 'looks_like_number'; looks_like_number '10%s'
evals/evals-freenode-#perl.lst[7321]: use Scalar::Util 'looks_like_number'; looks_like_number('123abc   ')
evals/evals-freenode-#perl.lst[7322]: use Scalar::Util 'looks_like_number'; looks_like_number('     9') ? 1 : 0
evals/evals-freenode-#perl.lst[7323]: use Scalar::Util 'looks_like_number'; my $s = qq{ 123 4.5 0xFF 5E7 }; [ grep looks_like_number $_, split /\s+/, $s ];
evals/evals-freenode-#perl.lst[7324]: use Scalar::Util 'looks_like_number'; my $s = qq{ 123 4.5 0xFF 5E7 }; [ map 0+$_, grep looks_like_number $_, split /\s+/, $s ];
evals/evals-freenode-#perl.lst[7325]: use Scalar::Util qw(dualvar); my $foo = dualvar 42, ""; if ($foo) { print "_${foo}_"; } else { print "aww"; }
evals/evals-freenode-#perl.lst[7326]: use Scalar::Util qw/dualvar/; my $i = dualvar 1, 'forty two'; my @a = qw/one two/; [ $a[ $i ], $a[ "$i" ] ]; # fun :)
evals/evals-freenode-#perl.lst[7327]: use Scalar::Util qw(dualvar); my $x = dualvar 12, 'twelve'; my $y = $x; [ 0+$y, "$y" ] # so something like this
evals/evals-freenode-#perl.lst[7328]: use Scalar::Util qw/dualvar/; my $x = dualvar 42, 'forty two'; [$x+0, "$x"]
evals/evals-freenode-#perl.lst[7329]: use Scalar::Util qw/dualvar/; my $x = dualvar 42, 'forty two'; [$x+0, "$x"]>
evals/evals-freenode-#perl.lst[7330]: use Scalar::Util qw/dualvar/; $x = dualvar 42, 'foo'; [ $x.'', $x+0 ]
evals/evals-freenode-#perl.lst[7331]: use Scalar::Util qw(looks_like_number); looks_like_number '4'
evals/evals-freenode-#perl.lst[7332]: use Scalar::Util qw(looks_like_number); looks_like_number 'infinity' ? '\o/' : '/o\\'
evals/evals-freenode-#perl.lst[7333]: use Scalar::Util qw(looks_like_number); looks_like_number 'Inf'  # wat
evals/evals-freenode-#perl.lst[7334]: use Scalar::Util qw(looks_like_number); looks_like_number 'nan'
evals/evals-freenode-#perl.lst[7335]: use Scalar::Util qw(looks_like_number); looks_like_number 'NAN'
evals/evals-freenode-#perl.lst[7336]: use Scalar::Util qw(looks_like_number); looks_like_number 'nandos';
evals/evals-freenode-#perl.lst[7337]: use Scalar::Util qw/looks_like_number/; [ looks_like_number 'sNan' ]
evals/evals-freenode-#perl.lst[7338]: use Scalar::Util qw(looks_like_number); +{ map { $_ => looks_like_number $_ ? q{Yes} : q{No} } 0, 123.456, 10.6E4, q{abc}, q{FF}, q{0xFF}, 0xFF, +23, "-32" }; ### Seems to fill my needs. I'm wondering if there are any gotchas.
evals/evals-freenode-#perl.lst[7339]: use Scalar::Util qw(refaddr); my $meow = []; [refaddr($meow), refaddr(\@{$meow})]
evals/evals-freenode-#perl.lst[7340]: use Scalar::Util qw( refaddr); sub foo { } my $foo = \&foo; my $bar = \&bar; [ refaddr $foo eq refaddr $bar ]
evals/evals-freenode-#perl.lst[7341]: use Scalar::Util qw/reftype blessed/; my $obj = bless {}, 'ARRAY'; my $obj2 = bless {}, 'Foo'; { obj => [ ref($obj), reftype($obj), blessed($obj) ], obj2 => [ref($obj2), reftype($obj2), blessed($obj2)], ref => [ ref([]), reftype([]), blessed([]) ]
evals/evals-freenode-#perl.lst[7342]: use Scalar::Util qw/reftype blessed/; my $obj = bless {}, 'ARRAY'; my $obj2 = bless {}, 'Foo'; { obj => [ ref($obj), reftype($obj), blessed($obj) ], obj2 => [ref($obj2), reftype($obj2), blessed($obj2)], ref => [ ref([]), reftype([]), blessed([]) ] }
evals/evals-freenode-#perl.lst[7343]: use Scalar::Util qw(reftype); my $x = bless [7,8,9], q{FOO}; [ qq{$x}, ref $x, reftype $x ]; # Cool :)
evals/evals-freenode-#perl.lst[7344]: use Scalar::Util qw,reftype,; [ reftype *STDOUT{IO} ]
evals/evals-freenode-#perl.lst[7345]: use Scalar::Util qw(weaken); my $v; $v = sub { my $x = $v; 1 }; $v->(); weaken $v; die if $v # dropping the extra var and moving weaken() after the call looks okay to me
evals/evals-freenode-#perl.lst[7346]: use Scalar::Util 'refaddr'; my $foo = []; my $addr = sprintf '%x', refaddr $foo; my %bar = ($foo => 1, "ARRAY(0x$addr)" => 1); \%bar
evals/evals-freenode-#perl.lst[7347]: use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $h2={foo=>43}; %$h=%$h2; [ refaddr($h), refaddr($h2), $h ]
evals/evals-freenode-#perl.lst[7348]: use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $h2={foo=>43}; %$h=%h2; [ refaddr($h), refaddr($h2), $h ]
evals/evals-freenode-#perl.lst[7349]: use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $hadd1 = refaddr $h; my $h2={foo=>43}; mh $h2add1 = refaddr $h2; %$h=%h2; [ $hadd1, $h2add1, refaddr($h), refaddr($h2), $h ]
evals/evals-freenode-#perl.lst[7350]: use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $hadd1 = refaddr $h; my $h2={foo=>43}; my $h2add1 = refaddr $h2; %$h=%$h2; [ $hadd1, $h2add1, refaddr($h), refaddr($h2), $h ]
evals/evals-freenode-#perl.lst[7351]: use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $hadd1 = refaddr $h; my $h2={foo=>43}; my $h2add1 = refaddr $h2; %$h=%h2; [ $hadd1, $h2add1, refaddr($h), refaddr($h2), $h ]
evals/evals-freenode-#perl.lst[7352]: use Scalar::Util 'refaddr'; my $h = { foo => 42 }; [ refaddr($h), refaddr(\%{$h}) ]
evals/evals-freenode-#perl.lst[7353]: use Scalar::Util 'reftype'; eval: $x = 'three'; $y = \$x; [ reftype $x, reftype $y ] #as contrast
evals/evals-freenode-#perl.lst[7354]: use Scalar::Util 'reftype'; eval: $x = 'three'; $y = \$x; $x = \$x; [ reftype $x, reftype $y ]
evals/evals-freenode-#perl.lst[7355]: use Scalar::Util 'reftype'; my $r = bless [], "HASH";  reftype $r
evals/evals-freenode-#perl.lst[7356]: use Scalar::Util 'reftype'; [ ref undef, reftype undef ]
evals/evals-freenode-#perl.lst[7357]: use Scalar::Util 'weaken'; my $foo = {}; my $bar = {}; my $closure; { my ($foo2, $bar2) = ($foo, $bar); $closure = sub { $foo2 }; } weaken $foo; weaken $bar; [$foo, $bar]
evals/evals-freenode-#perl.lst[7358]: use signatures; sub foo () { 5 } say foo, "bar";
evals/evals-freenode-#perl.lst[7359]: use Socket 'inet_aton'; [unpack 'N', inet_aton '92.168.1.1']
evals/evals-freenode-#perl.lst[7360]: use Socket 'pack_sockaddr_in6'; length pack_sockaddr_in6( 80, "\0" x 16 )
evals/evals-freenode-#perl.lst[7361]: use Socket::pack_sockaddr_in6; length pack_sockaddr_in6( 80, "\0" x 16 )
evals/evals-freenode-#perl.lst[7362]: use Socket qw(inet_pton AF_INET6); my $ip_addr = inet_pton(AF_INET6, "::ffff:127.0.0.1"); $ip_addr
evals/evals-freenode-#perl.lst[7363]: use Socket;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in(8989,inet_aton("107.191.117.124")))){print S hi};
evals/evals-freenode-#perl.lst[7364]: use Storable qw,dclone,; my @arr = ([], []); my $copyref = dclone(\@arr); $copyref->[0][0] = 3; \@arr
evals/evals-freenode-#perl.lst[7365]: use Storable qw(nfreeze thaw); my $x = 42; print thaw(nfreeze(\$x)); # easier to see the issue if you just leave out the pack/unpack, though
evals/evals-freenode-#perl.lst[7366]: use Storable; use strict; use warnings; my $x = { A => 123, B => q/foo/, C => [ qw(x y z) ] }; my $y = Storable::dclone $x; [ $x, $y ];
evals/evals-freenode-#perl.lst[7367]: use Storable; use strict; use warnings; my $x = { A => 123, B => qr/foo/, C => [ qw(x y z) ] }; my $y = Storable::dclone $x; [ $x, $y ];
evals/evals-freenode-#perl.lst[7368]: use Storable; use strict; use warnings; my $x = { A => 123, B => qr/foo/, C => [ qw(x y z) ] }; my $y = Storable::dclone $x; [ $x, $y ]; ### Why is it so hard to clone Regexp objects?
evals/evals-freenode-#perl.lst[7369]: use strict;
evals/evals-freenode-#perl.lst[7370]: use strict; [ $$$ ]
evals/evals-freenode-#perl.lst[7371]: use strict; [ %~, @/, $= ]
evals/evals-freenode-#perl.lst[7372]: use strict; 0->[0];
evals/evals-freenode-#perl.lst[7373]: use strict; &{0 == &{0 == 0}} * 0
evals/evals-freenode-#perl.lst[7374]: ${use strict; 1;};
evals/evals-freenode-#perl.lst[7375]: use strict; ${;1}
evals/evals-freenode-#perl.lst[7376]: use strict; ${1}
evals/evals-freenode-#perl.lst[7377]: use strict; ${1 + 1}
evals/evals-freenode-#perl.lst[7378]: use strict; 1234->{key}
evals/evals-freenode-#perl.lst[7379]: use strict; "${ 12+45 }"
evals/evals-freenode-#perl.lst[7380]: use strict; ${2}
evals/evals-freenode-#perl.lst[7381]: use strict; 404->();
evals/evals-freenode-#perl.lst[7382]: use strict; *4 = sub { 'ok' }; &{4};
evals/evals-freenode-#perl.lst[7383]: use strict; *4 = sub { 'ok' }; main->${ \4 };
evals/evals-freenode-#perl.lst[7384]: use strict; @5 = "hi";
evals/evals-freenode-#perl.lst[7385]: use strict; @5 = "hi"; \@5
evals/evals-freenode-#perl.lst[7386]: use strict; @a
evals/evals-freenode-#perl.lst[7387]: use strict; $a->[0];
evals/evals-freenode-#perl.lst[7388]: use strict; a->[0]
evals/evals-freenode-#perl.lst[7389]: use strict; $a = "it works"; print "${chr 97}"
evals/evals-freenode-#perl.lst[7390]: use strict; *{$::{Altreus}}{SCALAR}
evals/evals-freenode-#perl.lst[7391]: use strict; $ARGV
evals/evals-freenode-#perl.lst[7392]: use strict; "asd" ~~ s/^[:ascii:]]//g;
evals/evals-freenode-#perl.lst[7393]: use strict; "asd" ~~ s/^[:ascii:]]/g;
evals/evals-freenode-#perl.lst[7394]: use strict; @b = 42;
evals/evals-freenode-#perl.lst[7395]: use strict; BEGIN { package Zomg; *::foo = \$::foo; }  $foo = 42;
evals/evals-freenode-#perl.lst[7396]: use strict; blargh
evals/evals-freenode-#perl.lst[7397]: use strict; blargh()
evals/evals-freenode-#perl.lst[7398]: use strict; config
evals/evals-freenode-#perl.lst[7399]: use strict; defined (my $thing = $_[0]) or $thing = 'default'; $thing;
evals/evals-freenode-#perl.lst[7400]: use strict; @F = 42;
evals/evals-freenode-#perl.lst[7401]: use strict \&{"foo"}
evals/evals-freenode-#perl.lst[7402]: use strict; $foo
evals/evals-freenode-#perl.lst[7403]: use strict; \&{"foo"}
evals/evals-freenode-#perl.lst[7404]: use strict; [ Foo ]
evals/evals-freenode-#perl.lst[7405]: use strict; $foo = 'bar'; ++$$foo; $bar
evals/evals-freenode-#perl.lst[7406]: use strict; grep my $x = 1, 1, 2, 3; $x
evals/evals-freenode-#perl.lst[7407]: use strict; {{@{["I get it now"=>2, bar=>3]}}}->{"I get it now"}
evals/evals-freenode-#perl.lst[7408]: use strict; {{@{["I get it now"=>2, bar=>3]}}}{"I get it now"}
evals/evals-freenode-#perl.lst[7409]: use strict; ${{@{["I get it now"=>2, bar=>3]}}}{"I get it now"}
evals/evals-freenode-#perl.lst[7410]: use strict; +{ @{["I get it now"=>2, bar=>3]} }->{"I get it now"}
evals/evals-freenode-#perl.lst[7411]: use strict; ${ { @{["I get it now"=>'So this takes an arrayref, converts it to a array, then converts it to a hashref which is needed index the key because a hashref puts it into a hash context.  %{@a} does not work because % expects a "scalar" like a hashref or an arrayref (same with @), so you have to %{ {@a} }.', bar=>3]} } }{"I get it now"}
evals/evals-freenode-#perl.lst[7412]: use strict; $INC
evals/evals-freenode-#perl.lst[7413]: use strict; keys (%{ 'dave' => 1, 'bob' => 2 });
evals/evals-freenode-#perl.lst[7414]: use strict; [ map { my $foo if 0; ++$foo } 1 .. 10 ]
evals/evals-freenode-#perl.lst[7415]: use strict; my $a = {a=>"BLA", b=>"BLO"}; print "$k2:$v2\n" while((my($k2,$v2) = each %$a);
evals/evals-freenode-#perl.lst[7416]: use strict; my $action = "foo"; &{$action}()
evals/evals-freenode-#perl.lst[7417]: use strict; my $action = "foo"; &{\&{$action}}()
evals/evals-freenode-#perl.lst[7418]: use strict; my $bar; (my $foo, $bar) = 1 .. 2;
evals/evals-freenode-#perl.lst[7419]: use strict; my $cat, $dog;
evals/evals-freenode-#perl.lst[7420]: use strict; my $diff=todayDay-serviceEndDay;
evals/evals-freenode-#perl.lst[7421]: use strict; (my $foo, $bar) = ''
evals/evals-freenode-#perl.lst[7422]: use strict; my $foo = 'bar' and $foo
evals/evals-freenode-#perl.lst[7423]: use strict; my %foo; %{ 'foo' }
evals/evals-freenode-#perl.lst[7424]: use strict; my %foo; %{ foo }
evals/evals-freenode-#perl.lst[7425]: use strict; my %foo; %{ foo; }
evals/evals-freenode-#perl.lst[7426]: use strict; my $foo; $foo = sub { return $foo };
evals/evals-freenode-#perl.lst[7427]: use strict; (my $foo, my $bar) = 1 .. 2;
evals/evals-freenode-#perl.lst[7428]: use strict; my $foo = sub { 'hi there!' }; $foo->()
evals/evals-freenode-#perl.lst[7429]: use strict; my $foo = sub { return $foo };
evals/evals-freenode-#perl.lst[7430]: use strict; my %hash = (one => 'foo'); sub bar { my $href = @_; $href->{one} = 'baz'; } bar(\%hash);  [ %hash ]
evals/evals-freenode-#perl.lst[7431]: use strict; @{\my %hash}{qw(a b)} = (1, 2); \%hash
evals/evals-freenode-#perl.lst[7432]: use strict; my %hash = (thing => SOME_CONSTANT); sub SOME_CONSTANT { 5 }; $hash{thing}
evals/evals-freenode-#perl.lst[7433]: use strict; my $h; [ (delete $h->{foo}), $h ]
evals/evals-freenode-#perl.lst[7434]: use strict; my $h; [ delete $h->{foo}, %$h ]
evals/evals-freenode-#perl.lst[7435]: use strict; my $h; [ $h and %$h ]
evals/evals-freenode-#perl.lst[7436]: use strict; my $h; [ scalar %$h ]
evals/evals-freenode-#perl.lst[7437]: use strict; { my $i = 0; } $i
evals/evals-freenode-#perl.lst[7438]: use strict; my $new = "foo"; print $nwe;
evals/evals-freenode-#perl.lst[7439]: use strict; my $params; my $student; my $search_name = $params->{name} && $student->name =~ /\Q$search_name/i
evals/evals-freenode-#perl.lst[7440]: use strict; my %test = ( name => true, );
evals/evals-freenode-#perl.lst[7441]: use strict; my $x = 'code'; $$x;
evals/evals-freenode-#perl.lst[7442]: use strict; my %x = (-+CONSTANT => 123); [keys %x]
evals/evals-freenode-#perl.lst[7443]: use strict; my %x = (-CONSTANT => 123); [keys %x]
evals/evals-freenode-#perl.lst[7444]: use strict; my %x = (+CONSTANT => 123); [keys %x]
evals/evals-freenode-#perl.lst[7445]: use strict; my %x = (+CONSTANT => 123); keys %x
evals/evals-freenode-#perl.lst[7446]: use strict; my %x = (+CONSTANT => 123); %x
evals/evals-freenode-#perl.lst[7447]: use strict; my $x if $x || 1;
evals/evals-freenode-#perl.lst[7448]: use strict; my $x = 'nope'; use warnings my $x = 'all'; $x
evals/evals-freenode-#perl.lst[7449]: use strict; my @x =  qw(1 2); undef @x; push @x,1;
evals/evals-freenode-#perl.lst[7450]: use strict; my %x; $x[1] = 123;
evals/evals-freenode-#perl.lst[7451]: use strict; my $x->{y} = $x;
evals/evals-freenode-#perl.lst[7452]: use strict; my ($x, $y) = ($y, $x);
evals/evals-freenode-#perl.lst[7453]: use strict; package foo; sub bar { our $baz; package fizzbuz; "[". ++$baz . "]" }; [ bar(), bar()  ]
evals/evals-freenode-#perl.lst[7454]: use strict; package foo; sub bar { our $baz; package fizzbuz; "[". ++$baz . "]" }; [ bar(), bar(), $baz ]
evals/evals-freenode-#perl.lst[7455]: use strict; package foo; sub bar { our $baz; package fizzbuz; "[". ++$baz . "]" }; [ bar(), bar(), $foo::baz ]
evals/evals-freenode-#perl.lst[7456]: use strict; package Foo; use B '@optype'; package Bar; [ @optype ]
evals/evals-freenode-#perl.lst[7457]: use strict; package Foo; use B '@optype'; package Foo; [ @optype ]
evals/evals-freenode-#perl.lst[7458]: use strict; print "${chr(24)}"
evals/evals-freenode-#perl.lst[7459]: use strict; print foo::
evals/evals-freenode-#perl.lst[7460]: use strict; print foo::, bar:: ;
evals/evals-freenode-#perl.lst[7461]: use strict; print(foo::,"\n");
evals/evals-freenode-#perl.lst[7462]: use strict; print 'hi' if my $x = 1;
evals/evals-freenode-#perl.lst[7463]: use strict; print STDOUT:: foo:: ;
evals/evals-freenode-#perl.lst[7464]: use 'strict'; print $x;
evals/evals-freenode-#perl.lst[7465]: use strict qw(subs): use warnings;
evals/evals-freenode-#perl.lst[7466]: use strict; @% = qw(x y z); [ \@%, "@%" ] # doesn't even seem to interpolate in a string
evals/evals-freenode-#perl.lst[7467]: use strict "refs"; %{""}
evals/evals-freenode-#perl.lst[7468]: use strict; require foo.pl;
evals/evals-freenode-#perl.lst[7469]: use strict; "string"->{key}
evals/evals-freenode-#perl.lst[7470]: use strict; ${\"string"}->{key}  # why is this different
evals/evals-freenode-#perl.lst[7471]: use strict; sub AUTOLOAD { our $AUTOLOAD; print "[$AUTOLOAD]" }; foo();
evals/evals-freenode-#perl.lst[7472]: use strict; sub AUTOLOAD { our $AUTOLOAD; print "[$AUTOLOAD]" }; my $obj = bless []; $obj->foo();
evals/evals-freenode-#perl.lst[7473]: use strict; sub AUTOLOAD { print "[$AUTOLOAD]" }; foo();
evals/evals-freenode-#perl.lst[7474]: use strict; sub AUTOLOAD { print "[$main::AUTOLOAD]" }; foo();
evals/evals-freenode-#perl.lst[7475]: use strict; sub config { return "meow" } config
evals/evals-freenode-#perl.lst[7476]: use strict; sub Foo { "Bar" }; [ Foo ]
evals/evals-freenode-#perl.lst[7477]: use strict; sub foo { 'foohoo' } my $str = 'foo'; __PACKAGE__->can($str)->()
evals/evals-freenode-#perl.lst[7478]: use strict; sub foo { quux(); } # Grinnz_ I think he means that all his subs don't actually get called..
evals/evals-freenode-#perl.lst[7479]: use strict; sub foo { return false; }
evals/evals-freenode-#perl.lst[7480]: use strict; sub lala { 'hej' } my $name = 'lala'; my $ref = \&$name; $ref->()
evals/evals-freenode-#perl.lst[7481]: use strict; subname();
evals/evals-freenode-#perl.lst[7482]: use strict; subname(); { no strict 'refs'; *{__PACKAGE__ . "::subname"} = sub {1} }
evals/evals-freenode-#perl.lst[7483]: use strict; sub SOME_CONSTANT; my %hash = (thing => SOME_CONSTANT); sub SOME_CONSTANT { 5 }; $hash{thing}
evals/evals-freenode-#perl.lst[7484]: use strict; sub what { my ($foo, @_) = @_; \@_ } what(qw(a b c d));
evals/evals-freenode-#perl.lst[7485]: use strict; try {} catch {};
evals/evals-freenode-#perl.lst[7486]: use strict; $_ = undef; say @$_[1]; [ $_ ]
evals/evals-freenode-#perl.lst[7487]: use strict; $_ = undef; say @$_[1]; say Data::Dumper::Dumper [ $_ ]
evals/evals-freenode-#perl.lst[7488]: use strict; use B '@optype'; [ @optype ]
evals/evals-freenode-#perl.lst[7489]: use strict; use feature 'signatures'; sub add ($x = return 0, $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]
evals/evals-freenode-#perl.lst[7490]: use strict; use Function::Parameters qw(:strict); fun func($foo, $bar = sub { $foo }) { $bar } func(42)->()
evals/evals-freenode-#perl.lst[7491]: use strict; use v5.20; say "hi" for Altreus =>
evals/evals-freenode-#perl.lst[7492]: use strict; use v5.20; say "hi" for Altreus;
evals/evals-freenode-#perl.lst[7493]: use strict; use warnings; ["$ -"]
evals/evals-freenode-#perl.lst[7494]: use strict; use warnings; $! = 0; close "yolo" . rand; "$!"
evals/evals-freenode-#perl.lst[7495]: use strict; use warnings; $! = 0; readline "yolo" . rand; "$!"
evals/evals-freenode-#perl.lst[7496]: use strict; use warnings; 1234->{key}
evals/evals-freenode-#perl.lst[7497]: use strict; use warnings; [ @$_[3] ]
evals/evals-freenode-#perl.lst[7498]: use strict; use warnings; [ @{$_[3]} ] # you sure about that
evals/evals-freenode-#perl.lst[7499]: use strict; use warnings; ['' * 5]
evals/evals-freenode-#perl.lst[7500]: use strict; use warnings; $_ = "abc123xyz"; /\d{,3}/ ? ">$&<" : "no"
evals/evals-freenode-#perl.lst[7501]: use strict; use warnings; @a = {foo => 1, bar => 2}; print ${$a}{"foo"}
evals/evals-freenode-#perl.lst[7502]: use strict; use warnings; blasdsdasdsa->import
evals/evals-freenode-#perl.lst[7503]: use strict; use warnings; close "yolo" . rand
evals/evals-freenode-#perl.lst[7504]: use strict; use warnings; CORE::say "test" # use 5.016 mostly just covers imports, I think
evals/evals-freenode-#perl.lst[7505]: use strict; use warnings; @F=('5'); [@F]
evals/evals-freenode-#perl.lst[7506]: use strict; use warnings; $_ = "First Name Position first.name\@somewhere.com 745 45363\nSome One Worker some.one\@somewhere.com 343 5454\n" =~ s/^\s*(\S)\S*\s+(\S+).+?(\d\d\d \d\d\d\d)\s*/$1., $2, $3/gmr # for milfjord :)
evals/evals-freenode-#perl.lst[7507]: use strict; use warnings; $_ = "First Name Position first.name\@somewhere.com 745 45363\nSome One Worker some.one\@somewhere.com 343 5454\n" =~ s/^\s*(\S)\S*\s+(\S+).+?(\d\d\d \d+)\s*/$1., $2, $3/gmr # for milfjord :)
evals/evals-freenode-#perl.lst[7508]: use strict; use warnings; [ "First Name Position first.name\@somewhere.com 745 45363\nSome One Worker some.one\@somewhere.com 343 5454\n" =~ s/^\s*(\S)\S*\s+(\S+).+?(\d\d\d \d+)\s*/$1., $2, $3\n/gmr ]
evals/evals-freenode-#perl.lst[7509]: use strict; use warnings; [-foo]
evals/evals-freenode-#perl.lst[7510]: use strict; use warnings; [foo=>]
evals/evals-freenode-#perl.lst[7511]: use strict; use warnings; @foo = (1, 2, undef, 4); for my $foo (@foo) { print $foo }
evals/evals-freenode-#perl.lst[7512]: use strict; use warnings; foo; sub foo { "foo" }
evals/evals-freenode-#perl.lst[7513]: use strict; use warnings; foo(); sub foo { "foo" }
evals/evals-freenode-#perl.lst[7514]: use strict; use warnings; [ 'hentai' =~ m/#(?:hentai|yuri)/ ] # that line looks fine
evals/evals-freenode-#perl.lst[7515]: use strict; use warnings; if (0) {i_am_not_defined();} else {print "Perfectly OK\n";}
evals/evals-freenode-#perl.lst[7516]: use strict; use warnings; if (1) {} elseif (2) {}
evals/evals-freenode-#perl.lst[7517]: use strict; use warnings; 'inf' * 3
evals/evals-freenode-#perl.lst[7518]: use strict; use warnings; inf * 3
evals/evals-freenode-#perl.lst[7519]: use strict; use warnings; keys %{'main::'};
evals/evals-freenode-#perl.lst[7520]: use strict; use warnings; keys %{main::};
evals/evals-freenode-#perl.lst[7521]: use strict; use warnings; keys %main::
evals/evals-freenode-#perl.lst[7522]: use strict; use warnings;  length $12345678987654321
evals/evals-freenode-#perl.lst[7523]: use strict; use warnings; local $_ = "UCS-4"; eval q@qr/^UCS-?4-?(BE|LE)?$/i; uc("UTF-32$1")@
evals/evals-freenode-#perl.lst[7524]: use strict; use warnings; local $_ = "UCS-4"; my $p = qr/^UCS-?4-?(BE|LE|)?$/i; s@$p@uc("UTF-32$1")@er
evals/evals-freenode-#perl.lst[7525]: use strict; use warnings; { local $x = 123; } # nor on undeclared variables
evals/evals-freenode-#perl.lst[7526]: use strict; use warnings; [map { $_; last } (1,2,3)]
evals/evals-freenode-#perl.lst[7527]: use strict; use warnings; map {print $_} [1,2,3]
evals/evals-freenode-#perl.lst[7528]: use strict; use warnings; ''.methods.length
evals/evals-freenode-#perl.lst[7529]: use strict; use warnings; my @a = 'a'..'z'; [ $a[ 2..1 ] ];
evals/evals-freenode-#perl.lst[7530]: use strict; use warnings; my $abc = 'xyz'; my $asdf = 'mno'; sub asdf { return \$abc; } print "${asdf}"
evals/evals-freenode-#perl.lst[7531]: use strict; use warnings; my $abc = 'xyz'; sub asdf { return \$abc; } print "${asdf}"
evals/evals-freenode-#perl.lst[7532]: use strict; use warnings; my $abc = 'xyz'; sub asdf { return \$abc; } print ${asdf()}
evals/evals-freenode-#perl.lst[7533]: use strict; use warnings; my $abc = 'xyz'; sub asdf { return \$abc; } print ${asdf}
evals/evals-freenode-#perl.lst[7534]: use strict; use warnings; my  @a = ({foo=> "foo", moo => "bar", desc=> "lambda",},{foo=>"baz", moo=>"moo", desc=>"bring_it",}); my @keys = ('foo', 'desc'); [join(", ", map { my $href = $_; map { my $key = $_; "$key=\"$href->{$key}\"" } @keys } @a)]
evals/evals-freenode-#perl.lst[7535]: use strict; use warnings; my  @a = ({foo=> "foo", moo => "bar", desc=> "lambda",},{foo=>"baz", moo=>"moo", desc="bring_it",}); my @keys = ('foo', 'desc'); [join(", ", map { my $href = $_; map { my $key = $_; "$key=\"$href->{$key}\"" } @keys } @a)]
evals/evals-freenode-#perl.lst[7536]: use strict; use warnings; my  @a = ({foo=> "foo", moo => "bar"},{foo=>"baz", moo=>"moo"}); my $key = 'foo'; [join(", ", map { "$key=\"$_->{$key}\"" } @a)]
evals/evals-freenode-#perl.lst[7537]: use strict; use warnings; my @allowed = ('a'..'z','A'..'Z',' ', '{','}');my%allowed_hash = (map { $_ => 1 } @allowed); my %found; foreach my $c (split// , q#MPOPCNTSF: INTEGER[9]#) { if (!exists($allowed_hash{$c})) { $found{$c} = 1; } } [sort {$a cmp $b } keys%found]
evals/evals-freenode-#perl.lst[7538]: use strict; use warnings; my @allowed = ('a'..'z','A'..'Z',' ', '{','}');my%allowed_hash = (map { $_ => 1 } @allowed}; my %found; foreach my $c (split// , q#MPOPCNTSF: INTEGER[9]#) { if (!exists($allowed_hash{$c})) { $found{$c} = 1; } } [sort {$a cmp $b } keys%found]
evals/evals-freenode-#perl.lst[7539]: use strict; use warnings;  my $aref = [1,2,3];  @{ $aref + 1 }
evals/evals-freenode-#perl.lst[7540]: use strict; use warnings; my %args = ( number => 100 ); print $args{number};
evals/evals-freenode-#perl.lst[7541]: use strict; use warnings; my %args = { number => 100 }; print $args{number};
evals/evals-freenode-#perl.lst[7542]: use strict; use warnings; my $ar = [qw(x y z a b c)]; $ar->[2..4] # warnings to the rescue?
evals/evals-freenode-#perl.lst[7543]: use strict; use warnings; my $array = (1,2,3);
evals/evals-freenode-#perl.lst[7544]: use strict; use warnings; my $array_ref = [3,4,5]; ["$array_ref"]
evals/evals-freenode-#perl.lst[7545]: use strict; use warnings; my $array_ref = [3,4,5]; [scalar @$array_ref]
evals/evals-freenode-#perl.lst[7546]: use strict; use warnings; my @arr = ('One', 'Two', 'Three', 'Four'); @arr = grep { !/\AT/ } @arr; [@arr]
evals/evals-freenode-#perl.lst[7547]: use strict; use warnings; my $cat, $dog;
evals/evals-freenode-#perl.lst[7548]: use strict; use warnings; my @c=qw(a b c d);print((map{$_ >1}@c)/@c)
evals/evals-freenode-#perl.lst[7549]: use strict; use warnings; my $cwd = "/archivepath/SHORT"; my $ARCHIVEPATH="/archivepath/"; [$cwd =~ m#^${ARCHIVEPATH}(SHORT|MEDIUM|LONG)$# ? "Match" : "No match"]
evals/evals-freenode-#perl.lst[7550]: use strict; use warnings; my $cwd = "/archivepath/SHORT"; my $ARCHIVEPATH="/archivepath/"; [$cwd =~ m#^${ARCHIVEPATH}(SHORT|MEDIUM|LONG)\$# ? "Match" : "No match"]
evals/evals-freenode-#perl.lst[7551]: use strict; use warnings; my %d = ( A => sub{'a'}, B => 5, C => sub{'c'}, D => [], E => sub{'e'} ); while ( my ($name, $code) = each %d ) { delete $d{$name} unless ref $code eq 'CODE'; } \%d;
evals/evals-freenode-#perl.lst[7552]: use strict; use warnings; my @data = ("foo"); $data[0]{label} = $data[0]; [@data]
evals/evals-freenode-#perl.lst[7553]: use strict; use warnings; my @data = ("foo"); $data[0] = {label => $data[0]}; [$data[0]{label}]
evals/evals-freenode-#perl.lst[7554]: use strict; use warnings; my $data = [{}, { url => 'xyz' }]; $data->["1\n"]{url} # shouldn't matter
evals/evals-freenode-#perl.lst[7555]: use strict; use warnings; my @default = qw(d e f a u l t); my $h = { y => [ qw(A B C) ] }; [ map Data::Munge::list2re(@{ $h->{$_} // \@default }), qw(x y) ]
evals/evals-freenode-#perl.lst[7556]: use strict; use warnings; my @default = qw(d e f a u l t); my $h = { y => [ qw(A B C) ] }; [ map {   join q{|}, map { qq{\Q$_\E} } ( ref $h->{$_} eq q{ARRAY} && @{ $h->{$_} } ? @{ $h->{$_} } : @default )   } qw(x y) ];
evals/evals-freenode-#perl.lst[7557]: use strict; use warnings; my $foo = 1; my $bar = 2; my $name = "foo"; print "ok" if (defined(${$name}));
evals/evals-freenode-#perl.lst[7558]: use strict; use warnings; my %foo = (bar => 1); print %{foo};
evals/evals-freenode-#perl.lst[7559]: use strict; use warnings; my $foo = { bar => "stuff" }; $foo->{bar}->{baz}
evals/evals-freenode-#perl.lst[7560]: use strict; use warnings; my %foo = (hello => [1,22,303]); [$foo{hello}[1]]
evals/evals-freenode-#perl.lst[7561]: use strict; use warnings; my @foo = "hi"; "class ${foo[0]}{ ... };"
evals/evals-freenode-#perl.lst[7562]: use strict; use warnings; my @foo = "hi"; "class $foo[0]\{ ... };"
evals/evals-freenode-#perl.lst[7563]: use strict; use warnings; my $foo; push @$foo, 1; $foo
evals/evals-freenode-#perl.lst[7564]: use strict; use warnings; my @groups; my $chunk = []; for my $x ("foo", "bar", "baz\n", "x", "y", "z") { push @$chunk, $x; if ($x =~ /\R\z/) { push @groups, $chunk; $chunk = []; } } push @groups, $chunk if @$chunk; [ @groups ]
evals/evals-freenode-#perl.lst[7565]: use strict; use warnings; my %h = ( 1 => 200, 0 => 100, q{} => 50, undef => 25 ); $h{undef};
evals/evals-freenode-#perl.lst[7566]: use strict; use warnings; my %h = ( 1 => 200, 0 => 100, q{} => 50, undef => 25 ); my $x; $h{$x}; ### Wtf?
evals/evals-freenode-#perl.lst[7567]: use strict; use warnings; my %h = (1 => 2); sub x {my $ref = shift; $ref->{1} = 3}; x(\%h); $h{1}
evals/evals-freenode-#perl.lst[7568]: use strict; use warnings; my %h = (a => b, c => d, e => f); my $str = "abcdef"; $str =~ m/(.)/$h{$1}/g; print "$str";
evals/evals-freenode-#perl.lst[7569]: use strict; use warnings; my %h = (a => "b", c => "d", e => "f"); my $str = "abcdef"; $str =~ s/(.)/$h{$1} // $1 /eg; print "$str";
evals/evals-freenode-#perl.lst[7570]: use strict; use warnings; my $h = {a => "b", c => "d", e => "f"}; my $str = join ",", grep defined, @$h{qw/a b c/}; print $str;
evals/evals-freenode-#perl.lst[7571]: use strict; use warnings; my $h = {a => "b", c => "d", e => "f"}; my $str = join(",", grep {defined($h->{$_})} (qw/a b c/)); print $str;
evals/evals-freenode-#perl.lst[7572]: use strict; use warnings; my $h = {a => "b", c => "d", e => "f"}; my $str = join(",", map { $h->{$_} // () } (qw/a b c/)); print $str; # or do both in the map
evals/evals-freenode-#perl.lst[7573]: use strict; use warnings; my $h = {a => "b", c => "d", e => "f"}; my $str = map $h->{$_}, join(",", grep {defined($h->{$_})} (qw/a b c/)); print $str;
evals/evals-freenode-#perl.lst[7574]: use strict; use warnings; my %hash;  "hash"->{key} = "message"; \%hash
evals/evals-freenode-#perl.lst[7575]: use strict; use warnings; my %hash; ${"hash"}{key} = "message"; \%hash
evals/evals-freenode-#perl.lst[7576]: use strict; use warnings; my $hash_ref = { 'foo' => 'bar' }; $%hash_ref{'foo'};
evals/evals-freenode-#perl.lst[7577]: use strict; use warnings; my $hash_ref = { 'foo' => 'bar' }; $hash_ref{'foo'};
evals/evals-freenode-#perl.lst[7578]: use strict; use warnings; my $hash_ref = { 'foo' => 'bar' }; %$hash_ref{'foo'};
evals/evals-freenode-#perl.lst[7579]: use strict; use warnings; my %hash_ref = { 'foo' => 'bar' }; $hash_ref{'foo'};
evals/evals-freenode-#perl.lst[7580]: use strict; use warnings; my %h = ('a' => "This is A", 'b' => "This is B"); $h{'a'} = "One A too many."; $h{'c'} = "Foobar"; \%h
evals/evals-freenode-#perl.lst[7581]: use strict; use warnings; my $_ # hence the "experimental" - generally safer not to use it, and avoid things that do
evals/evals-freenode-#perl.lst[7582]: use strict; use warnings; my %h = ('fling' => 1, 'rindolf' => 2, 'gamo' => 3); my @arr = (map { [$_, $h{$_}] } keys %h); [@arr]
evals/evals-freenode-#perl.lst[7583]: use strict; use warnings; my $h = {"foo" => 5, "bar" => 6, "baz" => 2}; print Dumper(@{$h}->{qw/foo bar baz/});
evals/evals-freenode-#perl.lst[7584]: use strict; use warnings; my %h = (foo => 'bar'); my $aref = [\%h,\%h,\%h]; $aref->[0]{foo} = 'dexter'; $aref
evals/evals-freenode-#perl.lst[7585]: use strict; use warnings; my %h = (foo => bar); my $aref = [\%h,\%h,\%h]; $aref->[0]{foo} = 'dexter'; $aref
evals/evals-freenode-#perl.lst[7586]: use strict; use warnings; my %h = (foo => bar); my $aref = [\%h,\%h,\%h]; $aref[0]{foo} = 'dexter'; $aref
evals/evals-freenode-#perl.lst[7587]: use strict; use warnings; my %h; $h{'foo','bar'} = "much"; \%h
evals/evals-freenode-#perl.lst[7588]: use strict; use warnings; my $href; %$href
evals/evals-freenode-#perl.lst[7589]: use strict; use warnings; my $input="Exact map coverage is (55.668840408325195,20.794050693511963) to (58.08229207992554,28.241150379180908)"; [ $input =~ m#([0-9]+(?:\.[0-9]+)?)#g]
evals/evals-freenode-#perl.lst[7590]: use strict; use warnings; my $input="Exact map coverage is (55.668840408325195,20.794050693511963) to (58.08229207992554,28.241150379180908)"; [ $input =~ m#([0-9]+(\.[0-9]+)?#g]
evals/evals-freenode-#perl.lst[7591]: use strict; use warnings; my ( $linecount, $timestart) = (0,0); printf(".... %s ... ", int($linecount/(time()-$timestart+1)));
evals/evals-freenode-#perl.lst[7592]: use strict; use warnings; my $my->{my}
evals/evals-freenode-#perl.lst[7593]: use strict; use warnings; my $name = 'something'; $$name = 'data'; { our $something; $something } # if you get an error when you make that change...
evals/evals-freenode-#perl.lst[7594]: use strict; use warnings; my $name = 'Tectu'; print "Hello $name!\n";
evals/evals-freenode-#perl.lst[7595]: use strict; use warnings; my $num = 5.2323232; $num = sprintf("%.3f", $num); [$num]
evals/evals-freenode-#perl.lst[7596]: use strict; use warnings; my %old_hash = (1 => 2, 3 => undef); my %new_hash; $new_hash{$old_hash{$_}} = $_ for keys %old_hash; \%new_hash
evals/evals-freenode-#perl.lst[7597]: use strict; use warnings; my %old_hash = (1 => 2, 3 => undef); my %new_hash = reverse %old_hash; \%new_hash
evals/evals-freenode-#perl.lst[7598]: use strict; use warnings; my $PROG = sub { "like this?" }; "${PROG}" # really?
evals/evals-freenode-#perl.lst[7599]: use strict; use warnings; my $ref = [qw(hi one two)]; unshift(@$ref, "Hello"); [$ref]
evals/evals-freenode-#perl.lst[7600]: use strict; use warnings; my $s = "5/5/1977"; $s =~ s/(\d{1,2})\/(\d{1,2})\/(\d{4})/sprintf("%04d%02d%02d", $3, $2, $1)/e; [$s]
evals/evals-freenode-#perl.lst[7601]: use strict; use warnings; my $s = "aabaaaaaaaaaaaab"; my @x = $s =~ /(a++b)/; [@x]
evals/evals-freenode-#perl.lst[7602]: use strict; use warnings; my $s = "aabaaaaaaaaaaaab"; @x = $s =~ /(a++b)/; [@x]
evals/evals-freenode-#perl.lst[7603]: use strict; use warnings; my %sections = { name => "testname" }; [ %sections ] # probably not what you wanted in %sections
evals/evals-freenode-#perl.lst[7604]: use strict; use warnings; my $s = "Hello maroloccio___. How is your day."; $s =~ s#\AHello (\w+)# my $name = $1; $name =~ s/_+\z//; $name#e; [$s]
evals/evals-freenode-#perl.lst[7605]: use strict; use warnings; my $s = "Hello maroloccio___. How is your day."; $s =~ s#\AHello (\w+)# my $name = $1; $name =~ s/_+\z//; $name#; [$s]
evals/evals-freenode-#perl.lst[7606]: use strict; use warnings; my %shift = (bar => 1); print %shift
evals/evals-freenode-#perl.lst[7607]: use strict; use warnings; my %shift = (bar => 1); print %{shift}
evals/evals-freenode-#perl.lst[7608]: use strict; use warnings; my $s = q{<a rel="nofollow" href="http://www.FOOtube.com/v/ABCDEFG" target="_blank">Youtube Video</a>}; $s =~ s#<a(?:\s+(?:href=(\S+\byoutube\.com/\S+)|[^>]*?))+\s*\>.*?</a>#$1# && print qq{Match: $1\n}; [ $s, $1 ];
evals/evals-freenode-#perl.lst[7609]: use strict; use warnings; my $s = q{<a rel="nofollow" href="http://www.youtube.com/v/ABCDEFG" target="_blank">Youtube Video</a>}; $s =~ s#<a(?:\s+(?:href=(\S+\byoutube\.com/\S+)|[^>]*?))+\s*\>.*?</a>#$1# && print qq{Match: $1\n}; [ $s, $1 ];
evals/evals-freenode-#perl.lst[7610]: use strict; use warnings; my $s = q{foo=bar=baz}; my $p = qr/=(.*?)=/; my $r = q{",$1,"}; $s =~ s/$p/$r/re;
evals/evals-freenode-#perl.lst[7611]: use strict; use warnings; my $s = q{}; my $r = s =~ s///; OK wtf?
evals/evals-freenode-#perl.lst[7612]: use strict; use warnings; my $s = q{}; my $r = s =~ s///; # wtf?
evals/evals-freenode-#perl.lst[7613]: use strict; use warnings; my $str = "012"; my @f = (qw/2 1 0/); $str =~ s/(join("|", @f))/$f[$1]/g; print $str
evals/evals-freenode-#perl.lst[7614]: use strict; use warnings; my $str = "\"foo bar baz\""; print "pre [$str]\n"; $str =~ s/(?:[^\\])"$//; print "post [$str]\n";
evals/evals-freenode-#perl.lst[7615]: use strict; use warnings; my $str; length($str)
evals/evals-freenode-#perl.lst[7616]: use strict; use warnings; my %table = {}; # strict+warnings may help with issues like that
evals/evals-freenode-#perl.lst[7617]: use strict; use warnings; my $test = ""; [defined($test) ? "Def" : "Undef"]
evals/evals-freenode-#perl.lst[7618]: use strict; use warnings; my @things; (my $x = '%%123@@@@456&&234') =~ s/([\$%\@&])\1+\K([0-9]+)/push @things, $2/ge; \@things # could even do something like this, for example
evals/evals-freenode-#perl.lst[7619]: use strict; use warnings; { my $v=0; sub foo : lvalue { $v } } foo++;
evals/evals-freenode-#perl.lst[7620]: use strict; use warnings; { my $v=0; sub x : lvalue { $v } } ++x;
evals/evals-freenode-#perl.lst[7621]: use strict; use warnings; { my $v=0; sub x : lvalue { $v } } x++;
evals/evals-freenode-#perl.lst[7622]: use strict; use warnings; my $var = undef; @{$var} # and you understand why this fails but Bar(@{$var}) doesn't, right?
evals/evals-freenode-#perl.lst[7623]: use strict; use warnings; my $v = sub { "Miesco", 1+1, print("Blessed are the cheese makers") }->(); print " Return value was: [ $v ]" # seems print turns off auto-value-dump in perlbot?
evals/evals-freenode-#perl.lst[7624]: use strict; use warnings; my $v = sub { "Miesco", 1+1, print("Blessed are the cheese makers") }->(); [ $v ]
evals/evals-freenode-#perl.lst[7625]: use strict; use warnings; my $word_re = qr/\w+/; my $pat_re = qr/(?:$word_re-)*$word_re/; [grep { $_ =~ /\A$pat_re\z/ } ("foo-123")]
evals/evals-freenode-#perl.lst[7626]: use strict; use warnings; my $word_re = qr/\w+/; my $pat_re = qr/(?:$word_re-)*$word_re/; [grep { $_ =~ /\A$pat_re\z/ } ("foo-123", "bar-3600-Zab","Maj+4")]
evals/evals-freenode-#perl.lst[7627]: use strict; use warnings; my %x = { };
evals/evals-freenode-#perl.lst[7628]: use strict; use warnings; my @x = ([0,1,2]) x 5; $x[0][2] = 100; [@x]
evals/evals-freenode-#perl.lst[7629]: use strict; use warnings; my $x = 0; for my $i (1 .. 100) { $x += 0.01; } [sprintf("%.50f", $x)]
evals/evals-freenode-#perl.lst[7630]: use strict; use warnings; my $x = -100 ; for my $y (0 .. $x) { hello_there(); } 1;
evals/evals-freenode-#perl.lst[7631]: use strict; use warnings; my @x = (1 .. 5); @x[0,2] = (100,200); [@x]
evals/evals-freenode-#perl.lst[7632]: use strict; use warnings; my $x = 1; my $h = do { if ( $x == 2 ) { \*STDERR; } elsif ( $x == 1 ) { \*STDOUT; } }; $h
evals/evals-freenode-#perl.lst[7633]: use strict; use warnings; my $x = 1; my $h = do { if ( $x == 2 ) { \*STDERR; } if ( $x == 1 ) { \*STDOUT; } }; $h
evals/evals-freenode-#perl.lst[7634]: use strict; use warnings; my $x = 1; my $h = do { \*STDERR if $x == 2; \*STDOUT if $x == 1; }; $h
evals/evals-freenode-#perl.lst[7635]: use strict; use warnings; my $x = 1; our $x = 2; $x
evals/evals-freenode-#perl.lst[7636]: use strict; use warnings; my $ x = 2  # or even
evals/evals-freenode-#perl.lst[7637]: use strict; use warnings; my @x = (500, 24, 300, 2800); $#x = -1; [@x]
evals/evals-freenode-#perl.lst[7638]: use strict; use warnings; my @x = (500, 24, 300, 2800); $#x = 1; [@x]
evals/evals-freenode-#perl.lst[7639]: use strict; use warnings; my $x = 'abc'; ${x}
evals/evals-freenode-#perl.lst[7640]: use strict; use warnings; my $x = "| |"; ["Foo $x y $x"]
evals/evals-freenode-#perl.lst[7641]: use strict; use warnings; my $x = []; push $x, '...';
evals/evals-freenode-#perl.lst[7642]: use strict; use warnings; my %x = ( qw(AAA 1111 BBB 222 CCC 333 DDD 444) ); (()=%x)/2;
evals/evals-freenode-#perl.lst[7643]: use strict; use warnings; my %x = ( qw(AAA 1111 BBB 222) ); %x+0
evals/evals-freenode-#perl.lst[7644]: use strict; use warnings; my $x; sub Foo : lvalue { $x } sub Bar { } my $var = undef; Bar(@{Foo()}) # does that make it any clearer?
evals/evals-freenode-#perl.lst[7645]: use strict; use warnings; my $x = "test"; ["$ x"] # any clearer?
evals/evals-freenode-#perl.lst[7646]: use strict; use warnings; my ($x, undef) = (5,10);
evals/evals-freenode-#perl.lst[7647]: use strict; use warnings; my $x; undef $x; length($x) < 4 # the length() warnings can be mildly confusing
evals/evals-freenode-#perl.lst[7648]: use strict; use warnings ; my @x; $x[5] = 5; [keys@x]
evals/evals-freenode-#perl.lst[7649]: use strict; use warnings;  my %x; $x{a} = 4; @x{a} = (5); print $x{a};
evals/evals-freenode-#perl.lst[7650]: use strict; use warnings; my $x; --$x if $x > 1; \$x; # Just wondering, is there a nice rewrite this to avoid the warning, without using something like if $x && $x > 1 (is there a shorter/simpler way?)
evals/evals-freenode-#perl.lst[7651]: use strict; use warnings; my $x; $$x = 'test'; $x # even scalars
evals/evals-freenode-#perl.lst[7652]: use strict; use warnings; my $x; ($x ? $x++ : $x ) = 1; $x;
evals/evals-freenode-#perl.lst[7653]: use strict; use warnings; my $x; $x ? $x++ : ($x = 1); $x;
evals/evals-freenode-#perl.lst[7654]: use strict; use warnings; my $x; $x ? $x++ : $x = 1; $x;
evals/evals-freenode-#perl.lst[7655]: use strict; use warnings; my $x->{y} = 55
evals/evals-freenode-#perl.lst[7656]: use strict; use warnings; $_ = my ($x, $y); $x = "hi"
evals/evals-freenode-#perl.lst[7657]: use strict; use warnings; my %x = (y => 'z'); $x{'hey'} += 100; \%x
evals/evals-freenode-#perl.lst[7658]: use strict; use warnings; my $y; my @x = @$y; # rvalue
evals/evals-freenode-#perl.lst[7659]: use strict; use warnings; my $y; my @x; @$y = @x; # lvalue
evals/evals-freenode-#perl.lst[7660]: use strict; use warnings; my $z = {}; (my $z)->{z}
evals/evals-freenode-#perl.lst[7661]: use strict; use warnings; my $z = {}; my ($z->{z})
evals/evals-freenode-#perl.lst[7662]: use strict; use warnings; my $z = {}; my $z->{z}
evals/evals-freenode-#perl.lst[7663]: use strict; use warnings; [ 'NaN' + 'sNaN' ]
evals/evals-freenode-#perl.lst[7664]: use strict; use warnings; no strict 'refs'; my $name = 'something'; $$name = 'data'; { our $something; $something } # ... then add no strict 'refs';
evals/evals-freenode-#perl.lst[7665]: use strict; use warnings; 'ok'; ()
evals/evals-freenode-#perl.lst[7666]: use strict; use warnings; [open my $fh, '<', '']
evals/evals-freenode-#perl.lst[7667]: use strict; use warnings; open(my $fh, ">", "myfic.txt");my ($fh) = @_; # because this should give you a warning
evals/evals-freenode-#perl.lst[7668]: use strict; use warnings; [open my $fh, '<', undef]
evals/evals-freenode-#perl.lst[7669]: use strict; use warnings; open my $out2, q{>&=}, 2 or die qq{open failed: $!}; print $out2 "hi";
evals/evals-freenode-#perl.lst[7670]: use strict; use warnings; our $x = 1; my $x = 2; $x
evals/evals-freenode-#perl.lst[7671]: use strict; use warnings; package foo {} foo->import;
evals/evals-freenode-#perl.lst[7672]: use strict; use warnings; { package Foo; our $bar = 42; } my $pkg = "Foo"; my $var = do { no strict 'refs'; \${"${pkg}::bar"} }; $$var
evals/evals-freenode-#perl.lst[7673]: use strict; use warnings; { package Foo; our $bar = 42; } my $pkg = "Foo"; ${ $::{$pkg . '::'}->{bar} }
evals/evals-freenode-#perl.lst[7674]: use strict; use warnings; { package Foo; sub bar { 42 } } my $pkg = "Foo"; my $fn = \&{"${pkg}::bar"}; $fn->()
evals/evals-freenode-#perl.lst[7675]: use strict; use warnings; { package Foo; sub bar { 42 } } my $pkg = "Foo"; "${pkg}::bar"->()
evals/evals-freenode-#perl.lst[7676]: use strict; use warnings; package Obj; sub new { return bless {} , shift; } sub w_state { state $foo; return ++$foo; } ; package main; my @x; my $t = Obj->new; my $r = Obj->new; push @x, $t->w_state; push @x, $r->w_state; [@x]
evals/evals-freenode-#perl.lst[7677]: use strict; use warnings; {package sort::numeric; BEGIN { $INC{'sort/numeric.pm'} = 1 } sub import { no strict 'refs'; *{caller . '::sort'} = sub { GLOBAL::CORE::sort { $a <=> $b } @_ } } } use sort::numeric; [ sort 1,3,2,31,13,12,15,42 ] # pragma
evals/evals-freenode-#perl.lst[7678]: use strict; use warnings; package SubTest; sub DESTROY { print qq{Good bye cruel wor...\n}; } package main; sub foo { my ( $x, $worker ); $worker = bless sub { $x++; $worker->() unless $x >= 5; }, q{SubTest}; $worker->(); undef $worker; $x; } print foo;
evals/evals-freenode-#perl.lst[7679]: use strict; use warnings; package SubTest; sub DESTROY { print qq{Good bye cruel wor...\n}; } package main; sub foo { my ( $x, $worker ); $worker = bless sub { $x++; $worker->() unless $x >= 5; }, q{SubTest}; $worker->(); $x; } print foo;
evals/evals-freenode-#perl.lst[7680]: use strict; use warnings; package SubTest; sub DESTROY { print qq{Good bye cruel wor...\n}; } package main; sub foo { my ( $x, $worker ); $worker = bless sub { $x++; $worker->() unless $x >= 5; undef $worker; }, q{SubTest}; $worker->(); $x; } foo;
evals/evals-freenode-#perl.lst[7681]: use strict; use warnings; package SubTest; sub DESTROY { print qq{Good bye cruel wor...\n}; } package main; sub foo { my ( $x, $worker ); $worker = bless sub { $x++; $worker->() unless $x >= 5; undef $worker; }, q{SubTest}; $worker->(); $x; } print foo;
evals/evals-freenode-#perl.lst[7682]: use strict; use warnings; print $!
evals/evals-freenode-#perl.lst[7683]: use strict; use warnings; print &$!;
evals/evals-freenode-#perl.lst[7684]: use strict; use warnings; print chr(0xe08)
evals/evals-freenode-#perl.lst[7685]: use strict; use warnings; print "Foo $_" foreach qw(one two three);
evals/evals-freenode-#perl.lst[7686]: use strict; use warnings; rand * 3
evals/evals-freenode-#perl.lst[7687]: use strict; use warnings; reduce 1;
evals/evals-freenode-#perl.lst[7688]: use strict; use warnings; reduce(1)
evals/evals-freenode-#perl.lst[7689]: use strict; use warnings; say 1.2.3
evals/evals-freenode-#perl.lst[7690]: use strict; use warnings; sort { $a <=> $x } 1,2,3; # looks like an error to me
evals/evals-freenode-#perl.lst[7691]: use strict; use warnings; s/^\///r for ''; ''
evals/evals-freenode-#perl.lst[7692]: use strict; use warnings; sub abc { } sub xyz { } *xyz = sub { 123 }; { no warnings "redefine"; *abc = sub { 4 }; [] } # no warnings '...' is usefully self-documenting, any particular reason to do things manually?
evals/evals-freenode-#perl.lst[7693]: use strict; use warnings; sub ALL_EMPS { return +{ one => 1, two => 2, three => 3}}; my %h = %{ ALL_EMPS() }; [$h{three}]
evals/evals-freenode-#perl.lst[7694]: use strict; use warnings; sub a :lvalue { $a } a=10;a=20; print "$a\n"; # <--- see, strict and warnings clean
evals/evals-freenode-#perl.lst[7695]: use strict; use warnings; sub Bar { ++$_ for @_ } my $x; 1 for @{$x}; $x # note that it's not just function calls, you'll get the same with foreach aliasing
evals/evals-freenode-#perl.lst[7696]: use strict; use warnings; sub create_iterator { my ($val) = @_; my $iter = sub { return ++$val; } ; return $iter } my $iter1 = create_iterator(100); my $iter2 = create_iterator(5); [$iter1->(),$iter2->(),$iter1->(),$iter2->()]
evals/evals-freenode-#perl.lst[7697]: use strict; use warnings; sub flatten { return map { ref($_) eq 'ARRAY' ? flatten(@$_) : $_ } @_ } [flatten([1, [2, 3], [4, [5]], 6])]
evals/evals-freenode-#perl.lst[7698]: use strict; use warnings; sub flatten { return map { ref($_) eq 'ARRAY' ? flatten(@$_) : $_ } @_ } [flatten(1, [2, 3], [4, [5]], 6])]
evals/evals-freenode-#perl.lst[7699]: use strict; use warnings; sub foo { 42 } *bar = \&foo; bar()
evals/evals-freenode-#perl.lst[7700]: use strict; use warnings; sub foo { 42 } my $name = 'foo'; 'main'->$name
evals/evals-freenode-#perl.lst[7701]: use strict; use warnings; sub foo { "foo" } foo
evals/evals-freenode-#perl.lst[7702]: use strict; use warnings; sub foo { my ($ch, $name) = @_; } foo(undef, undef); #are you sure?
evals/evals-freenode-#perl.lst[7703]: use strict; use warnings; sub foo { shift } my $name = 'foo'; 'main'->can($name
evals/evals-freenode-#perl.lst[7704]: use strict; use warnings; sub foo { shift } my $name = 'foo'; 'main'->can($name)->(42)
evals/evals-freenode-#perl.lst[7705]: use strict; use warnings; sub foo { shift } my $name = 'foo'; 'main'->can($name)(42)
evals/evals-freenode-#perl.lst[7706]: use strict; use warnings; sub Foo { undef } sub Bar { } Bar(@{Foo()}) # you're saying this one works, or did you mean the else { } clause?
evals/evals-freenode-#perl.lst[7707]: use strict; use warnings; sub Foo {undef } sub Bar { } my $x; Bar(@{$x = Foo()})
evals/evals-freenode-#perl.lst[7708]: use strict; use warnings; sub func { return undef;} if(1 and defined(func("Foo"))) { print "Success!"; }
evals/evals-freenode-#perl.lst[7709]: use strict; use warnings; sub func { return undef;} if(1 and !defined(func("Foo"))) { print "Success!\n"; }
evals/evals-freenode-#perl.lst[7710]: use strict; use warnings; sub func { return undef;} if(1 and defined(func("Foo"))) { print "Success!\n"; }
evals/evals-freenode-#perl.lst[7711]: use strict; use warnings; sub get_closure { my $x = 124; my $returnval = sub { return $x; }; ++$x; return $returnval; } my $foo = get_closure(); [$foo->()]
evals/evals-freenode-#perl.lst[7712]: use strict; use warnings; sub get_closure { my $x = 124; my $returnval = sub { return $x; }; ++$x; return $retval; } my $foo = get_closure(); [$foo->()]
evals/evals-freenode-#perl.lst[7713]: use strict; use warnings; sub get_closure { my $x = 124; return sub { return $x; } } my $foo = get_closure(); [$foo->()]
evals/evals-freenode-#perl.lst[7714]: use strict; use warnings; sub get_closure { my $x = 124; return sub { return $x; }; ++$x; } my $foo = get_closure(); [$foo->()]
evals/evals-freenode-#perl.lst[7715]: use strict; use warnings; sub int {} my ( $linecount, $timestart) = (0,0); printf(".... %s ... ", int($linecount/(time()-$timestart+1)));
evals/evals-freenode-#perl.lst[7716]: use strict; use warnings; sub ls{my ($n, $h)=@_;my $ret;for(0..$#$h){$ret=$_ and last if $n eq $h->[$_]}$ret}; ls (3,[0,1,4,3,2])
evals/evals-freenode-#perl.lst[7717]: use strict; use warnings; sub { my $x = 42; sub { eval '$x' } }->()->()
evals/evals-freenode-#perl.lst[7718]: use strict; use warnings; sub outer { my ($var) = @_; sub inner { print $var||'three' } }   outer("one"); inner(); outer("two"); inner() # as the warning implies, "don't do this"
evals/evals-freenode-#perl.lst[7719]: use strict; use warnings; sub sort { CORE::GLOBAL::sort { $a <=> $b } @_ } [ sort 1,3,2,31,13,12,15,42 ] # huh, maybe
evals/evals-freenode-#perl.lst[7720]: use strict; use warnings; sub sort { GLOBAL::CORE::sort { $a <=> $b } @_ } [ sort 1,3,2,31,13,12,15,42 ] # all *your* sorts, sure, but not all sorts everywhere
evals/evals-freenode-#perl.lst[7721]: use strict; use warnings; sub test { return bareword { return 42; } }; test()
evals/evals-freenode-#perl.lst[7722]: use strict; use warnings; sub what { (my $foo, @_) = @_; \@_ } what(qw(a b c d));
evals/evals-freenode-#perl.lst[7723]: use strict; use warnings; sub what { my ($foo, @_) = @_; \@_ } what(qw(a b c d));
evals/evals-freenode-#perl.lst[7724]: use strict;use warnings;sub x { my($x,$y,$z)=@_;print $x } x(1,2);
evals/evals-freenode-#perl.lst[7725]: use strict; use warnings; system "echo 'xxx@xxxxxxxx$' rsync"
evals/evals-freenode-#perl.lst[7726]: use strict; use warnings; \&this_sub_doesnt_exist
evals/evals-freenode-#perl.lst[7727]: use strict; use warnings; "UCS-4" =~ /^UCS-?4-?(BE|LE)?$/i; eval q@uc("UTF-32$1")@
evals/evals-freenode-#perl.lst[7728]: use strict; use warnings; (undef) = 10;
evals/evals-freenode-#perl.lst[7729]: use strict; use warnings; undef = 10;
evals/evals-freenode-#perl.lst[7730]: use strict; use warnings; undef $f; my $f;
evals/evals-freenode-#perl.lst[7731]: use strict; use warnings; use 5.016; package Obj; sub new { return bless {} , shift; } sub w_state { state $foo; return ++$foo; } ; package main; my @x; my $t = Obj->new; my $r = Obj->new; push @x, $t->w_state; push @x, $r->w_state; [@x]
evals/evals-freenode-#perl.lst[7732]: use strict; use warnings; use constant TEST2 => TEST1; use constant TEST1 => 1; use constant TEST3 => TEST1; [TEST1, TEST2, TEST3]
evals/evals-freenode-#perl.lst[7733]: use strict; use warnings; use DateTime::TimeZone; my $tz = DateTime::TimeZone->new(name => '-0400')->name
evals/evals-freenode-#perl.lst[7734]: use strict; use warnings; use DateTime::TimeZone; my $tz = DateTime::TimeZone->new(name => 'America/New_York')
evals/evals-freenode-#perl.lst[7735]: use strict; use warnings; use experimental qw[signatures]; sub test ($foo) { say $foo } test ('moo')
evals/evals-freenode-#perl.lst[7736]: use strict; use warnings; use experimental qw(signatures); sub whatever($=) { print $= } whatever(3) # I'm happy enough with the way signatures work at the moment though
evals/evals-freenode-#perl.lst[7737]: use strict; use warnings; use feature qw(say); say for qw(foo -- bar); # what makes you think it throws an error?
evals/evals-freenode-#perl.lst[7738]: use strict; use warnings; use feature qw(say); use XML::LibXML; my $t1 = XML::LibXML::Text->new( q{foo} ); my $t2 = XML::LibXML::Text->new( q{bar} ); $t1->appendChild( $t2 ); say $t1;
evals/evals-freenode-#perl.lst[7739]: use strict; use warnings; use List::MoreUtils qw(any all); my $count = 5; my @nums = (sort { $a <=> $b} qw(10 4 3 4 4 59 39 5 3)); [any { my $x = $_; my $p = $nums[$_]; all { $nums[$x+$_]-$p <= 3 } (0 .. $count-1) } 0 .. (@nums-$count)]
evals/evals-freenode-#perl.lst[7740]: use strict; use warnings; use List::MoreUtils qw(any all); my @nums = (sort { $a <=> $b} qw(10 4 3 4 4 59 39 5 3)); [any { my $x = $_; my $p = $nums[$_]; all { $nums[$x+$_]-$p <= 3 } (0 .. 5) } } keys(@nums)]
evals/evals-freenode-#perl.lst[7741]: use strict; use warnings; use List::MoreUtils qw(any all); my @nums = (sort { $a <=> $b} qw(10 4 3 4 4 59 39 5 3)); [any { my $x = $_; my $p = $nums[$_]; all { $nums[$x+$_]-$p <= 3 } (0 .. 5) } keys(@nums)]
evals/evals-freenode-#perl.lst[7742]: use strict; use warnings; use List::MoreUtils qw/uniq/; [ sort(uniq qw/a b c a/) ];
evals/evals-freenode-#perl.lst[7743]: use strict; use warnings; use List::MoreUtils qw/uniq/; [ sort(uniq(qw/a b c a/)) ];
evals/evals-freenode-#perl.lst[7744]: use strict; use warnings; use List::Util; my $c = [qw(a b c)]; print "1" if List::Util::any { $_ eq "a" } @{$c}
evals/evals-freenode-#perl.lst[7745]: use strict; use warnings; use List::Util qw(pairmap); $_ = qq{foo}; my @l = /(\R)/; push @l, undef if @l%2; [ pairmap { [$a, $b] } @l ]
evals/evals-freenode-#perl.lst[7746]: use strict; use warnings; use List::Util qw(pairmap); $_ = qq{foo\n}; [ pairmap { } split /\R/ ];
evals/evals-freenode-#perl.lst[7747]: use strict; use warnings; use List::Util qw(pairmap); $_ = qq{foo}; [ pairmap { } split /(\R)/ ]; # Better test case.
evals/evals-freenode-#perl.lst[7748]: use strict; use warnings; use List::Util qw[sum]; my $var = {  a => {count => 1},  b => {count => 5} }; [sum map { $_->{count} } values %{ $var }]
evals/evals-freenode-#perl.lst[7749]: use strict; use warnings; use List::Util qw[sum]; my $var = {  a => {count => 1},  b => {count => 5} }; [sum values %{ $var }]
evals/evals-freenode-#perl.lst[7750]: use strict; use warnings; use POSIX qw(sysconf); [ sysconf(POSIX::_SC_PAGESIZE()) ]
evals/evals-freenode-#perl.lst[7751]: use strict; use warnings; use POSIX; setlocale(LC_NUMERIC, "de_DE") or die $!; sprintf("%.2f", 23.45)
evals/evals-freenode-#perl.lst[7752]: use strict; use warnings; use POSIX; setlocale(LC_NUMERIC, "de_DE"); sprintf("%.2f", 23.45)
evals/evals-freenode-#perl.lst[7753]: use strict; use warnings; use Scalar::Util qw(blessed); [ blessed qr/foo/ ]
evals/evals-freenode-#perl.lst[7754]: use strict; use warnings; use Scalar::Util qw( reftype ); my $foreach = q{}; ref $foreach eq q{CODE}; # No warning.
evals/evals-freenode-#perl.lst[7755]: use strict; use warnings; use Scalar::Util qw( reftype ); my $foreach = q{}; reftype $foreach eq q{CODE}; # Why does this warning occur?
evals/evals-freenode-#perl.lst[7756]: use strict; use warnings; use Scalar::Util qw(reftype); my $re = qr/foo/; [ ref $re, reftype $re ];
evals/evals-freenode-#perl.lst[7757]: use strict; use warnings; use Scalar::Util qw(reftype); my $x = bless \*STDOUT; [ ref $x, reftype $x ];
evals/evals-freenode-#perl.lst[7758]: use strict; use warnings; use Scalar::Util qw(reftype); my $x = []; [ ref $x, reftype $x ];
evals/evals-freenode-#perl.lst[7759]: use strict; use warnings; use Scalar::Util qw(reftype); my $x = {}; [ ref $x, reftype $x ];
evals/evals-freenode-#perl.lst[7760]: use strict; use warnings; use Scalar::Util qw(reftype); my $x = \*STDOUT; [ ref $x, reftype $x ];
evals/evals-freenode-#perl.lst[7761]: use strict; use warnings; use Scalar::Util qw(reftype); my $x = sub{}; [ ref $x, reftype $x ];
evals/evals-freenode-#perl.lst[7762]: use strict; use warnings; use version; my $ver = qv(q{1.0.0}); $ver;
evals/evals-freenode-#perl.lst[7763]: use strict; use warnings; use version; my $ver = qv(q{1.0.0}); version->parse( $ver )->stringify;
evals/evals-freenode-#perl.lst[7764]: use strict; use warnings; vA.10
evals/evals-freenode-#perl.lst[7765]: use strict; use warnings; $::whatever = 'like this'; $::whatever
evals/evals-freenode-#perl.lst[7766]: use strict; while (my $x = 1) { last } continue { say $x }
evals/evals-freenode-#perl.lst[7767]: use strict; $x->()
evals/evals-freenode-#perl.lst[7768]: use strict; @x = (foo => 1, bar => 2); ${{@x}}{"foo"}
evals/evals-freenode-#perl.lst[7769]: use strict; $x = inf;
evals/evals-freenode-#perl.lst[7770]: use String::Util qw/trim/; trim("pink_mist");
evals/evals-freenode-#perl.lst[7771]: use strit; 404->();
evals/evals-freenode-#perl.lst[7772]: use subs 'defined'; sub defined { 42 } defined
evals/evals-freenode-#perl.lst[7773]: use subs 'foo'; sub AUTOLOAD { print 'hi' } foo;
evals/evals-freenode-#perl.lst[7774]: use subs print; sub print {CORE::print "foo: @_"}; print bar;
evals/evals-freenode-#perl.lst[7775]: use subs qw/print/; sub *print {CORE::print "foo: @_"}; print bar;
evals/evals-freenode-#perl.lst[7776]: use subs qw/print/; sub print {CORE::print "foo: @_"}; print bar;
evals/evals-freenode-#perl.lst[7777]: use Sub::Util
evals/evals-freenode-#perl.lst[7778]: use Switch::Plain;
evals/evals-freenode-#perl.lst[7779]: use Test::more
evals/evals-freenode-#perl.lst[7780]: use Test::More
evals/evals-freenode-#perl.lst[7781]: use Tie::IxHash
evals/evals-freenode-#perl.lst[7782]: use Time::HiRes 'time'; time
evals/evals-freenode-#perl.lst[7783]: use Time::HiRes 'time'; time(0); # see, this is a much more sensible error
evals/evals-freenode-#perl.lst[7784]: use Time::HiRes 'time'; time() - $^T;
evals/evals-freenode-#perl.lst[7785]: use Time::HiRes; use POSIX qw(strftime); my $time = Time::HiRes::time; strftime('%Y-%m-%dT%H:%M:%S', gmtime $time) . sprintf '.%.06d', $time - int $time;
evals/evals-freenode-#perl.lst[7786]: use Time::HiRes 'usleep'; usleep(-1);
evals/evals-freenode-#perl.lst[7787]: use Time::Local; $bday="1951/1/1"; ($byear,$bmonth,$bday)=$bday=~/(\d+)\/(\d+)\/(\d+)/; print "".((localtime time)[5]-1900) - (localtime(timelocal(0,0,0,$bday,$bmonth-1,($byear-1900))))[5]+1900
evals/evals-freenode-#perl.lst[7788]: use Time::Local; $bday="1951/1/1"; ($byear,$bmonth,$bday)=$bday=~/(\d+)\/(\d+)\/(\d+)/; print "".((localtime time)[5]-1900) - (localtime(timelocal(0,0,0,$bday,$bmonth-1,$byear)))[5]+1900
evals/evals-freenode-#perl.lst[7789]: use Time::Local; $bday="1978/1/1"; ($byear,$bmonth,$bday)=$bday=~/(\d+)\/(\d+)\/(\d+)/; print "".((localtime time)[5]-1900) - (localtime(timelocal(0,0,0,$bday,$bmonth-1,($byear-1900))))[5]+1900
evals/evals-freenode-#perl.lst[7790]: use Time::Local; $bday="1978/1/1"; ($byear,$bmonth,$bday)=$bday=~/(\d+)\/(\d+)\/(\d+)/; print "".((localtime time)[5]-1900) - (localtime(timelocal(0,0,0,$bday,$bmonth-1,$byear)))[5]+1900
evals/evals-freenode-#perl.lst[7791]: use Time::Local; $bday="1980/1/1"; ($byear,$bmonth,$bday)=$bday=~/(\d+)\/(\d+)\/(\d+)/; print "".((localtime time)[5]-1900) - (localtime(timelocal(0,0,0,$bday,$bmonth-1,($byear-1900))))[5]+1900
evals/evals-freenode-#perl.lst[7792]: use Time::Local; $bday="1984/1/1"; ($byear,$bmonth,$bday)=$bday=~/(\d+)\/(\d+)\/(\d+)/; print "".((localtime time)[5]-1900) - (localtime(timelocal(0,0,0,$bday,$bmonth-1,($byear-1900))))[5]+1900
evals/evals-freenode-#perl.lst[7793]: use Time::localtime; print ctime();
evals/evals-freenode-#perl.lst[7794]: use Time::localtime; print localtime->year()+1900;
evals/evals-freenode-#perl.lst[7795]: use Time::Moment
evals/evals-freenode-#perl.lst[7796]: use Time::Moment; Time::Moment->now
evals/evals-freenode-#perl.lst[7797]: use Time::Piece
evals/evals-freenode-#perl.lst[7798]: use Time::Piece;
evals/evals-freenode-#perl.lst[7799]: use Time::Piece; $ENV{TZ} = 'UTC'; $t1 = Time::Piece->strptime("1:02:03", "%H:%M:%S")->epoch; $t2 = Time::Piece->strptime("4:05:06", "%H:%M:%S")->epoch; [ Time::Piece->new($t1 + $t2)->hms ];  # Syntactic
evals/evals-freenode-#perl.lst[7800]: use Time::Piece; $foo = Time::Piece->strptime('2014-12-25 14:00:10', '%Y-%m-%d %H:%M:%S'); [ scalar CORE::localtime($foo->epoch) ]
evals/evals-freenode-#perl.lst[7801]: use Time::Piece; [localtime->year, localtime->strftime("%a %b %d %H:%M:%S %Z %Y")]
evals/evals-freenode-#perl.lst[7802]: use Time::Piece; my $time = localtime; [map { $time->$_ } qw(mday mon year)]
evals/evals-freenode-#perl.lst[7803]: use Time::Piece; my $time = localtime; ($time->hour >= $open_hour and $time->hour < $close_hour) ? 1 : 0
evals/evals-freenode-#perl.lst[7804]: use Time::Piece; my $t = localtime; [$t->epoch]
evals/evals-freenode-#perl.lst[7805]: use Time::Piece; my $t = localtime; [ $t->mday, $t->month_last_day ]
evals/evals-freenode-#perl.lst[7806]: use Time::Piece; say scalar Time::Piece->strptime("20070930 170004000" =~ s/[0-9]{3}\z//r, "%Y%m%d %H%M%S")->strftime("%F %T")
evals/evals-freenode-#perl.lst[7807]: use Time::Piece; say scalar Time::Piece->strptime("20070930 170004000", "%Y%m%d %H%I%S%3N")->strftime("%F %T")
evals/evals-freenode-#perl.lst[7808]: use Time::Piece; say scalar Time::Piece->strptime("20070930 170004000", "%Y%m%d %H%I%S")->strftime("%F %T")
evals/evals-freenode-#perl.lst[7809]: use Time::Piece; say scalar Time::Piece->strptime("20070930 170004", "%Y%m%d %H%I%S")->strftime("%F %T")
evals/evals-freenode-#perl.lst[7810]: use Time::Piece; Time::Piece->strptime(201407100700, '%Y%m%d%H%M')->epoch
evals/evals-freenode-#perl.lst[7811]: use Time::Piece; Time::Piece->strptime("2015-04-27T15:43:16+02:00", "%Y-%m-%dT%H:%M:%S%z")
evals/evals-freenode-#perl.lst[7812]: use Time::Piece; Time::Piece->strptime("2015-04-27T15:43:16+02:00", "%Y-%m-%dT%H:%M:%S%Z")
evals/evals-freenode-#perl.lst[7813]: use Time::Piece; Time::Piece->strptime("2015-04-27T15:43:16.046379+02:00", "%Y-%m-%dT%H:%M:%S%Z")
evals/evals-freenode-#perl.lst[7814]: use Time::Piece; Time::Piece->strptime("2015-04-27T15:43:16", "%Y-%m-%dT%H:%M:%S")
evals/evals-freenode-#perl.lst[7815]: use Time::Seconds; say ONE_YEAR
evals/evals-freenode-#perl.lst[7816]: use Try::Tiny; $a=1; $b=1; LABL: while($a--) {try {die if $b--} catch {redo LABL;} finally {print "bark "; print "hello world"};
evals/evals-freenode-#perl.lst[7817]: use Try::Tiny; $a=1; $b=1; LABL: while($a--) {try {die if $b--} catch {redo LABL;} finally {print "bark "}; print "hello world"};
evals/evals-freenode-#perl.lst[7818]: use Try::Tiny; $a=1; $b=1; LABL: while($a--) {try {die if $b--} catch {redo LABL;}; print "hello world"};
evals/evals-freenode-#perl.lst[7819]: use Try::Tiny; try {die "baz";} catch {die "foo"} finally { print "hoyl shit that broke"};
evals/evals-freenode-#perl.lst[7820]: use Unicode::UCD qw(charinfo); charinfo('x')
evals/evals-freenode-#perl.lst[7821]: use URI
evals/evals-freenode-#perl.lst[7822]: use URI;
evals/evals-freenode-#perl.lst[7823]: use URI::Encode qw/uri_encode/; uri_encode "<arg>", {"encode_reserved", 1}; 
evals/evals-freenode-#perl.lst[7824]: use URI::Escape;
evals/evals-freenode-#perl.lst[7825]: use URI::Escape qw( uri_escape ); uri_escape q{foo+bar};
evals/evals-freenode-#perl.lst[7826]: use URI::Escape; uri_escape_utf8 "http://web.de/"
evals/evals-freenode-#perl.lst[7827]: use URI; my $foo = URI->new('http://www.example.com?q=Óthelo&s=blah'); $foo->as_string;
evals/evals-freenode-#perl.lst[7828]: use URI; my $u = URI->new( q{http://foo.com/bar?x=1&x=2&y=baz} ); +{ $u->query_form };
evals/evals-freenode-#perl.lst[7829]: use URI; my $u = URI->new( q{http://foo} ); do { no overload; print $u; }
evals/evals-freenode-#perl.lst[7830]: use URI; $u = URI->new("foo", "http"); [ $u->as_string, $u->canonical ]
evals/evals-freenode-#perl.lst[7831]: use utf8;  §$§")/"
evals/evals-freenode-#perl.lst[7832]: use utf8; "–"
evals/evals-freenode-#perl.lst[7833]: use utf8; $☃ = 1; $☃
evals/evals-freenode-#perl.lst[7834]: use utf8; ['٢٠١٦-٠٣-٢٢ ١٨:٥٤:٣٢' =~ /(\d{4}-\d{2}-\d{2}) (\d{2}:\d{2}:\d{2})/]
evals/evals-freenode-#perl.lst[7835]: use utf8; ['٢٠١٦-٠٣-٢٢ ١٨:٥٤:٣٢' =~ /(\d{4}-\d{2}-\d{2}) (\d{2}:\d{2}\d{2})/]
evals/evals-freenode-#perl.lst[7836]: use utf8; ['٢٠١٦-٠٣-٢٢ ١٨:٥٤:٣٢' =~ /(\d{4}-\d{2}-\d{2}) (\d{2}:\d{2}:\d{2})/a]
evals/evals-freenode-#perl.lst[7837]: use utf8; "٢ű" =~ /^\w+$/ # thomas_d
evals/evals-freenode-#perl.lst[7838]: use utf8; '٣' =~ /\d/
evals/evals-freenode-#perl.lst[7839]: use utf8; [ '٣' =~ /\d/a, '٣' =~ /./a, "٢" =~ /[١-٣]/a, '٣' =~ /\D/a ]
evals/evals-freenode-#perl.lst[7840]: use utf8; $🗾 = 42;
evals/evals-freenode-#perl.lst[7841]: use utf8; $✆ = 5;
evals/evals-freenode-#perl.lst[7842]: use utf8; $_ = "æøå"; s/(.)/sprintf('\\u%04x', ord $1)/ger
evals/evals-freenode-#perl.lst[7843]: use utf8; binmode STDOUT, ':utf8'; my $foo = "test\x{327}"; $foo =~ tr/\x{327}/\x{326}/; $foo
evals/evals-freenode-#perl.lst[7844]: use utf8; $bit = "C"; print unpack("b8", $bit) . "\n"; $bit | 1 << 6; $bit = unpack("b8", $bit); print $bi
evals/evals-freenode-#perl.lst[7845]: use utf8; bless {}, "skjærgårdsøl";
evals/evals-freenode-#perl.lst[7846]: use utf8; '𐒢' =~ /\d/
evals/evals-freenode-#perl.lst[7847]: use utf8; '𐒢' =~ /\d/a
evals/evals-freenode-#perl.lst[7848]: use utf8; $_="é"; $_++; $_
evals/evals-freenode-#perl.lst[7849]: use utf8; ['é' =~ /[[:alpha:]]/ . '', 'é' =~ /[[:alpha:]]/a . '']
evals/evals-freenode-#perl.lst[7850]: use utf8; fc "ß"
evals/evals-freenode-#perl.lst[7851]: use utf8; [fc("Ա"), fc("乕")]
evals/evals-freenode-#perl.lst[7852]: use utf8; $こんにちは = "Good afternoon"; $こんにちは
evals/evals-freenode-#perl.lst[7853]: use utf8; $l = "fooso"; [ $l & chr(0x80)x(length $l) ]
evals/evals-freenode-#perl.lst[7854]: use utf8; $l = "fooso"; [ $l =~tr/\0-\225//dr   ]
evals/evals-freenode-#perl.lst[7855]: use utf8; [ map fc, qw(SS ss ß Σ σ ς I i İ ı) ]
evals/evals-freenode-#perl.lst[7856]: use utf8; [ map lc, qw(SS ss ß Σ σ ς I i İ ı) ]
evals/evals-freenode-#perl.lst[7857]: use utf8; my $å = "buu"
evals/evals-freenode-#perl.lst[7858]: use utf8; my %foo = ('♥' => 'lukelove'); print $foo{'♥'} . 'fuckit';
evals/evals-freenode-#perl.lst[7859]: use utf8; my %foo = ('♥' => 'lukelove'); say $foo{'♥'};
evals/evals-freenode-#perl.lst[7860]: use utf8; my $foo = "test\x{327}"; $foo =~ tr/\x{327}/\x{326}/; $foo
evals/evals-freenode-#perl.lst[7861]: use utf8; my $input = '٣'; say $input + 42;
evals/evals-freenode-#perl.lst[7862]: use utf8; my $str = "Äö"; [ $str =~ /([[:upper:]])/ ]
evals/evals-freenode-#perl.lst[7863]: use utf8;  my $szín = 1; $szín + 1
evals/evals-freenode-#perl.lst[7864]: use utf8; my $x = "ABC"; $x =~ tr/ABC/ＡＢＣ/; sprintf "%vx", $x
evals/evals-freenode-#perl.lst[7865]: use utf8; my $x = "Bière"; printf "%vx", $x;
evals/evals-freenode-#perl.lst[7866]: use utf8; my $x = "café"; my $y = substr($x, 1); [ utf8::is_utf8($x), utf8::is_utf8($y) ]
evals/evals-freenode-#perl.lst[7867]: use utf8; my $α, $β; #these are fine, my $a, $b; is not :P
evals/evals-freenode-#perl.lst[7868]: use utf8; [ord "ĉ"]
evals/evals-freenode-#perl.lst[7869]: use utf8; ord "ĉ"
evals/evals-freenode-#perl.lst[7870]: use utf8; [ord "ø"]
evals/evals-freenode-#perl.lst[7871]: use utf8; [ord "ű"]
evals/evals-freenode-#perl.lst[7872]: use utf8; ord uc "ñ"
evals/evals-freenode-#perl.lst[7873]: use utf8; package µ; sub message { "Hi" };  say µ->message;
evals/evals-freenode-#perl.lst[7874]: use utf8; 'pokèmon' =~ /\bpok[eè]mon\b/
evals/evals-freenode-#perl.lst[7875]: use utf8; print "a"; print "b"
evals/evals-freenode-#perl.lst[7876]: use utf8; print join "", ("?".."?");
evals/evals-freenode-#perl.lst[7877]: use utf8; q ̈hellö
evals/evals-freenode-#perl.lst[7878]: use utf8; q̈hellö
evals/evals-freenode-#perl.lst[7879]: use utf8; quotemeta "ǁ"
evals/evals-freenode-#perl.lst[7880]: use utf8; "ǁ" =~ s/([^A-Za-z_0-9])/\\$1/gr
evals/evals-freenode-#perl.lst[7881]: use utf8; [ scalar('٣' =~ /^\d$/a), scalar('٣' =~ /^.$/a), scalar("٢" =~ /^[١-٣]$/a), scalar('٣' =~ /^\D$/a) ]
evals/evals-freenode-#perl.lst[7882]: use utf8; [ scalar('٣' =~ /\d/a), scalar('٣' =~ /./a), scalar("٢" =~ /[١-٣]/a), scalar('٣' =~ /\D/a) ]
evals/evals-freenode-#perl.lst[7883]: use utf8; sprintf "%x", ord "ő"
evals/evals-freenode-#perl.lst[7884]: use utf8; sprintf "%x", ord uc "ñ"
evals/evals-freenode-#perl.lst[7885]: use utf8; [ 'ß' =~ m/^\Qss\E\z/i ? 'True' : 'False' ];
evals/evals-freenode-#perl.lst[7886]: use utf8; sub a b { "hi" } a b
evals/evals-freenode-#perl.lst[7887]: use utf8; sub fåbar { print "whee" } fåbar();
evals/evals-freenode-#perl.lst[7888]: use utf8; sub InGerm { join "\n", map sprintf("%x", ord($_)), qw(ä ö ü) } "ö" =~ /\p{InGerm}/
evals/evals-freenode-#perl.lst[7889]: use utf8; sub » { print "whee" } »()
evals/evals-freenode-#perl.lst[7890]: use utf8; sub t { 1, 2, 3 } t⦇0⦈
evals/evals-freenode-#perl.lst[7891]: use utf8; sub ಠ_ಠ { "yay" } ಠ_ಠ
evals/evals-freenode-#perl.lst[7892]: use utf8; sub 个 { print "whee" } 个();
evals/evals-freenode-#perl.lst[7893]: use utf8; uc "ñ"
evals/evals-freenode-#perl.lst[7894]: use utf8; uc "ß"
evals/evals-freenode-#perl.lst[7895]: use utf8; unpack "H2", "ő"
evals/evals-freenode-#perl.lst[7896]: use utf8; use constant Foo => join "\n", map sprintf("%x", ord($_)), qw(ä ö ü); [ "ö" =~ /\p{Foo}/ ];
evals/evals-freenode-#perl.lst[7897]: use utf8; use constant InFoo => join "\n", map sprintf("%x", ord($_)), qw(ä ö ü); [ "ö" =~ /\p{InFoo}/ ];
evals/evals-freenode-#perl.lst[7898]: use utf8; use feature fc; [fc("Ա"), fc("乕")]
evals/evals-freenode-#perl.lst[7899]: use utf8; use Mojo::UserAgent; Mojo::UserAgent->new->get('http://mañana.com')->res->dom->at('title')->text
evals/evals-freenode-#perl.lst[7900]: use utf8; use strict; sub ℕ₀ () { "cool" } ℕ₀
evals/evals-freenode-#perl.lst[7901]: use utf8; [ "Ӧser Bánana" =~ /\w+/g ]
evals/evals-freenode-#perl.lst[7902]: use utf8; "Я очень плохо говорю по русский"
evals/evals-freenode-#perl.lst[7903]: use utf8; $Ա = 5; $乕 = 7; [ $Ա + $乕 ]
evals/evals-freenode-#perl.lst[7904]: use utf8; ["Ա" < "乕"?"yes":"no"]
evals/evals-freenode-#perl.lst[7905]: use v5.12; $foo = 'bar'; ++$$foo; $bar
evals/evals-freenode-#perl.lst[7906]: use v5.12; "foo" =~ /(.*)/; say $1; { if ("bar" =~ /(.*)/) { say $1; } } say $1;
evals/evals-freenode-#perl.lst[7907]: use v5.12; "foo" =~ /(.*)/; say $1; if ("bar" =~ /(.*)/) { say $1; } say $1;
evals/evals-freenode-#perl.lst[7908]: use v5.12; sub combine { my $f = shift; @_ or return $f->(); my $xs = shift; for my $x (@$xs) { combine(sub { $f->($x, @_) }, @_); } } combine sub { say join(", ", @_) }, ['a', 'b'], [1], [2, 3];
evals/evals-freenode-#perl.lst[7909]: use v5.12; sub combine { my $f = shift; @_ or return $f->(); my $xs = shift; for my $x (@$xs) { combine(sub { $f->($x, @_) }, @_); } } combine sub { say join(", ", @_), " | "; }, ['a', 'b'], [1], [2, 3];
evals/evals-freenode-#perl.lst[7910]: use v5.12; ++$x
evals/evals-freenode-#perl.lst[7911]: use v5.16; $[ = 0
evals/evals-freenode-#perl.lst[7912]: use v5.16; $[ = 1
evals/evals-freenode-#perl.lst[7913]: use v5.16; $_=1; $0xfc
evals/evals-freenode-#perl.lst[7914]: use v5.16; $_=1; $0x fc
evals/evals-freenode-#perl.lst[7915]: use v5.16; $[ = -5;
evals/evals-freenode-#perl.lst[7916]: use v5.16; my $f = sub { my ($n) = @_; print "$n "; $n or return; @_ = $n - 1; goto __SUB__; }; $f->(5);
evals/evals-freenode-#perl.lst[7917]: use v5.16; ++$x
evals/evals-freenode-#perl.lst[7918]: use v5.18; 1;
evals/evals-freenode-#perl.lst[7919]: use v5.18.2;
evals/evals-freenode-#perl.lst[7920]: use v5.20; my @x; push @x, foo(), foo(); sub foo { state $var = 0; $var++ } push @x, foo(), foo(); \@x
evals/evals-freenode-#perl.lst[7921]: use v5.20; say hi
evals/evals-freenode-#perl.lst[7922]: use v5.20; say "hi" for Altreus;
evals/evals-freenode-#perl.lst[7923]: use v5.20; sub foo { __SUB__ } foo
evals/evals-freenode-#perl.lst[7924]: use v5.20; use warnings; { package Hi; sub foo { state $x = 0; $x++ }  sub new { bless {}, $_[0] } }  [ Hi->new->foo, Hi->new->foo, Hi->new->foo ]
evals/evals-freenode-#perl.lst[7925]:  use v5.6.1;
evals/evals-freenode-#perl.lst[7926]: use Variable::Magic qw(cast wizard); cast my $foo = 4, wizard get => sub { ${$_[0]}++ }; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say "surprise!" }
evals/evals-freenode-#perl.lst[7927]: use vars qw( $foo ); $foo = 123; $foo;
evals/evals-freenode-#perl.lst[7928]: use version; my $v = version->new( 1.000001 ); printf q{%vd}, $v;
evals/evals-freenode-#perl.lst[7929]: use version; my $v = version->new( 1.000001 ); $v;
evals/evals-freenode-#perl.lst[7930]: use version; print version->parse($])->normal
evals/evals-freenode-#perl.lst[7931]: use warnings;
evals/evals-freenode-#perl.lst[7932]: use warnings; "" == ""
evals/evals-freenode-#perl.lst[7933]: use warnings; ();
evals/evals-freenode-#perl.lst[7934]: use warnings; {{}}
evals/evals-freenode-#perl.lst[7935]: use warnings; $#
evals/evals-freenode-#perl.lst[7936]: use warnings; +{{}}
evals/evals-freenode-#perl.lst[7937]: use warnings;  [ !!"" == 0 ]
evals/evals-freenode-#perl.lst[7938]: use warnings;  [ "" == 0 ]
evals/evals-freenode-#perl.lst[7939]: use warnings; @_[0]
evals/evals-freenode-#perl.lst[7940]: use warnings; 0 + ''
evals/evals-freenode-#perl.lst[7941]: use warnings; 0+''
evals/evals-freenode-#perl.lst[7942]: use warnings; 0+""
evals/evals-freenode-#perl.lst[7943]: use warnings; 0+{}
evals/evals-freenode-#perl.lst[7944]: use warnings; 0->[0];
evals/evals-freenode-#perl.lst[7945]: use warnings; 00./(?[()])/
evals/evals-freenode-#perl.lst[7946]: use warnings; 0+!1
evals/evals-freenode-#perl.lst[7947]: use warnings; 0 + !5
evals/evals-freenode-#perl.lst[7948]: use warnings; 0+'    9'
evals/evals-freenode-#perl.lst[7949]: use warnings; 0+"    9e5";  # boo!
evals/evals-freenode-#perl.lst[7950]: use warnings; 0+"    9e";  # yay!
evals/evals-freenode-#perl.lst[7951]: use warnings; 0+("a" eq "b")
evals/evals-freenode-#perl.lst[7952]: use warnings; [ '' == 0 ] # but you'll get a warning
evals/evals-freenode-#perl.lst[7953]: use warnings; 0 + defined( undef )
evals/evals-freenode-#perl.lst[7954]: use warnings; 0+'Inf'
evals/evals-freenode-#perl.lst[7955]: use warnings; 0+'nanny'
evals/evals-freenode-#perl.lst[7956]: use warnings; '0' == undef
evals/evals-freenode-#perl.lst[7957]: use warnings; $0 = undef; "hello $0"
evals/evals-freenode-#perl.lst[7958]: use warnings; [ 1 + "" ]
evals/evals-freenode-#perl.lst[7959]: use warnings; $_[100]=();"@_"
evals/evals-freenode-#perl.lst[7960]: use warnings; !1 == !1
evals/evals-freenode-#perl.lst[7961]: use warnings; [ 1 == "1" ]
evals/evals-freenode-#perl.lst[7962]: use warnings; [ 1 == "1foo" ]
evals/evals-freenode-#perl.lst[7963]: use warnings; 1+2; 3+4
evals/evals-freenode-#perl.lst[7964]: use warnings; '15.8' == '123abc   '
evals/evals-freenode-#perl.lst[7965]: use warnings; '15.8' == undef
evals/evals-freenode-#perl.lst[7966]: use warnings; '15.8' == (undef // '')
evals/evals-freenode-#perl.lst[7967]: use warnings; '15.8' == (undef // ')'
evals/evals-freenode-#perl.lst[7968]: use warnings; '15.8' == undef // ''
evals/evals-freenode-#perl.lst[7969]: use warnings 1e0;
evals/evals-freenode-#perl.lst[7970]: use warnings; [ 1 + "NaN" ]
evals/evals-freenode-#perl.lst[7971]: use warnings; [ 1 + "Nanny may I have another?" ]
evals/evals-freenode-#perl.lst[7972]: use warnings; [ 1 + "not a number" ]
evals/evals-freenode-#perl.lst[7973]: use warnings; 2 + '0 but foo'
evals/evals-freenode-#perl.lst[7974]: use warnings; 2 + '0 but true'
evals/evals-freenode-#perl.lst[7975]: use warnings; $[ = 2; my @a = 5..9; [ keys @a], $#a ]
evals/evals-freenode-#perl.lst[7976]: use warnings; 3 + undef
evals/evals-freenode-#perl.lst[7977]: use warnings; $] < 5.13.6
evals/evals-freenode-#perl.lst[7978]: use warnings; [ 5 <=> "infinityandbeyond", 8 <=> "nananananananananaBATMAN" ]
evals/evals-freenode-#perl.lst[7979]: use warnings; [ 7 <=> "cats" ]
evals/evals-freenode-#perl.lst[7980]: use warnings; [ 7 <=> "nan" ]
evals/evals-freenode-#perl.lst[7981]: use warnings; [ 7 <=> "nand" ]
evals/evals-freenode-#perl.lst[7982]: use warnings; [ 7 <=> "nandos" ]
evals/evals-freenode-#perl.lst[7983]: use warnings; 'a' < 0
evals/evals-freenode-#perl.lst[7984]: use warnings; @a[1]
evals/evals-freenode-#perl.lst[7985]: use warnings; [ "a{b" =~ /a{/ ]
evals/evals-freenode-#perl.lst[7986]: use warnings; "a{b" =~ m/{/;
evals/evals-freenode-#perl.lst[7987]: use warnings; "a{b" =~ m/a{/;
evals/evals-freenode-#perl.lst[7988]: use warnings; @a = (); print 'true' if @a == undef;
evals/evals-freenode-#perl.lst[7989]: use warnings; @array[0]=5
evals/evals-freenode-#perl.lst[7990]: use warnings; $array[99999]=5; 0+ $array[99998]
evals/evals-freenode-#perl.lst[7991]: use warnings; @array[$index]
evals/evals-freenode-#perl.lst[7992]: use warnings; "a" =~ s/./$1/gr
evals/evals-freenode-#perl.lst[7993]: use warnings; "a" =~ s/./$1/r
evals/evals-freenode-#perl.lst[7994]: use warnings; "a" =~ s/./$dict{1}/r
evals/evals-freenode-#perl.lst[7995]: use warnings; 'bill.gates@microsoft.com' =~ /[\w.]+\@microsoft\.com$/ ? "matches" : "does not"
evals/evals-freenode-#perl.lst[7996]: use warnings; binmode STDOUT; print "\x{1f4a9}"
evals/evals-freenode-#perl.lst[7997]: use warnings; "blah" == "bleh"
evals/evals-freenode-#perl.lst[7998]: use warnings; @bucket_store_content{ $_path_dismantled_tmp[-2] }
evals/evals-freenode-#perl.lst[7999]: use warnings; @confignew{ "vm-id" } = [@listvm];
evals/evals-freenode-#perl.lst[8000]: use warnings; CORE::localtime() - 3600
evals/evals-freenode-#perl.lst[8001]: use warnings; die, die, die;
evals/evals-freenode-#perl.lst[8002]: use warnings; [ $$, do { $a=++$$.s/../$$/;$$<<~~+$a } ]
evals/evals-freenode-#perl.lst[8003]: use warnings; dump
evals/evals-freenode-#perl.lst[8004]: use warnings; each []
evals/evals-freenode-#perl.lst[8005]: use warnings; -e "foo\nbar";
evals/evals-freenode-#perl.lst[8006]: use warnings; [ 'endurance' == 'strength' ? 'yes' : 'no' ]
evals/evals-freenode-#perl.lst[8007]: use warnings; eval{print 1; next; print 2}
evals/evals-freenode-#perl.lst[8008]: use warnings; eval{print 1; next; print 2}; print 'code: '.$?
evals/evals-freenode-#perl.lst[8009]: use warnings; eval { $x->{a}{b} }
evals/evals-freenode-#perl.lst[8010]: use warnings; exit "with a string"
evals/evals-freenode-#perl.lst[8011]: use warnings FATAL => "all"; if (1 { my $x = 42; print $x; }
evals/evals-freenode-#perl.lst[8012]: use warnings FATAL => 'utf8'; use Unicode::UTF8 'decode_utf8'; decode_utf8 "\x20\xf8\x20"
evals/evals-freenode-#perl.lst[8013]: use warnings; [ -f "/", -f "/does-not-exist", -f undef ]
evals/evals-freenode-#perl.lst[8014]: use warnings; @foo = (1,2,3); length(@foo)
evals/evals-freenode-#perl.lst[8015]: use warnings; "foo" ~~ "Bar"
evals/evals-freenode-#perl.lst[8016]: use warnings; "{{foo" =~ /{{f/
evals/evals-freenode-#perl.lst[8017]: use warnings; $foo = $foo . "abc";
evals/evals-freenode-#perl.lst[8018]: use warnings; 'foo' =~ s/(.)/\1/
evals/evals-freenode-#perl.lst[8019]: use warnings; 'foo' =~ s/(.)/\1/re
evals/evals-freenode-#perl.lst[8020]: use warnings; "foo"=~s/(foo)/\1/r
evals/evals-freenode-#perl.lst[8021]: use warnings; @hash{$key}
evals/evals-freenode-#perl.lst[8022]: use warnings; @hash{$key} = [ @list ]
evals/evals-freenode-#perl.lst[8023]: use warnings; $hash{thing} => $value;
evals/evals-freenode-#perl.lst[8024]: use warnings; ${^HELLO_GUYS} . ""
evals/evals-freenode-#perl.lst[8025]: use warnings;+{[ here => "are", my => "values" ]}
evals/evals-freenode-#perl.lst[8026]: use warnings; hex q{112233445566778899}
evals/evals-freenode-#perl.lst[8027]: use warnings; %h = { stuff => 'sterf' }; \%h
evals/evals-freenode-#perl.lst[8028]: use warnings; if (1 { my $x = 42; print $x; }
evals/evals-freenode-#perl.lst[8029]: use warnings; if("a" == "b"){print "true";}else{print "false";}
evals/evals-freenode-#perl.lst[8030]: use warnings; if (my $blah) { my $count = read $fh, my ($chunk), $chunk_size; }
evals/evals-freenode-#perl.lst[8031]: use warnings; if (my $blah) { my $count = read $fh, my $chunk, ($chunk_size); }
evals/evals-freenode-#perl.lst[8032]: use warnings; if (my $blah) { my $count = read $fh, my $chunk, $chunk_size }
evals/evals-freenode-#perl.lst[8033]: use warnings; if (my $blah) { my $count = read $fh, my $chunk, $chunk_size; }
evals/evals-freenode-#perl.lst[8034]: use warnings; if (my $blah) { my $count = read $fh, my $chunk, +$chunk_size; }
evals/evals-freenode-#perl.lst[8035]: use warnings; if ($_) { sub foo { ... } } else { sub foo { ... } }
evals/evals-freenode-#perl.lst[8036]: use warnings; if ("this section commented out" x 0) { die }
evals/evals-freenode-#perl.lst[8037]: use warnings; $INC{42}
evals/evals-freenode-#perl.lst[8038]: use warnings; int(q("1"))
evals/evals-freenode-#perl.lst[8039]: use warnings; join " ", undef, undef, undef;
evals/evals-freenode-#perl.lst[8040]: use warnings; join '', (undef)x100
evals/evals-freenode-#perl.lst[8041]: use warnings; keys +{}
evals/evals-freenode-#perl.lst[8042]: use warnings; keys INC
evals/evals-freenode-#perl.lst[8043]: use warnings; LABEL: { sub { last LABEL }->(); print "fail" }; print "ok";
evals/evals-freenode-#perl.lst[8044]: use warnings; [ map { $_ + 0 } !!0, !!"", !!undef ]
evals/evals-freenode-#perl.lst[8045]: use warnings; [ map { ($_+0) ? 'True' : 'False' } 0, '0', '0 but true', '0e0', '0.0' ]
evals/evals-freenode-#perl.lst[8046]: use warnings; [ map { $_ ? 'True' : 'False' } 0, '0', '0 but true', '0e0', '0.0' ]
evals/evals-freenode-#perl.lst[8047]: use warnings; ''.methods.length
evals/evals-freenode-#perl.lst[8048]: use warnings; "@microsoft.com" =~ /microsoft.com$/ ? "matches" : "does not"
evals/evals-freenode-#perl.lst[8049]: use warnings; m/$var/
evals/evals-freenode-#perl.lst[8050]: use warnings; my $_;
evals/evals-freenode-#perl.lst[8051]: use warnings; my @a = 1..3; my %hash = @a;
evals/evals-freenode-#perl.lst[8052]: use warnings; my $a=5+3, "hello\n";
evals/evals-freenode-#perl.lst[8053]: use warnings; my $a=5+3, "hello\n"; print $a
evals/evals-freenode-#perl.lst[8054]: use warnings; my @a = 5..9; delete $a[3] [ keys @a ]
evals/evals-freenode-#perl.lst[8055]: use warnings; my @a = 5..9; delete $a[3]; [ keys @a ]
evals/evals-freenode-#perl.lst[8056]: use warnings; my @a = 5..9; delete $a[4]; [ keys @a ]
evals/evals-freenode-#perl.lst[8057]: use warnings; my @a = 5..9; delete $a[4]; [ [keys @a], $#a ]
evals/evals-freenode-#perl.lst[8058]: use warnings; my @a = 5..9; [ keys @a ]
evals/evals-freenode-#perl.lst[8059]: use warnings; my $aref = [1,2,3]; @{$aref}[1]
evals/evals-freenode-#perl.lst[8060]: use warnings; my $aref = [1,2,3]; my $two = @{$aref}[1]
evals/evals-freenode-#perl.lst[8061]: use warnings; my %args = { foo => 'bar' };
evals/evals-freenode-#perl.lst[8062]: use warnings; my @arr = 1 .. 10; length(0 + @arr)
evals/evals-freenode-#perl.lst[8063]: use warnings; my @arr = 1 .. 10; length('' . @arr)
evals/evals-freenode-#perl.lst[8064]: use warnings; my @arr = 1 .. 10; length(@arr)
evals/evals-freenode-#perl.lst[8065]: use warnings; my $arr = [1 .. 10]; length('' . @$arr)
evals/evals-freenode-#perl.lst[8066]: use warnings; my @arr = 1 .. 10; length(map "now that's just silly", @arr)
evals/evals-freenode-#perl.lst[8067]: use warnings; my @arr = (1, 3); @arr[0]
evals/evals-freenode-#perl.lst[8068]: use warnings; my @arr; $arr["anything"] = 42;
evals/evals-freenode-#perl.lst[8069]: use warnings; my @arr; $arr["inf"] = 42; [ @arr ]
evals/evals-freenode-#perl.lst[8070]: use warnings; my @arr; $arr["NaN"] = 42;
evals/evals-freenode-#perl.lst[8071]: use warnings; my @arr; $arr["NaN"] = 42; [ @arr ]
evals/evals-freenode-#perl.lst[8072]: use warnings; my @array; print $array[5];
evals/evals-freenode-#perl.lst[8073]: use warnings; my $buf = "\x{666}"; open my $fh, '<', \$buf or die "open: $!"
evals/evals-freenode-#perl.lst[8074]: use warnings; my $buf = "\x{666}"; open my $fh, '<:encoding(utf8)', \$buf or die "open: $!"
evals/evals-freenode-#perl.lst[8075]: use warnings; my $buf = "\xd9\xa6"; open my $fh, '<:encoding(utf8)', \$buf or die "open: $!"
evals/evals-freenode-#perl.lst[8076]: use warnings; my @foo = 0..10; print "this matches" if "0 but true" ~~ @foo;
evals/evals-freenode-#perl.lst[8077]: use warnings; my @foo = 0..10; print "this matches" if "0 but true" ~~ @foo; # thanks, pink_mist++
evals/evals-freenode-#perl.lst[8078]: use warnings; my @foo = 0..10; print "this matches" if "0 but true" ~~ @foo; ... too vague for predictable behavior, use the comparison you mean or try Smart::Match for explicit smartmatching
evals/evals-freenode-#perl.lst[8079]: use warnings; my @foo = 0..10; print "this matches" if "0 but true" ~~ @foo; ... too vague for predictable behavior, use the comparison you mean or try Smart::Match for explicit smartmatching | "Any non-trivial example of smartmatch usually does something other than the author intended."
evals/evals-freenode-#perl.lst[8080]: use warnings; my @foo = 0..10; "this matches" if "0 but true" ~~ @foo;
evals/evals-freenode-#perl.lst[8081]: use warnings; my $foo = 1,2;
evals/evals-freenode-#perl.lst[8082]: use warnings; my $foo = 1,2,3; $foo
evals/evals-freenode-#perl.lst[8083]: use warnings; my $foo = 1,2; $foo
evals/evals-freenode-#perl.lst[8084]: use warnings; my $foo = 1; my $bar = 2; my $name = "foo"; print "ok" if (defined(${$name}));
evals/evals-freenode-#perl.lst[8085]: use warnings; my $foo = 1; my $foobar = 2; "$foo\bar"
evals/evals-freenode-#perl.lst[8086]: use warnings; my $foo = 1; undef $foo; say $foo
evals/evals-freenode-#perl.lst[8087]: use warnings; my $foo, *bar;
evals/evals-freenode-#perl.lst[8088]: use warnings; my @foo; defined @foo
evals/evals-freenode-#perl.lst[8089]: use warnings; my $foo; $foo; 1;
evals/evals-freenode-#perl.lst[8090]: use warnings; my $foo = { foo => 42}; [ keys  $foo]
evals/evals-freenode-#perl.lst[8091]: use warnings; { my $foo; my $foo; }
evals/evals-freenode-#perl.lst[8092]: use warnings; my $foo; { my $foo; }
evals/evals-freenode-#perl.lst[8093]: use warnings; my $foo = sub { +{ content => 'content' }; }; $foo->()->{content};
evals/evals-freenode-#perl.lst[8094]: use warnings; my $foo = sub { +{ content => 'content' }; }; $foo->(){'content'};
evals/evals-freenode-#perl.lst[8095]: use warnings; my $foo = sub { +{ content => 'content' }; }; $foo->(){content};
evals/evals-freenode-#perl.lst[8096]: use warnings; my $foo = undef; "$foo"
evals/evals-freenode-#perl.lst[8097]: use warnings; my %hash = undef;
evals/evals-freenode-#perl.lst[8098]: use warnings; my @list = 0 .. 10; [%list[1..2]]
evals/evals-freenode-#perl.lst[8099]: use warnings; my @list = "a" .. "h"; [%list[1..3]]
evals/evals-freenode-#perl.lst[8100]: use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; eval qq{ 'Just another Unicode hacker,' =~ tr[\Q$l\E][\Q$r\E]r };
evals/evals-freenode-#perl.lst[8101]: use warnings; my $n=split(/\|/,"one|two|three|four");
evals/evals-freenode-#perl.lst[8102]: use warnings; my $n = () = split(/\|/,"one|two|three|four");
evals/evals-freenode-#perl.lst[8103]: use warnings; my $ref = []; @$ref[0]
evals/evals-freenode-#perl.lst[8104]: use warnings; my $ret = "foo" =~ s/Z/; [ $ret."", $ret+0 ]
evals/evals-freenode-#perl.lst[8105]: use warnings; my $ret = "foo" =~ s/Z//; [ $ret."", $ret+0 ]
evals/evals-freenode-#perl.lst[8106]: use warnings; my $ret = ( my $tmp = "foo" ) =~ s/Z//; [ $ret."", $ret+0 ]
evals/evals-freenode-#perl.lst[8107]: use warnings; my $str; chomp($str);
evals/evals-freenode-#perl.lst[8108]: use warnings; my $undefined; $undefined =~ s///;
evals/evals-freenode-#perl.lst[8109]: use warnings; my $value = undef;  undef == 2
evals/evals-freenode-#perl.lst[8110]: use warnings; my $value = undef;  $value == 2
evals/evals-freenode-#perl.lst[8111]: use warnings; my $x = 12; [ "19" . $x ]
evals/evals-freenode-#perl.lst[8112]: use warnings; my $x = 12; [ 19 . $x ]
evals/evals-freenode-#perl.lst[8113]: use warnings; my $x = "1234abc"; $x++; $x
evals/evals-freenode-#perl.lst[8114]: use warnings; my $x = "abcd"; $x++; $x
evals/evals-freenode-#perl.lst[8115]: use warnings; my $xml = { sessions => [ { session => { status => 42 } } ] }; $xml->{sessions}{session}{status}
evals/evals-freenode-#perl.lst[8116]: use warnings; my $x, my $x;
evals/evals-freenode-#perl.lst[8117]: use warnings; my ($x, $x)
evals/evals-freenode-#perl.lst[8118]: use warnings; my $x; $x += 2;
evals/evals-freenode-#perl.lst[8119]: use warnings; my $x; $x .= "foo";
evals/evals-freenode-#perl.lst[8120]: use warnings; my $x; $x . 'foo'
evals/evals-freenode-#perl.lst[8121]: use warnings; my $x; $x = $x . 'foo'; # Zoffix
evals/evals-freenode-#perl.lst[8122]: use warnings; my ($x, $y, $var) = (42, 37, 0); $var += max $x, $y; $var
evals/evals-freenode-#perl.lst[8123]: use warnings; my($x, $y, $x)
evals/evals-freenode-#perl.lst[8124]: use warnings; my ($x, $y) = ($y, $x);
evals/evals-freenode-#perl.lst[8125]: use warnings; no warnings 'experimental::autoderef'; keys +{}
evals/evals-freenode-#perl.lst[8126]: use warnings "\N{U+7FFFFFFF}"
evals/evals-freenode-#perl.lst[8127]: use warnings; "\N{U+7FFFFFFF}"
evals/evals-freenode-#perl.lst[8128]: use warnings; opendir my $dirh, ".";
evals/evals-freenode-#perl.lst[8129]: use warnings; open $fh, '<', \"lala\nlulu"; join '|', <$fh>
evals/evals-freenode-#perl.lst[8130]: use warnings; open $fh, "lala\nlulu"; join '|', <$fh>
evals/evals-freenode-#perl.lst[8131]: use warnings; open $fh, \ "lala\nlulu"; join '|', <$fh>
evals/evals-freenode-#perl.lst[8132]: use warnings; open my $fh, '>&=', 2
evals/evals-freenode-#perl.lst[8133]: use warnings;  our $NEGATIVE_INDICES = 1; sub M::TIEARRAY { bless {}, shift } sub M::FETCH { print "Element $_[1]" }  tie my @arr, "M";   $arr["onetwothree"]
evals/evals-freenode-#perl.lst[8134]: use warnings; pop INC
evals/evals-freenode-#perl.lst[8135]: use warnings; print 'argh' and exit if $error;
evals/evals-freenode-#perl.lst[8136]: use warnings; print("~/")."\n"
evals/evals-freenode-#perl.lst[8137]: use warnings; print "\x{2603}"
evals/evals-freenode-#perl.lst[8138]: use warnings; push INC, undef;
evals/evals-freenode-#perl.lst[8139]: use warnings; qr{(?(DEFINE)(?<A>(?&B)|(?&C))}xms;
evals/evals-freenode-#perl.lst[8140]: use warnings; qw(1,2,3)
evals/evals-freenode-#perl.lst[8141]: use warnings qw(experimental); my sub foo { ... }
evals/evals-freenode-#perl.lst[8142]: use warnings; readline "{a,b,c}"
evals/evals-freenode-#perl.lst[8143]: use warnings; [ ref undef ]
evals/evals-freenode-#perl.lst[8144]: use warnings; reset
evals/evals-freenode-#perl.lst[8145]: use warnings; say undef
evals/evals-freenode-#perl.lst[8146]: use warnings; scalar( 0, 1, 0, 1 );
evals/evals-freenode-#perl.lst[8147]: use warnings; scalar( 2, 3, 4, 5 );
evals/evals-freenode-#perl.lst[8148]: use warnings; scalar grep {     $_ == 0 or $_ % 2 == 0 or $_ % 3 == 0 or $_ % 5 == 0 or $_ % 7 == 0 } map eval, glob join '{+,-,}', split //, "7474810769";
evals/evals-freenode-#perl.lst[8149]: use warnings; scalar grep {     $_ == 0 or $_ % 2 == 0 or $_ % 3 == 0 or $_ % 5 == 0 or $_ % 7 == 0 } map eval, map s{[^0-9]\K0([0-9])}{$1}gr, glob join "{+,-,}", split //, "7474810769";
evals/evals-freenode-#perl.lst[8150]: use warnings; set_status => 'available';
evals/evals-freenode-#perl.lst[8151]: use warnings; s///gI
evals/evals-freenode-#perl.lst[8152]: use warnings; [ sort { $a != $a ? 1 : $b != $b ? -1 : $a <=> $b } 0, 7, "nan", 3 ]
evals/evals-freenode-#perl.lst[8153]: use warnings; [ sort { $a <=> $b } 4, 15, 11, "NaN", 11, 2, 1, 4, 3, "nan", 8 ]
evals/evals-freenode-#perl.lst[8154]: use warnings; [ sort { $a <=> $b } 7, 0, "nan", 3 ]
evals/evals-freenode-#perl.lst[8155]: use warnings; [ sort { "NaN" } 4, 15, 11, 11, 2, 1, 4, 3, 8 ]
evals/evals-freenode-#perl.lst[8156]: use warnings; splice @a, 2, 2, qw/foo bar/; \@a
evals/evals-freenode-#perl.lst[8157]: use warnings; "string"->{key}
evals/evals-freenode-#perl.lst[8158]: use warnings; ${\"string"}->{key}
evals/evals-freenode-#perl.lst[8159]: use warnings; sub a { my $x=2; sub b { print $x } } a()
evals/evals-freenode-#perl.lst[8160]: use warnings; sub a { my $x=2; sub b ($x) { my $x = $_[0]; print $x; } } a()
evals/evals-freenode-#perl.lst[8161]: use warnings; sub f { my $foo .= "x" if shift; $foo .= shift; "$foo "; } f(0,0).f(0,1);
evals/evals-freenode-#perl.lst[8162]: use warnings; sub f { my $foo .= "x" if shift; $foo .= shift; "$foo "; } f(1,0).f(0,1);
evals/evals-freenode-#perl.lst[8163]: use warnings; sub foo {1} $x = foo and 1
evals/evals-freenode-#perl.lst[8164]: use warnings; sub foo(){{}} %{foo}
evals/evals-freenode-#perl.lst[8165]: use warnings; sub foo { @foos = 0; return @foos } @x = 'a' .. 'c'; [@x[foo()], $x[foo()]];
evals/evals-freenode-#perl.lst[8166]: use warnings; sub foo { @foos = 0 } @x = 'a' .. 'c'; @x[foo()]
evals/evals-freenode-#perl.lst[8167]: use warnings; sub foo { @foos = 1; return @foos } @x = 'a' .. 'c'; [@x[foo()], $x[foo()]];
evals/evals-freenode-#perl.lst[8168]: use warnings; sub foo { @foos = 1 } @x = 'a' .. 'c'; [@x[foo()], $x[foo()]];
evals/evals-freenode-#perl.lst[8169]: use warnings; sub foo(){{}} my %foo; %{foo}
evals/evals-freenode-#perl.lst[8170]: use warnings; sub foo { my $x = 1; sub bar {my $y = 2;}}; foo(); bar();
evals/evals-freenode-#perl.lst[8171]: use warnings; sub foo { my $x = 1; sub bar {my $y = $x} }
evals/evals-freenode-#perl.lst[8172]: use warnings; sub foo { my $x = 1; sub bar {$x++}}; foo(); bar();
evals/evals-freenode-#perl.lst[8173]: use warnings; sub foo (&@) { sub foo; }
evals/evals-freenode-#perl.lst[8174]: use warnings; sub format {} format
evals/evals-freenode-#perl.lst[8175]: use warnings sub get_var { warn "GET VAR\n"; return \my $var }   ${ get_var } += 1
evals/evals-freenode-#perl.lst[8176]: use warnings; sub get_var { warn "GET VAR\n"; return \my $var }   ${ get_var } += 1
evals/evals-freenode-#perl.lst[8177]: use warnings; sub index { ... } index "asdf", "d"
evals/evals-freenode-#perl.lst[8178]: use warnings; sub index :index { ... } index "asdf", "d"
evals/evals-freenode-#perl.lst[8179]: use warnings; sub index :method { ... } index "asdf", "d"
evals/evals-freenode-#perl.lst[8180]: use warnings; sub index :method { ... } main::index
evals/evals-freenode-#perl.lst[8181]: use warnings; sub index :method { scalar @_ } main::index qw( A B C D E )
evals/evals-freenode-#perl.lst[8182]: use warnings;  sub M::TIEARRAY { bless {}, shift } sub M::FETCH { print "Element $_[1]" }  tie my @arr, "M";   $arr["onetwothree"]
evals/evals-freenode-#perl.lst[8183]: use warnings; sub mynumbs (@$;$);
evals/evals-freenode-#perl.lst[8184]: use warnings; sub push :method { ... }  my @array; push @array, "value";
evals/evals-freenode-#perl.lst[8185]: use warnings; sub push { ... }  my @array; push @array, "value";
evals/evals-freenode-#perl.lst[8186]: use warnings; sub strftime {} use POSIX qw(strftime);
evals/evals-freenode-#perl.lst[8187]: use warnings; sub test { $_[0] < 0 and return } test('a')
evals/evals-freenode-#perl.lst[8188]: use warnings; "@things"
evals/evals-freenode-#perl.lst[8189]: use warnings; !!undef
evals/evals-freenode-#perl.lst[8190]: use warnings; [ undef == 0 ]
evals/evals-freenode-#perl.lst[8191]: use warnings; undef @foo;
evals/evals-freenode-#perl.lst[8192]: use warnings; $undefined =~ s//bar/;
evals/evals-freenode-#perl.lst[8193]: use warnings; undef =~ s//foo/r;
evals/evals-freenode-#perl.lst[8194]: use warnings; [undef, ''.undef]
evals/evals-freenode-#perl.lst[8195]: use warnings; use constant cat => 15; cat while $x++<1
evals/evals-freenode-#perl.lst[8196]: use warnings; use constant cat => 1; cat while $x++<1
evals/evals-freenode-#perl.lst[8197]: use warnings; use constant cat => 1; cat() while $x++<1
evals/evals-freenode-#perl.lst[8198]: use warnings; use Encode; my $buf = encode('UTF-8', "\x{666}"); open my $fh, '<', \$buf or die "open: $!"; printf "%vx", <$fh>;
evals/evals-freenode-#perl.lst[8199]: use warnings; use Encode; my $buf = encode('UTF-8', "\x{666}"); open my $fh, '<:encoding(UTF-8)', \$buf or die "open: $!" #fine, Grinnz_
evals/evals-freenode-#perl.lst[8200]: use warnings; use Encode; my $x = qq<\x{100}>; [ unpack q{H*}, Encode::encode_utf8 $x ]
evals/evals-freenode-#perl.lst[8201]: use warnings; use Encode; my $x = qq<\x{100}>; [ unpack q{H*}, $x ]
evals/evals-freenode-#perl.lst[8202]: use warnings; use experimental 'smartmatch'; "foo" ~~ "Bar"
evals/evals-freenode-#perl.lst[8203]: use warnings; use Function::Parameters qw(:strict); fun mynumbs :(@$;$) {}
evals/evals-freenode-#perl.lst[8204]: use warnings; use List::Uil 'max'; my ($x, $y, $var) = (42, 37, 0); $var += max $x, $y; $var
evals/evals-freenode-#perl.lst[8205]: use warnings; use List::Util 'max'; my ($x, $y, $var) = (42, 37, 0); $var += max $x, $y; $var
evals/evals-freenode-#perl.lst[8206]: use warnings; use Moose; has foo => (isa => 'rw); $x = $main->new; $x->foo(undef)
evals/evals-freenode-#perl.lst[8207]: use warnings; use POSIX qw(strftime); use POSIX qw(strftime);
evals/evals-freenode-#perl.lst[8208]: use warnings; use strict; "foo bar" =~ /(?<A>\w+)/ or die; print "outer1: @{[%+]}; "; { "baz" =~ /(?<B>failed match)/ or die; print "inner: @{[%+]}; "; } print "outer2: @{[%+]}; ";
evals/evals-freenode-#perl.lst[8209]: use warnings; use strict; "foo bar" =~ /(?<A>\w+)/ or die; print "outer1: @{[%+]}; "; { "baz" =~ /(?<B>failed match)/; print "inner: @{[%+]}; "; } print "outer2: @{[%+]}; ";
evals/evals-freenode-#perl.lst[8210]: use warnings; use strict; "foo bar" =~ /(?<A>\w+)/ or die; print "outer1: @{[%+]}; "; { "baz" =~ /(?<B>\w+)/ or die; print "inner: @{[%+]}; "; } print "outer2: @{[%+]}; ";
evals/evals-freenode-#perl.lst[8211]: use warnings; use strict; "foo bar" =~ /(?<A>\w+)/ or die; print "outer1: ${\\%+} @{[%+]}; "; { "baz" =~ /(?<B>\w+)/ or die; print "inner: ${\\%+} @{[%+]}; "; } print "outer2: ${\\%+} @{[%+]}; ";
evals/evals-freenode-#perl.lst[8212]: use warnings; use strict; my @arr; $arr[-1] = 'foo';
evals/evals-freenode-#perl.lst[8213]: use warnings; use strict; my $bar; if (my $foo = $bar) { 1 }
evals/evals-freenode-#perl.lst[8214]: use warnings; use strict; my $fh; print $fh 42
evals/evals-freenode-#perl.lst[8215]: use warnings; use strict; my (our $x) = 42; [$x, $::x]
evals/evals-freenode-#perl.lst[8216]: use warnings; use strict; my $str = 'afgasfasdf{afsfasdfsdafasf}asdfasfasdf'; my ($blah) = $str =~ m#^.*?{(.*?)}#; $blah
evals/evals-freenode-#perl.lst[8217]: use warnings; use strict; my $str = 'afgasfasdf{afsfasdfsdafasfasdfasfasdf'; my ($blah) = $str =~ m#^.*?{(.*)#; $blah
evals/evals-freenode-#perl.lst[8218]: use warnings; use strict; my $x = UNIVERSAL->can('can'); ''->$x('can')
evals/evals-freenode-#perl.lst[8219]: use warnings; use strict; my %x; $x{1}++;
evals/evals-freenode-#perl.lst[8220]: use warnings; use strict; my $x; $x++; $x
evals/evals-freenode-#perl.lst[8221]: use warnings; use strict; our (my $x) = 42; [$x, $::x]
evals/evals-freenode-#perl.lst[8222]: use warnings; use strict; package Don; sub t { 'cats' } package main; Don't;
evals/evals-freenode-#perl.lst[8223]: use warnings; use strict; { package Foo; sub TIESCALAR { '/foo/bar' } } tie my $var, Foo::
evals/evals-freenode-#perl.lst[8224]: use warnings; use strict; { package Foo; sub TIESCALAR { '/foo/bar' } } tie my $var, Foo::; "$var"
evals/evals-freenode-#perl.lst[8225]: use warnings; use strict; sub foo{{}} %{foo}
evals/evals-freenode-#perl.lst[8226]: use warnings; use strict; sub foo { my $x; BEGIN { $x = 42; } $x++ } [ foo, foo ]
evals/evals-freenode-#perl.lst[8227]: use warnings; use strict; sub test($hr) { print Dumper(%$hr); }
evals/evals-freenode-#perl.lst[8228]: use warnings; use strict; { test => sub { print shift }, color => 'blue' }->{color}->("bar")
evals/evals-freenode-#perl.lst[8229]: use warnings; use strict; { test => sub { print shift } }->{test}->("bar")
evals/evals-freenode-#perl.lst[8230]: use warnings; use strict; use experimental 'postderef'; my $x; my @z = @{ $x || [] }; $x->@*
evals/evals-freenode-#perl.lst[8231]: use warnings; $^V < 5.013006 ? "y" : "n"
evals/evals-freenode-#perl.lst[8232]: use warnings; $^V < 5.13.6 ? "y" : "n"
evals/evals-freenode-#perl.lst[8233]: use warnings; $^V < 5.136 ? "y" : "n"
evals/evals-freenode-#perl.lst[8234]: use warnings; v6.0.1 < 4
evals/evals-freenode-#perl.lst[8235]: use warnings; ${^WIBBLE}{wat} = 42; [ keys %{^wibble} ]
evals/evals-freenode-#perl.lst[8236]: use warnings; ${^WIBBLE}{wat} = 42; [ keys %{^WIBBLE} ]
evals/evals-freenode-#perl.lst[8237]: use warnings; $worldlen > 20
evals/evals-freenode-#perl.lst[8238]: use warnings; "$x"
evals/evals-freenode-#perl.lst[8239]: use warnings; $x
evals/evals-freenode-#perl.lst[8240]: use warnings; $x=0;121321 while $x++<1
evals/evals-freenode-#perl.lst[8241]: use warnings; $x = !0 + 1; $y = !0 . ''
evals/evals-freenode-#perl.lst[8242]: use warnings; $x = [ 0 ]; $x->[0][2]
evals/evals-freenode-#perl.lst[8243]: use warnings; $_="\x19"; $_="$_\x00"; print unpack "B*", $_&"\x80\x00"
evals/evals-freenode-#perl.lst[8244]: use warnings; $x = 1 and 1
evals/evals-freenode-#perl.lst[8245]: use warnings; $x = 1; @bucket_store_content{ $x }
evals/evals-freenode-#perl.lst[8246]: use warnings; $x = "32 string"; $y = 43; $x + $y
evals/evals-freenode-#perl.lst[8247]: use warnings; $x[3] = 9; [exists $x[0], exists $x[4]];
evals/evals-freenode-#perl.lst[8248]: use warnings; $x=[4,5,6]; @$x[0]
evals/evals-freenode-#perl.lst[8249]: use warnings; $x = "4"; $y = "3"; $l = $x . $y; $s = $x + $y; print $l print $s
evals/evals-freenode-#perl.lst[8250]: use warnings; $x .= "hallo";
evals/evals-freenode-#perl.lst[8251]: use warnings; $xml->{sessions}{session}{'status'}
evals/evals-freenode-#perl.lst[8252]: use warnings; @x = qw(a b); splice @x, 2, 0, 'c'; \ @x
evals/evals-freenode-#perl.lst[8253]: use warnings; $x = @x[0]
evals/evals-freenode-#perl.lst[8254]: use warnings; $x x101
evals/evals-freenode-#perl.lst[8255]: use warnings; $x == $y
evals/evals-freenode-#perl.lst[8256]: use warnings 'y2k'; "19" . (localtime)[5];
evals/evals-freenode-#perl.lst[8257]: use warnings; @y = (42); $x = delete $y[0]; [ $x, \@y ]
evals/evals-freenode-#perl.lst[8258]: use x $^W++;join(($x)x101)
evals/evals-freenode-#perl.lst[8259]: "U+" . sprintf "%*v04X", " U+", "hello"
evals/evals-freenode-#perl.lst[8260]: #!/usr/bin/perl -w                                      # camel code
evals/evals-freenode-#perl.lst[8261]: [ '/usr/local/bin/openerp-server' =~ m{([^/]+)$} ]
evals/evals-freenode-#perl.lst[8262]: utf8::downgrade(my $o = "\x{f4}"); $o
evals/evals-freenode-#perl.lst[8263]: utf8::downgrade(my $o = "\x{f4}"); use Data::Dumper; Dumper($o)
evals/evals-freenode-#perl.lst[8264]: utf8::encode(chr(2<<15))
evals/evals-freenode-#perl.lst[8265]: utf8::encode(my $s = chr(2<<15)); $s
evals/evals-freenode-#perl.lst[8266]: utf8::is_utf8 chr 255
evals/evals-freenode-#perl.lst[8267]: utf8::is_utf8 chr 321
evals/evals-freenode-#perl.lst[8268]: utf8::upgrade(my $o = "\x{f4}"); $o
evals/evals-freenode-#perl.lst[8269]: utf8::upgrade(my $o = "\x{f4}"); use Data::Dumper; Dumper($o)
evals/evals-freenode-#perl.lst[8270]: 'ü' =~ /\w/
evals/evals-freenode-#perl.lst[8271]: 'ü' =~ /\w/a
evals/evals-freenode-#perl.lst[8272]: "ü" xor "ü"
evals/evals-freenode-#perl.lst[8273]: ["ü" xor "ü"]
evals/evals-freenode-#perl.lst[8274]: "$^V"
evals/evals-freenode-#perl.lst[8275]: [ $^V ]
evals/evals-freenode-#perl.lst[8276]: [ %{ $^V } ]
evals/evals-freenode-#perl.lst[8277]: [ %$^V ]
evals/evals-freenode-#perl.lst[8278]: [$^V]
evals/evals-freenode-#perl.lst[8279]: $V
evals/evals-freenode-#perl.lst[8280]: $^V
evals/evals-freenode-#perl.lst[8281]: [$^V, ~0]
evals/evals-freenode-#perl.lst[8282]: $v = 0x100202020; $v =( ($v << 1) & 0xFFFFFFFF) | (($v >> 31) & 0x1); sprintf "%08X", $v
evals/evals-freenode-#perl.lst[8283]: $v = 0x100202020; $v =( ($v << 4) & 0xF) | (($v >> (32-4)) & 0x7); sprintf "%08X", $v
evals/evals-freenode-#perl.lst[8284]: $v = 0x10202020; $v =( ($v << 1) & 0xFFFFFFFF) | (($v >> 31) & 0x1); sprintf "%08X", $v
evals/evals-freenode-#perl.lst[8285]: $v = 0x10202020; $v =( ($v << 4) & 0xFFFFFFFF) | (($v >> (32-4)) & 0x7); sprintf "%08X", $v
evals/evals-freenode-#perl.lst[8286]: v112.97.110
evals/evals-freenode-#perl.lst[8287]: v116.104.120.32.112.105.110.107.95.109.105.115.116
evals/evals-freenode-#perl.lst[8288]: [v1.2.3]
evals/evals-freenode-#perl.lst[8289]: v1.2.3
evals/evals-freenode-#perl.lst[8290]: v="123 abc"; echo "${v//[^0-9]/}";
evals/evals-freenode-#perl.lst[8291]: [ v127.0.0.1 ]
evals/evals-freenode-#perl.lst[8292]: v137.80.78.71.13.10.26.10
evals/evals-freenode-#perl.lst[8293]: $^V^2
evals/evals-freenode-#perl.lst[8294]: v5.14.0
evals/evals-freenode-#perl.lst[8295]: v5.22.0
evals/evals-freenode-#perl.lst[8296]: v84.114.97.99.107.105.110.103.45.78.117.109.46.46.46.32
evals/evals-freenode-#perl.lst[8297]: vA.10 <=> vB.9
evals/evals-freenode-#perl.lst[8298]: vA.10 < vB.9
evals/evals-freenode-#perl.lst[8299]: $val = 'a'; [map $val++, 1 .. 3]
evals/evals-freenode-#perl.lst[8300]: $_ = '"Validation25",,,,,1,1,1,1,,'; s/,(?=,)/,\\N/g; $_
evals/evals-freenode-#perl.lst[8301]: @values = (1, 0, 1, 1); $n = 0; $idx = $#values; $n += $_ * (2 ** ($#values - $idx)), --$idx foreach reverse @values; $n;
evals/evals-freenode-#perl.lst[8302]: @values = (1, 0, 1, 1);  $n = 0; ($n *= 2) += $_ for reverse @values; $n;
evals/evals-freenode-#perl.lst[8303]: $var = 0; $var = ! $var;
evals/evals-freenode-#perl.lst[8304]: $var1 = ''; $var2 = 0; $var3 = undef; [ defined $var1, defined $var2, defined $var3 ]
evals/evals-freenode-#perl.lst[8305]: $variable = sprintf "%04o\n",0777;
evals/evals-freenode-#perl.lst[8306]: $varname="raddtiz"; print "$varname lol"
evals/evals-freenode-#perl.lst[8307]: $var = 'original '; print $var; { local $var = 'replacement '; print $var }; print $var;
evals/evals-freenode-#perl.lst[8308]: $var =[]; ref \$var
evals/evals-freenode-#perl.lst[8309]: $var = []; [ref $var, ref \$var]
evals/evals-freenode-#perl.lst[8310]: $var = *STDOUT; ref \$var
evals/evals-freenode-#perl.lst[8311]: $var = *STDOUT; [ref $var, ref \$var]
evals/evals-freenode-#perl.lst[8312]: $var = \*STDOUT; [ref $var, ref \$var]
evals/evals-freenode-#perl.lst[8313]: *var = \substr $_, 0, 1; ref \$var
evals/evals-freenode-#perl.lst[8314]: vec($_,7,1)=1; [unpack "s>", $_]
evals/evals-freenode-#perl.lst[8315]: vec($_,8,1)=1; [unpack "s>", $_]
evals/evals-freenode-#perl.lst[8316]: vec($_,9,1)=1; print $_
evals/evals-freenode-#perl.lst[8317]: vec($_,9,1)=1; print ord $_
evals/evals-freenode-#perl.lst[8318]: vec( my $x, 4, 4 ) = 1; printf '%*08b', ' ', $x;
evals/evals-freenode-#perl.lst[8319]: vec( my $x, 4, 4 ) = 1; printf '%*v08b', ' ', $x;
evals/evals-freenode-#perl.lst[8320]: vec( my $x, 4, 4 ) = 8; printf '%*v08b', ' ', $x;
evals/evals-freenode-#perl.lst[8321]: vec($str, $_, 8) = rand 256 for 0 .. 5; [split //, $str]
evals/evals-freenode-#perl.lst[8322]: [ 'version'->can('(""') ]
evals/evals-freenode-#perl.lst[8323]: version->new("0.01_002")->numify
evals/evals-freenode-#perl.lst[8324]: [version->parse('1.000001')->normal, version->parse('v1.0.1')->normal]
evals/evals-freenode-#perl.lst[8325]: [ version->parse("1.023-TRIAL") ]
evals/evals-freenode-#perl.lst[8326]: version->parse('2.08-TRIAL') # not that well, although CPAN itself knows enough to treat it as a dev release
evals/evals-freenode-#perl.lst[8327]: version->parse($])->normal # same as $^V
evals/evals-freenode-#perl.lst[8328]: [version->parse('v0.01'), version->parse('v0.1'), version->parse('v0.10'), version->parse('0.10')]
evals/evals-freenode-#perl.lst[8329]: version->parse('vA.10.0')->normal
evals/evals-freenode-#perl.lst[8330]: version->parse('vA.10')->normal
evals/evals-freenode-#perl.lst[8331]: version::qv('5.22.0')
evals/evals-freenode-#perl.lst[8332]: [$^V, $^O]
evals/evals-freenode-#perl.lst[8333]: '<' =~ /[[:vowel:]]/
evals/evals-freenode-#perl.lst[8334]: $v = unpack('C', pack('B8', '11111111')); $v
evals/evals-freenode-#perl.lst[8335]: $w = 3; $h = 4; @out = ( (0) x $w ) x $h; \@out
evals/evals-freenode-#perl.lst[8336]: $w = 3; $h = 4; @out = ([ (0) x $w ]) x $h; \@out
evals/evals-freenode-#perl.lst[8337]: $w = 3; $h = 4; @out = (\( (0) x $w )) x $h; \@out
evals/evals-freenode-#perl.lst[8338]: $w = 3; $h = 4; @out = map [ (0) x $w ] 1..$h; \@out
evals/evals-freenode-#perl.lst[8339]: $w = 3; $h = 4; @out = map [ (0) x $w ], 1..$h; \@out
evals/evals-freenode-#perl.lst[8340]: wantarray
evals/evals-freenode-#perl.lst[8341]: wantarray ? "list context" : defined wantarray ? "scalar context" : "void context" # there, made it more clearer
evals/evals-freenode-#perl.lst[8342]: "${\( wantarray() ? 'list' : 'scalar' )}->()}"
evals/evals-freenode-#perl.lst[8343]: "${\( wantarray() ? 'list' : 'scalar' )}"
evals/evals-freenode-#perl.lst[8344]: wantarray() ? 'list' : 'scalar'
evals/evals-freenode-#perl.lst[8345]: wantarray ? "yes" : defined wantarray ? "no" : "maybe"
evals/evals-freenode-#perl.lst[8346]: warn
evals/evals-freenode-#perl.lst[8347]: warn "hello"
evals/evals-freenode-#perl.lst[8348]: warn "hello\n"
evals/evals-freenode-#perl.lst[8349]: warn "test " . join(", ", @INC) . "\n";
evals/evals-freenode-#perl.lst[8350]: warn undef
evals/evals-freenode-#perl.lst[8351]: $^W++;eval "0".".undef"x101
evals/evals-freenode-#perl.lst[8352]: '/**' =~ /^\/\*\*/ # wfm
evals/evals-freenode-#perl.lst[8353]: 'wftedskaebjgdpjgidbsmnjgc' =~ tr/a-z/oh, turtleneck Phrase Jar!/;
evals/evals-freenode-#perl.lst[8354]: $_ = "wftedskaebjgdpjgidbsmnjgc"; tr/a-z/oh, turtleneck Phrase Jar!/; print;
evals/evals-freenode-#perl.lst[8355]: $_ = "wftedskaebjgdpjgidbsmnjgc";tr/a-z/oh, turtleneck Phrase Jar!/; print;
evals/evals-freenode-#perl.lst[8356]: 'wftedskaebjgdpjgidbsmnjgc' =~ tr/a-z/oh, turtleneck Phrase Jar!/r;
evals/evals-freenode-#perl.lst[8357]: @what = ([a,b],[1,2],[3,4]); [ map { s/_//r=~s/_/, /gr } glob join '', map { $"=',_'; "{_@$_}" } @what ]
evals/evals-freenode-#perl.lst[8358]: [$whatever++]
evals/evals-freenode-#perl.lst[8359]: while ( 1 ) { print "Don't break\n"; }
evals/evals-freenode-#perl.lst[8360]: while(@ARGV){@ARVG[1] = "test"; print "true"; exit()}
evals/evals-freenode-#perl.lst[8361]: while(@ARGV){print "true"; exit()}
evals/evals-freenode-#perl.lst[8362]: 'while cloud dark CLoud fluffy CLOUD ClOuD' =~ s/(cloud)/ (~($1 & ' ' x length $1) ^ ' ' x length $1) & lc 'butt' /egir
evals/evals-freenode-#perl.lst[8363]: while(my $e = glob "{foo,bar}") {print $e, "    "}
evals/evals-freenode-#perl.lst[8364]: while((my $pid = -1) > 0) { print $pid } "done"
evals/evals-freenode-#perl.lst[8365]: while ('peas and carrots' =~ /([aeiou])(.)/g) { push @bar, [ $1, $2 ] } \@bar
evals/evals-freenode-#perl.lst[8366]: while ('peas and carrots' =~ /(?<v>[aeiou])(?<n>.)/g) { push @bar, { %+ } } \@bar
evals/evals-freenode-#perl.lst[8367]:  while (($x < 10)) { ($y = $x); say($x); } continue { ($x += my $y) }
evals/evals-freenode-#perl.lst[8368]: whoami
evals/evals-freenode-#perl.lst[8369]: `whoami`
evals/evals-freenode-#perl.lst[8370]: "who knows?"
evals/evals-freenode-#perl.lst[8371]: "wibble" =~ s/wi(b+)/{"a".("g"x length $1)}re
evals/evals-freenode-#perl.lst[8372]: "wibble" =~ s{wi(b+)}{"a".("g"x length $1)}re
evals/evals-freenode-#perl.lst[8373]: $^W++;join(($x)x101)
evals/evals-freenode-#perl.lst[8374]: 'word $3' =~ /^\w+ \$\d$/
evals/evals-freenode-#perl.lst[8375]: 'word $3' =~ /^\w+\s\$\d$/
evals/evals-freenode-#perl.lst[8376]: $word = 'hangman'; $sofar = $word =~ s/./_/gr; for $guess (qw(n m z a g h)){ $sofar ^= $word =~ s/[^$guess]/\0/gr =~ s/$guess/$guess ^ '_'/ger; print "$sofar  " }
evals/evals-freenode-#perl.lst[8377]: ['"words in quotes"' =~ /\b(\w+)\b/g ]
evals/evals-freenode-#perl.lst[8378]: ["worker1worker2" =~ /^(worker[0-9],?)+$/]
evals/evals-freenode-#perl.lst[8379]: ["worker1worker2" =~ /(worker[0-9],?)+/]
evals/evals-freenode-#perl.lst[8380]: ["worker1worker2" =~ /^(worker[0-9],?)\1*$/]
evals/evals-freenode-#perl.lst[8381]: ["worker1worker2" =~ /(worker[0-9],?)\1*/]
evals/evals-freenode-#perl.lst[8382]: $_ = ' worker.loadbalancer.balance_workers=  worker_1,worker_2,worker_3,worker_4,worker_5'; my (@out, @tmp); m{ \A \s* \Qworker.loadbalancer.balance_workers=\E \s* (worker_[0-9]) (?{ push @tmp, $1 }) (?: , (worker_[0-9]) (?{ push @tmp, $2 }) )* \z (?{ @out = @tmp }) }x; [ @out ]
evals/evals-freenode-#perl.lst[8383]: ... works too
evals/evals-freenode-#perl.lst[8384]: $worldlen > 20
evals/evals-freenode-#perl.lst[8385]: write($sock, $request, length($request));
evals/evals-freenode-#perl.lst[8386]: %wrong = +{}; \%wrong
evals/evals-freenode-#perl.lst[8387]: [$^W, $^S, $^F]
evals/evals-freenode-#perl.lst[8388]: $w="specific"; $len=length $w; for my $i (0..$len-1) { for my $j (1..$len-$i) { push @parts,substr $w,$i,$j}} \@parts
evals/evals-freenode-#perl.lst[8389]: $^W + $^T + $^F
evals/evals-freenode-#perl.lst[8390]: $::{wtf} = \*hi; wft();
evals/evals-freenode-#perl.lst[8391]: $::{wtf} = \"hi"; wtf()
evals/evals-freenode-#perl.lst[8392]: "$x"
evals/evals-freenode-#perl.lst[8393]: "\x<"
evals/evals-freenode-#perl.lst[8394]: "\x"
evals/evals-freenode-#perl.lst[8395]: [x=>~~[]]
evals/evals-freenode-#perl.lst[8396]: $x
evals/evals-freenode-#perl.lst[8397]: $x->()
evals/evals-freenode-#perl.lst[8398]: \$x
evals/evals-freenode-#perl.lst[8399]: ++$x
evals/evals-freenode-#perl.lst[8400]: $^X
evals/evals-freenode-#perl.lst[8401]: $^X = "<_<";
evals/evals-freenode-#perl.lst[8402]: $x**0
evals/evals-freenode-#perl.lst[8403]: /x{00}/
evals/evals-freenode-#perl.lst[8404]: /x{01}/
evals/evals-freenode-#perl.lst[8405]: $x = '0.101010101110011'; hex("0b$x")/2**(length($x) - 2)
evals/evals-freenode-#perl.lst[8406]: "\x{0265}\x{01DD}\x{028E}"
evals/evals-freenode-#perl.lst[8407]: $x = '042'; [ $x, "$x" ]
evals/evals-freenode-#perl.lst[8408]: @x = (0 .. 5); [\@x, $#x, scalar @x]
evals/evals-freenode-#perl.lst[8409]: ${"\x{06}"} = 1; ++${"\x{06}"};
evals/evals-freenode-#perl.lst[8410]: @x = (0 .. 9); pop @x;
evals/evals-freenode-#perl.lst[8411]: @x = (0 .. 9); shift @x;
evals/evals-freenode-#perl.lst[8412]: ["\x0a"]
evals/evals-freenode-#perl.lst[8413]: $x = 0b00001000; $x >>= 1; sprintf '%08b', $x
evals/evals-freenode-#perl.lst[8414]: $x = 0; for (1..1000) {$x += 0.01;}; for (1..1000) {$x -= 0.01}; $x
evals/evals-freenode-#perl.lst[8415]: $x = 0; for (1 .. 1000) { $x += 0.01; } $x
evals/evals-freenode-#perl.lst[8416]: $x = 0; [ map {; $x += 1/(2**$_); $x } 1..64 ]
evals/evals-freenode-#perl.lst[8417]: $x = 0; [ map {; $x += 1/(2**$_); $x } 1..8 ]
evals/evals-freenode-#perl.lst[8418]: $x = 0; [ map {; $x += 1/(2**$_); $x =~ /\.(9*)/ ? length($1) : -1 } 1..64 ]
evals/evals-freenode-#perl.lst[8419]: $x = [ 0 ]; $x->[0][2]
evals/evals-freenode-#perl.lst[8420]: 'x' =~ /./; [$1]
evals/evals-freenode-#perl.lst[8421]: [ %x{1} ]
evals/evals-freenode-#perl.lst[8422]: [x=>~~-1]
evals/evals-freenode-#perl.lst[8423]: $x[-1]
evals/evals-freenode-#perl.lst[8424]: /x{10}/
evals/evals-freenode-#perl.lst[8425]: "x"=~/\{10}/;
evals/evals-freenode-#perl.lst[8426]: "\x{100}"
evals/evals-freenode-#perl.lst[8427]: $x = '10.12'; $x =~ s/\..+$//; $x
evals/evals-freenode-#perl.lst[8428]: "\x{10c}\x{e1}ste\x{10d}n\x{11b} schv\x{e1}leno"
evals/evals-freenode-#perl.lst[8429]: $x[10e10]++
evals/evals-freenode-#perl.lst[8430]: [ ('?') x 10 ] # magic ()
evals/evals-freenode-#perl.lst[8431]: [ ('?' x 10) ] # the () do nothing
evals/evals-freenode-#perl.lst[8432]: $x = 10; while ( $x --> 0 ) { push @arr, $x } \@arr
evals/evals-freenode-#perl.lst[8433]: x = 10 || (x > 20 && x < 30)
evals/evals-freenode-#perl.lst[8434]: $x = 10; $y = 9; [ [$x, $y], $x <= $y, [$x, $y]->[""] ]
evals/evals-freenode-#perl.lst[8435]: $x = 10; $y = 9; [ [$x, $y], $x <= $y, [$x, $y]->[$x <= $y] ]
evals/evals-freenode-#perl.lst[8436]: @x=(11,12,13); grep { s/1/9/ } @x; \@x
evals/evals-freenode-#perl.lst[8437]: $x = '11223344'; join( '+', map {  join('-', map { $_  } split //) } $x =~/../g);
evals/evals-freenode-#perl.lst[8438]: $x='${\1+1}'; eval qq{ "\Q$x\E" }
evals/evals-freenode-#perl.lst[8439]: @x = (12, 13); sprintf '%d %d', @x
evals/evals-freenode-#perl.lst[8440]: @x = (1, 2, 1); delete @x[@x]; \@x
evals/evals-freenode-#perl.lst[8441]: @x = (1, 2, 3,4 ,5 , 6, 7, 8); foreach my $x (@x[0..2]) { print $x; }
evals/evals-freenode-#perl.lst[8442]: @x = (1, 2, 3,4 ,5 , 6, 7, 8); @x[0..2];
evals/evals-freenode-#perl.lst[8443]: @x=([[1,2],[3,4]],[5]); $x[1][0]
evals/evals-freenode-#perl.lst[8444]: @x=([[1,2],[3,4]],[5]); $x[1][1]
evals/evals-freenode-#perl.lst[8445]: @x=([[1,2],[3,4]],[5]); $x[1][2]
evals/evals-freenode-#perl.lst[8446]: @x=(1,2,3,4,5); [$x[-20], \@x]
evals/evals-freenode-#perl.lst[8447]: @x=(1,2,3,4); scalar @x
evals/evals-freenode-#perl.lst[8448]: $x = (1, (2, 3), 5);
evals/evals-freenode-#perl.lst[8449]: $x = [1,2,3]; Data::Dumper::Dumper([$x, $x])
evals/evals-freenode-#perl.lst[8450]: @x=(1,2,3); delete @x[0,2]; \@x
evals/evals-freenode-#perl.lst[8451]: @x=(1,2,3); delete $x[1];
evals/evals-freenode-#perl.lst[8452]: @x=(1,2,3); delete @x[1,2]; \@x
evals/evals-freenode-#perl.lst[8453]: @x=(1,2,3); delete @x[1]; \@x
evals/evals-freenode-#perl.lst[8454]: @x=(1,2,3); delete $x[1]; \@x
evals/evals-freenode-#perl.lst[8455]: $x = '1.23'; $x =~ s/\D+//g; $x
evals/evals-freenode-#perl.lst[8456]: $x = () = (1,2,4); print($x)
evals/evals-freenode-#perl.lst[8457]: $x = 12; { ++local($x) } $x
evals/evals-freenode-#perl.lst[8458]: [{x => 12}, {x => 13}, {x => 14}]
evals/evals-freenode-#perl.lst[8459]: $x = "1   2"; @y = split(' ', $x); print "$x[0], $[x1]";
evals/evals-freenode-#perl.lst[8460]: $x = "1   2"; @y = split(' ', $x); print "$y[0], $y[1]";
evals/evals-freenode-#perl.lst[8461]: @x = (1..547); say length @x
evals/evals-freenode-#perl.lst[8462]: @x = (1..547); say scalar @x
evals/evals-freenode-#perl.lst[8463]: @x = 1 .. 6; scalar @x
evals/evals-freenode-#perl.lst[8464]: @x = (1 .. 8); print @x[0..2];
evals/evals-freenode-#perl.lst[8465]: $_="\x19"; $_="$_\x00"; print unpack "B*", $_&"\x80\x00"
evals/evals-freenode-#perl.lst[8466]: $_="\x19"; $_="$_\x00"; print "yes" if $_&"\x80\x00"
evals/evals-freenode-#perl.lst[8467]: "\x{1f441}\x{200d}\x{1f5e8}"
evals/evals-freenode-#perl.lst[8468]: "\x{1F478}\x{200D}\x{2764}\x{FE0F}\x{200D}\x{1F48B}\x{200D}\x{1F438}"
evals/evals-freenode-#perl.lst[8469]: "\x{1F64C}"
evals/evals-freenode-#perl.lst[8470]: $x = 1; sub { @_[0] = 2; }->($x); print $x
evals/evals-freenode-#perl.lst[8471]: $x =1; $x *= (2**2**$_ + 1) for 1 .. 4; $x
evals/evals-freenode-#perl.lst[8472]: $x=1; $x *= $_ for 2..10; $x
evals/evals-freenode-#perl.lst[8473]: $x=1; $x = \$x; $$x=2; $x
evals/evals-freenode-#perl.lst[8474]: {} x 2
evals/evals-freenode-#perl.lst[8475]: $x = "2015-0223"; substr($x,7,0) = "-"; $x
evals/evals-freenode-#perl.lst[8476]: $x = 20; [ ++$x, $x++, $x ] # wheeee
evals/evals-freenode-#perl.lst[8477]: @x = (2, 1, 2); delete @x[@dup = @x]; \ @x # this one is right
evals/evals-freenode-#perl.lst[8478]: @x = (2, 1, 2); delete @x[@x]; \ @x # right
evals/evals-freenode-#perl.lst[8479]: @x = (2, 1, 2); delete @x[@x]; \ @x # wrong!
evals/evals-freenode-#perl.lst[8480]: '\x21\x21' =~ s/(.)/qq("$1")/eer
evals/evals-freenode-#perl.lst[8481]: '\x21\x21' =~ s/(.*)/qq("$1")/eer
evals/evals-freenode-#perl.lst[8482]: '\x22\x22' =~ s/(.*)/qq("$1")/eer
evals/evals-freenode-#perl.lst[8483]: "\x{22}\x{31}"
evals/evals-freenode-#perl.lst[8484]: @{ $x->[2] } = (4, 5); $x
evals/evals-freenode-#perl.lst[8485]: ["\x27"]
evals/evals-freenode-#perl.lst[8486]: ($x = 2903000)/($y = 2903000)*100
evals/evals-freenode-#perl.lst[8487]: $x='\"2+@'; eval qq{ "\Q$x\E" }
evals/evals-freenode-#perl.lst[8488]: '\x2F\x76\x69' =~ s/\\x([[:xdigit:]]{1,2})/chr hex $1/ger
evals/evals-freenode-#perl.lst[8489]: $x[3] = 123; [keys @x]
evals/evals-freenode-#perl.lst[8490]: @x = 31 .. 33; scalar @x
evals/evals-freenode-#perl.lst[8491]: $x = "32 string"; $y = 43; $x + $y
evals/evals-freenode-#perl.lst[8492]: @x = (3, 4); print scalar @x
evals/evals-freenode-#perl.lst[8493]: @x = (3, 4); print scalar @x[0,1];
evals/evals-freenode-#perl.lst[8494]: $x = 3; $cond = '$x == 3'; print "$cond is true" if (eval $cond) # still, though -- ugh
evals/evals-freenode-#perl.lst[8495]: ('?') x 4
evals/evals-freenode-#perl.lst[8496]: [ ('?') x 4 ]
evals/evals-freenode-#perl.lst[8497]: [ ('?'x4) ]
evals/evals-freenode-#perl.lst[8498]: '\x40\x40' =~ s/(.*)/qq("$1")/eer
evals/evals-freenode-#perl.lst[8499]: '\x41\x41'
evals/evals-freenode-#perl.lst[8500]: '\x41\x41' =~ s/(.*)/qq("$1")/eer  # /me ducks
evals/evals-freenode-#perl.lst[8501]: '\x41\x41' =~ s/\\x([0-9a-fA-F]{2})/pack 'H*', $1/rge;
evals/evals-freenode-#perl.lst[8502]: '\x41\x41' =~ s/\\x(\d\d)/chr hex $1/rge;
evals/evals-freenode-#perl.lst[8503]: '\x41\x41' =~ s/\\x(\d\d)/hex $1/ge;
evals/evals-freenode-#perl.lst[8504]: '\x41\x41' =~ s/\\x(\d\d)/pack 'H*', $1/rge;
evals/evals-freenode-#perl.lst[8505]: '\x41\x41' =~ s/\\x(\d\d)/pack 'HH', $1/rge;
evals/evals-freenode-#perl.lst[8506]: '\x41\x41' =~ s/(\\x..)/'qq('.$1.')'/rgee;
evals/evals-freenode-#perl.lst[8507]: '\x41\x41' =~ s/(\\x..)/qq($1)/rgee;
evals/evals-freenode-#perl.lst[8508]: '\x41\x41' =~ s/(\\x..)/qq(qq($1))/rgee;
evals/evals-freenode-#perl.lst[8509]: '\x41\x41' =~ s((\\x..))(qq(qq($1)))rgee; # lisp-y?
evals/evals-freenode-#perl.lst[8510]: $x = 42; $first3 = ($x & 56) >> 3; $last3 = $x & 7; [ $first3, $last3 ]
evals/evals-freenode-#perl.lst[8511]: $x = 42; sub foo { $x += 23 } { local $x; foo() } $x
evals/evals-freenode-#perl.lst[8512]: $x = 42; $x /= 2; $x
evals/evals-freenode-#perl.lst[8513]: $x = 42; "x is ${\$x}, eh"
evals/evals-freenode-#perl.lst[8514]: $x = 42; $x_ref = \$x; ${$x_ref} = 37; [ $x, $x_ref ]
evals/evals-freenode-#perl.lst[8515]: $x = 42; $x_ref = \$x; [ $x_ref, ${ $x_ref } ]
evals/evals-freenode-#perl.lst[8516]: $x=[4,5,6]; @$x[0]
evals/evals-freenode-#perl.lst[8517]: $x=[4,5,6]; $$x[0]
evals/evals-freenode-#perl.lst[8518]: $x = [4, 5, 6]; @$x[0, 1]
evals/evals-freenode-#perl.lst[8519]: $x = 4; $x //= 3;
evals/evals-freenode-#perl.lst[8520]: (' ') x 5
evals/evals-freenode-#perl.lst[8521]: [ " " x 5 ]
evals/evals-freenode-#perl.lst[8522]: [ (' ') x 5 ]
evals/evals-freenode-#perl.lst[8523]: [ (" ") x 5 ]
evals/evals-freenode-#perl.lst[8524]: ["_ " x 5]
evals/evals-freenode-#perl.lst[8525]: [(" ") x 5]
evals/evals-freenode-#perl.lst[8526]: [("_ ") x 5]
evals/evals-freenode-#perl.lst[8527]: ["#" x 50 . "\n"]
evals/evals-freenode-#perl.lst[8528]: ["#"x50."\n"]
evals/evals-freenode-#perl.lst[8529]: [("_ ") x 5] [16:44] <perlbot> Altreus: ["_ ","_ ","_ ","_ ","_ "]
evals/evals-freenode-#perl.lst[8530]: $x=5; qq'$x'
evals/evals-freenode-#perl.lst[8531]: $x = 6.7233 * 1.22345;
evals/evals-freenode-#perl.lst[8532]: $x = 6.7233 * 1.22345; [ sprintf("%f", $x), unpack("H*",$f) ]
evals/evals-freenode-#perl.lst[8533]: $x = 9; $y = 10; [ [$x, $y], $x <= $y, [$x, $y]->[1] ]
evals/evals-freenode-#perl.lst[8534]: $x={'{a}'=2}; $x->{{a}};
evals/evals-freenode-#perl.lst[8535]: %x = (a => 3, b => 4); print scalar %x
evals/evals-freenode-#perl.lst[8536]: %x = (a => 3, b => 4); print scalar @x{'a','b'}
evals/evals-freenode-#perl.lst[8537]: %x = ( 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'); my @sortedkeys = sort(keys(%x)); my $highestkey = $sortedkeys[-1]; print $highestkey;
evals/evals-freenode-#perl.lst[8538]: %x = ( 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'); my @sortedkeys = sort(values(%x)); my $highestkey = $sortedkeys[-1]; print $highestkey;
evals/evals-freenode-#perl.lst[8539]: %x = ( 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'); print sort { $a cmp $b } keys %x;
evals/evals-freenode-#perl.lst[8540]: %x = { 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'}; print sort { $a cmp $b } keys %x;
evals/evals-freenode-#perl.lst[8541]: %x = { 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'}; print $x{'c'};
evals/evals-freenode-#perl.lst[8542]: $x = "a a a a a a"; $x =~ s/a/x/3;print $x
evals/evals-freenode-#perl.lst[8543]: $x = () = 'å' =~ /[åä]/g
evals/evals-freenode-#perl.lst[8544]: $x="aa";++;print ++$x
evals/evals-freenode-#perl.lst[8545]: $x="aa";++$x;print ++$x
evals/evals-freenode-#perl.lst[8546]: $x = { 'a.b' = 'c' }
evals/evals-freenode-#perl.lst[8547]: $x = 'abcdefg'; substr($x, 2) =~ y/a-z/A-Z/; $x
evals/evals-freenode-#perl.lst[8548]: $x = "abcdfghi"; substr($x, 4, 0, 'e'); $x
evals/evals-freenode-#perl.lst[8549]: $x="abcdfghi"; $x=~s/(abcd).*(fghi)/$1e$2/g; print $x;
evals/evals-freenode-#perl.lst[8550]: $x="abcd"; push @{$x{j}}, split(//,$x); print join("", @{$x{j}}[2,3]), "\n"
evals/evals-freenode-#perl.lst[8551]: $x="abcd"; push @{$x{j}}, split(//,$x); print join("", @{$x{j}}[2..3]), "\n"
evals/evals-freenode-#perl.lst[8552]: $x->{abc} #so it might
evals/evals-freenode-#perl.lst[8553]: $x->{abc}; $x
evals/evals-freenode-#perl.lst[8554]: @x = 'a' .. 'c'; sub lala { my ($aref) = @_; "@$aref" } lala \@x
evals/evals-freenode-#perl.lst[8555]: %x=(a=>undef); exists $x{a}
evals/evals-freenode-#perl.lst[8556]: $x = { a => 'value', b => $x->{a} }; $x
evals/evals-freenode-#perl.lst[8557]: $x->{a}; $x
evals/evals-freenode-#perl.lst[8558]: $x = "banana"; \substr($x, 2)
evals/evals-freenode-#perl.lst[8559]: $x = bless [], 'ARRYY(0xDEADBEEF)'; ref $x
evals/evals-freenode-#perl.lst[8560]: $x = bless {}, "Banana"; ["$x", $x =~ /t/]
evals/evals-freenode-#perl.lst[8561]: $x = bless {}, "Banana"; [$x, $x =~ /t/]
evals/evals-freenode-#perl.lst[8562]: $x = []; bless $x, "$x"; ref $x
evals/evals-freenode-#perl.lst[8563]: $x = []; bless $x, $x; ref $x
evals/evals-freenode-#perl.lst[8564]: "\x^C"
evals/evals-freenode-#perl.lst[8565]: "\xc6"
evals/evals-freenode-#perl.lst[8566]: ["\x{cf}", "\xcf" ]
evals/evals-freenode-#perl.lst[8567]: $x = chr(0xC6); Encode::encode_utf8($x)
evals/evals-freenode-#perl.lst[8568]: $x = chr(0xC6); unpack "H*", Encode::encode_utf8($x)
evals/evals-freenode-#perl.lst[8569]: $x = chr 0xcf; $y = chr 0xcf; Encode::_utf8_on($x); Encode::_utf8_off($y); [$x, $y]
evals/evals-freenode-#perl.lst[8570]: "\xd1"
evals/evals-freenode-#perl.lst[8571]: $x="@" . "{[ die 'horribly' ]}"; eval qq{ "\Q$x\E" }
evals/evals-freenode-#perl.lst[8572]: $x="@{[ die 'horribly' ]}"; eval qq{ "\Q$x\E" }
evals/evals-freenode-#perl.lst[8573]: [ $^X, $EXECUTABLE_NAME ]
evals/evals-freenode-#perl.lst[8574]: @x=([],{},$",\&f,\0);s/..(..).*/$1/ for@x;$"="";"@x"
evals/evals-freenode-#perl.lst[8575]: $"="";@x=([],{}," ",\&f,\0);s/..(..).*/$1/ for@x;"@x"
evals/evals-freenode-#perl.lst[8576]: "\xF0\x9F\x99\x8C"
evals/evals-freenode-#perl.lst[8577]: "\x{f4}"
evals/evals-freenode-#perl.lst[8578]: "\xf6"
evals/evals-freenode-#perl.lst[8579]: "\xFE\xAB"
evals/evals-freenode-#perl.lst[8580]: "\xff"
evals/evals-freenode-#perl.lst[8581]: @x = (foo => 1, bar => 2); print ${{@x}}{"foo"}
evals/evals-freenode-#perl.lst[8582]: @x = (foo => 1, bar => 2); ${{@x}}{"foo"}
evals/evals-freenode-#perl.lst[8583]: @x = ( {foo => 1} ); $x[0]->{foo}
evals/evals-freenode-#perl.lst[8584]: @x = (foo => 3, bar => 4); ${{[a=>2, b=>3]}}{"foo"}
evals/evals-freenode-#perl.lst[8585]: @x = (foo => 3, bar => 4); ${[foo=>2, bar=>3]}{"foo"}
evals/evals-freenode-#perl.lst[8586]: @x = (foo => 3, bar => 4); ${{[foo=>2, bar=>3]}}{"foo"}
evals/evals-freenode-#perl.lst[8587]: @x = (foo => 3, bar => 4); ${{@x}}{"foo"}
evals/evals-freenode-#perl.lst[8588]: $x = \@Foo::bar; delete $Foo::{bar}; @$x = "meow";
evals/evals-freenode-#perl.lst[8589]: @x = (foo => "fooval", bar => "barval"); print +{@x}->{"foo"}
evals/evals-freenode-#perl.lst[8590]: $x = \@{"Foo::ISA"}; delete $Foo::{ISA}; @$x = "Bar"
evals/evals-freenode-#perl.lst[8591]: $x="foo\n"; [ $x, chomp $x ];
evals/evals-freenode-#perl.lst[8592]: $x="foo\n"; [ $x, chomp $x, $x ];
evals/evals-freenode-#perl.lst[8593]: $x{foo}++, $x{foo}
evals/evals-freenode-#perl.lst[8594]: $x = "foo"; [ $x, $x =~ s/foo/bar/r ]
evals/evals-freenode-#perl.lst[8595]: $x{$_}++ for qw[a b c]; \%x
evals/evals-freenode-#perl.lst[8596]: @x = grep /[^\Wt]/, qw<q w t 6 ! . X>; [@x]
evals/evals-freenode-#perl.lst[8597]: @x = 'hello'; my @y = $x[@x] = 'world'; [ \@y, \@x ]
evals/evals-freenode-#perl.lst[8598]: [ ('?'x@ids) ]
evals/evals-freenode-#perl.lst[8599]: $x = { key => 'value' }, push @{$x->{foo}}, 'bar'; push @{$x->{foo}}, 'baz'; $x
evals/evals-freenode-#perl.lst[8600]: $x = "lala"; *$x = "cat"; $lala
evals/evals-freenode-#perl.lst[8601]: $x = "lala"; *$x = \"cat"; $lala
evals/evals-freenode-#perl.lst[8602]: $x = "lala"; *$x = sub {2*3}; lala();
evals/evals-freenode-#perl.lst[8603]: $x = 'loooong'; substr($x, 4, 0) = 'XX'; # substr is an lvalue
evals/evals-freenode-#perl.lst[8604]: $x = 'loooong'; substr($x, 4, 0) = 'XX'; $x ; # substr is an lvalue
evals/evals-freenode-#perl.lst[8605]: [*::X, *main::X, *::main::X, *main::main::main::main::X]
evals/evals-freenode-#perl.lst[8606]: @x = ( map ord, split //, 64.64.64.5000000000.64.64.64 );  $x = join ",", @x;  print "$x\n"
evals/evals-freenode-#perl.lst[8607]: $x = "\n"; chomp $x; [$x]
evals/evals-freenode-#perl.lst[8608]: [ "x\n   \t \t   \n \n\n\n\n\n\n\ny" =~ /^(.*)\s*$/gm ]
evals/evals-freenode-#perl.lst[8609]: [ "x\n   \t \t   \n \n\n\n\n\n\n\ny" =~ /^\s*(.*)$/gm ] # like this?
evals/evals-freenode-#perl.lst[8610]: [ "x\n   \t \t   \n \n\n\n\n\n\n\ny" =~ /^\s*(.*)\s*$/gm ] # so perhaps you wanted \h instead of \s?
evals/evals-freenode-#perl.lst[8611]: $x = "(??{print 42})"; "banana" =~ /$x/
evals/evals-freenode-#perl.lst[8612]: $x = qr/^cats$/
evals/evals-freenode-#perl.lst[8613]: $x = qr/lala/; $xx = qr/$x/; [$x, $xx]
evals/evals-freenode-#perl.lst[8614]: $x = qr/something/; "that's something" =~ $x
evals/evals-freenode-#perl.lst[8615]: "X\\Q(s)Y" =~ qr'\Q(s)' ? [$`, $&, $'] : "no"
evals/evals-freenode-#perl.lst[8616]: "X\\QsY" =~ qr'\Q(s)' ? [$`, $&, $'] : "no"
evals/evals-freenode-#perl.lst[8617]: @x=qw(a b c); push @x, shift @x; "@x"
evals/evals-freenode-#perl.lst[8618]: @x=qw(a b c); push @x, shift @x; @x
evals/evals-freenode-#perl.lst[8619]: @x=qw(a b c); sub z{$_[0]=5;} z(@x); \@x
evals/evals-freenode-#perl.lst[8620]: @x=qw(a b c); unshift @x, pop @x; "@x"
evals/evals-freenode-#perl.lst[8621]: @x{qw{a b c}}++; \%x
evals/evals-freenode-#perl.lst[8622]: @x=qw(a b c); $x=@x;($y)=@x;[$x,$y]
evals/evals-freenode-#perl.lst[8623]: @x=qw/a b c/; $z=[@x[0,1]]; for(@$z){$_++; print} \@x
evals/evals-freenode-#perl.lst[8624]: @x=qw/a b c/; $z=[@x[0,1]]; for(@$z){$_++} \@x
evals/evals-freenode-#perl.lst[8625]: @x=qw( a b ); print push @x, 'c'
evals/evals-freenode-#perl.lst[8626]: @x{qw/foo bar baz/}=(); \%x
evals/evals-freenode-#perl.lst[8627]: @x{qw/foo bar baz/})=(); \%x
evals/evals-freenode-#perl.lst[8628]: @x = qw{' . "@INC" . '}; \ @x
evals/evals-freenode-#perl.lst[8629]: $x = ''; $ref = \$x; [ "".$ref, "". \${$$ref} ]
evals/evals-freenode-#perl.lst[8630]: $x = ''; $ref = \$x; [ "".\$ref, "". \${$$ref} ]
evals/evals-freenode-#perl.lst[8631]: $x = { site => 'lol' }; $y = "foo";  "lefoobar" =~ s/$y/$x->{site}/r
evals/evals-freenode-#perl.lst[8632]: $x = {}; sprintf "%s %x", $x, $x
evals/evals-freenode-#perl.lst[8633]: $x = sub { 3 } $x->() + 1
evals/evals-freenode-#perl.lst[8634]: $x = sub { 3 }; $x->() + 1
evals/evals-freenode-#perl.lst[8635]: $x = [ sub { 'here ' . shift } ]; $x->[0]->('we go')
evals/evals-freenode-#perl.lst[8636]: @x=([],{}," ",sub{},\"");map{s/..(..).*/$1/}@x;"@x"
evals/evals-freenode-#perl.lst[8637]: $"="";@x=([],{}," ",sub{},\"");map{s/..(..).*/$1/}@x;"@x"
evals/evals-freenode-#perl.lst[8638]: $"="";@x=([],{}," ",sub{},\"");s/..(..).*/$1/ for@x;"@x"
evals/evals-freenode-#perl.lst[8639]: $x = 'text25more text25fdsdf'; $x =~ s/text(\d+)more text(\1)fdsdf/'foo' . ($1 * $1)/e; $x
evals/evals-freenode-#perl.lst[8640]: ' ' =~ /[ ]/x ? 'T' : 'F';
evals/evals-freenode-#perl.lst[8641]: %x = (this => {0..3}, that => {'a'..'d'}); \%x;
evals/evals-freenode-#perl.lst[8642]: @x = "This" =~ s/(.)/sprintf "%b ", ord $1/gre; [@x]
evals/evals-freenode-#perl.lst[8643]: @x = "This" =~ s/(.)/sprintf "%b ", ord $1/gre; [@x] is it a command ?
evals/evals-freenode-#perl.lst[8644]: $x = 'three'; $y = \$x; $x = \$x; [ $x, $y ]
evals/evals-freenode-#perl.lst[8645]: $x = \undef; "$x"
evals/evals-freenode-#perl.lst[8646]: $x = undef; $x //= 3;
evals/evals-freenode-#perl.lst[8647]: @x[$wa = wantarray]; $wa
evals/evals-freenode-#perl.lst[8648]: [ $x++, $x ]
evals/evals-freenode-#perl.lst[8649]: $x = {} [ "$x", 0+$x ]
evals/evals-freenode-#perl.lst[8650]: $x = {}; [ "$x", 0+$x ]
evals/evals-freenode-#perl.lst[8651]: @x = $x || (12, 13, 14); \ @x
evals/evals-freenode-#perl.lst[8652]:  @x = "\x{2019}"; push @x, ($x[0] =~ s/\x{2019}/'/r); [@x]
evals/evals-freenode-#perl.lst[8653]: [ 'x' x 5 ]
evals/evals-freenode-#perl.lst[8654]: $x = "\x65\x66\x67";
evals/evals-freenode-#perl.lst[8655]: $x = "\x65\x66\x67"; eval "qq($x)" # not recommended
evals/evals-freenode-#perl.lst[8656]: @x = "xAyxByxCy" =~ /x(.)y/g; $1 # last capture, not first
evals/evals-freenode-#perl.lst[8657]: [ 'XX' =~ /((?i)x)x/ ]
evals/evals-freenode-#perl.lst[8658]: "xx: m:q" =~ /(^[a-z367]*?: |\s|^)(?:m|mixer):(\S+)/; [$1, $2]
evals/evals-freenode-#perl.lst[8659]: 'xxS01E32yy' =~ s/S01E([0-9][0-9])/"S01E" . ($1*2) . "E" . ($1*2 + 1)/er
evals/evals-freenode-#perl.lst[8660]: 'xxS01E32yy' =~ s/S01E([0-9][0-9])/"S01E" . $1*2 . "E" . $1*2 + 1/er
evals/evals-freenode-#perl.lst[8661]: [ ++$x . '', ++$x . '', ++$x . '' ]
evals/evals-freenode-#perl.lst[8662]: [ ++$x, ++$x, ++$x ]
evals/evals-freenode-#perl.lst[8663]: [$x++, $x++, $x++]
evals/evals-freenode-#perl.lst[8664]: "xxx" + 5
evals/evals-freenode-#perl.lst[8665]: "\x<\x-\xc\xt\xr\xc"
evals/evals-freenode-#perl.lst[8666]: { "XXX" =~ /(.*)/; } print $1
evals/evals-freenode-#perl.lst[8667]: $_ = "x!xx!x!x!"; my $state = 0; s/(\w)/++$state % 2 ? (uc $1) : (lc $1)/ge; $_
evals/evals-freenode-#perl.lst[8668]: "x x xx xxx xxxxx\n" =~ /^\s*(?:((?(1)(?(3)(?(2)\2|\3)(\1)|(\S))|\S))\s+)+$/ ? "\\o/" : ":-("
evals/evals-freenode-#perl.lst[8669]: "x x xx xxx xxxxx\n" =~ /^\s*(?:((?(1)(?(3)(?(2)\2|\3)(\1)|(\S))|\S))\s+)+$/ ? "\o/" : ":-("
evals/evals-freenode-#perl.lst[8670]: "x x xx xxx xxxxx xxxxxxxx\n" =~ /^\s*(?:((?(1)(?(3)(?(2)\2|\3)(\1)|(\S))|\S))\s+)+$/ ? "a fibonacci sequence" : "bzzt"
evals/evals-freenode-#perl.lst[8671]: $x = 'XYZ XYZ XYZ'; $y =()= $x =~ /XYZ/g; $y
evals/evals-freenode-#perl.lst[8672]: \$x = \$y
evals/evals-freenode-#perl.lst[8673]: 'x' =~ /(y?)/; [$1]
evals/evals-freenode-#perl.lst[8674]: 'x' =~ /(y)?/; [$1]
evals/evals-freenode-#perl.lst[8675]: [ ($x, $y) = 5 .. 10 ]
evals/evals-freenode-#perl.lst[8676]: ($x, $y) = 'abc' =~ /(..)(.)/; [$1, $2] # $1, $2 are populated even when storing the values elsewhere
evals/evals-freenode-#perl.lst[8677]: ($x, $y) = qw(a b c d)
evals/evals-freenode-#perl.lst[8678]: $x="y"; [ ++$x ]
evals/evals-freenode-#perl.lst[8679]: %x = { "y" => "z" }; $x{"hey"} += 5; print $x{"hey"};
evals/evals-freenode-#perl.lst[8680]: [ 'xyzzy' =~ /(\w)\g{1}/ ]
evals/evals-freenode-#perl.lst[8681]: 'xZx' =~ m'Z'
evals/evals-freenode-#perl.lst[8682]: 'xZx' =~ m"Z"
evals/evals-freenode-#perl.lst[8683]: $x="z"; $x++; $x
evals/evals-freenode-#perl.lst[8684]: $x = 'zzz'; $x++; $x
evals/evals-freenode-#perl.lst[8685]: @y = (1, 2, 3); \ @y
evals/evals-freenode-#perl.lst[8686]: @y = 1, 2, 3; \ @y
evals/evals-freenode-#perl.lst[8687]: $y=1; *x = (sub { \@_ })->($y); $x[0] = 2; print "$y\n";
evals/evals-freenode-#perl.lst[8688]: $_ = "yes" ; y/e/é/; $_
evals/evals-freenode-#perl.lst[8689]: $_ = "yes" ; y/e/é//; $_
evals/evals-freenode-#perl.lst[8690]: $y="one"; $z = undef; $y = $z || ''; print $z;
evals/evals-freenode-#perl.lst[8691]: $y="one"; $z = undef; $y = $z || undef; print $z;
evals/evals-freenode-#perl.lst[8692]: \"you"
evals/evals-freenode-#perl.lst[8693]: you can use sprintf
evals/evals-freenode-#perl.lst[8694]: your code
evals/evals-freenode-#perl.lst[8695]: $y; { use strict; $x }
evals/evals-freenode-#perl.lst[8696]: $z=new IO::Handle; "$z"
evals/evals-freenode-#perl.lst[8697]: [ "Zoffix doubts that map example works" =~ /(?=(..))/sg ]
evals/evals-freenode-#perl.lst[8698]: 'zoom' =~ m moom
evals/evals-freenode-#perl.lst[8699]: $z='the quick brown fox jumped over the lazy dogs in leet speak'; $z=~s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $z;
evals/evals-freenode-#perl.lst[8700]: $z='the quick brown fox jumped over the lazy dogs in leet speak'; $z = s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $z;
evals/evals-freenode-#perl.lst[8701]: $z=\$x; "$z"
evals/evals-freenode-#perl.lst[8702]: [ "ΑRRΑΥ" ]
evals/evals-freenode-#perl.lst[8703]: [ 'Ω' cmp 'Α' ]
evals/evals-freenode-#perl.lst[8704]: "Я очень плохо говорю по русский"
evals/evals-freenode-#perlbot.lst[1]: 
evals/evals-freenode-#perlbot.lst[2]: - -
evals/evals-freenode-#perlbot.lst[3]: - - ' .'
evals/evals-freenode-#perlbot.lst[4]: - - ' '
evals/evals-freenode-#perlbot.lst[5]: - - '-'
evals/evals-freenode-#perlbot.lst[6]: - - '.'
evals/evals-freenode-#perlbot.lst[7]: - - '"'
evals/evals-freenode-#perlbot.lst[8]: - - '+'
evals/evals-freenode-#perlbot.lst[9]: - - '❧'
evals/evals-freenode-#perlbot.lst[10]: ;;;;;;;;;;;;;;;;;;;
evals/evals-freenode-#perlbot.lst[11]: "$^";
evals/evals-freenode-#perlbot.lst[12]: ()
evals/evals-freenode-#perlbot.lst[13]: ();
evals/evals-freenode-#perlbot.lst[14]: [ :: ]
evals/evals-freenode-#perlbot.lst[15]: [{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',]
evals/evals-freenode-#perlbot.lst[16]: [{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',]
evals/evals-freenode-#perlbot.lst[17]: [{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',\]
evals/evals-freenode-#perlbot.lst[18]: @_
evals/evals-freenode-#perlbot.lst[19]: $^]
evals/evals-freenode-#perlbot.lst[20]: $!
evals/evals-freenode-#perlbot.lst[21]: $]
evals/evals-freenode-#perlbot.lst[22]: \@_
evals/evals-freenode-#perlbot.lst[23]: \%::
evals/evals-freenode-#perlbot.lst[24]: ;
evals/evals-freenode-#perlbot.lst[25]: ;;;;;;;;;;;;;;;;;;;;
evals/evals-freenode-#perlbot.lst[26]: 0^^0
evals/evals-freenode-#perlbot.lst[27]: 0**0
evals/evals-freenode-#perlbot.lst[28]: '0.00'+0 ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[29]: '000202056D4C' =~ s/..\K\B/:/gr
evals/evals-freenode-#perlbot.lst[30]: '000202056D4C' =~ s/..\K/:/gr
evals/evals-freenode-#perlbot.lst[31]: '0.00' ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[32]: '0.0'? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[33]: 0%10
evals/evals-freenode-#perlbot.lst[34]: [ '010' + 0 ]
evals/evals-freenode-#perlbot.lst[35]:  "!(0 || 1 && (0 || 0)) && !(1 && 1)"
evals/evals-freenode-#perlbot.lst[36]: ((0.1 + 0.2)
evals/evals-freenode-#perlbot.lst[37]: ((0.1 + 0.2))
evals/evals-freenode-#perlbot.lst[38]: [ 0.1 + 0.2, ((0.1 + 0.2) == 0.3) ? 'y' : 'n' ]
evals/evals-freenode-#perlbot.lst[39]: ((0.1 + 0.2) == 0.3) ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[40]: 0.1 + 0.2 == 0.3 ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[41]: 0+grep - - chr, 0..255;
evals/evals-freenode-#perlbot.lst[42]: 0+grep { length(- - chr) > 1 } 0..255;
evals/evals-freenode-#perlbot.lst[43]: [ '0x010' + 0 ]
evals/evals-freenode-#perlbot.lst[44]: [ 0x7f - 0x20, 0xff5f - 0xff00 ];
evals/evals-freenode-#perlbot.lst[45]: 0x80
evals/evals-freenode-#perlbot.lst[46]: 0xFFF
evals/evals-freenode-#perlbot.lst[47]: 1
evals/evals-freenode-#perlbot.lst[48]: "1"
evals/evals-freenode-#perlbot.lst[49]: $! = 1; "$!"
evals/evals-freenode-#perlbot.lst[50]: [ !1, !0, !0+0]
evals/evals-freenode-#perlbot.lst[51]: [ !1, !0, !1+0]
evals/evals-freenode-#perlbot.lst[52]: 10**length q|*******|
evals/evals-freenode-#perlbot.lst[53]: [\1, \1]
evals/evals-freenode-#perlbot.lst[54]: [ 1111111 =~ /^(1+)+$/ ];
evals/evals-freenode-#perlbot.lst[55]: 1111111 =~ /^(1{1,10})(1{1,10})(1{1,10})(?{ push @comb, [$1, $2, $3] })(?!)/; \@comb
evals/evals-freenode-#perlbot.lst[56]: 1111111 =~ /^(1{1,10})(1{1,10})(1{1,10})(?{ push @comb, [$1, $2, $3] })(?!)/; [map [map length, @$_], @comb]
evals/evals-freenode-#perlbot.lst[57]: 1111111 =~ /^(1{1,10})(1{1,10})(1{1,10})$(?{ push @comb, [$1, $2, $3] })(?!)/; [map [map length, @$_], @comb]
evals/evals-freenode-#perlbot.lst[58]: 1111111 =~ /^((1+)(?{ local @one = @one, $1 }))+$(?{ push @comb, \@one })(?!)/; \@comb;
evals/evals-freenode-#perlbot.lst[59]: 1111111 =~ /^((1+)(?{ local @one = @one, $2 }))+$(?{ push @comb, \@one })(?!)/; \@comb;
evals/evals-freenode-#perlbot.lst[60]: 1111111 =~ /^((1+)(?{ local @one = @one, $2 })+$(?{ push @comb, \@one })(?!)/; \@comb;
evals/evals-freenode-#perlbot.lst[61]: [ 1111111 =~ /^(<A>1+)+$/ ];
evals/evals-freenode-#perlbot.lst[62]: [ 1111111 =~ /^(?<A>1+)+$/ ];
evals/evals-freenode-#perlbot.lst[63]: 1111111 =~ /^(<A>1+)*$/;
evals/evals-freenode-#perlbot.lst[64]: 1111111 =~ /^(<A>1+)*$(?{ print 'yes'; push @comb, [@{$-{A}}] })(?!)/; \@comb;
evals/evals-freenode-#perlbot.lst[65]: 1111111 =~ /^(?<A>1+)*$(?{ print 'yes'; push @comb, [@{$-{A}}] })(?!)/; \@comb;
evals/evals-freenode-#perlbot.lst[66]: 1111111 =~ /^(?<A>1+)*$(?{ push @comb, [@{$-{A}}] })(?!)/; \@comb;
evals/evals-freenode-#perlbot.lst[67]: 1111111 =~ /^(<A>1+)*$(?{ push @comb, [@{$-{A}}] })(?!)/ ? [map [map length, @$_], @comb] : 
evals/evals-freenode-#perlbot.lst[68]: 1111111 =~ /^(<A>1+)*$(?{ push @comb, [@{$-{A}}] })(?!)/; [map [map length, @$_], @comb]
evals/evals-freenode-#perlbot.lst[69]: 1111111 =~ /^(<A>1+)*$(?{ push @comb, [@{$-{A}}] })(?!)/ ? [map [map length, @$_], @comb] : 'no';
evals/evals-freenode-#perlbot.lst[70]: 1+2
evals/evals-freenode-#perlbot.lst[71]: '12' =~ /1\B2/ ? 'match' : 'nope'
evals/evals-freenode-#perlbot.lst[72]: [ '1234567890' =~ /.{0,3}/g ]
evals/evals-freenode-#perlbot.lst[73]: [ '1234567890' =~ /.{1,3}/g ]
evals/evals-freenode-#perlbot.lst[74]: [ '1234567890' =~ /.{,3}/g ]
evals/evals-freenode-#perlbot.lst[75]: /13
evals/evals-freenode-#perlbot.lst[76]: 1.5 * 14
evals/evals-freenode-#perlbot.lst[77]: /1\b2/ ? 'match' : 'nope'
evals/evals-freenode-#perlbot.lst[78]: /1\B2/ ? 'match' : 'nope'
evals/evals-freenode-#perlbot.lst[79]: 1e1000
evals/evals-freenode-#perlbot.lst[80]: [ 1e205 / 1e192 ]
evals/evals-freenode-#perlbot.lst[81]: 1+print 4
evals/evals-freenode-#perlbot.lst[82]: 1+print "4"
evals/evals-freenode-#perlbot.lst[83]: $[ = 1;  [ qw/Foo Bar/[1] ]
evals/evals-freenode-#perlbot.lst[84]: '-1' =~ s/(.+)/-$1/er
evals/evals-freenode-#perlbot.lst[85]: ++${\1}; say 1
evals/evals-freenode-#perlbot.lst[86]: $! = 2; "$!"
evals/evals-freenode-#perlbot.lst[87]: 20%10
evals/evals-freenode-#perlbot.lst[88]: 2 << 1
evals/evals-freenode-#perlbot.lst[89]: [ 2 << 1, 2 >> 1 ]
evals/evals-freenode-#perlbot.lst[90]: [ 2 << 1, 4 >> 1 ]
evals/evals-freenode-#perlbot.lst[91]: 2 << 2
evals/evals-freenode-#perlbot.lst[92]: 220/10*4/60
evals/evals-freenode-#perlbot.lst[93]: 220/8*4/60
evals/evals-freenode-#perlbot.lst[94]: *2=2.5; *2+*2
evals/evals-freenode-#perlbot.lst[95]: - - '234567'
evals/evals-freenode-#perlbot.lst[96]: 2**40
evals/evals-freenode-#perlbot.lst[97]: 255.244
evals/evals-freenode-#perlbot.lst[98]: 3%10
evals/evals-freenode-#perlbot.lst[99]: 378/462
evals/evals-freenode-#perlbot.lst[100]: [ 3 + asdfadsf->import ]
evals/evals-freenode-#perlbot.lst[101]: (4095 & 0xFF00) >> 8;
evals/evals-freenode-#perlbot.lst[102]: 417 * 256
evals/evals-freenode-#perlbot.lst[103]: 42
evals/evals-freenode-#perlbot.lst[104]: ’42’
evals/evals-freenode-#perlbot.lst[105]: ('42 bottles of beer' =~ /(\d+)/)[0]
evals/evals-freenode-#perlbot.lst[106]: \42->can("foo");
evals/evals-freenode-#perlbot.lst[107]: 42->can("foo");
evals/evals-freenode-#perlbot.lst[108]: (42 =~ /(\d+)/)[0]
evals/evals-freenode-#perlbot.lst[109]: 473*6
evals/evals-freenode-#perlbot.lst[110]: *4 = sub { 'ok' }; main->${ \4 };
evals/evals-freenode-#perlbot.lst[111]: *4 = sub { 'ok' }; main->4;
evals/evals-freenode-#perlbot.lst[112]: *4 = sub { print "yes" }; 4->()
evals/evals-freenode-#perlbot.lst[113]: 6%10
evals/evals-freenode-#perlbot.lst[114]: 71503 + 46697- 999
evals/evals-freenode-#perlbot.lst[115]: [ 98-110,106-117,118-103]  
evals/evals-freenode-#perlbot.lst[116]: 998*999
evals/evals-freenode-#perlbot.lst[117]: 999*999
evals/evals-freenode-#perlbot.lst[118]: - - ' A'
evals/evals-freenode-#perlbot.lst[119]: - - 'A'
evals/evals-freenode-#perlbot.lst[120]: *$a = 1;
evals/evals-freenode-#perlbot.lst[121]: @a=(1..5); $a[-20]
evals/evals-freenode-#perlbot.lst[122]: [ 'a 42 b' =~ s/\D+//, 'a 42 b' =~ s/\D+//g ]
evals/evals-freenode-#perlbot.lst[123]: [ 'a 42 b' =~ s/\D+//r, 'a 42 b' =~ s/\D+//gr ]
evals/evals-freenode-#perlbot.lst[124]: $_ = "aa"; /^(.)$1$/
evals/evals-freenode-#perlbot.lst[125]: $_ = "aa"; /^(.)\1$/
evals/evals-freenode-#perlbot.lst[126]: $a = 'a'; my $b = \*a; for $$b (0..5) { print $a }
evals/evals-freenode-#perlbot.lst[127]: \$a = \$b
evals/evals-freenode-#perlbot.lst[128]: /a\Ba/ ? 'match' : 'nope'
evals/evals-freenode-#perlbot.lst[129]: [ \'abc', \'abc' ]
evals/evals-freenode-#perlbot.lst[130]: [ \abc::, \abc:: ]
evals/evals-freenode-#perlbot.lst[131]: [ \('abc' x 2) ]
evals/evals-freenode-#perlbot.lst[132]: [ \(abc:: x 2) ]
evals/evals-freenode-#perlbot.lst[133]: /a\b/ ? 'match' : 'nope'
evals/evals-freenode-#perlbot.lst[134]: /a\b#/ ? 'match' : 'nope'
evals/evals-freenode-#perlbot.lst[135]: $a="foo bar" *$a = 1;
evals/evals-freenode-#perlbot.lst[136]: $a="foo bar"; *$a = 1;
evals/evals-freenode-#perlbot.lst[137]: $a="foo bar"; *$a = sub {"baz"};
evals/evals-freenode-#perlbot.lst[138]: $a="foo bar"; *$a = sub {"baz"}; "foo bar"->()
evals/evals-freenode-#perlbot.lst[139]: /a/ ? 'match' : 'nope'
evals/evals-freenode-#perlbot.lst[140]: 'A' =~ s/(A)/lcfirst $1/re
evals/evals-freenode-#perlbot.lst[141]: 'A' =~ s/(A)/'lcfirst $1'/ree
evals/evals-freenode-#perlbot.lst[142]: [asdfadsf->can('import')]
evals/evals-freenode-#perlbot.lst[143]: asdfadsf->fooo
evals/evals-freenode-#perlbot.lst[144]: [ asdfadsf->import ]
evals/evals-freenode-#perlbot.lst[145]: asdfadsf->import
evals/evals-freenode-#perlbot.lst[146]: '/asdf//' =~ m{/[^/]*/(?!/)} ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[147]: [ ('a' x 30) =~ /(.*a){25,}/ ];
evals/evals-freenode-#perlbot.lst[148]: ('a' x 30) =~ /([^a]*a){25,}/
evals/evals-freenode-#perlbot.lst[149]: [ ('a' x 30) =~ /([^a]*a){25,}/ ];
evals/evals-freenode-#perlbot.lst[150]: 'aXYbXYcXYdeXfYgX' =~ s/.+\KXY.+$//r;
evals/evals-freenode-#perlbot.lst[151]: 'aXYbXYcXYdeXfYgX' =~ s/(.+)XY.+$/$1/r;
evals/evals-freenode-#perlbot.lst[152]: 'aXYbXYcXYdeXfYgX' =~ s/XY(.(?!=XY))+//r
evals/evals-freenode-#perlbot.lst[153]: 'aXYbXYcXYdeXfYgX' =~ s/XY(.(?!=XY))+$//r
evals/evals-freenode-#perlbot.lst[154]: 'aXYbXYcXYdeXfYgX' =~ s/XY(.(?!=XY)+)//r
evals/evals-freenode-#perlbot.lst[155]: 'aXYbXYcXYdeXfYgX' =~ s/XY(.(?!=XY)+)$//r
evals/evals-freenode-#perlbot.lst[156]: 'aXYbXYcXYdeXfYgX' =~ s/XY(.(?!=XY)+)+//r
evals/evals-freenode-#perlbot.lst[157]: 'aXYbXYcXYdeXfYgX' =~ s/XY(.(?!XY))+$//r
evals/evals-freenode-#perlbot.lst[158]: [ ('A'..'Z', 0..9)[29] ]
evals/evals-freenode-#perlbot.lst[159]: [(a..z)[24]]
evals/evals-freenode-#perlbot.lst[160]: [ ('a'..'z')[25] ]
evals/evals-freenode-#perlbot.lst[161]: [ ('a'..'z')[26] ]
evals/evals-freenode-#perlbot.lst[162]: [ 'babgbag' =~ /.*?b.*?a.*?g.*?/g ]
evals/evals-freenode-#perlbot.lst[163]: [ 'babgbag' =~ /.*?b.*?a.*?g.*/g ]
evals/evals-freenode-#perlbot.lst[164]: [ 'babgbag' =~ /.*b.*a.*g.*/g ]
evals/evals-freenode-#perlbot.lst[165]: [ () = 'babgbag' =~ /.*?b.*?a.*?g.*?/g ]
evals/evals-freenode-#perlbot.lst[166]: [ () = 'babgbag' =~ /.*b.*a.*g.*/g ]
evals/evals-freenode-#perlbot.lst[167]: - - '+bar'
evals/evals-freenode-#perlbot.lst[168]: - 'bar'
evals/evals-freenode-#perlbot.lst[169]: --'bar'
evals/evals-freenode-#perlbot.lst[170]: -(-'bar')
evals/evals-freenode-#perlbot.lst[171]: 'bar' - 'bar'
evals/evals-freenode-#perlbot.lst[172]: BEGIN { *4 = sub () { 'ok' } }; &{ 4 };
evals/evals-freenode-#perlbot.lst[173]: BEGIN { *4 = sub () { 'ok' } }; &{ 4 }();
evals/evals-freenode-#perlbot.lst[174]: BEGIN { $::{ARRAY} = \[qw(one two three)] }; ARRAY
evals/evals-freenode-#perlbot.lst[175]: BEGIN { *consecrate = \&CORE::bless }  [ consecrate  {}, 'Foo' ]
evals/evals-freenode-#perlbot.lst[176]: BEGIN{ $^H = 0 }; use strict; use feature 'state';  for( 1..3) { print ++(state $x) }
evals/evals-freenode-#perlbot.lst[177]: BEGIN{ $^H = 0 }; use strict; use feature 'state';  for( 1..3) { state $x; print ++$x }
evals/evals-freenode-#perlbot.lst[178]: BEGIN { &Internals::SvREADONLY(\1, 0); ++${ \1 } }; say 1
evals/evals-freenode-#perlbot.lst[179]: BEGIN { Internals::SvREADONLY(\1, 0); ++${ \1 } }; say 1
evals/evals-freenode-#perlbot.lst[180]: BEGIN { &Internals::SvREADONLY(\undef, 0); ++${ \undef } }; say undef;
evals/evals-freenode-#perlbot.lst[181]: BEGIN { $SIG{__DIE__} = sub { say "42"; } } '..'
evals/evals-freenode-#perlbot.lst[182]: BEGIN { $SIG{__DIE__} = sub { say "42"; } }  a ab 
evals/evals-freenode-#perlbot.lst[183]: BEGIN { $SIG{__DIE__} = sub { say 42 };  }  a bc
evals/evals-freenode-#perlbot.lst[184]: BEGIN { $SIG{__DIE__} = sub { say 42; };  }  a bc
evals/evals-freenode-#perlbot.lst[185]: BEGIN { $SIG{__DIE__} = sub { say 42; exit  };  }  a bc
evals/evals-freenode-#perlbot.lst[186]: BEGIN { $SIG{__DIE__} = sub { say 42; return 0 };  }  a bc
evals/evals-freenode-#perlbot.lst[187]: BEGIN { $SIG{__DIE__} = sub { say 42; return  };  }  a bc
evals/evals-freenode-#perlbot.lst[188]: BEGIN { $SIG{__DIE__} = sub { say 42; return false };  }  a bc
evals/evals-freenode-#perlbot.lst[189]: "BenGoldberg \N{HEAVY SPARKLE}"
evals/evals-freenode-#perlbot.lst[190]: binmode STDOUT; ($a,$b) = ("\x{202d}", "\x{202e}");
evals/evals-freenode-#perlbot.lst[191]: binmode STDOUT; ($a,$b) = ("\x{202d}", "\x{202e}"); $_ = "Just another BIDI Hacker,\n"; print "$a$1$b$3" while s/(.)(.*)(.)/$2/;
evals/evals-freenode-#perlbot.lst[192]: binmode STDOUT; ($a,$b) = ("\x{202d}", "\x{202e}"); $_ = "Just another BIDI Hacker, "; print "$a$1$b$3" while s/(.)(.*)(.)/$2/;
evals/evals-freenode-#perlbot.lst[193]: binmode STDOUT; ($a,$b) = ("\x{202d}", "\x{202e}"); $_ = "Just another BIDI Hacker"; print "$a$1$b$3" while s/(.)(.*)(.)/$2/;
evals/evals-freenode-#perlbot.lst[194]: binmode STDOUT, 'encoding(utf8)'; my @o = ("\x{202d}", "\x{202e}"); print "$o[--$|]$_" for split //, 'J,ursetk cAanHo tIhDeIrB /Pler'
evals/evals-freenode-#perlbot.lst[195]: binmode STDOUT; $_ = "Just another BIDI Hacker, "; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
evals/evals-freenode-#perlbot.lst[196]: binmode STDOUT; $_ = "Just another Hexchat Hacker,  "; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
evals/evals-freenode-#perlbot.lst[197]: binmode STDOUT; $_ = "Just another Hexchat Hacker, "; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
evals/evals-freenode-#perlbot.lst[198]: binmode STDOUT; $_ = "Just another Hexchat Hacker,"; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
evals/evals-freenode-#perlbot.lst[199]: binmode STDOUT; $_ = "Just another Perl/BIDI Hacker,"; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
evals/evals-freenode-#perlbot.lst[200]: binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\x10-\x7f][\xff00-\xff5f]r;
evals/evals-freenode-#perlbot.lst[201]: binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\x20-\x7f][\x{2000}\x{ff01}-\x{ff5f}]r;
evals/evals-freenode-#perlbot.lst[202]: binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\x20-\x7f][\x{2001}\x{ff01}-\x{ff5f}]r;
evals/evals-freenode-#perlbot.lst[203]: binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\x20-\x7f][\x{2003}\x{ff01}-\x{ff5f}]r;
evals/evals-freenode-#perlbot.lst[204]: binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\x20-\x7f][\x{ff00}-\x{ff5f}]r;
evals/evals-freenode-#perlbot.lst[205]: binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\x20-\x7f][\xff00-\xff5f]r;
evals/evals-freenode-#perlbot.lst[206]: binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\x20-\x7f][ \x{ff01}-\x{ff5f}]r;
evals/evals-freenode-#perlbot.lst[207]: binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\x20-\x7f][\xff10-\xff5f]r;
evals/evals-freenode-#perlbot.lst[208]: binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\x20-\x7f][\xff20-\xff5f]r;
evals/evals-freenode-#perlbot.lst[209]: binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\x20-\x7f][\xff30-\xff5f]r;
evals/evals-freenode-#perlbot.lst[210]: binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\x20-\x7f][\xff40-\xff5f]r;
evals/evals-freenode-#perlbot.lst[211]: binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\x20-\x7f][\xff50-\xff5f]r;
evals/evals-freenode-#perlbot.lst[212]: binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\x30-\x7f][\xff00-\xff5f]r;
evals/evals-freenode-#perlbot.lst[213]: binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\x40-\x7f][\xff00-\xff5f]r;
evals/evals-freenode-#perlbot.lst[214]: binmode STDOUT; my @o = ("\x{202d}", "\x{202e}"); print "$o[--$|]$_" for split //, 'J,ursetk cAanHo tIhDeIrB /Pler'
evals/evals-freenode-#perlbot.lst[215]: binmode STDOUT; print '✙' .. '❉'
evals/evals-freenode-#perlbot.lst[216]: binmode STDOUT; print chr($_) for 0x2719 .. 0x2749;
evals/evals-freenode-#perlbot.lst[217]: binmode STDOUT; print for '✙' .. '❉'
evals/evals-freenode-#perlbot.lst[218]: binmode STDOUT; print "\x{1f4a9}"
evals/evals-freenode-#perlbot.lst[219]: binmode STDOUT; srand 42; my @o = ("\U{202d}", "\U{202e}"); print "$o[--$|]$_" for 'a'..'z', '_';
evals/evals-freenode-#perlbot.lst[220]: binmode STDOUT; srand 42; my @o = ("\U202d", "\U202e"); print "$o[--$|]$_" for 'a'..'z', '_';
evals/evals-freenode-#perlbot.lst[221]: binmode STDOUT; srand 42; my @o = ("\U202d", "\U202e"); print "$o[rand 2]$_" for 'a'..'z', '_';
evals/evals-freenode-#perlbot.lst[222]: binmode STDOUT; srand 42; my @o = ("\U202d", "\U202e"); print "$o[rand 2]$_" for 'A'..'Z', '_';
evals/evals-freenode-#perlbot.lst[223]: binmode STDOUT; srand 42; my @o = ("\x{202d}", "\x{202e}"); print "$o[--$|]$_" for 'a'..'z', '_';
evals/evals-freenode-#perlbot.lst[224]: binmode STDOUT; srand 42; my @o = ("\x{202d}", "\x{202e}"); print "$o[--$|]$_" for 'a'..'z', 0..3;
evals/evals-freenode-#perlbot.lst[225]: binmode STDOUT; srand 42; my @o = ("\x{202d}", "\x{202e}"); print "$o[rand 2]$_" for 'a'..'z', '_';
evals/evals-freenode-#perlbot.lst[226]: binmode STDOUT; srand 42; my @o = ("\x202d", "\x202e"); print "$o[rand 2]$_" for 'a'..'z', '_';
evals/evals-freenode-#perlbot.lst[227]: binmode STDOUT; srand 42; my @o = ("\x{202d}", "\x{202e}"); print "$o[rand 2]$_" for split //, "rJust anekocath ehder oUcin";
evals/evals-freenode-#perlbot.lst[228]: binmode STDOUT; srand 42; my @o = ("\x{202d}", "\x{202e}"); print "$o[rand 2]$_" for split //, "rJust_anekocath_ehder_oUcin";
evals/evals-freenode-#perlbot.lst[229]: binmode STDOUT; srand 42; my @o = ("\x{202d}", "\x{202e}"); print "$o[rand 2]$_" for split //, "rJust__Anekocath_ehder_oUcin";
evals/evals-freenode-#perlbot.lst[230]: binmode STDOUT; srand 42; my @o = ("\x{202d}", "\x{202e}"); print "$o[rand 2]$_" for split //, "rJust_Anekocath_ehder_oUcin";
evals/evals-freenode-#perlbot.lst[231]: binmode STDOUT; srand 42; my @o = ("\x{202d}", "\x{202e}"); print "$o[rand 2]$_" for split //, "rJustA_nekocath_ehder_oUcin";
evals/evals-freenode-#perlbot.lst[232]: binmode STDOUT; srand 42; my @o = ("\x{202d}", "\x{202e}"); print "$o[rand 2]$_" for split //, "rJustAnekocath_ehder_oUcin_";
evals/evals-freenode-#perlbot.lst[233]: binmode STDOUT, 'utf8'; my @o = ("\x{202d}", "\x{202e}"); print "$o[--$|]$_" for split //, 'J,ursetk cAanHo tIhDeIrB /Pler'
evals/evals-freenode-#perlbot.lst[234]: blahblah q|0.000.000_YYMMDDhhmm|
evals/evals-freenode-#perlbot.lst[235]: bless bless(), "Bar"
evals/evals-freenode-#perlbot.lst[236]: bless bless({}, "Foo"), "Bar"
evals/evals-freenode-#perlbot.lst[237]: *::bless = sub { print "foo" }; bless {}, 'Foo';
evals/evals-freenode-#perlbot.lst[238]: *bless = sub { print "foo" }; bless {}, 'Foo';
evals/evals-freenode-#perlbot.lst[239]: $_ = 'CamelCaseXMLParser'; join('_', map {lc} grep {length} split /([A-Z]+[^A-Z]*)/)
evals/evals-freenode-#perlbot.lst[240]: $_ = 'CamelCaseXMLParser'; join '', map { ucfirst lc } split '_', join('_', map {lc} grep {length} split /([A-Z]+[^A-Z]*)/)
evals/evals-freenode-#perlbot.lst[241]: $_ = 'CamelCaseXMLParser'; join('', map { ucfirst lc } split '_', join('_', map {lc} grep {length} split /([A-Z]+[^A-Z]*)/)
evals/evals-freenode-#perlbot.lst[242]: 'CamelCaseXMLParser' =~ s/([A-Z]+[^A-Z]*)/\u\L$1/gr;
evals/evals-freenode-#perlbot.lst[243]: ""->can("foo");
evals/evals-freenode-#perlbot.lst[244]: $Carp::CarpLevel++; Carp::croak("loaded");
evals/evals-freenode-#perlbot.lst[245]: Carp::croak("loaded")
evals/evals-freenode-#perlbot.lst[246]: $Carp::Internal{"main"}++; Carp::croak("loaded");
evals/evals-freenode-#perlbot.lst[247]: $cat_line = 'Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\Q*::*\E/g) > 3 ? 1 : 0; [ $is_deep ]
evals/evals-freenode-#perlbot.lst[248]: $cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur*::*Brooze'; my $is_deep = (() = $cat_line =~ /\Q*::*\E/g) > 1 ? 1 : 0; my @cat_bits = split /\Q*::*\E/, $cat_line; splice @cat_bits, -2; my $unwanted_cat = join '*::*', @cat_bits; [ \@cat_bits, $unwanted_cat  ]
evals/evals-freenode-#perlbot.lst[249]: $cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (=() = $cat_line =~ /\Q*::*\E/) > 3 ? 1 : 0; [ $is_deep ]
evals/evals-freenode-#perlbot.lst[250]: $cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\Q*::*\E/) > 3 ? 1 : 0; [ $is_deep ]
evals/evals-freenode-#perlbot.lst[251]: $cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\Q*::*\E/g) > 1 ? 1 : 0; my @cat_bits = split /\Q*::*\E/, $cat_line; [ \@cat_bits ]
evals/evals-freenode-#perlbot.lst[252]: $cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\Q*::*\E/g) > 1 ? 1 : 0; my @cat_bits = split /\Q*::*\E/, $cat_line; $cat_line = join '*::*', splice @cat_bits, 2; [ \@cat_bits, $cat_line ]
evals/evals-freenode-#perlbot.lst[253]: $cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\Q*::*\E/g) > 1 ? 1 : 0; my @cat_bits = split /\Q*::*\E/, $cat_line = join '*::*', splice @cat_bits, 2; [ \@cat_bits, $cat_line ]
evals/evals-freenode-#perlbot.lst[254]: $cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\Q*::*\E/g) > 1 ? 1 : 0; my @cat_bits = split /\Q*::*\E/, $cat_line = join '*::*', splice @cat_bits, 3; [ \@cat_bits, $cat_line ]
evals/evals-freenode-#perlbot.lst[255]: $cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\Q*::*\E/g) > 1 ? 1 : 0; my @cat_bits = split /\Q*::*\E/, $cat_line; splice @cat_bits, -2; my $unwanted_cat = join '*::*', @cat_bits; [ \@cat_bits, $unwanted_cat  ]
evals/evals-freenode-#perlbot.lst[256]: $cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\Q*::*\E/g) > 1 ? 1 : 0; my @cat_bits = split /\Q*::*\E/, $cat_line; splice @cat_bits, 2; my $unwanted_cat = join '*::*', @cat_bits; [ \@cat_bits, $unwanted_cat  ]
evals/evals-freenode-#perlbot.lst[257]: $cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\Q*::*\E/g) > 1 ? 1 : 0; my $prefix = splice 0, 3, @{[split /\Q*::*\E/, $cat_line]; [ $prefix ]
evals/evals-freenode-#perlbot.lst[258]: $cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\Q*::*\E/g) > 1 ? 1 : 0; my $prefix = splice 0, 3, @{[split /\Q*::*\E/, $cat_line]}; [ $prefix ]
evals/evals-freenode-#perlbot.lst[259]: $cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\Q*::*\E/g) > 1 ? 1 : 0; my $prefix = splice 0, 3, split /\Q*::*\E/, $cat_line; [ $prefix ]
evals/evals-freenode-#perlbot.lst[260]: $cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = (() = $cat_line =~ /\Q*::*\E/g) > 3 ? 1 : 0; [ $is_deep ]
evals/evals-freenode-#perlbot.lst[261]: $cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = () = $cat_line =~ /\Q*::*\E/g;  [ $is_deep ]
evals/evals-freenode-#perlbot.lst[262]: $cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = () = $cat_line =~ /\Q*::*\E/;  [ $is_deep ]
evals/evals-freenode-#perlbot.lst[263]: $cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; my $is_deep = () = $cat_line =~ /\Q*::*\E/);  [ $is_deep ]
evals/evals-freenode-#perlbot.lst[264]: $cat_line = '[Foo*::*Bar*::*Ber*::*Bez*::*Bur]'; $wanted_cat = join '*::*', (split /\Q*::*\E/, $cat_line)[-3,-1]; [ $wanted_cat ]
evals/evals-freenode-#perlbot.lst[265]: $cat_line = 'Foo*::*Bar*::*Ber*::*Bez*::*Bur'; $wanted_cat = join '*::*', (split /\Q*::*\E/, $cat_line)[-3,-1]; [ $wanted_cat ]
evals/evals-freenode-#perlbot.lst[266]: $c="{a,v,p,r}"; [grep {$_ !~ /(.)\1/} glob $c.$c]
evals/evals-freenode-#perlbot.lst[267]: $_ = 'C########C_##'; /(#*)C/; [ length $1 ]
evals/evals-freenode-#perlbot.lst[268]: $_ = '########C_##'; /(#+)C/; [ length $1 ]
evals/evals-freenode-#perlbot.lst[269]: $_ = '########C_##'; /C/; [ pos ]
evals/evals-freenode-#perlbot.lst[270]: @charmap = qw/Botje!!!/; @charmap->[qw/Botje/]
evals/evals-freenode-#perlbot.lst[271]: @charmap = qw/Botje/; @charmap->[qw/Botje!/]
evals/evals-freenode-#perlbot.lst[272]: charnames::string_vianame("SNOWMAN")
evals/evals-freenode-#perlbot.lst[273]: charnames::viacode(1234)
evals/evals-freenode-#perlbot.lst[274]: chr 0xd800
evals/evals-freenode-#perlbot.lst[275]: chr 'Χ'
evals/evals-freenode-#perlbot.lst[276]: $_ = '########_##'; /(#*)C/; [ length $1 ]
evals/evals-freenode-#perlbot.lst[277]: $code
evals/evals-freenode-#perlbot.lst[278]: *code = sub { print 'ok' }; say '[', code, ']';
evals/evals-freenode-#perlbot.lst[279]: \&code = sub { print 'ok' }; say '[', code, ']';
evals/evals-freenode-#perlbot.lst[280]: *CORE::bless = sub { print "foo" }
evals/evals-freenode-#perlbot.lst[281]: \*$CORE::bless = sub { print "foo" }
evals/evals-freenode-#perlbot.lst[282]: \*CORE::bless = sub { print "foo" }
evals/evals-freenode-#perlbot.lst[283]: *CORE::bless = sub { print "foo" }; bless
evals/evals-freenode-#perlbot.lst[284]: *CORE::bless = sub { print "foo" }; bless {}, 'Foo';
evals/evals-freenode-#perlbot.lst[285]: *CORE::die = sub { say "42"; } die  
evals/evals-freenode-#perlbot.lst[286]: *CORE::die = sub { say "42"; }; die  
evals/evals-freenode-#perlbot.lst[287]: $CORE::GLOBAL::print = sub { print 42 }; print "foo"
evals/evals-freenode-#perlbot.lst[288]: *CORE::GLOBAL::print = sub { print 42 }; print "foo"
evals/evals-freenode-#perlbot.lst[289]: CORE::GLOBAL{print} = sub { print 42 }; print "foo"
evals/evals-freenode-#perlbot.lst[290]: *CORE::print
evals/evals-freenode-#perlbot.lst[291]: \*CORE::print
evals/evals-freenode-#perlbot.lst[292]: [ ctime ]
evals/evals-freenode-#perlbot.lst[293]: [ ctime time ]
evals/evals-freenode-#perlbot.lst[294]: @d
evals/evals-freenode-#perlbot.lst[295]: $Data::Dumper::Deparse = 1; my $a = sub { say "Hello World" }; my $b = $a; \(sub {say "Goodbye Mars"});
evals/evals-freenode-#perlbot.lst[296]: Data::Dumper::Deparse = 1; my $a = sub { say "Hello World" }; my $b = $a; \(sub {say "Goodbye Mars"});
evals/evals-freenode-#perlbot.lst[297]: $Data::Dumper::Terse = 1; $r = [ 1, 2, 3, { foo => bar }, ]; @a = @$r; $r->[0] = 42; $r->[3]{ber} = 'bez'; [ \@a, $r ]
evals/evals-freenode-#perlbot.lst[298]: $_ = { date_updated => 0 }; $_->{date_updated} = $_->{date_updated} ? strftime "%Y-%m-%d", gmtime $_->{date_updated} : 'N/A'; say $_;
evals/evals-freenode-#perlbot.lst[299]: $_ = { date_updated => 0 }; $_->{date_updated} = $_->{date_updated} ? strftime "%Y-%m-%d", gmtime $_->{date_updated} : 'N/A'; say Dumper $_;
evals/evals-freenode-#perlbot.lst[300]: $_ = { date_updated => 42 }; $_->{date_updated} = $_->{date_updated} ? strftime "%Y-%m-%d", gmtime $_->{date_updated} : 'N/A'; say Dumper $_;
evals/evals-freenode-#perlbot.lst[301]: decode_json
evals/evals-freenode-#perlbot.lst[302]: deparse: sub foo (;$) { say "[@_]"; }; my %h = ( bar => foo(42), meow => 'moo' ); \%h
evals/evals-freenode-#perlbot.lst[303]: deparse: sub foo ($) { say "[@_]"; }; my %h = ( bar => foo(42), meow => 'moo' ); \%h
evals/evals-freenode-#perlbot.lst[304]: deparse: sub foo ($$) { say "[@_]"; }; my %h = ( bar => foo(42), meow => 'moo' ); \%h
evals/evals-freenode-#perlbot.lst[305]: ()?(): die 'Denied.';
evals/evals-freenode-#perlbot.lst[306]: do {my $print = \&CORE::GLOBAL::print; *CORE::GLOBAL::print = sub { $print->("wut wut: ", @_)}}; CORE::print "foo"
evals/evals-freenode-#perlbot.lst[307]: do { my @tmp = 1, 2, 3; \@tmp }
evals/evals-freenode-#perlbot.lst[308]: [ $!{EINSUFFICIENT_POO} ]
evals/evals-freenode-#perlbot.lst[309]: $!{EINSUFFICIENT_POO}
evals/evals-freenode-#perlbot.lst[310]: \%ENV
evals/evals-freenode-#perlbot.lst[311]: [ Errno::EBADE ]
evals/evals-freenode-#perlbot.lst[312]: [ Errno::EBADY ]
evals/evals-freenode-#perlbot.lst[313]: [ Errno::EBUSY ]
evals/evals-freenode-#perlbot.lst[314]: [ Errno::EPERM ]
evals/evals-freenode-#perlbot.lst[315]: [ Errno::ETOOMANYREFS ]
evals/evals-freenode-#perlbot.lst[316]: eval "!(0 || 1 && (0 || 0)) && !(1 && 1)"
evals/evals-freenode-#perlbot.lst[317]: [ eval "qw(yes yes),\n#no\nqw(yes yes)" ]
evals/evals-freenode-#perlbot.lst[318]: exec '/bin/cwd'; $!;
evals/evals-freenode-#perlbot.lst[319]: exec '/bin/ls'; $!;
evals/evals-freenode-#perlbot.lst[320]: exec '/usr/bin/ls'; $!;
evals/evals-freenode-#perlbot.lst[321]: $_ = '@f@f@f'; s'@f'$b'gr; 
evals/evals-freenode-#perlbot.lst[322]: $fl = '+++????? random shit any user can send to the bot'; my @mem_list = grep { $_ =~ /^$fl/i} 42;
evals/evals-freenode-#perlbot.lst[323]: $fl = '+++ random shit any user can send to the bot'; my @mem_list = grep { $_ =~ /^$fl/i} keys %$refer;
evals/evals-freenode-#perlbot.lst[324]: $fl = '+++????? random shit any user can send to the bot'; my @mem_list = grep { $_ =~ /^$fl/i} keys %$refer;
evals/evals-freenode-#perlbot.lst[325]: $fl = '+++????? random shit any user can send to the bot'; my @mem_list = grep { $_ =~ /^$fl/i} keys %$refer; 42
evals/evals-freenode-#perlbot.lst[326]: ++($foo++)
evals/evals-freenode-#perlbot.lst[327]: ++${($foo++)
evals/evals-freenode-#perlbot.lst[328]: * "foo" = 1;
evals/evals-freenode-#perlbot.lst[329]: *'foo' = 1;
evals/evals-freenode-#perlbot.lst[330]: $foo = 1; $bar = *foo; [ $$bar ]
evals/evals-freenode-#perlbot.lst[331]: $foo1 = $foo2 = '4 a 2'; ( $foo1 ) = $foo1 =~ /(\d+)/; $foo2 =~ s/\D+//g; [ $foo1, $foo2 ]
evals/evals-freenode-#perlbot.lst[332]: $foo = 42; $bar = *foo; [ *$bar = sub { 53 } ]
evals/evals-freenode-#perlbot.lst[333]: $foo = 42; $bar = *foo; *$bar = sub { 53 }; $$bar;
evals/evals-freenode-#perlbot.lst[334]: $foo = 42; $bar = *foo; *$bar = sub { 53 }; $bar->();
evals/evals-freenode-#perlbot.lst[335]: 'foo   ' ^. '   bar'
evals/evals-freenode-#perlbot.lst[336]: +{ foo => bar => 'ber' }
evals/evals-freenode-#perlbot.lst[337]: $foo = 'bar'; $qux = \$foo; for $$qux (1..3) { print $foo }
evals/evals-freenode-#perlbot.lst[338]: $foo = 'bar'; $qux = \*foo; for $$qux (1..3) { print $foo }
evals/evals-freenode-#perlbot.lst[339]: 'foo' =~ /(?<foo>foo)/; 'bar' =~ /(ba)/; [ $+{foo} 
evals/evals-freenode-#perlbot.lst[340]: 'foo' =~ /(?<foo>foo)/; 'bar' =~ /(ba)/; [ $+{foo} ]
evals/evals-freenode-#perlbot.lst[341]: 'foo' =~ /(?<foo>foo)/; 'bar' =~ /(ba)/; $+{foo}
evals/evals-freenode-#perlbot.lst[342]: "foo" =~ /(?<foo>foo)/; "bar" =~ /(ba)/; [ $+{foo} ]
evals/evals-freenode-#perlbot.lst[343]: 'foo' =~ /(?<foo>foo)/; $+{foo}
evals/evals-freenode-#perlbot.lst[344]: 'foo' =~ /.+/; 'foo' =~ s//bar/r;
evals/evals-freenode-#perlbot.lst[345]: Foo->meta
evals/evals-freenode-#perlbot.lst[346]: 'foo\n' =~ /foo$/m ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[347]: 'foo\n' =~ /foo$/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[348]: [ 'foo' =~ s/foo/bar/r, 'foo' =~ tr/o/x/r ]
evals/evals-freenode-#perlbot.lst[349]: * "foo"* = sub {"bar"};
evals/evals-freenode-#perlbot.lst[350]: *"foo" = sub {"bar"};
evals/evals-freenode-#perlbot.lst[351]: *"foo*" = sub {"bar"};
evals/evals-freenode-#perlbot.lst[352]: *"foo*"* = sub {"bar"};
evals/evals-freenode-#perlbot.lst[353]: 'foo' =~ /x.+/; 'foo' =~ s//bar/r;
evals/evals-freenode-#perlbot.lst[354]: for ("a".."z", " ") { say ($_ eq " " ? "SPACE" : $_) if (/(c|a)/i && /[^MCI]/i && /[ai]/i && /[^ki\sp]/i) }
evals/evals-freenode-#perlbot.lst[355]: for ("a".."z", " ") { say ($_ eq " " ? "SPACE" : $_) if (/(cat|a-t)/i && /[^MCI]/i && /[ai]/i && /[^ki\sp]/i) }
evals/evals-freenode-#perlbot.lst[356]: for ("a".."z", " ") { say if (/[a-gn-z]/i && /[^a-ru-z]/i && /[a-ks-v]/i && /[^a-di-s]/i) }
evals/evals-freenode-#perlbot.lst[357]: for ("a".."z", " ") { say if (/[a-gn-z]/i && /[d-hj-m]/i && /[^f-km-z]/i && /[^a-di-s]/i) }
evals/evals-freenode-#perlbot.lst[358]: for ("a".."z", " ") { say " " if (/(cat|a-t)/i && /[^MCI]/i && /[ai]/i && /[^ki\sp]/i) }
evals/evals-freenode-#perlbot.lst[359]: for ("a".."z", " ") { say if (/(cat|a-t)/i && /[^MCI]/i && /[ai]/i && /[^ki\sp]/i) }
evals/evals-freenode-#perlbot.lst[360]: for ("a".."z") { say if /[HELP\s]/ }
evals/evals-freenode-#perlbot.lst[361]: for ("a".."z") { say if /[HELP\s]/i }
evals/evals-freenode-#perlbot.lst[362]: for ("a".."z", " ") { say if (/[HELP\s]/i && /[\sCOPE]/i && /[^SEAP]/i) }
evals/evals-freenode-#perlbot.lst[363]: for ("a".."z") { say if (/[HELP\s]/i && /[\sCOPE]/i && /[^SEAP]/i) }
evals/evals-freenode-#perlbot.lst[364]: for ("a".."z", " ") { say "N" if (/[a-gn-z]/i && /[^a-ru-z]/i && /[a-ks-v]/i && /[^a-di-s]/i) }
evals/evals-freenode-#perlbot.lst[365]: for ("a".."z", " ") { say "N" if (/[a-gn-z]/i && /[d-hj-m]/i && /[^f-km-z]/i && /[^a-di-s]/i) }
evals/evals-freenode-#perlbot.lst[366]: for ("a".."z", " ") { say "N" if (/[HELP\s]/i && /[\sCOPE]/i && /[^SEAP]/i) }
evals/evals-freenode-#perlbot.lst[367]: for $$code (sub { print 'ok' }) { $code->() }
evals/evals-freenode-#perlbot.lst[368]: for $$code (sub { print 'ok' }) { code() }
evals/evals-freenode-#perlbot.lst[369]: for *code (sub { print 'ok' }) { code() }
evals/evals-freenode-#perlbot.lst[370]: for \$code (sub { print 'ok' }) { code() }
evals/evals-freenode-#perlbot.lst[371]: for \*code (sub { print 'ok' }) { code() }
evals/evals-freenode-#perlbot.lst[372]: for \&code (sub { print 'ok' }) { code }
evals/evals-freenode-#perlbot.lst[373]: for \&code (sub { print 'ok' }) { code() }
evals/evals-freenode-#perlbot.lst[374]: for \&code (sub { print 'ok' }) { print "[[[$asdf]]]" }
evals/evals-freenode-#perlbot.lst[375]: for $$code (sub { print 'ok' }) { print "[[[$code]]]" }
evals/evals-freenode-#perlbot.lst[376]: for $$code (sub { print 'ok' }) { print $code }
evals/evals-freenode-#perlbot.lst[377]: for $code (sub { print 'ok' }) { print "[[[$code]]]" }
evals/evals-freenode-#perlbot.lst[378]: for \&code (sub { print 'ok' }) { print "[[[$code]]]" }
evals/evals-freenode-#perlbot.lst[379]: for \&code (sub { print 'ok' }) { print code }
evals/evals-freenode-#perlbot.lst[380]: for $$code (sub { print 'ok' }) { print ref $code }
evals/evals-freenode-#perlbot.lst[381]: for $*code (sub { print 'ok' }) { print ref $code }
evals/evals-freenode-#perlbot.lst[382]: for \&code (sub { print 'ok' }) { say '[', code, ']' }
evals/evals-freenode-#perlbot.lst[383]: for \&code (sub { print 'ok' }) { say code }
evals/evals-freenode-#perlbot.lst[384]: for my ("a".."z") { say if /[HELP\s]/ }
evals/evals-freenode-#perlbot.lst[385]: for ( [qw/foo bar/]->@* ) { print}
evals/evals-freenode-#perlbot.lst[386]: for ( [qw/foo bar/]->*@ ) { print}
evals/evals-freenode-#perlbot.lst[387]: for $x (0..1) {for $y (0..1) {say $x ^ $y, " "}}
evals/evals-freenode-#perlbot.lst[388]: @f{qw/sign exponent fraction/} = (unpack "b*",(pack "d", 0.1)) =~ /^(\d)(\d{11,11})(\d+)$/; \%f
evals/evals-freenode-#perlbot.lst[389]: @f{qw/sign exponent fraction/} = unpack "b*",(pack "d", 0.1) =~ /^(\d)(\d{11,11})(\d+)$/; \%f
evals/evals-freenode-#perlbot.lst[390]:  'get http://ignorantdesigner.com/japh.html' =~ y ☻ a-z:/ ☻ n-za-m|☻r 
evals/evals-freenode-#perlbot.lst[391]:  'get http://ignorantdesigner.com/japh.html' =~ y • a-z:/ • n-za-m ☻•r 
evals/evals-freenode-#perlbot.lst[392]:  'get http://ignorantdesigner.com/japh.html' =~ y • a-z:/ • n-za-m •r 
evals/evals-freenode-#perlbot.lst[393]:  'get http://ignorantdesigner.com/japh.html' =~ y • a-z:/ • n-za-m☃ •r 
evals/evals-freenode-#perlbot.lst[394]:  'get http://ignorantdesigner.com/japh.html' =~ y☻ a-z:/ ☻ n-za-m|☻r 
evals/evals-freenode-#perlbot.lst[395]:  'get http://ignorantdesigner.com/japh.html' =~ y☻a-z:/☻n-za-m|☻r 
evals/evals-freenode-#perlbot.lst[396]:  'get http://ignorantdesigner.com/japh.html' =~ y☻a-z:/☻n-za-m.|☻r 
evals/evals-freenode-#perlbot.lst[397]:  [ 'get http://ignorantdesigner.com/japh.html' =~ y • a-z: • n-za-m •r ]
evals/evals-freenode-#perlbot.lst[398]:  [ 'get http://ignorantdesigner.com/japh.html' =~ y • a-z:/ • n-za-m☃ •r ]
evals/evals-freenode-#perlbot.lst[399]: [ 'get http://ignorantdesigner.com/japh.html' =~ y • a-z: • n-za-m • r ]
evals/evals-freenode-#perlbot.lst[400]: [ 'get http://ignorantdesigner.com/japh.html' =~ y/a-z/n-za-m/r ]
evals/evals-freenode-#perlbot.lst[401]:  'get http://ignorantdesigner.com/japh.html' =~ y☻a-z:/☻n-za-mX|☻r 
evals/evals-freenode-#perlbot.lst[402]: '.gitattributes' eq '.gitattributes'
evals/evals-freenode-#perlbot.lst[403]: [ glob '{a,b,c}' ]
evals/evals-freenode-#perlbot.lst[404]: [grep {$_ !~ /(.)\1/} glob "{a,v,p,r}{a,v,p,r}"]
evals/evals-freenode-#perlbot.lst[405]: [ grep /cc/i, keys \%INC ]
evals/evals-freenode-#perlbot.lst[406]: [ grep /CC/, keys \%INC ]
evals/evals-freenode-#perlbot.lst[407]: [ grep /cgi/i, keys \%INC ]
evals/evals-freenode-#perlbot.lst[408]: [ grep /file/i, keys \%INC ]
evals/evals-freenode-#perlbot.lst[409]: [grep {/Foo/} keys %INC]
evals/evals-freenode-#perlbot.lst[410]: grep {/Foo/} keys %INC
evals/evals-freenode-#perlbot.lst[411]: [ grep /::$/, keys %:: ]
evals/evals-freenode-#perlbot.lst[412]: [grep !/^_/, keys %main:: ]
evals/evals-freenode-#perlbot.lst[413]: [ grep { length($_) == 1 and $_ ne 0 } map - - chr, 0..255 ]
evals/evals-freenode-#perlbot.lst[414]: [ grep { length(- - $_) == 1 } map chr, 0..255 ]
evals/evals-freenode-#perlbot.lst[415]: [ grep { length(- - chr) == 1 } 0..255 ]
evals/evals-freenode-#perlbot.lst[416]: [ grep { length(- - chr) == 1 } 0..255; ]
evals/evals-freenode-#perlbot.lst[417]: [ grep m|^http://(?!.*avatar)|, qw( http://assets.tumblr.com/images/default_avatar/octahedron_open_48.png http://assets.tumblr.com/images/default_avatar/cube_closed_48.png http://40.media.tumblr.com/b3e62ef833996a4ffb544ed37300807d/tumblr_nlf8czGMpJ1s61cido1_500.jpg http://40.media.tumblr.com/c0e108161497f351e40db139289b3818/tumblr_nldblnzio71s61cido1_500.jpg ) ]
evals/evals-freenode-#perlbot.lst[418]: [ grep m|^http://(?=.*avatar)|, qw( http://default_avatar/octa  http://40.media ) ]
evals/evals-freenode-#perlbot.lst[419]: [ grep m|^http://(?!.*?avatar)|, qw( http://default_avatar/octa  http://40.media ) ]
evals/evals-freenode-#perlbot.lst[420]: [ grep m|^http://(?!.*avatar)|, qw( http://default_avatar/octa  http://40.media ) ]
evals/evals-freenode-#perlbot.lst[421]: grep { $_ ne 0 } map - - chr, 0..255
evals/evals-freenode-#perlbot.lst[422]: $h={a=>1, v=>2}; {av =>{;print 1}, ap=>, ar=>, pv=>, rv=>, pr=>sub{}}
evals/evals-freenode-#perlbot.lst[423]: $h={a=>1, v=>2}; sub calc {my %h=@_;my ($a,$v,$p,$r)=@h{qw/a v p r/};  {av =>sub {$r=$v/$a;$p=$v*$a}, ap=>sub{$v=$p/$a;$r=$v/$a}, ar=>sub{$v=$r*$a;$p=$a*$v}, pv=>sub{$a=$p/$v;$r=$v/$a}, rv=>sub{$a=$v*$r}, pr=>sub{$a=sqrt($p/$r);$v=$p/$a}}};
evals/evals-freenode-#perlbot.lst[424]: $h={a=>1, v=>2}; sub calc {my %h=@_;my ($a,$v,$p,$r)=@h{qw/a v p r/};  {av =>sub {$r=$v/$a;$p=$v*$a}, ap=>sub{$v=$p/$a;$r=$v/$a}, ar=>sub{$v=$r*$a;$p=$a*$v}, pv=>sub{$a=$p/$v;$r=$v/$a}, rv=>sub{$a=$v*$r;$p=$v*$a}, pr=>sub{$a=sqrt($p/$r);$v=$p/$a}}};
evals/evals-freenode-#perlbot.lst[425]: $h={a=>1, v=>2}; sub calc {my %h=@_;my ($a,$v,$p,$r)=@h{qw/a v p r/}; my $c=join '', sort keys %h; {av =>sub {$r=$v/$a;$p=$v*$a}, ap=>sub{$v=$p/$a;$r=$v/$a}, ar=>sub{$v=$r*$a;$p=$a*$v}, pv=>sub{$a=$p/$v;$r=$v/$a}, rv=>sub{$a=$v*$r;$p=$v*$a}, pr=>sub{$a=sqrt($p/$r);$v=$p/$a}}->{$c}->(); [$a, $v, $r, $p]}; calc %$h
evals/evals-freenode-#perlbot.lst[426]: $h={a=>1, v=>2}; sub calc {my %h=@_;my ($a,$v,$p,$r)=@h{qw/a v p r/}; my $c=sort keys %h; {av =>sub {$r=$v/$a;$p=$v*$a}, ap=>sub{$v=$p/$a;$r=$v/$a}, ar=>sub{$v=$r*$a;$p=$a*$v}, pv=>sub{$a=$p/$v;$r=$v/$a}, rv=>sub{$a=$v*$r;$p=$v*$a}, pr=>sub{$a=sqrt($p/$r);$v=$p/$a}}->{$c}->(); [$a, $v, $r, $p]}
evals/evals-freenode-#perlbot.lst[427]: $h={a=>1, v=>2}; sub calc {my %h=@_;my ($a,$v,$p,$r)=@h{qw/a v p r/}; my $c=sort keys %h; {av =>sub {$r=$v/$a;$p=$v*$a}, ap=>sub{$v=$p/$a;$r=$v/$a}, ar=>sub{$v=$r*$a;$p=$a*$v}, pv=>sub{$a=$p/$v;$r=$v/$a}, rv=>sub{$a=$v*$r;$p=$v*$a}, pr=>sub{$a=sqrt($p/$r);$v=$p/$a}}->{$c}->(); [$a, $v, $r, $p]}; calc %$h
evals/evals-freenode-#perlbot.lst[428]: %h = ( -desc => 'created_at' ); 
evals/evals-freenode-#perlbot.lst[429]: %h = ( -desc => 'created_at' ); \%h
evals/evals-freenode-#perlbot.lst[430]: hex 0x255
evals/evals-freenode-#perlbot.lst[431]: hex 0x80
evals/evals-freenode-#perlbot.lst[432]: hex 100
evals/evals-freenode-#perlbot.lst[433]: hex 255
evals/evals-freenode-#perlbot.lst[434]: "hi ".(v0.01)
evals/evals-freenode-#perlbot.lst[435]: "hi ".(v0.1)
evals/evals-freenode-#perlbot.lst[436]: $holyshit < 0
evals/evals-freenode-#perlbot.lst[437]: <- htmleval
evals/evals-freenode-#perlbot.lst[438]:  [ 'http://go2web4free.com:7004/img/users/1/1J2KAFHQk_.jpg' =~ m{[^/]+$}g ]
evals/evals-freenode-#perlbot.lst[439]:  'http://ignorantdesigner.com/japh.html' =~ y☻a-z:/☻n-za-m|☻r 
evals/evals-freenode-#perlbot.lst[440]:  'http://ignorantdesigner.com/japh.html' =~ y☻a-z:/☻n-za-m.|☻r 
evals/evals-freenode-#perlbot.lst[441]:  'http://ignorantdesigner.com/japh.html' =~ y☻a-z:/☻n-za-mX|☻r 
evals/evals-freenode-#perlbot.lst[442]: h->{two}();  sub h { +{ one => sub { 1 }, two => sub { 2 } } } 
evals/evals-freenode-#perlbot.lst[443]: h()->{two}();  sub h { +{ one => sub { 1 }, two => sub { 2 } } } 
evals/evals-freenode-#perlbot.lst[444]: huf->can("can")->()
evals/evals-freenode-#perlbot.lst[445]: huf->can("can")->can
evals/evals-freenode-#perlbot.lst[446]: huf->can("can")->("can")->("can")->("can")->("can")->("can")
evals/evals-freenode-#perlbot.lst[447]: huf->can("can")->(huf => "can")
evals/evals-freenode-#perlbot.lst[448]: huf->can("can")->(huf => "can")->(huf => "can")->(huf => "can")->(huf => "can")->(huf => "can")->(huf => "can")->(huf => "can")
evals/evals-freenode-#perlbot.lst[449]: $^I
evals/evals-freenode-#perlbot.lst[450]: if ( '0.00' ) { say "foo" }
evals/evals-freenode-#perlbot.lst[451]: if ( 0.00 ) { say "foo" }
evals/evals-freenode-#perlbot.lst[452]: if (1 ) { last; print "lols"; } print "lulz"
evals/evals-freenode-#perlbot.lst[453]: { if (1 ) { last; print "lols"; } print "lulz"; } print "lelz"; 
evals/evals-freenode-#perlbot.lst[454]: if('besaid' =~ m/(\w*said)/) {print qq{matched "$1"\n};} 
evals/evals-freenode-#perlbot.lst[455]: if ( $x = "\0" ) { print 1 }
evals/evals-freenode-#perlbot.lst[456]: if ( $x = "x\b" ) { print "_${x}_" }
evals/evals-freenode-#perlbot.lst[457]: if ( $x = "x\b" ) { print "_$x_" }
evals/evals-freenode-#perlbot.lst[458]: Im a little teapot
evals/evals-freenode-#perlbot.lst[459]: \%INC
evals/evals-freenode-#perlbot.lst[460]: [ $INC{'strict.pm'} ]
evals/evals-freenode-#perlbot.lst[461]: inf
evals/evals-freenode-#perlbot.lst[462]: +Inf
evals/evals-freenode-#perlbot.lst[463]: \%ISA;
evals/evals-freenode-#perlbot.lst[464]: is [fact htmleval [arg]]  
evals/evals-freenode-#perlbot.lst[465]: [join '']
evals/evals-freenode-#perlbot.lst[466]: join "\035", qw/freenode.net #regex re101/
evals/evals-freenode-#perlbot.lst[467]: $_ = join '', 'a'..'y'; tr<acegikmoqsuwybdfhjlnprtvx><Just another Sort hacker,>; print
evals/evals-freenode-#perlbot.lst[468]: $_ = join '', 'a'..'y'; tr<acegikmoqsuwybdfhjlnprtvx><Just another Sort hacker,>; print "[$_]"
evals/evals-freenode-#perlbot.lst[469]: $_ = join '', 'a'..'y'; tr/cbvokujpfynsewmtdxlrgqiah/Just another Sort hacker,/; print
evals/evals-freenode-#perlbot.lst[470]: [ (join '', 'a'..'y') =~ tr/sdyckamijgqbhtrfwuelnpovx/Just another :8() hacker,/r ]
evals/evals-freenode-#perlbot.lst[471]: [ (join '', 'a'..'y') =~ tr/sdyckamijgqbhtrfwuelnpovx/Just another sort hacker,/ ]
evals/evals-freenode-#perlbot.lst[472]: [ (join '', 'a'..'y') =~ tr/sdyckamijgqbhtrfwuelnpovx/Just another sort hacker,/r ]
evals/evals-freenode-#perlbot.lst[473]: $_ = join '', 'a'..'z', 0..3; tr!acegikmoqsuwy0231zxvtrpnljhfdb!Just Another Perl/BIDI Hacker,!; print
evals/evals-freenode-#perlbot.lst[474]: $_ = join '', 'a'..'z', 0..3; tr/acegikmoqsuwy0231zxvtrpnljhfdb/Just Another Perl/BIDI Hacker,/; print
evals/evals-freenode-#perlbot.lst[475]: $_ = join '', 'a'..'z'; $_ =~ tr/434dfddsaaaaa//d; $_
evals/evals-freenode-#perlbot.lst[476]: $_ = join '', 'a'..'z'; $_ =~ tr/434dfdds//d; $_
evals/evals-freenode-#perlbot.lst[477]: $_ = join('', 'a'..'z','_'); tr/bcdefghknrtuvx_zywsqpomljifa/Just another Unicode hacker/; [ $_  ]
evals/evals-freenode-#perlbot.lst[478]: $_ = join '', 'a'..'z'; $_ =~ tr/JwG7IpBbAFr4tyoVbbECZ26HYml 5QdDjLicbhUTdvWIzsnOuRTfE9ahgam2EkDqgVSXpUNGCPID KW exU7M//d; $_
evals/evals-freenode-#perlbot.lst[479]: [ join "", map +{}, 1..10 ]
evals/evals-freenode-#perlbot.lst[480]: join('_', map {lc} grep {length} split /([A-Z]{1}[^A-Z]*)/)
evals/evals-freenode-#perlbot.lst[481]: [ join '', map { pack "c", $_ } 72,101,108,108,111,32,87,111,114,108,100,-30,-104,-125,32]
evals/evals-freenode-#perlbot.lst[482]: [join '|', map ref, \*f, +{}, [], qr//,  \'', sub{}, \substr(\$x, 0, 0), \\"", \*STDOUT{FORMAT}, \*STDIN{IO}, \v5.10.0 ]
evals/evals-freenode-#perlbot.lst[483]: join '', map { ucfirst lc } 'CamelCaseXMLParser' =~ /([A-Z]+[^A-Z]*)/g;
evals/evals-freenode-#perlbot.lst[484]: join '', map { ucfirst lc } split /([A-Z]+[^A-Z]*)/, 'CamelCaseXMLParser';
evals/evals-freenode-#perlbot.lst[485]: join '', map { ucfirst lc } split /([A-Z]+[^A-Z]*)/i, 'CamelCaseXMLParser';
evals/evals-freenode-#perlbot.lst[486]: join '', map {; "\x03".int(rand 16).",".int(rand 16)."X" } 0..20;
evals/evals-freenode-#perlbot.lst[487]: [join '', sort {$|--} a..'y']
evals/evals-freenode-#perlbot.lst[488]: [join '', sort {$|--} split //, "suJta nohterP er lhakcer,"]
evals/evals-freenode-#perlbot.lst[489]: [join '', sort {$|--} split //, "sutJa nohterP er lhakcer,"]
evals/evals-freenode-#perlbot.lst[490]: [join '', sort {$|--} split //, "tuJsa nohterP er lhakcer,"]
evals/evals-freenode-#perlbot.lst[491]: [ join ":", split /../, '000202056D4C' ]
evals/evals-freenode-#perlbot.lst[492]: [ join ":", split /(?<=..)/, '000202056D4C' ]
evals/evals-freenode-#perlbot.lst[493]: [ join ":", split /(?=..)/, '000202056D4C' ]
evals/evals-freenode-#perlbot.lst[494]: [ join ":", split /(..)/, '000202056D4C' ]
evals/evals-freenode-#perlbot.lst[495]: join ":", split /../, '000202056D4C'
evals/evals-freenode-#perlbot.lst[496]: [ join ":", split /(?=\w{2])/, '000202056D4C' ]
evals/evals-freenode-#perlbot.lst[497]: [ join ":", split /(?=\w{2})/, '000202056D4C' ]
evals/evals-freenode-#perlbot.lst[498]: [join '', undef]
evals/evals-freenode-#perlbot.lst[499]: [ JSON() ]
evals/evals-freenode-#perlbot.lst[500]: \@JSON::MaybeXS::EXPORT
evals/evals-freenode-#perlbot.lst[501]: keys( {} ) = 42
evals/evals-freenode-#perlbot.lst[502]: [keys %DB:: ]
evals/evals-freenode-#perlbot.lst[503]: [ keys \%INC ]
evals/evals-freenode-#perlbot.lst[504]: [keys %main:: ]
evals/evals-freenode-#perlbot.lst[505]: 'knbZw6mW5RGbCQksNDg64g==' =~ /([\w=]{12,30})/
evals/evals-freenode-#perlbot.lst[506]: length @{[10]}
evals/evals-freenode-#perlbot.lst[507]: length 'barbarbarbarbarbar'
evals/evals-freenode-#perlbot.lst[508]: [ length 'bcdefghknrtuvx_zywsqpomljifa' ]
evals/evals-freenode-#perlbot.lst[509]: length '`eval use JSON::XS;@lt=gmtime;$m=($lt[2]*60+$lt[1])*60+$lt[0];$d=q{`fact _ipv4_json~};$h=decode_json $d;sub  sx{local$_;($t4,$d)=@_;$_=2*int($t4*128-($m*$d/675));1 while s/^(\d+)(\d{3})/$1,$2/;$_};"Estimated IPv4 Addresses left: ".join(" ",(map{(uc $_.":  ".sx($h->{$_."24s"},$h->{$_."24delta"}))." (".$h->{$_."Percent"}."%)"}qw/arin apnic afrinic ripe lacnic/))~'
evals/evals-freenode-#perlbot.lst[510]: length '`eval use JSON::XS;@lt=gmtime;$m=($lt[2]*60+$lt[1])*60+$lt[0];$d=q{`fact _ipv4_json~};$h=decode_json($d);sub  sx{local$_;($t4,$d)=@_;$_=2*int($t4*128-($m*$d/675));1 while s/^(\d+)(\d{3})/$1,$2/;$_};"Estimated IPv4 Addresses left: ".join(" ",(map{(uc $_.":  ".sx($h->{$_."24s"},$h->{$_."24delta"}))." (".$h->{$_."Percent"}."%)"} qw/arin apnic afrinic ripe lacnic/))~'
evals/evals-freenode-#perlbot.lst[511]: length '`eval use JSON::XS;@lt=gmtime;$m=($lt[2]*60+$lt[1])*60+$lt[0]; $d=q{`fact _ipv4_json~};$h=decode_json($d);sub  sx{local$_;($t4,$d)=@_;$_=int($t4*256-($m*$d*2/675));1 while s/^([-+]?\d+)(\d{3})/$1,$2/;$_};"Estimated IPv4 Addresses left: ".join(" ",(map{(uc $_.":  ".sx($h->{$_."24s"}, $h->{$_."24delta"}))." (".$h->{$_."Percent"}."%)"} qw/arin apnic afrinic ripe lacnic/))~
evals/evals-freenode-#perlbot.lst[512]: length '`eval use JSON::XS;@lt=gmtime;$m=($lt[2]*60+$lt[1])*60+$lt[0]; $d=q{`fact _ipv4_json~};$h=decode_json($d);sub  sx{local$_;($t4,$d)=@_;$_=int($t4*256-($m*$d*2/675));1 while s/^([-+]?\d+)(\d{3})/$1,$2/;$_};"Estimated IPv4 Addresses left: ".join(" ",(map{(uc $_.":  ".sx($h->{$_."24s"}, $h->{$_."24delta"}))." (".$h->{$_."Percent"}."%)"} qw/arin apnic afrinic ripe lacnic/))~'
evals/evals-freenode-#perlbot.lst[513]: length '`eval use JSON::XS;@lt=gmtime;$m=($lt[2]*60+$lt[1])*60+$lt[0]; $d=q{`fact _ipv4_json~};$h=decode_json($d);sub  sx{local$_;($t4,$d)=@_;$_=int($t4*256-($m*$d*2/675));1 while s/^(\d+)(\d{3})/$1,$2/;$_};"Estimated IPv4 Addresses left: ".join(" ",(map{(uc $_.":  ".sx($h->{$_."24s"}, $h->{$_."24delta"}))." (".$h->{$_."Percent"}."%)"} qw/arin apnic afrinic ripe lacnic/))~'
evals/evals-freenode-#perlbot.lst[514]: length $holyshit < 0
evals/evals-freenode-#perlbot.lst[515]: [length "Just Another Perl/BIDI Hacker,"];
evals/evals-freenode-#perlbot.lst[516]: [length "Just another perl hacker,"]
evals/evals-freenode-#perlbot.lst[517]: [ length "Just another Unicode hacker" ]
evals/evals-freenode-#perlbot.lst[518]: length "Just another Unicode hacker"
evals/evals-freenode-#perlbot.lst[519]: length q|	|
evals/evals-freenode-#perlbot.lst[520]: length q|"Added note that raw license copy/paste needs modification of copyright owner"|
evals/evals-freenode-#perlbot.lst[521]: length q|Croatia [Zagreb], Czechia [Brno Prague], Denmark [Aarhus Copenhagen], Equatorial Guinea [Bata Malabo], France [Lyon Marseille Nice Paris Toulouse], Gabon [Libreville Port-Gentil], Germany [Berlin Cologne Essen Frankfurt Hamburg Munich Stuttgart], Gibraltar, Hungary [Budapest Debrecen], Italy [Milan Naples Palermo Rome Turin], Liechtenstein, Luxembourg, Macedonia [Bitola Skopje], Malta [Valletta]|
evals/evals-freenode-#perlbot.lst[522]: length q|Happy New Year to Albania [Durrës Tirana], Algeria [Algiers Boumerdas Oran], Andorra, Angola [Luanda N'dalatando], Austria [Graz Vienna], Belgium [Antwerp Brussels], Benin [Abomey-Calavi Porto-Novo], Bosnia and Herzegovina [Sarajevo], Cameroon [Douala Yaoundé], Central African Republic [Bangui Bimbo], Chad [Moundou N'Djamena], Congo-Brazzaville [Brazzaville Pointe-Noire], Congo-Kinshasa [Kikwit Kinshas|
evals/evals-freenode-#perlbot.lst[523]: length q|	if ( !$ok and $@=~/^SKIP:.+BEGIN failed--compilation aborted/si ) {|
evals/evals-freenode-#perlbot.lst[524]: length q# mojobar.removeClass('animated');
evals/evals-freenode-#perlbot.lst[525]: length q# mojobar.removeClass('animated').css({'position': 'absolute', 'top': start + 'px'});#
evals/evals-freenode-#perlbot.lst[526]: length q|See C<< ->new >> method for mo|
evals/evals-freenode-#perlbot.lst[527]: $l = "foos" . chr(0x220); [ $l & chr(0x80)x(length $l) ]
evals/evals-freenode-#perlbot.lst[528]: $l = "foos" . chr(0xFA); [ $l & chr(0x80)x(length $l) ]
evals/evals-freenode-#perlbot.lst[529]: $l = "foos"; [ $l & chr(0x80)x(length $l) ]
evals/evals-freenode-#perlbot.lst[530]: $l = "fooso"; [ $l & chr(0x80)x(length $l) ]
evals/evals-freenode-#perlbot.lst[531]: \%LoadAllMooseXDeclare::
evals/evals-freenode-#perlbot.lst[532]: local $/ = 'd'; print "abc"
evals/evals-freenode-#perlbot.lst[533]: local $\ = 'd'; print "abc"
evals/evals-freenode-#perlbot.lst[534]: local $/ = $\; print "abc"
evals/evals-freenode-#perlbot.lst[535]: local $\ = $/; print "abc"
evals/evals-freenode-#perlbot.lst[536]: [[localtime], [gmtime]]
evals/evals-freenode-#perlbot.lst[537]: [ log(1e205 / 1e192)/log 10 ]
evals/evals-freenode-#perlbot.lst[538]: [ log(1e205 / 1e192)/log 2 ]
evals/evals-freenode-#perlbot.lst[539]: log(2**40)/log(10)
evals/evals-freenode-#perlbot.lst[540]: $long_var_blah = 42;  $my_pay = $long_var_b1ah * 1000; print "I'm fucking rich, I got $my_pay!";
evals/evals-freenode-#perlbot.lst[541]: @lt=localtime(time-7*3600);($two4s, $delta, $secs)=(417, 144.442, ($lt[2]*60+$lt[1])*60+$lt[0]); $secs
evals/evals-freenode-#perlbot.lst[542]: @lt=localtime(time-8*3600);($two4s, $delta, $secs)=(417, 144.442, ($lt[2]*60+$lt[1])*60+$lt[0]); $secs
evals/evals-freenode-#perlbot.lst[543]: @lt=localtime;($two4s, $delta, $secs)=(417, 144.442, ($lt[2]*60+$lt[1])*60+$lt[0]); $secs
evals/evals-freenode-#perlbot.lst[544]: [ main:: ]
evals/evals-freenode-#perlbot.lst[545]: *main::bless = sub { print "foo" }; bless {}, 'Foo';
evals/evals-freenode-#perlbot.lst[546]: main->foo
evals/evals-freenode-#perlbot.lst[547]: main->foo;
evals/evals-freenode-#perlbot.lst[548]: [ *main::{JSON} ]
evals/evals-freenode-#perlbot.lst[549]: *main::{JSON}
evals/evals-freenode-#perlbot.lst[550]: [ *main::JSON{CODE} ]
evals/evals-freenode-#perlbot.lst[551]: [ map [ $_+0, $_ ], Scalar::util::dualvar 6*9, '42 (base 13)' ]
evals/evals-freenode-#perlbot.lst[552]: [ map [ $_+0, $_ ], Scalar::Util::dualvar 6*9, '42 (base 13)' ]
evals/evals-freenode-#perlbot.lst[553]: [map +(1x$_), 3..541]
evals/evals-freenode-#perlbot.lst[554]: [map --$| ? *{$_}{ARRAY} : $_, %DB:: ]
evals/evals-freenode-#perlbot.lst[555]: [map chr, 72,101,108,108,111,32,87,111,114,108,100,226,152,131,32]
evals/evals-freenode-#perlbot.lst[556]: [map --$| ? *{$_}{CODE} : $_, %DB:: ]
evals/evals-freenode-#perlbot.lst[557]: [map --$| ? $_ : $$_, %DB:: ]
evals/evals-freenode-#perlbot.lst[558]: [map --$| ? $$_ : $_, %DB:: ]
evals/evals-freenode-#perlbot.lst[559]: [map --$| ? \%$_ : $_, %DB:: ]
evals/evals-freenode-#perlbot.lst[560]: [map { - - $_ } map chr, 0..255]
evals/evals-freenode-#perlbot.lst[561]: [map { - - $_ }, map chr, 0..255]
evals/evals-freenode-#perlbot.lst[562]: [ map ord,  'b' => 'n', 'j' => 'u', 'v' => 'g' ]
evals/evals-freenode-#perlbot.lst[563]: [ map ord, split //, '                                                     ' ]
evals/evals-freenode-#perlbot.lst[564]: map ord, split //, '                                                     
evals/evals-freenode-#perlbot.lst[565]: map ord, split //, '                                                     '
evals/evals-freenode-#perlbot.lst[566]: [map ord, split //, "Hello World☃ "]
evals/evals-freenode-#perlbot.lst[567]: [map { pack "c", $_ } 72,101,108,108,111,32,87,111,114,108,100,-30,-104,-125,32]
evals/evals-freenode-#perlbot.lst[568]: [map pack "c", 72,101,108,108,111,32,87,111,114,108,100,-30,-104,-125,32]
evals/evals-freenode-#perlbot.lst[569]: [map {rand * 10} 1..10]
evals/evals-freenode-#perlbot.lst[570]: [map {rand() * 10} 1..10]
evals/evals-freenode-#perlbot.lst[571]: [ map ref, \1, [], {}, sub{}, qr//,  ]
evals/evals-freenode-#perlbot.lst[572]: [ map ref, \1, [], {}, sub{}, qr//, \*CORE::substr ]
evals/evals-freenode-#perlbot.lst[573]: [ map ref, \1, [], {}, sub{}, qr//, \&CORE::substr ]
evals/evals-freenode-#perlbot.lst[574]: [ map ref, \1, [], {}, sub{}, qr//, \CORE::substr ]
evals/evals-freenode-#perlbot.lst[575]: [ map ref, \1, [], {}, sub{}, qr//, &CORE::substr ]
evals/evals-freenode-#perlbot.lst[576]: [ map ref, \1, [], {}, sub{}, qr//, \(pos) ]
evals/evals-freenode-#perlbot.lst[577]: [ map ref, \1, [], {}, sub{}, qr//, \(pos),  ]
evals/evals-freenode-#perlbot.lst[578]: [ map ref, \1, [], {}, sub{}, qr//, \pos,  ]
evals/evals-freenode-#perlbot.lst[579]: [ map ref, \1, [], {}, sub{}, qr//, \pos, \v1.2  ]
evals/evals-freenode-#perlbot.lst[580]: [ map ref, \1, [], {}, sub{}, qr//, sub :lvalue{} ]
evals/evals-freenode-#perlbot.lst[581]: [ map ref, \1, [], {}, sub{}, qr//, \&substr ]
evals/evals-freenode-#perlbot.lst[582]: [ map ref, \1, [], {}, sub{}, qr//, \substr ]
evals/evals-freenode-#perlbot.lst[583]: [ map ref, \1, [], {}, sub{}, qr//, substr ]
evals/evals-freenode-#perlbot.lst[584]: [ map ref, \1, [], {}, sub{}, qr//, substr() ]
evals/evals-freenode-#perlbot.lst[585]: [ map ref, \1, [], {}, sub{}, qr//, substr($_) ]
evals/evals-freenode-#perlbot.lst[586]: [ map ref, \1, [], {}, sub{}, qr//, \(substr($_,1) ]
evals/evals-freenode-#perlbot.lst[587]: [ map ref, \1, [], {}, sub{}, qr//, \(substr($_,1)) ]
evals/evals-freenode-#perlbot.lst[588]: [ map ref, \1, [], {}, sub{}, qr//, substr($_, 1) ]
evals/evals-freenode-#perlbot.lst[589]: [ map ref, \1, [], {}, sub{}, qr//, \(substr($_,1,1) ]
evals/evals-freenode-#perlbot.lst[590]: [ map ref, \1, [], {}, sub{}, qr//, substr($_, 1)=1 ]
evals/evals-freenode-#perlbot.lst[591]: [map ref, \*f, +{}, [], qr//,  \'',  ]
evals/evals-freenode-#perlbot.lst[592]: [map ref, \*f, +{}, [], qr//,  \'', sub{}, \\"" ]
evals/evals-freenode-#perlbot.lst[593]: [map ref, \*f, +{}, [], qr//,  \'', sub{}, sub:lvalue{}, ]
evals/evals-freenode-#perlbot.lst[594]: [map ref, \*f, +{}, [], qr//,  \'', sub{}, substr ''  ]
evals/evals-freenode-#perlbot.lst[595]: [map ref, \*f, +{}, [], qr//,  \'', sub{}, substr(), ]
evals/evals-freenode-#perlbot.lst[596]: [map ref, \*f, +{}, [], qr//,  \'', sub{}, substr(),\  ]
evals/evals-freenode-#perlbot.lst[597]: [map ref, \*f, +{}, [], qr//,  \'', sub{}, substr(),\ ]
evals/evals-freenode-#perlbot.lst[598]: [map ref, \*f, +{}, [], qr//,  \'', sub{}, substr(\$x, "", "", ""), ]
evals/evals-freenode-#perlbot.lst[599]: [map ref, \*f, +{}, [], qr//,  \'', sub{}, \substr(\$x, 0, 0), ]
evals/evals-freenode-#perlbot.lst[600]: [map ref, \*f, +{}, [], qr//,  \'', sub{}, \substr(\$x, 0, 0), \\"" ]
evals/evals-freenode-#perlbot.lst[601]: [map ref, \*f, +{}, [], qr//,  \'', sub{}, substr(\$x, 0, 0), ]
evals/evals-freenode-#perlbot.lst[602]: [map ref, \*f, +{}, [], qr//,  \'', sub{}, substr(\$x, 0, 0, 0, 0), ]
evals/evals-freenode-#perlbot.lst[603]: [map ref, \*f, +{}, [], qr//,  \'', sub{}, (substr(\$x, 0, 0, 0) = "foo"), ]
evals/evals-freenode-#perlbot.lst[604]: [map ref, \*f, +{}, [], qr//,  \'', sub{}, substr(\$x, 0, 0, 0) = "foo", ]
evals/evals-freenode-#perlbot.lst[605]: [map ref, \*f, +{}, [], qr//,  \'', sub{}, (substr(\$x, 0, 0) = "foo"), ]
evals/evals-freenode-#perlbot.lst[606]: [map ref, \*f, +{}, [], qr//,  \'', sub{}, \substr(\$x, 0, 0), \\"", *STDOUT{FORMAT} ]
evals/evals-freenode-#perlbot.lst[607]: [map ref, \*f, +{}, [], qr//,  \'', sub{}, \substr(\$x, 0, 0), \\"", *STDOUT{FORMAT}, *STDIN{IO} ]
evals/evals-freenode-#perlbot.lst[608]: [map ref, \*f, +{}, [], qr//,  \'', sub{}, \substr(\$x, 0, 0), \\"", \*STDOUT{FORMAT}, \*STDIN{IO}, \v5.10.0 ]
evals/evals-freenode-#perlbot.lst[609]: [map +ref, \*, {}, [], qr//,  \'',  ]
evals/evals-freenode-#perlbot.lst[610]: [map ref, \*, {}, [], qr//,  \'',  ]
evals/evals-freenode-#perlbot.lst[611]: [map ref, \*, +{}, [], qr//,  \'',  ]
evals/evals-freenode-#perlbot.lst[612]: [ map {scalar caller $_} -1 .. 4 ]
evals/evals-freenode-#perlbot.lst[613]: [map ~$_, sort map ~$_, 'a'..'z']
evals/evals-freenode-#perlbot.lst[614]: [map { sprintf '%0.0f', $_ } -2.5, -1.5, -0.5, 0.5, 1.5, 2.5]
evals/evals-freenode-#perlbot.lst[615]: [map { sprintf '%0f', $_ } -2.5, -1.5, -0.5, 0.5, 1.5, 2.5]
evals/evals-freenode-#perlbot.lst[616]: [ map sprintf('%.f', $_), 6.5, 7.5, 8.5, 11.5 ]
evals/evals-freenode-#perlbot.lst[617]: [ map sprintf('%.f', $_), 6.5, 7.5, 8.5, 9.5 ]
evals/evals-freenode-#perlbot.lst[618]: [ map sprintf('%.f', $_), 8.5, 11.5 ]
evals/evals-freenode-#perlbot.lst[619]: [ map //'undef', 1, '', undef, 42 ]
evals/evals-freenode-#perlbot.lst[620]: [ map $_//'undef', 1, '', undef, 42 ]
evals/evals-freenode-#perlbot.lst[621]: [map $$_, values %DB:: ]
evals/evals-freenode-#perlbot.lst[622]: methname {'main'} 1;
evals/evals-freenode-#perlbot.lst[623]: methname {main} 1;
evals/evals-freenode-#perlbot.lst[624]:  $    money   +    $    money   ==    $ $money
evals/evals-freenode-#perlbot.lst[625]:  $    money   +    $    money   ==    $ $    money
evals/evals-freenode-#perlbot.lst[626]:  $    money   +    $    money   ==    $$money
evals/evals-freenode-#perlbot.lst[627]: my @a = 1..10; [ $a[-20], \@a ]
evals/evals-freenode-#perlbot.lst[628]: my @a = 1..10; [ $a[20%$#a], \@a ]
evals/evals-freenode-#perlbot.lst[629]: my @a = 1..10; [ delete $a[-20], \@a ]
evals/evals-freenode-#perlbot.lst[630]: my @a = 1..10; [ delete $a[20], \@a ]
evals/evals-freenode-#perlbot.lst[631]: my @a = 1..10; [ delete $a[20%$#a], \@a ]
evals/evals-freenode-#perlbot.lst[632]: my @a = 1..3; 
evals/evals-freenode-#perlbot.lst[633]: my @a = 1..3; \@a
evals/evals-freenode-#perlbot.lst[634]: my @a = 1..3; each @a; \@a
evals/evals-freenode-#perlbot.lst[635]: my @a = 1..4; [ @a == grep $_ =~ /42/, @a ]
evals/evals-freenode-#perlbot.lst[636]: my @a = 1..4; [ @a == grep $_ =~ /4/, @a ]
evals/evals-freenode-#perlbot.lst[637]: my @a = 1..4; [ @a == grep $_, @a ]
evals/evals-freenode-#perlbot.lst[638]: my @a = 1..4; my %h1 = map +( $_ => $_+1 ), @a[0..@a/2]; my %h2 = map +( $_ => $_+1 ), @a[@a/2-1..$#a]; [ \%h1, \%h2 ]
evals/evals-freenode-#perlbot.lst[639]: my @a = 1..4; my %h1 = map +( $_ => $_+1 ), splice @a, 0, @a/2; my %h2 = map +( $_ => $_+1 ), splice @a, @a/2-1; [ \%h1, \%h2 ]
evals/evals-freenode-#perlbot.lst[640]: my @a = 1..4; my %h1 = map +( $_ => $_+1 ), splice @a, 0, @a/2; my %h2 = map +( $_ => $_+1 ), splice @a, @a/2; [ \%h1, \%h2 ]
evals/evals-freenode-#perlbot.lst[641]: my @a = 1..5; (shift @a)x3; \@a
evals/evals-freenode-#perlbot.lst[642]: my @a = 1..5; (shift @a)x5; \@a
evals/evals-freenode-#perlbot.lst[643]: my @a = 'a'..'c'; for( @a ) { print $_; push @a, 'x' if rand > .5 }; \@a;
evals/evals-freenode-#perlbot.lst[644]: my @a = 'a'..'c'; for( @a ) { push @a, 'x' if rand > .5 }; \@a;
evals/evals-freenode-#perlbot.lst[645]: my $a = 'a'; my $b = \$a; for $$b (0..5) { print $a }
evals/evals-freenode-#perlbot.lst[646]: my (  @a, @b ) = 1..10; $_%2 and push @b, delete $a[$_
evals/evals-freenode-#perlbot.lst[647]: my ($a, $b, (undef) x 3, $c) = (1..10); [$a, $b, $c]
evals/evals-freenode-#perlbot.lst[648]: my $a = {foo => 1}; sub foo {my $b={%{shift()}}; delete $b->{foo}}; foo($a); $a
evals/evals-freenode-#perlbot.lst[649]: my $a = {foo => 1}; sub foo {my $b=\%{shift()}; delete $b->{foo}}; foo($a); $a
evals/evals-freenode-#perlbot.lst[650]: my @a = (grep /2/, 1..4 )[0..5];
evals/evals-freenode-#perlbot.lst[651]: my @a = (grep /2/, 1..4 )[0..5]; splice @a, 2; \@a
evals/evals-freenode-#perlbot.lst[652]: my @a = (grep /2/, 1..4 )[0..5]; splice @a, 4; \@a
evals/evals-freenode-#perlbot.lst[653]: [ ++(my $a = "l"), ++(my $b = "1") ]
evals/evals-freenode-#perlbot.lst[654]: my @a; { local push @a, 1 }; \@a;
evals/evals-freenode-#perlbot.lst[655]: my $a; print;
evals/evals-freenode-#perlbot.lst[656]: my @a; { push (local @a), 42 }; \@a;
evals/evals-freenode-#perlbot.lst[657]: my @a = qw/one two/; [ $a['forty two'] ];
evals/evals-freenode-#perlbot.lst[658]: my $_ = 'asdf "foo"'; my $h = 0x20000; my %h; s/((["'])(?:[^"']+|\\.|(?!\2).)*\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split ' '; $h = chr($h-1); s/([\x{20000}-$h])/$h{$1}/g for @words; \@words;
evals/evals-freenode-#perlbot.lst[659]: my $_ = 'asdf "foo"'; my $h = 0x20000; my %h; s/((["'])(?:[^"']+|\\.|(?!\2).)*\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split ' ', $str; $h = chr($h-1); s/([\x{20000}-$h])/$h{$1}/g for @words; \@words;
evals/evals-freenode-#perlbot.lst[660]: my $_ = 'asdf "foo"'; my $h = 0x20000; my %h; $str =~ s/((["'])(?:[^"']+|\\.|(?!\2).)*\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split ' ', $str; $h = chr($h-1); s/([\x{20000}-$h])/$h{$1}/g for @words; \@words;
evals/evals-freenode-#perlbot.lst[661]: my $a = sub { say "Hello World" }; my $b = $a; $a
evals/evals-freenode-#perlbot.lst[662]: my $a = sub { say "Hello World" }; my $b = $a; $a->();
evals/evals-freenode-#perlbot.lst[663]: my $a = sub { say "Hello World" }; my $b = $a; \*$a
evals/evals-freenode-#perlbot.lst[664]: my $a = sub { say "Hello World" }; my $b = $a; \&$a
evals/evals-freenode-#perlbot.lst[665]: my $a = sub { say "Hello World" }; my $b = $a; &$a
evals/evals-freenode-#perlbot.lst[666]: my $a = sub { say "Hello World" }; my $b = $a; *$a = \(sub {say "Goodbye Mars"});
evals/evals-freenode-#perlbot.lst[667]: my $a = sub { say "Hello World" }; my $b = $a; &$a = \(sub {say "Goodbye Mars"});
evals/evals-freenode-#perlbot.lst[668]: my $a = sub { say "Hello World" }; my $b = $a; &$a = \&{sub {say "Goodbye Mars"}};
evals/evals-freenode-#perlbot.lst[669]: my $a = sub { say "Hello World" }; my $b = $a; &$a = &{sub {say "Goodbye Mars"}};
evals/evals-freenode-#perlbot.lst[670]: my $a = sub { say "Hello World" }; my $b = $a; \(sub {say "Goodbye Mars"});
evals/evals-freenode-#perlbot.lst[671]: my $bar = 42; my @foo = (12, 24, 42); say grep($_ eq $bar, @foo) ? 42 : 52;
evals/evals-freenode-#perlbot.lst[672]: my $bar = 42; my @foo = (12, 24); say grep($_ eq $bar, @foo) ? 42 : 52;
evals/evals-freenode-#perlbot.lst[673]: my $c = \&CORE::pop; my @abc = qw,a b c,; [$c->(\@abc)]
evals/evals-freenode-#perlbot.lst[674]: my @chars = '$#**\01000' =~/(.)+?([01]+)$/; \@chars
evals/evals-freenode-#perlbot.lst[675]: my $dist = { author => [qw/foo bar/] }; my %z = ( author_id => $dist->{author} // (ref $dist->{authors} ? $dist->{authors}[0] : $dist->{authors}) // 'N/A', url => 'N/A',); \%h
evals/evals-freenode-#perlbot.lst[676]: my $dist = { author => [qw/foo bar/] }; my %z = ( author_id => $dist->{author} // (ref $dist->{authors} ? $dist->{authors}[0] : $dist->{authors}) // 'N/A', url => 'N/A'); \%z
evals/evals-freenode-#perlbot.lst[677]: my $foo = 'BAR!'; BEGIN { say $foo }
evals/evals-freenode-#perlbot.lst[678]: my $foo = 'BAR!'; BEGIN say { $foo }
evals/evals-freenode-#perlbot.lst[679]: my $foo = 'bar' =~ /ber/; [ $foo ]
evals/evals-freenode-#perlbot.lst[680]: my $foo = 'bar'; -$foo
evals/evals-freenode-#perlbot.lst[681]: my $foo = 'bar'; $foo = -$foo for 1, 2; $foo
evals/evals-freenode-#perlbot.lst[682]: my $foo = '-'; $foo = -$foo for 1, 2; $foo
evals/evals-freenode-#perlbot.lst[683]: my $foo = ''; $foo = -$foo for 1, 2; $foo
evals/evals-freenode-#perlbot.lst[684]: my $foo = grep $_, 1..5, 'a', 'b'; $foo;
evals/evals-freenode-#perlbot.lst[685]: my $foo = grep $_, 1..5; $foo;
evals/evals-freenode-#perlbot.lst[686]: my ($foo) if 0;
evals/evals-freenode-#perlbot.lst[687]: my foo $x = 3; [ $x ]
evals/evals-freenode-#perlbot.lst[688]: my foo:: $x = 3; [ $x ]
evals/evals-freenode-#perlbot.lst[689]: my $h = {1..4};  [$h->@{1, 3}]
evals/evals-freenode-#perlbot.lst[690]: my $hash = {ref => [1, 2, 3]}; while(my $num = $hash->{ref}->"CORE::each") {print $num, " => ";}
evals/evals-freenode-#perlbot.lst[691]: my $hash = {ref => [1, 2, 3]}; while(my $num = $hash->{ref}->&CORE::each) {print $num, " => ";}
evals/evals-freenode-#perlbot.lst[692]: my %hash = ( "أ" => 1, )
evals/evals-freenode-#perlbot.lst[693]: my %hash = ( "أ" => 1", )
evals/evals-freenode-#perlbot.lst[694]: my %hash = ( "أ" => 1"", )
evals/evals-freenode-#perlbot.lst[695]: my %h = (a..z); ${%h}{"how strange"} = "is this, anyway?"; \%{%h};
evals/evals-freenode-#perlbot.lst[696]: my @heterological_scalar; my %autological_hash;
evals/evals-freenode-#perlbot.lst[697]: my %h = ( foo => { bar => {ber => [boor] } } } ); my $ar = $h{foo}{bar}{ber}; push @$ar, 'foor';  
evals/evals-freenode-#perlbot.lst[698]: my %h = ( foo => { bar => {ber => [boor] } } ); my $ar = $h{foo}{bar}{ber}; push @$ar, 'foor';  \%h
evals/evals-freenode-#perlbot.lst[699]: my %h = ( foo => { bar => {ber => [boor] } } } ); my $ar = $h{foo}{bar}{ber}; push @$ar, 'foor';  \%h
evals/evals-freenode-#perlbot.lst[700]: my ($home) = "git://github.com/labster/p6-IO-Path-More.git" =~ m[(?:git|https?)://([\w\.]+)/]; $home
evals/evals-freenode-#perlbot.lst[701]: my ($home) = "git://github.com/labster/p6-IO-Path-More.git" =~ m[(?:git|https?)://([\w\.]+)/]; my ($auth, $repo_name) = $url =~ m[(?:git|https?)://$home/([^/]+)/([^/]+)\.git];
evals/evals-freenode-#perlbot.lst[702]: my ($home) = "http://github.com/labster/p6-IO-Path-More/" =~ m[(?:git|https?)://([\w\.]+)/]; $home
evals/evals-freenode-#perlbot.lst[703]: my %h=qw/q 1 d 2 b 3/; [@h{qw/q d b/}]
evals/evals-freenode-#perlbot.lst[704]: my $hyphenated = 'foo-bar'; *$hyphenated = sub { 'works' }; main->$hyphenated();
evals/evals-freenode-#perlbot.lst[705]: my $i = 0; ++$i until charnames::viacode($i) =~ /music|note/i; chr $i;
evals/evals-freenode-#perlbot.lst[706]: my $i = 0; my $n; ++$i until ($n=charnames::viacode($i)) =~ /music|\bnote/i; [ chr $i, $n ]
evals/evals-freenode-#perlbot.lst[707]: my $i = 0; my $n; ++$i until ($n=charnames::viacode($i)) =~ /music|note/i; [ chr $i, $n ]
evals/evals-freenode-#perlbot.lst[708]: my $j = 'Foo'; $j =~ tr/\x20-\x7f/\xff00-\xff5f/; binmode STDOUT; print $j;
evals/evals-freenode-#perlbot.lst[709]: my $j = 'Foo'; $j =~ tr/\x20-\x7f/\xff0x-\xff5f/; binmode STDOUT; print $j;
evals/evals-freenode-#perlbot.lst[710]: my $j = 'Foo'; $j =~ tr/\x20-\x7f/\xff10-\xff5f/; binmode STDOUT; print $j;
evals/evals-freenode-#perlbot.lst[711]: my $j = 'Foo'; $j =~ tr/\x20-\x7f/\xff20-\xff5f/; binmode STDOUT; print $j;
evals/evals-freenode-#perlbot.lst[712]: my $j = 'Foo'; $j =~ tr/\x20-\xff/\xff10-\xff5f/; binmode STDOUT; print $j;
evals/evals-freenode-#perlbot.lst[713]: my $j = 'Foo'; $j =~ tr/\x20-\xff/\xff10-\xffff/; binmode STDOUT; print $j;
evals/evals-freenode-#perlbot.lst[714]: my $j = 'Just another Perl/Unicode Hacker,'; $j =~ tr/\x00-\xff/\xff00-\xffff/; binmode STDOUT;  $j;
evals/evals-freenode-#perlbot.lst[715]: my $j = 'Just another Perl/Unicode Hacker,'; $j =~ tr/\x00-\xff/\xff00-\xffff/; binmode STDOUT; print $j;
evals/evals-freenode-#perlbot.lst[716]: my $j = 'Just another Perl/Unicode Hacker,'; $j =~ tr/\x00-\xff/\xff00-\xffff/; $j;
evals/evals-freenode-#perlbot.lst[717]: my $j = 'Just another Perl/Unicode Hacker,'; $j =~ tr/\x20-\x7f/\xff00-\xff5f/; binmode STDOUT; print $j;
evals/evals-freenode-#perlbot.lst[718]: my $l = 0; [ 0 << 2 ]
evals/evals-freenode-#perlbot.lst[719]: my $l = 0; [ 1 << 1 ]
evals/evals-freenode-#perlbot.lst[720]: my $l = 0; [ 1 << 2 ]
evals/evals-freenode-#perlbot.lst[721]: my $l = 0; [ 1 << 2  << 2]
evals/evals-freenode-#perlbot.lst[722]: my $l = 0; [ 2 << 1 ]
evals/evals-freenode-#perlbot.lst[723]: my $l = 0; [ 3 << 1 ]
evals/evals-freenode-#perlbot.lst[724]: my $l = 0; [ 3 << 2 ]
evals/evals-freenode-#perlbot.lst[725]: my $l = 0; [ sprintf('b', 3), sprintf('b', 3 << 1) ]
evals/evals-freenode-#perlbot.lst[726]: my $lambda = sub { shift @_+1 }; @a=1..4; [{map{$_=>$lambda->($_)}@a[0..@a/2-1]},{map{$_=>$lambda->($_)}@a[@a/2..$#a]}]
evals/evals-freenode-#perlbot.lst[727]: my $lambda = sub { shift()+1 }; @a=1..4; [{map{$_=>$lambda->($_)}@a[0..@a/2-1]},{map{$_=>$lambda->($_)}@a[@a/2..$#a]}]
evals/evals-freenode-#perlbot.lst[728]: my $lambda = sub { shift+1 }; @a=1..4; [{map{$_=>$lambda->($_)}@a[0..@a/2-1]},{map{$_=>$lambda->($_)}@a[@a/2..$#a]}]
evals/evals-freenode-#perlbot.lst[729]: my main $x = 3; [ $x ]
evals/evals-freenode-#perlbot.lst[730]: my $n = 3; my $str = q(|1|2a|3abc|4abcd|5abcde); [join q(|), (split /\|/, $str)[0..$n]];
evals/evals-freenode-#perlbot.lst[731]: {my $print = \&CORE::GLOBAL::print; *CORE::GLOBAL::print = sub { $print->("wut wut: ", @_)}}; CORE::GLOBAL::print "foo"
evals/evals-freenode-#perlbot.lst[732]: {my $print = \&CORE::GLOBAL::print; *CORE::GLOBAL::print = sub { $print->("wut wut: ", @_)}}; CORE::print "foo"
evals/evals-freenode-#perlbot.lst[733]: {my $print = \&CORE::GLOBAL::print; *CORE::GLOBAL::print = sub { $print->("wut wut: ", @_)}}; print "foo"
evals/evals-freenode-#perlbot.lst[734]: my $print = \&CORE::GLOBAL::print; sub myprint {$print->("I don't wanna");}; *CORE::GLOBAL::print = &myprint; print "foo"
evals/evals-freenode-#perlbot.lst[735]: {my $print = \&CORE::print; *CORE::GLOBAL::print = sub { $print->("wut wut: ", @_)}}; print "foo"
evals/evals-freenode-#perlbot.lst[736]: {my $print = \&CORE::print; \*CORE::GLOBAL::print = sub { $print->("wut wut: ", @_)}}; print "foo"
evals/evals-freenode-#perlbot.lst[737]: my $print = \*CORE::print; sub myprint {$print->("I don't wanna");}; *CORE::GLOBAL::print = &myprint; print "foo"
evals/evals-freenode-#perlbot.lst[738]: my $print = \&CORE::print; sub myprint {$print->("I don't wanna");}; *CORE::GLOBAL::print = &myprint; print "foo"
evals/evals-freenode-#perlbot.lst[739]: {my $print = \&CORE::print; sub print { $print->("wut wut: ", @_)}}; print "foo"
evals/evals-freenode-#perlbot.lst[740]: {my $print = \&CORE::print; sub print { $print->("wut wut: ", @_}}; print "foo"
evals/evals-freenode-#perlbot.lst[741]: my $_ = q,asdf "foo"='bar baz',; my $h = 0x20000; my %h; s/((["'])(?:[^"']+|\\.|(?!\2).)*\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split ' '; $h = chr($h-1); s/([\x{20000}-$h])/$h{$1}/g for @words; \@words;
evals/evals-freenode-#perlbot.lst[742]: my $rule = qr/!!(.+?)!!/; my $s = "Foo bar !!meow!! lulz  !!mooo!!"; my @s; { my @bits = split /$rule/, $s, 2; push @s, @bits == 1 ? { t => $bits[0] } : ( { t => $bits[0]}, { t => $bits[1], shiny => 1 }, { t => $bits[2] } );  last if @bits == 1; $s =~ s/$rule//; } \@s
evals/evals-freenode-#perlbot.lst[743]: my $rule = qr/!!(.+?)!!/; my $s = "Foo bar !!meow!! lulz  !!mooo!!"; my @s; { my @bits = split /$rule/, $s, 2; push @s, @bits == 1 ? { t => $bits[0] } : ( { t => $bits[0]}, { t => $bits[1], shiny => 1 }, { t => $bits[2] } );  redo unless @bits == 1} \@s
evals/evals-freenode-#perlbot.lst[744]: my $rule = qr/!!(.+?)!!/; my $s = "Foo bar !!meow!! lulz  !!mooo!!"; my @s; { my @bits = split /$rule/, $s, 2; push @s, @bits == 1 ? { t => $bits[0] } : ( { t => $bits[0]}, { t => $bits[1], shiny => 1 }, { t => $bits[2] } ); } \@s
evals/evals-freenode-#perlbot.lst[745]: my $rule = qr/!!(.+?)!!/; my $s = "Foo bar !!meow!! lulz  !!mooo!!"; my @s; { my @bits = split /$rule/, $s, 2; push @s, @bits == 1 ? { t => $bits[0] } : ( { t => $bits[0]}, { t => $bits[1] }, { t => $bits[2] } ); } \@s
evals/evals-freenode-#perlbot.lst[746]: my $rule = qr/!!(.+?)!!/; my $s = "Foo bar !!meow!! lulz  !!mooo!!"; my @s; { my @bits = split /$rule/, $s, 2; push @s, @bits == 1 ? { t => $bits[0] } : ( { t => $bits[0]}, { t => $bits[1] }, { t => $bits[2] } ); \@s
evals/evals-freenode-#perlbot.lst[747]: my $rule = qr/!!(.?)!!/; my $s = "Foo bar !!meow!! lulz  !!mooo!!"; [  split /$rule/, $s ]
evals/evals-freenode-#perlbot.lst[748]: my $rule = qr/!!(.?)!!/; my $s = "Foo bar !!meow!! lulz  !!mooo!!"; [  split $rule, $s ]
evals/evals-freenode-#perlbot.lst[749]: my $rule = qr/!!(.+?)!!/; my $s = "Foo bar !!meow!! lulz  !!mooo!!"; [  split /$rule/, $s ]
evals/evals-freenode-#perlbot.lst[750]: my $rule = qr/!!(.+?)!!/; my $s = "Foo bar !!meow!! lulz  !!mooo!!"; [  split /$rule/, $s, 1 ]
evals/evals-freenode-#perlbot.lst[751]: my $rule = qr/!!(.+?)!!/; my $s = "Foo bar !!meow!! lulz  !!mooo!!"; [  split /$rule/, $s, 2 ]
evals/evals-freenode-#perlbot.lst[752]: my %seen; $seen{foo}; $seen{bar}; \%seen
evals/evals-freenode-#perlbot.lst[753]: my %seen; $seen{''} //= keys(%seen); print $seen{''}."\n";
evals/evals-freenode-#perlbot.lst[754]: my %seen; $test="one"; $seen{$test} //= [keys(%seen)]; \%seen
evals/evals-freenode-#perlbot.lst[755]: my $self; $self->{messages} = [1,2,3]; $self->{messages}->[0] = "a"; $self->{messages}
evals/evals-freenode-#perlbot.lst[756]: my $stash = %main:: ; *{$main->{foo}} = sub { 'bar' };
evals/evals-freenode-#perlbot.lst[757]: my $stash = %main:: ; *{$main}{foo} = sub { 'bar' };
evals/evals-freenode-#perlbot.lst[758]: my $stash = \%main:: ; sub foo { 42 }; [ $main->{foo} ]
evals/evals-freenode-#perlbot.lst[759]: my $stash = %main:: ; sub foo { 42 };  $main->{foo}
evals/evals-freenode-#perlbot.lst[760]: my $stash = %main:: ; sub foo { 42 }; [ $main->{foo} ]
evals/evals-freenode-#perlbot.lst[761]: my $stash = %main:: ; sub foo { 42 };  *{$main->{foo}} = sub { 'bar' };
evals/evals-freenode-#perlbot.lst[762]: my $stash = \%{ __PACKAGE__ . "::" } ; sub foo { 42 }; [ $main->{foo} ]
evals/evals-freenode-#perlbot.lst[763]: my $stash = \%{ __PACKAGE__ . "::" } ; sub foo { 42 }; [ $stash->{foo} ]
evals/evals-freenode-#perlbot.lst[764]: my sub stat;
evals/evals-freenode-#perlbot.lst[765]: my sub stat { 1.3 }; [ stat ]
evals/evals-freenode-#perlbot.lst[766]: my $t = 'ＹＯＵ  ＨＡＶＥ'; binmode STDOUT;  $t;
evals/evals-freenode-#perlbot.lst[767]: my @tmp; $tmp[3] = "gi|300707803|ref|XP_002996096.1|hypothetical protein NCER_100860 [Nosema ceranae BRL01] >gi|239605364|gb|EEQ82425.1| hypothetical protein NCER_100860 [Nosema ceranae BRL01]"; my($ia,$ib) = split(/\[/,$tmp[3]); [ $ia, $ib]
evals/evals-freenode-#perlbot.lst[768]: my $t = 'ＹＯＵ  ＨＡＶＥ'; $t;
evals/evals-freenode-#perlbot.lst[769]: my $u = 'ABC'; say $u =~ /./pos $u/ger;
evals/evals-freenode-#perlbot.lst[770]: my $u = 'ABC'; say $u =~ s/./pos $u/ger;
evals/evals-freenode-#perlbot.lst[771]: my $url = "http://github.com/labster/p6-IO-Path-More/"; my ($auth, $repo_name) = $url =~ m[(?:git|https?)://$home/([^/]+)/([^/]+)\.git]; [ $auth, $repo_name ]
evals/evals-freenode-#perlbot.lst[772]: my $url = "http://github.com/labster/p6-IO-Path-More/"; my ($home) = $url =~ m[(?:git|https?)://([\w\.]+)/]; my ($auth, $repo_name) = $url =~ m[(?:git|https?)://$home/([^/]+)/([^/]+)\.git]; [ $auth, $repo_name ]
evals/evals-freenode-#perlbot.lst[773]: my $url = "http://github.com/labster/p6-IO-Path-More/"; my ($home) = $url =~ m[(?:git|https?)://([\w\.]+)/]; my ($auth, $repo_name) = $url =~ m[(?:git|https?)://$home/([^/]+)/([^/]+)\.git]; [ $home, $auth, $repo_name ]
evals/evals-freenode-#perlbot.lst[774]: my $url = "http://github.com/labster/p6-IO-Path-More/"; my ($home) = $url =~ m[(?:git|https?)://([\w\.]+)/]; my ($auth, $repo_name) = $url =~ m[(?:git|https?)://\Q$home\E/([^/]+)/([^/]+)(\.git|/)?$]; [ $home, $auth, $repo_name ]
evals/evals-freenode-#perlbot.lst[775]: my $url = "http://github.com/labster/p6-IO-Path-More/"; my ($home) = $url =~ m[(?:git|https?)://([\w\.]+)/]; my ($auth, $repo_name) = $url =~ m[(?:git|https?)://\Q$home\E/([^/]+)/([^/]+)(\.git|/)$]; [ $home, $auth, $repo_name ]
evals/evals-freenode-#perlbot.lst[776]: my ( $user, $nick ) = ( 'root', 'ro.+' ); if($user =~ /^$nick$/){ say 'pwned' }
evals/evals-freenode-#perlbot.lst[777]: my ( $user, $nick ) = ( 'root', 'ro.+' ); if($user =~ /^$nick$/){ say 'pwned' } else { say 'you are not root' }
evals/evals-freenode-#perlbot.lst[778]: my utf8 $x = 3; [ $x ]
evals/evals-freenode-#perlbot.lst[779]: my @vals = (0); [pack("C*", @vals)];
evals/evals-freenode-#perlbot.lst[780]: my $x = 0.1 + 0.2; [ $x,  ("$x" == "0.3") ? 'y' : 'n' ]
evals/evals-freenode-#perlbot.lst[781]: my $x = 0.1 + 0.2; [ $x,  ($x == 0.3) ? 'y' : 'n' ]
evals/evals-freenode-#perlbot.lst[782]: my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 123456; [ exp $x, $y ];
evals/evals-freenode-#perlbot.lst[783]: my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 123456; [ $x, exp $x, $y ];
evals/evals-freenode-#perlbot.lst[784]: my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 12345; [ exp $x, $y ];
evals/evals-freenode-#perlbot.lst[785]: my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 12345; [ $x, exp $x, $y ];
evals/evals-freenode-#perlbot.lst[786]: my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 1234; [ $x, exp $x, $y, (exp $x) - $y ];
evals/evals-freenode-#perlbot.lst[787]: my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 1234; [ $x, exp $x, $y, exp $x - $y ];
evals/evals-freenode-#perlbot.lst[788]: my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 123; [ $x, exp $x, $y ];
evals/evals-freenode-#perlbot.lst[789]: my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 123; [ $x, exp $x, $y, (exp $x) - $y ];
evals/evals-freenode-#perlbot.lst[790]: my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 123; [ $x, exp $x, $y, $y - exp $x ];
evals/evals-freenode-#perlbot.lst[791]: my $x = 0; my $y = 1; $x += log, $y *= $_ for 1 .. 12; [ $x, exp $x, $y, $y - exp $x ];
evals/evals-freenode-#perlbot.lst[792]: my $x = 0; $x += log for 1 .. 123456; "123456! is a " . int($x / log 10 + .99999) . " digit number";
evals/evals-freenode-#perlbot.lst[793]: my $x = 0; $x += log for 1 .. 123456; "123456! is a " . int($x / log 10) . " digit number";
evals/evals-freenode-#perlbot.lst[794]: my $x = 0; $x += log for 1 .. 123456; "123456! is a " . ($x / log 10) . " digit number";
evals/evals-freenode-#perlbot.lst[795]: my $x = 0; $x += log for 1 .. 123456; "123456! is a " . $x / log 10 . " digit number";
evals/evals-freenode-#perlbot.lst[796]: my $x = 0; $x += log for 1 .. 123456; [ $x, $x / log 10, $x / log 2 ];
evals/evals-freenode-#perlbot.lst[797]: my $x = 0; $x += logfor 1 .. 123456; [ $x, $x / log 10, $x / log 2 ];
evals/evals-freenode-#perlbot.lst[798]: my $x = 10.01; $x -= 10.00; print $x
evals/evals-freenode-#perlbot.lst[799]: my $x = 10.01; $x -= 10; print $x
evals/evals-freenode-#perlbot.lst[800]: my $x = [1..10]; say $x->@[2,4]
evals/evals-freenode-#perlbot.lst[801]: my @x = (1, { x => z }, 2); sub foo {my @t = @_; undef @t } foo(@x); \@x
evals/evals-freenode-#perlbot.lst[802]: my $x = [3, 4, 5]; for my $y (map @$_, $x) { ++$y }
evals/evals-freenode-#perlbot.lst[803]: my $x = [3, 4, 5]; for my $y (map @$_, $x) { ++$y }; $x;
evals/evals-freenode-#perlbot.lst[804]: my $x = [3, 4, 5]; for my $y (map @$_, $x) { ++$y, ++$x }; $x;
evals/evals-freenode-#perlbot.lst[805]: my $x = [3, 4, 5]; for my $y (map @$_, $x) { ++$y, ++$y }; $x;
evals/evals-freenode-#perlbot.lst[806]: my $x = [3, 4, 5]; for my $y (@$x) { ++$y, ++$y }; $x;
evals/evals-freenode-#perlbot.lst[807]: my $x = 42; join ' ', ++$x, ++$x, ++$x;
evals/evals-freenode-#perlbot.lst[808]: my $x = '$5.99'; $x =~ tr/0-9//cd; $x
evals/evals-freenode-#perlbot.lst[809]: my $x = 5; until ( $x-- == 0 ) { print "foos " }
evals/evals-freenode-#perlbot.lst[810]: my $x = *a; [ ref \$x ]
evals/evals-freenode-#perlbot.lst[811]: my $x = bless [], 'foo'; [ ref($x)->isa( 'main' ) ]
evals/evals-freenode-#perlbot.lst[812]: my $x = "cbdafeghjiklnmoprqstvuwxy"; $x =~ tr/a-y/Just another Perl hacker,/; [$x];
evals/evals-freenode-#perlbot.lst[813]: my $x; [ defined &$x ]
evals/evals-freenode-#perlbot.lst[814]: my $x = 'foo bar baz'; say 's-' . ($x =~ s/\s.+//r) . '42'
evals/evals-freenode-#perlbot.lst[815]: my $x = 'foo bar baz'; say 's-' . $x =~ s/\s.+//r . '42'
evals/evals-freenode-#perlbot.lst[816]: my $x = 'foo bar baz'; say 's-' . ($x =~ s/\S.+//r) . '42'
evals/evals-freenode-#perlbot.lst[817]: my $x = 'foo bar baz'; say 's-' . $x =~ s/\S.+//r . '42
evals/evals-freenode-#perlbot.lst[818]: my $x = 'foo bar baz'; say 's-' . $x =~ s/\S.+//r . '42'
evals/evals-freenode-#perlbot.lst[819]: my $x = \*foo; $x
evals/evals-freenode-#perlbot.lst[820]: my $x = \*foo; *$x
evals/evals-freenode-#perlbot.lst[821]: my $x = '+foo'; $x =~ s/^\+// and say "42";
evals/evals-freenode-#perlbot.lst[822]: my $x = 'foo'; $x =~ s/^\+// and say "42";
evals/evals-freenode-#perlbot.lst[823]: my @x; local $x[0] = 1; \@x
evals/evals-freenode-#perlbot.lst[824]: my $x; local $x->[0] = 1; [ $x ]
evals/evals-freenode-#perlbot.lst[825]: my @x; local $x[0] = 42; "@x";
evals/evals-freenode-#perlbot.lst[826]: my @x; local $x[0] = 42; \@x
evals/evals-freenode-#perlbot.lst[827]: my $x; local $$x = 1; [ $x ]
evals/evals-freenode-#perlbot.lst[828]: my $x = "main::a"; [ ref \$x ]
evals/evals-freenode-#perlbot.lst[829]: my $x = 'nowhere'; eval { goto $x }; [ 'got', $@ ]
evals/evals-freenode-#perlbot.lst[830]: my $x = pack('C*', map rand(128), 1..1e5); my ($index, $regex); my $start = time; 1 while $start==time;++$start; { index($x, "\\x"); ++$index; redo if $start == time }; ++$start; { $x =~ /\\x/; ++$regex; redo if $start == time }; [ $index / $regex ]
evals/evals-freenode-#perlbot.lst[831]: my $x = pack('C*', map rand(128), 1..1e5); my ($index, $regex); my $start = time; 1 while $start==time;++$start; { index($x, "\\x"); ++$index; redo if $start == time }; ++$start; { $x =~ /\\x/; ++$regex; redo if $start == time }; [ $index, $regex ]
evals/evals-freenode-#perlbot.lst[832]: my $x = pack('C*', map rand(128), 1..1e5); my ($index, $regex); my $start = time; 1 while $start==time;++$start; { index($x, "\\x"); ++$index; redo if $start == time }; ++$start; { $x =~ /\\x/; ++$regex; redo if $start == time }; [ $index, $regex, $index / $regex ]
evals/evals-freenode-#perlbot.lst[833]: my $x = pack('C*', map rand(128), 1..1e5); my ($index, $regex); my $start = time; 1 while $start == time; ++$start; index($x, "\\x"), ++$index while $start == time; ++$start; $x =~ /\\x/, ++$regex while $start == time; [ $index, $regex, $index / $regex ]
evals/evals-freenode-#perlbot.lst[834]: my $x = []; [ ref($x)->isa( 'main' ) ]
evals/evals-freenode-#perlbot.lst[835]: my $x = []; [ ref($x)->SUPER::isa( 'main' ) ]
evals/evals-freenode-#perlbot.lst[836]: my $x = "\r\n"; chomp $x; [ $x ]
evals/evals-freenode-#perlbot.lst[837]: my $x = "\r\n"; chomp $x; $x
evals/evals-freenode-#perlbot.lst[838]: my $x = (sub { [1..3], [a..c] })->();
evals/evals-freenode-#perlbot.lst[839]: my $x = []; $x->@*
evals/evals-freenode-#perlbot.lst[840]: my $x; $x += 4;
evals/evals-freenode-#perlbot.lst[841]: my $x = {}; $x->@{qw/foo bar/} = ("foo", "bar"); $x
evals/evals-freenode-#perlbot.lst[842]: my $x = {}; $x->@*{qw/foo bar/} = ("foo", "bar"); $x
evals/evals-freenode-#perlbot.lst[843]: my $x = []; [ $x->SUPER::isa( 'main' ) ]
evals/evals-freenode-#perlbot.lst[844]: my $x = 'Zoffix'; substr($x, 2, 1) = 'ooooo'; $x
evals/evals-freenode-#perlbot.lst[845]: my $x = "z\r\n"; chomp $x; [ $x ]
evals/evals-freenode-#perlbot.lst[846]: my @Z = 'a'..'z'; my @Z2; for ( @Z ) { push @Z2, $_, uc $_; } \@Z2;
evals/evals-freenode-#perlbot.lst[847]: $n == 0 + reverse $n
evals/evals-freenode-#perlbot.lst[848]: $! = 'NaN'; $!
evals/evals-freenode-#perlbot.lst[849]: $! = 'NaN'; $1
evals/evals-freenode-#perlbot.lst[850]: "\N{DONG SIGN}"
evals/evals-freenode-#perlbot.lst[851]: no feature ':all'; sub foo (;$$;) { [@_] }; my %h = ( bar => foo 42, 'bar'  );  \%h
evals/evals-freenode-#perlbot.lst[852]: no feature ':all'; sub foo (;$$;) { [@_] }; my %h = ( bar => foo 42, bar => meow => 'moo' );  \%h
evals/evals-freenode-#perlbot.lst[853]: no feature ':all'; sub foo (;\[$@]) { [@_] }; my %h = ( bar => foo 42, bar => meow => 'moo' );  \%h
evals/evals-freenode-#perlbot.lst[854]: no feature ':all'; sub foo (;\[$$]) { [@_] }; my %h = ( bar => foo 42, bar => meow => 'moo' );  \%h
evals/evals-freenode-#perlbot.lst[855]: no feature ':all'; sub foo ($$;) { [@_] }; my %h = ( bar => foo 42, bar => meow => 'moo' );  \%h
evals/evals-freenode-#perlbot.lst[856]: no feature ':all'; sub foo ($$) { [@_] }; my %h = ( bar => foo 42, bar => meow => 'moo' );  \%h
evals/evals-freenode-#perlbot.lst[857]: no feature ':all'; sub foo (+) { [@_] }; my %h = ( bar => foo 42, bar => meow => 'moo' );  \%h
evals/evals-freenode-#perlbot.lst[858]: no feature ':all'; sub foo (+$) { [@_] }; my %h = ( bar => foo 42, bar => meow => 'moo' );  \%h
evals/evals-freenode-#perlbot.lst[859]: no feature ':all'; sub foo (;$) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \%h
evals/evals-freenode-#perlbot.lst[860]: no feature ':all'; sub foo (;$$;) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \%h
evals/evals-freenode-#perlbot.lst[861]: no feature ':all'; sub foo (;$$) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \%h
evals/evals-freenode-#perlbot.lst[862]: no feature ':all'; sub foo (;%$) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \%h
evals/evals-freenode-#perlbot.lst[863]: no feature ':all'; sub foo ($$) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \%h
evals/evals-freenode-#perlbot.lst[864]: no feature ':all'; sub foo ($;@) { [@_] }; my %h = ( bar => foo 42, x => meow => 'moo' );  \%h
evals/evals-freenode-#perlbot.lst[865]: no feature ':all'; sub foo ($@) { [@_] }; my %h = ( bar => foo 42, x => meow => 'moo' );  \%h
evals/evals-freenode-#perlbot.lst[866]: no feature ':all'; sub foo (+) { [@_] }; my %h = ( bar => foo 42, x => meow => 'moo' );  \%h
evals/evals-freenode-#perlbot.lst[867]: no feature ':all'; sub foo (++) { [@_] }; my %h = ( bar => foo 42, x => meow => 'moo' );  \%h
evals/evals-freenode-#perlbot.lst[868]: no feature ':all'; sub foo (;$$) { print  "[@_]"; }; my %h = ( bar => foo 42, meow => 'moo' ); \%h
evals/evals-freenode-#perlbot.lst[869]: no feature ':all'; sub foo (;$$) { print  "[@_]"; }; my %h = ( bar => foo(42), meow => 'moo' ); \%h
evals/evals-freenode-#perlbot.lst[870]: no feature ':all'; sub foo ($) { print  "[@_]"; }; my %h = ( bar => foo(42), meow => 'moo' ); \%h
evals/evals-freenode-#perlbot.lst[871]: no feature ':all'; sub foo (;$) { print "[@_]"; }; my %h = ( bar => foo 42, meow => 'moo' ); print Dumper \%h
evals/evals-freenode-#perlbot.lst[872]: no feature ':all'; sub foo (;$$) { print "[@_]"; }; my %h = ( bar => foo 42, meow => 'moo' ); print Dumper \%h
evals/evals-freenode-#perlbot.lst[873]: no feature ':all'; sub foo ($) { say "[@_]"; }; my %h = ( bar => foo(42), meow => 'moo' ); \%h
evals/evals-freenode-#perlbot.lst[874]: no feature 'signatures'; sub foo (\@) { say @_ };
evals/evals-freenode-#perlbot.lst[875]: no feature 'signatures'; sub foo (\@) { say @_ };  foo +(split //, "foobar")
evals/evals-freenode-#perlbot.lst[876]: no indirect; try {print "hw"} catch {die "hello"};
evals/evals-freenode-#perlbot.lst[877]: 'nonexist'->import();
evals/evals-freenode-#perlbot.lst[878]: "\N{PILE OF POO}"
evals/evals-freenode-#perlbot.lst[879]: "\N{SNOWMAN}"
evals/evals-freenode-#perlbot.lst[880]: "\N{SPARKLE}"
evals/evals-freenode-#perlbot.lst[881]: "\N{SPARKLE}\N{SPARKLE}"
evals/evals-freenode-#perlbot.lst[882]: "\N{SPARKLE}\N{SPARKLE}"
evals/evals-freenode-#perlbot.lst[883]: "\N{SPARKLE}\N{SPARKLE}"
evals/evals-freenode-#perlbot.lst[884]: '\n' =~ /^$/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[885]: "\n" =~ /^$/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[886]: "\n" =~ /^\z/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[887]: $^O
evals/evals-freenode-#perlbot.lst[888]: [ 'o010' + 0 ]
evals/evals-freenode-#perlbot.lst[889]:     $     OMG     =     8_0         ;$_;
evals/evals-freenode-#perlbot.lst[890]:     $     OMG     =     8_0         ;$_$;
evals/evals-freenode-#perlbot.lst[891]:     $     OMG     =     8_0      ;$    OMG
evals/evals-freenode-#perlbot.lst[892]:     $     OMG     =     8_0      ;$    OMG!
evals/evals-freenode-#perlbot.lst[893]:     $     OMG     =     8_0      ;$    OMG\
evals/evals-freenode-#perlbot.lst[894]:     $     OMG     =     8_0;                 $    OMG
evals/evals-freenode-#perlbot.lst[895]:     $     OMG     =     8_0;    $                 OMG
evals/evals-freenode-#perlbot.lst[896]: open my $fh, '<', $z; [ map ref, \1, [], {}, sub{}, qr//, \pos, \v1.2, $fh ]
evals/evals-freenode-#perlbot.lst[897]: open my $fh, '<', $z; [ map ref, \1, [], {}, sub{}, qr//, \pos, \v1.2, \$fh ]
evals/evals-freenode-#perlbot.lst[898]: ord 'a'
evals/evals-freenode-#perlbot.lst[899]: ord 'X'
evals/evals-freenode-#perlbot.lst[900]: ord 'Χ'
evals/evals-freenode-#perlbot.lst[901]: our @a; { push (local @a), 42 }; \@a;
evals/evals-freenode-#perlbot.lst[902]: our @CARP_NOT=qw/main/; Carp::croak("loaded");
evals/evals-freenode-#perlbot.lst[903]: our %temp = (1,2); [ %main:: ]
evals/evals-freenode-#perlbot.lst[904]: our %temp = (1,2); [ *main::{ temp } ]
evals/evals-freenode-#perlbot.lst[905]: our %temp = (1,2); [ $main::{ 'temp' }{ HASH } ]
evals/evals-freenode-#perlbot.lst[906]: our %temp = (1,2); [ *main::{ 'temp' }{ HASH } ]
evals/evals-freenode-#perlbot.lst[907]: our %temp = (1,2); my $stash = \%main:: ; [ grep /tem/, keys %$stash ]
evals/evals-freenode-#perlbot.lst[908]: our %temp = (1,2); my $stash = \%main:: ; [ grep /t/, keys %$stash ]
evals/evals-freenode-#perlbot.lst[909]: our %temp = (1,2); my $stash = \%main:: ; [ keys %$stash ]
evals/evals-freenode-#perlbot.lst[910]: our %temp = (1,2); my $stash = %main:: ; [ keys %$stash ]
evals/evals-freenode-#perlbot.lst[911]: our %temp = (1,2); my $stash = \%main:: ; [ $stash->{temp} ]
evals/evals-freenode-#perlbot.lst[912]: our %temp = (1,2); my $stash = %main:: ; [ $stash->{'temp::'} ]
evals/evals-freenode-#perlbot.lst[913]: our %temp = (1,2); my $stash = %main:: ; [ $stash->{temp} ]
evals/evals-freenode-#perlbot.lst[914]: our %temp = (1,2); my $stash = \%main:: ; [ *{$stash->{temp}}{array} ]
evals/evals-freenode-#perlbot.lst[915]: our %temp = (1,2); my $stash = \%main:: ; [ *{$stash->{temp}}{ARRAY} ]
evals/evals-freenode-#perlbot.lst[916]: our %temp = (1,2); my $stash = \%main:: ; [ $stash->{temp}{HASH} ]
evals/evals-freenode-#perlbot.lst[917]: our %temp = (1,2); my $stash = \%main:: ; [ *{$stash->{temp}}{HASH} ]
evals/evals-freenode-#perlbot.lst[918]: our %temp = (1,2); my $stash = \%main:: ; [ *{$stash->{temp}}{SCALAR} ]
evals/evals-freenode-#perlbot.lst[919]: our %temp = (1,2); my $temp = 4; my $stash = \%main:: ; [ *{$stash->{temp}}{SCALAR} ]
evals/evals-freenode-#perlbot.lst[920]: our %temp = (1,2); my $temp; my $stash = \%main:: ; [ *{$stash->{temp}}{SCALAR} ]
evals/evals-freenode-#perlbot.lst[921]: our %temp = (1,2); our $temp = 4; my $stash = \%main:: ; [ ref $stash->{temp} ]
evals/evals-freenode-#perlbot.lst[922]: our %temp = (1,2); our $temp = 4; my $stash = \%main:: ; [ $stash->{temp} ]
evals/evals-freenode-#perlbot.lst[923]: our %temp = (1,2); our $temp = 4; my $stash = \%main:: ; [ *{$stash->{temp}}{SCALAR} ]
evals/evals-freenode-#perlbot.lst[924]: our %temp; [ $main::{ 'temp' }
evals/evals-freenode-#perlbot.lst[925]: our %temp; [ $main::{ 'temp' } ]
evals/evals-freenode-#perlbot.lst[926]: our %temp; [ $main::{ 'temp' }{ 'HASH' ]
evals/evals-freenode-#perlbot.lst[927]: our %temp; [ $main::{ 'temp' }{ 'HASH' } ]
evals/evals-freenode-#perlbot.lst[928]: our %temp; [ $main::{ 'temp' }{ HASH } ]
evals/evals-freenode-#perlbot.lst[929]: our $VERSION = 'blah';  __PACKAGE__->VERSION
evals/evals-freenode-#perlbot.lst[930]: %p = (1, 2); ++$$_ for \(%p); \%p
evals/evals-freenode-#perlbot.lst[931]: %p = (1, 2); [ (()=%p) ]
evals/evals-freenode-#perlbot.lst[932]: %p = (1, 2); [ \(%p) ]
evals/evals-freenode-#perlbot.lst[933]: %p = (1, 2); [ \%p, map s/\d/3/, (()=%p) ]
evals/evals-freenode-#perlbot.lst[934]: %p = (1, 2); [ \%p, map s/\d/3/, %p ]
evals/evals-freenode-#perlbot.lst[935]: %p = (1, 2); [ \%p, map s/\d/3/r, %p ]
evals/evals-freenode-#perlbot.lst[936]: %p = 1, 2; [ \%p, map s/\d/3/r, %p ]
evals/evals-freenode-#perlbot.lst[937]: %p = 1, 2; \%p, map s/\d/3/r, %p
evals/evals-freenode-#perlbot.lst[938]: __PACAKAGE__
evals/evals-freenode-#perlbot.lst[939]: pacakge Foo; sub foo { bar() }; BEGIN { print join ",", keys %Foo:: }; 
evals/evals-freenode-#perlbot.lst[940]: __PACKAGE__
evals/evals-freenode-#perlbot.lst[941]: package Bar; CHECK { my @early; BEGIN { @early = keys %Bar:: }; print "CHECK: @early" }; sub quux { 42 }; print "Later: ", join(",", keys %Bar:: )
evals/evals-freenode-#perlbot.lst[942]: package Bar; CHECK { my @early; BEGIN { @early = keys %Bar:: }; print "@early" }; sub quux { 42 }; print "Later: ", join(",", keys %Bar:: )
evals/evals-freenode-#perlbot.lst[943]: package Bar; [ keys %Bar:: ]
evals/evals-freenode-#perlbot.lst[944]: package Bar; [ keys %Foo:: ]
evals/evals-freenode-#perlbot.lst[945]: package Bar; use Carp qw,croak,; CHECK { my @early; BEGIN { @early = keys %Bar:: }; print "CHECK: @early" }; sub quux { 42 }; print "Later: ", join(",", keys %Bar:: )
evals/evals-freenode-#perlbot.lst[946]: package Bar; use Carp qw,croak,; do { my @early; BEGIN { @early = keys %Bar:: }; print "Early: @early" }; sub quux { 42 }; print "Later: ", join(",", keys %Bar:: )
evals/evals-freenode-#perlbot.lst[947]: package Bar; use Carp qw,croak,; INIT { my @early; BEGIN { @early = keys %Bar:: }; print "Early: @early" }; sub quux { 42 }; print "Later: ", join(",", keys %Bar:: )
evals/evals-freenode-#perlbot.lst[948]: package Charlie; sub talk { 'blah' }; package main; $::{'DB::Sandie::'} = $::{'Charlie::'};
evals/evals-freenode-#perlbot.lst[949]: package Charlie; sub talk { 'blah' }; package main; $::{'DB::Sandie::'} = $::{'Charlie::'}; DB::Sandie->talk
evals/evals-freenode-#perlbot.lst[950]: package Charlie; sub talk { 'blah' }; package main; *::{'DB::Sandie::'} = $::{'Charlie::'}; DB::Sandie->talk
evals/evals-freenode-#perlbot.lst[951]: package Charlie; sub talk { 'blah' }; package main; *::{'DB::Sandie::'} = *::{'Charlie::'}; DB::Sandie->talk
evals/evals-freenode-#perlbot.lst[952]: package Charlie; sub talk { 'blah' }; package main; *::{'DB::Sandie::'} = \%$::{'Charlie::'}; DB::Sandie->talk
evals/evals-freenode-#perlbot.lst[953]: package Charlie; sub talk { 'blah' }; package main; *{$::{'DB::Sandie::'}} = \%{$::{'Charlie::'}}; DB::Sandie->talk
evals/evals-freenode-#perlbot.lst[954]: package Charlie; sub talk { 'blah' }; package main; *{$::{'DB::Sandie::'}} = \%{*::{'Charlie::'}}; DB::Sandie->talk
evals/evals-freenode-#perlbot.lst[955]: package Charlie; sub talk { 'blah' }; package main; *DB::Sandie:: = *Charlie:: ; DB::Sandie->talk;
evals/evals-freenode-#perlbot.lst[956]: package Charlie; sub talk { 'blah' }; package main; local *DB::Sandie:: = *Charlie:: ; DB::Sandie->talk;
evals/evals-freenode-#perlbot.lst[957]: package Charlie; sub talk { 'blah' }; package main; local $::{'DB::Sandy::'} = $::{'Charlie::'}; DB::Sandy->talk;
evals/evals-freenode-#perlbot.lst[958]: package Charlie; sub talk { 'blah' }; package main; local *::{'DB::Sandy::'} = *::{'Charlie::'}; DB::Sandy->talk;
evals/evals-freenode-#perlbot.lst[959]: package Charlie; sub talk { 'blah' }; package main; local *::{'DB::Sandy::} = *::{'Charlie::'}; DB::Sandy->talk;
evals/evals-freenode-#perlbot.lst[960]: package Charlie; sub talk { 'blah' }; package main; local %$::{'DB::Sandy::'} = %$::{'Charlie::'}; DB::Sandy->talk;
evals/evals-freenode-#perlbot.lst[961]: package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; Charlie->talk;
evals/evals-freenode-#perlbot.lst[962]: package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; DB::Sandie->talk;
evals/evals-freenode-#perlbot.lst[963]: package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; $g = $Charlie::{'::'} [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]
evals/evals-freenode-#perlbot.lst[964]: package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; $g = *Charlie:: ; [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]
evals/evals-freenode-#perlbot.lst[965]: package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; $g = *Charlie:: [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]
evals/evals-freenode-#perlbot.lst[966]: package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; $g = $DB::Sandie::{'::'} [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]
evals/evals-freenode-#perlbot.lst[967]: package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; $::{'DB::Sandie::'} = $g; [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]
evals/evals-freenode-#perlbot.lst[968]: package Charlie; sub talk { 'blah' }; package main; my $g = $::{'Charlie::'}; [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]
evals/evals-freenode-#perlbot.lst[969]: package Charlie; sub talk { 'blah' }; package main; my $g = \*::{'Charlie::'}; [ map *{$g}{$_}, qw,HASH SCALAR ARRAY GLOB, ]
evals/evals-freenode-#perlbot.lst[970]: package Charlie; sub talk { 'blah' }; package main; print $::{'Charlie::'}
evals/evals-freenode-#perlbot.lst[971]: package Charlie; sub talk { 'blah' }; package main; print *::{'Charlie::'}
evals/evals-freenode-#perlbot.lst[972]: package Foo; [ keys %Foo:: ]
evals/evals-freenode-#perlbot.lst[973]: package Foo; [ map {scalar caller $_} -1 .. 4 ]
evals/evals-freenode-#perlbot.lst[974]: package Foo; our $foo = 42; package main; \%{\Foo}::
evals/evals-freenode-#perlbot.lst[975]: package Foo; our $foo = 42; package main; \%Foo::
evals/evals-freenode-#perlbot.lst[976]: package Foo; our $foo = 42; package main; \%{Foo}::foo
evals/evals-freenode-#perlbot.lst[977]: package Foo; our $foo = 42; package main; \%Foo::foo
evals/evals-freenode-#perlbot.lst[978]: package Foo; our $foo = 42; package main; my $z = 'Foo';  \%"$x"::
evals/evals-freenode-#perlbot.lst[979]: package Foo; our $foo = 42; package main; my $z = 'Foo';  \%{{$x}::
evals/evals-freenode-#perlbot.lst[980]: package Foo; our $foo = 42; package main; my $z = 'Foo';  \%{$x}::
evals/evals-freenode-#perlbot.lst[981]: package Foo; our $foo = 42; package main; my $z = 'Foo';  \%$x::
evals/evals-freenode-#perlbot.lst[982]: package Foo; our $VERSION = 'blah'; package main; say Foo->VERSION
evals/evals-freenode-#perlbot.lst[983]: package Foo; package main; [ Foo->can('import') ]
evals/evals-freenode-#perlbot.lst[984]: package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );
evals/evals-freenode-#perlbot.lst[985]: package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );  $x->can($foo{bar})->()
evals/evals-freenode-#perlbot.lst[986]: package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );  $x->"$foo{bar}"
evals/evals-freenode-#perlbot.lst[987]: package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );  $x->("$foo{bar}")
evals/evals-freenode-#perlbot.lst[988]: package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );  $x->\"$foo{bar}"
evals/evals-freenode-#perlbot.lst[989]: package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' ); $x->($foo{bar})
evals/evals-freenode-#perlbot.lst[990]: package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' ); $x->(\"$foo{bar}")
evals/evals-freenode-#perlbot.lst[991]: package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' ); $x->(\$foo{bar})
evals/evals-freenode-#perlbot.lst[992]: package foo; sub bar {"baz"}; sub boo {"boobs"}; $a = "bar"; *{"foo::".$a}->()
evals/evals-freenode-#perlbot.lst[993]: package foo; sub bar {"baz"}; sub boo {"boobs"}; $a = "bar"; \*{"foo::".$a}
evals/evals-freenode-#perlbot.lst[994]: package foo; sub bar {"baz"}; sub boo {"boobs"}; $a = "bar"; \*{"foo::".$a}->()
evals/evals-freenode-#perlbot.lst[995]: package foo; sub bar {"baz"}; sub boo {"boobs"}; $a = "bar"; \*{foo::$a}
evals/evals-freenode-#perlbot.lst[996]: package Foo; sub bar; [ grep defined &$_, keys %Foo:: ]
evals/evals-freenode-#perlbot.lst[997]: package Foo; sub bar; [ keys %Foo:: ]
evals/evals-freenode-#perlbot.lst[998]: package Foo; sub bar; use strict; [ grep defined &$_, keys %Foo:: ]
evals/evals-freenode-#perlbot.lst[999]: package Foo; sub foo { bar() }; BEGIN { print join ",", keys %Foo:: }; 
evals/evals-freenode-#perlbot.lst[1000]: package Foo; sub import {} package main; [ Foo->can('import') ]
evals/evals-freenode-#perlbot.lst[1001]: package FOO; sub new { return bless [42], __PACKAGE__ };  package main; use constant BAR => 'FOO';  BAR->new
evals/evals-freenode-#perlbot.lst[1002]: package FOO; sub new { return bless [42], __PACKAGE__;  use constant BAR => 'FOO';  BAR->new
evals/evals-freenode-#perlbot.lst[1003]: package foo; tie *STDOUT, 'foo'; sub TIEHANDLE { return bless {}, 'foo' } sub PRINT { CORE::print "TEST" } print "hello"
evals/evals-freenode-#perlbot.lst[1004]: package foo; tie *STDOUT, 'foo'; sub TIEHANDLE { return bless {}, 'foo' } sub PRINT { print "TEST" } print "hello"
evals/evals-freenode-#perlbot.lst[1005]: package Foo; use overload q{""} => sub {42 }; package main; my $x = bless {}, 'Foo'; 'foo'->$x
evals/evals-freenode-#perlbot.lst[1006]: package Foo; use overload q{""} => sub {42 }; package main; my $x = bless sub{ 45 }, 'Foo'; [ 'foo'->$x // 'z', "$x" //'z' ]
evals/evals-freenode-#perlbot.lst[1007]: package Foo; use overload q{""} => sub {42 }; package main; my $x = bless sub{}, 'Foo'; 'foo'->$x
evals/evals-freenode-#perlbot.lst[1008]: package Foo; use overload q{""} => sub {42 }; package main; my $x = bless sub{}, 'Foo'; [ 'foo'->$x, "$x" ]
evals/evals-freenode-#perlbot.lst[1009]: package Foo; use overload q{""} => sub {42 }; package main; my $x = bless sub{}, 'Foo'; [ 'foo'->$x, "$x"]
evals/evals-freenode-#perlbot.lst[1010]: package Foo; use overload q{""} => sub {42 }; package main; my $x = bless sub{}, 'Foo'; [ 'foo'->$x // 'z', "$x" //'z' ]
evals/evals-freenode-#perlbot.lst[1011]: package Foo; use overload q{""} => sub {42 }; package main; my $x = bless sub{ shift }, 'Foo'; [ 'foo'->$x // 'z', "$x" //'z' ]
evals/evals-freenode-#perlbot.lst[1012]: package Foo; use strict; use warnings; 'blah'->VERSION;
evals/evals-freenode-#perlbot.lst[1013]: package Foo; use strict; use warnings; our $VERSION = 'blah';
evals/evals-freenode-#perlbot.lst[1014]: package Foo; use strict; use warnings; our $VERSION = 'blah'; package main; say Foo->VERSION
evals/evals-freenode-#perlbot.lst[1015]: package Foo; use warnings; sub foo { undef()+0 }; package main; foo();
evals/evals-freenode-#perlbot.lst[1016]: package Foo; use warnings; sub foo { undef+0 }; package main; foo();
evals/evals-freenode-#perlbot.lst[1017]: package Foo; use warnings; sub foo { undef()+0 }; package main; Foo::foo();
evals/evals-freenode-#perlbot.lst[1018]: package Foo; use warnings; sub foo { undef()+0 }; package main; $Foo::{'^WARNING_BITS'}=0; Foo::foo();
evals/evals-freenode-#perlbot.lst[1019]: package Foo; use warnings; sub foo { undef()+0 }; package main; $Foo::{'^WARNING_BITS'}=0; Foo::foo(); [1]
evals/evals-freenode-#perlbot.lst[1020]: package Foo; use warnings; sub foo { undef()+0 }; package main; no warnings; Foo::foo();
evals/evals-freenode-#perlbot.lst[1021]: package Foo; use warnings; sub foo { undef()+0 }; package main; no warnings 'Foo::uninitialized'; Foo::foo();
evals/evals-freenode-#perlbot.lst[1022]: package OOBLA; sub _compare {"compare"}; $self = bless {}; my $method = $self->can("_compare_".ref $comp) || $self->can("_compare"); &$method($self, "foo");
evals/evals-freenode-#perlbot.lst[1023]: package OOBLA; sub _compare {"compare"}; $self = bless {}; my $method = $self->can("_compare_".ref $comp) || $self->can("_compare"); &$method($self, \"foo");
evals/evals-freenode-#perlbot.lst[1024]: package OOBLA; sub _compare {"compare"}; sub _compare_SCALAR {"compare_scalar"}; my $self = bless {}; my $comp = "foo"; my $method = $self->can("_compare_".ref $comp) || $self->can("_compare"); &$method($self, $comp);
evals/evals-freenode-#perlbot.lst[1025]: package OOBLA; sub _compare {"compare"}; sub _compare_SCALAR {"compare_scalar"}; my $self = bless {}; my $comp = \"foo"; my $method = $self->can("_compare_".ref $comp) || $self->can("_compare"); &$method($self, $comp);
evals/evals-freenode-#perlbot.lst[1026]: package OOBLA; sub _compare {"compare"}; sub _compare_SCALAR {"compare_scalar"}; $self = bless {}; my $method = $self->can("_compare_".ref $comp) || $self->can("_compare"); &$method($self, \"foo");
evals/evals-freenode-#perlbot.lst[1027]: package OOBLA; sub _compare_OOBLA {"compare_OOBLA"; \@_}; sub _compare {"compare"}; sub _compare_SCALAR {"compare_scalar"}; my $self = bless {}; my $comp = $self; my $method = $self->can("_compare_".ref $comp) || $self->can("_compare"); $method->($self, $comp);
evals/evals-freenode-#perlbot.lst[1028]: package OOBLA; sub _compare_OOBLA {"compare_OOBLA"}; sub _compare {"compare"}; sub _compare_SCALAR {"compare_scalar"}; my $self = bless {}; my $comp = $self; my $method = $self->can("_compare_".ref $comp) || $self->can("_compare"); $method->($self, $comp);
evals/evals-freenode-#perlbot.lst[1029]: package OOBLA; sub _compare_OOBLA {"compare_OOBLA"}; sub _compare {"compare"}; sub _compare_SCALAR {"compare_scalar"}; my $self = bless {}; my $comp = $self; my $method = $self->can("_compare_".ref $comp) || $self->can("_compare"); &$method($self, $comp);
evals/evals-freenode-#perlbot.lst[1030]: package OOBLA; sub _compare_OOBLA {"compare_OOBLA"; \@_}; sub _compare {"compare"}; sub _compare_SCALAR {"compare_scalar"}; my $self = bless {}; my $comp = $self; $self->${["_compare"]}
evals/evals-freenode-#perlbot.lst[1031]: package OOBLA; sub _compare_OOBLA {"compare_OOBLA"; \@_}; sub _compare {"compare"}; sub _compare_SCALAR {"compare_scalar"}; my $self = bless {}; my $comp = $self; $self->${\("_compare")}
evals/evals-freenode-#perlbot.lst[1032]: package _; use constant test => 1; [ _->test ]
evals/evals-freenode-#perlbot.lst[1033]: package π; package main; require π;
evals/evals-freenode-#perlbot.lst[1034]: package π; sub 2 {atan2(1,1) * 2}; π::2
evals/evals-freenode-#perlbot.lst[1035]: package π; sub new { bless {}, shift } package main;   my $x = π->new; say $x
evals/evals-freenode-#perlbot.lst[1036]: package π; use overload fallback => 1, '+' => sub () {atan2(0,-1)}; 0+bless []
evals/evals-freenode-#perlbot.lst[1037]: package π; use overload fallback => 1, '+' => sub {atan2(0,-1)}; 0+bless []
evals/evals-freenode-#perlbot.lst[1038]: package π; use overload fallback => 1, '+' => sub () {atan2(0,-1)}; ''.bless []
evals/evals-freenode-#perlbot.lst[1039]: package π; use overload '+' => sub () {atan2(0,-1)}; ''.bless []
evals/evals-freenode-#perlbot.lst[1040]: package π; use π;
evals/evals-freenode-#perlbot.lst[1041]: package π; \*{"π::2"}
evals/evals-freenode-#perlbot.lst[1042]: package π; *{"π::2"} = sub {atan2(0,-1)}; π->${\2}
evals/evals-freenode-#perlbot.lst[1043]: package π; *{"π::2"} = sub {atan2(1,1) * 2}
evals/evals-freenode-#perlbot.lst[1044]: package π; *{"π::2"} = sub {atan2(1,-1) * 2}; π->${\2}
evals/evals-freenode-#perlbot.lst[1045]: package π; *{"π::2"} = sub {atan2(1,1) * 2}; π->2
evals/evals-freenode-#perlbot.lst[1046]: package π; *{"π::2"} = sub {atan2(1,1) * 2}; π->${\2}
evals/evals-freenode-#perlbot.lst[1047]: package π; *{"π::2"} = sub {atan2(1,1) * 2}; π::2
evals/evals-freenode-#perlbot.lst[1048]: package π; *{"π::2"} = sub {atan2(1,-1)}; π->${\2}
evals/evals-freenode-#perlbot.lst[1049]: package π; *{"π::(+"} = sub () {atan2(0,-1)}; ''.bless []
evals/evals-freenode-#perlbot.lst[1050]: package π; *{"π::+)"} = sub () {atan2(0,-1)}; ''.bless []
evals/evals-freenode-#perlbot.lst[1051]: [pack("C*", 0)];
evals/evals-freenode-#perlbot.lst[1052]: pack("C*", 0);
evals/evals-freenode-#perlbot.lst[1053]: pack "d", 0.1
evals/evals-freenode-#perlbot.lst[1054]: [ pack 'H', 1 ]
evals/evals-freenode-#perlbot.lst[1055]: pack("H*", 4095);
evals/evals-freenode-#perlbot.lst[1056]: pack "H*", "547275746820"
evals/evals-freenode-#perlbot.lst[1057]: pack "H*", "54727574682077617320746865206f6e6c79206461"
evals/evals-freenode-#perlbot.lst[1058]: pack "H*", "54727574682077617320746865206f6e6c79206461756768746572206f662054696d652e"
evals/evals-freenode-#perlbot.lst[1059]: print '✙' .. '❉'
evals/evals-freenode-#perlbot.lst[1060]: print 1
evals/evals-freenode-#perlbot.lst[1061]: print 1; 1
evals/evals-freenode-#perlbot.lst[1062]: print 1; 2
evals/evals-freenode-#perlbot.lst[1063]: print 123 =~ /[[digit]]/;
evals/evals-freenode-#perlbot.lst[1064]: print ’42’
evals/evals-freenode-#perlbot.lst[1065]: print 4; 2
evals/evals-freenode-#perlbot.lst[1066]: print "\a"
evals/evals-freenode-#perlbot.lst[1067]: printf '[%5s]', 'x'
evals/evals-freenode-#perlbot.lst[1068]: print "I'm a Perl ", 5 + !!"0", " program."
evals/evals-freenode-#perlbot.lst[1069]: print q ; $a ; 
evals/evals-freenode-#perlbot.lst[1070]: print q; $a; 
evals/evals-freenode-#perlbot.lst[1071]: print qfoo/bar
evals/evals-freenode-#perlbot.lst[1072]: print sort { $|-- or -1 } 'a'..'y'
evals/evals-freenode-#perlbot.lst[1073]: print sort { $|-- or -1 } 'ruJt tc,en hoetokarrasS h'
evals/evals-freenode-#perlbot.lst[1074]: print sort { $|-- or -1 } 'ruJt tc,en hoetokarrasS h' =~ /./g
evals/evals-freenode-#perlbot.lst[1075]: print "\x{1f4a9}"
evals/evals-freenode-#perlbot.lst[1076]: push(@$campaigns_by_type->{$$campaign{'campaign_type'}}, $campaign);  [ $campaigns_by_type ]
evals/evals-freenode-#perlbot.lst[1077]: push @ISA, 'main'; [ main::->can('foo') ]
evals/evals-freenode-#perlbot.lst[1078]: q;;
evals/evals-freenode-#perlbot.lst[1079]: q;;;;;;;;;;;;;;;;;;;;
evals/evals-freenode-#perlbot.lst[1080]: q=;$a;=;
evals/evals-freenode-#perlbot.lst[1081]: q=;$a; =;
evals/evals-freenode-#perlbot.lst[1082]: q =; $a; =;
evals/evals-freenode-#perlbot.lst[1083]: q =; $a; =; 5; 
evals/evals-freenode-#perlbot.lst[1084]: q= $a = 5; print q ; $a ; 
evals/evals-freenode-#perlbot.lst[1085]: q =; $a; =; 5; print q ; $a ; 
evals/evals-freenode-#perlbot.lst[1086]: $_ = q<acegikmoqsuwybdfhjlnprtvx>; tr/a-y/Just another Sort hacker,/; print
evals/evals-freenode-#perlbot.lst[1087]: $_ = q«acegikmoqsuwybdfhjlnprtvx»; tr/a-y/Just another Sort hacker,/; print
evals/evals-freenode-#perlbot.lst[1088]: q|{:amount($[4.95e0, 4.85e0, 2.4e0]), :description($["Hot beef burrito", "Mild fish taco", "Medium size orange juice"]), :name($["BUBH", "TAFM", "BEOM"]), :price($[4.95e0, 4.85e0, 1.2e0]), :quantity($[1, 1, 2])}| eq q|{:amount($[4.95e0, 4.85e0, 2.4e0]), :description($["Hot beef burrito", "Mild fish taco", "Medium size orange juice"]), :name($["BUBH", "TAFM", "BEOM"]), :price($[4.95e0, 4.85e0, 1.2e0]), :quantity($[1, 1, 2])}|
evals/evals-freenode-#perlbot.lst[1089]: q= $a; print q ; $a ; 
evals/evals-freenode-#perlbot.lst[1090]: q = $a; print q ; $a ; 
evals/evals-freenode-#perlbot.lst[1091]: q=;$a;==~s/;//gr
evals/evals-freenode-#perlbot.lst[1092]: q=;$a;=~s/;//r
evals/evals-freenode-#perlbot.lst[1093]: q=;$a;==~s/;//r
evals/evals-freenode-#perlbot.lst[1094]: q=;$a;=;=~s/;//r
evals/evals-freenode-#perlbot.lst[1095]: [ q(\d) ]
evals/evals-freenode-#perlbot.lst[1096]: $_ = q,echo foo bar=baz hmm="1 2 3" nn='aa bb',; my @h; s/((["'])(?:[^"']+|\\.|(?!\2).)*\2)/push @h, $1;"\xFFFD"/ge; my @words = split ' '; s/\xFFFD/shift @h/ge for @words; \@words;
evals/evals-freenode-#perlbot.lst[1097]: [  q{"foo bar \"something\""} =~ s/(?!<=\\)"//gr ]
evals/evals-freenode-#perlbot.lst[1098]: q ❤‎ Happy Valentine's Day, #perl ❤‎  s ❤ ❤ ❤‎r
evals/evals-freenode-#perlbot.lst[1099]: q ❤‎ Happy Valentine's Day, #perl ❤‎  s ❤ ❤‎r
evals/evals-freenode-#perlbot.lst[1100]: q{Number::RGB->new_from_guess() couldn't guess type} =~ /new_from_guess() couldn't guess/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1101]: q 😁 ☺ Perl \o/ ☺  😁
evals/evals-freenode-#perlbot.lst[1102]: [ quotemeta "~!@#$%^&*()_\\+?" ]
evals/evals-freenode-#perlbot.lst[1103]: quotemeta '~!@#$%^&*()_\\{}.,+?'
evals/evals-freenode-#perlbot.lst[1104]: quotemeta '~!@#$%^&*()_\\+?'
evals/evals-freenode-#perlbot.lst[1105]: quotemeta '~!@#$%^&*()_+?'
evals/evals-freenode-#perlbot.lst[1106]: quotemeta "ǁ
evals/evals-freenode-#perlbot.lst[1107]: quotemeta "\x{D000}"
evals/evals-freenode-#perlbot.lst[1108]: ({qw/ a 1 b 2/})->{b}
evals/evals-freenode-#perlbot.lst[1109]: {qw/ a 1 b 2/}->{b}
evals/evals-freenode-#perlbot.lst[1110]: qw/dial_a_bottle  take_a_cab/[rand 2]
evals/evals-freenode-#perlbot.lst[1111]: qw[foo bar]
evals/evals-freenode-#perlbot.lst[1112]: $r = [ 1, 2, 3, { foo => bar }, ]; @a = @$r; $r->[0] = 42; $r->[3]{ber} = 'bez'; [ \@a, $r ]
evals/evals-freenode-#perlbot.lst[1113]: rand 4
evals/evals-freenode-#perlbot.lst[1114]: readpipe q(echo foo)
evals/evals-freenode-#perlbot.lst[1115]: [ref bless [], 'foo' ]
evals/evals-freenode-#perlbot.lst[1116]: ref &CORE::GLOBAL::print
evals/evals-freenode-#perlbot.lst[1117]: ref *CORE::print
evals/evals-freenode-#perlbot.lst[1118]: ref \*CORE::print
evals/evals-freenode-#perlbot.lst[1119]: ref &CORE::print
evals/evals-freenode-#perlbot.lst[1120]: ref &print
evals/evals-freenode-#perlbot.lst[1121]: ref qr//
evals/evals-freenode-#perlbot.lst[1122]: [ require File::Spec ]
evals/evals-freenode-#perlbot.lst[1123]: require Foo; [ Foo::bar "baz" ]
evals/evals-freenode-#perlbot.lst[1124]: require Foo; [ Foo::bar( "baz" ) ]
evals/evals-freenode-#perlbot.lst[1125]: $s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand(4)]; $c=int(rand(13)); chr 0x1F000+$s+$c
evals/evals-freenode-#perlbot.lst[1126]: $s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand*4]; $c=int(rand*13);  hex $s+$c
evals/evals-freenode-#perlbot.lst[1127]: $s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand*4]; $c=int(rand*13); pack "H*" $s+$c
evals/evals-freenode-#perlbot.lst[1128]: $s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand*4]; $c=int(rand*13); pack "H*", $s+$c
evals/evals-freenode-#perlbot.lst[1129]: $s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand()*4]; $c=int(rand() *13); $s+$c
evals/evals-freenode-#perlbot.lst[1130]: $s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand(4)]; $c=int(rand(13)); $s+$c
evals/evals-freenode-#perlbot.lst[1131]: $s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand*4]; $c=int(rand*13);  $s+$c
evals/evals-freenode-#perlbot.lst[1132]: $s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand*4]; $c=int(rand*13); $s+$c
evals/evals-freenode-#perlbot.lst[1133]: $s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand*4]; $c=int(rand*13); unpack "H*", $s+$c
evals/evals-freenode-#perlbot.lst[1134]: $s=[0xA0, 0xB0, 0xC0, 0xD0]->(rand*4); $c=rand*13; unpack "H*", $s+$c
evals/evals-freenode-#perlbot.lst[1135]: $s=[0xA0, 0xB0, 0xC0, 0xD0]->[rand*4]; $c=rand*13; unpack "H*", $s+$c
evals/evals-freenode-#perlbot.lst[1136]: s/(A)/'lcfirst $1'/ee
evals/evals-freenode-#perlbot.lst[1137]: s/(A)/'lcfirst $1'/ee; $_
evals/evals-freenode-#perlbot.lst[1138]: say ⅔
evals/evals-freenode-#perlbot.lst[1139]: say "\002"
evals/evals-freenode-#perlbot.lst[1140]: say \002
evals/evals-freenode-#perlbot.lst[1141]: say "!(0 || 1 && (0 || 0)) && !(1 && 1)"
evals/evals-freenode-#perlbot.lst[1142]: say '4c6567f85f0980f30987b69b78767647c2165a26' =~ /^[[:hexdigit:]]{40}$/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1143]: say '4c6567f85f0980f30987b69b78767647c2165a26' =~ /^[[:xdigit:]]{40}$/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1144]: say '4c6567f85f0980f30987b69b78767647c2165a26' ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1145]: say blahblah 
evals/evals-freenode-#perlbot.lst[1146]: say chr 0xFE86
evals/evals-freenode-#perlbot.lst[1147]: say chr 10689
evals/evals-freenode-#perlbot.lst[1148]: say for 0.. 0xFF
evals/evals-freenode-#perlbot.lst[1149]: say hex 42
evals/evals-freenode-#perlbot.lst[1150]: say hex 'FA'
evals/evals-freenode-#perlbot.lst[1151]: say length chr 0xFE86
evals/evals-freenode-#perlbot.lst[1152]: say length chr 10689
evals/evals-freenode-#perlbot.lst[1153]: say length q|0.99999999999992|
evals/evals-freenode-#perlbot.lst[1154]: say length quotemeta chr 0xFE86
evals/evals-freenode-#perlbot.lst[1155]: say length quotemeta chr 10689
evals/evals-freenode-#perlbot.lst[1156]: say length "ﺆ"
evals/evals-freenode-#perlbot.lst[1157]: say "\N{COMBINING ACCUTE ACCENT}y"
evals/evals-freenode-#perlbot.lst[1158]: say ord "\n"
evals/evals-freenode-#perlbot.lst[1159]: say q|{:amount($[4.95e0, 4.85e0, 2.4e0]), :description($["Hot beef burrito", "Mild fish taco", "Medium size orange juice"]), :name($["BUBH", "TAFM", "BEOM"]), :price($[4.95e0, 4.85e0, 1.2e0]), :quantity($[1, 1, 2])}| eq q|{:amount($[4.95e0, 4.85e0, 2.4e0]), :description($["Hot beef burrito", "Mild fish taco", "Medium size orange juice"]), :name($["BUBH", "TAFM", "BEOM"]), :price($[4.95e0, 4.85e0, 1.2e0]), :quantity($[1, 1, 2])}|
evals/evals-freenode-#perlbot.lst[1160]: say q|{:amount($[4.95e0, 4.85e0, 2.4e0]), :description($["Hot beef burrito", "Mild fish taco", "Medium size orange juice"]), :name($["BUBH", "TAFM", "BEOM"]), :price($[4.95e0, 4.85e0, 1.2e0]), :quantity($[1, 1, 2])}| eq q|{:amount($[4.95e0, 4.85e0, 2.4e0]), :description($["Hot beef burrito", "Mild fish taco", "Medium size orange juice"]), :name($["BUBH", "TAFM", "BEOM"]), :price($[4.95e0, 4.85e0, 1.2e0]), :quantity($[1, 1, 2])}| ? 's
evals/evals-freenode-#perlbot.lst[1161]: say ref $^O
evals/evals-freenode-#perlbot.lst[1162]: say ref $^V
evals/evals-freenode-#perlbot.lst[1163]: say sort { $|-- or -1 } 'ruJt tc,en hoetokarrasS h' =~ /./g
evals/evals-freenode-#perlbot.lst[1164]: say sprintf '%x', 100
evals/evals-freenode-#perlbot.lst[1165]: say sprintf '%x', 15
evals/evals-freenode-#perlbot.lst[1166]: say sprintf '%x', 16
evals/evals-freenode-#perlbot.lst[1167]: say sprintf '%x', 96
evals/evals-freenode-#perlbot.lst[1168]: say "$^V"
evals/evals-freenode-#perlbot.lst[1169]: say $^V
evals/evals-freenode-#perlbot.lst[1170]: say ⅔ * π
evals/evals-freenode-#perlbot.lst[1171]: [ scalar asdfadsf->import ]
evals/evals-freenode-#perlbot.lst[1172]: scalar grep $_, 1..5
evals/evals-freenode-#perlbot.lst[1173]: [ scalar keys \%INC ]
evals/evals-freenode-#perlbot.lst[1174]: $self->{messages} = [1,2,3]; $self->{messages}->[0] = "a"; $self->{messages}
evals/evals-freenode-#perlbot.lst[1175]: $_ = '@@@'; s'@'$'gr; 
evals/evals-freenode-#perlbot.lst[1176]: "\\" =~ s'\'\\'gsr;
evals/evals-freenode-#perlbot.lst[1177]: "\\" =~ s'\\'\\'gsr;
evals/evals-freenode-#perlbot.lst[1178]: s ❤‎ Happy Valentine's Day, #perl ❤‎ ❤‎ ❤‎r
evals/evals-freenode-#perlbot.lst[1179]: [shift]
evals/evals-freenode-#perlbot.lst[1180]: $SIG{__DIE__} = sub { say "42"; } '..'
evals/evals-freenode-#perlbot.lst[1181]: $SIG{__DIE__} = sub { say 42 };  die  
evals/evals-freenode-#perlbot.lst[1182]: -sin
evals/evals-freenode-#perlbot.lst[1183]: [ -(sin =>)  ]
evals/evals-freenode-#perlbot.lst[1184]: [ -sin =>  ]
evals/evals-freenode-#perlbot.lst[1185]: [ -sin  ]
evals/evals-freenode-#perlbot.lst[1186]: [ sin =>  ]
evals/evals-freenode-#perlbot.lst[1187]: "some text [3] some more text [4] even more text" =~ s/(?=\[\d+\])/\n/gr
evals/evals-freenode-#perlbot.lst[1188]: "some text [3] some more text [4] even more text" =~ s/(?=\[)/␤/gr
evals/evals-freenode-#perlbot.lst[1189]: "some text [3] some more text [4] even more text" =~ s/(?=[)/\n/gr
evals/evals-freenode-#perlbot.lst[1190]: "some text [3] some more text [4] even more text" =~ s/(?=\[)/\n/gr
evals/evals-freenode-#perlbot.lst[1191]: [sort { -1 } 5, 2, 3]
evals/evals-freenode-#perlbot.lst[1192]: [sort {--$|} a..'y']
evals/evals-freenode-#perlbot.lst[1193]: [sort {--$|} a..y]
evals/evals-freenode-#perlbot.lst[1194]: [sort {$|--} a..'y']
evals/evals-freenode-#perlbot.lst[1195]: [ sort { int(rand(3)) - 1 } 1..20 ]
evals/evals-freenode-#perlbot.lst[1196]: [sort { --$| or -1 } 'a'..'y']
evals/evals-freenode-#perlbot.lst[1197]: [sort { $|-- or -1 } 'a'..'y']
evals/evals-freenode-#perlbot.lst[1198]: sort { --$| or -1 } 'a'..'y'
evals/evals-freenode-#perlbot.lst[1199]: [ sort { rand(3) - 1 } 1..20 ]
evals/evals-freenode-#perlbot.lst[1200]: [ sort { rand() > .5 ? 1 : -1 } 1..20 ]
evals/evals-freenode-#perlbot.lst[1201]: [ sort { rand() - .5 } 1..20 ]
evals/evals-freenode-#perlbot.lst[1202]: [ split / /, "foo     bar" ]
evals/evals-freenode-#perlbot.lst[1203]: [[ split / /, "foo     bar" ], [ split ' ', "foo     bar" ]]
evals/evals-freenode-#perlbot.lst[1204]: [ split ' ', "foo  \n  bar\nmer\n  "]
evals/evals-freenode-#perlbot.lst[1205]: [ sprintf('%020b', 4), bin sprintf('%b', 4 << 1) ]
evals/evals-freenode-#perlbot.lst[1206]: [ sprintf('%020b', 4), oct '0b' .  sprintf('%b', 4 << 1) ]
evals/evals-freenode-#perlbot.lst[1207]: [ sprintf('%020b', 4), sprintf('%b', 4 << 1) ]
evals/evals-freenode-#perlbot.lst[1208]: [ sprintf '.0f%', 8.5 ]
evals/evals-freenode-#perlbot.lst[1209]: [ sprintf '%.0f', 8.5 ]
evals/evals-freenode-#perlbot.lst[1210]: sprintf '%1$s %1$s', 'foo'
evals/evals-freenode-#perlbot.lst[1211]: [ sprintf('%20b', 4), sprintf('%b', 4 << 1) ]
evals/evals-freenode-#perlbot.lst[1212]: [ sprintf('%2b', 4), sprintf('%b', 4 << 1) ]
evals/evals-freenode-#perlbot.lst[1213]: [ sprintf('%b', 3), sprintf('%b', 3 << 1) ]
evals/evals-freenode-#perlbot.lst[1214]: [ sprintf('b', 3), sprintf('b', 3 << 1) ]
evals/evals-freenode-#perlbot.lst[1215]: [ sprintf('%b', 4), sprintf('%b', 4 << 1) ]
evals/evals-freenode-#perlbot.lst[1216]: [ sprintf '%.f', 8.5 ]
evals/evals-freenode-#perlbot.lst[1217]: [ sprintf '%.f', 8.5, 11.5 ]
evals/evals-freenode-#perlbot.lst[1218]: $_ = '@@@'; s'@'$'r; 
evals/evals-freenode-#perlbot.lst[1219]: srand 42; my @o = chr(0x202d, 0x202e); print "$o[rand 2]$_" for 'a'..'z', '_';
evals/evals-freenode-#perlbot.lst[1220]: srand 42; my @o = ("\x202d", "\x202e"); print "$o[rand 2]$_" for 'a'..'z', '_';
evals/evals-freenode-#perlbot.lst[1221]: $_ = "stackoverflow"; reverse 'catsoverflow'
evals/evals-freenode-#perlbot.lst[1222]: $_ = "stackoverflow"; reverse 'wolfrevostac'
evals/evals-freenode-#perlbot.lst[1223]: state $x;
evals/evals-freenode-#perlbot.lst[1224]: state $x; ++$x
evals/evals-freenode-#perlbot.lst[1225]: $_ = "STDERR output success\nSTDERR output fsuccess\n";  /^STDERR output success(?=.(?!STDERR output success))/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1226]: $_ = "STDERR output success\nSTDERR output success\n";  /^STD42ERR output success(?!STDERR output success)/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1227]: $_ = "STDERR output success\nSTDERR output success\n";  /^STDERR output success(?=\nSTDERR output success)/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1228]: $_ = "STDERR output success\nSTDERR output success\n";  /^STDERR output success(?!\nSTDERR output success)/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1229]: $_ = "STDERR output success\nSTDERR output success\n";  /^STDERR output success(?!.*STDERR output success)/s ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1230]: $_ = "STDERR output success\nSTDERR output success\n";  /^STDERR output success.*?(?!STDERR output success)/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1231]: $_ = "STDERR output success\nSTDERR output success\n";  /^STDERR output success.*(?!STDERR output success)/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1232]: $_ = "STDERR output success\nSTDERR output success\n";  /^STDERR output success(?=.(?!STDERR output success))/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1233]: $_ = "STDERR output success\nSTDERR output success\n";  /^STDERR output success(?=.*(?!STDERR output success))/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1234]: $_ = "STDERR output success\nSTDERR output success\n";  /^STDERR output success(?=STDERR output success)/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1235]: $_ = "STDERR output success\nSTDERR output success\n";  /^STDERR output success(?!.*STDERR output success)/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1236]: $_ = "STDERR output success\nSTDERR output success\n";  /^STDERR output success(?!.+STDERR output success)/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1237]: $_ = "STDERR output success\nSTDERR output success\n";  /^STDERR output success(?!.+STDERR output success))/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1238]: $_ = "STDERR output success\nSTDERR output success\n";  /^STDERR output success(?!STDERR output success)/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1239]: $_ = "STDERR output success\nSTDERR output success\n";  /^STDERR output success(?.*(?!STDERR output success))/ ? 'y' : 'n'
evals/evals-freenode-#perlbot.lst[1240]: sub add ( $x = return 0, $y = return $x ) { return $x + $y }   [ add(), add(2), add(2,3), add(2,3,4) ]
evals/evals-freenode-#perlbot.lst[1241]: sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/ }; fizz(), buzz();
evals/evals-freenode-#perlbot.lst[1242]: sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/, " " }; for(1..100) { undef($f), fizz() if 2 == ++$f; undef($b), buzz() if 4 == ++$b; $f && $b || &{$_}() }
evals/evals-freenode-#perlbot.lst[1243]: sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/, " " }; for(1..100) { undef($f), fizz() if 2 == ++$f; undef($b), buzz() if 4 == ++$b; $f && $b && nope(); &{$_}() }
evals/evals-freenode-#perlbot.lst[1244]: sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/, " " }; for(1..100) { undef($f), fizz() if 2 == ++$f; undef($b), buzz() if 4 == ++$b; $f && $b or nope(); &{$_}() }
evals/evals-freenode-#perlbot.lst[1245]: sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/ }; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b || &{$_}() }
evals/evals-freenode-#perlbot.lst[1246]: sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/ }; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b && &{$_}(); &{" "}() }
evals/evals-freenode-#perlbot.lst[1247]: sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/ }; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b && &$_; &{" "} }
evals/evals-freenode-#perlbot.lst[1248]: sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/, " " }; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b || &{$_}() }
evals/evals-freenode-#perlbot.lst[1249]: sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/, " " }; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b && &{$_}() }
evals/evals-freenode-#perlbot.lst[1250]: sub AUTOLOAD { print $AUTOLOAD =~ /::(.*)/, " " }; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b && nope(); &{$_}() }
evals/evals-freenode-#perlbot.lst[1251]: sub AUTOLOAD { print "hi" } 'foo'->();
evals/evals-freenode-#perlbot.lst[1252]: sub AUTOLOAD { print "hi" } ${*foo}->();
evals/evals-freenode-#perlbot.lst[1253]: sub AUTOLOAD { print "hi" } foo();
evals/evals-freenode-#perlbot.lst[1254]: sub AUTOLOAD { print "hi" } main->foo();
evals/evals-freenode-#perlbot.lst[1255]: sub AUTOLOAD { print "hi" } $x=\*foo; (&$x)->();
evals/evals-freenode-#perlbot.lst[1256]: sub AUTOLOAD { print "hi" } $x=\*foo; $x->();
evals/evals-freenode-#perlbot.lst[1257]: sub AUTOLOAD { print "hi" } $x=\*foo; &$x->();
evals/evals-freenode-#perlbot.lst[1258]: sub AUTOLOAD { print "hi" } $x = *foo; $x->();
evals/evals-freenode-#perlbot.lst[1259]: sub AUTOLOAD { print "hi" } $x = *foo; &{$x}();
evals/evals-freenode-#perlbot.lst[1260]: sub AUTOLOAD { print "hi" } $x = \*foo; $x->();
evals/evals-freenode-#perlbot.lst[1261]: sub AUTOLOAD { print "hi" } $x = \*foo; *{$x}->();
evals/evals-freenode-#perlbot.lst[1262]: sub AUTOLOAD { print "hi" } $x = \*foo; &{$x}();
evals/evals-freenode-#perlbot.lst[1263]: sub AUTOLOAD { print "hi" } $x = \*foo; &{*$x}();
evals/evals-freenode-#perlbot.lst[1264]: sub AUTOLOAD { print "hi" } $x = *foo; *$x{CODE}->();
evals/evals-freenode-#perlbot.lst[1265]: sub AUTOLOAD { print "hi" } $x = \*foo; *$x{CODE}->();
evals/evals-freenode-#perlbot.lst[1266]: sub blah { !!@_ } [ blah, blah(1) ]
evals/evals-freenode-#perlbot.lst[1267]: sub bubsort { my $arr = shift; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i] } }
evals/evals-freenode-#perlbot.lst[1268]: sub bubsort { my $arr = shift; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i] }; $arr }; bubsort [ sort { rand(1) < .5 } 1..20 ]
evals/evals-freenode-#perlbot.lst[1269]: sub bubsort { my $arr = shift; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i] }; $arr }; bubsort [ sort { rand < .5 } 1..20 ]
evals/evals-freenode-#perlbot.lst[1270]: sub bubsort { my $arr = shift; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i] }; $arr }; [ sort { rand(1) < .5 } 1..20 ]
evals/evals-freenode-#perlbot.lst[1271]: sub Buffalo(;@) {return 1 if ($_[0] eq 'buffalo')}; sub buffalo {"buffalo"}; 
evals/evals-freenode-#perlbot.lst[1272]: sub Buffalo(;@) {return 1 if $_[0] eq 'buffalo'}; sub buffalo {"buffalo"}; 
evals/evals-freenode-#perlbot.lst[1273]: sub Buffalo(;@) {return 1;}; sub buffalo {"buffalo"}; 
evals/evals-freenode-#perlbot.lst[1274]: sub Buffalo(@) {return 1;}; sub buffalo {"buffalo"}; 
evals/evals-freenode-#perlbot.lst[1275]: sub chomp { 42 }; [chomp "x\n" ]
evals/evals-freenode-#perlbot.lst[1276]: sub chomp { "blah" }; [ chomp ]
evals/evals-freenode-#perlbot.lst[1277]: sub code; for \&code (sub { print 'ok' }) { say '[', code, ']' }
evals/evals-freenode-#perlbot.lst[1278]: sub *CORE::die { say "42"; } die  
evals/evals-freenode-#perlbot.lst[1279]: sub CORE::die { say "42"; } die  
evals/evals-freenode-#perlbot.lst[1280]: sub die { say "42"; } die  
evals/evals-freenode-#perlbot.lst[1281]: sub { 'FILE' = 42; } say $FILE;
evals/evals-freenode-#perlbot.lst[1282]: sub foo { [1..3], [a..c] }; my $x = foo;
evals/evals-freenode-#perlbot.lst[1283]: sub foo {} "->${ \\&foo }"
evals/evals-freenode-#perlbot.lst[1284]: sub foo { "foo [@_]" }; my @bar = ((bless []), 43); shift(@bar)->foo(@bar);
evals/evals-freenode-#perlbot.lst[1285]: sub foo {" Hello"}; undef &foo;
evals/evals-freenode-#perlbot.lst[1286]: sub foo {" Hello"}; undef &foo; foo()
evals/evals-freenode-#perlbot.lst[1287]: sub foo :lvalue { print "FOO!" }  undef &foo; foo()
evals/evals-freenode-#perlbot.lst[1288]: sub foo { }; my $stash = \%main:: ; [ $stash->{'foo'} ]
evals/evals-freenode-#perlbot.lst[1289]: sub foo { }; my $stash = \%main:: ; [ *{$stash->{'foo'}}{CODE} ]
evals/evals-freenode-#perlbot.lst[1290]: sub foo { }; my $stash = \%main:: ; [ *{$stash->{foo}}{CODE} ]
evals/evals-freenode-#perlbot.lst[1291]: sub foo { }; my $stash = \%main:: ; [ *{$stash->{temp}}{CODE} ]
evals/evals-freenode-#perlbot.lst[1292]: sub foo { my $x = 1; use constant FOO => \$x; 2 }; [ foo, FOO ];
evals/evals-freenode-#perlbot.lst[1293]: sub foo { my $x = 1; use constant FOO => \$x }; [ foo, FOO ];
evals/evals-freenode-#perlbot.lst[1294]: sub foo { my @xs = "a" .. "c"; return ("X", "Y", @xs); }  my $x = foo; $x
evals/evals-freenode-#perlbot.lst[1295]: sub foo { my $x = shift; use constant FOO => \$x; 42 }; [ foo(1) ];
evals/evals-freenode-#perlbot.lst[1296]: sub foo { my $x = shift; use constant FOO => \$x; 42 }; [ foo(1), ${ FOO() } ];
evals/evals-freenode-#perlbot.lst[1297]: sub foo { my $x = shift; use constant FOO => \$x; 42 }; [ foo(1), ${ FOO() }, foo(2) ];
evals/evals-freenode-#perlbot.lst[1298]: sub foo { my $x = shift; use constant FOO => \$x; 42 }; my @a = foo(1), @{FOO()}; my @b = foo(2), @{FOO()}; [ @a, @b ];
evals/evals-freenode-#perlbot.lst[1299]: sub foo { my $x = shift; use constant FOO => \$x; 42 }; my @a = foo(1), ${FOO()}; my @b = foo(2), ${FOO()}; [ @a, @b ];
evals/evals-freenode-#perlbot.lst[1300]: sub foo { my $x = shift; use constant FOO => \$x; () }; [ foo(1), ${ FOO() }, foo(2), ${ FOO() } ];
evals/evals-freenode-#perlbot.lst[1301]: sub foo { my $x = shift; use constant FOO => \$x; ${ &{'FOO'}() } }; [ foo(1), foo(2) ];
evals/evals-freenode-#perlbot.lst[1302]: sub foo { my $x = shift; use constant FOO => \$x; &{'FOO'}() }; [ foo(1), foo(2) ];
evals/evals-freenode-#perlbot.lst[1303]: sub foo { my @z = (1, 2, 3); my @y = qw<a b c>; return \@z, \@y; } my $x = foo(); $x
evals/evals-freenode-#perlbot.lst[1304]: sub foo { print "FOO!" }  foo()
evals/evals-freenode-#perlbot.lst[1305]: sub foo { print "FOO!" }  undef &foo; foo()
evals/evals-freenode-#perlbot.lst[1306]: sub foo (\@) { say @_ };
evals/evals-freenode-#perlbot.lst[1307]: sub foo (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) { say @_ };
evals/evals-freenode-#perlbot.lst[1308]: sub foo (\@) { say @_ }; foo +(split //, "foobar")
evals/evals-freenode-#perlbot.lst[1309]: sub foo (;$) { say "[@_]"; }; my %h = ( bar => foo(42), meow => 'moo' ); \%h
evals/evals-freenode-#perlbot.lst[1310]: sub foo { say "[@_]"; }; my %h = ( bar => foo(42), meow => 'moo' ); \%h
evals/evals-freenode-#perlbot.lst[1311]: sub foo(;$) { say "[@_]"; }; my %h = ( bar => foo 42, meow => 'moo' ); \%h
evals/evals-freenode-#perlbot.lst[1312]: sub foo(;$) { say "[@_]"; }; my %h = ( bar => foo(42), meow => 'moo' ); \%h
evals/evals-freenode-#perlbot.lst[1313]: sub foo($) { say "[@_]"; }; my %h = ( bar => foo(42), meow => 'moo' ); \%h
evals/evals-freenode-#perlbot.lst[1314]: sub foo { shift }; @_ = 'a'..'d'; &foo; [ @_ ]
evals/evals-freenode-#perlbot.lst[1315]: sub foo {shift} { foo => 'bar' }->${ \\&foo }
evals/evals-freenode-#perlbot.lst[1316]: sub foo { state $foo = time; $foo }; [ foo, foo, foo]
evals/evals-freenode-#perlbot.lst[1317]: sub foo { wantarray ? 'foos' : 'bars' }  [ () = foo ]
evals/evals-freenode-#perlbot.lst[1318]: sub j { !( $_[0] && $_[1] ) }  sub p { !($_[0] || $_[1]) } [ map [j($_->[0], $_->[1]), p($_->[0], $_->[1])], [0, 0], [1, 0], [1, 1], [0, 1] ]
evals/evals-freenode-#perlbot.lst[1319]: sub List::Util::0sum {"Hello World"};
evals/evals-freenode-#perlbot.lst[1320]: sub List::Util::0sum {"Hello World"}; List::Util::0sum()
evals/evals-freenode-#perlbot.lst[1321]: sub List::Util::0sum {my ($a, $b)=(0,0); $a+=$_, $b-=$_ for @_; ($a, $b)}; [List::Util::0sum(1,2,3,4,5)]
evals/evals-freenode-#perlbot.lst[1322]: sub o { (!$_[0]) && (!$_[1]) } sub j { !( $_[0] && $_[1] ) }  sub p { !($_[0] || $_[1]) } [ map [j($_->[0], $_->[1]), j($_->[0], $_->[1]), p($_->[0], $_->[1])], [0, 0], [1, 0], [1, 1], [0, 1] ]
evals/evals-freenode-#perlbot.lst[1323]: sub o { ((!$_[0]) && (!$_[1])) } sub j { !( ($_[0] && $_[1]) ) }  sub p { !($_[0] || $_[1]) } [ map [j($_->[0], $_->[1]), j($_->[0], $_->[1]), p($_->[0], $_->[1])], [0, 0], [1, 0], [1, 1], [0, 1] ]
evals/evals-freenode-#perlbot.lst[1324]: sub _ { print /::(.*)/ }; *AUTOLOAD = *_; for(1..100) { $f=0, fizz() if 3 == ++$f; $b=0, buzz() if 5 == ++$b; $f && $b && &$_; &{" "} }
evals/evals-freenode-#perlbot.lst[1325]: sub _ { print /::(.*)/ }; *_ = *AUTOLOAD; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b && &$_; &{" "} }
evals/evals-freenode-#perlbot.lst[1326]: sub _ { print /::(.*)/ }; *AUTOLOAD = *_; for(1..100) { undef($f), fizz() if 3 == ++$f; undef($b), buzz() if 5 == ++$b; $f && $b && &$_; &{" "} }
evals/evals-freenode-#perlbot.lst[1327]: sub _ { print /::(.*)/ }; *AUTOLOAD = *_; for(1..50) { $f=0, fizz() if 3 == ++$f; $b=0, buzz() if 5 == ++$b; $f && $b && &$_; &{" "} }
evals/evals-freenode-#perlbot.lst[1328]: sub _ { print /::(.*)/, ' ' }; *AUTOLOAD = *_; Just(), another(), Perl(), &{"hacker,"};
evals/evals-freenode-#perlbot.lst[1329]: sub proc ( $ & ) {}; [ proc 'foo', {; } ]
evals/evals-freenode-#perlbot.lst[1330]: sub proc ( $ & ) {}; [ proc 'foo', {;} ]
evals/evals-freenode-#perlbot.lst[1331]: sub proc ( $ & ) {}; [ proc 'foo', {} ]
evals/evals-freenode-#perlbot.lst[1332]: sub proc ( $ & ) {}; [ proc 'foo', +{} ]
evals/evals-freenode-#perlbot.lst[1333]: sub proc ( $ & ) {}; [ proc 'foo', { 42} ]
evals/evals-freenode-#perlbot.lst[1334]: sub proc ( $ & ) {}; [ proc 'foo', {; 42} ]
evals/evals-freenode-#perlbot.lst[1335]: sub proc ( $ & ) {}; [ proc 'foo', { 42; 45; } ]
evals/evals-freenode-#perlbot.lst[1336]: sub ps(&@) { my $c = shift; my $p = ''; while(1) { my $i = 0; 1 until ++vec $p, $i++, 8; return if vec $p, @_, 1; $c->(@_[grep vec $p, $_, 1], 0..$#_]) } }
evals/evals-freenode-#perlbot.lst[1337]: sub ps(&@) { my $c = shift; my $p = ''; while(1) { my $i = 0; 1 until ++vec $p, $i++, 8; return if vec $p, @_, 1; $c->(@_[grep vec($p, $_, 1), 0..$#_]) } }; my @a;ps { push @a, "@_" } 'a'..'c'; \@a
evals/evals-freenode-#perlbot.lst[1338]: sub ps(&@) { my $c = shift; my $p = ''; while(1) { my $i = 0; 1 until ++vec $p, $i++, 8; return if vec $p, @_, 1; $c->(@_[grep vec($p, $_, 1), 0..$#_]) } }; my @a;ps { push @a, "@_" } 'a'..'d'; \@a
evals/evals-freenode-#perlbot.lst[1339]: sub ps(&@) { my $c = shift; my $p = ''; while(1) { my $i = 0; 1 until ++vec $p, $i++, 8; return if vec $p, @_, 1; $c->(@_[grep vec $p, $_, 1], 0..$#_]) } }; my @a;ps { push @a, \@_ } 'a'..'e'; \@a
evals/evals-freenode-#perlbot.lst[1340]: sub ps(&@) { my $c = shift; my $p = ''; while(1) { my $i = 0; 1 until ++vec $p, $i++, 8; return if vec $p, @_, 1; $c->(@_[grep vec($p, $_, 1), 0..$#_]) } }; my @a;ps { push @a, "@_" } 'a'..'e'; \@a
evals/evals-freenode-#perlbot.lst[1341]: sub ps(&@) { my $c = shift; my $p = ''; while(1) { my $i = 0; 1 until ++vec $p, $i++, 8; return if vec $p, @_, 1; $c->(@_[grep vec($p, $_, 1), 0..$#_]) } }; my @a;ps { push @a, \@_ } 'a'..'e'; \@a
evals/evals-freenode-#perlbot.lst[1342]: sub { @_ = qw/foo bar baz/; } my @z = 1..10; sub @z; \@z
evals/evals-freenode-#perlbot.lst[1343]: substr 'foo', 0, -1
evals/evals-freenode-#perlbot.lst[1344]: substr 'foo', -1
evals/evals-freenode-#perlbot.lst[1345]: sub TIEHANDLE { [] }; sub AUTOLOAD { print "In autoload!"; 42 }; tie *FH, 'main'; [ scalar <FH> ];
evals/evals-freenode-#perlbot.lst[1346]: sub TIEHANDLE { [] }; sub READLINE { "asdf" }; sub AUTOLOAD { print "In autoload!"; 42 }; tie *FH, 'main'; [ scalar <FH> ];
evals/evals-freenode-#perlbot.lst[1347]: sub TIEHANDLE { [] }; sub READLINE { "asdf" }; sub AUTOLOAD { print "In autoload!"; 42 }; tie *FH, 'main'; [ scalar readline FH ];
evals/evals-freenode-#perlbot.lst[1348]: sub TIEHANDLE { [] }; sub READLINE; sub AUTOLOAD { print "In autoload!"; 42 }; tie *FH, 'main'; [ scalar <FH> ];
evals/evals-freenode-#perlbot.lst[1349]: sub TIEHANDLE { [] }; tie *FH, 'main'; [ print FH "foo" ];
evals/evals-freenode-#perlbot.lst[1350]: sub TIEHANDLE { [] }; tie *FH, 'main'; print FH "foo";
evals/evals-freenode-#perlbot.lst[1351]: sub TIEHANDLE { [] }; tie *FH, 'main'; [ scalar <FH> ];
evals/evals-freenode-#perlbot.lst[1352]: sub TIEHASH { bless [] }; sub FETCH { __FILE__ }; BEGIN { tie %INC, 'main' }; sub UNIVERSAL::import { print "import @_" }; use How::Strange;
evals/evals-freenode-#perlbot.lst[1353]: sub TIEHASH { bless [] }; sub FETCH { __FILE__ }; BEGIN { tie %INC, 'main' }; sub UNIVERSAL::import { print "@_" }; use How::Strange;
evals/evals-freenode-#perlbot.lst[1354]: sub TIEHASH { bless [] }; sub FETCH { __FILE__ }; BEGIN { tie %INC, 'main' }; use How::Strange;
evals/evals-freenode-#perlbot.lst[1355]: sub TIEHASH { bless [] }; sub FETCH { __FILE__ }; [ (tie %INC, 'main'), require WhatDoesThisDo ]
evals/evals-freenode-#perlbot.lst[1356]: sub UNIVERSAL::maybe {$class=shift; rand() > 0.5 ? $class->new() : undef}; package bar { sub new {"Hello World"};}; bar->maybe()
evals/evals-freenode-#perlbot.lst[1357]: sub UNIVERSAL::maybe {rand() > 0.5 ? __PACKAGE__->new() : undef}; package bar { sub new {"Hello World"};}; bar->maybe()
evals/evals-freenode-#perlbot.lst[1358]: sub use constant foo::bar => 42; foo::bar
evals/evals-freenode-#perlbot.lst[1359]: sub x { my $params ||= '0' || '0'; $params } [ x(42), x(43) ]
evals/evals-freenode-#perlbot.lst[1360]: sub x { my $params ||= '0' || 'b'; $params } [ x(42), x(43) ]
evals/evals-freenode-#perlbot.lst[1361]: sub x { my $params ||= '0' || undef; $params } [ x(42), x(43) ]
evals/evals-freenode-#perlbot.lst[1362]: sub x { my $params ||= 'a' || 'b'; $params } [ x(42), x(43) ]
evals/evals-freenode-#perlbot.lst[1363]: sub x { my $params ||= shift; $params } [ x(42), x(43) ]
evals/evals-freenode-#perlbot.lst[1364]: sub x { @_ = qw/foo bar baz/; } my @z = 1..10; x @z; \@z
evals/evals-freenode-#perlbot.lst[1365]: sub z { }  z('∴')
evals/evals-freenode-#perlbot.lst[1366]: sub z { }  z(∴)
evals/evals-freenode-#perlbot.lst[1367]: sub π { atan2(1,1) * 4; } say π
evals/evals-freenode-#perlbot.lst[1368]: '	' =~ /\t/
evals/evals-freenode-#perlbot.lst[1369]: "test"
evals/evals-freenode-#perlbot.lst[1370]: "test123Wow" =~ /^.*(\d+).*$/g; $1
evals/evals-freenode-#perlbot.lst[1371]: *{'$::test'} = sub { 1 }; [ '$'->test ]
evals/evals-freenode-#perlbot.lst[1372]: ("the real life", "just fantasy")["is this"]
evals/evals-freenode-#perlbot.lst[1373]: [ time ]
evals/evals-freenode-#perlbot.lst[1374]:  'trg uggc|||vtabenagqrfvtare.pbz|wncu.ugzy' =~ y☻n-za-m|☻a-z:/☻r 
evals/evals-freenode-#perlbot.lst[1375]:  'trg uggc.||vtabenagqrfvtare.pbz|wncu.ugzy' =~ y☻n-za-m.|☻a-z:/☻r 
evals/evals-freenode-#perlbot.lst[1376]: 'trg uggcX||vtabenagqrfvtare.pbz|wncu.ugzy //obql' =~ y☻n-za-mX|☻a-z:/☻r
evals/evals-freenode-#perlbot.lst[1377]: try {foo}
evals/evals-freenode-#perlbot.lst[1378]: try {print "hw"
evals/evals-freenode-#perlbot.lst[1379]: try {print "hw"}
evals/evals-freenode-#perlbot.lst[1380]: try {print "hw"} catch {die "foo"}
evals/evals-freenode-#perlbot.lst[1381]: ($two4s, $delta, $secs)
evals/evals-freenode-#perlbot.lst[1382]:  'uggc|||vtabenagqrfvtare.pbz|wncu.ugzy' =~ y☻n-za-m.|☻a-z:/☻r 
evals/evals-freenode-#perlbot.lst[1383]:  'uggc.||vtabenagqrfvtare.pbz|wncu.ugzy' =~ y☻n-za-m.|☻a-z:/☻r 
evals/evals-freenode-#perlbot.lst[1384]:  'uggcX||vtabenagqrfvtare.pbz|wncu.ugzy' =~ y☻n-za-mX|☻a-z:/☻r 
evals/evals-freenode-#perlbot.lst[1385]: undef < 0
evals/evals-freenode-#perlbot.lst[1386]: [\undef, \undef]
evals/evals-freenode-#perlbot.lst[1387]: UNITCHECK { print 'ok' }; 42;
evals/evals-freenode-#perlbot.lst[1388]: [UNIVERSAL->can('import')]
evals/evals-freenode-#perlbot.lst[1389]: unless( $a or $b ){}
evals/evals-freenode-#perlbot.lst[1390]: unless( a or b ){}
evals/evals-freenode-#perlbot.lst[1391]: [ unpack '(A3)*', 'abcdefghi' ]
evals/evals-freenode-#perlbot.lst[1392]: [unpack "a*", "Hello World"]
evals/evals-freenode-#perlbot.lst[1393]: unpack "b*",(pack "d", 0.1)
evals/evals-freenode-#perlbot.lst[1394]: [ unpack 'C3', 'abcdefghi' ]
evals/evals-freenode-#perlbot.lst[1395]: [unpack "c*", "Hello World"]
evals/evals-freenode-#perlbot.lst[1396]: [unpack "c*", "Hello World☃ "]
evals/evals-freenode-#perlbot.lst[1397]: [unpack "C*", "Hello World☃ "]
evals/evals-freenode-#perlbot.lst[1398]: unpack "d", "0.1"
evals/evals-freenode-#perlbot.lst[1399]: unpack "d", 0.1
evals/evals-freenode-#perlbot.lst[1400]: unpack "D", "0.1"
evals/evals-freenode-#perlbot.lst[1401]: unpack("H*", (4095 & 0xFF00) >> 8);
evals/evals-freenode-#perlbot.lst[1402]: unpack("H*", chr 4095);
evals/evals-freenode-#perlbot.lst[1403]: unpack("H*", pack("C*", 0xFA, 15, 255))
evals/evals-freenode-#perlbot.lst[1404]: unpack("H*", pack("C*", 0xFA, (3192 & 0x0F00) >> 8, 255))
evals/evals-freenode-#perlbot.lst[1405]: unpack "h*", pack "d", 0.1
evals/evals-freenode-#perlbot.lst[1406]: unpack "h*",(pack "d", 0.1)
evals/evals-freenode-#perlbot.lst[1407]: URI->new('/product/IDHEREFUCKER');
evals/evals-freenode-#perlbot.lst[1408]: use 10;
evals/evals-freenode-#perlbot.lst[1409]: use 5.008; You know what I like about perl? It's the fact that this English sentence is perfectly parsable!
evals/evals-freenode-#perlbot.lst[1410]: use 5.008; You know what I like about perl? It's the fact that this English sentence is perfectly parsable! Some may say: "no way", but I got deparse to prove it
evals/evals-freenode-#perlbot.lst[1411]: use 5.010; for( 1..3 ) { my $x = sub { state $x = 5; print $x++ }; $x->() for 1..4 }
evals/evals-freenode-#perlbot.lst[1412]: use 5.010; for( 1..3 ) { sub { state $x = 5; print $x++ }->() }
evals/evals-freenode-#perlbot.lst[1413]: use 5.010; my $x; sub foo { ++$foo }; [ foo, foo, foo ]
evals/evals-freenode-#perlbot.lst[1414]: use 5.010; my $x; sub foo :lvalue { ++$foo }; [ foo, foo, foo ]
evals/evals-freenode-#perlbot.lst[1415]: use 5.010; my $x; [ ++$x,++$x,++$x ]
evals/evals-freenode-#perlbot.lst[1416]: use 5.010; say `ls -a`;
evals/evals-freenode-#perlbot.lst[1417]: use 5.010; say sort { $|-- or -1 } 'ruJt tc,en hoetokarrasS h' =~ /./g
evals/evals-freenode-#perlbot.lst[1418]: use 5.010; sub foo :lvalue { state $foo = shift; @_ and $foo = shift;$foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo("zof!"), foo, foo]
evals/evals-freenode-#perlbot.lst[1419]: use 5.010; sub foo { state $foo = do { print "TEST" }; @_ and $foo = shift; $foo }; [ foo, foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo("zof!"), foo, foo]
evals/evals-freenode-#perlbot.lst[1420]: use 5.010; sub foo { ++state $foo }; [ foo, foo, foo ]
evals/evals-freenode-#perlbot.lst[1421]: use 5.010; sub foo { state $foo = shift; @_ and $foo = 42;$foo }; [ foo(41), , foo(1), foo]
evals/evals-freenode-#perlbot.lst[1422]: use 5.010; sub foo { state $foo = shift; @_ and $foo = 42;$foo }; [ foo(41), foo, foo]
evals/evals-freenode-#perlbot.lst[1423]: use 5.010; sub foo { state $foo = shift; @_ and $foo = 42;$foo }; [ foo(41), foo , foo(1), foo]
evals/evals-freenode-#perlbot.lst[1424]: use 5.010; sub foo { state $foo = shift; @_ and $foo = 42;$foo }; [ foo, foo, foo]
evals/evals-freenode-#perlbot.lst[1425]: use 5.010; sub foo { state $foo = shift; @_ and $foo = shift;$foo }; [ foo(41), foo , foo(1), foo]
evals/evals-freenode-#perlbot.lst[1426]: use 5.010; sub foo { state $foo = shift; @_ and $foo = shift;$foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo("zof!"), foo, foo]
evals/evals-freenode-#perlbot.lst[1427]: use 5.010; sub foo { state $foo = shift; $foo = shift;$foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo("zof!"), foo, foo]
evals/evals-freenode-#perlbot.lst[1428]: use 5.010; sub foo { state $foo = time; $foo }; [ foo, foo, foo]
evals/evals-freenode-#perlbot.lst[1429]: use 5.010; sub foo { state $foo = time; sleep 1;$foo }; [ foo, foo, foo]
evals/evals-freenode-#perlbot.lst[1430]: use 5.010; sub spin { state $t = time; my $c = 0; ++$c while $t >= time; ++$t; $c }; [ map spin, 1..10 ]
evals/evals-freenode-#perlbot.lst[1431]: use 5.010; sub spin { state $t = time; my $c = 0; ++$c while $t >= time; ++$t; $c }; [ map spin, 1..4 ]
evals/evals-freenode-#perlbot.lst[1432]: use 5.010; sub spin { state $t = time; my $c = 0; ++$c while $t >= time; ++$t; $c }; [ map spin, 1..6 ]
evals/evals-freenode-#perlbot.lst[1433]: use 5.010; sub spin { state $t = time; my $c = 0; ++$c while $t >= time; ++$t; $c }; [ spin, spin, spin ]
evals/evals-freenode-#perlbot.lst[1434]: use 5.010; sub spin { state $t = time; my $c = 0; ++$c while $t >= time; ++$t }; [ spin, spin, spin ]
evals/evals-freenode-#perlbot.lst[1435]: use 5.020; for ( [qw/foo bar/]->@* ) { print}
evals/evals-freenode-#perlbot.lst[1436]: use 5.020; for ( [qw/foo bar/]->*@ ) { print}
evals/evals-freenode-#perlbot.lst[1437]: use 5.020; my $x = \42; $x->$*
evals/evals-freenode-#perlbot.lst[1438]: use 5.020; sub add ($x = return 0, $y = return $x) { return $x + $y }   [ add(), add(2), add(2,3)  ]
evals/evals-freenode-#perlbot.lst[1439]: use 5.020; sub add ( $x = return 0, $y = return $x ) { return $x + $y }   [ add(), add(2), add(2,3), add(2,3,4) ]
evals/evals-freenode-#perlbot.lst[1440]: use 5.020; sub add ($x = return 0, $y = return $x) { return $x + $y }   [ add(), add(2), add(2,3), add(2,3,4) ]
evals/evals-freenode-#perlbot.lst[1441]: use 5.020; use feature 'postderef'; no warnings 'experimental::postderef'; for ( [qw/foo bar/]->@* ) { print}
evals/evals-freenode-#perlbot.lst[1442]: use 5.08; You know what I like about perl? It's the fact that this English sentence is perfectly parsable! Some may say: "no way", but I got deparse to prove it
evals/evals-freenode-#perlbot.lst[1443]: use 5.10; sub foo { state $foo = time; $foo }; [ foo, foo, foo]
evals/evals-freenode-#perlbot.lst[1444]: use 5.20; my $x = \42; $x->$*
evals/evals-freenode-#perlbot.lst[1445]: use 6;
evals/evals-freenode-#perlbot.lst[1446]: use 999;
evals/evals-freenode-#perlbot.lst[1447]: use bigint; 1e1000
evals/evals-freenode-#perlbot.lst[1448]: use Carp;
evals/evals-freenode-#perlbot.lst[1449]: use Carp 9;
evals/evals-freenode-#perlbot.lst[1450]: use Carp::croak("loaded")
evals/evals-freenode-#perlbot.lst[1451]: use charnames (); [ charnames::viacode 0x92 ]
evals/evals-freenode-#perlbot.lst[1452]: use constant ARRAY => [qw(one two three)]; [ $::{ARRAY} ]
evals/evals-freenode-#perlbot.lst[1453]: use constant ARRAY => [qw(one two three)]; $::{ARRAY}
evals/evals-freenode-#perlbot.lst[1454]: use constant ARRAY => [qw(one two three)]; ${$::{ARRAY}}
evals/evals-freenode-#perlbot.lst[1455]: use constant foo::bar => 42; foo::bar
evals/evals-freenode-#perlbot.lst[1456]: use constant FOO => 'BAR!'; BEGIN { say FOO }
evals/evals-freenode-#perlbot.lst[1457]: use constant FOO => 'BAR!'; BEGIN say { FOO }
evals/evals-freenode-#perlbot.lst[1458]: use constant FOO => 'BAR!'; our $dir = FOO; BEGIN { say FOO } say $dir
evals/evals-freenode-#perlbot.lst[1459]: use constant FOO => 'BAR!'; our $dir = FOO; BEGIN { say FOO } say "Moar $dir!"
evals/evals-freenode-#perlbot.lst[1460]: use constant foo => bar; package bar; sub baz { 'quux' }; package main; [ baz { foo } ];
evals/evals-freenode-#perlbot.lst[1461]: use constant foo => bar; package bar; sub baz { 'quux' }; package main; [ baz { foo() } ];
evals/evals-freenode-#perlbot.lst[1462]: use constant foo => bar; package bar; sub baz { 'quux' }; package main; [ baz foo ];
evals/evals-freenode-#perlbot.lst[1463]: use constant foo => bar; package bar; sub baz() { 'quux' }; package main; [ baz { foo } ];
evals/evals-freenode-#perlbot.lst[1464]: use constant foo => bar; package bar; sub baz() { 'quux' }; package main; [ baz { foo() } ];
evals/evals-freenode-#perlbot.lst[1465]: use constant foo => bar; package bar; sub baz() { 'quux' }; package main; [ baz foo ];
evals/evals-freenode-#perlbot.lst[1466]: use constant foo => 'ok'; *main::{foo};
evals/evals-freenode-#perlbot.lst[1467]: use constant list => qw(a b c); [list[2]]
evals/evals-freenode-#perlbot.lst[1468]: use constant list => qw(a b c); list->[2]
evals/evals-freenode-#perlbot.lst[1469]: use constant one => 1; BEGIN { &Internals::SvREADONLY(\one, 0); ++${ \one } }; say one;
evals/evals-freenode-#perlbot.lst[1470]: use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); for my \%hash (@a) {print Dumper(%hash);}
evals/evals-freenode-#perlbot.lst[1471]: use Devel::Peek qw,SvREFCNT,;
evals/evals-freenode-#perlbot.lst[1472]: use Encode;
evals/evals-freenode-#perlbot.lst[1473]: use Encode; [Encode->encodings()];
evals/evals-freenode-#perlbot.lst[1474]: use Encode; print encode 'utf8', 'get http://ignorantdesigner.com/japh.html' =~ y • a-z:/ • n-za-m☃ •r 
evals/evals-freenode-#perlbot.lst[1475]: use experimental 'postderef'; my $x; $x->$@
evals/evals-freenode-#perlbot.lst[1476]: use experimental 'postderef'; my $x;  @{ $x || [] }; $x->@*
evals/evals-freenode-#perlbot.lst[1477]: use experimental 'postderef'; my $x;  @{ $x || [] }; $x->$@
evals/evals-freenode-#perlbot.lst[1478]: use experimental 'postderef'; my @z = 1..10; $z->$#
evals/evals-freenode-#perlbot.lst[1479]: use experimental 'postderef'; my $z =[ 1..10]; $z->$*#
evals/evals-freenode-#perlbot.lst[1480]: use experimental 'postderef'; my $z =[ 1..10]; $z->$#
evals/evals-freenode-#perlbot.lst[1481]: use experimental 'postderef'; my $z =[ 1..10]; $z->$#*
evals/evals-freenode-#perlbot.lst[1482]: use experimental 'postderef'; undef->$@
evals/evals-freenode-#perlbot.lst[1483]: use feature ':all'; sub add (@) { __CODE__->(1,2) }   [ add(), add(2), add(2,3)  ]
evals/evals-freenode-#perlbot.lst[1484]: use feature ':all'; sub add (__CODE__->(2,2)) { }   [ add(), add(2), add(2,3)  ]
evals/evals-freenode-#perlbot.lst[1485]: use feature ':all'; sub add (@) { __SUB__->(1,2) }   [ add(), add(2), add(2,3)  ]
evals/evals-freenode-#perlbot.lst[1486]: use feature ':all'; sub add (__SUB__->(2,2)) { }   [ add(), add(2), add(2,3)  ]
evals/evals-freenode-#perlbot.lst[1487]: use feature ':all'; sub add ($x = return 0, $y = return $x) { return $x + $y }   [ add(), add(2), add(2,3)  ]
evals/evals-freenode-#perlbot.lst[1488]: use feature 'postderef'; \(42)->$*
evals/evals-freenode-#perlbot.lst[1489]: use feature 'postderef'; \42->$*
evals/evals-freenode-#perlbot.lst[1490]: use feature 'postderef'; for my $i (1..10) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]
evals/evals-freenode-#perlbot.lst[1491]: use feature 'postderef'; for my $i (1..10) {push @a, [(1) x (1024*1024)]}; sleep 15; [scalar(@a), scalar($a[0]->@*)]
evals/evals-freenode-#perlbot.lst[1492]: use feature 'postderef'; for my $i (1..15) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]
evals/evals-freenode-#perlbot.lst[1493]: use feature 'postderef'; for my $i (1..30) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]
evals/evals-freenode-#perlbot.lst[1494]: use feature 'postderef'; for my $i (1..5) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]
evals/evals-freenode-#perlbot.lst[1495]: use feature 'postderef'; my $a; ++$a->$ ;[ $a ]
evals/evals-freenode-#perlbot.lst[1496]: use feature 'postderef'; my $aref = \['x']; $$aref->[0]
evals/evals-freenode-#perlbot.lst[1497]: use feature q,postderef,; my $x = 42; my $y = \$x; [ \$x, \$y->$* ]
evals/evals-freenode-#perlbot.lst[1498]: use feature q,postderef,; my $x = 42; my $y = \$x; [ \$x, \++$y->$* ]
evals/evals-freenode-#perlbot.lst[1499]: use feature 'say'; say "!(0 || 1 && (0 || 0)) && !(1 && 1)"
evals/evals-freenode-#perlbot.lst[1500]: use feature 'signatures'; sub add (__SUB__->(2,2)) { }   [ add(), add(2), add(2,3)  ]
evals/evals-freenode-#perlbot.lst[1501]: use feature 'signatures'; sub add ($x = 0, $y = 0) { return $x + $y }   [ add(), add(2), add(2,3)  ]
evals/evals-freenode-#perlbot.lst[1502]: use feature 'signatures'; sub add ($x = return 0, $y = return $x) { return $x + $y }   [ add(), add(2), add(2,3)  ]
evals/evals-freenode-#perlbot.lst[1503]: use File::Basename;
evals/evals-freenode-#perlbot.lst[1504]: use File::Basename; [map +(fileparse $_)[1], "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
evals/evals-freenode-#perlbot.lst[1505]: use File::Basename; [map +(fileparse $_)[2], "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
evals/evals-freenode-#perlbot.lst[1506]: use File::Basename; [map +(fileparse $_, qr/(?<=.)[^.]+/)[1], "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
evals/evals-freenode-#perlbot.lst[1507]: use File::Basename; [map +(fileparse $_, qr/(?<=\.)[^.]+/)[1], "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
evals/evals-freenode-#perlbot.lst[1508]: use File::Basename; [map +(fileparse $_, qr/[^.]+/)[1], "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
evals/evals-freenode-#perlbot.lst[1509]: use File::Basename; [map +(fileparse $_, qr/(?<=\.)[^.]+/)[2], "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
evals/evals-freenode-#perlbot.lst[1510]: use File::Basename; [map +(fileparse $_, qr/[^.]+/)[2], "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
evals/evals-freenode-#perlbot.lst[1511]: use File::Basename qw/fileparse/; [map +(basename $_)[2], "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
evals/evals-freenode-#perlbot.lst[1512]: use File::Basename qw/fileparse/; [map +(basename$_)[2] "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
evals/evals-freenode-#perlbot.lst[1513]: use File::Spec; 
evals/evals-freenode-#perlbot.lst[1514]: use File::Spec; use CGI
evals/evals-freenode-#perlbot.lst[1515]: use JSON;
evals/evals-freenode-#perlbot.lst[1516]: use JSON::MaybeXS;
evals/evals-freenode-#perlbot.lst[1517]: use JSON::MaybeXS; JSON
evals/evals-freenode-#perlbot.lst[1518]: use JSON::MaybeXS; [ JSON() ]
evals/evals-freenode-#perlbot.lst[1519]: use JSON::MaybeXS; JSON()
evals/evals-freenode-#perlbot.lst[1520]: use JSON::MaybeXS; [ *main::JSON{CODE} ]
evals/evals-freenode-#perlbot.lst[1521]: use JSON::PP; no JSON::XS; no Cpanel::JSON::XS; use JSON::MaybeXS; JSON(); # Don't think this will work
evals/evals-freenode-#perlbot.lst[1522]: use JSON::XS;
evals/evals-freenode-#perlbot.lst[1523]: use  JSON::XS; no Cpanel::JSON::XS; use JSON::MaybeXS; JSON(); # Don't think this will work
evals/evals-freenode-#perlbot.lst[1524]: use List::Util;
evals/evals-freenode-#perlbot.lst[1525]: use List::Util qw/reduce/; [ map { reduce {$a + $b} 1..$_ } 10, 20, 15, 16, 18, 17 ]
evals/evals-freenode-#perlbot.lst[1526]: use List::Util qw/reduce/; [ map { reduce {$a + $b} 1..$_ } sort 10, 20, 15..18 ]
evals/evals-freenode-#perlbot.lst[1527]: use List::Util qw/reduce/; reduce {$a + $b} 1..10
evals/evals-freenode-#perlbot.lst[1528]: use List::Util qw/reduce/; reduce {$a + $b} 1..15
evals/evals-freenode-#perlbot.lst[1529]: use List::Util qw/reduce/; reduce {$a + $b} 1..16
evals/evals-freenode-#perlbot.lst[1530]: use List::Util qw/reduce/; reduce {$a + $b} 1..17
evals/evals-freenode-#perlbot.lst[1531]: use List::Util qw/reduce/; reduce {$a + $b} 1..18
evals/evals-freenode-#perlbot.lst[1532]: use List::Util qw/reduce/; reduce {$a + $b} 1..20
evals/evals-freenode-#perlbot.lst[1533]: use List::Util qw(shufffle); [ shuffle 1..20 ]
evals/evals-freenode-#perlbot.lst[1534]: use List::Util qw(shuffle); [ shuffle 1..20 ]
evals/evals-freenode-#perlbot.lst[1535]: use List::Util qw(shuffle); sub bubsort { my $arr = shift; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i] }; $arr }; bubsort [ shuffle 1..20 ]
evals/evals-freenode-#perlbot.lst[1536]: use List::Util qw(shuffle); sub bubsort { my $arr = shift; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i]; &bubsort }; $arr }; bubsort [ shuffle 1..20 ]
evals/evals-freenode-#perlbot.lst[1537]: use List::Util qw(shuffle); sub bubsort { my ($arr) = @_; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i]; &bubsort }; $arr }; bubsort [ shuffle 1..100 ]
evals/evals-freenode-#perlbot.lst[1538]: use List::Util qw(shuffle); sub bubsort { my ($arr) = @_; while( my ($i) = grep $arr->[$_-1] > $arr->[$_], 1 .. $#$arr ) { @$arr[$i, $i-1] = @$arr[$i-1, $i]; &bubsort }; $arr }; bubsort [ shuffle 1..20 ]
evals/evals-freenode-#perlbot.lst[1539]: use Math::Complex; 
evals/evals-freenode-#perlbot.lst[1540]: use MIME::Base64;
evals/evals-freenode-#perlbot.lst[1541]: use MIME::Base64; decode_base64 'aHR0cDovL3NhZnIua2luZ2ZlYXR1cmVzLmNvbS9CZWV0bGVCYWlsZXkvMjAwNC8wNS9CZWV0bGVfQmFpbGV5LjIwMDQwNTIyXzkwMC5naWY='
evals/evals-freenode-#perlbot.lst[1542]: use MIME::Base64; use warnings; sub z { substr shift, 1, 1 }  z('∴')
evals/evals-freenode-#perlbot.lst[1543]: use overload
evals/evals-freenode-#perlbot.lst[1544]: use overload;
evals/evals-freenode-#perlbot.lst[1545]: use overload q|""| => sub { 42 }; my @a; $a[42] = 'forty two'; [ $a[bless 'main'] ]
evals/evals-freenode-#perlbot.lst[1546]: use overload q|""| => sub { 42 }; my @a; $a[42] = 'forty two'; [ $a[bless {}, 'main'] ]
evals/evals-freenode-#perlbot.lst[1547]: use overload qw,"",=> sub { die }; bless {}, bless []; 42;
evals/evals-freenode-#perlbot.lst[1548]: use overload qw,"",=> sub { die }; my $x = bless []; 42;
evals/evals-freenode-#perlbot.lst[1549]: use overload qw,"",=> sub { die }; my $x = bless []; bless {}, $x; 42;
evals/evals-freenode-#perlbot.lst[1550]: use overload '""' => sub { 'abcdef' }; '' . bless [];
evals/evals-freenode-#perlbot.lst[1551]: use overload '""' => sub { 'abcdef' }; ref bless [], bless [];
evals/evals-freenode-#perlbot.lst[1552]: use overload '""' => sub { die 'abcdef' }; ref bless [], bless [];
evals/evals-freenode-#perlbot.lst[1553]: use POSIX qw/ceil/; [ ceil(-2.20, int -2.2 ]
evals/evals-freenode-#perlbot.lst[1554]: use POSIX qw/ceil/; [ ceil -2.2, int(-2.2) ]
evals/evals-freenode-#perlbot.lst[1555]: use POSIX qw/ceil/; [ ceil(-2.2), int -2.2 ]
evals/evals-freenode-#perlbot.lst[1556]: use POSIX qw/strftime/; strftime "%Y-%m-%d", localtime 0;
evals/evals-freenode-#perlbot.lst[1557]: use Safe;
evals/evals-freenode-#perlbot.lst[1558]: use Scalar::Util qw/dualvar/; my $i = dualvar 1, 'forty two'; my @a = qw/one two/; [ $a[ $i ] ];
evals/evals-freenode-#perlbot.lst[1559]: use Scalar::Util qw/dualvar/; my $i = dualvar 1, 'forty two'; my @a = qw/one two/; [ $a[ $i ], $a[ "$i" ] ];
evals/evals-freenode-#perlbot.lst[1560]: use Scalar::Util qw/dualvar/; my $i = dualvar 1, 'forty two'; my @a = qw/one two/; [ $a[ $i ], $a[ $i+0 ] ];
evals/evals-freenode-#perlbot.lst[1561]: use Scalar::Util qw/dualvar/; my $x = dualvar(42,'foo'); [ $x+0, "$x" ]
evals/evals-freenode-#perlbot.lst[1562]: use Scalar::Util qw/dualvar/; my $x = dualvar('42','foo'); $x = 55; [ $x+0, "$x" ]
evals/evals-freenode-#perlbot.lst[1563]: use Scalar::Util qw/dualvar/; my $x = dualvar 42, 'forty two'; [$x+0, "$x"]
evals/evals-freenode-#perlbot.lst[1564]: use Scalar::Util qw/dualvar/; my $x = dualvar 42, 'forty two'; [$x, "$x"]
evals/evals-freenode-#perlbot.lst[1565]: use Scalar::Util qw/dualvar/; my $x = dualvar('NaN','foo'); [ $x+0, "$x" ]
evals/evals-freenode-#perlbot.lst[1566]: use Scalar::Util qw/dualvar/; $x = dualvar 42, 'foo'; [ $x.'', $x+0 ]
evals/evals-freenode-#perlbot.lst[1567]: use Scalar::Util qw/looks_like_a_number/; looks_like_a_number 'NaN'
evals/evals-freenode-#perlbot.lst[1568]: use Scalar::Util qw/looks_like_number/; [ looks_like_number 'iNan' ]
evals/evals-freenode-#perlbot.lst[1569]: use Scalar::Util qw/looks_like_number/; [ looks_like_number 'Nan' ]
evals/evals-freenode-#perlbot.lst[1570]: use Scalar::Util qw/looks_like_number/; [ looks_like_number 'NaN' ]
evals/evals-freenode-#perlbot.lst[1571]: use Scalar::Util qw/looks_like_number/; looks_like_number 'NaN'
evals/evals-freenode-#perlbot.lst[1572]: use Scalar::Util qw/looks_like_number/; [ looks_like_number 'sdss' ]
evals/evals-freenode-#perlbot.lst[1573]: use Scalar::Util qw/looks_like_number/; [ looks_like_number 'sNan' ]
evals/evals-freenode-#perlbot.lst[1574]: use Scalar::Util qw/looks_like_number/; [ looks_like_number 'sNaN' ]
evals/evals-freenode-#perlbot.lst[1575]: use Scalar::Util qw/looks_like_number/; [ looks_like_number 'wtfNan' ]
evals/evals-freenode-#perlbot.lst[1576]: use Scalar::Util qw/looks_like_number/; [ looks_like_number 'xsNan' ]
evals/evals-freenode-#perlbot.lst[1577]: use Scalar::Util qw/looks_like_number/; [ looks_like_number 'zNan' ]
evals/evals-freenode-#perlbot.lst[1578]: use Scalar::Utils qw/dualvar/; my $x = dualvar 42, 'forty two'; [$x, "$x"]
evals/evals-freenode-#perlbot.lst[1579]: use strict; *4 = sub { 'ok' }; *{ \4 };
evals/evals-freenode-#perlbot.lst[1580]: use strict; *4 = sub { 'ok' }; *{ 4 };
evals/evals-freenode-#perlbot.lst[1581]: use strict; *4 = sub { 'ok' }; &{ \4 };
evals/evals-freenode-#perlbot.lst[1582]: use strict; *4 = sub { 'ok' }; &{4};
evals/evals-freenode-#perlbot.lst[1583]: use strict; *4 = sub { 'ok' }; main->${ \4 };
evals/evals-freenode-#perlbot.lst[1584]: use strict; $a="foo bar"; *$a = sub {"baz"}; "foo bar"->()
evals/evals-freenode-#perlbot.lst[1585]: use strict;  BEGIN { *::foo = \$::foo; } $foo = 42;
evals/evals-freenode-#perlbot.lst[1586]: use strict; BEGIN { package Zomg; use strict; *::foo = \$::foo; }  $foo = 42;
evals/evals-freenode-#perlbot.lst[1587]: use strict; $fl = '+++????? random shit any user can send to the bot'; my @mem_list = grep { $_ =~ /^$fl/i} 42;
evals/evals-freenode-#perlbot.lst[1588]: use strict;  *::foo = \$::foo;  $foo = 42;
evals/evals-freenode-#perlbot.lst[1589]: use strict; inf
evals/evals-freenode-#perlbot.lst[1590]: use strict; "-inf"<0
evals/evals-freenode-#perlbot.lst[1591]: use strict; "inf"<0
evals/evals-freenode-#perlbot.lst[1592]: use strict; "inf">0
evals/evals-freenode-#perlbot.lst[1593]: use strict; "inf"+0
evals/evals-freenode-#perlbot.lst[1594]: use strict; my $x; if ( $x = "x\b" ) { print "_$x_" }
evals/evals-freenode-#perlbot.lst[1595]: use strict; use v5.21; use feature qw(refaliasing);use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); foreach \%hash (@a) {print Dumper(%hash);}
evals/evals-freenode-#perlbot.lst[1596]: use strict; use v5.21; use feature qw(refaliasing);use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); foreach my \%hash (@a) {print Dumper(%hash);}
evals/evals-freenode-#perlbot.lst[1597]: use strict; use v5.21; use feature qw(refaliasing);use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); my %hash; foreach \%hash (@a) {print Dumper(%hash);}
evals/evals-freenode-#perlbot.lst[1598]: use strict; use warnings; blasdsdasdsa->import
evals/evals-freenode-#perlbot.lst[1599]: use strict; use warnings; $_ = '@f@f@f'; s'@f'$b'gr; 
evals/evals-freenode-#perlbot.lst[1600]: use strict; use warnings; [ grep defined, @{+{a => "b", c => "d", e => "f"}}{qw/a b c/} ];
evals/evals-freenode-#perlbot.lst[1601]: use strict use warnings; h->{two}();  sub h { +{ one => sub { 1 }, two => sub { 2 } } }
evals/evals-freenode-#perlbot.lst[1602]: use strict; use warnings; h->{two}();  sub h { +{ one => sub { 1 }, two => sub { 2 } } }
evals/evals-freenode-#perlbot.lst[1603]: use strict; use warnings; h()->{two}();  sub h { +{ one => sub { 1 }, two => sub { 2 } } }
evals/evals-freenode-#perlbot.lst[1604]: use strict; use warnings; +Inf
evals/evals-freenode-#perlbot.lst[1605]: use strict; use warnings; [ "+inf" > 0 ]
evals/evals-freenode-#perlbot.lst[1606]: use strict; use warnings; "+Inf"+0
evals/evals-freenode-#perlbot.lst[1607]: use strict; use warnings; [ "-Inf" > 0 ]
evals/evals-freenode-#perlbot.lst[1608]: use strict; use warnings; [ "+Inf" > 0 ]
evals/evals-freenode-#perlbot.lst[1609]: use strict; use warnings; [ "+Inx" > 0 ]
evals/evals-freenode-#perlbot.lst[1610]: use strict; use warnings; my $a = 42; my $z = 42; [ sort { $z <=> $b } 42 ]
evals/evals-freenode-#perlbot.lst[1611]: use strict; use warnings; my $a = 42; [ sort ]
evals/evals-freenode-#perlbot.lst[1612]: use strict; use warnings; my $a = 42; sort 
evals/evals-freenode-#perlbot.lst[1613]: use strict; use warnings; my $a = 42; [ sort { $a <=> $b } 42 ]
evals/evals-freenode-#perlbot.lst[1614]: use strict; use warnings; my $a = 42; [ sort { $z <=> $b } 42 ]
evals/evals-freenode-#perlbot.lst[1615]: use strict; use warnings; my @a; $a[undef]
evals/evals-freenode-#perlbot.lst[1616]: use strict; use warnings; my $foo; if ( %$foo ) { 1; }
evals/evals-freenode-#perlbot.lst[1617]: use strict; use warnings; my $foo; if ( $foo and %$foo ) { 1; }
evals/evals-freenode-#perlbot.lst[1618]: use strict; use warnings; my $h = {a => "b", c => "d", e => "f"}; my $str = join ",", grep defined, @$h{qw/a b c/}; print $str;
evals/evals-freenode-#perlbot.lst[1619]: use strict; use warnings; my ( $linecount, $timestart) = (0,0); printf(".... %s ... ", int($linecount/(time()-$timestart+1)));
evals/evals-freenode-#perlbot.lst[1620]: use strict; use warnings; my $stash = \%main:: ; sub foo { 42 }; *foo = sub { 'bar' };
evals/evals-freenode-#perlbot.lst[1621]: use strict; use warnings; my $stash = \%main:: ; sub foo { 42 }; $stash->{foo} = sub { 'bar' };
evals/evals-freenode-#perlbot.lst[1622]: use strict; use warnings; my $stash = \%main:: ; sub foo { 42 }; $stash->{foo} = sub { 'bar' }; [ foo() ]
evals/evals-freenode-#perlbot.lst[1623]: use strict; use warnings; my $str = join ",", grep defined, @{+{a => "b", c => "d", e => "f"}}{qw/a b c/}; print $str;
evals/evals-freenode-#perlbot.lst[1624]: use strict; use warnings; my $x = 42; [ defined &$x ]
evals/evals-freenode-#perlbot.lst[1625]: use strict; use warnings; my $x; [ defined &$x ]
evals/evals-freenode-#perlbot.lst[1626]: use strict; use warnings; my $x; [ &$x ]
evals/evals-freenode-#perlbot.lst[1627]: use strict; use warnings; [ "nan" > 0 ]
evals/evals-freenode-#perlbot.lst[1628]: use strict; use warnings; [ "Nan" > 0 ]
evals/evals-freenode-#perlbot.lst[1629]: use strict; use warnings; [ "NaN" > 0 ]
evals/evals-freenode-#perlbot.lst[1630]: use strict; use warnings; [ "nann" > 0 ]
evals/evals-freenode-#perlbot.lst[1631]: use strict; use warnings; [ 'NaN' + 'sNaN' ]
evals/evals-freenode-#perlbot.lst[1632]: use strict; use warnings; [ 'NaN' + 'sNaN' + 55]
evals/evals-freenode-#perlbot.lst[1633]: use strict; use warnings; open( my($fh), "<", \"asdf" ); [ <$fh> ];
evals/evals-freenode-#perlbot.lst[1634]: use strict; use warnings; open( my($fh), "<", \"asdf" ); [ <$fh>, scalar <$fh> ];
evals/evals-freenode-#perlbot.lst[1635]: use strict; use warnings; open( my($fh), "<", \"asdf" ); [ <$fh>, scalar <$fh>, scalar <$fh> ];
evals/evals-freenode-#perlbot.lst[1636]: use strict; use warnings; our $a = -1; [ sort {  $b <=> $a } 1..10 ]
evals/evals-freenode-#perlbot.lst[1637]: use strict; use warnings; our $a = 42; [ sort {  $b <=> $a } 1..10 ]
evals/evals-freenode-#perlbot.lst[1638]: use strict; use warnings; our $VERSION = 'blah';
evals/evals-freenode-#perlbot.lst[1639]: use strict;  use warnings; sub bar { 42 } print "Return $foo" if my $foo = bar;
evals/evals-freenode-#perlbot.lst[1640]: use strict; use warnings; sub h { +{ one => sub { 1 }, two => sub { 2 } } }  h->{two}();  
evals/evals-freenode-#perlbot.lst[1641]: use strict; use warnings; sub int {} my ( $linecount, $timestart) = (0,0); printf(".... %s ... ", int($linecount/(time()-$timestart+1)));
evals/evals-freenode-#perlbot.lst[1642]: use strict; use warnings; sub TIEHANDLE { bless [] }; sub AUTOLOAD { print "In autoload!"; 42 }; tie *FH, 'main'; [ print FH 'adfasdf' ];
evals/evals-freenode-#perlbot.lst[1643]: use strict; use warnings; sub TIEHANDLE { bless [] }; sub AUTOLOAD { print "In autoload!"; 42 }; tie *FH, 'main'; [ scalar readline FH ];
evals/evals-freenode-#perlbot.lst[1644]: use strict; use warnings; sub TIEHANDLE { bless [] }; sub AUTOLOAD { print "In autoload! $AUTOLOAD"; 42 }; tie *FH, 'main'; [ print FH 'adfasdf' ];
evals/evals-freenode-#perlbot.lst[1645]: use strict; use warnings; sub TIEHANDLE { bless [] }; sub READLINE { "asdf" }; sub AUTOLOAD { print "In autoload!"; 42 }; tie *FH, 'main'; [ scalar readline FH ];
evals/evals-freenode-#perlbot.lst[1646]: use strict; use warnings; use autodie; open( my($fh), "<", \"asdf" ); [ <$fh> ];
evals/evals-freenode-#perlbot.lst[1647]: use strict; use warnings; $VERSION = 'blah';
evals/evals-freenode-#perlbot.lst[1648]: use Test::More
evals/evals-freenode-#perlbot.lst[1649]: use Text::Soundex;
evals/evals-freenode-#perlbot.lst[1650]: use Text::SoundEx;
evals/evals-freenode-#perlbot.lst[1651]: use Tie::Handle; tie *FH, 'Tie::Handle'; 
evals/evals-freenode-#perlbot.lst[1652]: use Try::Tiny; try {die "baz";} catch {die "foo"}; die "bar";
evals/evals-freenode-#perlbot.lst[1653]: use Try::Tiny; try {die "baz";} catch {die "foo"} finally { "bar"};
evals/evals-freenode-#perlbot.lst[1654]: use Try::Tiny; try {die "baz";} catch {die "foo"} finally { die "bar"};
evals/evals-freenode-#perlbot.lst[1655]: use Try::Tiny; try {die "baz";} catch {die "foo"} finally { print "hoyl shit that broke"};
evals/evals-freenode-#perlbot.lst[1656]: use URI::Encode qw/uri_encode/;
evals/evals-freenode-#perlbot.lst[1657]: use URI::Encode qw/uri_encode/; uri_encode "<arg>", {"encode_reserved", 1}; 
evals/evals-freenode-#perlbot.lst[1658]: use URI::Encode qw/uri_encode/; uri_encode "LWP::Authen::Digest"
evals/evals-freenode-#perlbot.lst[1659]: use URI::Encode; [ URI::Encode::uri_encode "test", {encode_reserved=>1} ];
evals/evals-freenode-#perlbot.lst[1660]: use URI; URI->new('/product/IDHEREFUCKER');
evals/evals-freenode-#perlbot.lst[1661]: use URI; URI->new("www.ebay.com");
evals/evals-freenode-#perlbot.lst[1662]: use utf8; - - '❧'
evals/evals-freenode-#perlbot.lst[1663]: use utf8; [ 'get http://ignorantdesigner.com/japh.html' =~ y • a-z: • n-za-m • r ]
evals/evals-freenode-#perlbot.lst[1664]: use utf8; [ 'get http://ignorantdesigner.com/japh.html' =~ y • a-z: • n-za-m •r ]
evals/evals-freenode-#perlbot.lst[1665]: use utf8; $l = "fooso"; [ $l & chr(0x80)x(length $l) ]
evals/evals-freenode-#perlbot.lst[1666]: use utf8; $l = "fooso"; [ $l =~tr/[\0-\127]//cdr  ]
evals/evals-freenode-#perlbot.lst[1667]: use utf8; $l = "fooso"; [ $l =~tr/[\0-\127]//dr  ]
evals/evals-freenode-#perlbot.lst[1668]: use utf8; $l = "fooso"; [ $l =~tr/\0-\127//dr  ]
evals/evals-freenode-#perlbot.lst[1669]: use utf8; $l = "fooso"; [ $l =~tr/[\0-\127]//r  ]
evals/evals-freenode-#perlbot.lst[1670]: use utf8; $l = "fooso"; [ $l =~tr/\0-\225//dr  ]
evals/evals-freenode-#perlbot.lst[1671]: use utf8; $l = "fooso"; [ $l =~tr/\0-\250//dr  ]
evals/evals-freenode-#perlbot.lst[1672]: use utf8; my $ a; print;
evals/evals-freenode-#perlbot.lst[1673]: use utf8; my $a; print;
evals/evals-freenode-#perlbot.lst[1674]: use utf8; print ’42’
evals/evals-freenode-#perlbot.lst[1675]: use utf8; q ❤‎ Happy Valentine's Day, #perl ❤‎ 
evals/evals-freenode-#perlbot.lst[1676]: use utf8; q ❤‎ Happy Valentine's Day, #perl ❤‎ ❤‎r
evals/evals-freenode-#perlbot.lst[1677]: use utf8; q ❤‎ Happy Valentine's Day, #perl ❤‎  s ❤ ❤‎r
evals/evals-freenode-#perlbot.lst[1678]: use utf8; q ❤‎ Happy Valentine's Day, #perl ❤‎  s ❤ ❤‎ ❤r
evals/evals-freenode-#perlbot.lst[1679]: use utf8; q ❤‎ Happy Valentine's Day, perl ❤ ;‎  s ❤ ❤‎ ❤r
evals/evals-freenode-#perlbot.lst[1680]: use utf8; q ❤‎ Happy Valentine's Day, perl ❤;‎  s ❤ ❤‎ ❤r
evals/evals-freenode-#perlbot.lst[1681]: use utf8; q ❤‎ Happy Valentine's Day, perl ❤‎  s ❤ ❤‎ ❤r
evals/evals-freenode-#perlbot.lst[1682]: use utf8; q 😁 ☺ Perl \o/ ☺  😁
evals/evals-freenode-#perlbot.lst[1683]: use utf8; quotemeta '÷'
evals/evals-freenode-#perlbot.lst[1684]: use utf8; quotemeta "ǁ"
evals/evals-freenode-#perlbot.lst[1685]: use utf8; say length "ﺆ"
evals/evals-freenode-#perlbot.lst[1686]: use utf8; "ǁ" =~ s/([^A-Za-z_0-9])/\\$1/gr
evals/evals-freenode-#perlbot.lst[1687]: use utf8; "ǁ" =~ s/([^A-Za-z_0-9])/\\$1/r
evals/evals-freenode-#perlbot.lst[1688]: use utf8; s ❤‎ Happy Valentine's Day, #perl ❤‎ ❤ ❤‎r
evals/evals-freenode-#perlbot.lst[1689]: use utf8; s ❤‎ Happy Valentine's Day, #perl ❤‎ ❤‎r
evals/evals-freenode-#perlbot.lst[1690]: use utf8; s ❤‎ Happy Valentine's Day, #perl ❤‎ ❤‎ ❤‎r
evals/evals-freenode-#perlbot.lst[1691]: use utf8; use Encode; my $z = '≅';  [ length($z), length(encode 'utf8', $z) ]
evals/evals-freenode-#perlbot.lst[1692]: use utf8; use warnings; sub z { print shift }  z('∴')
evals/evals-freenode-#perlbot.lst[1693]: use utf8; use warnings; sub z { substr shift, 1, 1 }  z('∴')
evals/evals-freenode-#perlbot.lst[1694]: use v5.21; 0.deadbeefp2
evals/evals-freenode-#perlbot.lst[1695]: use v5.21; $a = 0.deadbeefp2
evals/evals-freenode-#perlbot.lst[1696]: use v5.21; ($a, $b, (undef) x 3, $c) = (1..10); [$a, $b, $c]
evals/evals-freenode-#perlbot.lst[1697]: use v5.21; my ($a, $b, (undef) x 3, $c) = (1..10); [$a, $b, $c]
evals/evals-freenode-#perlbot.lst[1698]: use v5.21; use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); for my \%hash (@a) {print Dumper(%hash);}
evals/evals-freenode-#perlbot.lst[1699]: use v5.21; use feature qw(refaliasing);use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); foreach my \%hash (@a) {print Dumper(%hash);}
evals/evals-freenode-#perlbot.lst[1700]: use v5.21; use feature qw(refaliasing);use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); for \%hash (@a) {print Dumper(%hash);}
evals/evals-freenode-#perlbot.lst[1701]: use v5.21; use feature qw(refaliasing);use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); for my \%hash (@a) {print Dumper(%hash);}
evals/evals-freenode-#perlbot.lst[1702]: use v5.22; use Data::Dumper; my @a = ({foo => 1, bar => 2}, {problems => 99, bitches => 0}); for my \%hash (@a) {print Dumper(%hash);}
evals/evals-freenode-#perlbot.lst[1703]: use vars qw/@CARP_NOT/; Carp::croak("loaded");
evals/evals-freenode-#perlbot.lst[1704]: use warnings; $_ = '@f@f@f'; s'@f'$b'gr; 
evals/evals-freenode-#perlbot.lst[1705]: use warnings; foo(3); sub foo(@) { print @_ }
evals/evals-freenode-#perlbot.lst[1706]: use warnings; foo(3); sub foo($) { print @_ }
evals/evals-freenode-#perlbot.lst[1707]: use warnings; "foo" ~~ "Bar"
evals/evals-freenode-#perlbot.lst[1708]: use warnings; "foo" ~~ "Bar":
evals/evals-freenode-#perlbot.lst[1709]: use warnings; +{ foo => bar => 'ber' }
evals/evals-freenode-#perlbot.lst[1710]: use warnings; @hash{$key} = [ @list ];
evals/evals-freenode-#perlbot.lst[1711]: use warnings; my $foo = 1; my $foo_bar = 2; "$foo\_bar"
evals/evals-freenode-#perlbot.lst[1712]: use warnings; my $foo = 1; my $foobar = 2; "$foo\bar"
evals/evals-freenode-#perlbot.lst[1713]: use warnings; my ($foo) if 0;
evals/evals-freenode-#perlbot.lst[1714]: use warnings; my $j = 'Foo'; $j =~ tr/\x20-\xff/\xff10-\xffff/; binmode STDOUT; print $j;
evals/evals-freenode-#perlbot.lst[1715]: use warnings; my $j = 'Foo'; $j =~ tr/\x20-\xff/\xff30-\xffff/; binmode STDOUT; print $j;
evals/evals-freenode-#perlbot.lst[1716]: use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; [ eval qq{ 'Just another Unicode hacker,' =~ tr[$l][$r]r } ];
evals/evals-freenode-#perlbot.lst[1717]: use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; eval qq{ 'Just another Unicode hacker,' =~ tr[$l][$r]r };
evals/evals-freenode-#perlbot.lst[1718]: use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; eval qq{ 'Just another Unicode hacker,' =~ tr[$l][$r]r }; $@
evals/evals-freenode-#perlbot.lst[1719]: use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; eval qq{ 'Just another Unicode hacker,' =~ tr[\Q$l\E][\Q$r\E]r };
evals/evals-freenode-#perlbot.lst[1720]: use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; eval qq{ 'Just another Unicode hacker,' =~ tr[\Q$l\E][\Q$r\E]r }; $@
evals/evals-freenode-#perlbot.lst[1721]: use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; $l
evals/evals-freenode-#perlbot.lst[1722]: use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_0xff00) for 0x00..0x50; binmode STDOUT; $l
evals/evals-freenode-#perlbot.lst[1723]: use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; $r
evals/evals-freenode-#perlbot.lst[1724]: use warnings; my $u = 'ABC'; say $u =~ s/./pos $u/ger;
evals/evals-freenode-#perlbot.lst[1725]: use warnings; my @x = (1...4); undef @x;
evals/evals-freenode-#perlbot.lst[1726]: use warnings; my $x; $x++;
evals/evals-freenode-#perlbot.lst[1727]: use warnings; my $x; ++$x;
evals/evals-freenode-#perlbot.lst[1728]: use warnings; my $x; $x -= 4;
evals/evals-freenode-#perlbot.lst[1729]: use warnings; my $x; $x .= 4;
evals/evals-freenode-#perlbot.lst[1730]: use warnings; my $x; $x += 4;
evals/evals-freenode-#perlbot.lst[1731]: use warnings; my $x; $x . 'foo'
evals/evals-freenode-#perlbot.lst[1732]: use warnings; my $x; $x = $x - 4;
evals/evals-freenode-#perlbot.lst[1733]: use warnings; our $foo; sub foo { my $x = shift; BEGIN { $foo = \$x }; $$foo }; [ foo(1), foo(2) ];
evals/evals-freenode-#perlbot.lst[1734]: use warnings; our $foo; sub foo { my $x = shift; BEGIN { $foo = \$x }; ${ &{'FOO'}() } }; [ foo(1), foo(2) ];
evals/evals-freenode-#perlbot.lst[1735]: use warnings; sub chomp { "blah" }; [ chomp ]
evals/evals-freenode-#perlbot.lst[1736]: use warnings; sub foo { my $x = shift; use constant FOO => \$x; ${ &{'FOO'}() } }; [ foo(1), foo(2) ];
evals/evals-freenode-#perlbot.lst[1737]: use warnings; sub TIEHANDLE { bless [] }; sub AUTOLOAD { print "In autoload! $AUTOLOAD"; 42 }; tie *FH, 'main'; [ print FH 'adfasdf' ];
evals/evals-freenode-#perlbot.lst[1738]: use warnings; sub z { print shift }  z('∴')
evals/evals-freenode-#perlbot.lst[1739]: use warnings; sub z { }  z('∴')
evals/evals-freenode-#perlbot.lst[1740]: use warnings; use experimental 'smartmatch'; "foo" ~~ "Bar"
evals/evals-freenode-#perlbot.lst[1741]: use warnings; use experimental 'smartmatch'; "foo" ~~ "Bar";
evals/evals-freenode-#perlbot.lst[1742]: use warnings; use experimental 'smartmatch'; "foo" ~~ "Bar"; "All ok"
evals/evals-freenode-#perlbot.lst[1743]: use warnings; use strict; use experimental 'postderef'; my $x; my @z = @{ $x || [] }; $x->@*
evals/evals-freenode-#perlbot.lst[1744]: use warnings; use strict; use experimental 'postderef'; my $x;  @{ $x || [] }; $x->@*
evals/evals-freenode-#perlbot.lst[1745]: use warnngs; my $foo = 1; my $foo_bar = 2; "$foo\_bar"
evals/evals-freenode-#perlbot.lst[1746]: ; ;;;;;;;;;;;;;;;;;;v
evals/evals-freenode-#perlbot.lst[1747]: "$^V";
evals/evals-freenode-#perlbot.lst[1748]: $V
evals/evals-freenode-#perlbot.lst[1749]: $^V
evals/evals-freenode-#perlbot.lst[1750]: $^V;
evals/evals-freenode-#perlbot.lst[1751]: "".(v0.01)
evals/evals-freenode-#perlbot.lst[1752]: v0.01
evals/evals-freenode-#perlbot.lst[1753]: v0.1
evals/evals-freenode-#perlbot.lst[1754]: $^V^2
evals/evals-freenode-#perlbot.lst[1755]: v.255
evals/evals-freenode-#perlbot.lst[1756]: v3232.95.3232
evals/evals-freenode-#perlbot.lst[1757]: v5
evals/evals-freenode-#perlbot.lst[1758]: v5 ^ 2
evals/evals-freenode-#perlbot.lst[1759]: [values %DB:: ]
evals/evals-freenode-#perlbot.lst[1760]: $VERSION = 'blah';
evals/evals-freenode-#perlbot.lst[1761]: $w = 3; $h = 4; @out = ( (0) x $w ) x $h; 
evals/evals-freenode-#perlbot.lst[1762]: $w = 3; $h = 4; @out = ( (0) x $w ) x $h; \@out
evals/evals-freenode-#perlbot.lst[1763]: "W\x{200d}⚓"
evals/evals-freenode-#perlbot.lst[1764]: - - 'x'
evals/evals-freenode-#perlbot.lst[1765]: $x = 0; for (1..1000) {$x += 0.01;}; for (1..2000) {$x -= 0.005}; $x
evals/evals-freenode-#perlbot.lst[1766]: @x = (1, 1, 1); delete @x[@x]; \@x
evals/evals-freenode-#perlbot.lst[1767]: $x = (1, (2, 3), 5); 
evals/evals-freenode-#perlbot.lst[1768]: @x = (1, 2, 3); delete @x[@x]; \@x
evals/evals-freenode-#perlbot.lst[1769]: "\x{1f31b}\x{200D}\x{1f31c}"
evals/evals-freenode-#perlbot.lst[1770]: "\x{1f31b}\x{200D}\x{1f51c}\x{200D}\x{1f31c}"
evals/evals-freenode-#perlbot.lst[1771]: "\x{1f31c}\x{200D}\x{1f31b}"
evals/evals-freenode-#perlbot.lst[1772]: "\x{1F466}\x{200D}\x{2764}\x{FE0F}\x{200D}\x{1F48B}\x{200D}\x{1F468}"
evals/evals-freenode-#perlbot.lst[1773]: "\x{1F468}\x{200D}\x{2764}\x{FE0F}\x{200D}\x{1F48B}\x{200D}\x{1F469}"
evals/evals-freenode-#perlbot.lst[1774]: "\x{1F469}\x{200D}\x{2764}\x{FE0F}\x{200D}\x{1F48B}\x{200D}\x{1F468}"
evals/evals-freenode-#perlbot.lst[1775]: "\x{1F469}\x{200D}\x{2764}\x{FE0F}\x{200D}\x{1F48B}\x{200D}\x{1F469}"
evals/evals-freenode-#perlbot.lst[1776]: "\x{1F478}\x{200D}\x{1f31b}"
evals/evals-freenode-#perlbot.lst[1777]: "\x{1F478}\x{200D}\x{2764}\x{FE0F}\x{200D}\x{1F48B}\x{200D}\x{1F438}"
evals/evals-freenode-#perlbot.lst[1778]: "\x{1f4a9}"
evals/evals-freenode-#perlbot.lst[1779]: ["\x{1f4a9}"]
evals/evals-freenode-#perlbot.lst[1780]: "\x{1f51c}"
evals/evals-freenode-#perlbot.lst[1781]: @x = (2, 1, 2); delete @x[2, 1, 2]; 
evals/evals-freenode-#perlbot.lst[1782]: @x = (2, 1, 2); delete @x[2, 1, 2]; \@a
evals/evals-freenode-#perlbot.lst[1783]: @x = (2, 1, 2); delete @x[2, 1, 2]; \@x
evals/evals-freenode-#perlbot.lst[1784]: @x = (2, 1, 2); delete @x[2, 2, 1]; \@x
evals/evals-freenode-#perlbot.lst[1785]: @x = (2, 1, 2); delete @x[@x];
evals/evals-freenode-#perlbot.lst[1786]: @x = (2, 1, 2); delete @x[~~@x]; \@x
evals/evals-freenode-#perlbot.lst[1787]: @x = (2, 1, 2); delete @x[@x]; \@x
evals/evals-freenode-#perlbot.lst[1788]: @x = (4, 5, 6); delete @x[@x]; \@x
evals/evals-freenode-#perlbot.lst[1789]: "\x{749}"
evals/evals-freenode-#perlbot.lst[1790]: $x = []; bless $x, []; ref $x
evals/evals-freenode-#perlbot.lst[1791]: "\x{D000}"
evals/evals-freenode-#perlbot.lst[1792]: [ 'X' =~ /(?i)x/]
evals/evals-freenode-#perlbot.lst[1793]: $_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]{1}(?![A-Z])/)
evals/evals-freenode-#perlbot.lst[1794]: $_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]{1}(?![A-Z]))/)
evals/evals-freenode-#perlbot.lst[1795]: $_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]{1}(?![A-Z]*))/)
evals/evals-freenode-#perlbot.lst[1796]: $_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]{1}[^A-Z]*)/)
evals/evals-freenode-#perlbot.lst[1797]: $_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]+(?=[^A-Z]*)/)
evals/evals-freenode-#perlbot.lst[1798]: $_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]+(?=[^A-Z]*))/)
evals/evals-freenode-#perlbot.lst[1799]: $_ = 'XMLParser'; join('_', map {lc} grep {length} split /([A-Z]+[^A-Z]*)/)
evals/evals-freenode-#perlbot.lst[1800]: $_ = 'XMLParser'; [split /([A-Z]{1}(?![A-Z]))/)]
evals/evals-freenode-#perlbot.lst[1801]: $_ = 'XMLParser'; [split /([A-Z]{1}(?![A-Z]))/]
evals/evals-freenode-#perlbot.lst[1802]: $_ = 'XMLParser'; [split /([A-Z]*[^A-Z]*)/]
evals/evals-freenode-#perlbot.lst[1803]: [ 'XX' =~ /(?i)xx/]
evals/evals-freenode-#perlbot.lst[1804]: [ 'XX' =~ /((?i)x)x/]
evals/evals-freenode-#perlbot.lst[1805]: 'XYXYXYXY foos' =~ s/(XY)*.+
evals/evals-freenode-#perlbot.lst[1806]: 'XYXYXYXY foos' =~ s/(XY)+?\1.+/$1/r
evals/evals-freenode-#perlbot.lst[1807]: 'XYXYXYXY foos' =~ s/(XY)+\1.+/$1/r
evals/evals-freenode-#perlbot.lst[1808]: 'XYXYXYXY foos' =~ s/(XY)+?\1.+//r
evals/evals-freenode-#perlbot.lst[1809]: 'XYXYXYXY foos' =~ s/(XY)+\1.+//r
evals/evals-freenode-#perlbot.lst[1810]: 'XYXYXYXY foos' =~ s/(XY)+\K\1.+/$1/r
evals/evals-freenode-#perlbot.lst[1811]: 'XYXYXYXY foos' =~ s/(?:XY)+\K\1.+//r
evals/evals-freenode-#perlbot.lst[1812]: 'XYXYXYXY foos' =~ s/((?:XY))+\K\1.+//r
evals/evals-freenode-#perlbot.lst[1813]: 'XYXYXYXY foos' =~ s/((?:XY)+)\K\1.+//r
evals/evals-freenode-#perlbot.lst[1814]: 'XYXYXYXY foos' =~ s/(XY)*XY.+
evals/evals-freenode-#perlbot.lst[1815]: $x * $y // $z
evals/evals-freenode-#perlbot.lst[1816]: You know what I like about perl? It's the fact that this English sentence is perfectly parsable! Some may say: "no way", but I got deparse to prove it
evals/evals-freenode-#perlbot.lst[1817]: $π = 42; say $π
evals/evals-freenode-#perlcafe.lst[1]: /(?[()-!])/
evals/evals-freenode-#perlcafe.lst[2]: [0b1010 & 0b1000]
evals/evals-freenode-#perlcafe.lst[3]: [0b11111100000]
evals/evals-freenode-#perlcafe.lst[4]: 1022/24
evals/evals-freenode-#perlcafe.lst[5]: (188982-183984)/1024
evals/evals-freenode-#perlcafe.lst[6]: [20+4]
evals/evals-freenode-#perlcafe.lst[7]: [5+6]
evals/evals-freenode-#perlcafe.lst[8]: BEGIN(){i or$[}
evals/evals-freenode-#perlcafe.lst[9]: eval 'BEGIN(){i or$[}'
evals/evals-freenode-#perlcafe.lst[10]: eval 'BEGIN(){i or$[}'; [5+6]
evals/evals-freenode-#perlcafe.lst[11]: [grep {/Trig/} keys %INC]
evals/evals-freenode-#perlcafe.lst[12]: ($inf, $neginf, $nan) = (9**9**9, -9**9**9, -sin(9**9**9)); use List::Util qw/max/; max(1.0, $nan)
evals/evals-freenode-#perlcafe.lst[13]: ($inf, $neginf, $nan) = (9**9**9, -9**9**9, -sin(9**9**9)); use List::Util qw/max/; max($nan, 1.0)
evals/evals-freenode-#perlcafe.lst[14]: [map {$_->[1] * 2 ** (32-$_->[0])} ([11, 1], [21, 2], [22, 4], [23, 127], [24, 479])]
evals/evals-freenode-#perlcafe.lst[15]: my $line = "This is my line."; $line;
evals/evals-freenode-#perlcafe.lst[16]: my $string = 'I<Literature|^hardcover^>'; if ($string ~= /I\<(.+)\|(.+)\>/) { "<i $2>$1</i>"} else { "fail" }
evals/evals-freenode-#perlcafe.lst[17]: my $string = 'I<Literature|^hardcover^>'; if ($string =~ /I\<(.+)\|(.+)\>/) { "<i $2>$1</i>"} else { "fail" }
evals/evals-freenode-#perlcafe.lst[18]: my $string = 'I<Literature|^hardcover^> Other text'; $string =~ /I\<(.+)\|(.+)\>/<i $2>$1<\/i>/; $string;
evals/evals-freenode-#perlcafe.lst[19]: my $string = 'I<Literature|^hardcover^> Other text'; $string =~ /I\<(.+)\|(.+)\>/<i $2\>$1<\/i>/; $string;
evals/evals-freenode-#perlcafe.lst[20]: my $x = [{z => \{foo=>1}]; $x;
evals/evals-freenode-#perlcafe.lst[21]: my $x = [{z => \{foo=>1}}]; $x;
evals/evals-freenode-#perlcafe.lst[22]: my $x = [{z => \{foo=>1}}]; $x->[0]{z}->$*;
evals/evals-freenode-#perlcafe.lst[23]: pack('V' . 99999990);
evals/evals-freenode-#perlcafe.lst[24]: say "Hello libreman."
evals/evals-freenode-#perlcafe.lst[25]: tan(0)
evals/evals-freenode-#perlcafe.lst[26]: use experimental 'signatures'; sub rindolf($message) {print "There's a message for you sire: ", $message}; rindolf("HI!");
evals/evals-freenode-#perlcafe.lst[27]: use List::Util qw/reduce/; reduce {$a + $b} map {$_->[1] * 2 ** (32-$_->[0])} ([11, 1], [21, 2], [22, 4], [23, 127], [24, 479])
evals/evals-freenode-#perlcafe.lst[28]: use List::Utils qw/reduce/; reduce {$a + $b} map {$_->[1] * 2 ** (32-$_->[0])} ([11, 1], [21, 2], [22, 4], [23, 127], [24, 479])
evals/evals-freenode-#perlcafe.lst[29]: use POSIX; [POSIX::cot(0)]
evals/evals-freenode-#perlcafe.lst[30]: use POSIX; [POSIX::tan(0)]
evals/evals-freenode-#perlcafe.lst[31]: use strict; use warnings; my $sub = sub { print "Hello world\n" }; &$sub;
evals/evals-freenode-#perlcafe.lst[32]: use strict; use warnings; my $sub = sub { print 'Hello world'; }; $sub;
evals/evals-freenode-#perlcafe.lst[33]: $^V;
evals/evals-freenode-#perlcafe.lst[34]: $x[()[()]]
evals/evals-magnet-#perl.lst[1]: $.
evals/evals-magnet-#perl.lst[2]: $$
evals/evals-magnet-#perl.lst[3]: 0 && 1
evals/evals-magnet-#perl.lst[4]: $_ = '02 Maria';  my ( $n, $name ) = split ' '; my %h; push @{ $h{ $n } }, $name; \%h
evals/evals-magnet-#perl.lst[5]: [0b00, 0b11, 0b01, 0b10]
evals/evals-magnet-#perl.lst[6]: 0 && print "foo"
evals/evals-magnet-#perl.lst[7]: [1]
evals/evals-magnet-#perl.lst[8]: 10**20
evals/evals-magnet-#perl.lst[9]: 1 + 1
evals/evals-magnet-#perl.lst[10]: 11+16
evals/evals-magnet-#perl.lst[11]: 12*473
evals/evals-magnet-#perl.lst[12]: 1995 * .75
evals/evals-magnet-#perl.lst[13]: @_=(1); [ defined(1), defined(shift) ]
evals/evals-magnet-#perl.lst[14]: 1+nan
evals/evals-magnet-#perl.lst[15]: @_ = (1); print 'YES' if( shift == undef )
evals/evals-magnet-#perl.lst[16]:  2 * @
evals/evals-magnet-#perl.lst[17]:  2 * 2
evals/evals-magnet-#perl.lst[18]: 220/8*4/60
evals/evals-magnet-#perl.lst[19]: 2 ** 3
evals/evals-magnet-#perl.lst[20]: (2**32)/92682
evals/evals-magnet-#perl.lst[21]: [ 2.5 * 6 ];
evals/evals-magnet-#perl.lst[22]: 2 == ('a','b')
evals/evals-magnet-#perl.lst[23]: 2 == @{['a','b']}
evals/evals-magnet-#perl.lst[24]: (3/2)*(3/2)*(19/16)*(271/512)
evals/evals-magnet-#perl.lst[25]: 34/26.81
evals/evals-magnet-#perl.lst[26]: 473*12*.04
evals/evals-magnet-#perl.lst[27]: 473*16
evals/evals-magnet-#perl.lst[28]: 499/80
evals/evals-magnet-#perl.lst[29]: 6/16
evals/evals-magnet-#perl.lst[30]:  $_ = "a[b]"; [ "a[b]" =~ /$_/ ]
evals/evals-magnet-#perl.lst[31]:  $_ = "a[b]"; [ "a[b]" =~ /\Q$_\E/ ]
evals/evals-magnet-#perl.lst[32]: @ARGV = "hello"; [ shift ]
evals/evals-magnet-#perl.lst[33]: a..z
evals/evals-magnet-#perl.lst[34]: binmode STDOUT; $_ = "Just another Perl/BIDI Hacker,"; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/; # does this show up right for everyone?
evals/evals-magnet-#perl.lst[35]: binmode STDOUT; 'Perl can be awesome, sometimes,' =~ s,([\x20-\x7f]),chr(ord($1)-0x20+0xff00),gre;
evals/evals-magnet-#perl.lst[36]: binmode STDOUT; 'Perl can be awesome, sometimes,' =~ tr[\x20-\x7f][\x{ff00}-\x{ff5f}]r; # tr is better
evals/evals-magnet-#perl.lst[37]: binmode STDOUT; 'Unicode can be confusing,' =~ tr[\x20-\x7f][\x{3000}\x{ff01}-\x{ff5f}]r; # tr is better
evals/evals-magnet-#perl.lst[38]: binmode \*STDOUT, ':utf8'; print v3232.95.3232
evals/evals-magnet-#perl.lst[39]: binmode STDOUT ':utf8'; print v3232.95.3232
evals/evals-magnet-#perl.lst[40]: binmode(STDOUT, ':utf8'); print v3232.95.3232
evals/evals-magnet-#perl.lst[41]: binmode \*STDOUT, ':utf8'; say v3232.95.3232
evals/evals-magnet-#perl.lst[42]: binmode \&STDOUT, ':utf8'; say v3232.95.3232
evals/evals-magnet-#perl.lst[43]: binmode STDOUT; v3232.95.3232
evals/evals-magnet-#perl.lst[44]: $code
evals/evals-magnet-#perl.lst[45]: $code =~ s/[^\$]*\$/\$/r;
evals/evals-magnet-#perl.lst[46]: ctime time
evals/evals-magnet-#perl.lst[47]: do{...;"abc"} if 0;
evals/evals-magnet-#perl.lst[48]: do{...;"abc"} if 1;
evals/evals-magnet-#perl.lst[49]: '$equation'
evals/evals-magnet-#perl.lst[50]: 'example@gmail.com' =~ m/[a-z0-9A-Z-_]+\@[a-z0-9A-Z-_]+\./
evals/evals-magnet-#perl.lst[51]: "fmekmftestdwadwad" =~ m/test/i
evals/evals-magnet-#perl.lst[52]: "fmekmftestdwadwad" =~ m/tesT/i
evals/evals-magnet-#perl.lst[53]: "fmekmftestdwadwad" =~ /tesT/i # "m" is optional with standard / / delimiters
evals/evals-magnet-#perl.lst[54]: 'fnnny' =~ s/nn(?!n)/tt/r
evals/evals-magnet-#perl.lst[55]: 'foo'
evals/evals-magnet-#perl.lst[56]: 'foo&amp;bar' =~ /&amp;/;
evals/evals-magnet-#perl.lst[57]: 'foo bar' =~ s/(foo) bar/$1 $1/r
evals/evals-magnet-#perl.lst[58]: '&foo' =~ /\b&foo/;
evals/evals-magnet-#perl.lst[59]: '&foo' =~ /&\bfoo/;
evals/evals-magnet-#perl.lst[60]: for $$code (sub { print 'ok' }) { print "[[[$code]]]" }
evals/evals-magnet-#perl.lst[61]: $_++ for map $_, qw(hobbs mst)
evals/evals-magnet-#perl.lst[62]: for \my @foo (['foo', 'foo'], ['foo', 'bar'], ['bar', 'foo'], ['bar', 'bar']) { my $correct = ($foo[0] ne 'foo' && $foo[1] ne 'foo');  my $x = !($foo[0] eq 'foo' && $foo[1] eq 'foo'); my $y = !($foo[0] eq 'foo' || $foo[1] eq 'foo');  print $correct == $x ? '' : 'x is wrong'; print $correct == $y ? '' : 'y is wrong'; }
evals/evals-magnet-#perl.lst[63]: @_ = "hello"; [ shift ]
evals/evals-magnet-#perl.lst[64]: %h = (   foo => "bar",  bar => [ "baz" ],  argle => { "blargle" => "blop" } ); print %h
evals/evals-magnet-#perl.lst[65]: %h = (   foo => "bar",  bar => [ "baz" ],  argle => { "blargle" => "blop" } ); use Data::Dumper; print Dumper \%h
evals/evals-magnet-#perl.lst[66]: %h = (   foo => "bar",  bar => [ "baz" ],  argle => { "blargle" => "blop" } ); use Data::Dumper; print Dumper %h
evals/evals-magnet-#perl.lst[67]: if (rand) {{ say 1; next; say 2 }} say 3;
evals/evals-magnet-#perl.lst[68]: index "banana", "na", -2
evals/evals-magnet-#perl.lst[69]: join('','A'..'Z') =~ s/(.)/chr(ord($1)+1)/ger
evals/evals-magnet-#perl.lst[70]: join"",map uc,map$_ eq"i"?"u":$_,("fist"=~/./sg)[2,3,0,1] or "Show Them Fury Unleashed" or St. Thomas Franciscan University or shut the fuck up or subsiste sermonem statim
evals/evals-magnet-#perl.lst[71]: $_ = 'Just another Perl hacker,'; undef $_{++$x}, ($h eq %_ or ((${%_}=chop),($h=%_))) while length; @_ = grep m!^\d+/\d+$!, keys %::; print map ${join "/", @$_}, sort { $b->[1] <=> $a->[1] or $b->[0] <=> $a->[0] } map [/\d+/g], @_;
evals/evals-magnet-#perl.lst[72]: $_ = 'Just another Perl hacker,'; undef $_{++$x}, ($h eq %_ or ((${%_}=chop),($h=%_))) while length; print map ${join "/", @$_}, sort { $b->[1] <=> $a->[1] or $b->[0] <=> $a->[0] } map [/\d+/g], grep m!^\d+/\d+$!, keys %::;
evals/evals-magnet-#perl.lst[73]: $_ = 'Just another Perl hacker,'; undef $_{++$x}, ($h eq %_ or ((${%_}=chop),($h=%_))) while length; print map ${join "/", (unpack 'NN', $_)[1,0]}, reverse sort map {pack 'NN', (/\d+/g)[1,0] } grep m!^\d+/\d+$!, keys %::;
evals/evals-magnet-#perl.lst[74]: kill 19, $$
FAILED TO EVAL!
evals/evals-magnet-#perl.lst[75]: kill 19, $_ for 1..100000
FAILED TO EVAL!
evals/evals-magnet-#perl.lst[76]: kill 19, getppid
evals/evals-magnet-#perl.lst[77]: length sprintf "%b", ~0
evals/evals-magnet-#perl.lst[78]: `ls`
evals/evals-magnet-#perl.lst[79]: [ map prototype("CORE::$_"), qw(sysopen truncate) ]
evals/evals-magnet-#perl.lst[80]: $memper = '60.1'; if ( int $memper > 90 ) { print "int($memper) is more than 90"  }
evals/evals-magnet-#perl.lst[81]: $memper = 60.1; if ( int $memper > 90 ) { print "int($memper) is more than 90"  }
evals/evals-magnet-#perl.lst[82]: my @array = ("1234567890abcdefghij1234567890", "1234567890klmnopqrst1234567890", "1234567890bcdefghijk1234567890");    my @sorted = sort { substr($a, 9, 10) cmp substr($b, 9, 10) } @array;  [ @sorted ] # seems to work for me
evals/evals-magnet-#perl.lst[83]: my $a = sub{ shift == undef }; print "YES" if $a->( 1 );
evals/evals-magnet-#perl.lst[84]: my $a = sub{ shift == undef }; print "YES" if $a->( 'AF' );
evals/evals-magnet-#perl.lst[85]: my $copy; for my $foo (1) { $copy = $foo } [$copy]
evals/evals-magnet-#perl.lst[86]: my $foo = 42; my $bar = \$foo; local $$bar = 53;
evals/evals-magnet-#perl.lst[87]: my $foo; for  $foo (1) { $copy = $foo } [$foo]
evals/evals-magnet-#perl.lst[88]: my $foo; for $foo (1) { ''; } [$foo]
evals/evals-magnet-#perl.lst[89]: my @foo; local $foo[0] = 1; \@foo;
evals/evals-magnet-#perl.lst[90]: my $foo = "wi(bb)le"; qr/\Q$foo\E/
evals/evals-magnet-#perl.lst[91]: my $hack_int = 42; [ !!( $hack_int ^ $hack_int ) ]
evals/evals-magnet-#perl.lst[92]: my $hack_int = 42; "$hack_int"; [ !!( $hack_int ^ $hack_int ) ]
evals/evals-magnet-#perl.lst[93]: my $hack_str = "42"; [ !!( $hack_str ^ $hack_str ) ]
evals/evals-magnet-#perl.lst[94]: my %h = ( A => q(W), a => q(w), B => q(G), b => q(g), y => q(h) ); [join q(), map { $h{$_} } split //, q(Baby)]
evals/evals-magnet-#perl.lst[95]: my %h = (a..z)
evals/evals-magnet-#perl.lst[96]: my %h = a..z
evals/evals-magnet-#perl.lst[97]: my %h = (a..z); ${%h}
evals/evals-magnet-#perl.lst[98]: my %h = ('a'..'z'); ${%h}{"how strange"} = "is this, anyway?"; \%{%h};
evals/evals-magnet-#perl.lst[99]: my %h = (a..z); ${%h}{"how strange"} = "is this, anyway?"; \%{%h};
evals/evals-magnet-#perl.lst[100]:  my $h = {"foo" => 5, "bar" => 6, "baz" => 2}; [ sort { $h->{$a} <=> $h->{$b} } keys %$h ]
evals/evals-magnet-#perl.lst[101]:  my $h = {"foo" => 5, "bar" => 6, "baz" => 2}; [ sort keys %$h ]
evals/evals-magnet-#perl.lst[102]: my $h = {}; undef( %$h ); warn $h
evals/evals-magnet-#perl.lst[103]: my %map = map +( $_ => chr(ord()+1) ), 'A'..'Z', 'a'..'z'; @map{qw/A a Z z/} = qw/Z z A a/; my $encoded = 'Aneehw hr zvdrnld!'; $encoded =~ s#(.)#$map{$1} // $1#ge; $encoded
evals/evals-magnet-#perl.lst[104]: my @names=["Bill", "Smith", "John", "Jane"]; [$names[0][0]]
evals/evals-magnet-#perl.lst[105]: my @nums = 1..10; [\@nums]
evals/evals-magnet-#perl.lst[106]: my @nums = 1..10; [$nums[0]]
evals/evals-magnet-#perl.lst[107]: my $s = sub{wantarray?'YES':'NO'}; $z='a'; my( $fh ) =  $s->()  ||  $s->(); print $fh;
evals/evals-magnet-#perl.lst[108]: my $s = sub{wantarray?'YES':'NO'}; $z='a'; my( $fh ) =  $z =~/^(\d+)$/  ||  $s->(); print $fh;
evals/evals-magnet-#perl.lst[109]: my $str = "asdf"; open(my $fh, "+<", \$str) or die "open: $!"; [ <$fh> ]
evals/evals-magnet-#perl.lst[110]: my $str = "foo"; open my $fh, '<', \$str; <$fh>
evals/evals-magnet-#perl.lst[111]: my $str = "\x{2603}"; $fh = IO::String->new($str) or die "new: $!"; [ <$fh> ]
evals/evals-magnet-#perl.lst[112]: my $str = "\x{2603}"; open(my $fh, "+<", \$str) or die "open: $!"; [ <$fh> ]
evals/evals-magnet-#perl.lst[113]: my $test_link = "http://zombo.com/"; my $re = q`(?^:[a-zA-Z][a-zA-Z0-9\+]*):[\;\/\?\\@\&\=\+\$\,\[\]\p{isAlpha}A-Za-z0-9\-_\.\!\~\*\'\(\)%][\|\;\/\?\:\@\&\=\+\$\,\[\]\p{isAlpha}A-Za-z0-9\-_\.\!\~\*\'\(\)%#]*`; $test_link =~ /$re/g && warn 1; $test_link =~ /$re/g && warn 2; 
evals/evals-magnet-#perl.lst[114]: my $test = sub { say 'ran it' }; my $foo = \&$test;
evals/evals-magnet-#perl.lst[115]: my $test = sub { say 'ran it' }; my $foo = &$test;
evals/evals-magnet-#perl.lst[116]: my $t = v3232.95.3232;  [map ord, split //, $t]
evals/evals-magnet-#perl.lst[117]: my $t = v3232.95.3232; utf8::decode($t); $t
evals/evals-magnet-#perl.lst[118]: my $t = v3232.95.3232; utf8::downgrade($t); [map ord, split // 4t]
evals/evals-magnet-#perl.lst[119]: my $t = v3232.95.3232; utf8::downgrade($t); [map ord, split //, $t]
evals/evals-magnet-#perl.lst[120]: my $t = v3232.95.3232; utf8::downgrade($t); $t
evals/evals-magnet-#perl.lst[121]: my $t = v3232.95.3232;  utf8::encode($t); binmode STDOUT; $t
evals/evals-magnet-#perl.lst[122]: my $t = v3232.95.3232;  utf8::encode($t); binmode STDOUT, ":utf8"; $t
evals/evals-magnet-#perl.lst[123]: my $t = v3232.95.3232;  utf8::encode($t); [map ord, split //, $t]
evals/evals-magnet-#perl.lst[124]: my $t = v3232.95.3232; utf8::encode($t); $t
evals/evals-magnet-#perl.lst[125]: my $t = v3232.95.3232; utf::downgrade($t); $t
evals/evals-magnet-#perl.lst[126]: my $t = v3232.95.3232; utf::encode($t); $t
evals/evals-magnet-#perl.lst[127]: my %unstricthash = ( a => [ qw / 1 2 3 4 /] , b => [ qw/ camel snake  hummingbird hamster/ ]) ; for ( %unstricthash ) {  print  " @{ $_ } "  if (@{ $_ } )  }  ;
evals/evals-magnet-#perl.lst[128]: my $w = 'The'; my @r = "The\nend" =~ /$w$end/msg; @r;
evals/evals-magnet-#perl.lst[129]: my $w = 'The'; my @r = "The\nend" =~ /$w$end/msg; \@r
evals/evals-magnet-#perl.lst[130]: my $w = 'The'; "The\nend" =~ /$w$end/msg;
evals/evals-magnet-#perl.lst[131]: my $w = 'The'; ("The\nend" =~ /$w$end/msg);
evals/evals-magnet-#perl.lst[132]: my $x = [1..10]; say $x->@[2,4]
evals/evals-magnet-#perl.lst[133]: my $x = "lex"; eval 'say $x'
evals/evals-magnet-#perl.lst[134]:     $     OMG     =     8_0;    $                 OMG
evals/evals-magnet-#perl.lst[135]: package Foo { sub index { ... } index('aaaao', 'o'); }
evals/evals-magnet-#perl.lst[136]: package Foo; use strict; use warnings; our $VERSION = 'blah'; package main; say Foo->VERSION
evals/evals-magnet-#perl.lst[137]: package loose; sub import { shift; strict->unimport(@_) }; sub unimport { shift; strict->import(@_) }
evals/evals-magnet-#perl.lst[138]: [pack 'NI', 12345, 12345]
evals/evals-magnet-#perl.lst[139]: perl -e 'warn hey { "wtf" }'
evals/evals-magnet-#perl.lst[140]: 'Please identify via /msg NickServ identify <password>.' =~ /^(?:If this is your nickname, type|Please identify via|Type) \/msg NickServ identify/
evals/evals-magnet-#perl.lst[141]: print $code
evals/evals-magnet-#perl.lst[142]: print"F"x!($_%3).b x!($_%5)||$_ for 1..32
evals/evals-magnet-#perl.lst[143]: print "hi"
evals/evals-magnet-#perl.lst[144]: print "I'm a Perl ", 5 + !!"0", " program."
evals/evals-magnet-#perl.lst[145]: print sort { $|-- or -1 } 'ruJt tc,en hoetokarrasS h' =~ /./g
evals/evals-magnet-#perl.lst[146]: print v3232.95.3232
evals/evals-magnet-#perl.lst[147]: print 'YES'  if( 1 == undef ) 
evals/evals-magnet-#perl.lst[148]: ({qw/ a 1 b 2/})->{b} # kes
evals/evals-magnet-#perl.lst[149]: qw/BuildBot, Tinderbox, Hudson, Jenkins, TeamCity, Bamboo/[rand]
evals/evals-magnet-#perl.lst[150]: qw/dial_a_bottle  take_a_cab/[rand 2]
evals/evals-magnet-#perl.lst[151]: qw (foo bar);
evals/evals-magnet-#perl.lst[152]: qw ́yó
evals/evals-magnet-#perl.lst[153]: rindex "banana", "na"
evals/evals-magnet-#perl.lst[154]: say $$
evals/evals-magnet-#perl.lst[155]: say 0xFFFFFFFFFFFFFFFFF
evals/evals-magnet-#perl.lst[156]: say 1 + 1
evals/evals-magnet-#perl.lst[157]: say ༡ + ༢
evals/evals-magnet-#perl.lst[158]: say ⅓²
evals/evals-magnet-#perl.lst[159]: say `ps ax`
evals/evals-magnet-#perl.lst[160]: say q’42’;
evals/evals-magnet-#perl.lst[161]: say $^V
evals/evals-magnet-#perl.lst[162]: scalar ('a','b')
evals/evals-magnet-#perl.lst[163]: sprintf "%08b", 0x36
evals/evals-magnet-#perl.lst[164]: sprintf '%.18f', .025 + .05
evals/evals-magnet-#perl.lst[165]: sprintf '%.18f', .075
evals/evals-magnet-#perl.lst[166]: sprintf "%b", 0x36
evals/evals-magnet-#perl.lst[167]: sqrt(2)
evals/evals-magnet-#perl.lst[168]: sqrt(2)*(2 ** 16)
evals/evals-magnet-#perl.lst[169]: *STDOUT{IO}
evals/evals-magnet-#perl.lst[170]: $str = '2 floor'; $str =~ s/([0-9]*)\bFlo*r/${1}00/i; say $str
evals/evals-magnet-#perl.lst[171]: $str = '2 floor'; $str =~ s/([0-9]*)( +Flo*r)/${1}00$2/i; say $str
evals/evals-magnet-#perl.lst[172]: $str = '2 floor'; $str =~ s/([0-9]*) +Flo*r/${1}00/i; say $str
evals/evals-magnet-#perl.lst[173]: s TT$ Donald Trump
evals/evals-magnet-#perl.lst[174]: sub foo { "bar" }; goto +foo; print "foo"; bar: print "bar"
evals/evals-magnet-#perl.lst[175]: sub foo { "bar" }; goto +foo; say "foo"; bar: say "bar"
evals/evals-magnet-#perl.lst[176]: sub foo :lvalue { print "foo called"; $tmp }; tie &foo, "main";
evals/evals-magnet-#perl.lst[177]: sub foo { my $bar = \@_; $bar->[0] = 'abc'; 'def' }; my $quux = 42; foo($quux); $quux;
evals/evals-magnet-#perl.lst[178]: sub foo { my $bar = \@_; local $_[0] = 'abc'; 'def' }; my $quux = 42; foo($quux); $quux;
evals/evals-magnet-#perl.lst[179]: sub foo { my $bar = \@_; local $bar->[0] = 'abc'; 'def' }; my $quux = 42; foo($quux); $quux;
evals/evals-magnet-#perl.lst[180]: sub foo { my @x = (0,0,0); @x } [ [foo()], scalar foo() ]
evals/evals-magnet-#perl.lst[181]: sub hacker'Perl{"Perl @_,"}sub another'Just{"Just @_ "}     Just another Perl hacker, 
evals/evals-magnet-#perl.lst[182]: sub o { (!$_[0]) && (!$_[1]) } sub j { !( $_[0] && $_[1] ) }  sub p { !($_[0] || $_[1]) } [ map [o($_->[0], $_->[1]), j($_->[0], $_->[1]), p($_->[0], $_->[1])], [0, 0], [1, 0], [1, 1], [0, 1] ]
evals/evals-magnet-#perl.lst[183]: substr("banana", -2) =~ /na/
evals/evals-magnet-#perl.lst[184]: sub test { say 'ran it' }; my $test = *test; my $foo = \&$test;
evals/evals-magnet-#perl.lst[185]: sub test { say 'ran it' }; my $test = *test; ( \&$test ) -> ();
evals/evals-magnet-#perl.lst[186]: sub TIEHANDLE { [] }; sub READLINE { "asdf" }; sub AUTOLOAD { print "In autoload!"; 42 }; tie *FH, 'main'; [ scalar readline FH ];
evals/evals-magnet-#perl.lst[187]: system('ls')
FAILED TO EVAL!
evals/evals-magnet-#perl.lst[188]: use bigint; my ($k, $c) = ("3", "37"); say ((($k+0)**($c+0))-1);
evals/evals-magnet-#perl.lst[189]: use bigint; my ($k, $c) = ("3", "37"); say (($k**$c)-1);
evals/evals-magnet-#perl.lst[190]: use bigint; my ($k, $c) = (3, 37); say (($k**$c)-1);
evals/evals-magnet-#perl.lst[191]: use bigint; print 11**20;
evals/evals-magnet-#perl.lst[192]: use bigint; print 11**2000;
evals/evals-magnet-#perl.lst[193]: use DateTime; DateTime->now;
evals/evals-magnet-#perl.lst[194]: use DateTime; DateTime->now."";
evals/evals-magnet-#perl.lst[195]: use experimental 'postderef'; my $z =[ 1..10]; $z->$#* # or this
evals/evals-magnet-#perl.lst[196]: use experimental 'switch'; use warnings; given (1) { when (1) { print "ok"; } }
evals/evals-magnet-#perl.lst[197]: use feature 'refaliasing'; my @a = (1, 2, 3); \my (@b) = \(@a); @b[2] = 5; [@a];
evals/evals-magnet-#perl.lst[198]: use feature 'refaliasing'; my @a = (1, 2, 3); \my (@b) = \(@a); @b[2] = 5; shift @b; [@a];
evals/evals-magnet-#perl.lst[199]: use feature 'refaliasing'; my @a = (1, 2, 3); \my @b = \@a; @b[2] = 5; shift @b; [@a];
evals/evals-magnet-#perl.lst[200]: use feature 'refaliasing'; my @a = (1, 2, 3); \my (@b) = \(@a); @b[2] = 5; shift @b; [@b];
evals/evals-magnet-#perl.lst[201]: use feature 'refaliasing'; my $zoit = [1 .. 3]; \my $narf = \$zoit; [ $narf ]
evals/evals-magnet-#perl.lst[202]: use feature 'refaliasing'; my $zoit = [1 .. 3]; my $narf = \$zoit; say $narf;
evals/evals-magnet-#perl.lst[203]: use feature 'refaliasing'; my $zoit = [1 .. 3]; my \$narf = \$zoit; say $narf;
evals/evals-magnet-#perl.lst[204]: use integer; my $x; for $x (1 .. 10 ) { say $x; }
evals/evals-magnet-#perl.lst[205]: use List::Util qw(reduce); reduce { my $key = join '', sort split '', $b; +{ %$a, $key => [ @{$a->{$key}||[]}, $b ] } } {}, qw(foo oof bar baz bza)
evals/evals-magnet-#perl.lst[206]: use List::Utils qw(reduce); reduce { my $key = join '', sort split '', $b; +{ %$a, $key => [ @{$a->{$key}||[]}, $b ] } } {}, qw(foo oof bar baz bza)
evals/evals-magnet-#perl.lst[207]: use open qw(:std utf8); say v3232.95.3232
evals/evals-magnet-#perl.lst[208]: use overload '&{}' => sub { sub { 42 } }; (bless [])->();
evals/evals-magnet-#perl.lst[209]: use overload '&{}' => sub { sub { 42 } }; my $foo = bless []; my $bar = bless [], 'baz'; [ $bar->$foo ]
evals/evals-magnet-#perl.lst[210]: use overload '&{}' => sub { sub { 42 } }; my $foo = bless []; my $bar = bless [], 'baz'; no overloading; [ $bar->$foo ]
evals/evals-magnet-#perl.lst[211]: use strict; my $foo  = () = 3; say $foo;
evals/evals-magnet-#perl.lst[212]: use strict; my( $foo ) = () = 3; say $foo;
evals/evals-magnet-#perl.lst[213]: use strict; my $foo = $bar = 3;
evals/evals-magnet-#perl.lst[214]: use strict; my $foo = my $bar = 3; say $bar;
evals/evals-magnet-#perl.lst[215]: use strict; my $foo = my $bar = 3; say $foo;
evals/evals-magnet-#perl.lst[216]: use strict; my $foo  = my( $bar ) = 3; say $foo;
evals/evals-magnet-#perl.lst[217]: use strict; my( $foo  ) = my( $bar ) = 3; say $foo;
evals/evals-magnet-#perl.lst[218]: use strict; my $w = 'The'; my @r = "The\nend" =~ /$w$(?:)end/msg; \@r
evals/evals-magnet-#perl.lst[219]: use strict; my $w = 'The'; my @r = "The\nend" =~ /$w$end/msg; \@r
evals/evals-magnet-#perl.lst[220]: use strict; my $z=7; my ( $fh ) =  $z =~/^(\d+)$/  ||  $fh; print $fh;
evals/evals-magnet-#perl.lst[221]: use strict; use warnings; my $h = {"foo" => 5, "bar" => 6, "baz" => 2}; print Dumper(@{$h}->{qw/foo bar baz/});
evals/evals-magnet-#perl.lst[222]: use strict; use warnings; sub TIEHANDLE { bless [] }; sub READLINE { "asdf" }; sub AUTOLOAD { print "In autoload!"; 42 }; tie *FH, 'main'; [ scalar readline FH ];
evals/evals-magnet-#perl.lst[223]: use strict; use warnings; sub TIEHANDLE { [] }; sub READLINE { "asdf" }; sub AUTOLOAD { print "In autoload!"; 42 }; tie *FH, 'main'; [ scalar readline FH ];
evals/evals-magnet-#perl.lst[224]: use ut8; sub 您好 { say "您好" }; 您好
evals/evals-magnet-#perl.lst[225]: use utf8; ${"☺"} = "❤"; binmode STDOUT; chr 1 + ord ${"☺"}
evals/evals-magnet-#perl.lst[226]: use utf8; package テスト; sub new { bless {}, shift} sub モー { say "モー" }; package main; テスト->new->モー
evals/evals-magnet-#perl.lst[227]: use utf8; package テスト; sub モー { say "モー" }; package main; テスト->new->モー
evals/evals-magnet-#perl.lst[228]: use utf8; qw ́yó
evals/evals-magnet-#perl.lst[229]: use utf8; say ༡ + ༢
evals/evals-magnet-#perl.lst[230]: use utf8; sub 您好 { say "您好" }; 您好
evals/evals-magnet-#perl.lst[231]: use v5.20; say "hi"; state $your_business;
evals/evals-magnet-#perl.lst[232]: use warnings; $^I = 42; [ \$^I, 0, eval("\$\t;"), $@ ]
evals/evals-magnet-#perl.lst[233]: use warnings; my @foo = 0..10; print "this matches" if "0 but true" ~~ @foo; # thanks, pink_mist++  
evals/evals-magnet-#perl.lst[234]: use warnings; my @foo = qw/bar/; print @foo[0] # Perl911 yours will warn I expect
evals/evals-magnet-#perl.lst[235]: use warnings; package Foo; sub index { ... }  index('aaaao', 'o');
evals/evals-magnet-#perl.lst[236]: use warnings; package Foo; sub index :method { ... }  index('aaaao', 'o');
evals/evals-magnet-#perl.lst[237]: use warnings; use experimental 'switch'; given (1) { when (1) { print "ok"; } }
evals/evals-magnet-#perl.lst[238]: use warnings; use feature 'switch'; given (1) { when (1) { print "ok"; } }
evals/evals-magnet-#perl.lst[239]: use warnings; use strict; my $x; for $x (1 .. 10) { last if $x % 2 == 0; } [ $x ]
evals/evals-magnet-#perl.lst[240]: [$^V]
evals/evals-magnet-#perl.lst[241]: $^V
evals/evals-magnet-#perl.lst[242]: v3232.95.3232
evals/evals-magnet-#perl.lst[243]: v3232.95.3232;  # This looks like à ² _ à ² 
evals/evals-magnet-#perl.lst[244]: [$^V,$^O, log(~0+1)/log(2)]
evals/evals-magnet-#perl.lst[245]: warn hey { "wtf" }
evals/evals-magnet-#perl.lst[246]: $_="Whfg nabgure crey unpxre"; tr/A-Za-z/N-ZA-Mn-za-m/;
evals/evals-magnet-#perl.lst[247]: $_="Whfg nabgure crey unpxre"; tr/A-Za-z/N-ZA-Mn-za-m/ * 2; 
evals/evals-magnet-#perl.lst[248]: $_="Whfg nabgure crey unpxre"; tr/A-Za-z/N-ZA-Mn-za-m/r; 
evals/evals-magnet-#perl.lst[249]: $_="Whfg nabgure crey unpxre"; tr/A-Zn-za-m/N-ZA-Ma-z/r;
evals/evals-magnet-#perl.lst[250]: write select
evals/evals-magnet-#perl.lst[251]: $^X
evals/evals-magnet-#perl.lst[252]: "\x{02}" =~ /\s/
evals/evals-magnet-#perl.lst[253]: %x = ( 1 => "a", b => 3 ); $str = "ab"; print $x{ $str =~ /(.)$/ }
evals/evals-magnet-#perl.lst[254]: "\x7f" =~ /[[:cntrl:]]/ ? "yes" : "no"
evals/evals-magnet-#perl.lst[255]: $x = 99; $x =~ s/([0-9])/${1}00/g; say $x
evals/evals-magnet-#perl.lst[256]: $x = 99; $x =~ s/([0-9])/${1}00/; say $x
evals/evals-magnet-#perl.lst[257]: "\x{a9}\x{263a}\x{2665}"
evals/evals-magnet-#perl.lst[258]: [ '+-++-X' =~ /([+\-](?=[+\-]*X))/g ]
evals/evals-magnet-#perl.lst[259]: $z=0; ( $fh ) =  $z =~/^(\d+)$/  ||  $fh; print $fh;
evals/evals-magnet-#perl.lst[260]: $z=7; ( $fh ) =  $z =~/^(\d+)$/  ||  $fh; print $fh;
evals/evals-magnet-#perl.lst[261]: $z='a'; my( $fh ) =  $z =~/^(\d+)$/  ||  sub {wantarray?'YES':'NO'}->(); print $fh;
evals/evals-magnet-#perl.lst[262]: $z='a'; my( $fh ) =  $z =~/^(\d+)$/  ||  (wantarray?'YES':'NO'); print $fh;
evals/evals-magnet-#perl.lst[263]: "Zoffix" =~ m ☃zof☃i ? 'yes' : 'nope'
./maketests.pl  10036.50s user 643.42s system 86% cpu 3:26:07.04 total
[1m[3m%[23m[1m[0m                                                                                                                                                                                             k../perlblead-ci\[0m[23m[24m[J[01;32mryan@simcop2387 [34m[02:08:34 AM] [00m[37m[~/workspace/perlblead-ci][00m [32m[master [31m*[32m][00m
[34m->[01;34m %[00m [K[?1h=lls[?1l>
kls\[0m[01;32mbuild_blead.sh[0m  [01;34mevals[0m  [01;32minstall_cpan.sh[0m  [01;32mmaketests.pl[0m  [01;32mstart.sh[0m  [01;34mt[0m  typescript
[1m[3m%[23m[1m[0m                                                                                                                                                                                             k../perlblead-ci\[0m[23m[24m[J[01;32mryan@simcop2387 [34m[02:12:30 AM] [00m[37m[~/workspace/perlblead-ci][00m [32m[master [31m*[32m][00m
[34m->[01;34m %[00m [K[?1h=l ddu -sh t/[31m......[39mM[0m[23m[24m[J[01;32mryan@simcop2387 [34m[02:12:30 AM] [00m[37m[~/workspace/perlblead-ci][00m [32m[master [31m*[32m][00m
[34m->[01;34m %[00m du -sh t/defs.json[1m [0m[K[0m [?1l>
kdu\7.4M	t/defs.json
[1m[3m%[23m[1m[0m                                                                                                                                                                                             k../perlblead-ci\[0m[23m[24m[J[01;32mryan@simcop2387 [34m[02:12:39 AM] [00m[37m[~/workspace/perlblead-ci][00m [32m[master [31m*[32m][00m
[34m->[01;34m %[00m [K[?1h=jjson_pp t/dfs  es fs.json[?1l>
kjson_pp\^C
[1m[3m%[23m[1m[0m                                                                                                                                                                                             k../perlblead-ci\[0m[23m[24m[J[01;32mryan@simcop2387 [34m[02:24:34 AM] [00m[37m[~/workspace/perlblead-ci][00m [32m[master [31m*[32m][00m
[34m->[01;34m %[00m [K[?1h=json_pp t/defs.json } | less    head[?1l>
kjson_pp\^C
[1m[3m%[23m[1m[0m                                                                                                                                                                                             k../perlblead-ci\[0m[23m[24m[J[01;32mryan@simcop2387 [34m[02:30:36 AM] [00m[37m[~/workspace/perlblead-ci][00m [32m[master [31m*[32m][00m
[34m->[01;34m %[00m [K[?1h=lless t/defs.json[?1l>
kless\[?1049h[?1h={"evals/evals-freenode-#perlbot.lst":[{"code":"\n","out":"","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","code":"- -\n"},{"code":"- - ' .'\n","err":"","out[m ":"0"},{"err":"","out":"0","code":"- - ' '\n"},{"err":"","out":"-","code":"- - '-'\n"},{"err":"","out":"0","code":"- - '.'\n"},{"out":"0","err":"","code":"- - '\"'\n"},{"code":"- - '+'\n","[m err":"","out":"+"},{"err":"","out":"0","code":"- - 'â[3m<U+009D>[23m§'\n"},{"err":"","out":"","code":";;;;;;;;;;;;;;;;;;;\n"},{"err":"","out":"$stdh_TOP","code":"\"$^\";\n"},{"err":"","out":"","co[m de":"()\n"},{"out":"","err":"","code":"();\n"},{"err":"","out":"[\"::\"]","code":"[ :: ]\n"},{"code":"[{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',]\n","err":"","out":"[\"HASH(0x61e8[m 900)\",\"HASH(0x61e8828)\",\"HASH(0x61e88b8)\",\"HASH(0x61e8840)\",\"HASH(0x4ff3438)\",\"HASH(0x5ee5fd8)\"]"},{"err":"","out":"[\"HASH(0x600d200)\",\"HASH(0x600d128)\",\"HASH(0x600d1b8)\",\[m "HASH(0x600d140)\",\"HASH(0x4e18028)\",\"HASH(0x5cd8388)\",\"HASH(0x5cd8358)\",\"HASH(0x5cd83a0)\",\"HASH(0x5cd83e8)\",\"HASH(0x5cd83d0)\",\"HASH(0x5cd8418)\",\"HASH(0x600d398)\"]","code":"[m [{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',]\n"},{"code":"[{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{}[m  . '', {} . '',{} . '', {} . '',\\]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"\\]\"\n","err":""},{"code":"@_\n","out":"1","err":""},{"out":"","err":"","code":"$^]\n"},{"cod[m e":"$!\n","out":"Too many open files","err":""},{"code":"$]\n","err":"","out":"5.022001"},{"code":"\\@_\n","err":"","out":"[\"\\\\\\@_\"]"},{"code":"\\%::\n","err":"","out":"{longjmp => *::[m longjmp,\"JavaScript::\" => *{'::JavaScript::'},ECHOE => \\16,\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/DateTime/Format/ICal.pm\" => *{'::_</home/ryan/perl5/perlb[m rew/perls/perl-5.22.1/lib/site_perl/5.22.1/DateTime/Format/ICal.pm'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Clone.pm\" => *{'::_</home/ryan/perl5/[m perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Clone.pm'},\"_<MoreUtils.c\" => *{'::_<MoreUtils.c'},FP_SUBNORMAL => \\3,\"_<clearer Parse::Method::Signatures::clear_ppi_doc of[m  attribute ppi_doc (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Parse/Method/Signatures.pm line 72)\" => *{'::_<clearer Parse::Method::Signatures::clear_ppi_[m doc of attribute ppi_doc (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Parse/Method/Signatures.pm line 72)'},\"_<native delegation method MooseX::Declare::Con[m text::add_preamble_code_parts (push) of attribute preamble_code_parts (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/MooseX/Declare/Context.pm line 107)\" => *[m {'::_<native delegation method MooseX::Declare::Context::add_preamble_code_parts (push) of attribute preamble_code_parts (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_per[m l/5.22.1/MooseX/Declare/Context.pm line 107)'},STDERR_FILENO => \\2,shellwords => *::shellwords,\":\" => *{':::'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64[m -linux/auto/Sub/Identify/Identify.so\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/auto/Sub/Identify/Identify.so'},_POSIX_SAVED_IDS => \\1,_POSIX[m _NO_TRUNC => \\1,\"_<native delegation method MooseX::Declare::Context::add_scope_code_parts (push) of attribute scope_code_parts (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib[m /site_perl/5.22.1/MooseX/Declare/Context.pm line 131)\" => *{'::_<native delegation method MooseX::Declare::Context::add_scope_code_parts (push) of attribute scope_code_parts (defined at /h[m ome/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/MooseX/Declare/Context.pm line 131)'},ENODATA => \\61,\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86[m _64-linux/List/MoreUtils/XS.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/List/MoreUtils/XS.pm'},\"_<Piece.c\" => *{'::_<Piece.c'},\"_</home/r[m yan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/auto/Fcntl/Fcntl.so\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/auto/Fcntl/Fcntl.so'},role =[m > *::role,getcwd => *::getcwd,SIGQUIT => \\3,\"Language::\" => *{'::Language::'},\"_<mro_core.c\" => *{'::_<mro_core.c'},atoi => *::atoi,TCOON => \\1,\"_</home/ryan/perl5/perlbrew/perls/per[m l-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Meta/Method/Accessor/Native/Array/elements.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moos[m e/Meta/Method/Accessor/Native/Array/elements.pm'},\"_<xs/Method.c\" => *{'::_<xs/Method.c'},ERESTART => \\85,\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Regexp/Comm[m on/SEN.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Regexp/Common/SEN.pm'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Parse/Meth[m od/Signatures/Param/Named.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Parse/Method/Signatures/Param/Named.pm'},\"\\\\\" => *{'::\\\\'},bytes2str => *::by[m tes2str,\"_<reader Moose::Meta::Role::Attribute::_original_role (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Meta/Role.pm line 11)\" => *{[m [3mt/defs.json[23m[K[K/[Kee[Krr[Krr[K[1;1H{"evals/evals-freenode-#perlbot.lst":[{"code":"\n","out":"","err":""},{"err":"","out":"ERROR: syntax error at (eval 558) line 1, at EOF\n","code":"- -\n"},{"code":"- - ' .'\n","err":"","out[m [2;1H":"0"},{"err":"","out":"0","code":"- - ' '\n"},{"err":"","out":"-","code":"- - '-'\n"},{"err":"","out":"0","code":"- - '.'\n"},{"out":"0","err":"","code":"- - '\"'\n"},{"code":"- - '+'\n","[m [3;1Herr":"","out":"+"},{"err":"","out":"0","code":"- - 'â[3m<U+009D>[23m§'\n"},{"err":"","out":"","code":";;;;;;;;;;;;;;;;;;;\n"},{"err":"","out":"$stdh_TOP","code":"\"$^\";\n"},{"err":"","out":"","co[m [4;1Hde":"()\n"},{"out":"","err":"","code":"();\n"},{"err":"","out":"[\"::\"]","code":"[ :: ]\n"},{"code":"[{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',]\n","err":"","out":"[\"HASH(0x61e8[m [5;1H900)\",\"HASH(0x61e8828)\",\"HASH(0x61e88b8)\",\"HASH(0x61e8840)\",\"HASH(0x4ff3438)\",\"HASH(0x5ee5fd8)\"]"},{"err":"","out":"[\"HASH(0x600d200)\",\"HASH(0x600d128)\",\"HASH(0x600d1b8)\",\[m [6;1H"HASH(0x600d140)\",\"HASH(0x4e18028)\",\"HASH(0x5cd8388)\",\"HASH(0x5cd8358)\",\"HASH(0x5cd83a0)\",\"HASH(0x5cd83e8)\",\"HASH(0x5cd83d0)\",\"HASH(0x5cd8418)\",\"HASH(0x600d398)\"]","code":"[m [7;1H[{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',]\n"},{"code":"[{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{}[m [8;1H . '', {} . '',{} . '', {} . '',\\]\n","out":"ERROR: syntax error at (eval 558) line 1, near \"\\]\"\n","err":""},{"code":"@_\n","out":"1","err":""},{"out":"","err":"","code":"$^]\n"},{"cod[m [9;1He":"$!\n","out":"Too many open files","err":""},{"code":"$]\n","err":"","out":"5.022001"},{"code":"\\@_\n","err":"","out":"[\"\\\\\\@_\"]"},{"code":"\\%::\n","err":"","out":"{longjmp => *::[m [10;1Hlongjmp,\"JavaScript::\" => *{'::JavaScript::'},ECHOE => \\16,\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/DateTime/Format/ICal.pm\" => *{'::_</home/ryan/perl5/perlb[m [11;1Hrew/perls/perl-5.22.1/lib/site_perl/5.22.1/DateTime/Format/ICal.pm'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Clone.pm\" => *{'::_</home/ryan/perl5/[m [12;1Hperlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Clone.pm'},\"_<MoreUtils.c\" => *{'::_<MoreUtils.c'},FP_SUBNORMAL => \\3,\"_<clearer Parse::Method::Signatures::clear_ppi_doc of[m [13;1H attribute ppi_doc (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Parse/Method/Signatures.pm line 72)\" => *{'::_<clearer Parse::Method::Signatures::clear_ppi_[m [14;1Hdoc of attribute ppi_doc (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Parse/Method/Signatures.pm line 72)'},\"_<native delegation method MooseX::Declare::Con[m [15;1Htext::add_preamble_code_parts (push) of attribute preamble_code_parts (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/MooseX/Declare/Context.pm line 107)\" => *[m [16;1H{'::_<native delegation method MooseX::Declare::Context::add_preamble_code_parts (push) of attribute preamble_code_parts (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_per[m [17;1Hl/5.22.1/MooseX/Declare/Context.pm line 107)'},STDERR_FILENO => \\2,shellwords => *::shellwords,\":\" => *{':::'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64[m [18;1H-linux/auto/Sub/Identify/Identify.so\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/auto/Sub/Identify/Identify.so'},_POSIX_SAVED_IDS => \\1,_POSIX[m [19;1H_NO_TRUNC => \\1,\"_<native delegation method MooseX::Declare::Context::add_scope_code_parts (push) of attribute scope_code_parts (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib[m [20;1H/site_perl/5.22.1/MooseX/Declare/Context.pm line 131)\" => *{'::_<native delegation method MooseX::Declare::Context::add_scope_code_parts (push) of attribute scope_code_parts (defined at /h[m [21;1Home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/MooseX/Declare/Context.pm line 131)'},ENODATA => \\61,\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86[m [22;1H_64-linux/List/MoreUtils/XS.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/List/MoreUtils/XS.pm'},\"_<Piece.c\" => *{'::_<Piece.c'},\"_</home/r[m [23;1Hyan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/auto/Fcntl/Fcntl.so\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/auto/Fcntl/Fcntl.so'},role =[m [24;1H> *::role,getcwd => *::getcwd,SIGQUIT => \\3,\"Language::\" => *{'::Language::'},\"_<mro_core.c\" => *{'::_<mro_core.c'},atoi => *::atoi,TCOON => \\1,\"_</home/ryan/perl5/perlbrew/perls/per[m [25;1Hl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Meta/Method/Accessor/Native/Array/elements.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moos[m [26;1He/Meta/Method/Accessor/Native/Array/elements.pm'},\"_<xs/Method.c\" => *{'::_<xs/Method.c'},ERESTART => \\85,\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Regexp/Comm[m [27;1Hon/SEN.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Regexp/Common/SEN.pm'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Parse/Meth[m [28;1Hod/Signatures/Param/Named.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Parse/Method/Signatures/Param/Named.pm'},\"\\\\\" => *{'::\\\\'},bytes2str => *::by[m [29;1Htes2str,\"_<reader Moose::Meta::Role::Attribute::_original_role (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Meta/Role.pm line 11)\" => *{[m [30;1H[1;1H{"evals/evals-freenode-#perlbot.lst":[{"code":"\n","out":"","[3merr[23m":""},{"[3merr[23m":"","out":"ERROR: syntax [3merr[23mor at (eval 558) line 1, at EOF\n","code":"- -\n"},{"code":"- - ' .'\n","[3merr[23m":"","out[m [2;1H":"0"},{"[3merr[23m":"","out":"0","code":"- - ' '\n"},{"[3merr[23m":"","out":"-","code":"- - '-'\n"},{"[3merr[23m":"","out":"0","code":"- - '.'\n"},{"out":"0","[3merr[23m":"","code":"- - '\"'\n"},{"code":"- - '+'\n","[m [3;1H[3merr[23m":"","out":"+"},{"[3merr[23m":"","out":"0","code":"- - 'â[3m<U+009D>[23m§'\n"},{"[3merr[23m":"","out":"","code":";;;;;;;;;;;;;;;;;;;\n"},{"[3merr[23m":"","out":"$stdh_TOP","code":"\"$^\";\n"},{"[3merr[23m":"","out":"","co[m [4;1Hde":"()\n"},{"out":"","[3merr[23m":"","code":"();\n"},{"[3merr[23m":"","out":"[\"::\"]","code":"[ :: ]\n"},{"code":"[{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',]\n","[3merr[23m":"","out":"[\"HASH(0x61e8[m [5;1H900)\",\"HASH(0x61e8828)\",\"HASH(0x61e88b8)\",\"HASH(0x61e8840)\",\"HASH(0x4ff3438)\",\"HASH(0x5ee5fd8)\"]"},{"[3merr[23m":"","out":"[\"HASH(0x600d200)\",\"HASH(0x600d128)\",\"HASH(0x600d1b8)\",\[m [6;1H"HASH(0x600d140)\",\"HASH(0x4e18028)\",\"HASH(0x5cd8388)\",\"HASH(0x5cd8358)\",\"HASH(0x5cd83a0)\",\"HASH(0x5cd83e8)\",\"HASH(0x5cd83d0)\",\"HASH(0x5cd8418)\",\"HASH(0x600d398)\"]","code":"[m [7;1H[{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',]\n"},{"code":"[{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{}[m [8;1H . '', {} . '',{} . '', {} . '',\\]\n","out":"ERROR: syntax [3merr[23mor at (eval 558) line 1, near \"\\]\"\n","[3merr[23m":""},{"code":"@_\n","out":"1","[3merr[23m":""},{"out":"","[3merr[23m":"","code":"$^]\n"},{"cod[m [9;1He":"$!\n","out":"Too many open files","[3merr[23m":""},{"code":"$]\n","[3merr[23m":"","out":"5.022001"},{"code":"\\@_\n","[3merr[23m":"","out":"[\"\\\\\\@_\"]"},{"code":"\\%::\n","[3merr[23m":"","out":"{longjmp => *::[m [10;1Hlongjmp,\"JavaScript::\" => *{'::JavaScript::'},ECHOE => \\16,\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/DateTime/Format/ICal.pm\" => *{'::_</home/ryan/perl5/perlb[m [11;1Hrew/perls/perl-5.22.1/lib/site_perl/5.22.1/DateTime/Format/ICal.pm'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Clone.pm\" => *{'::_</home/ryan/perl5/[m [12;1Hperlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Clone.pm'},\"_<MoreUtils.c\" => *{'::_<MoreUtils.c'},FP_SUBNORMAL => \\3,\"_<clearer Parse::Method::Signatures::clear_ppi_doc of[m [13;1H attribute ppi_doc (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Parse/Method/Signatures.pm line 72)\" => *{'::_<clearer Parse::Method::Signatures::clear_ppi_[m [14;1Hdoc of attribute ppi_doc (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Parse/Method/Signatures.pm line 72)'},\"_<native delegation method MooseX::Declare::Con[m [15;1Htext::add_preamble_code_parts (push) of attribute preamble_code_parts (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/MooseX/Declare/Context.pm line 107)\" => *[m [16;1H{'::_<native delegation method MooseX::Declare::Context::add_preamble_code_parts (push) of attribute preamble_code_parts (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_per[m [17;1Hl/5.22.1/MooseX/Declare/Context.pm line 107)'},STDERR_FILENO => \\2,shellwords => *::shellwords,\":\" => *{':::'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64[m [18;1H-linux/auto/Sub/Identify/Identify.so\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/auto/Sub/Identify/Identify.so'},_POSIX_SAVED_IDS => \\1,_POSIX[m [19;1H_NO_TRUNC => \\1,\"_<native delegation method MooseX::Declare::Context::add_scope_code_parts (push) of attribute scope_code_parts (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib[m [20;1H/site_perl/5.22.1/MooseX/Declare/Context.pm line 131)\" => *{'::_<native delegation method MooseX::Declare::Context::add_scope_code_parts (push) of attribute scope_code_parts (defined at /h[m [21;1Home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/MooseX/Declare/Context.pm line 131)'},ENODATA => \\61,\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86[m [22;1H_64-linux/List/MoreUtils/XS.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/List/MoreUtils/XS.pm'},\"_<Piece.c\" => *{'::_<Piece.c'},\"_</home/r[m [23;1Hyan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/auto/Fcntl/Fcntl.so\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/auto/Fcntl/Fcntl.so'},role =[m [24;1H> *::role,getcwd => *::getcwd,SIGQUIT => \\3,\"Language::\" => *{'::Language::'},\"_<mro_core.c\" => *{'::_<mro_core.c'},atoi => *::atoi,TCOON => \\1,\"_</home/ryan/perl5/perlbrew/perls/per[m [25;1Hl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Meta/Method/Accessor/Native/Array/elements.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moos[m [26;1He/Meta/Method/Accessor/Native/Array/elements.pm'},\"_<xs/Method.c\" => *{'::_<xs/Method.c'},ERESTART => \\85,\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Regexp/Comm[m [27;1Hon/SEN.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Regexp/Common/SEN.pm'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Parse/Meth[m [28;1Hod/Signatures/Param/Named.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Parse/Method/Signatures/Param/Named.pm'},\"\\\\\" => *{'::\\\\'},bytes2str => *::by[m [29;1Htes2str,\"_<reader Moose::Meta::Role::Attribute::_original_role (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Meta/Role.pm line 11)\" => *{[m [30;1H[K:[K[K [KESCESC[K[[[K66[K~~[K'::_<reader Moose::Meta::Role::Attribute::_original_role (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Meta/Role.pm line 11)'},lseek => *::[m lseek,W_OK => \\2,\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Class/MOP/Method/Wrapped.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/s[m ite_perl/5.22.1/x86_64-linux/Class/MOP/Method/Wrapped.pm'},\"_<reader MooseX::Declare::Context::scope_code_parts (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1[m /MooseX/Declare/Context.pm line 131)\" => *{'::_<reader MooseX::Declare::Context::scope_code_parts (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/MooseX/Declar[m e/Context.pm line 131)'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Meta/TypeCoercion/Union.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-[m 5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Meta/TypeCoercion/Union.pm'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/re.pm\" => *{'::_</home/ryan/perl5/perlbr[m ew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/re.pm'},\"_<reader MooseX::Method::Signatures::Meta::Method::type_constraint (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_pe[m rl/5.22.1/MooseX/Method/Signatures/Meta/Method.pm line 78)\" => *{'::_<reader MooseX::Method::Signatures::Meta::Method::type_constraint (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22[m .1/lib/site_perl/5.22.1/MooseX/Method/Signatures/Meta/Method.pm line 78)'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/URI/Escape.pm\" => *{'::_</home/ryan/perl5/pe[m rlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/URI/Escape.pm'},\"_<accessor Moose::Meta::TypeConstraint::Parameterized::parameterized_from (defined at /home/ryan/perl5/perlbrew/perls/perl-5.[m 22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Util/TypeConstraints.pm line 26)\" => *{'::_<accessor Moose::Meta::TypeConstraint::Parameterized::parameterized_from (defined at /home/ryan/perl[m 5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Util/TypeConstraints.pm line 26)'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moo[m se/Meta/Method/Delegation.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Meta/Method/Delegation.pm'},\"_</home/ryan/perl5/perlbrew/perls/[m perl-5.22.1/lib/site_perl/5.22.1/Regexp/Common/URI/RFC1738.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Regexp/Common/URI/RFC1738.pm'},\"_<destructor Moos[m eX::Types::Structured::OverflowHandler::DESTROY (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/MooseX/Types/Structured/OverflowHandler.pm line 21)\" => *{'::_<[m destructor MooseX::Types::Structured::OverflowHandler::DESTROY (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/MooseX/Types/Structured/OverflowHandler.pm line 2[m 1)'},ENFILE => \\23,\"_<constructor Moose::Meta::Role::Composite::_new (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose.pm line 243)\" => *{':[m :_<constructor Moose::Meta::Role::Composite::_new (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose.pm line 243)'},setpgid => *::setpgid,CLOCKS[m _PER_SEC => \\1000000,\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/auto/DateTime/DateTime.so\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib[m /site_perl/5.22.1/x86_64-linux/auto/DateTime/DateTime.so'},\"_<destructor MooseX::Declare::StackItem::DESTROY (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Mo[m oseX/Declare/StackItem.pm line 57)\" => *{'::_<destructor MooseX::Declare::StackItem::DESTROY (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/MooseX/Declare/Sta[m ckItem.pm line 57)'},\"_<native delegation method MooseX::Types::Structured::MessageStack::dec_level (dec) of attribute level (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/sit[m e_perl/5.22.1/MooseX/Types/Structured/MessageStack.pm line 6)\" => *{'::_<native delegation method MooseX::Types::Structured::MessageStack::dec_level (dec) of attribute level (defined at /h[m ome/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/MooseX/Types/Structured/MessageStack.pm line 6)'},STDOUT_FILENO => \\1,RLIMIT_TCACHE => *::RLIMIT_TCACHE,\"_</home/ryan/perl5/[m perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Meta/Attribute.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Meta/Att[m ribute.pm'},\"Carp::\" => *{'::Carp::'},_POSIX_ARG_MAX => \\4096,tmpfile => *::tmpfile,\"_<reader Moose::Meta::Role::Composite::_overload_map of attribute _overloads (defined at /home/ryan/[m perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose.pm line 33)\" => *{'::_<reader Moose::Meta::Role::Composite::_overload_map of attribute _overloads (defined at /home[m /ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose.pm line 33)'},ENOBUFS => \\105,\"List::\" => *{'::List::'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib[m /site_perl/5.22.1/PPI/Token/Number/Hex.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/PPI/Token/Number/Hex.pm'},\"Win32::\" => *{'::Win32::'},\"^\" => *{'::[m :[K[K [KESCESC[K[[[K55[K~~[K[HMtes2str,\"_<reader Moose::Meta::Role::Attribute::_original_role (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Meta/Role.pm line 11)\" => *{[m[HMod/Signatures/Param/Named.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Parse/Method/Signatures/Param/Named.pm'},\"\\\\\" => *{'::\\\\'},bytes2str => *::by[m[HMon/SEN.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Regexp/Common/SEN.pm'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Parse/Meth[m[HMe/Meta/Method/Accessor/Native/Array/elements.pm'},\"_<xs/Method.c\" => *{'::_<xs/Method.c'},ERESTART => \\85,\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Regexp/Comm[m[HMl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Meta/Method/Accessor/Native/Array/elements.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moos[m[HM> *::role,getcwd => *::getcwd,SIGQUIT => \\3,\"Language::\" => *{'::Language::'},\"_<mro_core.c\" => *{'::_<mro_core.c'},atoi => *::atoi,TCOON => \\1,\"_</home/ryan/perl5/perlbrew/perls/per[m[HMyan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/auto/Fcntl/Fcntl.so\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/auto/Fcntl/Fcntl.so'},role =[m[HM_64-linux/List/MoreUtils/XS.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/List/MoreUtils/XS.pm'},\"_<Piece.c\" => *{'::_<Piece.c'},\"_</home/r[m[HMome/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/MooseX/Declare/Context.pm line 131)'},ENODATA => \\61,\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86[m[HM/site_perl/5.22.1/MooseX/Declare/Context.pm line 131)\" => *{'::_<native delegation method MooseX::Declare::Context::add_scope_code_parts (push) of attribute scope_code_parts (defined at /h[m[HM_NO_TRUNC => \\1,\"_<native delegation method MooseX::Declare::Context::add_scope_code_parts (push) of attribute scope_code_parts (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib[m[HM-linux/auto/Sub/Identify/Identify.so\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/auto/Sub/Identify/Identify.so'},_POSIX_SAVED_IDS => \\1,_POSIX[m[HMl/5.22.1/MooseX/Declare/Context.pm line 107)'},STDERR_FILENO => \\2,shellwords => *::shellwords,\":\" => *{':::'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64[m[HM{'::_<native delegation method MooseX::Declare::Context::add_preamble_code_parts (push) of attribute preamble_code_parts (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_per[m[HMtext::add_preamble_code_parts (push) of attribute preamble_code_parts (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/MooseX/Declare/Context.pm line 107)\" => *[m[HMdoc of attribute ppi_doc (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Parse/Method/Signatures.pm line 72)'},\"_<native delegation method MooseX::Declare::Con[m[HM attribute ppi_doc (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/Parse/Method/Signatures.pm line 72)\" => *{'::_<clearer Parse::Method::Signatures::clear_ppi_[m[HMperlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Clone.pm'},\"_<MoreUtils.c\" => *{'::_<MoreUtils.c'},FP_SUBNORMAL => \\3,\"_<clearer Parse::Method::Signatures::clear_ppi_doc of[m[HMrew/perls/perl-5.22.1/lib/site_perl/5.22.1/DateTime/Format/ICal.pm'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Clone.pm\" => *{'::_</home/ryan/perl5/[m[HMlongjmp,\"JavaScript::\" => *{'::JavaScript::'},ECHOE => \\16,\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/DateTime/Format/ICal.pm\" => *{'::_</home/ryan/perl5/perlb[m[HMe":"$!\n","out":"Too many open files","[3merr[23m":""},{"code":"$]\n","[3merr[23m":"","out":"5.022001"},{"code":"\\@_\n","[3merr[23m":"","out":"[\"\\\\\\@_\"]"},{"code":"\\%::\n","[3merr[23m":"","out":"{longjmp => *::[m[HM . '', {} . '',{} . '', {} . '',\\]\n","out":"ERROR: syntax [3merr[23mor at (eval 558) line 1, near \"\\]\"\n","[3merr[23m":""},{"code":"@_\n","out":"1","[3merr[23m":""},{"out":"","[3merr[23m":"","code":"$^]\n"},{"cod[m[HM[{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',]\n"},{"code":"[{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{}[m[HM"HASH(0x600d140)\",\"HASH(0x4e18028)\",\"HASH(0x5cd8388)\",\"HASH(0x5cd8358)\",\"HASH(0x5cd83a0)\",\"HASH(0x5cd83e8)\",\"HASH(0x5cd83d0)\",\"HASH(0x5cd8418)\",\"HASH(0x600d398)\"]","code":"[m[HM900)\",\"HASH(0x61e8828)\",\"HASH(0x61e88b8)\",\"HASH(0x61e8840)\",\"HASH(0x4ff3438)\",\"HASH(0x5ee5fd8)\"]"},{"[3merr[23m":"","out":"[\"HASH(0x600d200)\",\"HASH(0x600d128)\",\"HASH(0x600d1b8)\",\[m[HMde":"()\n"},{"out":"","[3merr[23m":"","code":"();\n"},{"[3merr[23m":"","out":"[\"::\"]","code":"[ :: ]\n"},{"code":"[{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',]\n","[3merr[23m":"","out":"[\"HASH(0x61e8[m[HM[3merr[23m":"","out":"+"},{"[3merr[23m":"","out":"0","code":"- - 'â[3m<U+009D>[23m§'\n"},{"[3merr[23m":"","out":"","code":";;;;;;;;;;;;;;;;;;;\n"},{"[3merr[23m":"","out":"$stdh_TOP","code":"\"$^\";\n"},{"[3merr[23m":"","out":"","co[m[HM":"0"},{"[3merr[23m":"","out":"0","code":"- - ' '\n"},{"[3merr[23m":"","out":"-","code":"- - '-'\n"},{"[3merr[23m":"","out":"0","code":"- - '.'\n"},{"out":"0","[3merr[23m":"","code":"- - '\"'\n"},{"code":"- - '+'\n","[m[HM{"evals/evals-freenode-#perlbot.lst":[{"code":"\n","out":"","[3merr[23m":""},{"[3merr[23m":"","out":"ERROR: syntax [3merr[23mor at (eval 558) line 1, at EOF\n","code":"- -\n"},{"code":"- - ' .'\n","[3merr[23m":"","out[m[30;1H[K:[K[K [KESCESC[K[[[K66[K~~[K'::_<reader Moose::Meta::Role::Attribute::_original_role (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Meta/Role.pm line 11)'},lseek => *::[m lseek,W_OK => \\2,\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Class/MOP/Method/Wrapped.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/s[m ite_perl/5.22.1/x86_64-linux/Class/MOP/Method/Wrapped.pm'},\"_<reader MooseX::Declare::Context::scope_code_parts (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1[m /MooseX/Declare/Context.pm line 131)\" => *{'::_<reader MooseX::Declare::Context::scope_code_parts (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/MooseX/Declar[m e/Context.pm line 131)'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Meta/TypeCoercion/Union.pm\" => *{'::_</home/ryan/perl5/perlbrew/perls/perl-[m 5.22.1/lib/site_perl/5.22.1/x86_64-linux/Moose/Meta/TypeCoercion/Union.pm'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/re.pm\" => *{'::_</home/ryan/perl5/perlbr[m ew/perls/perl-5.22.1/lib/5.22.1/x86_64-linux/re.pm'},\"_<reader MooseX::Method::Signatures::Meta::Method::type_constraint (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_pe[m rl/5.22.1/MooseX/Method/Signatures/Meta/Method.pm line 78)\" => *{'::_<reader MooseX::Method::Signatures::Meta::Method::type_constraint (defined at /home/ryan/perl5/perlbrew/perls/perl-5.22[m .1/lib/site_perl/5.22.1/MooseX/Method/Signatures/Meta/Method.pm line 78)'},\"_</home/ryan/perl5/perlbrew/perls/perl-5.22.1/lib/site_perl/5.22.1/URI/Escape.pm\" => *{'::_</home/ryan/perl5/pe[m [K[3mLine numbers turned off  (press RETURN)[23m[30;1H[K[K[?1l>[?1049l[1m[3m%[23m[1m[0m                                                                                                                                                                                             k../perlblead-ci\[0m[23m[24m[J[01;32mryan@simcop2387 [34m[02:32:40 AM] [00m[37m[~/workspace/perlblead-ci][00m [32m[master [31m*[32m][00m
[34m->[01;34m %[00m [K[?1h=lls[?1l>
kls\[0m[01;32mbuild_blead.sh[0m  [01;34mevals[0m  [01;32minstall_cpan.sh[0m  [01;32mmaketests.pl[0m  [01;32mstart.sh[0m  [01;34mt[0m  typescript
[1m[3m%[23m[1m[0m                                                                                                                                                                                             k../perlblead-ci\[0m[23m[24m[J[01;32mryan@simcop2387 [34m[02:33:00 AM] [00m[37m[~/workspace/perlblead-ci][00m [32m[master [31m*[32m][00m
[34m->[01;34m %[00m [K[?1h=ggit status[?1l>
kgit\On branch master
Your branch is ahead of 'origin/master' by 1 commit.
  (use "git push" to publish your local commits)
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	[31mmodified:   maketests.pl[m

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	[31mt/[m
	[31mtypescript[m

no changes added to commit (use "git add" and/or "git commit -a")
[1m[3m%[23m[1m[0m                                                                                                                                                                                             k../perlblead-ci\[0m[23m[24m[J[01;32mryan@simcop2387 [34m[02:33:02 AM] [00m[37m[~/workspace/perlblead-ci][00m [32m[master [31m*[32m][00m
[34m->[01;34m %[00m [K[?1h=ggit add t maketests.pl  pl ty  [?1l>
kgit\[1m[3m%[23m[1m[0m                                                                                                                                                                                             k../perlblead-ci\[0m[23m[24m[J[01;32mryan@simcop2387 [34m[02:33:10 AM] [00m[37m[~/workspace/perlblead-ci][00m [32m[master [31m*[32m][00m
[34m->[01;34m %[00m [K[?1h=mmv typ[31m......[39mM[0m[23m[24m[J[01;32mryan@simcop2387 [34m[02:33:10 AM] [00m[37m[~/workspace/perlblead-ci][00m [32m[master [31m*[32m][00m
[34m->[01;34m %[00m mv typescript[1m [0m[K[0m maketests.log[?1l>
kmv\[1m[3m%[23m[1m[0m                                                                                                                                                                                             k../perlblead-ci\[0m[23m[24m[J[01;32mryan@simcop2387 [34m[02:33:15 AM] [00m[37m[~/workspace/perlblead-ci][00m [32m[master [31m*[32m][00m
[34m->[01;34m %[00m [K[?1h=ggit add make[31m......[39mM[0m[23m[24m[J[01;32mryan@simcop2387 [34m[02:33:15 AM] [00m[37m[~/workspace/perlblead-ci][00m [32m[master [31m*[32m][00m
[34m->[01;34m %[00m git add maketests.log[1m [0m[K[0m [?1l>
kgit\[1m[3m%[23m[1m[0m                                                                                                                                                                                             k../perlblead-ci\[0m[23m[24m[J[01;32mryan@simcop2387 [34m[02:33:17 AM] [00m[37m[~/workspace/perlblead-ci][00m [32m[master [31m*[32m][00m
[34m->[01;34m %[00m [K[?1h=eexit[?1l>
kexit\
Script done on Mon 11 Apr 2016 02:33:19 AM EDT
