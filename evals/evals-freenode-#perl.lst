~-~()
 [ "(" =~ /[(]/ ]
 [ "]" =~ /[\]]/ ]
- - _
- '-'
-(''.{})
-{}
;;
:)
?
?^?
/^+/
/[^]]/
/[/
/${#}/
/$#/
/$#//
/**/
...
'^\/\/'
'=' =~ /=/
''
''.[]
'@' ^ '$'
"
"'" =~ /'/
"" . \ ""
"" . \ "" . \ ""
"" . \\ ""
""->()
"[" =~ /[[]/
"$_"
"$( $)"
"${}"
"\"
"\["
"❇"
"ほげ"
();
[~~( )]
[ !() ]
[ @_ ]
[ $| ]
[ $$ ]
[ $$$ ]
[ ⓴ ]
['
['']
[""]
[]
[] == []
[]->$#*
[{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',{} . '', {} . '',]
[@_]
[$|--, $|--, $|--, $|--]
[$_]
[$,, $;]
[$;]
[$"]
[$[]
[$@]
[++$|, ++$|, --$|, --$|]
[++$|, ++$|]
[++$|; ++$|]
{;} + {}
{} {}
{} + {}
@_
@{ [] } // []
@{[]}=()
@#
@#{ [] }
$
$^_^$;;
$_ = '
$;
$!
$!->()
$?
$"
$";
$[++
$]
$@
$$
$#
$%
*_
*{""}
*{}
\[]->[[]]
\{}
\@_
\@.
\$_
\%::
∞
~0
!0
!!0
"\0"
[~~"0"]
[~0]
[ !!0 ]
[ "".{}, 0+{} ]
[ ""{}, 0+{} ]
[ 0 + '⓴' ]
[ 0 + $!, "$!" ]
[!!"0"]
['0' .. ':']
["\0"]
[] + 0
[]+0
$0
$_ = '0'; $_++; $_
$_[0]
\0
0!
0+[]
0+{}
!!'0.0'
"" . \ 0 . \ 0
[ (!!0) + 0 ]
[(0 ** 0)]
$0->[0]
0 ^ 0
0 == 0
0->[0]
0/0
0**0
0+ ½
0+'½'
$_ = '000'; $_++; $_
&{0 == &{0 == 0}} * 0
"000000" && "foo";
[ 0.00_02 ]
["0.00_02" + 0]
'000202056D4C' =~ s/..\K\B/:/gr
0+!! 0==1
(001234 ^ 01234) =~ /(^\0*)/; length $1
0+!!(0==1) # what I probably meant
'008' == 8
[ ~0, ~0 =~ s/(?=(\d{3})+$)/,/gr ]
"00" ? "true" : "false";
$_ = "\0\0"; vec($_, 7, 1)=1; [unpack "s>", $_]
[ 0 & 0xFF, 0 >> 8 & 0xFF ]
~0 + 1
"0" | "1"
[0,1]
$< = $$ ? 0+<=><=><=>:+1
$_ = '0.1'; $_++; $_
0/1
~0 + 1 > ~0
[0?1:0,0e0?1:0]
[0?1:0,0E0?1:0]
[0, '1'] ~~ [0, 1]
"010" ~~ [ 10 ]
[ 0.1 + 0.2, ((0.1 + 0.2) == 0.3) ? 'y' : 'n' ] #weird
(("010"+2)/(010+2))*5
0.1 + 0.2 - 0.3
~0 + 1 == ~0 ? 64 : 32
0 + "1+1"
[ "01101000 01100101 01101100 01110000" =~ /\d+/g ]; ### ZoffixWeb, why does it return an array when \d+ isn't in a capture group?
"011112233" =~ /^0[0-9]*\s*\z/
01.23
01.23 >= 2.34 ? "greater or equal" : "nope"
"0123456" ~~ 123_456
'01234567891b' =~ s/(..)(?!$)/$1:/gr
'01234567891b' =~ s/..\K\B/:/gr
[ "-0123456789abcdefghi" =~ /[[:xdigit:]]/g ]
$_ = "\0\1\2"; s/([\x00-\x1f])/"\x{2400}" | $1/eg; $_
$_ = "\0\1\2"; s/([\x00-\x1f])/"\x{2400}" | $1/eg; \$_
"0" | "1.5"
[ 0 .. 15 ]
["0" | "1.5"]
(0)*150
01777
[ ¡!0, ¡!1 ] # this might not "work", for example
~0 + 2
$#{[0..2]}
~0 * 2 > ~0
02/03/04
[@{[0 .. 20]}[5,10,3]]
[ 021, 017, 015, 013, 011, eval "09" || $@ ]
025
0 % -3
[ 0302, 0255 ]
031
[0320, 0230]
"\034"
0377
'03' lt '7'
$$[0]=3; print @$
[0 .. 4]
[ 0 || 42 ]
0 // 42
0444
0.45
[ 0.5, 0 .5, 0 . 5 ]
[ 0.5, 0. 5, 0 .5, 0 . 5 ]
[0.6 + 0.04, 0.64 + 0.04, 0.68 + 0.04]
0734
!! "0/8"
0+'    9'
0.99999999999929
0.9999999999999
0.99999999999999
0.9999999999999901
0.9999999999999901 > 0.99999999999999
0.9999999999999902 > 0.99999999999999
0.9999999999999919 > 0.9999999999999918
$_ = "0.9999999999999926"; sprintf '%.*f', length, $_
$_ = "0.9999999999999927"; sprintf '%.*f', length, $_
[ 0.999999999999999 == 1, 0.9999999999999999 == 1]
0b1_10010010
0b111 >> 1
0b11111
[ 0b11111, oct("31") ]
0bPortalMeme
"0 but true" + 1
'0 but true' ? 'true' : 'false'
'0BZMNDSFZNQOBNDOFGSN1SFZ!' =~ tr/\"-;N-ZA-M/A-Z a-z/r
'0BZMNDSFZNQOBNDOFGSN1SFZ!' =~ tr/\"-;N-ZA-M/A-Z a-z/r;
0E0 eq 0
'0e0' ? 'true' : 'false'
"0e0" ? "true" : "false"
0e0 ? 'true' :'false'
0e0 ? "true" : "false"
'0' && 'foo'
0 if 1
0+keys %INC
0=~m{}=~y///d
0o734
0;qq{@{sub{]]}}}}}
["\0" ? "T" : "F"]
[ 0?'t':'f', 00?'t':'f' ]
[ 0 == true ]
0 ? 'true' : 'false'
[ (0 == true) ? "true" : "false ];
[ (0 == true) ? "true" : "false" ];
"0" == undef
[ !!0, !!"", !!undef ]
$_[ ~0 ] = undef
0 == undef
[ !0, !'', !undef, !'0' ]
'<0x000D>' =~ s/<0x(....)>/"\N{U+$1}"/er
"<0x000D>" =~ s/<(0x[[:xdigit:]]{4})>/chr hex $1/ger
"<0x0034>" =~ s/<(0x[[:xdigit:]]{4})>/chr hex $1/ger
0x00FF
0x011b;
0x03 & 0x07f
0x0x0x0
"0x10" + 0
[0x110000, 2**20 + 2**16]
0x1.23
0x123abc
0x1.23p0
0x1252
0x173
[0x173, unpack("n", "\x01\x73"), unpack("v", "\x73\x01")]
[0x18, 0x12]
0x1a
0x1p-10
'<0x2004>' =~ s/<0x(....)>/"\N{U+$1}"/er
0x33 & 0x7f
0x3b1
0x4
0x4000
"0x4000"
0x41
0x4x0
0x61 & 0x31
[0x7200, 0x720000]
0xC0 & 0x7f
[0xc3, 0xa8]
0xcfedde
0xCFEDDE
0xDFEDDE
0xFF
0xFF & 0x07F
0xffff**3
0 xor 0
[ [0 xor 0], [1 xor 0], [0 xor 1], [1 xor 1] ]
[ 0 xor 0, 1 xor 0, 0 xor 1, 1 xor 1 ]
0 xor 1
0xpink_mist
!0=~y///d
1
~1
/(?(1)/
'' . \1
"1"
[] != -1
$ = 1; ++$
$[ = 1
1;
1++
10
-1%~0
'1' ^ '0'
1/0
[ '1' + 0 ^ '0' ]
100.
100/0.0000003
100 * 10000000
100./ 100./5
100. / 4
10 ** 0.5
[ "100.5" =~ /([-+]?\d+)(\.\d+)?\s*(g|mg)/ ]
[ "100.5 g" =~ /([-+]?\d+)(\.\d+)?\s*(g|mg)/ ]
"100.5 g" =~ /([-+]?\d+)(\.\d+)?\s*(g|mg)/; [$1, $2, $3]
[ !1, !0, !1+0]
[ "1.0" != 1.0, "1.0" ne 1.0 ]
'10/10/2010' =~ m[(\d\d)/(\d\d)/(\d\d\d\d)]; my $age = DateTime->new(year => $3, month => $2, day => $1)->delta_md(DateTime->now())->years;
10.123
101.97.114
102.0.114.0.111.0.109
1.0/2 + 1/4 + 1/8 + 2/16
1024 >> 6
1.0 == 3.0/2.9999999999999999999999999999999999
(1 == 0) + 5
10/7
1 - 0.99999999999903
10e30
10^length q|*******|
$. = 10; my ($what_you_think, $what_it_is) = ($.++,$.); [ $what_you_think, $what_it_is ]
1/(0*nan/nan)
'10%s' % 2
'10%s' % 3
$. = 10; scalar($.++,$.)
$. = 10; [ [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ], [ $.++, scalar(10..15) ] ];
$. = 10; [ [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ], [ scalar(10..15), $.++ ] ]
$. = 10; while (10..15) { print "$. "; $.++ }
$. = 10; while (10..20) { print "$. "; $.++ }
-1 >> 1
[ 1 == "1" ]
[1.1]
$1$1
1 ~~ '1'
1+1
1+'1'
[ (!!1) . '', (!!1) + 0 ]
[() = (1..10)]
[1 .. 10]
1/11
[ 1 | 1, 1 | 0, 0 | 1, 0 | 0 ]
"111" >> 1
1111111 =~ /^(1{1,10})(1{1,10})(1{1,10})$(?{ push @comb, [$1, $2, $3] })(?!)/; [map [map length, @$_], @comb]
"111" >> 2
[ (1,1,(),((1,2),,,,,,,3)) ]
11/13
11/15;
"111" << 8
"111" >> 8
[ 1 << 1, 2 << 1, 3 << 1 ]
"1122" =~ s/\d\d(\d\d)??//r #let's try
"1122" =~ s/\d\d(\d\d)?//r #no, it's greedy, Iota
$[ = -1; (1, 2, 3)[-2]
-1 & 127 # piko` - at a guess you're just getting this, and perldoc -f system covers it
{ 1+1 => 2, cats => 'dogs' }
+{ 1+1 => 2, cats => 'dogs' }
1/1.3
1.139999999999999
1 << 14
'11' lt '7'
[-1 .. -2]
[1,,,,,,2,,,,,,,]
1 + 2
1+2
{ 1 => [21] }
1/2 + 1/4 + 1/8 + 2/16
1./2 + 1/4 + 1/8 + 2/16
'12' =~ /1\B2/ ? 'match' : 'nope'
[1<=>2, 2<=>2, 3<=>2]
[ "1.22.333.4" =~ /\d+/g ]
~~1.23
.1 + .2 - .3
.1+.2-.3
(.1 + .2 == .3)
(1, 2, 3)
(1+2==3)
[ , 1 , 2 , 3 ]
[ \(1, 2, 3) ]
[ 1.2.3 . "" ]
"123" & 0x00FF;
[ %{[ 1, 2, 3 ]}[ 1,2 ] ]
123 == '123abc  '
(1,2,3)[1.5]
[ "1.2.3.192/26" =~ /((?:\d{1,3}\.){3}\d{1,3})(?!\/)/ ]
[ "1.2.3.192/26" =~ /((?:\d{1,3}\.){3}\d{1,3})(?!\/))/ ]
[ "1.2.3.192/26" =~ ((?:\d{1,3}\.){3}\d{1,3})(?!\/) ]
"@{[1 2 3 4]}"
"@{[1, 2, 3, 4]}"
'12341234' =~ /.*(3.*)/; $1
[ '%%123@@@@456&&234' =~ /(?<prefix>)\g{prefix}+(\d+)/g ] # still returned in the results, but sometimes looks cleaner than using \123
"123.45670000000" + 0
"123.45670000000"" + 0
" 1234567 " =~ / [0-9]{7} /;
$_ = "1234567"; /.{5,}/; [$1]
$_ = "1234567"; /(.){5,}/; [$1]
$_ = "1234567"; /(.{5,})/; [$1]
" 12345678 " =~ / [0-9]{7} /;
123456789012 =~ s/(\d\d\d)/$1,/gr
[ '1234567890' =~ /.{1,3}/g ]
1234567890 =~ s/(\d\d\d)/$1,/gr
[ "12345678" =~ m/(\d+{4})/g ]
[ "1234 5678" =~ m/(\d+)/g ]
[ "12345678" =~ m/(\d+)/g ]
$_="1234567"; s/(\d\d\d)/$1,/g; $_
[(1,2), (3,4), (5,6)] # Not what you think it will be, petrutrimbitas
"123456" =~ s/../reverse $&/ger
$_ = "123.456str789; $_++; $_
$_ = "123.456str789"; $_++; $_
"1/2/3/4/5" =~ s{^.*/(?=[^/])}{}
1.2345 =~ /^([^.])(\..*)?/ && sprintf( q{%03d}, $1 ). ( $2 // q{} ); ### leobut
"1/2/3/4/5/" =~ s{^.*/(?=[^/]$)}{}r
"1/2/3/4/5" =~ s{^.*/(?=[^/])}{}r
"1/2/3/4/5" =~ s{^.*/(?=[^/]$)}{}r
"1234abc"+0
'+1234' =~ m/^+/
'+1234' =~ s/^+//
'+1234' =~ s/^+//r
["1234x 123y" =~ /\d*(?:[02468]\D|[13579])/g ]
["1234x 123y" =~ m{((?>\d+)(?(?{$1 % 2 == 0}).))}g]
["1234x 123y" =~ m{((?>(\d+))(?(?{$2 % 2 == 0}).))}g]
12351
[ "123 5 12 7 " =~ /(\d+)\s*/g ] # or just numbers?
[ "123 5 12 7 " =~ m/(?<num>\d+)(?<space>\s*)/g ]; \%+
[ "123 5 12 7 " =~ m/(?<num>\d+)(?<space>\s*)/g ]; +{ %+ } # scope, I think?
"123abc" + 1
$_ = "123AG3GCAT422TG3"; [/([:alpha:]+)/]
$_ = "123AG3GCAT422TG3"; [/([[:alpha:]]+)/]
$_ = "123AG3GCAT422TG3"; [/([[:alpha:]]+)/g]
$_ = "123AG3GCAT422TG3"; [split /([[:alpha:]]+)/]
[ "[123]a test\n[345] second\nthird\n[456]more\n" =~ /(^\[.*?(?=^\[|$))/gsm ]
[ "[123]a test\n[345] second\nthird\n[456]more\n" =~ /(^\[.*?(?=^\[|\z))/gsm ]
1.2.3 eq "1.2.3"
'123' eq lc('123')
"123" eq uc "123";
"123 HAI STRINGS ARE COOL" + 5
"1.2.3" lt "1.10.0"
1.2.3 lt 1.10.0
$_ = '1_2_3'; m/(\w*_)/; push @arr, $1; m/(\w*?_)/; push @arr, $1; \@arr
$_=123;print eval'$_++.$/,'x10
"123" =~ s/2//gr
$_ = '1 2 3'; [ split ];
$_ = "123str456"; $_++; $_
*{123} = sub { "D:" }; &123
*{123} = sub { "D:" }; 123->()
*{123} = sub { "D:" }; \&123->()  # guessing this is also wrong
*{123} = sub { "D:" }; (bless {})->123
12*473
"125 some text" =~ s/^[1-9][0-9]* //r
[ 127.0.0.1 . ""]
[ 127.0.0.1 ]
128.129.130
("12 bananas buys you 0.1 ruby" =~ /\d+/g)[1]
("12 bananas buys you 1 ruby" =~ /\d+/g)[1]
'?=12' =~ /^\?(?:=(\d+))?/
$. = 12; my $x = 10..20; [ $x ]; ### I've read the link but think I'm misunderstanding something. $. appears to be within that range but it still returns false.
[ "12\n13\n14" =~ /(\d+)/g ]
@; = (1, 2); print @;;
[ 1, 2 ] # these brackets?
"@{[ 1+3 ]}"
"${\( 1+3 )}"
"1" & "3"
1 % -3
1.3 * 0.7
[ "1:30" =~ /(?:(\d*):)?(\d+)/ ]
[((1 << 3) - 1), 1+2+4]
1<<32
134.95 * 100
[  '1-3,5,6-9' =~ s/(\d+)-(\d+)/join ',', $1..$2/ger ]
".1.3.6.1.2.1.43.11.1.1.6.1.1" =~ m/\.(?!5|4|12)$/
1.3e12 / 300e6
[ "13month" =~ /(\d+)(\w+)/ ]
[1..4]
@_ = (1..4); $#_
[((1 << 4) - 1), 1+2+4+8]
1414364400 - 1414274400
'1.43531264539073e-11' * 10
1 < 4 < 6
14/88
1.4e8
1.4e9 - time
(14 gt 7) ? 'yes' : 'no' # maxstr just uses gt instead of >, this seems completely wrong for what you're asking
1/5
"150" |. "105"
[150 | 105, 150 |. 105]
"- 15:03:48,619  -" =~ /- (\d{2}:\d{2}:\d{2},\d{3}).{3,}/
"- 15:03:48,619  " =~ /- (\d{2}:\d{2}:\d{2},\d{3}).{3,}/
"- 15:03:48,619  -" =~ /- (\d{2}:\d{2}:\d{2},\d{3}).{4,}/
"- 15:03:48,619  -\n\r" =~ /- (\d{2}:\d{2}:\d{2},\d{3}).{4,}/
155.0 / 3.0
'15.8' == '15.80'
'15.8' == undef
1.5e308
@_ = (1 .. 5); $single = @_; $single
16 | 0
16 & 0
16 | 16
16 & 16
(1 << 63) - 1 + (1 << 63)
163.163.163
((16385 >> 12) <<12)
1.79e308
1 << 8
[ 180000000 / 57100  ]
18446744073709551615 + 1
18446744073709551616  - 18446744073709551000
[ 1890 & 8,  1890 & 32 ]
1.8e308
1.8e308-1
[1 << 90, 2**90]
[ 192.168.0.0 . '', '192.168.0.0' ]
[ 192.168.0.0, '192.168.0.0' ]
[ '1990-1992-1993-2010' =~ tr/-/ /r ]
19.99*100
1^9999
1999979/1999993
1**9999 # perl's spelling of "^"
"19" . (localtime)[5]
-+- "1abc"
-+-+-+-+-+- "1abc"
$[ = 1; ("A", "B", "C")[0]
'1e0' == 1
1e02.34
$_ = '1e1'; $_++; $_
1e10
1e1000
1e999
1e9999
[ 1 eq '1.0', 1 == '1.0' ]
[ 1 eq 1.0, 1 == 1.0 ]
1 eq 2 != 3
$1 = eval {a:}
("1foo"=~/(\d+)/)[0]
1 for @array;
1 if scalar \%hash
$1\l$2
$[ = -1; my @foo = qw/x y z/; [ $foo[-1] ]
[ 1=>'one' ];
[(1 or 0 and "foo"), ((1 or 0) and "foo")]
1p-10
$ = 1; print $++;
1+print 4
$! = 1; printf "SvPV is %s but SvIV is %d\n", $!, $!
1 =~ /^([^.])(\..*)?/ && sprintf( q{%03d}, $1 ). ( $2 // q{} ); ### leobut
1=>undef
1,undef
[ -1 - ~unpack 'N', join '', map chr, '192.168.254.43' =~ /\d+/g ]
1x4
2014-1989
2014-1997
$_ = "2015021900:00:00"; /^(....)(..)(..)/; "$1-$2-$3"
$_ = 2015021900:00:00; /^(....)(..)(..)/; "$1-$2-$3"
['2.0' == 2 ? "Y" : "N"]
[20 + 4]
[20+4]
2048 & 0x00FF
"²" =~ /[⁰-⁹]/
"  20:       ee110f10      mrc     15, 0, r0, cr1, cr0, {0}" =~ s/^\s+[0-9a-f]+:\s+([0-9a-f]+)\K/sprintf "     %b   ", hex $1/er #netz something like this then?
2**100
2**127;
2**1270;
"٢" =~ /[١-٣]/a
[ 2 << 1, 4 >> 1 ]
2**17 * 2**17
-2 % 1e6
2 + 2
2+2
[2**2*3]
*2 = 2.5; 2 + 2
*2 = 2.5; 2 + &2
"\22\a\6\21A\5SK" ^ 'foobar22'
[2.3 ^ 0, 2 . 3 ^ 0]
2 * 3 + 1
2**31
[ 23 ** 11, 2 ** 32 ]
2^32
2**32
(2**32)/1000/60/60/24/365
2**32 / 3600 / 24 / 365
[ 2.3, 2 . 3 ]  # different
23 % 24
(2**32)/60/60/24
2**32 =~ s/\B(?=(\d\d\d)+$)/,/gr
2**33
235 ^ 255
235 xor 255
240*(10**9)/(2**30)
240*10^9/2^30
24 % 24
24 + localtime
2**5
2**50 / 1000 / 3600 / 24 / 365  # that's a loooooong time @ 1000/sec
2**50  # really ?
25 % 24
255 & 0x7f
25 | 6 ** 4
[ 256 >> 8 ]
25**7
25 or 6 ** 4
260 / 3600
2**62
(2**63 - 1) + 2**63
2**64
2**64 - 1
265 % 2
2*710 . ' litres of beer tonight'
2733.754 % 60.0; ### Why exactly is it that this yields 33 instead of 33.754 ?
2**(7*8)
2790**2753 % 3233
2**8
2**88
28867 / 150000
(2903000/2903000)*100
29822 * length q|/gnu/store/d8fwypp5cnzjpc7kycmj4nj0gwn7k6lq-perl-xml-sax-0.99|
2 =~ /\A(?:(?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9])\z/
$! = 2; die "$!"
[2,grep{(1x$_)!~/^(..+)\1+$/}3..541]
$_ = 2; grep { $_ } qw(1 3 5); $_
(2 or 3)
*2 = sub {2.5}; 2 + &2
*{"2"} = sub { 'ok' }; [ main->${\2} ]
*{"2"} = sub { 'ok' }; [ main->2 ]
*{"2"} = sub { 'ok' }; [ my $two = 2; main->$two ]
*{"2"} = sub { 'ok' }; my $two = 2; [ main->$two ]
2 =~ /\w/
2x4
3
3_000_000 / 100  # this many seconds
30_000 * 30_000 / 2
300 x $60
'30/10/2010' =~ m[(\d\d)/(\d\d)/(\d\d\d\d)]; my $age = DateTime->new(year => $3, month => $2, day => $1)->delta_md(DateTime->now())->years;
"\303\203\302\241r j\303\203\302\272 s\303\203\302\272r?\n"
-30 % 60
307 * 500
[ ":30" =~ /(?:(\d*):)?(\d+)/ ]
[ 30 =~ /(?:(\d*):)?(\d+)/ ]
3 ** 12   # Actually :)
3 ** 13
"31323334" =~ s/.(.)/$1/gr
"31323334" =~ s/(..)/chr hex $1/g
"31323334" =~ s/(..)/chr hex $1/gr
"31323334" =~ s/(..)/chr hex $1/gre
3.141592653589793238462643383279502884
3 / 2
3 // 2
"321" =~ /\d+/
3/2 > 7/5
[ 3 ^ 3 ]
$_ = '"33.62" "114.72" "Blythe"'; s/(\S+)\s(\S+)\s(.+$)/$3 $1 $2/; $_ # seems happy enough, did you try it?
337 * 1051
(3 == 3) ? "yes" : "no";
"@{[ 3 + 4 ]}"
3.4/2.31012414912481924812904128490128412
$_ = "\345\207\272\350\262\250\346\230\216\347\264\260"; utf8::decode $_; [$_]
@3 = 4..9; \@3  # other global stuff :)
 3 ∗ 5;
3:5
3+5
350*24*365.25*100/(1024*1024) # about 300TB, why do you ask?
3568 / 100
360/24
365/((localtime)[7])
365/(localtime)[7]
'٣' =~ /./a
'٣' =~ /\d/a
'٣' =~ /\D/a
[ '٣' =~ /\d/a, '٣' =~ /./a, "٢" =~ /[١-٣]/a, '٣' =~ /\D/a ]
"(3/(x+2)+(-1/2)/(x-3))dx " =~ s/^\(((?:[^()]|\((?1)\))*)\)dx\s*$/$1/r
"(3/(x+2)+(-1/2)/(x-3))dx " =~ s/^\(((?:[^()]|\((?1)\))*\)dx\s*$/$1/r
404->()
$_ = '4 1 4 2 3'; @a=(); $a[abs $1-$']+=1 while / (\d+)(?= )/g; (!defined shift @a) && @a == $_ - 1 && $_ - 1 == grep($_ == 1, @a) ? 'jolly' : 'Not jolly'
 $_ = '4 1 4 2 3'; @deltas = 1; $deltas[abs $1 - $2] += 1 while / (\d+)(?= (\d+))/g;  grep($_ != 1, @deltas) ? 'Not jolly' : 'jolly'
42
[ ~42 ]
[ "" || 42 ]
[ "" // 42 ]
$_ = []; $_->[42] = $_; [ ''.$_, ''.$_->[42] ]
('42 bottles of beer' =~ /(\d+)/)[0]
[ !!42, !!"foo", !!{baz=>quux} ]
$_ = 42; [ \$_, \$main::_, \$main::main::_ ]
$_ = 42; [ map ${$_}, \$_, \$main::_, \$main::main::_ ]
$_ = 42; print map { $_ } qw(a b c); print "; $_"
[ '446744073709551615' =~ s/\B(?=(\d{3})+$)/,/gr ]  # fix
[ '446744073709551615' =~ s/(?=(\d{3})+$)/,/gr ]
45_000_000 * 24
(45/50-1)*100
(4,5,6)[-2..-1]
[(4,5,6)[-2..-1]]
47 % 24
[ 4 .. 9 ]
4 .. 9
49 & 97
"4-9" =~ /-/ and [eval '$`..$\'']
"4-9" =~ /-/ and [ split /,/, `perl -e'print join ",", $\` .. $'\'` ]
$_ = "4-9"; s/(\d+)-/$1,@{[$1+1]}-/ until /(?<=,)(\d+)-\1/; s//$1/; $_
$_ = "4-9"; s/(\d+)-/$1,@{[$1+1]}-/ until /(?<=,)(\d+)-\1/; s//$1/; [ /(\d+)/g ]  # better
$_ = "4-9"; s/-/../; [ eval ]
4[$array]
4*atan2(1,1)
$! = 4; die "$!"
$_[4] = ['foo']; $_->[4] = 'bar'; [ @{$_[4]} ];
$_[4] = ['foo']; $_->[4] = 'bar'; [ @$_[4] ];
$_ = '4x4x4'; y(4)(5); $_ # still potential for confusion though
[ .5]
[ 5. ]
[5 .. 0]
[ "5" & "000000" ]
*5000 = \5;
\*5000 = \5;
\*5000 = 5;
*5000 = \5; $5000
*5000 = \5; *5000
*5000 = sub {5}; 5 & & 5000
*5000 = sub {"Hello World"}; 10 &5000
*5000 = sub {"Hello World"}; \*5000->()
*5000 = sub {"Hello World"}; &5000
*5000 = sub {"Hello World"}; 5000->()
*5000 = sub {"Hello World"}; 5000()
*5000 = sub {"Hello World"}; "Hello" + &5000
[ 5/0.06 ]
5.013_006 # mauke typo I think
$] < 5.013006 #surely this is what he wants
[5 + 100]
[ 5 .. 12 ]
$] < 5.13.6
[5.14.0]
5.14.0
$✆ = 5; $✌ = 2; $✆ + $✌
[ "5" & "3" ]
5<=>3
5/3
[ 5 5 ]
5*5
5+5
5 == 5.0
[ 5 . 5, 5. 5, 5 .5, 5.5 ]
"5 + 5" =~ s/(.+)/ $1 /eer;
"5 + 5" =~ s/.*/$&/eer;
"5 5" =~ s/(.)\s(.)/$1 + $2/er;
"5 5" =~ s/(.)\s(.)/print $1 + $2/er;
[5+6]
5+6
5/7
[ 57100 / 180000000 ]
57+42  # perlbot is the most accessible calculator
[ 5.'a' ]
$! = 5; say $!
62 ** 4
64.64.64.5000000000.64.64.64
64.65.68.70
65280 & 127
65280 >> 8
65536 >> 16
65536 >> 8
[ 65.66.67 ]
[65.66.67]
6_5,6_6,6_7
6_5.6_6.6_7
65.66.67
~~667
6.6e-16 == 6.6 * 10 ** -16
6*710 . ' militres of beer tonight'
6 * 99.90
6 * 99.90 > 599.40
"6C5775272327642A382A453C327D3A31" =~ s/(..)/chr hex $1/gre
"6d73616e64626f78" =~ s/([0-9a-f]{2})/chr hex $1/eg
70 / 4.4
7200 * 12
7 + 32 + 64
 7 + 7 / 7 + 7 * 7 - 7
 7 + 7 / 7 + 7 x 7 - 7
$78_char_wide_text
[ 7 <=> "cats" ]
7 < 'D'
.7E9 / 604
[ 7 <=> 'nan' ]
8181 / 101
8181/9999
8192 / 1024
8 >> 2
(86274 ^ 87381) ** 2
"\8" eq "\9" ? "yes" : "no"
*9001 = \5;
9/11
953-176
97 =~ s/(\d+)/chr $1/er
97 =~ s/(\d+)/${\chr $1}/r
99.97.102.233
9999 / 101
$. = 9; [ [ $.++, scalar(10..15) ], ]
{a=>1}
@a=(1,2,3,4,5); [@a[-20..-1]]
@a=[1,2,3,4,5]; [@a[-20..-1]]
[ { a => 123 }, { b => 456 } ];
"a123b" =~ s/(\d+)/$1*100/er
@a = (1, 2, 3); print $#a;
$_ = "a1 2b 3 c 44"; [/(\d+)/g]
@a = (1, 2, 'foo'); grep { $_ eq 'foo' } @a[1..$#a]
$a = {1..4}; [keys $a]
@a=1..4; [{map{$_=>$_+1}@a[0..@a/2-1]},{map{$_=>$_+1}@a[@a/2..$#a]}]
@a = (1,5,2,4,3); @b = (5,3,1,4,2); (() = delete @{ { map {$_,1} @a } }{ @b }) == @b
@a = (1,5,2,4,6); @b = (5,3,1,4,2); (() = delete @{ { map {$_,1} @a } }{ @b }) == @a
@a = (1,5,2,4,6); @b = (5,3,1,4,2); "@{[sort @a]}" eq "@{[sort @b]}" ? same : different
@a = (1,5,2,4,6); @b = (5,6,1,4,2); "@{[sort @a]}" eq "@{[sort @b]}" ? same : different
@a = (1,5,2,4); @b = (5,3,1,4,2); (() = delete @{ { map {$_,1} @a } }{ @b }) == @b
{ a => 1, a => 2 }
$a=1; $b=1; LABL: while($a--) {try {die if $b--} catch {redo LABL;}; print "hello world"};
$a = 1; $b = 3; ($a/$b)*$b
@a = (1) x 1024*1024*30; $#a
@a = (1) x 1024*1024*5
@a = 2; [ @a == 2 ]
$a->[2]->{bar} eq 'baz'; $a
[ 'a 42 b' =~ s/\D+//, 'a 42 b' =~ s/\D+//g ]
[ 'a 42 b' =~ s/\D+//r, 'a 42 b' =~ s/\D+//gr ]
@a=(4,5,6); [ map [@a[0..@a-$_]], 1..@a+1 ]
%a=(a=>1); $s="a"; $s=~s/.+/$a{\1}/eg; print $s;
"<a<a></a>></a>" =~ /<a(.*)>(.*)<\/a>/
"<a<a></a>></a>" !~ /<a(.*)>(.*)<\/a>/
"aaaaaaaanother thing" =~ m/^(a+)/ and $+[1]
'AAAAABBBB' =~ /((.)\2*)(.*)/ ; [ $1, $3 ]
'aaaabbbbbccccddddd' =~ tr/abc//sr
"aaa b ccccc abcadaba" =~ tr/abc/abc/sr
$_ = 'aaa'; my $a = 5; ++$_ for $a; [ $_, $a ];
$_ = 'aaa'; my $a = 5; {local *_ = \$a; ++$_}; [ $_, $a ];
$_ = 'aaa'; my $a = 5; {local $_ = $a; ++$_}; [ $_, $a ]; # note that this, which uses 'local $_', acts differently
[ 'aaa' .. 'zzz' ]
[ "aabbaa" =~ /(aab??)(b+aa)/ ]
[ "aabbaa" =~ /(aab?)(b+aa)/ ]
"aabbcc" =~ s/(\w)\1/ $& /g;
@a = (); 'abcccccdefghi' =~ / (c) (?:(\1)(?{push @a, $1})){4} /x; \@a # backrefs :)
@a = (); 'abcdefghi' =~ / c (?:(.)(?{push @a, $1})){4} /x; \@a
@a = (); 'abcdefghi' =~ / c (?:(.)(?{push @a, $1})){4} (?!) /x; \@a
@a = (); 'abcdefghi' =~ / (?:(.)(?{push @a, $1})){4} (?= $ ) /x; \@a
@a = (); 'abcdefghi' =~ / (?:(.)(?{push @a, $1})){4} $ /x; \@a
$_="aabcdef"; print if /^a([abcd]+)ef$/ and $1 !~ /([abcd]).*\1/
$a="a.b.com";print "yes" if $a=~/^a.com$/
$a = 'a'; my $b = \$a; for $$b (0..5) { print $a }
$a = 'a'; my $b = \*a; for $$b (0..5) { print $a }
$a="asd1312321asd1212asd121212"; print $_,"\n" for $a=~/(asd\d+)/g;
[ @a=['asd qwe', 'qqq '];   /(\w+)\s+(\w+?)/ , print "$1 - $2" for ( @a )   ]
[ 'a' ^ 'A' ] # secret - the difference between upper and lower case is a space
"AA" =~ s/(.)(.)/\l$1$2/r
[ 'a' ^ 'b' ]
+{ a; b}
"ab12312532" =~ /.*3.*/
-+- "ab1c"
[ "a{b" =~ /a{/ ]
("AB" ^ "A4") =~ tr/\0\1-\377/01/r
[ "a" . "b", "a" . 5, 5 . "b", 5 . 5 ]
[ 'ababab' =~ /(ab)*/ ]
[ 'ababab' =~ /(ab)/g ]
[ "ab" =~ /(a)x|b/ ]
'ab' & 'b'
'ab' & 'ba'
["abba" =~ /(ab(ba))/]
"abba" =~ /(ab(ba))/; [$1, $2]
"ABBBBBBBABBA" =~ s/(B+)/length $1 < 3 ? 'C' x length $1 : $1/ger
'aBBBc' =~ s/[^a-z]//gr
$_ = 'Abbott &&& Costello'; s/\s\K\W+(?=\s)/and/; $_ # should work here though
[ 'Abbott &&& Costello' =~ s/(\s*)&&&(\s*)/$1and$2/gr ]
[~~"abc"]
['ABC']
A: B: C: ;
"ABC" & 0x00FF;
"abc" =~ "(..)"; $1
{ abc => 123 }->JSON::encode_json
[ "abc123___" =~ /\w+/g ]
[ "abc 30 def" =~ /abc (\d+) def/  ]
[ "abc 30 def" =~ /abc (\d) def/ || "No match" ]
[ "abc 30 def" =~ /abc (\d+) def/ || "No match" ]
[ 'abc446744073709551615' =~ s/\B(?=(\d{3})+$)/,/gr ]
[ 'abc446744073709551615' =~ s/(?<=\d)(?=(\d{3})+$)/,/gr ]
@abc = (5,6,7,8); $c = @abc[1,2]
"abc" =~ /a/
"abca9" =~ /(.)(.)(.)${3}9/
'abc' =~ /(a+)/; 'abc' =~ /(d+)/; [ 'bbaaccddee' =~ // ]
$_ = 'abcabcabc'; s/b(??{ ++$idx == 2 ? '' : 'no match' })/c/; $_ # except you'd never actually write code like this of course
[ "abcabca" =~ s/a.*a/CAT/r, "abcabca" =~ s/a.*?a/CAT/r ] # greedy vs not greedy
[ ("A","B"),("C","D") ]
[ 'abcd' & '1111' ]
[ "abcd123efg567h8i" =~ /([a-z]+|[0-9]+)/g ];
$_ = "abcd12ABCD"; print "[[$_]]" for  /(abcd|ABCD)/g
[ "abcd" =~ /^ab/ ]
$_="abcdaef"; print /^(a[abcd]+ef)$/ and $1 !~ /([abcd]).*\1/ ? "Yes" : "no";
$_="abcdaef"; print if /^(a[abcd]+)ef)$/ and $1 !~ /([abcd]).*\1/
$_="abcdaef"; print if /^a([abcd]+)ef$/ and $1 !~ /([abcd]).*\1/
$_="abcdaef"; print if /^a([abcd]+)ef$/ and $1 !~ /([abcd]).*\1(??{print $1})/
$_="abcdaef"; print if /^(a[abcd]+ef)$/ and $1 !~ /([abcd]).*\1/; print "done"
$_=abcda; print if /^([abcd]{1})+$/ or print "hmm"
[ 'abcdcdcd' =~ /(ab)(cd)*/ ]
[ "abcdef" =~ /^(?!.*([abcd]).*\1)a.*ef\z/s ]
$_ = "abcdef"; [ /abc(?=def)/ ? $& : 'fail' ]
"abc def" =~ /(?<first> \w+ )/x; [ $+{first} ]
'abcdefgh' & '11111111'
[ 'abcdefgh' =~ /(ab)(..)*/ ]
[ "ABCDEFGHABCD" =~ /(?=(....))/g ]
abcdefghi
'abcdefghi' =~ / (?{@a=()}) (?:(.)(?{push @a, $1})){4} (?= $ ) /x; \@a
 "abc,,def,ghi,,jkl" =~ s/(?<=,)(?=,)/\\N/gr
"abcdefg" =~ s/ef//; [ $-[0], length $` ]
$_ = "[a=b][c=d][e=f]"; my @matches = /(\[[^=]*=[^]]\])/g; [ @matches ]
$_ = "[a=b][c=d][e=f]"; my @matches = split /(\[[^\]]*\])/; [ @matches ]
$_ = "[a=b][c=d][e=f]"; my @matches = split /\[[^\]]*\]/; [ @matches ]
[ 'abcdef' =~ s/cd/XY/r ];
['abcde' =~ /(?=(...))/g]
$_= /a b c d/; @vars = (split)[2,3]; \@vars
"abc" =~ /(?<gold>bc)/; $1
'aBc' =~ m{([^a-z])}; [ $1 ]
["a b c\n", split]
@abc = qw(a b c); [ @abc => @abc ]
@abc = qw(a b c); [ \@abc => \@abc ]
'abc' =~ s/a//;
$_="abc"; s/a/ a /; $_
'abc' =~ s/a//r;
[ " a b c " =~ /\s+\S+/g ]
[ " a b c " =~ /\s*\S+/g ]  # to keep first non-space
 'abc,,"this is ,, a ,, string column",ghi,,jkl' =~ s/(?<=,)(?=,)/\\N/gr
($a, $b) = [ print("Miesco"), print("Miesco") ]
($a, $b) = [ print("Miesco"), print("Miesco") ]; print("$a"), print("$b")
'Abra Kadabra'->import; say 'Magic'
'a-b' =~ s/[a\- ]//gr
' a b ' =~ /\s\B\s/
'[a][b]' =~ s/[][]//gr
"a()[]{}<>b" =~ s/[][(){}<>]//gr
'a-b' =~ s/[- ]//r
'a-b' =~ s/[\- ]//r
['A' cmp 'a']
'a.com' =~ #(\w+\.)com$#
"a.com" =~ /(?:\w+\.)+com$/
'a' .. 'd'
['a' .. 'd']
add 5; sub add { $_[0]+1 }
$_ = '$addmodnav'; if(/^\$addmod/i) { if(/^\$addmod(?: )/i) { print "some other stuff" } else { print "args would be printed here" } }
$addr = PF_PACKET; $iface = "eth0"; $socket = pack("Sa14", $addr, $iface);
`adduser modulus`
['æ' =~ /([[:alpha:]])/]
['æ' =~ /([[:alpha:]])/a]
$_ = "æøå"; s/(.)/sprintf('\\u%04x', ord $1)/ger
$_ = "æøå"; s/(.)sprintf('\\u%04x', ord $1)/ger
"a" eq "b"
[ "a" eq "b" ]
@_ = ('a' .. 'e'); $single = @_; $single
@a = (foo => 1, bar => 2); print %{a}
@a = (foo => 1, bar => 2); print ${{@a}}{"a"}
@a = {foo => 1, bar => 2}; print ${$a}{"foo"}
$a="foo bar"; *$a = sub {"baz"}; "foo bar"->()
[ "a hash" cmp "an array" ]
@a = (); "Hello" =~ /.+(??{unshift@a,$&})/; \@a
@a = (); "Hello" =~ /.+$(??{unshift@a,$&})/; \@a
 <a href="http://www.yahoo.com/something.php?else=AoilkOoiud.FUoiu239834&ipadd=4.2.2.2&uri=a8s98loielulius_souej." min="s987ojeouyslkje"> =~ s/(<.*(src|href)="[_%&:\/\?=,\.a-z0-9-]+)[\?|#|&]ip(ad(d(r(ess?)?)?)?)?=([1-2]?[0-9]{1,2}\.[1-2]?[0-9]{1,2}\.[1-2]?[0-9]{1,2}\.[1-2]?[0-9]{1,2})([_%#&=\/\.a-z0-9-]*".*>)/$1$8/isg
$a = "it works"; print "${chr 97}"
$all = [[1,2],[4,5,6],[7,8]]; push @one, @$_ for @$all; \@one
@_ = "a"; { local @_ = "b"; } "@_"
'_' =~ /[:alpha:]/
$alpha{1}='1'; $alpha{'01'}='01'; $alpha{2}='2'; map { print "$alpha{$_},"; } sort { $a <=> $b || $alpha{$b} cmp $alpha{$a} } keys %alpha
$alpha{1}='1'; $alpha{01}='01'; $alpha{2}='2'; map { print "$alpha{$_},"; } sort { $a <=> $b || $alpha{$b} cmp $alpha{$a} } keys %alpha
$alpha{a}='1'; $alpha{b}='01'; $alpha{c}='2'; map { print "$alpha{$_},"; } sort { $a <=> $b || $alpha{$a} cmp $alpha{$b} } keys %alpha
$alpha{a}='1'; $alpha{b}='01'; $alpha{c}='2'; map { print "$alpha{$_},"; } sort { $a <=> $b || $alpha{$b} cmp $alpha{$a} } keys %alpha
$alpha{a}='1'; $alpha{b}='01'; $alpha{c}='2'; map { print "$alpha{$_},"; } sort { $b <=> $a || $alpha{$b} cmp $alpha{$a} } keys %alpha
$alpha{a}='1'; $alpha{b}='01'; $alpha{c}='2'; map { print "$alpha{$_},"; } sort { $b cmp $a || $alpha{$b} <=> $alpha{$a} } keys %alpha
"Also this: \N{PILE OF POO}"
*{$::{Altreus}}{SCALAR}
"Altreus" =~ s/^.*\Ke/s/sr
a..'m'
'a' =~ m\a\
a..'m',N..Z
a..m=>N..Z
[ a..'m',N..Z ] # list context
and evaldev: or so.
[ ............. and in regex i have ranges []...do i parse out the [] in the regex?
[ 'a' =~ /((.))/ ] # ningu how about this?
'### An introduction to Firmware Analysis' =~ s/### (.*)/1. [$1](#\L$1)/gr
"annoy"] ["meow" is f00bot: loleval VISIBLE "meow"] [$@ is variable storing the latest error in eval {} block. It's usually better idea to not use it directly and leave it to modules such as Try::Tiny.] [1 is eval: "1"] [8-ball is {eval @t=split"/",{fact 8-ball replies};$t[rand@t]}] [[Sno]: eval isn't part of the construct, that's... [Output truncated. Use `more` to read more]
[ "Another happy day" =~ m/(.\K..?)/gc ]
@answer = (); ' foo= bar1,bar2,bar3  ' =~ / +foo= +.*?(\b\w+\d+)(?{push @answer, $1})(*FAIL)/; \@answer
"A\N{U+0327}"
any {1} 1
any {$_ eq 'a'}, 'b', 'c'
"any string" =~ /alias:any string/
$a="one"; $a = $b || undef; print $a;
$_="Äö"; [ s/[^ä]/x/gir ]
'a' =~ /\P{In_Latin1}/
$a=[]; print !!@$a;
$a=[]; print !!$a
$a=[]; print !!${@a}
$a=[]; print !!${$a}
$a=[]; print !!$@a
$a = []; push $a, 1; $a  # right?
"a quine!: @_"
@a = qw(1 2 3); [ map { $_ == shift @a } @a ]
@a = qw( 1 one 2 two ); print "$_: $a[ $_ ] " for keys @a;
%a = qw ( 1 one 2 two ); print "$_: $a{$_}, " for keys %a
%a = qw ( 1 one 2 two ); print "$_: $a{$_}, " for keys %s
%a = qw ( 1 one 2 two ); print keys %a
%a = qw ( 1 one 2 two ); print scalar %a
%a = qw ( 1 one 2 two ); print scalar keys %a
@A = qw<a b c>; sprintf "%d elems: " . ("<%s>") x @A, scalar(@A), @A;
@a = (qw/foo bar baz/); @b = map {/bar/} @a; grep !defined, @b;
@a = (qw/foo bar baz/); @b = map {/bar/} @a; print Dumper(\@b);
@a = (qw/foo bar baz/); [map {/bar/} @a]
@a = (qw/foo bar baz); [map {/bar/} @a]
@a = (qw/foo bar baz/); [map {scalar /bar/} @a]
@a = qw(f o o); undef @a; push @a, qw( b a r );
$a=[qw/john paul george ringo/]; $str=join(', ', '?' x scalar @$a);
$a=[qw/john paul george ringo/]; $str=join(', ', ('?' x scalar @$a));
@a = qw(N 123); sub f { &CORE::pack }; f(@a)
@a = qw(N 123); sub f { &CORE::pack(@_) }; f(@a)
<>; \@ARGV
@ARGV
$#ARGV
*ARGV = [1]; print for <>;
@ar = (); [ map { $_->{a} } @ar ]
$ar = []; [ map { $_->{a} } @$ar ]
arn
@arr = ( 1, 2, 3, 4, 5 ); if ( $#arr == 4 ){ print "Total: $# arr" };
@arr = ( 1, 2, 3, 4, 5 ); if (!@arr) { print "array was empty"; }
@arr = ( '1','2','3','4' ); print @arr >>;
@arr = 1; [exists $arr[-1], exists $arr[-2]]
@arr1 = qw/ a b c /; @arr2 = @arr1;      ++$#arr1;     [ 'Arr1:', @arr1, 'Arr2:', @arr2 ] # modulus^ it seems you don't really understand that @arr1 *actually gets changed* when you do that ...
@arr1 = qw/ a b c /; @arr2 = @arr1;      ++$#arr1;       print '@arr1: ' . join(
@arr1 = qw/bob alan/; @arr2 = (50, 100); @foo{@arr2} = @arr1; $foo{50}
@arr=("a","b","c"); $r=rand(++$#arr); print "$#arr ", scalar @arr, " $arr[$r]"
@array/1
@array = 1..10; [ join ',', map '?', @array ]  # so would this
@array = 1..10; [ join ',', ('?') x @array ]
@array = (1,2,3); [ \(@array) ]
@array = (1,2,3); return join(',', @accounts);
@array=(1..5); $array[10]
@array = 1; for (@array) {$_ <= 100 and push @array, $_ * 2} \@array  # hehehe  (never do this :)
@array = ( 1=>"one", 2=>"two"); %hash = @array; map { print "k:$_ v:$hash{$_}, " } @array;
@array = ( 1=>"one", 2=>"two"); %hash = @array; map { print "k:$_ v:$hash{$_}" } @array;
@array = ( 1=>"one", 2=>"two"); %hash = @array; map { print "k:$_ v:$hash{$_}, " } keys @array;
@array = ( 1=>"one", 2=>"two"); %hash = @array; map { print "k:$_ v:$hash{$_}, " } keys @hash;
@array = ( 1=>"one", 2=>"two"); %hash = @array; map { print "k:$_ v:$hash{$_}, " } keys %hash;
$#array = -2
@array = (45,34,67,98); @array = grep $_ != 34, @array; \@array
@array = (45,34,67,98); @index{@array} = 0 .. $#array; splice @array, $index{34}, 1; \ @array
@array = (45,34,67,98); splice @array, $_, 1 for grep $array[$_] == 34, reverse 0 .. $#array; \@array
@array = ( 'a' .. 'c' ); printf "Array:" . ('%1$d - %s' x @array), 1, @array
@array = a..j;  [ @array[-@array .. -2] ]  # entire array except for last element (without modifying array)
@array = (('a')x55555); scalar @array
@array = (('a')x55); scalar @array
@array = (('a')x5); \@array
@array = (('a')x(5x10)); scalar @array
@array = map { $_ % 11 * int $_ / 11 } 0..120; \@array
@array = qw(1 2 3); print "match" if(any{ $_ eq '4'} @array);
@array = qw(1 2 3); say "match" if(any{ $_ eq '4'} @array);
@array = qw(1,2,3); say "match" if(any{ $_ eq '4'} @array);
@array = qw/a b c d e f/; splice @array, -1, 0, 'x'; \@array  # voila
@array = qw/a b c d e f/; splice @array, -2, 0, 'x'; \@array
@array = qw/a b c d e f/; splice @array, -2, 0, 'x'; \@array  # voila
@array = qw/a b c d e f/; splice @array, scalar(@array), 0, 'x'; \@array  # voila
@array = qw(SHOUTY SHOUT SHOUT); $_ = lc for @array; \@array
@array = qw//; splice @array, -2, 0, 'x'; \@array
$arrayref = ["a","b"];  "$arrayref->[1]"
$arrayref = [ { foo => bar, baz => m00 }, { lol => lulz, schweinerei => smut } ]; $arrayref->[1]{schweinerei}
$arrayref=[qw/a b c/]; scalar @{$arrayref}[1,2,3]
$arrayref=[qw/a b c]; scalar @{$arrayref}[1,2,3]
@arr='a'--'z';
@arr = (foo => 1, bar => 2); { %{a} }
@arr = (); if (!@arr) { print "array was empty"; }
$arr = []; push $arr, 1; $arr
@arr=qw/a b c/; $b = 3; printf "this :".("%d %s |" x @arr), $b, @arr;
@arr=qw/a b c/; @bong = (1..@arr); printf "this :".("%d %s |" x @arr), @bong, @arr;
@arr=qw/a b c/; $bong = 3; printf "this :".("%d %s |" x @arr), $bong, @arr;
@arr=qw/a b c/; sprintf "%d: '%s', " x @arr, %arr[0 .. $#arr]
@arr=qw/a b c/; $x = 3; printf '%.0s' . ('%1$d %s |' x @arr), $x, @arr;
@arr=qw/a b c/; $x = 3; printf '%1$d %s' x @arr, $x, @arr;
@arr = qw(one two three); sub f{print@{$_[0]}}f*{arr}{ref[]};
@arr = qw(one two three); sub f{print@{$_[0]}}f*{arr}{ref[]}; <-- *{arr}{ref[]}? o_O
@arr = undef; if (!@arr) { print "array was empty"; }
@ar = (undef); [ map { $_->{a} } @ar ]
$ar = [undef]; [ map { $_->{a} } @$ar ]
[ 'a' =~ s/(.)/('$1','$1')/re ]
[ 'a' =~ s/(.)/($1,$1)/re ]
[ 'a' =~ s/(.)/($1) x 2/re ]
$a=++$$.s/../$$/;$$<<~~+$a
'A' =~ s/(A)/lcfirst $1/re
$_="Ä"; [ s/ä/x/ir ]
[ "asd1312321asd1212asd121212" =~/(asd\d+)/g ]
~"asdf"
$asdf = []; 0 + !!@$blah
"asdf" =~ /(.)+/; [ $1 ]
$asdf=[1,2]; !!@$asdf;
$asdf=[]; !!@$asdf;
"asd.fg.foo.asd.fg" =~ /(.*)\.([^.]*)\.\1/
$asdf=[]; print !!@$asdf;
"        asdf    " =~ /^([\t ]+)/; my $indents = () = $1 =~ /(\t| {4})/g
"        asdf    " =~ /^([\t ]+)/; my $indents = () = $1 =~ /(\t| {8})/g
"        asdf    " =~ /^([\t\s]+)/; my $indents = () = $1 =~ /(\t|\s{4})/g
"        asdf    " =~ /^[\t\s]+/; my $indents = () = $1 =~ /(\t|\s{4})/g
("asdfX" ^ "asdfY") =~ /^\0*[^\0]\z/ ? 'yes' : 'no'
("asdfYt" ^ "asdfY") =~ /^\0*[^\0]\z/ ? 'yes' : 'no'
[ "asd   qwe" =~ /(\w+)\s(\w+?)/ ]
[ "asd   qwe" =~ /(\w+)\s+(\w+?)/ ]
"a" =~ s/(.)/\l$1/r
"A" =~ s/(.)/\l$1/r
@a = split //, 123456; join '', @a[map $_^1, 0..$#a]
"a string literal" ~~ ["a string literal"]
[ "a string literal" ] ~~ "a string literal"
["a string literal"] ~~ ["a string literal", "another string literal"]
{ a => sub { print 'foo' } }->{a}()
atan(0, -1)
atan2(0, -1)
'atcg' ^ 'agcg'
$a='the quick brown fox jumped over the lazy dogs'; $a=~s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $a;
$a="the quick brown fox jumped over the lazy dogs"; $a=~s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $a
"Ã\u{0086}ther"
"Ã\u0086ther"
$a=[]; use print !!$a
("a" x 20) =~ /a*b/;
[ ("a" x 20) =~ /(a*b)/ ];
[ ("a" x 20 . "b") =~ /((a*?)*b)/ ];
[ ("a" x 20 . "b") =~ /((a*)*b)/ ];
[ ("a" x 20 . "b") =~ /((a+?)*b)/ ];
[ ("a" x 20 . "b") =~ /((a+)*b)/ ];
[ ("a" x 20 . "b") =~ /(a*?b)/ ];
'a' x 3
[('a'++)x3]
[ ("a" x 30) =~ /((a|a?)+)/ ];
['a' x 4]
[('a') x 4]
('a,'x45) =~ s/(.*?,){10}\K/\n/gr
[ 'a' x 'b' ]
[ 'axcom' =~ /a.com/ ? 'yes' : 'no' ]
["a" xor "a"]
"A-Z" =~ /A-Z/ ? 'true' : 'false'
'_[a-z]+_(bd\d+_[a-z0-9]{7}_\d{6}_\d{4}(AM|PM)_PST).tar.gz'
"\\\\\\\\$backup_server\\\\$host"
"\\\\\\\\backup_server\\\\host"
"banana" =~ /(a)/; [ @- ]
"banana" =~ /(a)/; \@-
"banana" =~ /a/; \@-
[ "banana" =~ ?a? ]
[ "banana" =~ /.a/g ]
() = 'banana' =~ /(?=ana)/g
"banana" =~ /apple/; join //, qw(foo bar baz)
"banana" =~ /b(a)/; [ @- ]
"banana" =~ /(b|a|n)/g; [@-]
('banana' ^ 'batman') =~ s/(.)/chr(ord "0" + !ord $1)/ger
('banana' ^ 'batman') =~ s/(.)/chr(ord "0" + ord $1)/ger
('banana' ^ 'batma') =~ s/(.)/chr(ord "0" + !ord $1)/ger
$_ = "banana"; $from =~ /$_/i; [$from, $_]
$_ = "banana"; $from =~ /$_/i; [$from, $_, scalar /$_/i]
bananas
"banana" =~ s/a/o/gr
$_ = "banana"; [ s/(ba)/bo/ ]
$_ = "banana"; s/./sprintf '%2x', ord $&/ge; $_
"banana" =~ s/(.)/sprintf "\\x%x", $1/gers
"banana" =~ s/(.)/sprintf "\\x%x", ord $1/gers
('banan' ^ 'batman') =~ s/(.)/chr(ord "0" + !ord $1)/ger
"banannas" =~ /anna/
-(-bar)
'bar'
'bar'+0
$_ = "barbb"; my $count = 0 + s/b//g; [ $count, length($_), $_ ]
[ $_ = "barbb") =~ s/b//g ]
$_ = " bar"; /(foo)? (bar); [$1, $2]
$_ = " bar"; /(foo)? (bar)/; [$1, $2]
-(-'bar') # lul wat?
"B" =~ /A-Z/ ? 'true' : 'false'
$bday="1/1/1980"; ($byear) = $bday =~/(\d{4})/; print "".(localtime)[5]+1900 - $byear
$bday="1/1/1980"; ($byear) = $bday =~/(\d{4})/; print "".(localtime(time))[5]+1900 - $byear
"bead^corn" =~ /d^/
'beans [and rice]' =~ s/[]]/--> ] <--/r
"beans" . ' ' . "cornbread"
BEGIN(<>)
BEGIN { *buffalo:: = \%::; } *buffalo::buffalo::buffalo::buffalo
BEGIN { *CORE::GLOBAL::defined = sub { 42 }; } defined
BEGIN { *CORE::GLOBAL::ref = sub { 42 }; }  ref 42
BEGIN { *CORE::GLOBAL::ref = sub { "er, wait" }; }  ref 42
BEGIN { *CORE::GLOBAL::time = sub { 'override' } } *CORE::GLOBAL::time = \&CORE::time; time()
BEGIN { *CORE::GLOBAL::time = sub { 'override' } } [ time(), CORE::time() ]
 BEGIN { *foo = sub (&) { shift->("wibble") } } foo { [ @_ ] }
 BEGIN { *foo = sub (&) { shift->("wibble") } foo { [ @_ ] }
BEGIN { $^H = 0 }; open $fh, ">", \$str; $fh->say('asdf'); [ $str ]
BEGIN { $^H = 0 }; open $fh, ">", \$str; say {$fh} 'asdf'; [ $str ]
BEGIN { $^H = 0 }; open $fh, ">", \$str; say $fh 'asdf'; [ $str ]
BEGIN { $^H = 0 }; open $fh, ">", \$str; say {$fh} 'main'; [ $str ]
BEGIN { $^H = 0 }; say 42;
BEGIN { $^H = 0 }; say {$fh} 'main';
BEGIN { $^H{q} = sub {}; $^H |= 0x8000; } defined 'foo'
BEGIN { *keyys = \&CORE::keys; } my %foo = 1 .. 10; [ keyys %foo ]
BEGIN { *main::defined = sub { !1 } } defined("womble") ? "yes" : "no"
BEGIN{ my $p = \__PACKAGE__; &Internals::SvREADONLY($p, 0); $$p = 'foo'; } [ caller(0) ]
BEGIN{ my $p = \__PACKAGE__; &Internals::SvREADONLY($p, 0); $$p = 'foo'; } [ __PACKAGE__ ]
BEGIN { no strict 'refs'; *$_ = sub () :lvalue { state $x; $x } for qw/foo bar baz/; } foo = 1; bar = 2; baz = 3; [ foo, bar, baz ] # works for whatever
BEGIN { overload::constant integer => sub { state $x = 5; $x++ }; } my $foo = "5"; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say "surprise!" }
BEGIN { package X; *::defined = \&::defined; } sub defined { 42 } defined
BEGIN { $SIG{__DIE__} = sub { say 42; exit  };  }  a bc
BEGIN { $SIG{__DIE__} = sub { say 42; return  };  }  a bc
BEGIN { $::{true} = \!!1; $::{false} = \!!0 }; [ map { 0+$_, ''.$_, \$_ } true, false, !!0, !!1 ];
BEGIN{$^W=1}join+($x)x101
BEGIN { $::{wtf} = \"hi"; } "wtf"->();
BEGIN { $::{wtf} = \"hi"; } wtf()
BEGIN { $::{wtf} = \"hi"; } wtf( "bleh" )
BEGIN { $::{wtf} = \"hi"; } (\&wtf)->()  # runtime call
["big endian: " . 0x0000_0072, "little endian: " . 0x7200_0000 ]
"big fan of Fred, Frederick, and Wilma." =~ s/\b(Fred|Wilma)\b/Barney/gr
() = bike .. care
`/bin/ls`
`/bin/ls`; $!
binmode select; print chr 8305
binmode STDOUT; a^"☹"^b
binmode STDOUT; "♡"^b^u^u
binmode STDOUT; $_ = "CaMeL cAsE   iS sIlLy!  "; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
binmode STDOUT; $_ = "CaMeL cAsE   iS sIlLy! ?"; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
binmode STDOUT; $_ = "CaMeL cAsE   iS sIlLy! "; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
binmode STDOUT; $_ = "CaMeL cAsE  iS sIlLy! "; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
binmode STDOUT; $_ = "CaMeL cAsE iS sIlLy! "; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
binmode STDOUT; $_ = "CaMeL cAsE iS sIlLy!"; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
binmode STDOUT; Encode::decode("utf-8", "\x99\x99\x99\x99\x99\x99")
binmode STDOUT; $_ = "Just another Perl/BIDI Hacker,"; print "\x{202d}$1\x{202e}$3" while s/(.)(.*)(.)/$2/;
binmode STDOUT; 'Just another Unicode hacker,' =~ tr[\x20-\x7f][\xff00-\xff5f]r;
binmode STDOUT; my @d = qw( ‭ ‮ ); print "$_$d[rand 2]" for 'a'..'z'
binmode STDOUT; "\N{SPARKLE}";
binmode STDOUT; 'Perl can be awesome, sometimes,' =~ s,([\x20-\x7f]),chr(ord($1)-0x20+0xff00),gre;
binmode STDOUT; 'Perl can be awesome, sometimes,' =~ s[([\x20-\x7f])][chr(ord($1)-0x20+0xff00)]gre;
binmode STDOUT; 'Perl can be awesome, sometimes,' =~ s[(\x20-\x7f)][chr(ord($1)-0x20+0xff00)]gre;
binmode STDOUT; 'Perl can be awesome, sometimes,' =~ tr[\x20-\x7f][\x{ff00}-\x{ff5f}]r;
binmode STDOUT; 'Perl can be icky, lotsa times, <-ctrlc' =~ s/([\x0-\x7f])/$1/gre;
binmode STDOUT; 'Perl can be icky, lotsa times, <-ctrlc' =~ s/([\x0-\x7f])/chr(32^ord($1))/gre;
binmode STDOUT; 'Perl can be icky, lotsa times, <-ctrlc' =~ s/([\x20-\x7f])/$1/gre;
binmode STDOUT; 'Perl can be icky, lotsa times, <-ctrlc' =~ s/([\x20-\x7f])/$i/gre;
binmode STDOUT; 'Perl can be icky, lotsa times,' =~ s/([\x20-\x7f])/(chr(ord($1)-0x20+0xff00)/gre;
binmode STDOUT; 'Perl can be icky, lotsa times,' =~ s/([\x20-\x7f])/chr(ord($1)-0x20+0xff00)/gre;
binmode STDOUT; 'Perl can be icky, lotsa times, ' =~ s/([\x20-\x7f])/$_/gre;
binmode STDOUT; 'Perl can be icky, lotsa times,  =~ s/([\x20-\x7f])/$i/gre;
binmode STDOUT; print "\x{1f4a9}"
binmode STDOUT, ':raw'; print grep { /\d/ } map { chr } 0x1..0xe50 # for pink_mist's irssi
binmode STDOUT, ':raw'; print grep { /\d/ } map { chr } 0x11067..0x10ffff # how about these fonts ;)
binmode STDOUT, ':raw'; print grep { /\d/ } map { chr } 1..0x10ffff
binmode STDOUT; srand 42; my @o = ("\x{202d}", "\x{202e}"); print "$o[rand 2]$_" for split //, "rJust anekocath ehder oUcin";
$bla = (12, 13); $bla
($bla = ($bli, $blu)) = (12, 13, 14); [$bla, $bli, $blu]
'blah blah '\'' blah blah '\'' blah blah'
'blah' . print "a" . 'blah' . print "b"
[ "blah" =~ s/bl/h/r ]
$blah = { x=>1 }; $z => { y=>$blah->{x} }; $blah->{x} = "hello"; $z->{y}
"blalapi0" =~ /^lapi0$/ ? "match" : "no match"
"bleep"->bloop
[ "blehAAtingtongtangTTthe cat" =~ m/(AA.{1,23}TT)/ ]
$bleh = sub { print $_[0]; }; $bleh->("two");
$bleh = sub { print "$_" }; $bleh->("one");
$bleh = sub { print "$_" }; $bleh->("two");
$bleh = sub { print shift }; $bleh->("two");
bless {}, ""
"" . bless {}, "0"
bless [], "\0" # or something
"" . bless {}, "ARRAY"
bless \do { my $nou = undef }, "trolol"
bless {}, pack("ll",0xFEEDFACE,0xDEADBEEF)
bless []; [ ref \%main:: ]
bless []; [ ref %main:: ]
'' . bless {}, 'Some::Class'
bless \undef, "trolol"
bless you
bless \'you', 'Altreus'
bless([], "your::face")->import(42);
Blubb->new
"bold test end bold"
" *bold* _underline_ /italics/ normal "
'bool' gt '_Bool'
[ 'boooo' =~ /\w*(.)\1\w*/g ]
"btw, you can do the same kind of thing with trigger.pl"
"but not this" =~ m/^(a+)/ and $+[1]
but where do i put the test?
buu
"b"x10e10
"\^C"
$^C
$c = 0; [ ' foo (bar (baz) quux (blop)) ' =~ s/[()]/$& eq '(' ? $c++ ? '[' : $& : --$c ? ']' : $&/ger ]
$c = 1; while(my $e = glob "{foo,bar}") {print $c++, ") ", $e, "    "}
(caller(1))[3]
$(caller(1))[3]
${(caller(1))}[3]
""->can("foo");
'.canvas_container' =~ /\b\.canvas/
($capt) = 'hello world' =~ /(hello)/
($capt) = 'hello world' =~ /(hello)/; $cap
($capt) = 'hello world' =~ /(hello)/; $capt
carp 'haha'; with 'use Carp' it would run
[ "cat 10" =~ /(?:cat|dog)\s(\d+)/ ]
[ "cat 10" =~ /(?:cat)|(?:dog)\s(\d+)/ ]
[ 'catdog' =~ /(?=(\w{2}))./sg ]
[ 'catdog' =~ /(\w\K\w)/g ]
cats
~'cats'
"@cats"
[ "" || "cats" ]
+"cats"
"cats and dogs say hello world" =~ /hello world/
$cats = "cats"; $cats =~ s{$cats}'$dogs'r
$cats = "meow"; printf '"many cats %s"', $cats
$cats = "meow"; [qq("many cats $cats")]
$cats = "meow"; [ sprintf '"many cats %s"', $cats ]
"cats" =~ m pcatsp
"cats" =~ s'cats'$dogs'r
'cats' =~ s/(.)/\U$1/gr
"cats"->${ \sub {$_[0]} }
() = "C++" =~ /\b/g
[ "\cC" ]
"c" == "d"
"\cD" eq "\x04"
ceil(log(~0)/log(2))
char 0x3b
char 0x7b
char(2**16)
char(2*16)					        [13:56]
char('a')^char('A')
@charmap = qw/Botje!!!/; @charmap->[qw/Botje/]
@charmap = undef; \@charmap
charnames::viacode(0x666)
charnames::viacode(0xdf)
[chomp($_="")]
chr 0b01000001
[ chr 0b1111_1111 ]
chr 0x064b
chr 0x064e
[chr 0x11b, \x{11b}]
chr 0x1F5FE
chr(0x30)
chr 0x3b
chr 0x71
chr 0x7b
chr 0xe2
chr 0xe9
chr 0xfb06
chr(171)
chr(173) =~ /\N{SOFT HYPHEN}/;
chr(173) =~ /\N{U+AD}/;
chr(173) =~ /\xad/;
chr(173) =~ /\xAD/;
chr(2 << 15)
chr(2**16)					        [13:56]
chr 232
${\chr 24}
chr 24
chr 33
chr 34
chr 39
[chr(48) .. chr(48)]
[chr(48) .. chr(58)]
[chr 49, chr 10]
chr 5000000000
chr(51) . chr(76)
[chr(60) .. chr(88)]
chr 65
[chr(65) .. chr(100)]
[chr(65), chr(100)]
[chr(65] .. chr(100)]
chr 8304
\chr 8305
chr 8305
chr 86;
chr 9585.5
chr('a')^chr('A')
[chr(hex "3c"), "\x3c"]
chr(ord('a') + 2)
$c = join ',', a..z, A..Z, 0..9; [ glob "{$c}" x 2 ]
close(STDIN); close(STDOUT); close(STDERR); print "I have no mouth and I must scream"
{ Clubs => [ { Url => 'foo.com' } ] }->{Clubs}[0]{Url}
<code>
[$_, $code]
[$code]
$code
code; also pleval deparse rbeval jseval pyeval phpeval k20eval luaeval jeval.
<code here>
$code =~ s/^[^\$]*/eval: /r
$code =~ s/.*?\$/\$/r; # small quine
$code = sub { return () }; @r = (1,2,3); push @r, $code->(); \@r
$color = 'green'; $ref = \$color; $$ref = 'blue'; $color
@color = qw(blue white red); print $color[$#color];
@color = qw(blue white red); print $color[eval($#color)];
@color = qw(blue white red); print $color[rand($#color)];
command of perlbot, that's useful to perlbot to display things properly
COMMAND --password
"COMPRESSION_GZIP" eq "COMPRESS_GZIP" # let's ask perl
$_ = "  Computer  "; [ s/^ +| +$| Computer //gr, s/ Computer |^ +| +$//gr ]
$_ = "C omputer"; [ s/ |Computer//gr; s/ //gr =~ s/Computer//gr ]
$Config{osname}
*CONST = sub { 'haha' }; CONST
*CONST = sub { 'haha' }; CONST()
copy("$alt", "$neu");
CORE::dump()
[CORE::fc '€']
&CORE::for () CORE::for ();
CORE::GLOBAL::gmtime 0
CORE::gmtime
CORE::gmtime 0
CORE::gmtime 'NaN'
\&CORE::hex->("0x24")
\&CORE::lc
(\&CORE::lc)->('lol')
(\&CORE::lc)->(undef)
[ CORE::localtime ]
CORE::localtime
CORE::localtime + 24
CORE::localtime - 3600
CORE::localtime() - 3600
&CORE::open()
(\&CORE::print)->('a')
\&CORE::print->("foo")
(\&CORE::print)->('lol')
CORE::prototoype(\&CORE::die)
CORE::prototype(\&CORE::die)
CORE::prototype(\&CORE::prototype)
\(&CORE::ref)->([])
\&CORE::ref->([])
CORE::say "hi"
(\&CORE::say)->("/layout save")
CORE::stat('file')
&CORE::system("ls &") # aw, no symmetry for me :(
$count = 0; do { echo $count; $count++ } while ($count le 3);
$count = 0; do { print $count; $count++ } while ($count le 3);
$count = () = bike..care
++$count{$_} for split //, 'abcaba'; \ %count
$counts{int rand 5}++ for 1..100; \%counts
[ counts=>{},_keys=>() ]
'CryptoX' != 'CryptX' # orly
${ "\cV" }
${ "\cV" } . ''
$c=v0;'test! Test'=~s/[a-z]/$&^($c^=$")/gire
$c=v0;'test! Test'=~s/[a-z]/($c^=$")^lc$&/gire
$c=v0;'x!xx!x!x!'=~s/[a-z]/$&^($c^=$")/gire
['*.c' =~ /\*\.\w/]
$_ = 'd850e684e6de'; [join ':', unpack('(A2)*')]
'd850e684e6de' =~ s/..\K\B/:/gr
"daleks" lt "perl" # but of course perl would say that
[ 'data 234 foo 456 bar' =~ /(\d+).*bar$/ ]
[ 'data 234 foo 456 bar' =~ /(\d+)(?=.*bar$)/ ]
[ 'data 234 foo 456 bar' =~ /(\d+)(?:.*bar$)/ ]
@data = '25 25.175 jitter'; [split(/\s+/, $data];
database->quick_select($Table, \%Params, \%Options)
'data-date="02/14/2014"' =~ m!data-date="(\d\d/\d\d/\d\d\d\d)"!; [ $1 ]
$Data::Dumper::Indent = 0; $h = {'a' => {'one' => 1}, "b" => 2}; $i = {'a' => {'two' => 2}}; $j = {%$h, %$i}; print Dumper($j);
$Data::Dumper::Useperl = 1; open my $fh , '>', \my $str; [ *$fh{IO} ]
@data = ("foo"); $data[0]{label} = $data[0]; [@data]
"/data/install/smt/repo/\$RCE/SLES11-SP3-Updates/sle-11-x86_64"
Data::Munge::list2re ""
Data::Munge::list2re ();
Data::Munge::list2re qw(= == : --)
Data::Munge->VERSION
[`date`]
$_="date"; exec $_;
DateTime::Duration->new( minutes => 3, seconds => 15 )->in_units('seconds')
[ DateTime::Format::DateParse->parse_datetime("1:33PM")->time ]
DateTime->noew
~~DateTime->now
DateTime->now
DateTime->now->add(weeks => 1)->strftime('%U %W %V')
DateTime->now->set_month(11)->set_day(23)->truncate(to => "day")->subtract(weeks => 1)->ymd
DateTime->now->set_month(11)->set_month(23)->truncate(to => "day")->subtract(weeks => 1)->ymd
DateTime->now->strftime('%U %W %V')
DateTime::TimeZone->is_valid_name("America/New_York");
"D:/AU\ Files"
debugmsg("Value missing at %d:%d\n", 1, 5);   sub debugmsg { my $msg = sprintf(shift, @_); warn $msg; print $msg; }
debugmsg("Value missing at %d:%d\n", 1, 5);   sub debugmsg { my $msg = sprintf(@_); warn $msg; print $msg; } #since perlbot doesn't have $dbug opened, I removed it ... let's see what happens!
dec('008') == 8
\&decode_json
decode_json
decode_utf8("s\x{c3}\x{bc}\x{c3}\x{9f}e")
[ defined ${bless \do { my $nou = undef }, "trolol"} ];
[defined chomp($_="")]
defined fork
defined($INC[-1]) ? "yay" : "nay"
[ defined ${\undef} ]
delete *C::foo{CODE}
delete $undef->{foo}; print defined, ref for $foo
delete $undef->{foo}; print defined, ref for $undef
delete $undef->{key}; $undef
deparse: $::{true}
$deploys = [1..3]; [ @{$deploys}[-5 .. -1] ];
$deploys = [1..3]; [ grep $_, @{$deploys}[-3 .. -1] ];
$deploys = [1..3]; [ grep $_, @{$deploys}[-5 .. -1] ];
$deploys = [1..3]; push @foo, $_ for @{$deploys}[-5 .. -1]; [ @foo ]
DESTROY <>
die();
?: die 'Denied.';
()?(): die 'Denied.';
[ "died with signal " . (256 & 127), 256 & 128 ? 'core dumped' : '' ]
die "failed"
die "foo" . "\n"
die or do
die \"ref here";
Digest::MD5::md5_hex ""
$dirname = "/usr/share/local/"; $arg = '$dirname/'
"<div id=\"search-results\" ... >"
$_ = 'DoÆ'; s[(doÆ)][ $1 ^ lc $1 ^ 'cat' ]ier;
[ $$, do { $a=++$$.s/../$$/;$$<<~~+$a } ]
$_ = '"Doe","John "Johnny"","T",...'; s/(?<=[^,])"(?!,)/'/gr
$_ = 'Dog'; s[(dog)][ $1 ^ lc $1 ^ 'cat' ]er;
$_ = 'Dog'; s[(dog)][ $1 ^ lc $1 ^ 'cat' ]ier;
[ do { if(0) { 2 } else { 3 } } ]
[do { if (1) {} }]
[ do { if(1) { 2 } else { 3 } } ]
"doing it for fun" =~ s/fu/cpa/r
{ do { last } while 1 }
do { last } while 1
[do { my $asdf = 9; if ($asdf==9) {} }]
do { my $line = $_; chomp $line; say $line } for "asdf","asdf\n"
do { next }
do {} or die
do or die
do { print q{foo}; } while 0;
++do{ state $N }
do { ++state $N }
do { state $N++ }
do { $x = 1; $x +=2; } if 1; $x
"Dr doctor" =~ s/(Dr).+/$1/r;
drink_coffee() if $!{ ENOCAFFIENE };
Dumper(undef); use Data::Dumper
Dumper; use Data::Dumper
Dumper(); use Data::Dumper
Dumper([]); use Data::Dumper
-e
-'e'
-"e"
$_ = "é"; $_++; $_
$_ = 'e8b748680748'; [ s/..\K\B/:/gr ]
[ each @{[ qw( a b c d e ) ]} ]
each $^V
[ $!{EAGAIN} ]
[$!{EAGAIN}]
['è" =~ /[[:alpha:]]/, 'è' =~ /[[:alpha:&&
earlier
$e = "...brow,n"; $e =~ s/^\W*(\w+).*/$1/; [ $e ]
$e = "...brow,n"; $e =~ s/^\W*(\w+).*/\1/; [ $e ]
$e = "...brow,n"; $e =~ s/^\W*(\w+)\W*$/\1/; [ $e ]
echo true
`echo uuoo`
$e = ' e'; @x = (qw(a b c d), $e); \@x;   # quitte
$e = 'e'; @x = (qw(a b c d), $e); \@x;   # quitte
$e = 'e'; @x = qw(a b c d), $e; \@x;   # quitte
-e "foo"; $!
@elems = (0..5);  my $ref =  \@elems; $ref;
EmptyPkg->can("can")
EmptyPkg->can("DOES")
EmptyPkg->can("import")
EmptyPkg->can("isa")
Encode::decode_utf8(join "", map chr, qw(195 188 195 159))
Encode::decode("utf-8", "\x99\x99\x99\x99\x99\x99")
encode 'UTF-8', 'Ã¡r jÃº sÃºr?'
[encode_utf8("\x{2665}")] # works too, depening inthe output you want
END { ... }
END { print "1-" } END { die "2-" } END { print "3-" } # b100s
END {print "yes" } cvx{{Wr
[ %ENV ]
\%ENV
\%ENV;
%ENV
$ENV{meow} = undef; \%ENV
$ENV{PATH)
$ENV{PATH}
$ENV{PATH} = /home/somedir
$ENV{PATH} = "/home/somedir"
$ENV{TZ}
$ENV{TZ} = 'EST5EDT'; use POSIX qw/strftime/; strftime "%Y-%m-%d", gmtime 0
$ENV{TZ} = 'EST5EDT'; use POSIX qw/strftime/; strftime "%Y-%m-%d", localtime 0;
$ENV{TZ} = MST7MDT; scalar localtime;
$ENV{wibble} = []; \%ENV
EOF # are you a thing?
[ "EOL\r\n" =~ m/L$/,  "EOL\r\n" =~ m/L$/m ]
[ "EOL\r\n" =~ m/L$/,  "EOL\r\n", =~ m/L$/m ]
[ "EOL\r\n" =~ m/L\R\z/ ]
"Episode 1x4.mkv" =~ s{(\d+)x(\d+)}{ sprintf "s%02d%02d", $1, $2 + 1 }ger
"Episode 1x4.mkv" =~ s{(\d+)x(\d+)}{ sprintf "s%02d%02d", $1, $2 }ger
$_ = 'episode9'; s/episode(\d)/sprintf "e(%d)", $1 - 1/e
$_ = 'episode9'; s/episode(\d)/sprintf "e(%d)", $1 - 1/e; $_
"equal" if "aaaa" == "bbbb"
"equal" if "aaaa" eq "bbbb"
'' eq undef
Errno::ENOENT
[ eval "0.00_02" ]
eval '0;qq{@{sub{]]}}}}}'
[ eval '0x10', eval '10' ]
[eval "0x" . ('f' x 16), unpack("q", '\xff' x 8)] # hmm
eval {1}; [ $@ ]
eval "12w6d17h19m58s" =~ s/(\d+)(\w)/'+' . $1 * {qw(w 604800 d 86400 h 3600 m 60 s 1)}->{$2}/ger
[ eval '1-3,5,6-9' =~ s/-/../gr ]
eval{5 / 0} // 1
eval "\\\\\\\\backup_server\\\\host"
eval "\$       \b     leonerd = 42";
eval "\$       \b     leonerd = 42"; $@
eval { die 0; } say "Died" if $@;
eval { die 0; }; say "Died $@" if $@;
eval { die 0; }; say "Died" if $@;
eval { die JSON::false; }; say "Died $@" if $@;
eval {die \"ref here";} $$@
eval {die \"ref here";}; $$@
eval { die 'there you are' }; $@ # easily tested
eval { die undef } [ $@ ]
eval { die undef }; [ $@ ]
eval join '*', 1..10
eval(join '*', 1..30) / 1000 / 3600 / 24 / 365  # after heat death of universe ?
eval: $l = "abc"; $r = "ABC"; $l =~ s/./$&.substr($r,$-[0],1)/rge
eval "#line 0 /dev/null\n}"; $@
eval "#line 1 /dev/null\n}"; $@
eval "#line -42 /dev/null\n}"; $@
eval "\$       \n     leonerd = 42"; $@
eval "\$       \n     leonerd = 42"; $leonerd
eval {print 1; next; print 2}
eval { print "2" }
eval \{ print "2" }
eval &{ print "2" }
eval print "2"
eval { print "2" }; print $?
eval { print "2" }; print $@
eval "print 'nested\nlike\nthis'"
[ eval "qw(yes yes),\n#no\nqw(yes yes)" ]
eval { return 1; }; print "HELLO"
eval "say 1; next; say 2"
eval {say 1; next; say 2}
eval: $str="network=192.168.1.1; Dummy-SIGB=10.0.2.79; testbed-oam-net=135.111.74.116; Dummy-SIGA=10.0.1.111"; for ( split /\;/, $str ){ if ( /(.*)\=(.*)/ ){ print "$1,$2" } }
eval {sub C::foo {}; my $o = \&C::foo; undef &C::foo; $o->(); 1} or $@
eval "\$       \t     leonerd = 42"; $@
eval { undef->() }; "-> $@ <-"
eval { undef->() }; $@
eval "unpack 'S', \"\xff\xff\""
eval "\$       \v     leonerd = 42"; $@
eval "`who"."ami`"
eval '"'.'\x41\x41'.'"'
exec '/bin/ls'
exec 'ping', 'google.com'
exec '/usr/bin/ping', 'google.com'
exec $^X
exists ""
~~exp 2
exp(2)
*EXPORT = \@Foo::Bar::EXPORT; push @EXPORT, "hello world"; [ \@EXPORT, \@Foo::Bar::EXPORT ]
"#\\E \\z" =~ m{ \Q#\E \z}xms ? "wtf" : "k"
@F=(0..9,0);sub r{my($y,@x)=@_;map{ref$_ ? (&$_) :$_}@d=(@F,($y && sub{@F[$y-1,-1-$y]=($")x2;r(@x)}),@F%2|$y?@F:())}print r 1,1,3..@F/2-1
"f0b0" =~ /f(.)b\1/
fail?succeed:fail
FAIL x 2
false ? true : file_not_found
'false' ? "yes it is" : "no, it isn't" # place your bets!
%fancylist = ( 1,"one",2,"two",3,"three" ); print scalar %fancylist;
%fancylist = ( 1,"one",2,"two",3,"three" ); print scalar keys %fancylist;
fc('er') eq fc('Er')
fc "ß"
FF & 07F
[ -f "/", -f "/does-not-exist", -f undef ]
$_ = '@f@f@f'; s'@f'$b'gr;
$_ = 'file-bkp-2014-06-08'; [ map { s/bkp\K(\d*)/$1+1/e; $_ } ($_) x 12 ]
[ fileno STDIN, fileno STDOUT, fileno STDERR ]
@files = qw(one two three); 'there are ' . @files . ' files'
@files = qw(one two three); "there are @{[ scalar @files ]} files"
[ %{File::Stat::} ]
File::Stat->import; [ %{File::Stat::} ]
 $_ = "First Name Position first.name@somewhere.com 745 45363\nSome One Worker some.one@somewhere.com 343 5454\n" =~ s/^\s*(\S)\S*\s+(\S+).+?(\d\d\d \d\d\d\d)\s*/$1., $2, $3/gmr
$_ = "First.\nSecond.\nBla, bla, bla. \nHi.\t\nLast line.\n"; [ /^.*\h+$/gm ] # try \h if you only want horizontal whitespace
@_=('first','second'); print $_[0];
floor()
[ floor(-5/3), int(-5/3) ]
floor(85.3)
$fl = '+++????? random shit any user can send to the bot'; my @mem_list = grep { $_ =~ /^$fl/i} 42;
-F\"m S\"
foo
~~"foo"
-foo
'\'foo\''
'foo'
"" . \@{\*foo}
"foo" =~ /[.]/
(\*foo)->()
(\&{ \*foo })->()
[ "foo" =~ /()(.)/ ]
[${\ 'foo' }]
$_="foo
$_ = 'foo'; $::_
${\*foo}
$foo->@*
*foo
\\*foo
\&::foo
\&{ \*foo }->()
++$foo++
'foo'+0
foo { $$_[0] = 1 } foo \(my $x); $x
(\@{ \*foo })->[0]++; \@foo;
(\@{ \*foo })->[0]++; say @foo;
$_ = [['foo']]; @$_[0] # Which is entirely different from @{$_[0]}
$foo = 1; [ 0+$foo, map $foo++, 1..4 ] # if you wanted the other behaviour
$foo[-1] = 2
[ foo => (1, 2, 3) ]
[ foo => [1, 2, 3] ]
[ foo => 1, 2, 3 ]
{ +FOO => 123 }
@foo = ( 1, 2, 3 ); $" = ', '; [ "@foo" ]
{ foo => (1, 2, 3) } # perhaps more useful
[foo 1, 2, 3] sub foo { { thingy => $_[0] } }
"@{ [ %{ {foo => 12, bar => 13} }] }" # no hash slice involved
"foo=(1, 2)   bar=(3, 4)" =~ s/(?<=\()([^)]+)/$1=~s{\s+}{}gr/gre
@foo = (1, 2, undef, 4); for my $foo (@foo) { print $foo }
$foo = 1419516010; [ ''.localtime($foo), ''.gmtime($foo) ] # LeoNerd - so shouldn't these be different?
$foo[-1] = 42
$foo1 = 4/5; $foo2 = int(4/5); $foo3 = $foo2 ? $foo2 : 1; [ foo1 => $foo1, foo2 => $foo2, foo3 => $foo3 ]
$foo = 1; $bar = *foo; $qux = \*foo; [ $$bar, $$qux ]
$foo = 1; $bar = *foo; $qux = \*foo; use strict; [ $$bar, $$qux ]
$foo1 = $foo2 = '4 a 2'; ( $foo1 ) = $foo1 =~ /(\d+)/; $foo2 =~ s/\D+//g; [ $foo1, $foo2 ]
$foo = 1; $foo++; $foo
$foo = 1; [$foo, map { $foo++ } 1 .. 4]; # isn't the order of evaluation from left to right?
$foo = 1; our $bar = *foo; our $qux = \*foo; use strict; [ %$bar ]
$foo = 1; our $bar = *foo; our $qux = \*foo; use strict; [ $$bar, $$qux ]
$foo = 1; our $bar = *foo; our $qux = \*foo; use strict; [ %$bar, %$qux ]
$foo = 1; our $bar = *foo; our $qux = \*foo; use strict; [ %{*$qux} ]
$foo ||= 2;
${{[foo=>2, bar=>3]}}{"foo"}
$foo=3; $foo ||= 2;
$foo = 3; oct "0x$foo"
{ -foo, 42 }
{ +foo => 42 }
+{ +foo => 42 }
($foo = 42)++; $foo  # same kind of thing
$foo = 42; our $bar = *foo; our $qux = \*foo; use strict; [ *$bar, *$qux ]
$foo = 42; our $bar = *foo; our $qux = \*foo; use strict; [ *{$bar}{SCALAR}, *{$qux}{SCALAR} ]
$foo = 42; [ qq' "$foo" ' ]
$foo = [42]; shift $foo
$foo = 5607181; substr($foo, -6, 0) = '.'; $foo # without all that FANCY COMPLICATED DIVISION
$foo=5; ${*$foo}{"bar"}=2; $5{bar}
$foo = 'a2b11c3d5'; $foo =~ s/[^a-z]//g; print $foo;
@foo = "a2b11c3d5" =~ /(\w+)/g; \@foo
"f o o" =~ /[ab ]/
$foo = "abcdefg"; $foo =~ s/ef//; [ $-[0], length $` ]
$foo = "abc:def"; {split /:/, $foo};
$foo = "abc:def"; sprintf("0x%x", ~~{split ":", $foo});
$foo = '...'; "abc" =~ /\Q$foo/
"f o o" =~ /[ab ]/x
[ "foo a b = z" =~ /foo((?: \w)+)/ ]
"foo a b = z" =~ /foo( \w)+/; [ $1, $& ]
$foo = "AF"; [chr oct "0x$foo"]
$_ = "foo: a\n bar: 1\n bar: 2\nfoo: b\n bar: 5\nfoo: c\n"; my(%h,$last); $1 ? push @{ $h{$last} }, $2 : ($h{$last = $2} = [])   while/^( ?)\w+: (\w+)/gm; \%h
$foo = "(A)"; "\Q$foo"
$foo = [ a..z ]; *array = $foo;  $array[5] # glob trick for programmers that don't like ->  hehehe
'foo  bang' =~ /foo (?:bar)? bang/ ? match : nomatch
'foo bang' =~ /foo (?:bar)? bang/ ? match : nomatch
[ 'foo bang' =~ /foo\s+(?:bar\s+)?bang/ ? 'match' : 'nomatch' ]
<{foo,bar}>
'foo   ' ^. '   bar'
'foo' == 'bar'
"foo" =~ /bar/
"foo" != "bar"
"foo" . "bar"
"foobar" ^ "   "
[ <{foo,bar}> ]
[ "foo ); bar );" =~ /(.* \)\;)/ ]
[ "foo ); bar );" =~ /(.*? \)\;)/ ]
[- -foo => 'bar']
[--foo => 'bar']
[-+-+-+-+-+-+-+-+foo => 'bar']
[-+-foo => 'bar']
[(-+foo => 'bar')]
[{ +foo => 'bar' }]
[{-+foo => 'bar'}]
{ +foo => 'bar' }
{ +foo => "bar" }
{-+foo => 'bar'}
+{ foo => "bar" }
Foo'bar
$foo = $bar = 0; $foo += $bar += 1 for 1..10; $foo  # even more fun :)
[ ' foo= bar1,bar2,bar3  ' =~ /bar\d+/g ]
$foo{'bar'} = 1; $foo{'baz'} = 1; scalar(%foo);
$foo{'bar'} = 1; $foo{'baz'} = 1; scalar(keys(%foo));
@foo = ( bar => 34, baz => 42 ); print +{@foo}->{bar};
'foo bar bang' =~ /foo (?:bar)? bang/ ? match : nomatch
[ 'foo bar bang' =~ /foo\s+(?:bar\s+)?bang/ ? 'match' : 'nomatch' ]
[ foo => bar => baz => ]
foo bar baz
$_ = 'foo bar baz'; my %foo; @foo{qw(one two three)} = m/(\w+)/g; \%foo;
$foo->{bar} = 'baz'; "quux $foo->{bar}"
"foo bar baz" =~ s/\b(\w)/\U$1/gr
[ 'foo bar baz' =~ /\S+/g ]
"    foo bar baz" =~ s/(?<=\s)foo//r
"foo bar baz" =~ s/(?<=\s)foo//r
"    foo bar baz" =~ s/\s\Kfoo//r
"foo bar baz" =~ s/\s\Kfoo//r
"foo/bar-baz&stuff/51" =~ /(\d+)$/r # if >5.10, I think
$foo = { bar => 'baz }; sub foo { $foo->{bar}{baz}{quux} }; exists foo()
$foo = { bar => 'baz' }; sub foo { $foo->{bar}{baz}{quux} }; exists &foo;
$foo = { bar => 'baz' }; sub foo { $foo->{bar}{baz}{quux} }; exists foo()
[ "foo.bar.baz" =~ s{\.(\w+)}{.get\u$1()}gr ]
"foo bar baz" =~ s/(\w+)/\u$1/gr #ah, this is what I was looking for
"foo bar baz" =~ s/(\w+)/\U$1/gr #will this work I wonder?
$foo = $bar = './blah'; substr($foo, 0, 2) = ''; $bar = substr($bar, 2); [ $foo, $bar ]
%foo; @bar = ('cat', 'dog', 'bird', 'bird'); @foo{@animals} = (); %foo;
%foo; @bar = ('cat', 'dog', 'bird', 'bird'); @foo{@bar} = (); \%foo;
%foo; @bar = ('cat', 'dog', 'bird', 'bird'); @foo{@bar} = (); %foo;
$foo{bar} = (); \%foo
$foo = 'bar'; ++$$foo; $bar
["foobar" =~ /f(ooo)|(bar)/]
"foo(bar" =~ /oo\(ba/ ? "match" : "no match"
$_='FOO bar'; print if $_ !~ /FOO\s*?(BAR|xx)/i;
$_='FOObar'; print if $_ !~ /FOO\s*?(BAR|xx)/i;
$_='FOO bar'; print "Invalid str.  Foo is missing BAR or xx"  if $_ =~ /FOO(?!\s*(BAR|xx))/i;
$_='FOO bar'; print "Invalid str.  Foo is missing BAR or xx"  if $_ =~ /FOO\s*?(?!(BAR|xx))/i;
$_='FOObar'; print "Invalid str.  Foo is missing BAR or xx"  if $_ =~ /FOO(?!\s*(BAR|xx))/i;
%foo = (bar => 'quux'); sub foo { +{%foo} } [ foo->{bar}, $foo{bar} ] #huf, you're wrong, foo->{bar} is $foo{bar} :P
['foobarrrrsplot' =~ /foo(bar+)splot/
['foobarrrrsplot' =~ /foo(bar+)splot/]
['foobarrrrsplot foobarsplot' =~ /foo(bar+)splot/g]
['foobarrrrsplot' =~ /foo(bar+)splot/g]
$foo = { bar => "stuff" };  $foo->{bar}->{gravy}
foo 'bar'; sub foo { 1; } # you mean you want to catch things like this?
$_ = "Foo & Bar"; s{(\W)}{ sprintf rand() < 0.5 ? "&#%d;" : "%%%02X", ord $1 }ge; $_
"foo" . "bar" . "yin" . "yang"
$_='FOObat'; print if $_ !~ /FOO\s*?(BAR|xx)/i;
$foo = "blah"; ($bar = $foo) =~ s/bl/h/; [$bar]
$foo = "blah"; ($bar = $foo) =~ s/bl/h/r; [$bar]
[ 'fooblahblahbarfoobazbar' =~ /foo((?:(?!bar).)*)bar/ ]
$foo = "blah episode9 blah"; $foo =~ s/episode([0-9])/e($1-1)/e; $foo
$foo = "blah episode9 blah"; $foo =~ s/episode([0-9])/'e'($-1)/e; $foo
$foo = "blah episode9 blah"; $foo =~ s/episode([0-9])/e($-1)/e; $foo
$foo = "blah episode9 blah"; $foo =~ s/episode([0-9])/e$1/; $foo
$foo = 'b(o+g[o|n(s';  [ $foo =~ /\Q$foo\E/, "\Q$foo" ]
'foo' eq 'bar'
"{{foo" =~ /{{f/
"foo" =~ /foo/
[ "foo" =~ /foo(.*)(.*?)/ ]
%foo{'foo'};
[ "foo" =~ /foo(.*)(bar|)/ ]
[ "foo" =~ /foo(.*)(bar)/ ]
[ "foo" =~ /foo(bar)(baz)/ ]
($foo) = "foo/bar-baz&stuff/51" =~ /(\d+)$/;  $foo
[ "foo foobar foobaz rarafoo gerzson" =~ /\w*o\b/g ]
[ "foo foobar foobaz rarafoo gerzson" =~ /\w*o\W/g ]
[ "foo foobar foobaz rarafoo" =~ /\w*foo\b/g ]
[ "foo foobar foobaz rarafoo" =~ /\w*foo/g ]
[ "foo foobar foobaz rarafoo" =~ /\w*foo$/g ]
$foo["foo"] = "hallo"; \@foo
$foo = {};  "foo!" if $foo;
'foo' =~ /.+/; 'foo' =~ s//bar/r; # yup
'foo' ^ 'fop'
[ 'foo' ^ 'fop' ]
FOO: for (0 .. 9) { last FOO; } FOO: while () { last FOO; } "k"
$foo = 'hello'; push @bar, substr($foo, -$_) for 1 .. length $foo; \@bar
foo "HERE"
foo "hi\n"; sub foo { print "moo\n"; }
\ @Foo::ISA
@$foo{key} # except it isn't
"foo" =~ m/\1/
"foo" =~ m/f/ and print "yay"
$_ = 'foo'; my $a = 5; 1 for $a; $_
$_ = 'foo'; { my $_ = 'bar'; print $_; }
$_ = 'foo'; { my $_; print $main::_; }
$foo = 'name'; "define('DB_NAME', 'l33t7ex7');" =~ /^define\('DB_\U$foo\E', '(.*)'\);$/
"foo\nbar" =~ m/[\n]/ and "yes"
[ "foo\nbar\nbaz" =~ s/^.//mgr ]
"foo\nbar" =~ /o\nb/ ? "matches" : "doesn't match"
$_="foo\nbar"; s/.+//; $_
"foo\nbar" ~~ s/\n/<br>/gr
"foo\nbar" =~ s/\n/<br>/gr
"foo\nbar" =~ s/\n/<br\>/gr
"foo" ne "bar"
[ 'foo nobang' =~ /foo\s+(?:bar\s+)?bang/ ? 'match' : 'nomatch' ]
$_ = "foo\n#one\n #two \n#three\n##bar\nfour\n"; @parse = (); push @parse, $1 =~ /##/ ? "ERROR" : $1 while s/^((?:\s*#(?!#).*\n)+|.*\n)//; \@parse
[ "foo" =~ /o{2}/, "foo" =~ /\Qo{2}/ ]
$foo = 'origin/beans-and-cornbread'; substr($foo, 7)
$_='FOO'; print if !~ /(BAR|xx)/;
$_='FOO'; print if $_ !~ /(BAR|xx)/;
$foo = ''; print "nothing found" unless length $foo;
$foo = q{$$}; [ '$$' =~ /\Q$foo/ ]
@foo = qw/a b c d e/; $x = \$foo[2];  $$x = 'i';  [ @foo ]
@foo = qw/a b c d/; [ $#foo ]
@foo = qw( a b c ); [$#foo]
@foo = qw( foo bar baz biz fuzz buzz wowzers ); [ @foo[ int rand @foo, -1 ] ]
"foo\r\n\tbar\n"
*foo{SCALAR}->$* = 2; my $bar; $$bar = 3; say $bar->$****foo{SCALAR}->$*;
[ (foo => scalar('bar', baz => scalar('quux', flurb => scalar('flarb')))) ]
[ (foo =>scalar 'bar', baz =>scalar 'quux', flurb =>scalar 'flarb') ]
[ 'foo' =~ s/foo/bar/r, 'foo' =~ tr/o/x/r ]
"foo" =~ s/foo/^{MATCH}bar/pr;
"foo" =~ s/foo/$^{MATCH}bar/pr;
"foo" =~ s/foo/${^MATCH}bar/pr;
$foo = [$]]; shift $foo
"foo" =~ s/o/e/gr
@foo = ("%s %s", 'foo', 'bar'); printf @foo;
@foo = ("%s %s", 'foo', 'bar'); sprintf @foo;
[ {foo => sub {1}} ]
"Foo"->${\sub { "hello" } };
'foo*' =~ s{([*?]+)|(\W)}{ $2 ? "\\$2" : '.{' . $1 =~ tr/?// . '}' . '.*' x (index($1, '*') >= 0) }egr
'foo*' =~ s{([*?]+)|(\W)}{ $2 ? "\\$2" : '.' x $1 =~ tr/?// . '.*' x (index($1, '*') >= 0) }egr
[ " foo\tbar  baz " =~ /\S+/g ]
$foo = 'this/that' =~ s/th//r; $foo
$_="foo"; tr alaLa; print $_
%foo = (undef, undef); say "defined" if (grep { defined } keys %foo);
$_='FOO v'; print if $_ !~ /FOO\s*?(BAR|xx)/i;
$_='FOO v'; print "Invalid str.  Foo is missing BAR or xx"  if $_ =~ /FOO(?!\s*(BAR|xx)/i;
$_='FOO v'; print "Invalid str.  Foo is missing BAR or xx"  if $_ =~ /FOO(?!\s*(BAR|xx))/i;
"foo" =~ /(?<<<<!>&)#(\w+)/
[ "(foo)" =~ /\w+/g ]
${\*foo}->("why hello")
$foo="wibble"; q"$foo"
'foo' xor 'fop'
$_='FOO x'; print "Invalid str.  Foo is missing BAR or xx"  if $_ =~ /FOO(?!\s*(BAR|xx))/i;
for \@{[]} (()) {}
for ( 0 .. 10 ) { print; } print $_;
for ("1".."128"){ print chr "$_" };
[ for (1..20){if (/^5$/ .. /^18$/){print $_;} ]
[ for (1..20){if (/^5$/ .. /^18$/){print $_;}} ]
for (1..20){if (/^5$/ .. /^18$/){print $_;}
for (1..20){if (/^5$/ .. /^18$/){print $_;}}
for ("123 5 12 7 ") { my $re = qr/(\d+)(\s+)/; if(/^(?:$re)+$/) { my @result = /$re/g; print "[" . join(",", @result) . "]" } else { print "no match" } } # maybe not necessarily like this, but something along these lines
for (1 .. 3) { my @bar; push @foo, \@bar } "@foo"
for(1..3) { print $_+1 }
for (1..5) { print; print and last if 0 }
... for "A" ... "Z"
foreach (1..4) { do { next }; print "$_\n"}
foreach ($i = 0; $i < 3; $i++) { push @foo, $i*2 }  \@foo
foreach ( keys %ENV ){ say "$_ => $ENV{ $_ };last;}"
foreach ( keys %ENV ){ say "$_ => $ENV{ $_ }";last;}"
foreach my $val (qw/entity baz /) {print +(grep /$val/,( "foo", "bar", "foo entity bar quux", "foo bar")) ? "$val found" : "$val not found" };
foreach my $var ( 1..5 ){ print "$var," }
for ('foo', 'bar') { s/oo/ar/g } # sirkha, like this
for ( grep { print $_; 1 } 1 .. 5 ) { print $_ }
for ("hello") { $_ = 42 }
fork
"fork-fork" =~ /-/ and [eval '$`..$\'']
fork; print $!;
fork => until 0 => $$
fork until 0
fork => until 0 => $$, "\d"
fork while fork
fork while fork;
fork while fork'
for (map $_, 'hello') { $_ = 42 }
formatbw\.css   # not valid
for my $a(1 .. 100) { if ($a == 4) last; }
for my $cat (1,2,3,4) { $cat++ }
for \my %hash ({foo => 1}, {foo => 2}) { say $hash{foo}; }
for(my $i=0;$i<10;$i++) {print "Don't spam, please!"\n";}
for(my $i=0;$i<10;$i++) {print "Don't spam, please!\n";}
for(my $i = 0; $i < 10; $i++) { print "Hello #$i "; }
for(my $i = 0; $i < 10; $i++) { print "Hello #$i\n"; }
for(my $i =0; $i <= $#$ref;$i++){ print @$ref[$i] , "\n";}
for my $i (1..100) {push @a, [(1) x 1024*1024]}; scalar @a
for my $i (1 .. 10) { print "Hello #$i "; }
for my $i (1..30) {push @a, [(1) x 1024*1024]}; scalar @a
for my $k (keys %{{a=>1, b=>2, c=>3}}) { print $k } # works fine with hashes only known by reference too
for my $k (keys %ENV) { print $k } # perfectly normal
for my $x ( 1..10 ) { print $x }
for my $x ( 1..10 ) { say $x }
for (my $x = 1; $x < 10; $x += my $y) { $y=$x; say $x}
for (my $x = 1; $x < 10; $x += my $y) { $y=$x; say $x; push @wtf, \$y; } say "@wtf"
for (my ($x, $y) = ("A", "B")) { print "$x $y. "; }
for (my ($x, $y) = ("A", "B")) { print "$x $y (current value: $_). "; }
for (()) { next }
for $_ qw(foo bar baz) { print }
for ([qw/foo bar/]->${\\&CORE::values}) { print }
for ([qw/foo bar/]->${\\&values}) { print }
for (while 1) {}
'Ḟ' =~ /\P{UpperCase}/
@f{qw/sign exponent fraction/} = (unpack "b*",(pack "d", 0.9999999999999926)) =~ /^(\d)(\d{11,11})(\d+)$/; \%f
*f = sub { 23 }; no strict; &{'f'}()
"ft\n" =~ m/ft$/ ? 't' : 'f'
*fuck = sub { 123 }; fuck()
"F­u­dge" =~ /\N{SOFT HYPHEN}/;
Function::Parameters->VERSION
"gammadelta" =~ /alfa(bravo)|(gamma)delta/
getlogin()
[glob("../*")]
(glob '*')[0]
[[ ((glob("*.*"))[0]) ]]
[ glob "123{4,5,6,7}" ]
[ glob("{1,2,3,4,5,6,7,8,9,10}{11,12,13,14,15,16,17,17,18,19,20}") ]
[ glob "123[4 .. 7]" ]
[ glob "123[4-7]" ]
[ glob '"{1,2}{ no split on space,d}"' ]
[glob "[abc]"]
[glob "{a,b,c}"]
[glob "abc"]
[ glob '{a,b,c,d}' x 4 ]
[ glob '{a,b}' x 2 ]
[glob "foo{a,b}"]
glob "foo{a,b}"
[glob "foo{a,b}{c,d}"]
[ glob "{${\join ',', 'a' .. 'e'}}" x 2 ]
[ glob "kjdasfkjdasfdas/*" ]
*globlal = sub {"Hello World"}; globlal()
\*globlal = sub {"Hello World"}; globlal()
[glob("/*")] # nothing even in /?
[ glob '"samuel road"' =~ s/\bsamuel\b/{samuel,sam,s}/gr =~ s/\broad\b/{road,street,alley}/gr ]
[[ ((glob("*.txt"))[0]) ]]
[[ ((glob("*.txt"))[0..3]) ]]
[glob ".[Zz][Ii][Pp]"]
[glob {".[Zz][Ii][Pp]"}]
gmtime
"" . gmtime
"".gmtime
gmtime . ""
gmtime.""
gmtime 0
[ gmtime("NaN") ]
[ "GMT" =~ /(?:[PMCE][SD]T|UTC)/ ? 'match' : 'nomatch' ]
~("Goat" & " ") ^ "oatgma"
"Goat" & " " | "oatgma"
"Good morning! Sabah el kheer   صباح الخير" =~  m{[^\x00-\x7f]}
goto LABEL; [do { ; LABEL: 42 }];
goto LABEL; [do { ; LABEL: print 'wut' }];
goto LABEL; [do { ; LABEL: print 'wut' } 1];
goto LABEL; [grep { ; LABEL: print 'wut' } 1];
goto LABEL; [map { ; LABEL: print 'wut' } 1];
[ grep /.../ ]
[ grep $_, "0 and false" , 1 , "false", 0 ]
[ grep 1 ]
[grep { !($_ & ($_-1)) } 0 .. 1024]
[ grep !/(.).*\1/, glob '{a,b,c,d}' x 4 ]
[ grep $_ % 2, 1 .. 20 ]
[ grep { $_-=2 } 1,2,3,4,5 ]
[ grep { $_-=2 } 1..5 ]
[ grep { $_+=2 } 1..5 ]
[ grep { $_-=2 } 1..5 ]  # where's my error
[ grep { ($_ >= 5) .. ($_ <= 18) } (1..20) ]
[grep $_ == 5 .. $_ == 18, 1 ..20]
[grep $_ == 5 .. $_ == 18, reverse 1 ..20]
[ grep { /a/ and /b/ } qw/abc cat bat/ ]
[ grep /(a.a)/, qw(apple pear banana) ]
[ grep { /a/ && /b/ } qw/abc cat bat/ ]
[grep { $_ =~ /\Afoobar.(?:true|false|yes|no)\z/ms } ("foobar=true", "foobar.yes", "foobar|no", "foobar.lambda",)];
grep { $_ =~ /\Afoobar.(?:true|false|yes|no)\z/ms } ("foobar=true", "foobar.yes", "foobar|no", "foobar.lambda",);
[ grep /a(x{0,3})(??{'y' x length $1})b/, qw( axxxyyb axxxyyyb axxxyyyyb ) ]  # Su-Shee
[ grep /^[a-z0-9]*[a-z](\.[a-z0-9]*[a-z])*\z/, qw( foo.bar foo foo..bar foo0.bar foo.bar. ) ]
[grep "cats", qw(dogs badgers monkeys)]
grep chr() =~ /[[:space:]]/, 0 .. 0x10_ffff
[grep defined, "this is (a test,a problem)" =~ /.*\(|\).*|([^,()]+)/g ]
!grep($_ eq 'bbb', qw(aaa bbb ccc)) ? 'not present' : 'present'
!grep($_ eq 'xxx', qw(aaa bbb ccc)) ? 'not present' : 'present'
[ grep /foo(?!.*bar)/, qw( foo bar foobar fooooooobar  foosomebar foosomeba ) ]
[ grep /^([^()]+|\([^()]*\))*$/g, "foo", "foo (bar)", "(bar) foo", "foo (bar) baz", "foo (bar" ]
grep $_ .= '-haha', map $_, qw(a b c d e)
grep $_ .= '-haha', qw(a b c d e)
[ grep /h/, map chr, (0..0x3000) ]
[grep -iP { $_ =~ /(?:foobar)(?:\s.\s|.)(?:true|false|yes|no) } ("foobar=true", "foobar = true", "FOOBAR:no", "barfoo=yes",)];
[ grep /json/i, keys %INC ]
[grep /JSON/, keys %INC ]
[grep /::/,keys \%::]
[ grep { length * 2 < 4 } qw/a bcd efgh i j k/ ]
[ grep { length <= 3 } qw/a bcd efgh i j k/ ]
[ grep { length >= 3 } qw/a bcd efgh i j k/ ]
[ grep /[\[\]]/, map chr, 0..255 ]
[ grep m|^http://(?!.*avatar)|, qw( http://assets.tumblr.com/images/default_avatar/octahedron_open_48.png http://assets.tumblr.com/images/default_avatar/cube_closed_48.png http://40.media.tumblr.com/b3e62ef833996a4ffb544ed37300807d/tumblr_nlf8czGMpJ1s61cido1_500.jpg http://40.media.tumblr.com/c0e108161497f351e40db139289b3818/tumblr_nldblnzio71s61cido1_500.jpg ) ]
grep { $_->{name}[0] eq $w } @list,
grep { $_->{name}[0] eq $w }, @list
[ grep { not (1../3/) } (1..10) ]
[ grep { not (1 + index $_, 'approver') and m/help.*?\@example.net/ } qw(help-approver@example.net help-comment@example.net help@example.net) ];
[ grep { not (do{1}../3/) } (1..10) ]
[ grep { not eval } a..z ]
grep $_, @order[-1]
[ grep { scalar(/\Aw\z/../\Af\z/) } qw/m tu w th f sa su/ ]
[ grep Scalar::Util::looks_like_number $_, split ' ', "foo 12 bar lol super-yay 13_000 20.12 baz" ]
[ grep Scalar::Util::looks_like_number $_, split ' ', "foo 12 bar lol super-yay 13 baz" ]
[ grep /^scaleaddr(\d)=([^\d]*)/i, qw(blahj blah blah ScaleAddr5=abc) ];
[ grep /^scaleaddr(\d)/i qw/scaleaddr123/ ];
[ grep /\s/,map chr,  0..255 ]
[  grep { $_ !~ /:/ } split('\s+', 'frog abd:def "jumping jack" 123:456 book jimbo:"billy bob" elephant') ]
grep { $_ !~ /:/ } split('\s+', 'frog abd:def "jumping jack" 123:456 book jimbo:"billy bob" elephant');
grep s/\.pm\z//, keys %INC
[ grep tr/()//cdr!~/^\)|\($|\(\(|\)\)/, "foo", "foo (bar)", "(bar) foo", "foo (bar) baz", "foo (bar" ]
[ grep tr/()//cdr=~/^(\(\))*$/g, "foo", "foo (bar)", "(bar) foo", "foo (bar) baz", "foo (bar" ]
[ grep /^uni/, keys %INC ]
[ grep /^\w{3,10}\z/, qw( one jdhfkjhfkjhdlkfjgh qwe.ert abcdefghij  no abcdefghijk ) ]
Grinnz->can('import') ? "has import kthx" : "no such thing"
Grinnz->import()
"guess\nwhat" =~ /\Aguess$/m ? "k" : "wtf"
%h = ( 1=>1, 1=>0, 0=>1, 0=>0 ); [ map { !$_ || $h{$_} ? 'T' : 'F' } keys %h ]
%h = ( 1=>1, 1=>0, 0=>1, 0=>0 ); map { !$_ || $h{$_} ? 'T' : 'F' } keys %h
@h = ( 1=>1, 1=>0, 0=>1, 0=>0 ); [ map { ! $_ || shift @h ? 'T' : 'F' } shift @h ]
@h = ( 1, 1, 1, 0, 0, 1, 0, 0 ); [ map { ! $_ || shift @h ? 'T' : 'F' } shift @h ]
%h = (12 => 'hip', 0x12 => 'hop'); \%h
%h = 1..6; {%h{1,3}}
%h = 1..6; +{%h{1,3}}
%h = 1..6; +{%h{1,3,5}} # boo
%h = 1..6; +{%h{1,3,7}} # boo
[\(%h1, %h2, %h3)]
%h = ( 1=>"one", 2=>"two" ); map { print "key: $_ val: $h{$_}" } keys %h
$h = { 25 => 1 }; my $idx = "25 "; [ $h->{$idx}, $h->{0+$idx} ]
$h = { 25 => 1 }; my $idx = "25"; [ $h->{$idx}, $h->{0+$idx} ]
$^H=256;join(($x)x101)
$^H=256;join($x)x101
%h=( 'a'=>'1', 'b'=>'2' ); %h=( 'c'=>'3', 'd'=>'4' ); for ( sort keys %h ){ print "$_ $h{$_" };
%h=( 'a'=>'1', 'b'=>'2' ); %h=( 'c'=>'3', 'd'=>'4' ); for ( sort keys %h ){ print "$_ $h{$_}" };
%h = (a => 1); scalar %h
@h{'a' .. 'c'} = 1 .. 3; ++$_ for values %h; \ %h;
halal
`halt`;
$h = {'a' => {'one' => 1}, "b" => 2}; $i = {'a' => {'two' => 2}; $j = {%$h, %$i}; print Dumper($j);
$h = {'a' => {'one' => 1}, "b" => 2}; $i = {'a' => {'two' => 2}}; $j = {%$h, %$i}; print Dumper($j);
$h = {'a' => {'one' => 1}, "b" => 2}}; $i = {'a' => {'two' => 2}}; $j = {%$h, %$i}; print Dumper($j);
'Happy ' . (int(1970 + time() / 31557600)+1)
'Happy ' . int(1970 + time() / 31557600)+1
%hash = 1..4; delete @hash{1,3}; scalar %hash
%hash = 1..4; scalar %hash
%hash = (1..8); $_++ for %hash; \%hash
%hash = (1..8); %hashtwo = (a..j); $_++ for %hash, %hashtwo; [ \%hash, \%hashtwo ]
%hash1 = ( foo => 1, bar => 2 ); %hash2 = ( baz => undef, quux => \%hash1 );  \%hash2
%hash1 = ( foo => 1, bar => 2 ); %hash2 = ( baz => undef, quux => \%hash1 );  $hash2{quux}
%hash1 = ( foo => 1, bar => 2 ); %hash2 = ( baz => undef, quux => \%hash1 );  $hash2{quux}{bar}
%hash=(2=>"two", 1=>"one"); print sort { $a cmp $b } keys %hash
%hash=(2=>"two", 1=>"one"); print sort keys { $a cmp $b } keys %hash
%hash = @array = qw/a list of stuff/; [ \%hash, \@array ]   # you have arrayrefs though. see perldoc perlreftut
$hash = { a => 'z', b => { c => 'y' } }; if(ref $hash->{a} ne ;
$hash = { a => 'z', b => { c => 'y' } }; if(ref $hash->{a} ne 'ARRAY' && ref $hash->{a} ne 'HASH') { print 'scalar' };
$hash = { a => 'z', b => { c => 'y' } }; ref $hash->{b};
%hash = (); @hash{a..f} = (1)x7; $_++ for @hash{a,c,f}; \%hash  # hehehe
$hash{'key1'} = "val1"; print ref %hash
$hash{'key1'} = "val1"; print ref $hash{'key1'}
$hash{"key1"}="val2"; $hash{"key2"}="val1"; for ( sort { $hash{$a} cmp $hash{$b} } keys %hash ) { print "key: $_: val: $hash{$_}, "; };
$hash{"key1"}="val2"; $hash{"key2"}="val1"; for ( sort { $hash{$a} <=> $hash{$b} } keys %hash ) { print "key: $_: val: $hash{$_}, "; };
$hash{"key1"}="val2"; $hash{"key2"}="val1"; for ( sort { $hash{$b} cmp $hash{$a} } keys %hash ) { print "key: $_: val: $hash{$_}, "; };
$hash{"key1"}="val2"; $hash{"key2"}="val1"; for ( sort { $hash{$b} <=> $hash{$a} } keys %hash ) { print "key:$_: val:$hash{$_}, "; };
%hash = map { join '', 1..1+ rand 9} 1..20; $long = ''; $long |= $_ for keys %hash; [ \%hash, "longest key is " . length $long ]
%hash={ 'stuff' => 'sterf' } ; \%hash
$h->{bar} eq 'lol'; $h->{baz}->{whiz} eq 'lol'; $h
$h->{bar} eq 'lol'; $h->{baz}->{whiz} = 'lol'; $h
"hello 123 time 8:08 =~ m/{\A .* on (.*) }xms/;
"hello 123 time 8:08" =~ m/{\A .* on (.*) }xms/;
[ "hello" =~ /^([a-z]+)(?:\s+(.+))?$/ ]
$_ = "hello"; /e/c or die; [pos]
"hello it is now on 8:08" =~ m{\A .* on (.*) }xms;
("hello it is now on 8:08" =~ m{\A .* on (.*) }xms);
["hello it is now on 8:08" =~ m{\A .* on (.*) }xms];
[ "hello\nworld" =~ m/(.*(?:\n|$))/g ]
[ "hello\nworld" =~ /^.*\n?/mg ]
"Hello" =~ /^.*(.+)$(??{print"$1\n"})/
"Hello" =~ /(?!^).*(.+)$(??{print"$1\n"})/    # test
"Hello" =~ /(?!^).+(*PRUNE)(?{push @bar, $&})(*FAIL)/; [ reverse @bar ]
"   hello" =~ s/^\s*//sr
$_ = " hello there 123... the time is 8:08";  [ /(\d+:\d+)/ ]
[ "hello there" =~ /^([a-z]+)(?:\s+(.+))?$/
[ "hello there" =~ /^([a-z]+)(?:\s+(.+))?$/ ]
[ "hello there" =~ /^([a-z]+)\s*(|(?<=\s).+)$/ ]
[ "hello-there" =~ /^([a-z]+)\s*(|(?<=\s).+)$/ ]
[ "hellothere" =~ /^([a-z]+)\s*(|(?<=\s).+)$/ ]
$_ = " hello time time time time time time there 123... the time is 8:08";  [ /the time is (\d+:\d+)/ ]
["Hello" =~ tr/l/g/r
["Hello" =~ tr/l/g/r]
{%{hello=>"world"}}
%{%{{hello=>"world"}}}
%{%{hello=>"world"}}
$_ = 'hello, world, foo bar baz';  [ map tr/ /-/r, split /,\s*/ ]
$_ = 'hello, world, foo bar baz';  [ map tr/ /-/r, split /,\s*/ ] # try three :)
[ "Hello, world!" =~ m/(....)/g ]
[ "Hello, world!" =~ m/(....)/g; ]
$_ = 'hello world'; push @ar, [$1,$2] while /(.)(.)/g; \@ar
"Hello, world" =~ tr/A-Za-z/N-ZA-Mn-za-m/
'help-approver@example.net' =~ /^(?!help-approver).+\@example\.net$/
'help-approver@example.net' =~ /(?<!^help-approver)\@example\.net$/
'help-approver@example.net' =~ /(?<!help-approver)\@example\.net$/
'help-approver@example.net' =~ /(?!<^help-approver)\@example\.net$/
'help-approver@example.net' =~ /(?!<help-approver)\@example\.net$/
'help-approver@example.net' =~ /(?!help-approver).+\@example\.net/
'help-comment@example.net' =~ /^(?!help-approver).+\@example\.net$/
'help@example.net' =~ /(?<!help-approver)\@example\.net$/
here
+{[ here => "are", my => "values" ]}
HERE: { print 1; HERE: { print 2; HERE: { print 3; goto HERE } } }
HERE: { print 1; HERE: { print 2; HERE: { print 3; goto HERE unless $i++ > 2 } } }
 ${{here,there}}{here};
\&hex
hex("000001448e317907") / 1000
hex '0a'
hex '0x0a'
hex "0x14"
\&hex->("0x24")
hex "0xabcd"
hex $1
hex "1e0"
hex 41
hex "4155"
$hex = '6060FF'; [ unpack q{L>*}, pack q{H*}, '0' x (-length($hex) % 8) . $hex ]
hex "dead"
hex 'f' x 16
hex q{112233445566778899}
"hey, this contains A-Z somewhere" =~ /A-Z/ ? 'true' : 'false'
$^H{feature_state} = 1; sub foo { state $x; }
$h = { "foo" => 42 } ;  push @{$h->{foo}}, 17;  say $h->{foo};  # Really?
$h = {foo => 5, bar => 6, baz => 2}; [@{$h}{qw(foo bar baz)}] # is that what you mean?
$h = {foo => 5, bar => 6}; [$h->{foo}]
$h = {foo => 5, bar => 6}; [@{$h}{qw/foo/}]
$H{'foobar'}++
@h{grep !/[a-zA-Z{}]/, split //, "MPOPCNTSF: INTEGER[9]"} = (); join '', keys %h
$h="hello world!"; $h=~ s/(.){1}(.){1}/$2,$1/eg; print $h
$h="hello world!"; $h=~ s/(.)(.)/$2,$1/eg; print $h
$h="hello world!"; $h=~ s/(.)(.)/$cipher.=chr(ord($1)+1).chr(ord($2)+1);/eg; print $cipher
$h="hello world!"; $h=~ s/(.)(.)/$cipher.=chr(ord($1)+1).chr(ord($2)+1);/eg; print "$h == $cipher"
$h="hello world!"; $h=~ s/(.)(.)/$h="$2$1";/eg; print $h
$h="hello world!"; $h=~ s/(.)(.)/$h=$2++.$1++;/eg; print $h
$h="hello world!"; $h=~ s/(.)(.)/$h=chr(ord($1)+1.$1++;/eg; print $h
$h="hello world!"; $h=~ s/(.)(.)/$h=chr(ord($1)+1).chr(ord($2)+1);/eg; print $h
$h="hello world!"; $h=~ s/(.)(.)/$h=uc($2)."$1";/eg; print $h
$h="hello world!"; $h=~ s/(.)(.)/$h=uc($2).$1";/eg; print $h
hi
"hi"
%h = (ichi, ni, san, shi); $h{ichi}
["Hi mace"]
$_="hi"; print();
$_="hi"; print(undef);
'Hi these_eyes' x 3
"hi" x 4
[("hi") x 4]
'{# hiya #} {# world #}' =~ m/{#\s?(.+?)\s?#}/g; $1;
"hlagh"**0
$h{'login'} = 'foo'; $h{login}
%h = map { /^(.+)\.(.*?)\.\1$/ } "aaa.one.aaa", "bbb.two.bbb", "ccc.test.ccc", "asd.fg.foo.asd.fg"; \%h
%h = map { split /:/ } qw( a:123 b:456 ); \%h
$_ = 'hood'; s/h(.*)d/n$1k/r
$href = { "foo"=>"bar" }; [ %$href ]
$href = { "foo"=>"bar" }; lock_ref_keys($href); map { print "\"$_\":$href->{$_}\n" } %{$href}
$href = { "foo"=>"bar" }; map { print "\"$_\":$href->{$_}\n" } %{$href}
$href = { "foo"=>"bar" }; print (%{$href})
$href = { "foo"=>"bar" }; print $href->{"foo"}
$href = { "foo"=>"bar" }; sub pr { print @_ }; pr( %$href );
$hs1 = { _ -> {} }
$h->{someKey}->{whatever} = 'abc'; qr/X$h->{someKey}->{whatever}Y/
%h = { stuff => 'sterf' }; \%h
["<html>foo</html>" =~ /<([^>]+)>\s*$/m]
$_="http://a?k1=v1&k2=v2"; $_=(split /\?/)[-1]; [ map { split /=/ } (split /&/) ]
 [ 'http://go2web4free.com:7004/img/users/1/1J2KAFHQk_.jpg' =~ m{[^/]+$}g ]
http://google.com $html->at('title')->text
https://gist.github.com/anonymous/599c9b609f78f9b0abf4
https://gist.github.com/zoffixznet/2ad28e7398c95bb4c92d#file-test-pl-L9
http://www.google.com/ $html = lc $html; $html =~ tr/a-z/n-za-m/;
http://www.google.com/ $html = lc $html; $html =~ tr/a-z/n-za-m/; $html
http://www.google.com/ ref $html
"http://www.google.com" =~ s/http:\/\//http:\/\/CLOUD_NETWORK.1.1:2144\//r # I get www.google.com at the end
[ 'http://www.site.com/letters0241/something-in-australia-a' =~ m[/(?:[^-/]*-){2}([^-/]*)[^/]*\z] ]
[ 'http://www.site.com/letters0241/something-in-australia-a' =~ m[something-in-([^-]*)] ]
$_ = "huf"; ++$_
huf->can("be::sure")
huf->can("can")
huf->can("can")->(huf => "can")->(huf => "can")->(huf => "can")->(huf => "can")->(huf => "can")->(huf => "can")->(huf => "can")
@hyperv = qw(foo bar baz); print @hyperv . "\n"
$i = 0; "aaaa" =~ s/a/(++$i == 2) ? 'b' : $&/ger #hey, you can do it in perl too! :P
$i = 1; for (1 .. 12) { print $i, " "; $i = int $i * (.5 + sqrt 1.25) + .5; }
$i=5; $i = ++$i + ++$i
"I am "
"I am a bot"
"I am a fish ".$_[0]
$_ = 'i am happy'; [ /(?=(....))/g ]
`id`
'i' ^ 'd'
[ 'i' ^ 'd' ]
[ "<id>textA<email1><id>textB<email2>" =~ m!<id>([^<>]*)<email2>! ]
[ "<id>textA<email1><id>textB<email2>" =~ m!<id>([^<>]*)<email\d>!g ]
if(0)
if (0) { 'a block' }
if (0) { } esle { } exit
if (1 == 1) { print 'foo'; } else;
if ( 1 ){ do_something(); } sub  do_something { print "heyy"; }
if (1) {} elseif (2) {}
if (1) {} elsif (2) {}
{ if (1 ) { last; print "lols"; } print "lulz"; } print "lelz";  # linagee
if(1) {{ print "here"; last; print "not here" }} print " done"
if ('abc' =~ /^a/) { 1 } else { 0 }
if("a" == "b"){print "true";}else{print "false";}
if("a" eq "b"){print "true";}else{print "false";}
"if answer > 0: answer = answer + 2" =~ /^\s*if (.*): (.*)/
if (@a = sub { return }->()) { 1 }
if (@a = sub { return undef }->()) { 1 }
if('besaid' =~ m/(\w*said)/) {print qq{matched "$1"\n};}
`ifconfig -a | grep -i inet`
if (exists $x->{foo}{bar}{baz}) { } [$x]
if (false) { print "false is true!"; }
if...if ($x.endswith("ft"))...
if (int(rand(2))) { return 'wrapper' } return 'builder'
if (my ($var1, $var2) = "foo bar" =~ /(foo|bar)/g) { print "Matches! var1: $var1, var2: $var2"; }
if (my ($var1, $var2) = "foo bar" =~ /(foo)|(bar)/g) { print "Matches! var1: $var1, var2: $var2"; }
if (my ($var1, $var2) = "foo bar" =~ /(foo|bar)/) { print "Matches! var1: $var1, var2: $var2"; } #I'm not quite sure it's entirely correct though
if (my ($var1, $var2) = "foo bar" =~ /(foo)|(bar)/) { print "Matches! var1: $var1, var2: $var2"; } #meant like this rather, but meh
if ((my $var) = ("z" =~ //)) { print "TRUE" ;}
if (my ($x, $y) = (1, 0) { ['true']; } else { ['false'] }
if (my ($x, $y) = (1, 0)) { ['true']; } else { ['false'] }
if  !($sender =~ qr/@ArrayNickHighLight/i) {}
if (!($sender =~ qr/@ArrayNickHighLight/i))
if (!($sender =~ qr/@ArrayNickHighLight/i)) {}
if ($sender !~ qr/@ArrayNightHighLight/i) { ... }
if( "        " =~ /^((\t|\s{4})+)/ ) { print length $1 }
if( "        " =~ /^(\t|\s{4})+/ ) { print length $1 }
"        if (x = 2): print y;        yo" =~ /^([\t ]+)/; my $indents = () = $1 =~ /(\t| {8})/g
if (! $x = foo() )
if ($x->{foo}{bar}{baz}) { } [$x]
if ($x){next}
$_ = "If you can read this, you could be a programmer"; tr/aeiou//d; $_
$i = {"h" => 1, "i" => 2}; $j = "i"; [ ${$j}, $i->{${$j}} ]
"I hate people" =~ s/e//gr
"I" + "I";
$i=$i++;  ++$i + $i++
$i=$i++;  ++$i + $i++  ;
"i like my keys with rings, not within my hammy interior" =~ s/\b(my|with)\b/[$1]/rg
"i like my keys with rings, not within my hammy interior" =~ s/\b(my|with)\b/[$1]/rg -- this one?
"img 34 32 4 3453  m agi  img 34 ag sgd dfg dfs img 54323 423 img 3sadf  asd
"img 34 32 4 3453  m agi  img 34 ag sgd dfg dfs img 54323 423 img 3sadf  asd" =~ s/img/img\n/gr
$in = "abc123def456xyz"; (@out) = $in =~ /\d+/g; \@out;
$in = "abc123def"; ($out) = $in =~ /\d+/g; [$out]; # for added confusion
$in = "abc123def"; ($out) = $in =~ /(\d+)/; [$out]
$in = "abc123def"; ($out) = $in =~ /\d+/; [$out]
[@INC]
@INC;
\@INC
\%INC
%INC
[ %INC/\@INC ]; # hash/array reference
$INC{'version'}
$INC{'version.pm'}
index('abcde', 'd')
[index("foo bar","foo"),index("food","foo")]
[index("foo", "foo bar"),index("foo","food")]
index('test123', 'test') == 0  # I assume?
@indices; for (1 .. 10) { push @indices, 11 - $_ }; [@indices];
'inf'
'inf' > ~0
'inf'/0
'inf' - 'inf'
inf == inf
"inf" == "Inf"
'inf'/'nan'
$in="foo"; ($out = $in) .= ".bak"; [ $in, $out ]
$in="foo"; $out = $in .= ".bak"; [ $in, $out ]
"INGY" ^ "perl"
$input = "123\n456"; [ $input =~ /123.*456/ ? "yes" : "no", $input =~ /123.*456/s ? "yes" : "no" ]
$input = '       A         B        C'; [ split " ", $input ]
$input = ideally I'd
int(11/15 * 100);
int(1.139999999999999 * 100)
int(1.14 * 100)
int(134.95 * 100)
int( (1414364400 - 1414274400) / 3600 )
int(19.99*100)
int(2.4213534531451E+30)
int((45/50-1)*100)
int(5/3)
&Internals::SvREADONLY \!0, 0; ${\!0} = 0; defined 'foo'
&Internals::SvREADONLY(\!0, 0); ${\!0} = 0; defined 'foo'
&Internals::SvREADONLY(\undef, 0); undef = []; undef
int((foo); bar()
int rand 0
int rand + 1;
(int rand 2) ? "Yes" : "No"
((int rand 5) + 22) % 24
(int(rand 5) - 2) % 24
$intsize = length(~1) > 10 ? 64 : 32
int sprintf '%.f', 134.95 * 100
int(((time+256)/1024*123))+1
int(((time+256)/1024*123)+1)
int(((time+256)/1024%123)+1)
int(((time+256))/1024*123)+1
int(((time+256)%1024*123)+1)
" " == int(" ") ? "true" : "false"
"" == int("") ? "true" : "false"
int((x)
int((x); y()
IO::Socket::INET->new()
[ "<ip:11111432941656@192.168.0.230>" =~ /:([0-9]+)/ ]
$i = [qw/5 7 8 2/]; [sum map { scalar @$_ } @i]
$i = [qw/5 7 8 2/]; [sum map { scalar @$_ } @list
$i = [qw/5 7 8 2/]; [sum map { scalar @$_ } @list]
'irc.freenode.net' =~ /irc\.([^.]+)/ and print $1;
isa {STDOUT} 'GLOB';
isa {STDOUT} 'IO::Handle';
""->isa("UNIVERSAL")
$_ = "I saw Wilma yesterday"; [ /(\w*)a/, /(\w*a)(\s+[a-zA-Z]{4})/ ]
" is just our way of talking to the evalbot. Nothing to do wih code.
$_ = 'I speak Goat Latin'; my $n = 1; s/\b([^aeiou\W])?(\w+)/"$2\L$1ma".'a'x$n++ ^ (($&&$")^$")/geir
$_ = 'I speAk Goat Latin'; my $n = 1; s/\b([^aeiou\W])?(\w+)/"$2\L$1ma".'a'x$n++ ^ (($&&$")^$")/geir
$_ = 'I speAk Goat Latin'; my $n = 1; s/\b([^aeiou\W])?(\w+)/"\L$2$1ma".'a'x$n++ ^ (($&&$")^$")/geir
$_ = 'I speak Goat Latin'; my $n = 1; s/\b([^\Waeiouy]?)(\w+)/$2\l$1ma/gr =~ s/\w+\K/'a'x$n++/ger
$_ = "I speAk Goat Latin"; my $n = 1; s/\b([^\Waeiouy]?)(\w+)/my $z = "$2\l$1ma" ; ($1=~m"\p{Lu}"?"\u$z":$z)/ger =~ s/\w+\K/"a"x$n++/ger
$_ = 'I speAk Goat Latin'; my $n = 1; s/\b([^\Waeiouy]?)(\w+)/$"x length$&&"$1$2"^"\U$2$1\Ema"/ger =~ s/\w+\K/'a'x$n++/ger
$_ = 'I speAk Goat Latin'; my $n = 1; s/\b([^\Waeiouy]?)(\w+)/$"x length$&&$&^"\U$2$1\Ema"/ger =~ s/\w+\K/'a'x$n++/ger
$_ = 'I speak Goat Latin'; s/\b[aeiouy]\w+\K/ma/gi || s/\b(\w)(\w*)/$2$1ma/g; my $n = 1; s/\w+\K/'a'x$n++/ger # like this riceandbeans
is to test things.
"italic test after italic"
{ itemFilter => 'first value', itemFilter => 'second value' };
( item => "first value", item => "second value" ); # That's how you fix *that*
[ item => "first value", item => "second value" ]; # Why did you evaluate the last one the way you did, anyway?
"It puts the lotion in the basket!"
'i' xor 'd'
"\j"
- -'jesus'
-'jesus'
"john@example.com"
j oin
join "\0", qw<a b c>
join(':', (1..10))
join ", ", 1, 2, "\n";
join'','a'..'m','N'..'Z'
join'',a..'m',N..Z
join'',a..m ,N..Z
join'',a..m,N..Z
join('', 'a'..'z') =~ s/(.{13})$/uc$1/er
join('', 'a'..'z') =~ s/^(.*)\K(??{ '.' x length $1 })$/\U$&/r;
join ' ', ("Buffalo")
join ' ', ("Buffalo") x8
join ':', 'd850e684e6de' =~ /../g
join'e', qw(y s)
join "", grep /\w/a, map chr, 0..999999
join "", grep /\w/, map chr, 0..999999
join "hello", "a single argument"
join 'irre', qw(sq l)
join "-",(localtime)[5,4,3]
[ join('', map { +{} } 0..10 ]
[join "", map "$_\0", qw(foo bar baz)]
[ join ',', map '?', 1..10 ]
join(':', map { $_ *= $_ } (1..10))
join ' ', map { 20 * ($_ - 1) } 1 .. 5;
join '', map chr, 0x2603 # works fine with >256, but they're unicode not utf-8
join '', map { chr(255 - hex) } "9E9B929691" =~ /([[:xdigit:]]{2})/g # Nei++
join ' ', map chr, 97 .. 100
join('',map chr,(97, 98, 99))
join '', map chr(ord ^ 32), split '', 'Grinnz'
join '', map { chr } unpack 'H*', "31323234"
join ",", map { $_ || "\\N" } split ",", "abc,,def,ghi,,jkl"
join ' ', map $_ . "\N{U+0300}", qw(a e i o u)
join ' ', map $_ . "\N{U+0300}", qw(a e i o u)  <perlbot> anno: àèìò
join ', ', map ord, qw(⁰ ¹ ² ³ ⁴ ⁵ ⁶ ⁷ ⁸ ⁹)
join ' ', map pack('B8', $_), "01101000 01100101 01101100 01110000" =~ /\d+/g;
[ join " -- ",map { s!^/|/$!!g;$_ } @{[ qw{ /foo/bar/baz/ foo/bar/baz /foo/bar/baz foo/bar/baz/ } ]} ]
join(' ', map { sprintf("%02X", ord($_)) } split('', "bar"))
join " ", map sprintf("%02x", $_), qw|137 80 78 71 13 10 26 10|
join " ", map {ucfirst} split(" ", "My fancy filename.txt")
join ' ', map { "$_:".(unpack( "H*", pack $_, 945 ) =~ s/../$&./gr) } 'V', 'N'
join '-', map { "x$_y" } 1..3;
join '-', map { "x${_}y" } 1..3;
[ join ("\n", unpack '(A4)*', 'This is a string') ]
join ('\n', unpack '(A4)*', 'This is a string')
[ join '|', qr/^[a-zA-Z]+$/, qr/^[0-9]+$/ ]
join ' <<<<<<< ', qw(fname lname age)
join //, qw(foo bar baz)
join ',', qw(?) x 10
join '', reverse "7c86467b" =~ m/../g
join '', sort { --$| * 2 - 1 } split //, 'Jurlt ,cneh eeotakrrsa Ph';
join '', sort { --$| * 2 - 1 } split //, 'LaeulsraWt y yarmsoir r l';
join '', sort split '', 'msixpodualngc'
[join '', sort {$|--} split //, "tuJsa nohterP er lhakcer,"]
(join '', (split //, 'abc'))
+join +'_', +(+split /_/, +"the_cool_string")[+1,+2]
join '_', (split /_/, "the_cool_string")[1,2]
join '_', +(split /_/, "the_cool_string")[1,2]
join " ", @{ unbuu || [] }
join " ", @{ undef || [] }
join " ", @{ undef() || [] }
join " ", @{ undef() }
[ join ',', (undef // ()), 'x', (undef // ()) ]
join ":", unpack "(a2)*", "000202056D4C"
join ".", unpack "C*", pack "n", 945
join ':', unpack('(H2)3', "\x12\x34\x56")
join ":", unpack "(H2)*", pack "H*", "e8b748680748"
[ join ',', ('?')x4 ]
[ join ',', ('?'x4) ]
JSON
JSON()
JSON::encode_json [sprintf("%.2f", 1.234), sprintf("%.2f", 1.234) + 0]
\@JSON::EXPORT
\@JSON::EXPORT_OK
JSON->new->encode({ value => 0+sprintf("%.3f", 34.33/400) })
[JSON::true]
"JUNK" =~ m/(.*)/; do { local $1; "wibble" =~ m/(\d+)/; $1; }
"JUNK" =~ m/(.*)/; "wibble" =~ m/(\d+)/; $1;
Just'another'Perl'hacker =~ s/::/ /gr
"Just another Perl hacker" =~ so?  silly! r
$k=0; $numseg=30000; for (my $i = 0; $i < $numseg; $i++) { for (my $j = $i; $j < $numseg; $j++) {$k++}}; print $k;
$_ = "key foo"; push @arr, /key(.*)/; [@arr]
[ keys { 1 .. 10 } ]
[keys {1..4}]
keys @{ [1..5] }
keys( {} ) = 42
[ keys (%{{ 'dave' => 1, 'bob' => 2 }}) ]
[ keys (%{{ 'dave' => 1, 'bob' => 2 }}); ]
keys (%{ 'dave' => 1, 'bob' => 2 });
keys (%{{ 'dave' => 1, 'bob' => 2 }});
keys %ENV
keys %hash = 200; scalar %hash
[ keys %INC ]
keys INC
keys %{main::};
keys %main::
keys(%order) = 2; keys(%order)
keys(%order) = 2; scalar %order
[keys { qw(a b c d) }]
keys { qw(a b c d) }
@keys = qw(a b c d); @hash{@keys} = @hash{@keys}
@keys = qw(a b c d); @hash{@keys} = @hash{@keys}; \%hash
@keys = qw(a b c); @values = qw(1 2 3 4); my %result; if (@keys < @values) { push @values, [ splice @values, $#keys ]} @results{@keys} = @values; \%results
@keys = qw(a b c); @values = qw(1 2 3 4); my %result; if (@keys < @values) { push @values, [ splice @values, $#keys ]} $results{@keys} = @values; \%results
[ keys(%^V), values(%^V) ]
[ keys(%$^V), values(%$^V) ]
kill $$
kill -TERM, 0
@{["Knark",". ","knark",","]}
"\\l\$1"
"\l\$1"
LABEL: { goto redo next last LABEL; }
LABEL: { last LABEL if 1; }
LABEL: sub { }
LABEL: { sub { last LABEL }->() }
LABEL: { sub { last LABEL }->(); print "fail" }; print "ok";
LABEL: sub { { last LABEL } print "hax" }->()
"lag"
'lala'->${ \sub { 'here ' . shift } }
*{ 'la la'} = sub { 'la la' }; my $name = 'la la'; my $ref = \&$name; $ref->()
lc 'ẞ'
lc chr 0xfb06
lc chr 0xfb08
lc "Foo" eq lc "foo"
length
[length]
length "[^ /"
length 0x00FF
length 0xFF
length 100
length "1436365603657"
length 1e10
length 1e1000
length 2**32
length "2421392269093537440547188383164"
length 2**64
length 64.64.64.5000000000.64.64.6
length "̀a"
length "à"
length "à"
length ("a"x(100*1024*1024))
length ("a"x(30*1024*1024))
length "é"
length 'ṏ͓͔ͅ'
length pack "c", 9999;
length pack "cc", 9888, 9999;
length pack "cc", 9999;
length pack "h", "41"
length q(\\)
length q|0.99999999999996|
length q|0.9999999999999919|
length q caller vec and print chr ord uc q chr lc and print chr ord q ge log and print chr ord qw q lc q and print chr ord qw q lc q and print chr ord q xor x and print chr ord qq q q and print chr ord uc qw q wait q and print chr ord q xor x and print chr ord q qr q and print chr ord qw q le q and print chr ord qw q do q and print chr hex length q q semctl setpgrp chop q and print chr length q q conti
length q[{CRYPT}$2a$04$MjkMhQxasFQod1qq56DXCOvWu6YTWk9X.EZGnmSSIbbtyEBIAixbS]
length 'sາໍ '
length 'sາໍ'
length sprintf "%8.2f", 12
length sprintf "%8f", 12
length sprintf '%b', 2 ** 100
length sprintf '%b', 2**64
[ length unpack 'H12', 'version' ]
$            leonerd = 42;
$ leonerd = 42;
@lettuce = ( kale => "chrunchy"); map { print "yummy" if  /kale/ } @lettuce;
@lettuce = ( kale => "chrunchy"); map { print "yummy" if $lettuce{$_} eq "kale" } @lettuce;
'<li><a href="' =~ /<li><a href=/
'<li><a href="' =~ /<li><a href=/; [$1, $2, $3]
$likeb = qr/(?:(?<!\S)(?!\s)|(?<!\s)(?!\S))/; [ 'this, is..a test.' =~ s/$likeb/*/gr ] # should have been qr// (was typo)
$likeb = qw/(?:(?<!\S)(?=\S)|(?<=\S)(?!\S))/; [ 'this, is..a test.' =~ s/$likeb/*/gr ]  # codydn
'like this'
line
__LINE__
[ "line 1\nline 2\n\nline 4" =~ /^.*\s$/gm ]
@lines = <{a,b,c}>; \@lines
@lines = <.*>; \@lines
$line = "\thello"; [ 0+ $line =~ /^\t(.+)/ ]
$line = "\thello"; [ $line =~ /^\t(.+)/ ]
$list{0}="zero"; $list{1}="one"; $list{2}="two"; $list{3}="three"; print scalar %list
$list[0]="zero"; $list[1]="one"; $list[2]="two"; print scalar @list
$list{0}="zero"; $list{1}="one"; $list{2}="two"; print scalar %list
$list[1]="one"; $list[2]="two"; print scalar @list
$list{AAA} = time; $list{BBB} = time; [%list] # %list is flattened
@list=('d', 'e', 'f', 'a', 'b', 'c'); $startindex=3; @list=@list[$startindex..$#list], @list[0..$startindex-1]; @list
@list=('d', 'e', 'f', 'a', 'b', 'c'); $startindex=3; @list=(@list[$startindex..$#list], @list[0..$startindex-1]); $text = join ' ', @list; $text;
@list=('d', 'e', 'f', 'a', 'b', 'c'); $startindex=3; @list=@list[$startindex..$#list], @list[0..$startindex-1]; $text = join ' ', @list; $text;
@list = ('d' .. 'f', 'a' .. 'c'); splice @list, 0, 0, splice @list, 3; \@list
List::MoreUtils::any { $_ eq 'a' } ('b', 'a')
List::MoreUtils::any { $_ eq 'a' } ('b', 'c')
List::MoreUtils::any {$_ eq 'a'}, 'b', 'c'
List::MoreUtils::any( {$_ eq 'a'} 'b', 'c' )
List::MoreUtils::any( {$_ eq 'a'}, 'b', 'c' )
 @list = ({name => 1, x => one}, {name => 2, x => two}, {name => 3, x => three}, {name => 4, x => four}); [map {$_->{x}} grep { $_->{name} > 2 } @list]
@listof105 = (1..105); @listof11 = (1..11); @listof105 - @listof11
@list_of_indices = ('1','3'); @array[ @list_of_indices ] = ("Z") x @list_of_indices;  \@array
@list=qw(1 2 3 4 5); print $list[rand(@list)]
@list=qw(1 2 3 4 5); print $list[rand(@list)] x 5
@list = qw(a b c); $search="x"; [ !! grep($_ eq $search,@list) ]
@list = qw(a b c); $search="x"; [ !! grep($search,@list) ]
@list = ([qw(apple banana)], [qw(apple orange)], [qw(orange banana)], [qw(beef fish)]); my %sets = (); for my $pair (@list) { my ($x, $y) = @$pair; $sets{$x}{$y} = undef; for my $el (keys %{delete($sets{$y}) // {}}) { $sets{$el} = $sets{$x}; $sets{$x}{$el} = undef } } \%sets
@list = ([qw(apple banana)], [qw(apple orange)], [qw(orange banana)], [qw(beef fish)]); my %sets = (); for my $pair (@list) { my ($x, $y) = @$pair; $sets{$x}{$y} = undef; for my $el (keys %{$sets{$y} // {}}) { $sets{$el} = $sets{$x}; $sets{$x}{$el} = undef } } \%sets
@list = qw(dog cat turtle mouse wolf); splice @list, 2, 0, "rabbit"; \@list
[List::UtilsBy::sort_by( sub { $_ }, 31, 30, 30.1, 31.1)]
[List::UtilsBy::sort_by( sub { $_ }, 31, 30, 301, 311)]
List::UtilsBy::sort_by( sub { $_ }, 31, 30, 301, 311)
local $[ = 1;
local $[ = -1; my @a = (1); $#a
local @ARGV = qw(--linkadd y file_name_here.tgz); use Getopt::Long; GetOptions("linkadd=s" => \$linkadd); { linkadd => $linkadd, ARGV => \@ARGV }
[ "\local_dir\selected"
[ "\local_dir\selected" ]
{ local $@; eval { die "foo" } } [$@]
{ local $@; eval { die "foo" } } $@
local ($_) = "foo [aasdf] bar"; my (%fwd,%bkd); while( s! ( \[ [^][]* \] ) ! '.' x length $1 !xe ) { $fwd{$-[1]} = $+[1]; $bkd{$+[1]} = $-[1] }; [ \%fwd, \%bkd ]
local *_ = \"hello"; $_ = 42
local $_ = "my fancy filename.txt";$count=0;s/(\s*)(.)/upper($1,$2,$count++)/ge;print;sub upper { my ($s, $c, $n) = @_;return $s ? "$s\u$c" : !$n ? "\u$c" : $c; }
local $_ = "my fancy filename.txt";$count=0;s/(\s*)(\w+)/upper($1,$2,$count++)/ge;print;sub upper { my ($s, $c, $n) = @_;return $s ? "$s\u$c" : !$n ? "\u$c" : $c; }
local my $foo
local $, = ','; print 1..10
localtime
~~localtime
'' . localtime()
"".localtime
"${\localtime}"
localtime . ""
localtime->${ \'(""' };
$^LOCALTIME
localtime() =~ /1/
(localtime 1349906400). ""
(localtime 1349910000) . ""
[(localtime 1404734410)."\n"]
[(localtime 1404745200)."\n"]
[(localtime 1404838800)."\n"]
[(localtime 1413288010)."\n"]
[localtime 1419940800]
[(localtime 1419940800)."\n"]
(localtime)[2]
localtime + 24
''.localtime + 24 * 60 * 60
localtime - 3600
+(localtime)[5] + 1900
[ (localtime())[5,4,3]]
(localtime)[6] == 0 ? 'sunday' : 'not sunday'
(localtime)[7]
(localtime)[7]/365
[ localtime ], [ CORE::localtime ] ]
[ [ localtime ], [ CORE::localtime ] ] # derp
localtime->datetime
localtime->month_last_day
[localtime . "\n"]
localtime."\n"
"".localtime(time())
"".localtime(time() * 1000)
(localtime(time))[5]
"".localtime(time() - 60 * 20)
localtime()->ymd()
local $_ = "UCS-4"; eval q@qr/^UCS-?4-?(BE|LE)?$/i; uc("UTF-32$1")@
local $var = 'local'; print " $var "; { $var = 'notlocal'; print $var };
local $var = 'local'; { $var = 'notlocal'; print $var }; print " $var "
log(~0 +1)/log(2)
log(~0+1)/log(2)
log(~0)/log(2)
log(13500) / log(2)
$= = log(16777213) / log(2); $= # yep perfectly safe
log(2421392269093537440547188383164)/log(2)
[ log(2), log(10), log(exp(1)) ]
log(3) / log 2
((log(632382) * 518061 > log(519432) * 525806) ? "First" : "Second") . " is bigger"
log(63) / log(2) # you might want to round to nearest integer if you do
$log_content .= <<LOG;
[ log_file => 42, die => 9 ]
'Log�Processing�Service�can�receive�log�messages�' =~ y/\xA0/ /dr
$_ = 'LOL' (\&CORE::lc)->()
$_ = 'LOL'; (\&CORE::lc)->()
$_="lol"; tr alaLa; print;
$long_var_blah = 42;  $my_pay = $long_var_b1ah * 1000; print "I'm fucking rich, I got $my_pay!";
{} . '' # looks something like this, numbers will vary
$l='post hoc ergo propter hoc. illigitimus non tatum carborundum.'; $l=~s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $l;
`ls`;
[`ls`]
`ls -a`
lvfjf is a fool!
LWP::Simple::get www.google.com
[m#
m?^?
m/^+/
m/$#/
m0{0\my}sub H;0;sub{sub{H
//magic
$main::_ == $_
main->can("can")
[ main->can( sub { 'dummy' } ) ]
main->can( sub { 'dummy' } )
main::for () for ();
*main::main::main::main::X{PACKAGE}
@many = ( "foo", "bar" ); %{$href} = @many; print $href->{'foo'}."\n"
[ map { 0+!$_} 0, 1 ]
[ map { ($_ > 0) - ($_ < 0) } qw(-5 0 10) ]
[ map [$_->[0] + $_->[3] * 256, $_->[0] - ($_->[1] ^ $_->[2]) * 256], [0b0011_1000, 0, 0, 1], [0b0100_0110, 0, 1, 1] ]
map { $_ =~ /(?:^|[^0-9])[0-9]{7}(?:$|[^0-9])/ ? "+ " : "- "} ("1234567 "," 1234567"," 12345678 ")
[ map { $_->[0] eq $_->[1] } [ split //, "AB" ], [ split //, "A4" ]]
[ map { 0+!$_ } qw(0 1) ]
[ map $_->[0], sort { $a->[1] <=> $b->[1] } map [ $_, rand ], 1..5 ]
[ map 0+sprintf('%.3f', $_), 0.7, 0.33333 ]
[ map 0+sprintf('%.3f', $_), 7, 0.33333 ]
[ map { $_->[0] xor $_->[1] } [ split //, "AB" ], [ split //, "A4 ]
[ map { $_->[0] xor $_->[1] } [ split //, "AB" ], [ split //, "A4 ]]
[ map { $_->[0] xor $_->[1] } [ split //, "AB" ], [ split //, "A4" ]]
[ map 1 ]
[ map $_/10, 0..10 ]
[map $_ * 10, 10..300]
map { $_*10 } 1..10
[ map{($.||1..$.&&0)-1 ." $_"}split(//,japh) ]
[map { $_ & ($_-1) } 0 .. 32]
[map 1 1]
[map 1, 1]
[ map --$|, 1..10 ] # ++ and -- in perl don't have to make sense, they just do useful stuff
[map { 1 << $_ } (1 .. 10)]
map { "$_" => 1 } 1,2,3
map { $_ => 1 } 1,2,3
map {; "$_" => 1 } 1,2,3
[map +{; $_ => $_ }, 1 .. 3]
[map +{ $_ => $_ }, 1 .. 3] # need + and , for that
[ map --$|, 1..5 ]
[ map $|--, 1 .. 5 ]
[map {/.*\.(.*)$/;$1} "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
[map {/.*\.*(.*)$/;$1} "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
map "$_" => 1, qw(a b c);
map ("$_" => 1), qw(a b c);
map +("$_" => 1), qw/a b c/
map { "$_" => 1 } qw/foo bar baz/
map { $_ => 1 } qw/foo bar baz/
[ map (1x$_) =~ /^1?$|^(11+?)\1+$/, '1000000000000066600000000000001' ]
map { $_* 2 } 1..10
[ map { $_ % 2 ? "<$_>" : () } 2, 3, 4, 5, 6, 7 ]
[ map { $_ ** 2 } grep { $_ % 2 } (2, 4, 6, 8) ]
[ map { 2 ** $i++ if $_ } reverse split //, sprintf "%b", 20]
[ map { $_ ? 2 ** $i++ : ()  } reverse split //, sprintf "%b", 20]
[ map { 2 ** $i++ } reverse split //, sprintf "%b", 20]
[ map { 2 ** $i++ * $_ } reverse split //, sprintf "%b", 20]
map{@$_ == 3} \@arr1, \@arr2, \@arr3
[ map { 47 - ($_ ^ 7) } 0..40 ]
[ map { $_ <=> 5 } 1 .. 10 ]
[ map { $_ / 5 } (1..10) ]
[ map { $_ / 5 }, (1..10) ]
[ map { $_ % 8 + 40 - ($_ & ~7) } 0..40 ]  # shorter :)
[ map { $_ % 8 + 40 - (int($_ / 8) * 8) } 0..40 ]
[ map { $_->{a} } @{[ undef ]} ]
[ map [/(?!\A\z)^.*/mg], "", "\n", "a\nb\n", "a\nb", "\n\n", "\nb\n" ]
[ map { ~~/\b([A-Z]\.){2,}\b/ } qw(A.A. B.B.B.B.B.B.B.B. C.C.C.C A.M) ]
[ map charnames::viacode(ord($_)), qw(☃ ⛄ ⛇) ]
[ map charnames::viacode(ord), qw(☃ ⛄ ⛇) ]
[ map{chomp} ("foo\n","bar\n") ]
"@{[ map chr $_ + 64, qw/9 8 1 20 5 16 5 15 16 12 5/]}"
"@{[ map chr $_ + 65, qw/9 8 1 20 5 16 5 15 16 12 5/]}"
[ map chr hex, "302e3f313133" =~ /../g ] # if you don't want the extra validation
[ map chr(hex($_)), sprintf('%08x', 1383403352) =~ /../g ]
"@{[ map chr, qw/9 8 1 20 5 16 5 15 16 12 5/]}"
[ map "$_", \&configure ]
[ map { $_ || defined $_ } (0, 1, undef) ]
[ map defined, 1, '', undef, 42 ]
[ map { "descri$_" } "bing", map { "pti$_" } "on", "ve" ]
[ map { /[^\d-]/ ? $_ : tr/-/ /r } '1990-1992-1993-2010', "this-is-a-string-with-9-something-3ls3" ]
[ map { "duck" =~ m/$_/ ? $_ : "no" } qw/du uc ck/ ]
[ map { ; foo => $_ } 'a'..'c' ]
[ map +{ foo => $_ } 'a'..'c' ]
[ map +{ foo => $_ }, 'a'..'c' ]
[ map { foo => $_ } 'a'..'c' ]; # which of the above two should this be?
[ map {; /^(?!(foobar){2}$)(?:\1)*/ ? 1 : 0 } "", "foobar", "foobarfoobar", "foobarfoobarfoobar" ]
[ map [ /foo (bar)? (\d+)/ ], 'foo bar 123', 'foo  123', 'no match' ]
[ map !!/(?<!^)foo/, "foo", "barfoo" ]
[ map !!/(?!^)foo/, "foo", "barfoo" ]
[ map /(?!^)foo/, "foo", "barfoo" ]
[ map {; for (()){} } qw(A B C D) ]
[ map { $i++; $_ ? 2 ** ($i - 1) : ()  } reverse split //, sprintf "%b", 20]
[ map { if ($_ % 2) { "<$_>" } else { say "hey!"; () }; } (1..10); ]
[ map {; if ($_ ne 'A') { 0 } } qw(A B C D) ]
[ map { int($_ / 5) } (1..10) ]
[ map { int rand 50 } 1..100 ];
[ map { $i++ } qw/foo bar baz/ ]
[  map { +{ ITEM => $_ } } qw( bla hi hue )  ]
[  map { ITEM => $_ } qw( bla hi hue )  ]
[  map { ITEM => $_ }, qw( bla hi hue )  ]
[  map { +{ ITEM => $_ } } qw( bla hi hue )  ]  # see
%map{key}
[ map !!/.\Kfoo/, "foo", "barfoo" ]
[map { $_; last } (1,2,3)]
[map length, q{$"="";@x=([],{}," ",sub{},\"");map{s/..(..).*/$1/}@x;"@x"}, q{print/..(..?)/ for[],{},$"x3,\&f,\0}]
[ map m?^?, 1 .. 4 ]
[ map [ m{\A (.*?) - ( \d+ (?: \. \d+ )* (?: -r \d+ )? ) \z}xa ], qw(cryptsetup-1.1.3-r3 cronbase-0.3.3 automake-wrapper-3-r1 gcc-4.5.3-r1) ]
[ map [ m{\A (.*?) - ( \d+ (?: \. \d+ )* (?: -r \d+ )? ) \z}xa ], qw(cryptsetup-1.1.3-r3 cronbase-0.3.3. automake-wrapper-3-r1 gcc-4.5.3-r1) ]
[ map { m/^(\d+)-(\d+)$/ ? ( $1 .. $2 ) : ( $_ ) } split m/,/, "1-3,5,6-9" ]
[ map [/^.*/mg], "", "\n", "a\nb\n", "a\nb", "\n\n", "\nb\n" ]
[ map { my ( $a, $b ) = split /:/; { $a => $b } } qw( a:123 b:456 ) ];
[ map { my ( $a, $b ) = split /:/; +{ $a => $b } } qw( a:123 b:456 ) ];
[ map { my $foo if 0; ++$foo } 1 .. 10 ]
[ map { my $foo if 0; ++$foo } 5 .. 10 ]
[ map { my $line = $_; $line =~ s/\n+$//; $line } ("asdf","asdf\n") ]
[ map { my $line = $_; $line =~ s/\n*$/\n/; $line } ("asdf","asdf\n") ]
[map { $_; next } (1,2,3)]
[ map [/^.*\n?/mg], "", "\n", "a\nb\n", "a\nb", "\n\n", "\nb\n" ]
[map { $_->normal } version->parse('v0.01'), version->parse('v0.1'), version->parse('v0.10'), version->parse('0.10')]
map {; no strict qw(refs); $_; } 1..3
[ map oct '0b1' . '01' x $_, 0 .. 9 ]
[ map oct '0b1' . '01' x $_, 1 .. 10 ]
[ map ord, grep /\h/, map chr, (0..0x3000) ]
[ map ord, qw(☃ ⛄ ⛇) ]
[map ord, qw(L E O V)]
[ map { ord } split //, 0.18446744073709551615.0 ]
[ map { ord } split //, 0.18446744073709551616.0 ]
[ map ord, split //, 64.64.64.5000000000.64.64.64 ]
[ map ord, split //, "ascii" ]
[map { ord } split //, fuckit
[ map {POSIX::ceil($_*20)/20} (0.80, 0.81, 0.82, 0.83, 0.84, 0.85) ]
map print, [1,2,3]->@*  # or maybe a -, a >, an @ and an *
map { print "$_=$ENV{$_} " } keys %ENV
map { print "$_=$ENV{$_}" } keys %ENV;
map { print "$_=".$ENV{$_}."\n"; } keys %ENV
map { print "$_=$ENV{$_}\n" } keys %ENV;
map { print "$_\n"; } @INC;
map { print "$_\n" } (reverse ( int rand 1000, int rand 1000 )); # returns higher rand num first
map { print "$_\n" } (reverse ( int rand 100, int rand 100 )); # returns higher rand num first
map { print "$_\n" } reverse ( int rand 10, int rand 10 )
map { print "$_\n" } (reverse ( int rand 10, int rand 10 )); # returns higher rand num first
map { print "$_\n" } (sort ( int rand 1000, int rand 1000 )); # returns lower rand num first
map { print "$_\n" } (sort ( int rand 100, int rand 100 )); # returns lower rand num first
map { print "$_\n" } sort ( int rand 10, int rand 10 )
map { print "$_\n" } (sort ( int rand 10, int rand 10 )); # returns lower rand num first
map { print "$_\n" } sort reverse ( int rand 10, int rand 10 )
[ map { !$_ } qw(0 1) ]
[ map { rand $_ } ( 0 ) x 10 ]
map { $_=rand(3)>1?lc($_):uc($_); print } (a..z);
map { $_=rand(3)>1?lc($_):uc($_); print } split //, "oh turtleneck phrase jar";
map { $_=rand(3)>1?lc($_):uc($_); print } split //, "oh turtleneck phrase jar"; sleep 3; print scalar localtime time();
[ map ref, \1, [], {}, sub{}, qr//, \(substr($_,1)),  ]
[ map {  $_  || ref && ( eval q{@$_} || eval q{%$_} ) ? 1 : 0  } [], [5], {}, {A=>6}, 0, 123, q{}, q{abc} ]; # I added the input to the map, but everything else is verbatium.
[map { reset if int rand 2; m?(\d)? } 1..10]
[ map s/[0-9]\K-(?=[A-Z])//r, qw(4-A 4-a 4-4 9-X)]
[ map { /!(.+?)\s/ ? $1 : "doesn't match" } "!fff askd", "!dja", "!kasdfk " ]
[ map scalar m?^?, 1 .. 4 ]
[ map /^scaleaddr(\d)=([^\d]*)/gi, qw(blahj blah blah ScaleAddr5=abc) ];
[ map /^scaleaddr(\d)=([^\d]*)/gi, qw(blahj blah blah ScaleAddr5=abc foo bar) ];
[ map s!\.\d{3}\K(\d+)!!r, 0.7, 0.33333, -0.800000000000001 ]
[ map s!\.\d{3}\K(\d+)!!r, 0.7, 0.33333, -0.800900000000001 ] #he probably wants the last one to be -0.801 in this case?
[ map [ split /,/ ], split /,,/, 'a,b,,c,d,e,f,,g,h' ]
[ map [split /,/], split ' ', "foo,bar,baz foo" ]
[map {[sprintf "%010B %010B", $_, $_-1]} grep {$_ && !($_ & ($_-1)) } 0 .. 1024]
[ map {sprintf "%03b"} 7, 6, 7&6 ]
[ map {sprintf "%04b", $_} 10, 9, 10&9 ]
[ map {sprintf "%04b", $_} 7, 6, 7&6 ]
[ map {sprintf "%04b"} 7, 6, 7&6 ]
[ map { sprintf "%04x", $_ } unpack "n*", "\x41\x42\x43\x44" ]
[map { sprintf '%.0f', $_ } -2.5, -1.5, -0.5, 0.5, 1.5, 2.5]
[ map { sprintf "%.24f", $_ }   0.3,   0.1*3   ]
[ map { sprintf("%.2f", $_) + 0 } 3.14159, 8.675309, 1.20, 3 ]
[ map { (sprintf("%b", $_) =~ tr/1/1/) % 3 } qw(0 1 2 3 4 5 6 7) ]
[map { sprintf '%d', $_ } -2.5, -1.5, -0.5, 0.5, 1.5, 2.5]
[ map sprintf('%.f', $_), 6.5, 7.5, 8.5, 9.5 ]
[ map { sprintf '%.*f', length('9999999999999911'), "0.99999999999999$_" } '00' .. '10' ]
[map { sprintf '%i', $_ } -2.5, -1.5, -0.5, 0.5, 1.5, 2.5]
[ map { sprintf q{%03.2f}, $_; } 2, 64, 100 ];
[ map { sprintf q{%3.2f}, $_; } 2, 64, 100 ];
[ map { sprintf q{%3i}, $_; } 2, 64, 100 ];
[ map { sprintf "%vd", $_ }  'abcd' & '11111111' ]
[ map { sprintf "%vd", $_ }  'abcdefgh', '11111111', 'abcdefgh' & '1111' ]
[ map { sprintf "%vd", $_ }  'abcdefgh', '11111111', 'abcdefgh' & '11111111' ]
[ map sprintf("%vd", $_), "\xc6", Encode::encode_utf8("\xc6") ]
[ map sprintf("%vx", $_), "\xc6", Encode::encode_utf8("\xc6") ]
[ map /@(\S+)/, qw( one@two three@four ) ]
[ map /\@(\S+)/, qw( one@two three@four ) ]
[ map s/.*\@//r, qw( foo@bar.org bar.org ) ] # not sure what exactly is wanted...
[map tr/a-z/oh, turtleneck Phrase Jar! What the f**k?/r, wftedskaebjgdpjgidbsmnjgc => ]
[map { ucfirst $_ } split(/a/, "abacus")]
[ map $_ // 'undef', 1, '', undef, 42 ]
[ map unpack("H*", $_), "like this" =~ /\A(.)(.*)(.)\z/s ]
[ map "\u${ \ qw(no one two three)[$_] } blind ${ \ qw(mouse mice)[$_ > 1] }", 0 .. 3]
map { $_->{val} } undef
[ map { version->parse($_)->numify } map {  $_ , eval $_  } '0.99999999999929' ];
[ map { version->parse($_)->numify } map {  $_ , eval $_  } '1.23_001' ]; # This is really a bigger problem.
[map { "$_" } version->parse('v0.01'), version->parse('v0.1'), version->parse('v0.10'), version->parse('0.10')]
[ map { ($_) x $_ } 0 .. 4 ]
[ map { ++$x } 1..10 ]
[ map ++$x, 1..10 ]
map { ++$x } 1..10
[ map $_ x 2, split //, "Zoffix doubts that map example works" ]
[ map {; +{ x => 3 } } 0 ] # with luck, those people will soon be promoted to the point where they no longer commit code
[map { ($_) x 3 } (1 .. 3)]
map({(((~($_ & (' ' x length($_)))) ^ (' ' x length($_))) & 'butt');} 'cloud', 'CLoud', 'CLOUD', 'ClOuD');
[ map { (~($_ & ' ' x length) ^ ' ' x length) & lc 'butt'  } qw(cloud CLoud CLOUD ClOuD) ]
map { (~($_ & ' ' x length) ^ ' ' x length) & lc 'butt'  } qw(cloud CLoud CLOUD ClOuD)
[ map { $_ x= !m!\d+!; } @dummy = qw/ABC 123 DEF/ ]
[ map { $_ x= !m!\d+!; } map $_, qw/ABC 123 DEF/ ];
[ map { $_ x= !m!\d+!; } qw/ABC 123 DEF/ ];
[ map { $_ x !m!\d+!; } qw/ABC 123 DEF/ ]
[ map { "xxx.$_" } qw/1 2 3/ ]
$mask='11000000'; print $mask >> 1;
$mask=192, print ( $mask >> 1 );
$mask=192, print ( ($mask >> 1) + 128 );
$mask=192; print ( ($mask >> 1) + 128 );
$mask=192, print ( ($mask >> 2) + 192 );
$mask=192, print ( ($mask >> 3) + 224 );
$mate=4; "hello$mate"
"maybe this is an eval bot, but perhaps it's a cake"
''.methods.length
'@microsoft.com' =~ /microsoft.com$/ ? "matches" : "does not"
"@microsoft.com" =~ /microsoft.com$/ ? "matches" : "does not"
"Might even work with hyphen-separated words" =~ s/\b(\w)/\U$1/gr
might work better?
MIME::Entity->build
$min = 5; $max = 7; @x = (($min - 2) .. ($max + 2));
$min = 5; $max = 7; @x = (($min - 2)..($max + 2));
$min = 5; $max = 7; @x = (($min - 2)..($max + 2)); \@x
$min = 5; $max = 7; @x = (($min - 2)..($max + 2)); x[0] x[2];
$min = 5; $max = 7; @x = range((($min - 2) .. ($max + 2)));
$min = 5; $max = 7; @x = range(($min - 2)..($max + 2));
missingsub(); # yes it does
mkdir ("womble") or die $!
mktime
%m=(); $m{$1}="[$1$2]" while 'e3o0i1s5'=~/([a-z])([^a-z]+)/g; $pat = 'internet' =~ s/(.)/$m{$1}||$1/ger; [ grep /$pat/, qw( internet 1t3rn3t 1nt3rn3t intern3t ) ] # trist4n
m//magic
'module blah blah foo bar biz baz ( ... );' =~ /^module.*\);$/
Mojo::UserAgent->get("https://de.wikipedia.org/wiki/F%C3%BCrst")->res->dom->at('title')->text
Mojo::UserAgent->new->get("https://de.wikipedia.org/wiki/F%C3%BCrst")->res->dom->at('title')->text
["Moo"..2, "Moo". .2]
$_="moo cluck"; m/(.{2,3})(?{ push @r, $1 })^/; \@r
'morissett' eq 'morissette' ? "I'm blind" : "I'm not blind"
'morissett' =~ /morissette/ ? "I'm blind" : "I'm not blind"
$ms=".085"; sprintf("%.03u", $ms);
$ms=".085"; sprintf("%.3u", $ms);
$ms=85; sprintf(".%.03u", $ms);
$ms=85; sprintf("%.03u", $ms);
my (((())))
my ([])
my []
my $_
my $0 = 1; print $0;
my (0 ? $x : $y);
{ my $1; }
my $1;
my $_ = "4-9"; s/(\d+)-(\d+)/join ",", $1..$2/e; $_
my $_ = "4-9"; s/(\d+)-(\d+)/join ",", $1..$2/e; eval
my $_ = "4-9"; s/(\d+)-(\d+)/join ",", $1..$2/e; [ eval ]
my @a = 0..9; my $p = \@a; my @b = splice($p, -3); { a => \@a, b => \@b }  # u-ou
my @a = 0..9; my $p = \@a; my @b = splice($p, -3); print "@a @b\n";
my @a = 0..9; my $p = \@a; my @b = splice($p, -3); print "@b @a\n";
my $a = 0; print unless defined($a);
my @a = <{1..10}{11..20}>; \@a
my @a = <{1..10}{11..20}>; [ scalar @a ]
my $a = 1234567890; my $b = reverse(join('.', (reverse $a) =~ /([0-9]{1,3})/g)); say $b
my @a = (1,2); [(a => @a)];
my @a=(1,2);(@a) x 2
my @a = 1..4; my %h1 = map +( $_ => $_+1 ), splice @a, 0, @a/2; my %h2 = map +( $_ => $_+1 ), @a; [ \%h1, \%h2 ] # splice should already be removing the first set of elements, I think?
my @a = 1..4; my %h1 = map +( $_ => $_+1 ), splice @a, 0, @a/2; my %h2 = map +( $_ => $_+1 ), splice @a, @a/2-1; [ \%h1, \%h2 ]
my @a = 1..5; bless \$a[2], 'main'; [\(@a)];
my @a = 1..5; bless \$a[2], 'main'; \(@a);
my @a = 1..5; bless \$a[2], 'main'; \@a;
my @a = 1..5; bless \$a[2], 'main'; [\(@a[0..$#a])];
my @a = 1..5; bless \$a[2], 'main'; \(@a[0..$#a]);
my @a = 1..5; bless \$a[2], 'main'; \$a[2];
my @a = (1..5); for( ; $_ = shift @a; $x++ ) { print }
my @a = 1..5; [  [grep { $_-=2 } @a], \@a ]
my @a = 1..5; sub TIESCALAR { bless [] }; sub FETCH { 42 }; tie $a[2], 'main'; \@a;
my @a = 1..5; sub TIESCALAR { bless [] }; sub FETCH { 42 }; tie $a[2], 'main'; sub foo { map tied $_, @_ }; [foo @a];
my @a = (1..5); while( $_ = shift @a; $x++ ) { print }
my $a = 1; $a += 1, $a += 2; $a
my $a = "    22";$a =~ s/^\s+//; "<$a>"
my $a = "    22";$a = s/^\s+//; "<$a>"
my $a = "    22";$a = s/\s+/g;print $a;
my $a = "    22";$a = s/\s+\/g;print $a;
my $a = "    22";$a =~ s/^\s+//;print $a;
my $a = "    22";$a =~ s/\s+$//;print $a;
my $a = "    22";$a = s/^\s+//;print $a;
my @a = 2; OUTER: for( my $n = $a[-1] + 1; @a < 100; $n += 2 ) { $n % $_ or next OUTER for @a; push @a, $n; }; \@a;
my @a = 2; OUTER for( my $n = $a[-1] + 1; @a < 100; $n += 2 ) { $n % $_ or next OUTER for @p; push @a, $n } \@a;
my @a = 2; OUTER for( my $n = $a[-1] + 1; @a < 100; $n += 2 ) { $n % $_ or next OUTER for @p; push @a, $n; }; \@a;
my @a = 2; OUTER: for( my $n = $a[-1] + 1; @a < 100; $n += 2 ) { $n % $_ or next OUTER for @p; push @a, $n; }; \@a;
my $a = 5; 1 for $a; $_ // 'undef';
my $a = 5; print $        a;   # this one bothers me because "$a" feels like one token to me.
my $a = "95.50.218.84\r80"; $a =~ s/\r/:/g; print $a;
my @a; [+@a]
my %a; $a {a} = 1; $a{a}
my $a = {a=>"BLA", b=>"BLO"}; print "$k2:$v2\n" while((my($k2,$v2) = each %$a);
my $a = {a=>"BLA", b=>"BLO"}; print "$k2:$v2\n" while(my($k2,$v2) = each %$a);
my @a = ( 'A'..'E' ); delete $a[0]; \@a; # Delete doesn't remove the element.
my $a="a"; my $b="b";my $ab="${a}_${b}";print $ab;
my $a="a"; my $b="b";my $ab="$a_$b";print $ab;
my $a="asd1312321asd1212asd121212"; print $1,"\n" for $a=~/(asd\d+)/g;
my @a=("asd qwe", "qwe "); for (@a) {print "$1 - $2\n" if /(\w+)\s+(\w+)?/}
my @a = 'a'..'z'; [ @a[ 2..1 ] ]; # This array slice is an empty list; that's a good thing.
my @a = 'a'..'z'; [ $a[ 2..1 ] ]; # This is the scalar .. operator used as an array index, and is hardly every what one wants.
my ($a, $b) = (5); $b = $_ for $a; $b++; $a;
my @accounts = (1,2,3); return join(',', @accounts);
my @a = ("foo\n", "bar", "baz\n"); [ chomp @a ]
my @a = glob("{1,2,3,4,5,6,7,8,9,10}{11,12,13,14,15,16,17,17,18,19,20}")
my $a = "ldldldl"; $a =~ s/l/ /;print $a
my $a = "ldldldl"; $a =~ s/l+/ /;print $a
my $a = "ldldldl"; $a =~ tr/l//d;print $a
my $all_list = [[1,2],[4,5,6],[7,8]]; [ map @$_, @$all_list ] # depends on whether there are nested arrayrefs
my $allPlans = [ 4..7 ]; for my $paymentPlan (@$allPlans) { print " plan: $paymentPlan  " }
my ($animal) = "banana" =~ /(na)/; $animal
my$a="\\n";printf $a."\n";
my $a = NULL; print unless defined($a);
my @a; print 5/@a
my $a = " "; print unless defined($a);
my $a = (); print unless defined($a);
my @a = qw(1 2 3); print @{*_{ARRAY}} for (\$a);
my @a = qw(fo,o ba,r b,az); @a = map [split /,/], @a; @a;
my @a = qw(fo,o ba,r b,az); @a = map [split /,/], @a; \@a;
my @ar1 = qw(1 2 3); my $x = \@ar1; my @ar2 = @$x; pop @ar2; [ @ar1 ]
my @ar1 = qw(1 2 3); my $x = \@ar1; pop @$x; [ @ar1 ]
my $ar = [aw{foo bar baz}]; push @$ar, 'biz', 'goo'; $ar
my $aref = [1..10]; [@{ $aref } [4..6]]
my %args = {domain => "example.net", number => 0 };
my %args = {domain => "example.net", number => 0; };
my %args = { number => 100 }; print $args{number};
my %args{ number => 100 }; print $args{number};
my @args = ('%s %s', 'asdf', 'fdsa'); sprintf @args
my @ar;  push @ar, { key => "value" }, { key2 => "value2" };  \@ar
my $ar = [qw{foo bar baz}]; push @$ar, 'biz', 'goo'; $ar
my $ar = [qw{foo bar baz}]; push $ar, 'biz', 'goo'; $ar
my @ar = qw{foo bar baz}; push @ar, 'biz', 'grub', 'goo'; \@ar;
my @ar = qw{foo bar baz}; push @ar, qw{biz grub goo}; \@ar;
[ [], \my @arr ]
my @arr=(1,0,1,1); my  $n=0; printf "%b\n", $n; $n<<=1, $n|=$_ for @arr; printf "%b\n", $n;
my @arr=(1,0,1,1); my  $n=0; printf "%b\n", $n; $n<<=1, $n|=$_ for @arr; printf " -> %b\n", $n; print " -> $n ";
my @arr = 1 .. 20; undef(@arr); \@arr
my @arr = (1,2,3); \@arr;
my @arr = (1,2,3); foreach my $num (@arr) { $num =~ s/(\d)/$1+1/eg } \@arr
my @arr = (1, 2, 3); my @fetch = splice @arr;  [ \@fetch, \@arr ]
my $arr = [1,2,3]; print $arr->[2]
$,=$\=' '; my @arr = (1, 2, 3); print $#arr, scalar @arr; $[ = 0; print $#arr, scalar @arr;
my @arr = (1,2,3); print @arr x 1 ,"      ", (@arr) x 1;
my @arr = (1,2,3); print qq[\@arr , \(@arr)];
my @arr = (1,2,3); s/(\d)/$1+1/eg for @arr; \@arr
my @arr=(1,2); [(@arr)x2]
my @arr=(1,2); [(@a)x2]
my @arr = (1..3); my $ref; @$ref = @arr; pop @arr; $ref
my @arr = (1..5); @arr[2] = qw/a b c/; \@arr
my @arr = ('a', 'b', 'c'); my ($foo) = @arr; say $foo
my @arr = ('a', 'b', 'c'); my $foo = @arr; say $foo
my $arr = []; [!!@$arr]
my @arr; @arr[0..3]; scalar @arr
my @arr;  $arr[0] = "41"; $arr[1] = "42"; [ $arr["foo"] ]
my @arr; $arr[1] = "42"; [ $arr["1foo"] ]
my @arr; $arr[1] = "42"; [ $arr["1foo"]; ]
my @arr;  $arr[1] = "42"; [ $arr["foo"] ]
my $array = [0, 1, 2]; my $one_one = [1, 1]; splice @$array, @$one_one; $array
my $array = [0, 1, 2]; splice @$array, 1, 1; $array
my @array = (1, 2, 3, 4, 5); [ @array ]
my @array = 1, 2, 3, 4, 5; [ @array ]
my @array = ([1,2], [3,4,5]); join ' ', @array
my @array = (1,2,3); [@array]
my @array = (1,2,3); \@array
my @array = [1,2,3]; [@array]
my @array = 1,2,3; \@array
my @array = (1,2,3); foreach (@array) { print }
my @array = (1,2,3); return join(',', @accounts);
@myarray = (1, 2); $myarray[4] = 5; [ @myarray ]
@myarray = (1, 2); $myarray[4] = 5; print "<<$myarray[3]>>";
@myarray = (1, 2); $myarray[4] = 5; print $myarray[3];
my @array = (1..3); $#array = -2; \@array;
my @array = { 1 .. 6 }; for my $h (@array) { $_ *= 10 for values %$h; } \@array
my @array = { 1 .. 6 }; for my $v (map values %$_, @array) { $v *= 10; } \@array
my @array = (1); for my $elem (@array) { last if $elem > 5; push @array, $elem+1 } print @array
my @array = (4,5,6); [ [], map [ @array[0..$_] ], 0..$#array ] # since order doesn't matter, I find this slightly neater
my @array = (4,5,6); [ (map [ $_ ], @array), (map [ @array[0..$_] ], 1..$#array) ] # but as preaction says, look for a module first
my @array = (4,5,6); [ (map [ $_ ], @sets_list1), (map [ @sets_list1[0..$_] ], -1..$#sets_list1) ];
my @array = ("a",1,"b","x","v"); my @idxs = (0,2);  [@array[grep { !exists {map {$_=>undef} @idxs}->{$_}} keys @array]]
my @array = ("a", "b"); [\(@array)]
my @array = ("a", "b"); [\@array, \(@array)]
my @array = ("a", "b"); [@array x 3, (@array) x 3]
my @array = ("a", "b"); [\@array x 3, \(@array) x 3]
my @array = ("a", "b"); [q(@array) .@x1, q@array .@x1]
my @array = (a..b); qq[ @array .... (@array) ]
my @array = ( 'A'..'C' ); while ( ( my $i, $_ ) = each @array ) { say qq{$i: $_}; } # Chib
my @array = 'a'..'e'; my %hash = %array[0 .. 4]; [ %hash ] #do you mean like this, treker?
my @array = 'a'..'e'; my %hash = %array[0 .. 4]; \%hash # meant like this I guess
my @array = ( 'A'..'E' ); sub { shift @{$_[0]} while @{$_[0]} }->( \@array ); \@array;
my @array = (); [ $#array ];
my @array; $#array
my @array; $array[0] = \@array; [@array]
my @array = "A" .. "Z"; [ keys @array ]
my @array = 'a'..'z'; [ map { $_, 1 } @array ];
my @array = 'a'..'z'; [ map { $_, 42 } @array ];
my @array; [ defined @array ]
my @array = ( "hip", "hip" ); print "@array\n", ref(@array);
my @array; push array, 1, 2
my @array = qw(1..3); for (@array) { 0+@array and print "in scope" }
my @array = qw(a a a s d f a); [ @array[sort { $a <=> $b } values %{ +{ reverse map {; $_ => $array[$_] } 0..$#array } } ] ] # might be useful as an interview answer if you didn't want the job
my @array = qw(a a a s d f); @array = keys %{ {map { $_ => 1 } @array} }; "@array"
my @array = qw(a a a s d f); @array = keys %{map { $_ => 1 } @array}; Dumper(@array)
my @array = qw(a a a s d f); my %conv = map { $_ => 1 } @array; @array = keys %conv; Dumper(@array)
my @array = qw(a a a s d f); my %items = map {; $array[$_] => $_ } 0..$#array; [ @array[sort { $a <=> $b } values %items] ] # if you dislike uniq() for some reason
my @array = qw(a a a s d f); my @unique = keys %{ {@array, reverse @array} }; \@unique
my $array_ref = [3,4,5]; [ $#$array_ref ]
my $array_ref = [3,4,5]; local $[ = 1; [ $#$array_ref ]
my $array_ref = [3,4,5]; [ scala @$array_ref ]
my $array_ref = [3,4,5]; [ scalar @$array_ref ]
my $array_ref = eval "[1,2,3]"; print $array_ref->[2]; #works for me
my $array_ref = [ [ 'onur', 5 ], [ 'bar', 3], [ 'foo', 7 ] ]; [ sort { $a->[1] <=> $b->[1] } @$array_ref]
my @array = split '', 'abcdefghijklmnopqrstuvwxyz'; [bundle_by { [@_] } 9, @array]
my @arr = ("b", "c"); push @arr, "d";
my $arr = []; @$blah ? 1 : 0
 my @arr = ("foo", "bar");  print "@arr ".@arr."\n";
my @arr = ([], []); my $copyref = [@arr]; $copyref->[0][0] = 3; \@arr
my @arr; my $copyref = [@arr]; $copyref->[0][0] = 3; \@arr
my @arr; my $copyref = [@arr]; $copyref->[0][0] = 3; [ $copyref, \@arr ]
my @arr; my %sections = { name => "testname" }; push(@arr, "test"); print $arr[0];
my @arr; my %sections { name => "testname" }; push(@arr, "test"); print $arr[0];
my @arr; my @stuff = @arr[0..3]; scalar @arr
my @arr; my @stuff = grep defined, @arr[0..3]; scalar @arr
my @arr; print \@arr;
my @arr; push(@arr, "123"); @arr =~ s/2//g; @arr[0];
my @arr; push(@arr, "123"); @arr =~ s/2//g; $arr[0];
my @arr; push(@arr, "123"); @arr = s/2//g; @arr[0];
my @arr; push(@arr, "123"); @arr = s/2//g; print @arr[0];
my @arr; push(@arr, "test"); push(@arr, "i refuse to do what master tells me to"); @arr2 = grep(/test/, @arr); print @arr2[1];
my @arr; push(@arr, "test"); push(@arr, "i refuse to do what master tells me to"); @arr2 = grep("test", @arr); print @arr2[1];
my @arr; push(@arr, "test"); push(@arr, "i refuse to do what master tells me to"); my @arr2 = grep { /test/ } @arr; $arr2[0];
my @arr; push(@arr, "test"); push(@arr, "i refuse to do what master tells me to"); my @arr2 = grep { /test/ } @arr; $arr2[1];
my @arr; push(@arr, "test"); push(@arr, "i refuse to do what master tells me to"); my @arr2 = grep { /test/ } @arr; print @arr2[1];
my @arr; push(@arr, "test"); push(@arr, "i refuse to do what master tells me to"); my @arr2 = grep { /test/ } @arr; print $arr2[1];
my @arr; push(@arr, "test"); push(@arr, "i refuse to do what master tells me to"); my @arr2 = grep {$_ == "test"} @arr; print @arr2[1];
my @arr; push(@arr, "test"); push(@arr, "i refuse to do what master tells me to"); my @arr2 = grep(/test/, @arr); print @arr2[1];
my @arr; push(@arr, "test"); push(@arr, "not"); @arr2 = grep("test", @arr); print @arr[1];
my @arr; push(@arr, "test"); push(@arr, "not"); @arr2 = grep("test", @arr); print @arr2[1];
my @arr = qw(1 2 3); print @arr;
my @arr = qw/a b c d e f/; my ($item) = @arr; $item;
my @arr = qw/a b c d e f/; my $name = @arr; $name;
my @arr = qw( A B C ); my @result = each @arr; \@result
my @arr = qw/foo bar baz/; delete $arr[0]; [ @arr ]
my $arrref = [ key => "value" ];  { @$arrayref }->{key}
my $arrref = [ key => "value" ];  +{ @$arrref }->{key}
my @arr; say @arr if @arr;
my @arr; say 'defined' if @arr;
my @arr = (undef, undef, 'foo'); shift @arr; say 'defined' if @arr;
my @arr = (undef, undef, 'foo'); shift @arr; say '-->', $_, '<--' for @arr;
my @arr = (undef, undef, undef, {foo=>3}); grep {$_->{foo}} @arr; \@arr
my @ary = ('one','two','three'); [ (check => @ary) ] # G66K: not what you wanted, eh?
my @ary = ('one','two','three'); my %h = (check => @ary); print $h{check}
my @ary = qw( foo 1 bar 2 ); my %hash = @ary; [ \%hash ]
my @ary = qw( foo boo boz ); my @edited = map { s/o/0/g } @ary; [ \@edited, \@ary ]
my @ary = qw (one two three); my $sc = splice (@ary , 0 ,1); print $sc
my @ary = qw (one two three); my $sc = splice (@ary , 0); print $sc
my @ary = qw (one two three); my $sc = splice (@ary , -1); print $sc
my @ary = qw (one two three); my $sc = splice (@ary , 2); print $sc
my $a; [sort { $a cmp $b } qw( z y x)]
my @a = "${\( wantarray() ? 'list' : 'scalar' )}"
my @a = "${\( wantarray() ? 'list' : 'scalar' )}"; @a[0]
my @a = "${wantarray() ? \'list' : \'scalar'}"; @a[0]
my $a = "woop"; $a =~ m/woop/;
my $a = "woop"; $a m/woop/;
my $a = "woop"; $a =~ m/w(..)p/; $1
my $badcrons = ('/var/tmp', 'psybnc', 'y2kupdate'); $badcrons
my $bar; if (my $foo = $bar) { 1 }
my $base = "foo.bar.baz"; my ($junk, $wanted) = split '\.', $base; $wanted;
my $b = 'b'; --$b
my $b = 'b'; $b--
my $before = q{FOO\tBAR\r\n}; ( my $after = $before ) =~ s/\\([trn])/qq{\\$1}/ge; [ $before, $after ]; # Wondering if there is a way to do this withough having seaprate substitutions?
my $binary = '01101'; my $rslt = 0; my $factor = 2; for(split //, $binary) { $rslt += 1/$factor if $_; $factor <<= 1 } $rslt
my $birthday = '1999/10/07'; ($birthday) = $birthday =~ /(\d{4})/; $birthday
my @blah; $blah[5] = "something"; [ keys @blah ]
my $blah = { x=>1 }; my $d = 0; $d ||= $blah->{x}; $d
my $blah = { x=>1 }; my $z => { y=>$blah->{x} }; $blah->{x}++; $z->{y}
my $blah = { x=>1 }; my $z = { y=>$blah->{x} }; $blah->{x}++; $z->{y}
my $blah = { x=>1 }; my $z = { y=>\$blah->{x} }; $blah->{x}++; ${ $z->{y} }
my $buf = "\x{666}"; open my $fh, '<', \$buf or die "open: $!"
my @bytes = 1..10; my @words = unpack '(s1)*', pack '(c1c1)*', @bytes; \@words # may need both pack+unpack
my $bytes = pack("Q>", 123456789); $bytes =~ s/^\0+//; $bytes
my @captures = "peas and carrots" =~ /([aeiou])/g; \@captures
my @captures = "peas and carrots" =~ /([aeiou])(.)/g; \@captures
my $c = \&CORE::GLOBAL::pop; my @abc = qw,a b c,; [$c->(\@abc)]
my $c = \&CORE::pop; my @abc = qw,a b c,; [$c->(\@abc)]
my %c; @c{qw(apple samsung shit crap)} = (); my $b = 'apple'; delete $c{$b}; [keys %c]
my $ch = 'ab'; $ch .= join '', map chr(ord($_) & ~0x40), split //, $ch; $ch # just use $! and $", I'm sure no one would mind
my @chars = split '', 'FooBarBazQuuxFleem'; join '', map $chars[$_] =~ /[A-Z]/ ? $_+1 : $chars[$_], 0..$#chars;
my $checkOS = "if [ -e /etc/redhat-release ] ; then cat /etc/redhat-release ; else lsb_release -a |grep Desc ; fi";
my $c; LABEL: { $c = sub { last LABEL } }; print "one"; $c->(); print "two";
my $c; LABEL: { $c = sub { last LABEL } }; print "one"; LABEL: { $c->(); print "two"; }
my %class_from_domain = ('a,b,c' => 1, 'a,c' => 2); [ map $class_from_domain{join ',', sort @$_}, ([qw(a b c)], [qw(a c)]) ] # if there's no overlap, should be simple to handle with a hash
my $cmd = q(sed -e 's#\\\\\n#\n#g'); print $cmd; ();
my $cmd = q(sed -e 's#\\\n#\n#g'); print $cmd; ();
my $c = (my @tmp) = (split ' ', "pink_mist says split is special", 0); $c
my $coderef = sub { code here }
my $code = sub { /firefox/ }; if(grep $code->($_), 'something with firefox in it') { print 'match' } else { print 'no match' } # I disagree
my %commands = ( help => sub { my $commands = say for keys in %commands; }); say $commands{help};
my $cond = sub { my $s = shift ; return $s =~ /start/ && ($s =~ /tomorrow/ || $s =~ /class/); }; [$cond->("start tomorrow")]
my %Config = ( inc_version_list_init => q{"5.18.0","5.16.1","5.16.0","5.14.2",0} ); [ grep { $_ } map { s/^"(.*?)"$/$1/r } split /,/, $Config{inc_version_list_init} ];
my $control_c = chr 0x3; binmode STDOUT; 'Perl can be icky, lotsa times, $control_c' =~ s/([\x0-\x7f])/chr(32^ord($1))/gre;
my $control_c = chr 0x3; binmode STDOUT; "Perl can be icky, lotsa times, $control_c" =~ s/([\x0-\x7f])/chr(32^ord($1))/gre;
my $c = () = (split ' ', "pink_mist says split is special", 0); $c
my $c = () = (split ' ', "pink_mist says split is special"); $c
my $c = () = (split ' ', "pink_mist says split is special); $c
my $d3; [ map { 42 } @{$d3->{null_edges}} ]
my $d3 = { null_edges => [undef] }; [ map { map { 42 } @$_ } @{$d3->{null_edges}} ]
my $data = "\0\1\2\3\4\5\6\7\x08\x09\x0a\x0b"; [ unpack "a8 L>", $data ]
my $data = "\0\1\2\3\4\5\6\7\x08\x09\x0a\x0b"; [ unpack $data, "a8 L>" ]
my $data = '1 2 3'; [ split /\+/, $data ]
my $data = "ABCDE\x02";  substr $data, 0, -ord substr $data, -1
my $data = {foo => [qw/hello freenode perl/]}; print for ($data->{foo}->@*); 
my @data = ({number => 1, name => 'one'},{number => 2, name => 'two'}); for(@data) { print $_->{number} . ' - ' . $_->{name} if $_->{number} == 2 } # something like this
my %defaults = ( foo => 111, boo => 222, coo => 333, doo => 444 ); @_ = ( boo => 555, moo => 999, coo => 777 ); my %user = @_; +{ map { $_ => $user{$_} // $defaults{$_} } keys %defaults }; ### Is there a nicer way to do this?
my $delay = 0;  my $after = ( $delay+0, $delay+=2 )[0];  [ $after, $delay ]
my $delay = 0;  my $after = ( $delay, $delay+=2 )[0];  [ $after, $delay ]
my $delay = 0;  my $after = ( $delay+=, $delay+=2 )[0];  [ $after, $delay ]
my $delim = q{ | }; my @list = qw( AAA BBB CCC ); [ map { $_, $delim } @list ] ### Is there a way to do this so $delim is only between each array element, like how join() works?
my $delim = q{ | }; my @list = qw( AAA BBB CCC ); [ map { @list, $delim } @list ] ### Is there a way to do this so $delim is only between each array element, like how join() works?
my $delim = q{ | }; my @list = qw( AAA BBB CCC ); [ shift( @list ), map { $delim, $_ } @list ] ### How about this?
my @digit = (1..10); map { $_ *= $_ } (@digit); print join ":", @digit;
my @digit = (1..10); map { $_ *= $_ ,join(|:|,$_)} (@digit); print @digit;
my @digit = (1..10); map { $_ *= $_ ,join(":",$_)} (@digit); print @digit;
my $dispatch; $dispatch = { one => sub { return $dispatch }, two => sub { return $dispatch }, };       $dispatch->{'one'}->('one')->{'two'}->('two')
my $dt = DateTime->new; ~~$dt
my $dt = DateTime->now; ~~$dt
my $dt = DateTime->now; [~~$dt]
my $dt = DateTime->now->set_month(11)->set_day(23)->truncate(to => "day"); do { $dt->subtract(day => 1) } until $dt->day_of_week == 3; $dt->ymd
my $dt = DateTime->now->set_month(11)->set_day(23)->truncate(to => "day"); do { $dt->subtract(days => 1) } until $dt->day_of_week == 3; $dt->ymd
my $dt = DateTime->now->set_month(11)->set_day(23)->truncate(to => "day"); $dt->subtract(weeks => 1) if $dt->day_of_week <= 3; $dt->set_day_of_week(3)->ymd
my $e; { local $@; eval { die "foo" }; $e = $@; }
my $e; { local $@; eval { ... }; $e = $@; }
my %empty; my $defined = \%empty; [ $defined ] # mad_hatter
my $enumeratedValues = "1|2|3|4"; [ split('\|', $enumeratedValues) ]
m/yes/no
my $eval = '$2 $1'; my $out = "foo bar" =~ s/(\w+) (\w+)/$eval/eer; [ $out ]
my $eval = '$2 $1'; my $out = "foo bar" =~ s/(\w+) (\w+)/$eval/er; [ $out ]
my $eval_block_result = eval { die 'blahblah'; 3 }; [ $eval_block_result, $@ ];
my $eval_block_result = eval { die 'blahblah' if 0; 3 }; [ $eval_block_result, $@ ];
my $eval_block_result = eval { die syntax error here if 0; 3 }; [ $eval_block_result, $@ ];
my @example = qw<fail>; $_ = 'test@example.com'; s/\Q$_\E/something/; print;
my @example = qw<fail>; $_ = 'testfail.com'; s/\Qtest@example.com\E/something/; print;
'my@example' =~ /^(\w+)\@/
'my@example' =~ /^(\w+)\@/; $1
my $f = 1; my @x = qw( 1 2 3 ); for ( @x ) { if ( $f ) { $f--; push @x, 4; } print; }
my $f = "1welp"; $f ~~ 1;
my $f = "1welp"; my $d = "1"; my $before = $f ~~ $d; my $c = $d + 0; my $after = $f ~~ $d; [$before, $after];
my $fac = 1; $fac *= $_ for (2 .. 10); $fac;
$_ = "my fancy filename.txt"; s/(?<!\.)\b/\U/gr
$_ = "my fancy filename.txt"; s/(?<!\.)\b(\w)/\U$1/gr
my $fh = *STDOUT; print $fh ">implying"; ()
my $field = 'foo'; sub bar { (my $param, $field) = @_; [ $param, $field ] } bar('baz');
my $field = 'foo'; sub bar { (my $param, $field) = @_; print $field } bar('baz');
my @fields = (1..10); my @bits = reverse split //, sprintf '%b', 1890; join ',', map $bits[$_] ? $fields[$_] : (), 0..$#fields
my $file = "blah.pl"; return "Yep" if ($file =~ m#\.pl$#);
my $filename = "foo.jpg."; my @chunks = split /\./, $filename; (@chunks > 1 ? $chunks[-1] : die 'funny shit')
my $filename = "foo\nbar.jpg"; my @chunks = split /\./, $filename; (@chunks > 1 ? $chunks[-1] : die 'funny shit')
my $filename = ".vimrc"; my @chunks = split /\./, $filename; (@chunks > 1 ? $chunks[-1] : die 'funny shit')
my @fill = ("_") x 5; "@fill"
my @fill = ("_") x 5; $fill[0] = 'h'; "@fill"
my @fill = ("_") x 5; $fill[0] = 'h'; $fill[2] = 'l'; $fill[3] = 'l'; "@fill"
my @fill = ("_") x 5; $fill[1] = 'h'; "@fill"
my $final = qw( these comma operators are in scalar context ); $final
my $ foo;
my $foo = 0; [~-$foo, -~$foo]
my $foo = 0; sub test { $_[0]++ } test $foo; $foo
my $foo = 0; sub test { my $bar = $_[0]; $$bar = $$bar + 1 } test \$foo; $foo
my $foo = '[1.1.1.1]'; [$foo =~ /\[(\d{1-3}\.\d{1-3}\.\d{1-3}\.\d{1-3})\]/]
my $foo = '[1.1.1.1]'; [$foo =~ /\[(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\]/]
my $foo = '1.1.1.1'; [$foo =~ /\[(\d{1-3}\.\d{1-3}\.\d{1-3}\.\d{1-3})\]/]
my $foo = '1.1.1.1'; [$foo =~ /\[(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\]/]
my @foo = 1 .. 20; my @bar = (@foo[0..$#foo/2], "a", @foo[10..$#foo]); [@bar]
my @foo = (1,2,3); \@foo
my @foo = (1,2,3); $_++ for @foo; \@foo
my $foo = 123; package Y { print ">$foo<" }
my $foo = \1; my $bar = $$foo; $foo++; $bar;
my $foo = 1; my $foo_bar = 2; "$foo\_bar"
my $foo = 1; sub change_foo { $foo = 2 }; change_foo(); [ $foo ]
my @foo = [1, sub { code; }]; \@foo
my @foo = [1, sub { ... }]; \@foo
my $foo = 1; sub get_foo { return $foo }; [ get_foo() ]
my $foo = 2 ** 20; $foo;
my $foo = 2**32; [~-$foo, -~$foo]
my $foo = 42; my $bar = \$foo; $foo = "hi"; $bar
my $foo = 42; my $bar = \$foo; $foo = "hi"; $$bar
my $foo = + + + + + + + 5;
my $foo = 5.0; [~-$foo, -~$foo]
my $foo = 5 + do { 5 }; [$foo]
my $foo = 5; $ foo;
my $foo = 5; [~-$foo, -~$foo]
my $foo = 5; my $bar = sub { $foo }; $bar->()
my $foo = 5; sub bar { $foo } bar
my $foo = 5; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say 3 }
my $foo = 5; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say 3 } else { say 4 }
my $foo = 7; my $bar = 1; say "blah" if (($foo or $bar) == 1);
my $foo = 7; my $bar = 1; say "blah" if ($foo or $bar) == 1;
my %foo = (a,1,b,2,c,3); join(', ', keys %foo); #for PSGroup53
my %foo = (a,1,b,2,c,3); join(', ', values %foo); #for PSGroup53
my %foo = (a,1,b,2,c,3); keys %foo; #for PSGroup53
my $foo = {a => bar, b => baz}; $moo = "lucky:luke"; $foo = {split ":", $moo}; $foo;
my $foo = 'a b c d'; $foo =~ s/ /\\s+/g; 'a    b    c     d' =~ s/$foo/bar/r
my $foo = 'a b c d'; $foo =~ s/ /\\s+/g; 'a    b    c     d' =~ s/$foo//r
my @foo = (["A","B","C"],["E","F"],["G","H","I","J","K"],["L"]); $#{$foo[0]}
my $foo = ('a', 'b', 'c'); say $foo #this though...
my $foo = "asdf"; open my $fh, '<', \$foo; [<$fh>]
my $foo{bar} = 1
[ my ($foo, $bar) //= (1,2) ]
my $foo = 'bar' and $foo
my($foo,$bar)=('bar','bra ann');$foo x= 5;print $foo.$bar;
my %foo = (bar => 'baz'); my @refs = \(%foo); ${$refs[0]} = 'quux'; [%foo]
my %foo = (bar => 'baz'); my @refs = \(%foo); ${$refs[1]} = 'quux'; [%foo]
[ my ($foo, $bar, $baz) = ('quux') x 3 ]
my $foo = 'ba\'r'; [ "foo '$foo'" ]
my $foo="bar"; for $foo (1..4) {}; $foo
my $foo="bar"; for $foo (1..4) {last}; $foo
my $foo = "bar"; my $baz = sub {$foo; ${"foo"}}; $baz->();
my $foo = "bar"; my $baz = sub {${"foo"}}; print $baz->();
my $foo = "bar"; print $                 foo;
my @foo; defined @foo
my @foo; exists $foo[5][3][7]; [ \@foo ]; ### It also works with arrays.
my @foo; exists $foo[5]{bar}[7]; [ \@foo ]; ### Or a mix of the two.
my %foo; exists $foo{bar}{baz}{quux}{floop}; [ \%foo ]
my @foo; [ $foo[1] != 1 ]
my %foo = foo => 1, bar => 1; sub foo { print join " ", %foo }; foo; { delete local $foo{foo}; foo }; foo;
my %foo = foo => 1; sub foo { print join " ", %foo }; foo; delete local $foo{foo}; foo;
my %foo = (foo => 2, bar => 2); sub foo { print join " ", %foo }; foo; { delete local $foo{foo}; foo }; foo;
my $foo = 'foo bar=baz big="some \"other\" thing" dumb=today'; [split / (?![^"]*?")/, $foo]
my $foo = 'foo bar=baz big="some thing" dumb=today'; [split / (?![^"]*?")/, $foo]
my $foo = 'foo bar=baz big="some thing" dumb=today'; [split / (?![^"]*")/, $foo]
my $foo =()= 'foo bar who owl scoop' =~ /oo/g; [ $foo ];
my @foo; @foo = @foo || (0..2); say "@foo"; @foo = @foo || (5..7); say "@foo"
my $foo = 'foo'; package Bar { my $foo = 'quux'; print $foo; }
my $foo = []; [ "$foo", sprintf('ARRAY(0x%x)', $foo) ]
my $foo = []; [ "$foo", sprintf('ARRAY(%#x)', $foo) ]
my %foo; $foo{zot}="asdf\n"; chomp $foo{zot}; \%foo;
my $foo = "hello"; print "haha " . $foo . " hihi";
my $foo = int 5; [~-$foo, -~$foo]
my $foo = { key => [ 2, 3, 4] }; print @$foo{key}[1]
my $foo = { key => [ 2, 3, 4] }; say @$foo{key}[1]
my $foo = map { 0, 0, 0 } "A", "B", "C", "D"
my $foo = map {; 0, 0, 0 } "A", "B", "C", "D"
my $foo = map { 42 } "A", "B", "C", "D"
my $foo = map { for (()) { } } qw(A B C) if 0;
my $foo = map { if ($_ ne "A") return 0 } "A", "B", "C", "D"
my $foo = map { if ($_ neq "A") 0 } "A", "B", "C", "D"
my $foo = map { $_ ne "A" ? 0 : () } "A", "B", "C", "D"
my $foo; my $bar;  (1 ? $foo : $bar) = "let's see"; [ $foo, $bar ]
my $foo; my $bar = []; [$foo, $bar]
my $foo = []; my $base = 0x400_0000; $base += 8 while $base < $foo; sprintf '%s %#x', $foo, $base
my $foo = []; my %hash = ($foo => 1); my $base = 0x400_0000; $base += 8 until $hash{sprintf 'ARRAY(%#x)', $base}; sprintf "found %#x in %s", $base, join(" ", keys %hash)
my $foo = {}; my $k = "dev/database/url"; my $p = \$foo; for my $n (split m{/}, $k) { $p = \$$p->{$n}; } $$p = 42; $foo
my $foo; my $ref = \$foo; $$ref = 'bar'; [ $foo ]
my $foo; my $ref = \$foo; $ref++; $$ref = '
my $foo; my $ref = \$foo; $ref++; $$ref = 'bar'; [ $foo ]
my ($foo) = "onetwothree" =~ s/(tw.)//g; $foo
my $foo = pack('V31337'); $foo;
my %foo = ('♥' => 'perllove');
my %foo = ('♥' => 'perllove'); say $foo{'♥'};
my $foo; push @{$foo->{bar}{baz}}, 123; $foo
my $foo; push @{$foo{bar}{baz}}, 123; $foo
my $foo = qr/bananas!/; qr/^$foo/
my @foo = qw(1 2 3 4); push(@foo, splice(@foo, 0, 2)); [@foo]
my @foo = qw(1 2 3 4); [ unshift(@foo, splice(@foo, 2, 2)); ]
my @foo = qw(1 2 3 4); unshift(@foo, splice(@foo, 2, 2)); [ @foo ]
my @foo = qw(1 2 3 4); unshift(@foo, splice(@foo, -2)); [ @foo ]
my @foo = qw(a 1 b 2 c 3); open my $printer, '>', \my $buffer; print $printer @foo; [$buffer, "@foo"]
my $foo = [qw/a b c d e/]; [ scalar @$foo ]
my $foo = qw/azertyuiopqsdfghjklmwxcvbn/; $foo =~ s/(.{8})\s.+?/$1/; $foo;
my %foo = qw(foo 1 bar 2 baz 3); @foo{keys %foo} = (); \%foo;
my @foo = qw(foo bar baz); [ \(@foo) ]
my @foo = qw(foo bar baz); [ \@foo ]
my @foo = qw(foo bar baz); \(@foo)
my @foo = qw(foo bar baz); [ \(@foo, 42) ]
my @foo = qw(foo bar baz); (@foo) = (@foo) x 5;
my @foo = qw(foo bar baz); (@foo) x= 5;
my @foo = qw(foo bar baz); [(@foo) x= 5];
my @foo = qw(foo bar baz); [(@foo) x 5];
my %foo = qw(foo bar baz qux kitties nip); my $ref = \%foo; undef %foo; $ref
my @foo = qw(milk nip kitties meow); my @slice = @foo[2,3,2,1]; \@slice
my @foo = split /\s+/, "foo bar"; [ [ @foo[0,0] ], [ @foo[0,1] ], [ @foo[1,1] ] ]
my $foo; sub bar { print "[$foo]"; } for $foo ("hello") { bar; }
my %foo; sub foo { print join " ", %foo }; foo; local $foo{foo} = foo; foo;
my %foo; sub foo { print join(" ", %foo }; foo; local $foo{foo} = foo; foo;
{ my $foo; sub plusfoo { $foo++ } sub getfoo { $foo } } plusfoo(); getfoo()
my $foo = sub { return $foo };
my $foo = sub { shift }; [ map $foo->($_), 1, 2, 3 ]
my $foo = sub { shift }; [ map $foo, 1, 2, 3 ]
my $foo = sub { shift }; [ map &$foo, 1, 2, 3 ]
my $foo = "test\x{327}"; $foo =~ tr/\x{327}/\x{326}/; [$foo]
(my $foo:)//= undef
my $foo ://= undef;
my $foo //= undef;
my $foo = undef; [ @$foo ]
my $foo = undef // say "it broke!"; [ $foo ]
my $found = 0; 0+($found == 7) # you pass a zero to exit, it will happily use that value
my $f = "s/l/y/g;s/k/x/g"; my $s = "lk\n"; $s = do { local $_ = $s; eval($f); $_ }; printf("%s", $s)
my $f = sub { [] }; @a = map { 0+ $f->($_) } 1..10;
my $f = sub { [] }; @a = map { 0+ $f->($_) } 1..10; \@a
my $f = sub { [] }; @a = map { refaddr $f->($_) } 1..10;
my $f = sub { SUB: my ($n) = @_; print "$n "; $n or return; @_ = $n - 1; goto SUB; }; $f->(5);
$_ = "my.funny-str is a string"; [ [split /(?=[. -])/], [split /[. -]/]
$_ = "my.funny-str is a string"; [ [split /(?=[. -])/], [split /[. -]/]]
my $gf = sub { (1..50) }; my $ev = sub { $_ % 2 == 0 }; print join ",", grep { $ev->($_) }  $gf->()
(my $good_stuff, my $throw_away) = split(“=“, $stuff);  # for comparison
my @groups; my $chunk = []; for my $x ("foo", "bar", "baz\n", "x", "y", "z") { push @$chunk, $x; if ($x =~ /\R\z/) { push @groups, $chunk; $chunk = []; } } push @$groups, $chunk if @$chunk; [ @groups ]
my @groups; my $chunk = []; for my $x ("foo", "bar", "baz\n", "x", "y", "z") { push @$chunk, $x; if ($x =~ /\R\z) { push @groups, $chunk; $chunk = []; } } push @$groups, $chunk if @$chunk; [ @groups ]
my $h = {}; [ {}, {} ]
my $h = '09:12:34'; $h =~ s/0(\d)(?=(?::\d\d){2})/$1/r;
my $h = '09'; [ $h, 0+$h ];
my %h = (a => 1); ++$_ for keys %h;
my %h = (a = 1); ++$_ for keys %h;
my %h = (a => 1); ++$_ for keys %h; \%h;
my %h = (a => 1); ++$_ for values %h; \%h;
my %hash = ( 1 => '', 2 => '', 1 => '');  \%hash
my %hash = (1 => 2, 3 => 4); my $out=''; while (my ($key, $val) = each %hash) { $out .= join ' ', keys %hash } $out
my $hash = { a=>1, b=>2 }; delete $hash->{(keys %{$hash})[0]}
my $hash = { a=>1, b=>2 }; delete $hash{(keys %{$hash})[0]}
my %hash = (a => 1, b => 2); mySub(%hash); sub mySub { my (%hash) = @_; warn join ', ', %hash }
my %hash = (a => 1, b => 2); mySub(%hash); sub mySub { my (%h) = @_; warn $h{a} }
my %hash = ( abc => 'def', asdf => 'jkl;' ); print join ' ', @hash{abc,asdf}
my %hash = ( abc => 'def', asdf => 'jkl;' ); print join ' ', @hash{abc,def}
my %hash; bless \%hash, "SomeClass";  ref \%hash;   # <== tm604: *technically* it's the referrant itself, and not the reference
my %hash; bless \%hash, "SomeClass";  ref \%somehash;   # <== tm604: *technically* it's the referrant itself, and not the reference
my %hash = (foo => !!1); $hash{foo} = 1
my %hash = (foo => [ 4 ]); $ hash { 'foo' } [ 0 ]
my %hash = (foo => "bar", baz => "bra"); use JSON::XS; encode_json \%hash
my %hash = (foo => 'bar'); (%hash)[1]
my %hash = (foo => 'bar'); (values %hash)[0];
my @hash = %hash; print @hash
my %hash; if ($hash{foo} eq $hash{bar}) { print "OMG" }
my %hash; keys %hash = 200; $hash{abc} = 1; [scalar %hash]
my %hash; my @array1 = qw/ 1 2 3 4 /; my @array2 = qw/ 3 4 5 /;    @hash{@array1,@array2} = ();   my @combined = sort keys %hash;    [ @combined ]
my %hash; my %dash = (qw/a 1 b 2/); [ scalar %hash, scalar %dash ]
my %hash; my $prior = ""; for my $new (1..1000) { ++$hash{$new}; print "$new\n" if $prior ne join " ", grep $_ != $new, keys %hash; $prior = join " ", keys %hash }
my %hash; my $str = "foo:12 bar:34 baz:45"; @hash{'foo', 'bar', 'baz'} = $str =~ /foo:(\d+) bar:(\d+) baz:(\d+)/; \%hash
my %hash; my $val1 = $hash{a}; my $val2 = $hash{b} if exists $hash{b}; [keys %hash]
my %hash = (one => [1, 2, 4]);
my %hash = (one => [1, 2, 4]); sub bar { 	my $href = shift @_; 	push @{$href->{one}}, 5; } bar(\%hash); @{$hash{one}};
my %hash = (one => [1, 2, 4]); sub bar { 	my $href = shift @_; 	push @{$href->{one}}, 5; } bar(\%hash); print @{$hash{one}};
my $hash = {one=>1,two=>2,three=>2}; [ grep $_ == 2, values %$hash ]
my $hash = {one=>1,two=>2,three=>2};[  %{$hash}{ grep $hash->{$_} == 2, keys %$hash } ] # mauke's version is much neater unless you really wanted this
my $hash = {one=>1,two=>2,three=>2};[  @{$hash}{ grep $hash->{$_} == 2, keys %$hash } ] # then as huf said, use something like this. seems a bit pointless though
my %hash = ( one => 1, two => 2, three => 3 );  [ %hash{qw(one two)} ]
my %hash = ( one => 1, two => 2, three => 3 );  [ %hash{qw(one, two)} ]
my %hash = (one => 'foo'); sub bar { my ($href) = @_; $href->{one} = 'baz'; } bar(\%hash);  [ %hash ]
my %hash = (one => 'foo'); sub bar { my $href = @_; $href->{one} = 'baz'; } bar(\%hash);  [ %hash ]
my %hash = (one => two, three => four); say for keys %hash;
my %hash = one => two, three => four; say for keys %hash;
my %hash; push @{$hash{foo}}, 3; \%hash
@{\my %hash}{qw(a b)} = (1, 2); \%hash
my $hash = {ref => [1, 2, 3]}; while(my $num = $hash->{ref}->CORE::each) {print $num, " => ";}
my $hashref = { 20001 => {} }; my ($key) = %$hashref; $key
my $hashref = { 20001 => {} }; my ($key) = %$hr; $key
my $hash_ref = { 'foo' => 'bar' }; $hash_ref{'foo'};
my $hashref = { foo => 'bar' }; my $doesntwork = $#$hashref;
my $hash_ref = {'one' => 'falcom', 'two' => 'rindolf'}; my $d = { %$hash_ref, 'three' => "Isaac Newton"}; [$d]
my %hash; scalar %hash
my %hash = (thing => SOME_CONSTANT() ); sub SOME_CONSTANT { 5 }; $hash{thing}
my %hash = (thing => SOME_CONSTANT); sub SOME_CONSTANT { 5 }; $hash{thing}
my %hash = (x=>123); %hash = (); \%hash
my %h = (a..z); ${%h}{"how strange"} = "is this, anyway?"; \%{%h};
my %h = (a..z); ${%h}{"ignore the man"} = "behind the curtain"; print scalar %h; undef $h{$_} for 1..20; print scalar %h;
my %h = (a..z); ${%h}{"ignore the man"} = "behind the curtain"; undef $h{$_} for 1..20; \%{%h};
my %hb = (a => 'bleh', b => 'bluh'); my %ha = (a => 'woo', x => 'y', %hb); \%ha;
my @headers = qw(foo bar ibytes pickles);
my @headers = qw(hits bytes ihits ibytes ips);
my %h = (); exists $h{foo}->{bar}; print exists $h{foo}
my $hex = q{6060FF}; [ hex($hex), [ unpack q{L>*}, pack q{H*}, map { sprintf q{%08s}, $_; } ( $hex =~ s!^0x!!r) =~ m!(^.{2,6}|.{2,8})!g ] ]; ### How to do what hex() does with pack/unpack. Is there a cleaner / less-hackier way?
my $hex = q{6060FF}; [ hex($hex), [ unpack q{L>*}, pack q{H*}, map { sprintf q{%08s}, $_; } ( $hex =~ s!^0x!!r) =~ m!(^.{2,6}|.{2,8})!g ] ]; How to do what hex() does with pack/unpack. Is there a cleaner / less-hackier way?
my $hex = q{6060FF}; [ hex($hex), [ unpack q{N*}, pack q{(h8)*}, $hex ] ];
my $hex = q{6060FF}; [ hex($hex), [ unpack q{N*}, pack q{(H8)*}, $hex ] ];
my $hex = q{6060FF}; [ hex($hex), [ unpack q{N}, pack q{H8}, q{6060FF} ] ] # How to do the equivilent of hex() with pack/unpack functions?
my $hex = q{6060FF}; [ hex($hex), [ unpack q{N}, pack q{H*}, q{6060FF} ] ] # with H* it is only three bytes and apparently rejected by V/N/I/L
my $hex = q{6060FF}; [ hex($hex), [ unpack q{V*}, pack q{(h8)*}, $hex ] ];
my $hex = q{6060FF}; [ hex($hex), [ unpack q{V*}, pack q{(H8)*}, $hex ] ];
my $hex = unpack("H*", pack("Q<", 1397463445)); my $td = pack("H*", unpack("Q<",$hex)); $td;
my $h = { foo => 42 }; $h == \%{$h}
my %h = ( foo => { bar => {ber => [boor] } } ); my $ar = $h{foo}{bar}{ber}; push @$ar, 'foor';  \%h
my $h = {}; [ "$h" ]
my %h = +{}; \%h
 my %h; @h{(20..34)} = (); [(sort keys %h)[0..10]];
my %h=(); %h=( 'a'=>'1', 'b'=>'2' ); %h=( 'c'=>'3', 'd'=>'4' ); for ( sort keys %h ){ print "$_ $h{$_}" };
my %h; @{ $h{a}{b} } = qw/c d e/; \%h
my $h = "Hello world!"; $h =~ s/(.)(.)/$2$1/g; $h
my $h = "Hello world!"; $h =~ s/(.)(.)/\U$2\E$1/g; $h
my %h=(); %h=getone(); sub getone {return ('a'=>'1','b'=>'2')}; %h=gettwo(); sub gettwo { return('c'=>'3','d'=>'4')}; for ( sort keys %h ){ print "$_ $h{$_}" };
my %h=(); %h=getone(); sub getone {return ('a'=>'1','b'=>'2')}; %h=gettwo(); sub gettwo { return undef}; for ( sort keys %h ){ print "[$_] $h{$_}" }
my %h=(); %h=getone(); sub getone {return ('a'=>'1','b'=>'2')}; %h=gettwo(); sub gettwo { return undef}; for ( sort keys %h ){ print "$_ $h{$_}" }
my %h=(); %h=getone(); sub getone {return ('a'=>'1','b'=>'2')}; %h=gettwo(); sub gettwo { return undef}; for ( sort keys %h ){ print "$_ $h{$_}" };
my $h = {}; [ $h, $h ]
my %h=(); %h=(%h, 'a'=>'1', 'b'=>'2' ); %h=(%h, 'c'=>'3', 'd'=>'4' ); for ( sort keys %h ){ print "$_ $h{$_}" };
my $h; $h->{key}[2]{anotherkey} = "hello"; $h
my %h=(); %h={return ('a'=>'1','b'=>'2')}; %h={ return('c'=>'3','d'=>'4')}; for ( sort keys %h ){ print "$_ $h{$_}" };
my %h; $h{two} = sub { \%h }; $h{two}->()->{two}->()
my %h; $h{x}{y}{z} = 123; \%h # sure
my %h = (map { $_ => 2*$_ } 1 .. 10); [ %h{3,5,8} ]
my %h = (map { $_ => 3*$_  } 1.. 10); { %h{(1,4,6)} }
my %h = (map { $_ => 3*$_  } 1.. 10); +{ %h{(1,4,6)} }
my %h; my $p = \%h; $p = $p->{$_} //= {} for qw/foo bar bizbaz/; $p->{cats} = 1; [ \%h ]
my %h = (one => [1,2,4]); sub bar { my ($href) = @_; push ${$href->{one}}, 5; } bar(\%h); @{$h{one}}
my %h = ( one => 1, two => 2 ); [ %h{qw( one three )} ]
my %h = qw/foo bar baz ber/; say $h{foo}; my $x = 'baz'; say $h{$x}
my %h = qw(must 1 should 2 could 3); [ sort {$h{$a} <=> $h{$b}} qw(must should could could must could should must) ]
my $hr = {a => 5}; my @arr; push @arr, %$hr; my %hash = @arr; \%hash
my $hr = {a => 5}; my %hash; $hash{hashref}=$hr; $hash{hashref}{a}
my $hr = { asdf => 5 }; (%$hr)[1]
my $hr = { asdf => 5 }; (values %$hr)[0]
my $href = { foo => 42, bar => 37 }; keys %$href - 3
my $href = { foo => 42, bar => 37 }; keys(%$href) - 3
my $href; %$href
my $href; $href->{key} = {}; my $other = $href->{key}; $other->{bar} = 1; $href
my $href; my $other = $href->{key} ||= {}; $other->{bar} = 1; $href
my $hr = {searchable => {phones => "bullshit"}}; unless ($hr->{searchable}->%*) { "Empty" } else { "not empty" };
my $hr = {searchable => {}}; unless ($hr->{searchable}->%*) { "Empty" } else { "not empty" };
my $html = "<html><body><div>and stuff</div></body></html>"; $html->find
my $hw = "Hello World!\n"; print $hw;
my %h = (x => "abc123", y => "def456"); map { tr/a-z//dc } values %h; \%h
my %h = (x => "abc123", y => "def456"); tr/a-z//dc for values %h; \%h # are you trying to do something like this
my $i = 0; HERE: { HERE: { HERE: { HERE: goto HERE unless $i++ > 3 } } }  print $i
my $i = 0; while ( $i <= 10) { print; $i++; } print $_;
my $i = 0; while ( $i <= 10) { print; } print $_;
my $i = 5; ++$i++
my @ids = $page_content =~ m!http://www\.liveleak\.com/view\?i=(\w{14})!g;
my $idx = 0; my @group; push @{$group[/\R$/ ? $idx++ : $idx]}, $_ for  "foo", "bar", "baz\n", "x", "y", "z"; \@group # something like that?
my $imagecount = ""; my $foo = "%0" . length $imagecount . "d";
my $i; { my $foo; sub get_foo { $foo //= $i++ } } [get_foo, get_foo, get_foo]
my @in = 1..3; my @out = grep { $_++ } @in; [ \@in, \@out ] # far as I recall, List::UtilsBy has an explicit local $_ = $_; to avoid this sort of behaviour, so presumably ::XS doesn't have an equivalent
my $indents = () = "        " =~ /(\t|\s{4})/g
my @index; $_ = "  * *    * ** "; while(/\G[^*]*\*/gc) { push @index, pos } \@index
my $ind = index(fc 'test string', fc 'STRING'); $ind;
my $ind = index('test string', 'STRING'); $ind;
my $input = '٣'; say $input + 42;
my @input = map pack('H2', $_), qw(02 02 01 11 48 85 03 86 11 FB FF 42 01 00 00 08 00 00 00 00 00 00 00 86); [ join ' ', map sprintf("%08x", unpack('N1', $_)), join('', @input) =~ /..../g ] # you're asking for this?
my $input = "Number 123 here won't be matched, but <number 666, the number of the beast> will."; my $match_mode = 0; while ($input =~ /(\d+)|(<)|(>)/g) { if ($1 and $match_mode) { print $1; } if ($2) { $match_mode = 1; } if ($3) { $match_mode = 0; }}
my $input = "Number 666 will match, but not <number 123 here>, ok?"; my $match_mode = 1; while ($input =~ /(\d+)|(<)|(>)/g) { if ($1 and $match_mode) { print $1; } if ($2) { $match_mode = 0; } if ($3) { $match_mode = 1; }}
my $ip = '127.0.0.1'; $ip =~ s#(\d+)#unpack( "H*", pack( "V1",$1))#ge; $ip
my $ip = '127.0.0.1'; $ip =~ s#(\d+)#unpack( "H*", pack( "V1",$1))#ge; $ip =~ s#.##g; $ip
my $ip = '127.0.0.1'; $ip =~ s#(\d+)#unpack( "H*", pack( "V1",$1))#ge; $ip =~ s#.#g; $ip
my $ip = '127.0.0.1'; $ip =~ s#(\d+).?#unpack( "H*", pack( "v",$1))#ge; $ip
my $i; sub get_foo { state $foo = $i++ } [get_foo, get_foo, get_foo]
my $karma = 27; sub mst :() :lvalue { $karma } mst++; $karma
my $karma = 27; sub mst :lvalue { $karma } mst++; $karma
my $karma = 27; sub mst() :lvalue { $karma } mst++; $karma
my $karma = 27; sub mst :lvalue { $karma } mst()++; $karma # actually, might just be this?
my $key = 'a'; $hash{$key} = 'foo'; print $hash{$key};
my @keys = (1..10); ++$_ for @keys; \@keys
my $L = 2**32; join "", reverse split //, ((reverse $L) =~ s/(\d{3})/$1,/rg);
my $L = 2**32; local $\ = ','; print for reverse unpack '(A3)*', scalar reverse $L
my $L = 2**32; local $\ = ','; print reverse unpack '(A3)*', scalar reverse $L
my $L = 2**32; $L =~ s/(?<=\d)(?=(?:\d{3})+(?!\d))/,/rg
my $L = 2**32; $L =~ s/\d\K(?=(?:\d{3})+(?!\d))/,/rg
my $l = 2**32; my $s = join "", reverse split //, $l; $s =~ s/(\d{3})/$1,/g; join "", reverse split //, $s
my $L = 2**32; reverse reverse($L) =~ s/(\d{3})/$1,/rg
my $L = 2**32; scalar reverse join ',', unpack '(A3)*', scalar reverse $L
my $l = 4; "stuff" . ( $l + 1 );
my $l = 4; "stuff" . $l + 1;
my $lambda = sub { shift()+1 }; @a=1..4; [{map{$_=>$lambda->($_)}@a[0..@a/2-1]},{map{$_=>$lambda->($_)}@a[@a/2..$#a]}]
my $last; [ map { $last = $_ // $last } ( 123, 456, undef, undef, undef ) ]
my $last; [ map { $last = $_ // $last } qw[ 123, 456, undef, undef, undef ] ]
my $lengths = { mach => 5 }; "%-$lengths->{mach}s" # you want this, right?
my $line = "COMP2711|3713452|Warren, Ahmad|3645/2|M"; $line =~ s/\|(.+), (.+)\|/$2$1/; print $line;
my $line = "COMP2711|3713452|Warren, Ahmad|3645/2|M"; print $line;
my $line = "if answer > 0: answer = answer + 2"; if(0) { } elsif($line =~ /^\s*if (.*): (.*)/) { print "1 => $1, 2 => $2" }
my $line = "take cat";  my ( $verb, @others ) = split m/\s+/, $line;  "The verb is <$verb> and the other arguments are <@others>"
my @list = map do { my $x = $_; sub { 3 * $x } }, qw(2 4 6); [ map $_->(), @list ] # sometimes putting the closure inside do {} can make the intention clearer
my @list = qw(foo bar foo baz kitties meow); 3 + @list
my @list = qw(foo bar foo baz kitties meow); my %hash = @list; \%hash
my @l = qw/2 4 6/; my @f; for ( my $i=0; $i<@l; $i++ ) { my $x = $l[$i]; push @f, sub { 3 * $x; }; } [ map { $_->(); } @f ];
my @l = qw/2 4 6/; my @f; for ( my $i=0; $i<@l; $i++ ) { push @f, sub { 3 * $l[$i]; }; } [ map { $_->(); } @f ];
my @l = qw(foo1 foo2 foo3); my $foo1 = \ $l[0]; $$foo1 = 'some foo1 string'; \@l
my %map = (param1 => 'cats', param2 => 'botje'); my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \{ ([^{]+) \}/push @params, $2; $1 . 's'/gex; printf $str, map {$map{$_}} @params
my ($mapped, $grepped); map { $mapped = wantarray } 1; grep { $grepped = wantarray } 1; [$mapped, $grepped]
my %map = ('\t' => "\t", '\r' => "\r", '\n' => "\n"); my $x = q{FOO\tBAR\r\n}; my $y = s/(\\[trn])/$map{$1}/ge; [$x, $y]
my %map = ('\t' => "\t", '\r' => "\r", '\n' => "\n"); my $x = q{FOO\tBAR\r\n}; my $y = s/(\\[trn])/$map{$1}/gre; [$x, $y]
my %map = ('\t' => "\t", '\r' => "\r", '\n' => "\n"); my $x = q{FOO\tBAR\r\n}; my $y = $x =~ s/(\\[trn])/$map{$1}/gre; [$x, $y]
my @matches = "foobarbaz" =~ /(ba.)/g; \@matches
my $meth = sub { 'here' }; main->$meth
my $meth = sub { 'here' }; notmain->$meth
my $meth = sub { 'here' }; undef->$meth
my @m; push @m, $1 ? [ digit => $1 ] : [ space => $2 ] while "foo 3 5 1 7 bar" =~ m/(\d+)|(\s+)/g; \@m
my $my->{my}
my (my (my $delilah))
my My $my :Delilah;
my (my $x)
my $n = 0; while(1){print $n." "; $n = $n+1;}
my $n = 0; while($n < 99999){print $n." "; $n = $n+1;}
my $n = 20; my $t = 0; my @c; while ($n) { push @c, 1 << $t if $n & 1; $n >>= 1; $t++; } \@c
my $n = 3; my $str = q(|1|2a|3abc|4abcd|5abcde); [join q(|), (split /\|/, $str)[0..$n]];
my $name = "nonconvergent"; my $s = "Hello $name - what's up?"; [$s]
my @names = qw(one two three); my @numbers = qw(1 2 3); for(0..$#numbers) { print $numbers[$_] . ' - ' . $names[$_] if $numbers[$_] == 2} # one option is to iterate by index rather than element
my $name = 'xx.xx.xx.xx'; $name =~ s/\./_/g; $name
my %notes = qw/0 C 2 D/; [ @notes{0,2} ]
my $not_really_an_array = ("a", "b"); $not_really_an_array # no arrays here
my $now = Time::Moment->now;  $now->with_hour(op)->with_minute(0)->with_second(0);
my $n=split(/\|/,"one|two|three|four");
'my $num = 10; my  $res = ($num > 15 and $num < 30) ? "Num is out of range" : "Num is in range"; print $res ."\n";'
my $num = 10; my  $res = ($num > 15 and $num < 30) ? "Num is out of range" : "Num is in range"; print $res ."\n";
my $num = 42; my @array = (1, 2, DateTime->now); $num ~~ @array
my $num = 42; my @array = (1, 2, qr/2$/); $num ~~ @array
my $num = 42; my @array = (1, 2, sub { die "wat" }); $num ~~ @array
my $num = 50; my $bitstring = unpack 'b*', $num;
my $num = 50; my $bitstring = unpack 'B*', $num;
my $num = "99839489327429485246"; $num =~ tr/89/01/; oct $num
my $number = grep { $_ == 2 } (1, 2, 2, 2, 3); $number
my $obj = "azertyu iopqsdfghjklmwxcvbn"; $obj =~ s/(.{8})\s.+?/$1/; $obj;
my $obj = "azertyui opqsdfghjklmwxcvbn"; $obj =~ s/(.{8})\s.+?/$1/; $obj;
my $obj = "azertyui opqsdfghjklmwxcvbn"; $obj =~ s/(.{8})\s[^\n]+/$1/; [$obj;]
my $obj = "azertyui opqsdfghjklmwxcvbn"; $obj =~ s/(.{8})\s[^\n]+/$1/; [$obj]
my $obj = bless {};  ($a, $b, $c) = ($obj) x 3; [$a, $b, $c]
my %old = (1..10); +{ %old{1,5,7} }
my %old_hash = (1 => 2, 3 => undef); my %new_hash = reverse %old_hash; \%new_hash
my %old_hash = (1 => 2, 3 => undef); my %new_hash = reverse %old_hash; %new_hash
my $one = "1"; my $two = $one + "0 but true"; [ $one ^ $one ];
my $one = 1; my $two = $one . " used as a string?"; [ $one ^ $one ];
my $one = "1"; [ $one ^ $one ];
my $one = 1; [ $one ^ $one ];
my @one = qw(1 2 3); @one = (); my @two; @two = (); [ (defined(@one) ? 'defined' : 'undef'), (defined(@two) ? 'defined' : 'undef') ]
my $optional = 1; my $alternative = 1; print (["", "Optional.", "Alternative.", "Optional and alternative."]->[($alternative ? 2 : 0) + ($optional ? 1 : 0)])
my $orig = 'abcdef'; my $str = $orig =~ s/(cde)//r; my $removed = $1; [$orig, $str, $removed]
my $orig = $SIG{__WARN__}; local $SIG{__WARN__} = sub { my $warn = shift; $warn =~ s/ at /!!!/g; local $SIG{__WARN__} = $orig; warn $warn }; warn 'lemmings' # could just double-local it
my (our $x);
my @out; { local our @tmp; 'abcdefghi' =~ /c(?:(.)(?{ local @tmp = (@tmp, $^N) })){4}(?{ @out = @tmp })/ or die } \@out
my @out; { local our @tmp; 'abcdefghi' =~ / (?:(.)(?{ local @tmp = (@tmp, $^N) })){4}(?{ @out = @tmp }) (?= $ ) /x or die } \@out
my @out; { my $tmp = []; 'abcdefghi' =~ /c(?:(.)(?{ local @$tmp = (@$tmp, $^N) })){4}(?{ @out = @$tmp })/ or die } \@out
my @out; { our @tmp; 'abcdefghi' =~ /c(?:(.)(?{ local @tmp = (@tmp, $^N) })){4}(?{ @out = @tmp })/ or die } \@out
my @packets = qw(foo=ba r=baz= quux =teeen); my @chunks; my $prev = ''; for my $part (@packets) { my @pieces = split /=/, $part, -1; $pieces[0] = $prev . $pieces[0]; $prev = pop @pieces; push @chunks, @pieces; } push @chunks, $prev; \@chunks
my $p = \&CORE::print; $p->("foo")
my $pi = atan2(0, -1); my $x = $pi; [ $pi, map { $x *= 1e10; ($x - int $x)*1e10;  } 1..10 ]
my $pi = atan2(0, -1); $pi *= 1e10; [ int $pi, $pi - int $pi ]
my $pi = atan2(0, -1); $pi *= 1e20; [ int $pi, $pi - int $pi ]
my %pool = (param0 => 'a', param1 => 'b'); [ map { $pool{$_} } 'param1', 'param0' ]
my %pool = (param0 => 'a', param1 => 'b'); [ @pool{'param1', 'param0'} ]
my %pool = qw(param0 altreus param1 cats); my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \{ ([^{]+) \}/push @params, $pool{$2}; $1 . 's'/gex; printf $str, @params
my %pool = qw(param0 altreus param1 cats); my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \{ ([^{]+) \}/push @params, $pool{"param$2"}; $1 . 's'/gex; printf $str, @params
my $pos = 3; my $ref = '1'; my $seq = [qw(a b c d e f g h i j)]; join '', @{$seq}[($pos - 1)..(($pos-2) + length($ref))] # off by 2, I think?
my $p = "(part1).*(part2)"; "foopart1barpart2" =~ /$p/; print "$1 $2";
my $prev; for my $cur ("A" .. "D") { print "($prev $cur) "; } continue { $prev = $cur; }
my $_ = q,asdf "foo"='bar baz',; my $h = 0x20000; my %h; s/((["'])(?:[^"']+|\\.|(?!\2).)*\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split ' '; $h = chr($h-1); s/([\x{20000}-$h])/$h{$1}/g for @words; \@words;
my $_ = q, echo foo bar=baz hmm="1 2 3" nn='aa bb',; my $h = 0x20000; my %h; s/((["'])(?:[^"']+|\\.|(?!\2).)*\2)/$h{chr $h}=$1;chr($h++)/ge; my @words = split /\s+/; $h = chr($h-1); s/([\x{20000}-$h])/$h{$1}/g for @words; \@words;
my qw( $foo ); $foo = 123; $foo; ### Why does this not work?
my $r = bless [], "HASH";  ref $r
my @rc; my @vals = ('a','b','c'); (0 ? @rc : $rc[0]) = @vals; \@rc
my @rc; my @vals = ('a','b','c'); 0 ? @rc : $rc[0] = @vals; \@rc
my @rc; my @vals = ('a','b','c'); (1 ? @rc : $rc[0]) = @vals; \@rc
my @rcolors = ("red", "orange", "color green"); my $count = 0; for (@rcolors) { last if /color green/; } continue { $count++; } $count; # seems unlikely
my $r = \&CORE::ref; $r->([])
my $readfromfile = '[x'; my $re = eval { qr/$readfromfile/; 1 } or die 'failed'; [ $re ]
my $re = 'asdf'; ['asdfasdf' =~ /^\Q$re\E.*$/]
my $re = 'asdf\E.*'; ['asdfasdf' =~ /^\Q$re$/]
my $records = { foo => "bar", baz => "quux" }; s/./moo/g for values %$records; $records
my $recurse = sub { ref ? __SUB__->($_) : say for values $_[0] }; $recurse->({x => 123, y => [qw(a b c)]}) # this
my ($red, $green, $blue) = (100, 100, 100); sprintf '#%02x%02x%02x', $red, $green, $blue;
my $ref = [1,2,3,4]; for my $item (@$ref) { print $item, "\n" }
my $ref = [1,2,3]; push @{$ref}, "hi"; $ref
my $ref = { 1 => foo => 2 => bar => 3 => baz => 4 => quux => 5 => 'floop' }; %{ $ref } = %{ $ref }{ (reverse sort keys %$ref)[0 .. 2] }; $ref # joobie
my $ref = \42; ${$ref} = "hi";
my $ref = [[8],[9],[10]]; @{$ref}[0,1,2]->[0]
my $ref = [[8],[9],[10]]; @{$ref}[0,1,2][0]
my $ref = do { \ my $foo; }; ref $ref
my $ref = \&foo; $ref->(21);  sub foo { $_[0] * 2 }
my $refName = [ 'one', 'two', 'three', 'four', 'five' ];  my @slice = (1,3);  my @values = @{$refName}[@slice];  \@values
my $refName = [ 'one', 'two', 'three', 'four', 'five' ];  my @values = @{$refName}[1,3];  \@values
my $ref = [ qw/ a b c / ]; [ @{ $ref }[1,2] ]
my $ref = [qw/foo bar baz/]; for $i (keys $ref) { print "$i "; }
my $re = "motd \\^(.*)"; [ map /$re/, 'motd ^something' ] # vs. /motd \^/
my @replacements = (['foo', 'bar', 'baz'], ['quux']); $replacements[0][0]
my $re = '/projects/test/(.*)'; [ "/projects/test/vkAuth?code=edb31139a2f04d22a8" =~ $re ]
my $re = '/projects/(\w+)/(.*)'; [ "/projects/test/vkAuth?code=edb31139a2f04d22a8" =~ $re ]
my $re = '/projects/(\w+)/test/(.*)'; [ "projects/test/vkAuth?code=edb31139a2f04d22a8" =~ $re ]
my $reps = 0; my $start = time; 1 while $start==time;++$start; { my $y = index( pack('C*', map rand(128), 1..1e5), "\\x" ); ++$reps; redo if $start == time }; [ $reps ]
my $reps = 0; my $start = time; 1 while $start==time;++$start; { my $y = pack('C*', map rand(128), 1..1e5) =~ m/\\x/ ); ++$reps; redo if $start == time }; [ $reps ]
my $reps = 0; my $start = time; 1 while $start==time;++$start; { pack('C*', map rand(128), 1..1e5) =~ m/\\x/; ++$reps; redo if $start == time }; [ $reps ]
my $reps = 0; my $start = time; { my $y = index( pack('C*', map rand(128), 1..1e5), "\\x" ); ++$reps; redo if $start == time }; [ $reps ]
my $re = qr/[[]/
my $re = qr/ blah \n | \n blah1 \n | \n yada/x; print "Failed\n" if 'testing' =~ $re
my $re = qr/^To: .*helpme\@mydomain.com/; 'To: Some person<helpme@mydomain.com> lalala' =~ $re ? "Match" : "No match"
my $re = qr/(?<!x)(x+)(??{ my $len = length $1; "y{$len}" })(?!y)/; [ map { scalar $_ =~ $re } qw(xxyy xxy xyy) ]
my @res = map { chomp; $_ if (-f $_) } qw(dupes.txt allfiles.bak.txt hahaha.setnhue); print join(' ', @res) . "\n";
my ($result) = "a numeric example: 42" =~ /(\d+)/; $result # note the lack of \
my $result = do { "my string" for 1 .. 8 };  [$result]
my $result = do { "my string" for 1 .. 8 };  $result
my $result; if (0) { $result = "if"; } elsif (1) { $result = "elsif"; } else { $result = "else"; } [$result]
my $result = sprintf '%.28f', '1.43531262539073e-11'; { local $/ = '0'; 1 while chomp($result) } $result # let perl work it out
 my $result = sub { my $str = "foo:12 bar:34 baz:45"; $str =~ /foo:(?<foo>\d+) bar:(?<bar>\d+) baz:(?<baz>\d+)/; return \%+ }->(); 'x: 78' =~ /\w+: (?<whatevs>\d+)/; +{ %$result } # yeah, you'll just get the results from whichever regex is in the current scope
my $ret = my ($x, $y) = 1..10; [ $ret, $x, $y ];
my $ret = my ($x, $y) = 9..19; [ $ret, $x, $y ];
my $ret = my ($x, $y, @z) = 9..19; [ $ret, $x, $y, \@z ]; # For those wondering, the right way to grab the rest of the elements.
my $ret = my @z = my ($x, $y) = 9..19; [ $ret, $x, $y, \@z ];
my $return = print "hello, here is my message";   $return
my @rocks = qw (granite rubble lava slate); [ grep { $rocks[$_] =~ /a/ } 0..$#rocks ]
my %roman; sub r :lvalue { $roman{$_[0]} }  ( r("I"), r("II"), r("III"), r("IV"), r("V") ) = 1..5;  \%roman
my %s = (1,2,3,4,5,6); my $pre = %s; delete @s{keys %s}; [$pre, scalar %s]
my %s = (1,2,3,4,5,6); %s+1
my %s = (1,2,3,4,5,6); scalar keys %s
my %s = (1,2,3,4,5,6); [ scalar %s, 0+%s, 0+keys %s ]
my %s = (1,2,3,4,5,6); [ scalar %s, 1+%s, 0+keys %s ]
my $s = "1,2,3,4,5"; join "-", split ",", $s, 3;
my $s1 = q#([A-Z]+)# ; my $s2 = q#([a-z]+)#; my @foo = ("HELLO-hi" =~ /$s1-$s2/); [@foo]
my ($s1, $s2) = qw/abc abx/; my $prefix = ($s1 ^ $s2) =~ /\A(\0*)/ ? substr($s1, 0, length $1) : ''; $prefix
my $s = "3 5 1 7 ";  my @m = $s =~ /^(?:(\d)(\s))+$/g; \@m;
my $s = "3 5 1 7 ";  my @m = $s =~ /^(?:(\d)(\s))+$/; \@m;
my $s = "aabaaaaaaaaaaaab"; @x = /(a++b)/; [@x]
my $s = "abcdefghijklmnopqrstuvwxyz"; $s =~ tr/a-e/A-E/; [$s]
my $s = 'ABC'; $s =~ s/([A-Za-z])/join '', map chr(ord ^ 32), split '', $1/ge; $s   # pretty, portable, uses s//, what's not to like?
my $s = "A#B"; $s =~ s/[#]//; [ $s ]
my $scalar = [1,2,3]; "$scalar"
my $scalar = [1,2,3]; $scalar
my $scalar_ref = \\\1; $$$$scalar_ref
my $search = "hot chicks"; $search =~ tr/ /%20/; print $search
my $search = "hot chicks"; $search =~ tr/hot/123/; print $search
my $search = "hot chicks"; $search =~ tr/ /+/; print $search
my $search_path = "ILMT::HIN::PAN"; [ grep /^${search_path}::[^:]+$/, "ILMT::HIN::PAN::UTF2WX" ]
my $search_path = "ILMT::HIN::PAN"; [ grep /^${search_path}::[^:]+$/, "ILMT::HIN::PAN::UTF2WX::UTF2WX" ]
my $sec=3982; strftime '%H:%M:%S', gmtime $sec # slightly less typing, also less control over formatting
my %seen; my $i = 0; $seen{$_} = ++$i for 'one','two','three'; \%seen
my %seen; my $i = 0; $seen{''} = ++$i; \%seen
my %seen; $seen{''} = 123; print $seen{''};
my %seen; $seen{foo} // 1; \%seen
my %seen; $seen{foo}; $seen{bar}; \%seen
my %seen; $seen{''} //= keys(%seen)+1; print $seen{''}."\n";
my %seen; $test="one"; $seen{$test} //= keys(%seen)+1; print $seen{$test};
my %seen; $test="one"; $seen{$test} //= keys(%seen); print $seen{$test};
my %seen; $test="one"; $seen{$test} = [keys(%seen)]; \%seen
my %seen; $test="one"; $seen{$test} //= [keys(%seen)]; \%seen
my ( $self ) = @_;
my ( $self ) = $_;
my $self = bless {}; $self->goats();
my $self = +{}; $self->{messages} = [1,2,3]; $self->{messages}->[0] = "a"; $self->{messages}
my $sentence = " I saw the the router."; [$sentence =~ /([a-zA-Z]+)\s+\1/]
my @sets_list1 = (4,5,6); [ (map [ $_ ], @sets_list1), (map [ @sets_list1[0..$_] ], -1..$#sets_list1) ];
my $s = "foo 3 5 1 7 bar";  my @m = $s =~ /(?:(\d)(\s))/g; \@m;
my $s = "foo 3 5 1 7 bar";  my @m = $s =~ /(\d)(\s)/g; \@m;
my $s = "foo 3 5 1 7 bar";  my @m = $s =~ /(?:(\d)(\s))/g; \@m;  # JQKP
my $s = "foo 3 5 1 7 bar";  my @m = $s =~ /(?:(\d)(\s))/g; \@m; # wasn't your earlier example already capturing what you wanted?
my $s = "foo 3 5 1 7 bar";  my @m = $s =~ /(?:(\d)(\s))/g; say join "|", @m;  # JQKP
my $s = "foo\r\nbar\r\nbaz\r\n"; $s =~ s/\R(?=.)//g; [ $s ];
 my ($sha) = split(' ', readpipe("sha1sum", $filename));
my $s = "Hello (hey) My name is (rindolf)."; $s =~ s/\([^)]*\)//g; [$s]
my $s = "Hello.label"; if (my ($m) = $s =~ /^(.*)\.label$/) { print "Matched <$m>\n"; }
my $s = "Hello" [ref($s)]
my $s = "Hello"; [ref($s)]
my $s = "Hello"; [($s eq "Good" or "Way")]
my $s = "Hello"; $s .= " rrman!"; [$s]
my $s = "      Hello"; $s =~ s/^\s//; [$s]
my $s = "      Hello"; $s =~ s/^\s+//; [$s]
my $s = "hello world <120423424> one two three"; $s =~ s/\A((?:\S+\s+){2})<([0-9]+)>/$1$2/; [$s]
my $s = "hello world <120423424> one two three"; $s =~ s/\A(?:\S+\s+){2}\K<([0-9]+)>/$1/; [$s]
my $s = "Hello World"; $s=~ /Wor/; [$`]
my %sieve; my @primes = (2,3); my ($p_i, $p, $q, $n)=(1,3,9,3); push @primes, do { { $n += 2; if ( my $s = delete $sieve{$n} ) { push @{$sieve{$n + $_}}, $_ for @$s; redo } elsif ( $n < $q ) { $n } else { push @{$sieve{$q + $p*2}}, $p * 2; $p = $primes[++$p_i]; $q = $p*$p; redo } } } until @primes >= 1000; \%sieve;
my %sieve; my @primes = (2,3); my ($p_i, $p, $q, $n)=(1,3,9,3); push @primes, do { { $n += 2; if ( my $s = delete $sieve{$n} ) { push @{$sieve{$n + $_}}, $_ for @$s; redo } elsif ( $n < $q ) { $n } else { push @{$sieve{$q + $p*2}}, $p * 2; $p = $primes[++$p_i]; $q = $p*$p; redo } } } until @primes >= 100; \@primes;
my %sieve; my @primes = (2,3); my ($p_i, $p, $q, $n)=(1,3,9,3); push @primes, do { { $n += 2; if ( my $s = delete $sieve{$n} ) { push @{$sieve{$n + $_}}, $_ for @$s; redo } elsif ( $n < $q ) { $n } else { push @{$sieve{$q + $p*2}}, $p * 2; $p = $primes[++$p_i]; $q = $p*$p; redo } } } until @primes >= 100; \%sieve;
my $s = "llama"; [ map { substr($s, $_).substr($s, 0, $_) } 0..4 ]
my $s; my $c = sub { warn $s }; for $s (1,2,3) { $c->(); }
my @some_array = qw/0 1 2 3 4 5 6 7 8 9 10/; my (@primes, $zero) = @some_array[2,3,5,7,0]; print "@primes%"; print !defined $zero;
my $s = "<One> Two <Three> Four <Five>"; [$s =~ /<([^>]+)>/g]
my $s = "one.two.three"; my $count = $s =~ tr/././; [$count]
my $space = 15; printf("... %-${space}s => %s", "foo", "bar");
my $space = 15; printf("... %${space}s => %s", "foo", "bar");
my $space = 15; printf("... %s%${space}s => %s", "foo", "", "bar");
my $s = q{abc}; [ $s =~ /(?:abc(foo|bar|baz)|)/ ]; # anno, seems it does returns undef.
my $s = q{abc}; [ $s =~ /(?:abc(foo|bar|baz)|)/ # anno, seems it does returns undef.
my $s = q{foo=bar=baz}; my $p = qr/=(.*?)=/; my $r = q{,$1,}; $s =~ s/$p/$r/re;
my $s = q{foo=bar=baz}; my $p = qr/=(.*?)=/; my $r = q{,$1,}; $s =~ s/$p/$r/ree;
my $s = q{foo=bar=baz}; my $p = qr/=(.*?)=/; my $r = q{",$1,"}; $s =~ s/$p/$r/ree
my $s = q{foo=bar=baz}; my $p = qr/=/; my $r = ','; $s = s/$p/$r/;
my $s = q{foo=bar=baz}; my $p = qr/=/; my $r = ','; $s = s/$p/$r/r;
my $s = q{foo=bar=baz}; my $p = qr/=/; my $r = ','; $s =~ s/$p/$r/rg;
my sql $db: cool cool
my $s = qq{ 0xFF }; [ 0+$s ];
my $s = qq{ 1234.5 }; [ 0+$s ];
my $s = qq{Hello "World"!}; [$s]
my $s = 'some text'; my $f = 's/x/s/g; s/o/a/g;'; eval $f for $s; $s # if you want to limit the scope... why is there a string eval involved anyway
my $_ = "☃"; s/(.)/sprintf('\\u%04x', ord "$1")/ger
my $s = sub { "x${_}y" }; join '-', map $s->(), 1..3;
my (state $foo)
{ my $state_var sub function_that_uses_state_var { ... } }
{ my $state_var; sub function_that_uses_state_var { ...; } }
my $str = "001.html"; my @pats = (qr/^\d\d\d\.html/); print "fail" unless $str ~~ @pats;
my $str = "001.html"; my @pats = (qr/\d\d\d\.html/); print "fail" unless $str ~~ @pats;
my $str = "001.html"; my @pats = (qr/\d\d\d\.html); print "fail" unless $str ~~ @pats;
my $str = "001.html"; my $re = qr/^\d\d\d\.html/;  $str =~ /$re/ ? "ok" : "fail"
my $str = "\0"; [ $str ]
my $str = '123456'; substr $str, -2, 0, ','; $str
my $str = "123AG3GCAT422TG3"; my @groups = $str =~ m/(\d+|[[:alpha:]]{2})/g; \@groups
my $str = "13month"; my ($N, $dep) = $str =~ m/(\d+)(\w+)/; print "$N; $dep"
my $str = "#     18       0     18      0 Chunk     17:25:25 17:25:25 2    arabidopsis_thaliana_core_28_81_10.analysis_description"; [split /\s+/, $str]
my $str = "\23\53\52"; $str # Grinnz_
my $str = "\\23\\53\\52"; $str =~ s/\\(\d\d)/chr $1/eg; $str
my $str = "\23\53\52"; $str =~ s/\\(\d\d)/chr $1/eg; $str
my $str = "\\23\\53\\52"; $str =~ s/\\(\d\d)/chr oct $1/eg; $str
my $str = '2 4 8 16'; my $match = '(\d+)'; my $subst = '$1 / 2'; $str =~ s/$match/$subst/ge; $str
my $str = "4 8 16 7"; $str =~ s{(\d+)}{$1 / 2}ge; print $str
my $str = "aabbcc"; $str =~ s/((\w)\1)/ $1 /g; $str
my $str = "aabbcc"; $str =~ s/(\w)\1/ $& /g;
my $str = "aabbcc"; $str =~ s/(\w)\1/ $& /g; $str
my $str = "aabbcc"; $str =~ s/((\w)\2)/ $1 /g; $str
my $str = "a b c d e f g h i j h k l"; [ (split " ", $str)[2,5-8,10] ]
my $str = "a b c d e f g h i j h k l"; [ (split " ", $str)[2,5..8,10] ]
my $str = 'abcdefghijklmnopqrstuvwxyz'; [ join '', split /(.)../, $str ] # depends on how you define 'easiest'
my $str = 'abcdefghijklmnopqrstuvwxyz'; join '', $str =~ /..(.)/g
my $str = 'abcdefghijklmnopqrstuvwxyz'; $str =~ s/..(.)/$1/gr
my $str = 'abc def'; [ $str =~ m/^(\w*)/ ]
my $str = 'abc def'; [ $str =~ m/^(\w*)/; ]
my $str = 'abcdef'; $str =~ s/(cde)//; my $removed = $1; $removed
my $str = 'abcdef'; $str =~ s/(cde)//; my $removed = $1; [$str, $removed]
my $str = 'abc def'; [ $str =~ /^(\w*)/; ]
my $str = 'abc def'; [ $_ =~ /^(\w*)/; ]
my $str = "a_b_c_d"; my $newstr = $str =~ s/_[^_]*$//r; print $str, $newstr
my $str = 'abcd'; substr($str, 2, 2).substr($str, 0, 2)
my $str = "abc"; my $len = length $str; my $copy = $str; my @rslt; for(1..2**$len-1) { my $idx = 0; do { substr($copy, $idx, 1) ^= " " } until substr($copy, $idx, 1) eq uc substr($str, $idx++, 1); push @rslt, $copy } \@rslt
my $str = "Anna: barbara (>= 0.6.16), cindy (>= 0.6.16), deborah (>= 2.7), ellen (= 1.5.3-5+deb7u1), fiona (>= 1.4.2), greta (>= 1.4.0)"; my @girls = $str =~ /\b([a-z]+)\b/ig; [@girls]
my $str = "Äö"; [ $str =~ /([[:upper:]])/ ]
my $str = '{ awf wv qwea vwev eaga }END'; return "woot" if ($str =~ m#^{.*}END$#);
my $str = "Buyer information:vivek jena"; my ($first, $second) = $str =~ /:(\w+)\s+(\w+)/; [$first, $second]
my $str = '{f.43.fq34.gf.34gfeg.ea.greags sdfasfd sd {} s{S}D F{SA}D{ FSA}D{ }},'; my ($return) = $str =~ m#^({.*?}).*#; $return
my $str = "foo:12 bar:34 baz:45"; $str =~ /foo:(?<foo>\d+) bar:(?<bar>\d+) baz:(?<baz>\d+)/; \%+
my $str = "foo:12 bar:34 baz:45"; $str =~ /foo:(?<foo>\d+) bar:(?<bar>\d+) baz:(?<baz>\d+)/; +{ %+ }
my $str = "foo:12 bar:34 baz:45"; $str =~ /foo:(?<foo>\d+) bar:(?<bar>\d+) baz:(?<baz>\d+)/; $+{foo}
my $str = "foo:12 bar:34 baz:45"; $str =~ /foo:(?<foo>\d+) bar:(?<bar>\d+) baz:(?<baz>\d+)/; [ keys %+ ]
my $str = "foo:12 bar:34 baz:45"; $str =~ /foo:(?<foo>\d+) bar:(?<bar>\d+) baz:(?<baz>\d+)/; { %+{keys %+} }
my $str = "foo:12 bar:34 baz:45"; $str =~ /foo:(?<foo>\d+) bar:(?<bar>\d+) baz:(?<baz>\d+)/; +{ %+{keys %+} }
my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \{ ([^{]+) \}/push @params, $2; $1 . @params/gex; { str => $str, params => \@params }
my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \{ ([^{]+) \}/push @params, $2; $1 . 's'/gex; printf $str, @params
my $str = 'foo%-33{param1}bar%{param0}'; my @params; $str =~ s/(%[^{]*) \{ ([^{]+) \}/push @params, $2; $1 . 's'/gex; { str => $str, params => \@params }
my $str = "foo,bar,baz foo"; my $arr = [map {split(",", $_)} split(" ", $str)]; [$arr]
my $str = "foo,bar,baz foo"; my $arr = [map {split(",", $_)} split($str)]; [$arr]
my $str = "foo bar baz"; open(my $fh, '<', \$str); print <$fh>;
my $str = "foobar"; my $new = $str ^ "   "; $new
my $str='   foo bar   '; $str =~ s/^\s+|\s+$//gie; print "STR is now '$str'";
my $str='   foo bar   '; $str =~ s/^\s+|\s+$//gi; print "STR is now '$str'";
my $str='   foo bar   '; $str =~ s/^\s+|\s+$//grie; print "STR is now '$str'";
my $str = "foo\nbar\nbaz\n"; my @lines; while ($str =~ m/([^\n]+\n)/gc) { my $line = $1; push @lines, $line } \@lines
my $str = "foo\nbar\nbaz\n"; [ split /(?<=\n)/ $str ]
my $str = "foo\nbar\nbaz\n"; [ split /(?<=\n)/, $str ]
my $str = "foo\nbar\nbaz\n"; [ split /(?<\n)/ $str ]
my $str = "foo\nbar\nbaz\n"; [ split "(?<\n)" $str ]
my $str = "fooo.bar/blah,+bar"; $str =~ s/,[+]/%2C+/g
my $str = "fooo.bar/blah,+bar"; $str =~ s/,[+]/%2C+/g; $str
my $str = "fooo.bar/blah,+bar"; $str =~ s/,\+/%2C+/g; $str
my $str = "foo"; open( my ($fh), ">", \$str ); print $fh "bar"; [ $str ];
my $str = "foo"; open( my ($fh), ">+", \$str ); print $fh "bar"; [ $str ];
my $str = "foo"; open( my ($fh), "+>", \$str ); print $fh "bar"; [ $str ];
my $str = "foo"; open( my ($fh), ">", \$str ); print $fh; [ $str ];
my $str = "foo"; substr $str, 0, 1, ''; $str
my $str = '( G1 Z0.252 F7200.000 )'; my ($int) = $str =~ m#^.*?Z([0-9.]+)#; $int
my $str = '( G1 Z0.252 F7200.000 )'; my ($value) = $str =~ m#Z([0-9.]+)#; printf("%f",$value);
my $str = '( G1 Z0.252 F7200.000 )'; my ($value) = $str =~ m#Z([0-9.]+)#; printf("%s",$value);
my $str = "Hello"; $str = $str =~ tr/l/m/r =~ tr/m/l/r; # b100s is this what you mean?
my $string = 'danny larry monica'; my @names = split /\s/, $string; print $names[0];
my $string = "it's great fun"; $string =~ s/[aeiou]/$string/g; $string
my @_STRING_; my $_INDEX_ = 0; while($_STRING_[$_INDEX_] ne '=') { $_INDEX_++ } print "finished" # basically there's no protection against this
my $string = "Number of Users: 3 Active: 3 Neighbor: 0 Parent: "; my ($number_of_users) = $string =~ /Number of Users: (\d+)/; $number_of_users
my $string = "parachutes are good"; $string =~ /chute/; pos($string) = $-[0]; $string =~ /\G.*//;
my $str = join '', a..z; [map substr($str, 2 + $_ * 3, 1), 0 .. length($str)/3 ]
my $str = join '', a..z; [map substr($str, $_ * 5, 1), 0 .. length($str)/5 ]
my $str = $LastZvalue; my ($int) = $str =~ m#^.*?Z([0-9.]+)#; $int; > and when I use the variable in < printf $fhS "; Last Z value = %d\n", $int; > it is showing me '; Last Z value = 0'
my $str = "longword"; substr $str, (int rand length $str), 1
my $str = "mello"; $str = $str =~ tr/l/m/r =~ tr/m/l/r; # this might illustrate it better?
my $str = "nickserv!nickserv@blah"; return 1 if ($str =~ m#^nickserv!nickserv\@#);
my $str = "nickserv!nickserv\@blah"; return 1 if ($str =~ m#^nickserv!nickserv\@#);
my $str = q{blah blah
my @str = ('Site oficial', 'Site não oficial'); my @results = grep { /(?<!não )oficial/i } @str; [@results]
my $str = "some text here"; $str =~ / (\S+) (\S+)/  or die; my $tmpl = "we had '[1]' and '[2]'"; my @matches = map substr($str, $-[$_], $+[$_] - $-[$_]), 0..$#+; [ $tmpl =~ s/\[(\d+)\]/$matches[$1]/ger ] # and it tends to obscure the important parts of the code
my $str = ''; $str .= chr int rand 1000000 for 1..10; $str
my $str = ''; $str .= chr rand 1000000 for 1..10; $str
my $str = "--"; $str =~ tr/-/-1/; $str
my $str = "take cat"; open my $fh, '<', \$str; $/ = \4; [ readline($fh) ]
my $str = 'te'; return substr($str,0,3);
my $str = "test"; my $len = length $str; my $mask = "\0" x $len; my @rslt; for(1..2**$len-1) { my $idx = 0; do { substr($mask, $idx, 1) ^= " " } until substr($mask, $idx++, 1) eq " "; push @rslt, $str ^ $mask } \@rslt
my $str = "test test, test"; substr($str, (rindex $str, ','), 1, ''); $str;
my $struct = { things => [1, 2, 3] };  push @{ $struct->{things} }, "more", "things";  $struct->{things}
my $structure = {}; push @{$structure->{test}}, "hello";  $structure
my $structure; push @{$structure->{test}}, "hello";  $structure
my $struct = { x => { y => { z => 1, a => 2, b => 3 }, c => 5 } }; my $code; $code = sub { my $ptr = shift; my $count = 0; for(values %$ptr) { if(ref($_) && ref($_) eq 'HASH') { $count += $code->($_) } else { ++$count } } return $count }; $code->($struct)
my $str = '[word1] word2 [word3] word4'; 1 while $str =~ s/(\[.*?\])/\N{U+FFFC}/; [ $str =~ /(\w+)/g ];
my $str = "words, only like this phrase!"; $str =~ tr/ a-z//cd; $str; # doesn't need regex, if you mean remove non-alpha characters
my $str = "\x01\x92"; my $v = 0; $v = ($v << 8) | $_ for map ord, split //, $str; $v
my $str = "\x01\x92"; my $v = 0; $v = $v << 8 | $_ for unpack 'C*', $str; $v
my $str = "\x01\x92"; unpack 'N', substr("\0" x 4 . $str, -4)
my $str = "\xff\xff\xff\xff; my $v = 0; $v = $v << 8 | $_ for unpack 'C*', $str; $v
my $str = "\xff\xff\xff\xff"; my $v = 0; $v = $v << 8 | $_ for unpack 'C*', $str; $v
my $str = "\xff\xff\xff\xff"; unpack 'N', substr("\0" x 4 . $str, -4)
my @stuff = ( 1..4 ); my ( $x, $y, @output ) = @stuff; [ @output, $x, $y ];
my $stuff = {a => 1, b => 2}; [@$stuff{'a','b'}]
my $stuff = {a => 1, b => 2}; [$stuff->@{'a','b'}] # might work on new perls?
my %stuff = (abc => 1); { local $stuff{abc} = 2; delete $stuff{abc} } \%stuff
my ($stuff) = grep { /foo/ } qw/acme beta foorlp/; [ $stuff ]
{ my sub foo { 42 } print foo(); } foo()
{ my $_; sub foo { say } } foo for 123
my @subs; for (1 .. 5) { { push @subs, sub { $_ + 1 } } }; [ map { $_->
my @subs; for (1 .. 5) { { push @subs, sub { $_ + 1 } } }; [ map { $_->>() } @subs ]
my @subs; for (1 .. 5) { push @subs, sub { $_ + 1 } }; [ map { $_->() } @subs ]
my @subs; for (1 .. 5) { { push @subs, sub { $_ + 1 } } }; [ map { $_->() } @subs ]; # stupid fingers.
my @subs; for my $_ (1 .. 5) { { push @subs, sub { $_ + 1 } } }; [ map { $_->() } @subs ]; # stupid fingers.
my @subs; for my $n (1 .. 5) { push @subs, sub { $n + 1 } }; [ map { $_->() } @subs ]
my $subs = [ sub { print 'foo'; }, sub { print 'bar'; } ]; &{$subs->[0]};
my $sub = sub { say shift // 'no args' } sub foo { &$sub } foo('one arg')
my $sub = sub { say shift // 'no args' }; sub foo { &$sub } foo('one arg')
my (sub { $x })
my @super = qw/foo bar baz aaa bbb/; my @unordered = qw/aaa foo baz/; my %order; $order{$super[$_]} = $_ for 0 .. $#super; [ sort { $order{$a} <=> $order{$b} } @unordered ]
my $_ = "system qw(rm -rf /*)"; s/(\d+)-(\d+)/join ",", $1..$2/e; [ eval ]
my @t=(3,5,7); print shift(@t)*100
my $tdata = { }; push @{ $data }, $tdata;
my $test = 1; my $something = delete $test;
my $test = `echo "here" >> /tmp/tactical`; print $test;
my $test = ('hello'); ref(\$test)
my @test = qw(dword 42 imixed42); my $pat = join '|', qr/(.).{3,}\1/, qr/(.).{0,1}\1/; [ grep { m/(?|$pat)/ } @test ]
my @test = qw(dword 42 imixed42); my $pat = join '|', qr/(.).{3,}\1/, qr/(.).{0,1}\1/; [ grep { m/$pat/ } @test ]
my @test = qw(test ing foobar thab); my $pat = join '|', map { quotemeta } qw(e a t); [ grep { m/$pat/ } @test ]
my @test = qw(word 42 mixed42); my $pat = join '|', qr/^[a-zA-Z]+$/, qr/^[0-9]+$/; [ grep { m/$pat/ } @test ]
my $test = sub { "don't do this" }; [ $test { 'main' } ]
my $test = sub { '$test is not a string' }; my $class = 'main'; [ $class->$test() ]
 my $text = 'M\xf6glich'
 my $text = "M\xf6glich"
my $text = "onetwothree"; my ($foo) = $text =~ s/(tw.)//g; $foo
my $text = 'some text to match'; my ($captured) = $text =~ /\b(t[^ ]+)/; $captured
my $thing = {};  $thing->{cycle} = $thing;  q( <== Here I have created a cycle. IT IS NOT YET A LEAK BECAUSE $thing STILL HOLDS IT );   undef $thing->{cycle};   q( <== There. I broke the cycle so now all is fine )
my $time_piece = localtime(); overload::StrVal $time_piece;
 my $time           = Time::Piece->new; Time::Piece->strptime($time->strftime('%y/%m/%d %H:00'), '%y/%m/%d %H:%M');
 my $time           = Time::Piece->new; $time->strftime('%y/%m/%d %H:00');
my $title = (sub (_) { defined ? $_ : '' })->($big_long_var_name)
my $title = (sub :prototype(_) { defined ? $_ : '' })->($big_long_var_name)
my @t = localtime; $t[3] += 1; my $tomorrow = mktime @t;
my @t = localtime; $t[4]--; say strftime "%Y-%m-%d %H:%M", @t
my @t = localtime; $t[4]--; strftime "%Y-%m-%d %H:%M", @t
my @$tmp;
my @tmp = (1..3); my @tmp; \@tmp
( my $tmp = "Hello, world" ) =~ tr/A-Za-z/N-ZA-Mn-za-m/
( my $tmp = "Hello, world" ) =~ tr/A-Za-z/N-ZA-Mn-za-m/; $tmp
my @tmp; $tmp[3] = "gi|300707803|ref|XP_002996096.1|hypothetical protein NCER_100860 [Nosema ceranae BRL01] >gi|239605364|gb|EEQ82425.1| hypothetical protein NCER_100860 [Nosema ceranae BRL01]"; my($ia,$ib) = split(/\[/,$tmp[3]); [ $ia, $ib]
my $two = "two"; [ "two\n" =~ /^\Q$two\E$/, "two\n" =~ /\A\Q$two\E\z/, "two\n" eq $two ]
my $two = "two"; [ "two\n" =~ /^\Q$two\E$/, "two\n" eq $two ]
my $txt = "T\x0A\x0B"; s{([^[:print:]])}{sprintf '\\%02x', ord $1}ge for $txt; [ $txt ] # or this. or Data::Dumper
[ my $tz ]
my (undef, $b) = (1,2)
my $undef = " "; print $undef
my $undef = ""; print $undef
my (undef, undef);
my $undef = undef; print $undef
my (undef, $y) = ("a", "b");
my @under = ( "_" );   [ ( @under )x 5 ]
my @under = ( "_" );   [ @under x 5 ]
my $url = 'http://something'; my @cmd = (qw(youtube-dl -f 17 ...), $url); \@cmd # I'd write it more like this
my $USA; my $x = 'USA'; ${$x} = 42; [ $USA ]
my $username_ = 'xyz'; "$username_%" # ${...} might look better
my ( $user, $nick ) = ( 'root', 'ro.+' ); if($user =~ /^$nick$/){ say 'pwned' } else { say 'you are not root' }
my $users = 1;say "damn them" if $users;
my $v = 0.223; die "out of range" if $v > 1; my $w = 0.05; my $start = $w * int($v / 0.05); [ $start, $start + $w ]
my $v = '0.9'; $v .= '9' until $v . '9' == $v; length $v
my $v = 0.9; $v .= '9' until $v == $v.'9'; length $v;
my $v = 0; $v ||= 5; [$v]
my $v = -1; my @x; for( my $i = 0, my $r = 0; $r = ($v/256**$i)%256; $i++ ) { push @x, pack q{C}, $r; } [ map { [ unpack( q{C} ), unpack( q{B8} ) ]; } @x ]
my $v = 1; $v ||= 5; [$v]
my $v = 246307; my @x; for( my $i = 0, my $r = 0; $r = ($v/256**$i)%256; $i++ ) { push @x, pack q{C}, $r; } [ map { unpack q{B8}; } @x ]
my $v = 261; my @x; for( my $i = 0, my $r = 0; $r = ($v/256**$i)%256; $i++ ) { push @x, pack q{C}, $r; } [ map { unpack q{B8}; } @x ] ## Use 'reverse @x' for opposite endian, big endian in this case.
my $val = 'a'; [($val++)x3]
my @vals = (1,2,3); sub do_stuff { undef $_ } [ map { do_stuff(); $_ } (@vals) ]
my @values = (1, 0, 1, 1);  my $n = 0; ($n >>= 2) |= $_ for reverse @values; [ $n, sprintf '%b', $n ];
my @values = (1, 0, 1, 1);  my $n = 0; ($n <<= 2) |= $_ for reverse @values; [ $n, sprintf '%b', $n ]; # d'oh
my @values = ((1)x 7, 0);  my $n = 0; ($n *= 2) += $_ for reverse @values; $n;
my @values = ((1)x 7, 0);  my $n = 0; ($n *= 2) += $_ for @values;
my @values = ((1)x 7, 0);  my $n = 0; ($n *= 2) += $_ for @values; $n;
my @values = ((1)x 7, 0); unpack 'I<', pack(('b' x @values), @values);
my @values = ((1)x 7, 0); unpack 'I>', pack(('b' x @values), @values);
my @values = ((1)x 7, 0); unpack 'I<', pack(('B' x @values), @values);
my @values = ((1)x 7, 0); unpack 'I>', pack(('B' x @values), @values);
my @values = ((1)x 7, 0); unpack 'n', pack(('b' x @values), @values);
my @values = ((1)x 7, 0); unpack 'n', pack(('B' x @values), @values);
my @values = ((1)x 7, 0); unpack 'N<', pack(('b' x @values), @values);
my @values = ((1)x 7, 0); unpack 'N', pack(('b' x @values), @values);
my @values = ((1)x 7, 0); unpack 'N', pack(('B' x @values), @values);
my $value = undef;  undef == 2
my $var = 0 || 1;
my $var = 0; [ defined $var ]
my $var = (1-1) || (2-2);
my $var1 = 3; my $var2 = 7888; ($var1, $var2) = ($var2, $var1); print "var1: $var1. var2: $var2"; #hudo
my $var = "1k10k1l11dld1";  $var =~ /(\d+)/; print $var;
my $var = "1k10k1l11dld1";  $var = tr/(d+)//d; print $var;
my ($var1, $var2) = split(/\=/, "you=me"); print $var1 . " = " . $var2
my $var = 2 || 3;
my $var = 42; my $ref = \$var; Internals::SvREFCNT $var
my $var = 42; sub xxx { my ($stuff) = @_; return $stuff + $var } xxx(5)
my(@var) = 5; [ @var ]
my@var = 5; [ @var ]
my $var = "6d73616e64626f78"; $var =~ s/([0-9a-f]{2})/chr hex $1/eg
my $var = "6d73616e64626f78"; $var =~ s/([0-9a-f]{2})/chr hex $1/eg; $var
my $var = (7,8,9); print "($var)";
my $var='/.a./.a./.a./.a./'; $var =~ /(\.\.)/ ? print "match two dots in a row" : "no match";
my $var = "cat"; "${var}iable"
my $var = ( 'One', 'Two', 'Three');
my $var = ( 'One', 'Two', 'Three'); $var
my $var='\/print "OK" if
my $var = qw/ One Two Three /; $var
my $var = "something"; "$var" # this?
my $var = "this"; my $ref = \$var; my $copy = $$ref; $var = "that"; $copy
my $var = "this"; my $ref = \$var; my $copy = $ref; $var = "that"; print($$copy);
my $var='/../../../../'; $var =~ /(\.\.)/ ? print "match two dots in a row" : "no match";
my $v = q{1.41_02}; [ $v, eval $v ];
my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { 1 } @$v[ $i, $i + 1 ]; print qq{($a,$n)}; } ### This results in an infinate loop some how...
my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { 1 } @$v; print qq{($a,$n)}; } ### Oddly though, changing @$v[ $i, $i + 1 ]; to just @$v makes the loop finite again...
my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } do { @$v[ $i, $i + 1 ] }; print qq{($a,$n)}; } ### Another way, a little cleaner and without an explicit array being declared.
my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } (my @x) = @$v[ $i, $i + 1 ]; print qq{($a,$n)}; } ### Slightly hackish but works.
my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } splice @$v, $i, -2, 2; print qq{($a,$n)}; }
my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } () = @$v[ $i, $i + 1 ]; print qq{($a,$n)}; }
my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } @$v[ $i, $i + 1 ]; print qq{($a,$n)}; } ### This results in an infinate loop some how...
my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } @$v[ $i, $i < $#$v ? $i + 1 : () ]; print qq{($a,$n)}; } ### This solution is rather ugly as sin, but it works. Is there another way?
my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } $v->[$i], $v->[$i+1]; print qq{($a,$n)}; }
my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } $v[$i], $v[$i+1]; print qq{($a,$n)}; }
my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ // q{} } $v->[ $i ], $v->[ $i + 1 ]; print qq{($a,$n)}; } ### Why does this still loop infinately when $v->[ $i ], $v->[ $i + 1 ]; on two seaprate lines does not?
my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = map { $_ } @$v[ $i, $i + 1 ]; print qq{($a,$n)}; } ### This results in an infinate loop some how...
my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = @$v[ $i, $i + 1 ]; print qq{($a,$n)}; }
my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my ( $a, $n ) = ($v->[$i], $v->[$i+1]); print qq{($a,$n)}; }
my $v = [ qw( A B C ) ]; for ( my $i = 0; $i < @$v; $i++ ) { my $a = $v->[ $i ] // q{}; my $n = $v->[ $i + 1 ] // q{}; print qq{($a,$n)}; } ### This works as expected.
my %v = %$^V; [ keys %v, values %v ]
my $warning; $SIG{__WARN__} = sub { $warning = shift }; warn 'asdf'; [$warning]
my @warnings; sub foo { local $SIG{__WARN__} = sub { push @warnings, @_ }; goto &bar } sub bar { warn "blah" } foo(); \@warnings
my $wat = "\\Q"; "Q" =~ /$wat/ ? "yes" : "no"
my $what = "cats"; [ delete $cats ]
my $what = "cats"; [ delete $what ]
my @whatever = ( my %being = qw(state alive) ); \@whatever
my @whitelist = qw(the b brown dog); [ map { my $word = $_; grep { index($word, $_) >= 0 } @whitelist } "the brown dog jumps over the brown fox" =~ /\w+/g ] # apart from the illegibility, of course
my $_ = "wibble"; s/(.)/sprintf('\\u%04x', "$1")/ger
my $_ = "wibble"; s/(.)/sprintf('\\u%04x', $1)/ger
my $_ = "wibble"; s/(.)/sprintf('\\u%04x', ord "$1")/ger
my @w = map { $_ =~ /\s+/ ? $_ =~ s/\s|\s+/-/g : trim($_) } split ',', ('hello, world, foo bar baz');
my @words = split /\W/, "a.b!c?d e"; for my $i (0..$#words - 1) { push @word_pairs [ $words[$i], $words[$i+1 ]; }; \@word_pairs
my @words = split /\W/, "a.b!c?d e"; for my $i (0..$#words - 1) { push @word_pairs, [ $words[$i], $words[$i+1] ]; }; \@word_pairs
my @wrong = [] ; my @right = (); { wrong => \@wrong, right => \@right }
[\my $x]
my @x = ;
my @x = ( [ 0, 1, 2 ] ); $#{$x[0]}
my @x = ( [ 0, 1, 2 ] ); $#$x[0]
my $x = [ [ 0, 1, 2 ] ]; $#{$x[0]}
my $x = 0.21875; my $out = ''; while(int($x) != $x) { $x *= 2; $out .= ($x & 1) ? 1 : 0; }; $out
my $x = 0.3; my $out = ''; while(int($x) != $x) { $x *= 2; $out .= ($x & 1) ? 1 : 0; }; $out
my $x = 0.40625; my $out = ''; while(int($x) != $x) { $x *= 2; $out .= ($x & 1) ? 1 : 0; }; $out
my $x = 0.5; my $out = ''; while(int($x) != $x) { $x *= 2; $out .= ($x & 1) ? 1 : 0; }; $out
my $x = [0..9];  $#$x # is this the right way to get the last index of @$x?
my $x = 0; eval 'print ++$x;'x10  # "power of looping"
my $x = 0; [ map { $x = int !!--$x } 1..5 ]
my $x = 0; [ map { $x = int !!++$x } 1..5 ]
my $x = 0; print "$x" if $x == 0;
my $x = 0; print $x if $x == 0;
my $x = 0; print "$x,  return value:" if $x == 0;
my $x = 0; $x += $_ + ($_*$_ < 2119) * $_ * $_ for 1 .. 2118; $x
my $x := 1;
my $x = 10.01; $x -= 10; print $x
my $x = 10,25;
my $x = 10,25; [$x]
my $x = 10; my $y = 20; sprintf "%d is %s %d", $x, [qw( equal-to greater-than less-than )]->[ $x <=> $y ], $y
my %x = 1 .. 100; eval scalar %x
my %x = 1..100; int %x
my %x = 1..100; scalar keys %x
my %x = 1..100; scalar %x
my %x = 1..10; $_ += 100 for keys %x; \%x
my %x = 1..10; $_ += 100 for values %x; \%x
my @x = 1..10; [ @x[0 .. -1] ]
my @x = 1..10; [ $x[0 .. -1] ]
my $x = "123"; 0+$x; "123 " ~~ $x ? 'yes' : 'no'
my $x = "123"; 0+$x; print "123 " ~~ $x ? "yes" : "no"
my $x = "123"; "123 " ~~ $x ? 'yes' : 'no'
my $x = '1.2345' + '10000000000'; $x =~ /([0-9]{3}\.[0-9]+)$/; print $1;
my @x = [1,2,3]; for my $v (@x) { print "$v" } # are you doing something like this
my $x = "123"; print "123 " ~~ $x ? "yes" : "no"
{ my $x =123; sub cloure { $x } } closure
{ my $x =123; sub clousre { $x } } closure
my $x = [[1],[2],[3]]; [ @$x[0, 2] ]
my $x = [[1],[2],[3]]; @x->[0,2]
my @x = (1,2,3); [\@x, \(@x)]
my $x = [[1],[2]]; my $y = $x->[1]; 42 if \$x->[1] == $y
my $x = [[1],[2]]; my $y = $x->[1]; 42 if \$x->[1] == \$y
my $x = [[1],[2]]; my $y = \$x->[1]; [grep { $y == \$_ } @$x];
my $x = [ 1, 2 ]; $x->[0] # or these?
my @x = (1..5); @x[0..2] = (1..3); scalar @x;
my @x = (1..5); @x = (1..3); scalar @x;
my %x = (1, 'a'); my @x = ('c', 'd'); [ %x{1} ]
my $x = 1e-100; print $x
my @x1 = 'FOO'; my @array = ("a", "b"); [q(@array) .@x1, q@array .@x1]
my $x = \(!!1); &Internals::SvREADONLY($x, 0); $$x = Scalar::Util::dualvar undef, "no"; [ 3 == 3 ] # sometimes useful in recalcitrant code
my $x = 1; print $x++, $x++, ++$x, ++$x;
my $x = 1; print $x++, $x++, "" . ++$x, "" . ++$x, $x++, "" . ++$x;
my $x = 1; print $x++, $x++, ++$x, ++$x, $x++, ++$x;
my $x = 1; sub foo :lvalue { $x }  undef foo; [$x]
my $x = 1; sub foo :lvalue { $x }  undef foo; $x
my $x = 1; $x+2
my $x = 1; ( ++$x ) =~ s/2/TWO/;  $x
my $x = 1; ${\$x++} =~ s/2/TWO/; $x
my $x = 1; ${\++$x} =~ s/2/TWO/; $x
my $x = 2118 * 2119 / 2; $x += $_ * $_ for 1 .. sqrt 2118; $x
my $x = (3,2,1); $x
my $x = '3 + 4 eq "7"; my @n = $x =~ /(\d+)g/; [ @n ]
my $x = '3 + 4 eq "7"'; my @n = $x =~ /(\d+)/g; [ @n ]
my $x = '3 + 4 eq "7"'; my @n = $x =~ /(\d+)g/; [ @n ]
my $x = '3 + 4 eq "7"'; my @n = $x =~ /\d+/g; [ @n ]
my $x = 3; $x /= 3; $x
my $x = 42; [  map { state $y = $x++; $y } 0..3 ];
my $x = 42; sub { $x++ }->(); $x
my $x = \42; $x->$*
my $x = ~42; [ $x =~ 42 ]
my $x = ~42; [ $x = ~42 ]
{ my $x = 42; } "x = $x"
my $x = 43; Internals::SvREADONLY $x, 1; $x = 23; $x
my $x = ( 4, 5, 6 ); $x; ### Gives last value from comma list (comma operator.)
my $x = "4-9"; s/(\d+)-(\d+)/join ",", $1..$2/e; $x
my $x = 55; sub foo { unless ($x) { return 'foo' } } [foo()]
my @x = (5,6,7); print "Hello", scalar(@x), "\n";
my @x = (5,6,7); print "Hello", @x, "\n";
my @x = (5,6,7); \@x
my @x = [5,6,7]; \@x
my @x = 7 .. 9; please, print @x;
my @x = 7..9; print @x;
my %x = (a => 0); [ (exists $x{a} ? 'true' : 'false'), ($x{a} ? 'true' : 'false') ]
my $x = \{ a => 123 }; [ ref $x, $$x->{a} ]
my %x = (a => 1); my $y = { %x }; delete $y->{a}; \%x
my %x = (a => 1); my $y = \%x; delete $y->{a}; \%x
my $x = 'aaa'; sub f { $_[0] = 'bbb';}; f($x); [$x]
my $x = 'aaa'; sub f { \@_ }; my $y = f($x); $y->[0] = 'bbb'; $x
my $x="ababababa"; $x=~s/a/x/ for 1..3; $x
my $x = "a b a c a d a e"; [$x =~ s/a/t/g]
my $x = "a b a c a d a e"; [$x !~ s/a/t/g]
my $x = 'abcd'; substr $x, 2 # but more importantly it'd make the code almost readable
my $x = "a"; ${\my $x} = "b"; $x
my $x = "asdf"; pos($x) = 1; { local pos($x) = 2; print pos $x, ";";} pos $x
my $x = "asdf"; pos($x) = 2; { local pos($x) = 4; print pos $x, ";";} print pos $x
my $x = "asdf"; pos($x) = 666; pos $x
my $x = "asdfX"; my $y = "asdfY"; $x =~ /\A\Q$y\E{0}.\z/s ? "yes" : "no"
my $x = "asdfX"; my $y = "asdfY"; $x =~ /\A(?>\Q$y\E??).\z/s ? "yes" : "no"
my $x = "asdfY"; my $y = "asdfYt"; $x =~ /\A(?>\Q$y\E??).\z/s ? "yes" : "no"
my $x = "asdfYt"; my $y = "asdfY"; $x =~ /\A(?>\Q$y\E??).\z/s ? "yes" : "no"
my $x; BEGIN { $x = 'x' } our $$x = 123; # basically this - the 'our' isn't doing anything useful so it can be left out entirely
my $x = bless [7,8,9], q{FOO}; print qq{($a, $b)} while ($a, $b) = each @$x; ### What I don't quite understand is that @$x to such a function works, so it wouldn't make sense for keys or so to do something similar, if UNIVERSAL::isa( $arg, q{ARRAY} ) @$arg or something like that? Or would overloading still muck with that?
my $x = bless [7,8,9], q{FOO}; UNIVERSAL::isa( $x, q{ARRAY} )
my $x = bless {}, q{Foo}; "$x";
my @x = ('c', 'd'); [ %x[1] ]
my @x = ('c', 'd'); [ %x{1} ]
my $x = 'code'; print $$x;
my $x = 'code'; $$x;
my $x = "Data::Dumper"; use $x;
my $x = \do {42}; [ $x ]
my $x = \do {42}; [ ++$$x ]
my $x = \do {my $o = 42}; [ ++$$x ]
my $x = do { my $tmp; \$tmp }; my $y = $x; $$y = 'foo'; print $$x; # porton is this what you want?
{ my $x = "e"; $x--; print $x }
my $x = { first => 'some error here', second => 'great success' }; my %h = map { ($x->{$_} !~ /error/) ? ($_ => $x->{$_}) : () } keys %$x; \%h # like this, you mean?
my $x = { foo => 1 }; my \%y = $x; $y{bar} = 2; $x;
my $x = 'FooBarBazQuuxFleem'; my $off = 1; join '', map { (my $str = $_) =~ s/^./$off/; $off += length($_); $str } split /(?=[A-Z])/, $x;
my $x = 'FooBarBazQuuxFleem'; my $off = 1; join '', map { (my $str = $_) =~ s/$/$off/; $off += length($_); $str } split /(?=[A-Z])/, $x;
my $x = 'FooBarBazQuuxFleem'; $x =~ s/[A-Z]/$+[0]/g; $x
my $x = 'FooBarBazQuuxFleem'; $x =~ s/B/$+[0]/g; $x
my $x = 'FooBarBazQuuxFleem'; $x =~ s/B/$+[0]/g; $x =~ s/Q/$+[0]/g; $x
my $x = 'FooBarBazQuuxFleem'; $x =~ s/B/$+[0]/g; x =~ s/Q/$+[0]/g; $x
my $x = "foo:bar:baz"; [ $x =~ /\A(.*?)(?:=|==|:|--)(.*)\z/s ]
my $x = "foo:bar:baz"; $x =~ /=|==|:|--/ or die; [ substr($x, 0, $-[0]), substr($x, $+[0]) ]
my $x = "foo"; my $f = sub { print $x }; $f->(); $x = "bar"; $f->();
my @x = ("foo\n", "bar", "baz\n"); chomp @x; \@x
my $x = 'foo'; $x ||= do { print 'bar'; 'baz' }; [ $x ];
my $x = 'foo'; $x &&= do { print 'bar'; 'baz' }; [ $x ];
my @x; for (@x) { print "entered" } # unless you mean something other than running code inside the foreach loop?
my $x; $_++ for ($x)x3; $x # two more examples
my $x = 'Friseure'; [ map { $x =~ /e$/g; pos($x) } 1..10 ] # does this make it any clearer?
my $x="from nm37.bullet.mail.ir2.yahoo.com (nm37.bullet.mail.ir2.yahoo.com [212.82.96.62])"; [ ($x =~ /[\w.]+/g)[-2, -1] ] # tharkun
my $x = "Hello a and b"; $x =~ s/\b([ab])\b/$1 eq 'a' ? "l3u" : "rindolf"/ge; [$x]
my $x = "Hello anna!" [($x eq "anna" ? "T" : "F"), ($x =~ /anna/ ? "T" : "F")]
my $x = "Hello anna!"; [($x eq "anna" ? "T" : "F"), ($x =~ /anna/ ? "T" : "F")]
my $x = "Hello "; $x .= "KNERD"; [$x]
my $x = "hmm"; [ (my $tmp = $x, undef $x)[0] ]
my $x = "hmm"; [ (my $tmp = $x; undef $x)[0] ]
my $x = 'hmm'; [ ([$x]->[0], undef $x) ]
my $x = 'hmm'; [ ([$x]->[0], undef $x)[0] ]
my $x = 'hmm'; [ ("$x", undef $x)[0] ]
my $x = 'hmm'; [ ($x, undef $x)[0] ]
my $x = 'hmm'; [ [$x, undef $x]->[0] ]
my $x = "Host: myHost\n";  my ($targetHost) = $heap->{buffer} =~ m#Host: (.*?)#; return $targetHost;
my $x = []; if ($x) { print "a ref is true even when it refers to empty" }
my $x = 'interpolates?'; qq'$x';
my $x = 'interpolates?'; q"$x";
my %x; local keys %x;
my %x; local keys %x = "hi";
my @x; local $x[0] = 42; "@x";
my @x; local $x[0] = 42; @x;
my @x; local $x[0] = 42; \@x;
my @x = (map { $_ * 10 } 0 .. 9); [%x[3,6]]
my @x = map { no strict qw(refs); $_; } 1..3; ### Why does this generate an error regarding the use of `no` ?
my @x = map { qq{$_\n} } qw/ABC DEF 123 GHI/; join q{}, map { $_ x= !m!\d+!; } @x ;
my @x = map rand(5), 1..10; [ map int(.5+$_), @x ]
my @x = map rand(5), 1..40; [ map int(.5+$_), @x ]
my @x = map /(\w+)/g, "some test line"; \@x; # Third time's the charm?
my @x = map /^(\w+)/g, "some test line"; \@x; # This is what I meant.
my @x = map /^(\w+)/m, "some test line"; \@x; # Passing flags can be useful.
my @x = map /^(\w+)/, "some test line"; \@x; # yet another way to do it.
my @x; my $line = "some test line"; push @x, $line =~ /^(\w+)/; print for @x; # another way to write the same thing
[\(my $x, my $y)]
my $x; my $y = 1..1; [ $x, $y ]; ### Why exactly does assigning a range in scalar context result in the lhs being an empty string (not undef) ?
my $x = "" ; my $y; [ ($x // '') eq ($y // '') ]
my $x = "\n"; [ $_ = chomp $x ]
my $x = "\n"; [chomp($x);]
my $x = "\n"; [chomp($x)]
my $x = "\n"; chomp($x); print $x;
my $x = "\n"; [ $x = chomp $x ]
my $x = "\n"; [$x = chomp $x, $x]
my $x = "\n"; $x = chomp $x; $x
my $x = "\n"; $x = chomp($x); $x
my @x = ("One", "Two", "Three"); [join(" ", @x)]
my $x = pack('C*', map rand(128), 1..1e5); my ($index, $regex); my $start = time; 1 while $start == time; ++$start; index($x, "\\x"), ++$index while $start == time; ++$start; $x =~ /\\x/, ++$regex while $start == time; [ $index, $regex, $index / $regex, $regex / $index ];
my $x = pack('C*', map rand(128), 1..1e5); my $reps = 0; my $start = time; 1 while $start==time;++$start; { index($x, "\x"); ++$reps; redo if $start == time }; [ $reps ]
my $x = pack('C*', map rand(128), 1..1e5); my $reps = 0; my $start = time; 1 while $start==time;++$start; { $x =~ m/\\x/; ++$reps; redo if $start == time }; [ $reps ]
my $x = pack 'C*', map rand(128), 1..1e5; my $start = time; my $y = index( $x, "\\x" ); [ time()-$start, $y ];
my @x; push @x, foo(), foo(); { my $var = 0; sub foo { $var++ } } push @x, foo(), foo(); \@x
my @x; push @x, qw( A B C ); unshift @x, qw( X Y Z ); \@x;
my @x; push @x, /^(\w+)/ for 'test something'; \@x;
my $x = q{abc}; !!$x;
my $x = q{FOO\tBAR\r\n}; ( my $y = $x ) =~ s/\\t/\t/g; $y =~ s/\\r/\r/g; $y =~ s/\\n/\n/g; [ $x, $y ];
my $x = q{}; int !!$x;
my $x = qr/bar/; no overloading; "$x";
my $x = qr/bar/; "$x"; # vs.
my $x = qr/what does this do/x; "$x"
my $x = qr/\w+/; [ $x, qr/$x/ ]; # Why can't dclone just handle Regexp objects like this?
my $x = qr/x/; my $y = $x; [ $x, $y ];
my @x = qw/1 2 3/; $_+=3 for @x; \@x
my @x = qw/1 2 3 4/; delete $x[-1]; print $_ // '!' for @x;
my @x = qw/1 2 3 4/; $x[-1] = undef; print $_ // '!' for @x;
my @x = qw( @ A 1 B 2 C 3 ); foreach my $i ( 1 .. $#x ) { my ( $k, $v ) = ( $x[ $i ], $x[ $i++ + 1 ] ); print qq{$k => $v | }; }
my @x = qw( @ A 1 B 2 C 3 ); for ( my $i = 1; $i < @x; $i++ ) { my ( $k, $v ) = ( $x[ $i ], $x[ $i++ + 1 ] ); print qq{$k => $v | }; }
my @x = qw(a b c d d a b a c a c c c d e f g h); for(@x) { if($seen{$_}) { $_ = $_ . "_" . $seen{$_}++ } else { $seen{$_} = "aa" } } \@x # like this, or something else?
my @x = qw(a b c d); delete $x[1]; print $_ // '!' for @x;
my %x = qw(a b c d e f g h); [ @x{a, g} ]
my %x = qw(a b c d e f g h); @y{a, g} = @x{a, g}; \%y
my $x = [qw(a b c d e f g)]; [ keys @$x ] # it's available in both perl versions - 5.20 and 5.22
my @x = ( qw( A B C ) ); { exists => [ map { exists $x[ $_ ] } 0..5 ], x => \@x };
my @x = qw(a b c); splice @x, 1, 1; \@x # if you want to remove an element from the array, use splice, pop or shift
my @x = qw(a b c); undef $x[1]; \@x # if you want to set a specific element to undef, use undef
my $x = qw(a b c); $x # it's the list/scalar context that determines what you get
my @x = qw(foo bar baz); my @y = 1..3; [ \(map {$_} @x, @y, 42) ]
my @x = qw(foo bar baz); my @y = 1..3; [ \((@x, @y, 42)) ]
my @x = qw(foo bar baz); my @y = 1..3; [ \(@x, @y, 42) ]
my $x = () = qw(foo bar baz); $x
my @x = qw/foo bar/; my $y = (123 => @x); $y # or the usual fun
my @x = qw(x y z); my @y = do { push @x, my @x = q chic; @x }; [ \@x, \@y ]
my @x = qw(zero one two); my ($idx) = grep $x[$_] eq 'two', 0 .. $#x; $idx
my $x = q{}; !!$x;
my $x = {}; [ q{}. $x, int $x ]
my $x = []; ref \$x
my @xs; bless \@xs, "hello world"; ref \@xs
my $x :shared;
my $x = '/somepath/subdir'; $y = '/newpath/newdir'; my $data = '/somepath/subdir/whatever.txt'; $data =~ s/\Q$x/$y/g; [ $data ]
my $x = 'some test'; my $y = \substr($x, 5, 4); $$y = 'data'; $x
my $x = "something"; qq/'" foo bar baz '" $x/
my $x = 'some var'; my $y = $x =~ s/var/thing/r; [ $x, $y ]
my @xs = qw/a b d z o l p a l/; [ keys %{{ @xs, reverse @xs }} ]
my $x = sub (\@) { "$_[0]" }; my @a = (3, 4); print &$x(@a); ()
my $x = sub (\@) { "$_[0]" }; my @a = (3, 4); $x->(@a)
my $x; sub foo:lvalue { return $x } foo() = 123; $x;
my $x; sub lala { \$x } [\$x, lala()] # identical
my $x = sub ($) { @_ }; *x = $x; [ join ' ', $x->('a'..'c'), '|', x('a'..'c') ]
my $x = 'test$blah'; $x =~ s#[^a-zA-Z0-9 ]##g; $x
my $x = "test$blah"; $x =~ s#[^a-zA-Z0-9 ]##g; $x
my $x = 'testing'; for ($x) { (sub { $_ = shift; return /firefox/ })->('...') } $x # no, probably not okay
my $x = time; print $x;
my $x = \undef; &Internals::SvREADONLY($x, 0); $$x = 3; [ undef ]
my $x = \undef; &Internals::SvREADONLY($x, 0); $$x = Scalar::Util::dualvar 0, "lemons"; [ undef, defined undef ]
my $x = \undef; &Internals::SvREADONLY($x, 0); $$x = Scalar::Util::dualvar 0, "lemons"; [ undef ] # maybe?
my $x = unpack "b*", "this is a test"; $c
my $x = unpack "b*", "this is a test"; $x
my @x; [ @x[0..3] ]
my $x = []; ["$x", 0+$x]
my %x; $x[1] = 1;
my %x; %x[1] = 1; # gives a syntax error
my ($x, $x) = (1, 2); $x
my %x; $x{a} = 4; @x{a} = (5); print $x{a}
my %x; $x{a} = 4; @x{'a','b'} = (5); print $x{a}
my $x; $x{abc} = 123; $x
my $x; $x ||= do { print 'bar'; 'baz' }; [ $x ];
my $x; $x &&= do { print 'bar'; 'baz' }; [ $x ];
my $x = "X\n"; $x = chomp($x); [ "$^V : x=$x" ]
my $x; $x->what_did_you_expect
my @x; { ++$#x } \@x
my $x; $x++; $x
my $x = []; $x == \@$xs ? "yes" : "no"
my $x; $x ? $x++ : ( $x = 1 ); $x;
my $x = {}; $x->{x} = $x; $x
my $x = []; $x == \@$x ? "yes" : "no"
my ($x, $y) = 1..10;
my ( $x, $y ) = ( 2733.754, 60 ); sprintf q{%.3f}, $x - int( $x/$y ) * $y;
my ( $x, $y ) = ( 2733.754, 60 ); ( ( $x * 10000 ) - ( int($x/$y) * $y * 10000) ) / 10000; ### :)
my ( $x, $y ) = ( 2733.754, 60 ); $x - int( $x/$y ) * $y; ### :)
my ($x, $y) = 9..19;
my $x->{y} = $x;
my ($x, $y); ${'x'} = 123; ${'y'} = 456;  [ $x, $y ] # even typo fixes I can't see how that would ever work
my $x = 'Zoffix'; substr($x, 2, 1) = 'ooooo'; $x
my @y = 1..9; my $x = (map { $y[$_-1] += $y[$_] } reverse 1..$#y)[-1]; $x # death.
my $y=1; my $x=\$y; ++$x; [$x, $y]
my @y = ( 4, 5, 6 ); my $x = ( 0, @y[0 .. $#y] ); $x
my @y = ( 4, 5, 6 ); my $x = ( 0, @y ); ### I thought that would work, but I see it interprets @y in ( 0, @y ) in scalar context, effectively being ( 0, 3 ) rather than ( 0, 4, 5, 6 )
my @y = ( 4, 5, 6 ); my $x = @y; $x; ### Gives size of list instead, as expected here. Is there a way to get the last item in the list, similar to how the comma operator would, like above?
my %y; my $x; \$x = \$y{x}; $x = 42; [ $x, \%y ]
my %y; our $x; *x = \$y{x}; $x = 42; [ $x, \%y ]
my $y = q{bar}; my @x = <A "B \\"foo $y baz\\" C" D>; print qq{$_\n} for @x; # Seems to do everything I've seen people over and over ask if qw() could do.
my $y = q|foo{x,y,z}|; my @x = < $y >; \@x;
my $y = q{x y z}; my @x = <A "B foo" C $y D "$y" E>; \@x; # Feels a little like bash.
my @z = my $ret = my ($x, $y) = 9..19; [ $ret, $x, $y, \@z ]; # Basically just assigning $ret to @z, a la @z = $ret;
my %args = {domain => "example.net", number => 0;};
my $_ = "啊啊"; s/(.)/sprintf('\\u%04x', $1)/ger
"\n" =~ /^$/
['\n']
["\n"]
$n = 0; 5 / ($n || 1)
$n=10;$==0,(1x$_)=~/^(1|11(??{}))*$(?{$=++})^/,print"$= "for 0..$n-1
$n=10;$==0,(1x$_)=~/^(1|11(?{}))*$(?{$=++})^/,print"$= "for 0..$n-1
$n=10;$==0,(1x$_)=~/^(1|11)*$(?{$=++})^/,print"$= "for 0..$n-1
$n = 11111111113232323232 ; $d = $n << 32 >> 32 ; $d1 = ($n - $d) >> 32 ;  $r = pack("N",$d1) . pack("N",$d) ; print unpack("H*",$r) ."\n"
$n = 232 ; $d = $n << 32 >> 32 ; $d1 = ($n - $d) >> 32 ;  $r = pack("N",$d1) . pack("N",$d) ; print unpack("H*",$r) ."\n"
$n = 23342342342342342342 ; $d = $n << 32 >> 32 ; $d1 = ($n - $d) >> 32 ;  $r = pack("N",$d1) . pack("N",$d) ; print unpack("H*",$r) ."\n"
$n = 42; $, = ' '; print ++$n, ++$n, ++$n, ++$n  # oh, really
$n = 4; [ 'abcdefghi' =~ /c@{['(.)'x$n]}/ ]
$n = 5; $n = $n++; $n
$n = 5; $n = ++$n; $n
$\="\n"; $_ = "ab"; print; $_++; print; $_+0; print; $_++; print
$\="\n"; $_ = "ab"; print; $_++; print; $_+0; print; $_++; print; ()
$! = 'NaN'; $!
'nan'/0
NaN/0
!!( "nan" <= 1.0 )
"NaN" <=> "NaN"
("NaN" <=> "NaN") + 0
'na'x3^"\f"
"\n" =~ /\A\z/
"\N{BEER MUG}"
"\nD" =~ /^D/m
'needs more :'
$new = true; [$new, true]
{ next }
{ next if $x->{a}{b}; } [ $x ]
"nickserv!nickserv@blah"
"\N{INTERROBANG}" x 3 . "HELLO" . "\N{INTERROBANG}" x 3
"\n" =~ /\n/
[ "  \n   \n  \n   hello\n" =~ s/^\s*\n//r ]
"  \n   \n  \nhello\n" =~ s/^\s*//sr
$_ = "\n\nTAG\n\n\n"; s/\A\n+//; s/\n+\z/\n/; [ $_ ]
no arybase;
no autovivification 'delete'; delete $undef->{key}; $undef
$nodes[5] = 1; \@nodes
@nodeStatus = (0) * 150; \@nodeStatus
@nodeStatus = (0) x 150; \@nodeStatus
no feature ':all'; sub foo (;$) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \%h
no feature ':all'; sub foo (;$$) { [@_] }; my %h = ( bar => foo 42, meow => 'moo' );  \%h
no feature; no indirect 'fatal'; sub new { bless [] }; [ new {main} 1,2 ]
no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new { bless [] }; [ new {main} ]
no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new { bless [] }; [ new main ]
no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new(*) { bless [] }; [ new main ]
no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new { die @_ }; [ new {main} ]
no feature; no indirect 'fatal'; sub new { bless [] }; package foo; sub new { die @_ }; [ new {main} 1,2 ]
no feature; no indirect; sub new { bless [] }; package foo; sub new(*) { bless [] }; [ new main ]
no feature 'say'; open $fh, ">", \$str; say $fh $_ for qw,foo bar baz,; [ $str ]
no feature 'say'; open $fh, ">", \$str; say($fh $_) for qw,foo bar baz,; [ $str ]
no feature 'signatures'; sub foo (&@) { my ($code, @args) = @_; $code->(@args) } my $res = foo { [@_] } 1, 2, 3; $res
no feature 'signatures'; sub foo (\@) { say @_ };  foo +(split //, "foobar")
no feature 'signatures'; sub foo { [@_] } sub bar (\@) { [@_] } [foo(1,2,3), bar(1,2,3)]
no feature 'signatures'; sub foo ($) { {thingy => $_[0]} } [foo 1, 2, 3]
no feature 'signatures'; sub sort_subset_by (\@@) { my ($expected, @stuff) = @_; my %in = map { ($_ => 1) } @stuff; return grep { $in{$_} } @$expected; } my @exp = (5,4,3,2,1); my @arr = (2,3,4); [sort_subset_by @exp, @arr]
no feature; sub new { bless [] }; package foo; sub new(*) { bless [] }; [ new main ]
no feature 'unicode_strings'; my $d = my $u; utf8::upgrade($u); utf8::downgrade($d); [ map /\w/, $u, $d ]
no feature 'unicode_strings'; my $d = my $u = "\x{df}"; utf8::upgrade($u); utf8::downgrade($d); [ map 0+/\w/, $u, $d ]
no feature 'unicode_strings'; my $d = my $u = "\x{df}"; utf8::upgrade($u); utf8::downgrade($d); [ map /\w/, $u, $d ]
no feature 'unicode_strings'; "\N{U+666}" =~ /\d/
no indirect; parse backwards;
no indirect; sub main { bless [] }; [ new main ]
"No output."
no overloading; '' . *STDOUT{IO};
no 'strict'
no strict; [ Foo ]
no strict 'refs';  my $lexicalvar = "hello";  ${"lexicalvar"}
no strict 'refs';  our $packagevar = "hello";  ${"packagevar"}
no strict; sub Foo { "Bar" }; [ Foo ]
no strict 'vars'; sub foo { local $n = $n//0; my @p = (shift, $n, $n ? 'N' : 'F'); ++$n; @_ ? (\@p, &foo) : \@p }; { 'one' => [foo('a'..'c')], 'two' => [foo('x'..'z')] };
no strict 'vars'; sub foo { local $n = $n//0; my @p = [ shift, $n, $n ? 'N' : 'F' ]; ++$n; @_ ? [ @p, foo( @_ ) ] : \@p }; { 'one' => foo('a'..'c'), 'two' => foo('x'..'z') };
no strict 'vars'; sub foo { local $n = $n//0; my @p = (shift, $n, $n ? 'N' : 'F'); @_ ? (@p, &foo) : @p }; { 'one' => [foo('a'..'c')], 'two' => [foo('x'..'z')] };
no strict 'vars'; sub foo { local $n = $n//0; my @p = (shift, $n, $n ? 'N' : 'F'); @_ ? (\@p, &foo) : \@p }; { 'one' => [foo('a'..'c')], 'two' => [foo('x'..'z')] };
[ No::Such::Class->import() ]
{ not => 'a block' }
$nothing="a"; print "Nothing found\n" if $nothing !~ /^\w+/;
$nothing=""; if ($nothing !~ /./) { print "Nothing found\n" }
$nothing=""; print "Nothing found\n" if $nothing eq "";
$nothing=""; print "Nothing found\n" if $nothing !~ /^\w+/;
no utf8; encode 'UTF-8', 'Ã¡r jÃº sÃºr?'
no utf8; printf "%vd", "ü"  # does this even work
{no utf8; $x="☃☃☃" }; $x
"no" while "no"
"\N{PILE OF POO}"
[ $., $NR ]
"\N{REGIONAL INDICATOR SYMBOL LETTER Z}\N{REGIONAL INDICATOR SYMBOL LETTER A}"
"\n\r\n"
"\n" =~ /\s/
"\n" =~ /(?[ \s - [\n] ])/ ? "match" : "no match"
"\n" =~ (?[ \s - [\n] ]) ? "match" : "no match"
"\N{SNOWMAN}"
"\N{SPARKLE}"
"\N{SPARKLE}";
[ "\N{SPARKLE}" ]
[ "\N{test}" ]
"\N{U+00A2}"
"\N{U+0B}" =~ /(?[ \s - [\n] ])/ ? "match" : "no match"
"\N{U+1f52b}"
"\N{U+666}" =~ /\d/
$num = 0b00000011111111111111111111111111; [vec($num, 0, 26), vec($num, 26, 6)]
$num = -1.67; int($num + $num / abs($num * 2));
$num = 1; "banana" =~ s/a/$num++/ger
$num = 1; "banana" =~ s/a/"test: ${\$num++}"/ger
$num = 1; "banana" =~ s/a/"test: $num++"/ger
$num = 1; "banana" =~ s/a/test: $num++/ger
$num=2**32; $digits=reverse $num; $digits =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g; $num=reverse $digits; print $num
$num=2**32; $digits=reverse $num; $digits =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g; print $digits;
$num='2**32'; $digits=reverse $num; $digits =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g; print reverse $digist;
$num='2**32'; $digits=reverse $num; $digits =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g; print reverse $digits;
$num=2**32; $digits=reverse $num; $digits =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g; print reverse $digits;
$num="2"; $num = sprintf("%02d", $num); print $num
$num="2"; $num = sprintf("%2d", $num); print $num
@nums = (30, 7, 200, 40, 5, 1000); [ [ sort @nums ], [ sort { $a <=> $b } @nums ] ] # string-sort using default cmp vs numeric <=>
"\N{VERTICAL TAB}" =~ /(?[ \s - [\n] ])/ ? "match" : "no match"
"\N{VT}" =~ /(?[ \s - [\n] ])/ ? "match" : "no match"
"\n" =~ /^/ ? 'y' : 'n'
"\n" =~ /^$/ ? 'y' : 'n'
"\n" =~ /^\z/ ? 'y' : 'n'
$^O
$obj->generic_method();
@occ = 'xxx hihi.so yyy hoho.so' =~ /\w+\.so/g; \@occ
[ oct "0.00_02" ]
oct '0775'
oct '0a'
oct "0b0100100"
[ oct(0b10),oct(0x2),hex(0b10) ]
oct(0b11111);
oct '0b' . '11111111'
oct '0b' . ('1' x 64)
oct "0x10"
[ oct "0x10", hex "010" ]
[ oct "0xa" ]
oct "10"
[ oct "10_00" ]
oct "1_2"
oct "1.2e3"
oct("420)"
oct "4e3"
$_='oh turtleneck
$_='oh turtleneck phrase jar!'; s/.{13}\K.*//s; print;
$_='oh turtleneck phrase jar!'; s/(?<=.{13}).*//; print
$_='oh turtleneck phrase jar!'; s/(?<=.{13}).*//s; print
$_='oh turtleneck phrase jar!'; s/(?<=.{13}).*//s; print;
$_ = "Oh Turtleneck Phrase Jar";  s/(.)/rand(3)>1?lc($1):uc($1)/ge; $_
$_ = "Oh Turtleneck Phrase Jar";  s/(.)/rand(3)?lc($1):uc($1)/ge; $_
$_='oh turtleneck phrase jar!'; s/(?<=\w{13}).*//s; print;
$old = 'abc'; $new = substr($old, 0) = ''; [$old, $new]
$old = 'abc'; $new = substr($old) = ''; [$old, $new]
\@ONC
$_ = "one=1 two=2 three=3"; [ m/(\w+)=(\d+)/gc ]
$_ = "one=1 two=2 three=3"; print $1 while m/(\w+)=(\d+)/gc
$one = 'foobar'; $two = "foobazquux"; $count = () = $one.$two =~ /[$one$two]/g
$one = 'foobar'; $two = "foobazquux"; $count = () = ($one.$two) =~ /[\Q$one$two\E]/g
$one = 'foobar'; $two = "foobazquux"; $count = () = $one.$two =~ /[\Q$one$two\E]/g
$one = 'foobar'; $two = "foobazquux"; $count = () = $two =~ /[$one]/g
$one = "foobar"; $two = "foobazquux"; $i++ while substr($one, $i, 1) eq substr($two, $i, 1); $i
$_ = "one\ntwo\nthree some text four\nfive\n"; [ /(.*some text.*)/ ]
["one two " =~ /(one (two)) (three)?/]
$_ = 'one.two.three'; [ /(.*)\./ ]
$_ = "one two three"; %h = ( one => 1, two => 2 ); s/$_/$h{$_}/ for keys %h; $_
$_ = "one two three"; %h = ( one => 1, two => 2 ); s/$_/$h{$_}/ for keys %h; $_"
["one two three" =~ /(one (two)) (three)/]
$_ = 'one two two three'; $_ =~ s/^.*?two//; $_
'one two two three' =~ 's/^.*?two//r
'one two two three' =~ s/^.*?two//r
[ $^O ] # of course perlbot runs on a massively-distributed network with lots of nodes so the result here may vary
"O.O" =~ s/\./_/r
[ ${^OPEN} ]
open(2, "|df -h")
[ 'openerp-server' =~ m{/([^/]+)$} ]
open $fh, ">", \$str; say($fh 'asdf'); [ $str ]
open $fh, ">", \$str; say($fh $_) for qw,foo bar baz,; [ $str ]
open FILE, "<", "/etc/passwdoeuoe"; print <FILE>
open FILE, "<", "/etc/passwd"; print <FILE>
open $f, "<", "/proc/self/mountinfo"; fileno($f)
open(F,"/usr/share/dict/words");@w=<F>;close(F); $r=rand($#w++); print $r
open(F,"/usr/share/dict/words");@w=<F>;close(F); $r=rand($#w++); print $w[$r]
open(F,"/usr/share/dict/words");@w=<F>;close(F); $r=rand($#w++); $w[$r]
open my $fh, \$altreus; print $fh "I hate you";
open my @fh, '<', '/dev/zero' or die $!; \@fh
open my $fh, '>', \my $buffer; ref $fh
open my $fh, '>', \my $foo or die $!; [$fh, $fh->isa("GLOB"), ref $fh]
open my $fh, '>', \my $foo or die $!; [$fh, $fh->isa("GLOB"), ref $fh, \@GLOB::ISA]
open my $fh, '>', \my $foo or die $!; print ref $fh;
open my $fh , '>', \my $str; [ '' . *$fh{IO} ]
open my $fh , '>', \my $str; [ *$fh{IO} ]
open my $fh , '>', \my $str; [ ref *$fh{IO} ]
open my $fh , q{>}, \(my $str); say $fh q{foo}; [ ref $fh ];
open my($fh), "<", "some file which doesn't exist"; [ $! + 0, "" . $! ]
open my($fh), "<", "some file which doesn't exist"; [ 0 + $!, "" . $! ]
open my $fh, '<', \"xyzwtu"; my $s = "abc"; read $fh, $s, 4, 3; $s
open my $lol, '<', 'lol'; <$lol>
open my $lol, '>', 'lol'; $lol->print("lol");
open( my $ofh, q{>}, q{/tmp/abc.txt} ) or die qq{write: $!}; print $ofh q{abcdefghijklmnopqrstuvwxyz}; close $ofh; open( my $ifh, q{<}, q{/tmp/abc.txt} ) or die qq{read: $!}; my $count = read $ifh, my $chunk, 10, 5; close $ifh; [ $count, $chunk ];
open $out2, '>&=', 2 or warn ">$!<"; $out2->autoflush(1); "".$out2
open undef
[ $^O ] # perldoc -v '$^O' for details
ord '«'
ord '£'
ord '*'
ord '☃'
ord "'"
ord('/')
ord(".")
[ ord "⁰", ord "⁹" ]
[ord "²"]
ord 'a'
ord 'A'
ord('a')^ord('A')
ord chr 0xe9
(ord chr 0xe9) == 0xe9
ord chr 0xe9 == 0xe9
or deparse:?
$#order = 2; $#order
@order = 2; @order and @order = grep $_, @order[-2, -1]
$#order = 2; @order and @order = grep $_, @order[-2,-1]
$#order = 2; @order and order = grep $_, @order[-2,-1];
@order and @order = grep $_, @order[-2, -1]
... or die
ord "\n"
[ord '~', ord ' ']
[ord '.', ord '[']
ord('/') - ord('+')
ord pack 'A', 32
ord pack "B8", "11111110"
ord(split '',a..m=>N..Z)-7
[ord 'ß']
ord unpack 'A', 32
ord "\xFE"
ord 'й'
or evaljs:
$original = "hello"; [ $coded = $original ^ '1' x length $original, $coded ^ '1' x length $coded ]
$_="otmat"; /(?{$name="foo"})re[x]ma|(?{$name="bar"})o[ther]matc/; $name
our $AUTOLOAD = 'cats'; sub cats { "lol" } notlol()
our $baz = 'abc'; package foo; sub bar { our $baz; return ++$baz }; package main; [ foo::bar(), foo::bar(), $foo::baz, $baz ]
{ our $baz = 'abc'; package foo; sub bar { our $baz; return ++$baz }; }; package thisfails; [ foo::bar(), foo::bar(), $foo::baz, $baz ]
our $baz = 'abc'; package foo; sub bar { our $baz; return ++$baz }; package thisfails; [ foo::bar(), foo::bar(), $foo::baz, $baz ]
our $descriptivism++;
our $DIR; BEGIN { $DIR = 'BAR' } say $DIR;
our %foo = 1 .. 2; *foo->{1}
our %foo = 1, 2; (\*foo)->{HASH}
our %foo = 1, 2; *foo{HASH}
{ our $foo = 5;} eval { $foo }; { our $foo . $@ }
our $n = 0; sub foo { local $n = $n; my @p = [ shift, $n ? 'N' : 'F' ]; ++$n; @_ ? do { @p, foo( @_ ) } : \@p }; { 'one' => foo('a'..'c'), 'two' => foo('x'..'z') };
our $n = 0; sub foo { local $n = $n; my @p = [ shift, $n ? 'N' : 'F' ]; ++$n; @_ ? do { @p, foo( @_ ) } : \@p }; { one => foo('a'..'c'), two => foo('x'..'z') };
our $n = 0; sub foo { local $n = $n; my @p = [ shift, $n ? 'N' : 'F' ]; ++$n; @_ ? [ @p, foo( @_ ) ] : \@p }; { 'one' => foo('a'..'c'), 'two' => foo('x'..'z') };
our $n = 0; sub foo { local $n = $n; my @p = [ shift, $n, $n ? 'N' : 'F' ]; ++$n; @_ ? [ @p, foo( @_ ) ] : \@p }; { 'one' => foo('a'..'c'), 'two' => foo('x'..'z') };
our sub Bulgaria { print caller; } package Wimbledon; Bulgaria()
our $varname = "womble"; ${$varname} = "Bulgaria"; print "Uncle $womble"
our $x = "\
{ our $x = "dogs" } { our $x; print $x }
our $x="\n"; $x = chomp $x; $x
our $x = 'package'; my $x = 'lexical'; { our $x; print $x }
our $x; sub lala { \$x } [\$x, lala()] # also identical
our %y; our $x = 5; *{y{x}} = *x; $y = 3; [ $x, \%y ]; ### I saw this in some code I was reviewing, which I think was someone trying to alias a hash key to a variable, similar to *x = *y, but it doesn't seem t owork (maybe for an old Perl?)
@output=`df -h`; for my $line (@output){ print $line if $line =~ /procfs/ }
[ overload::Overloaded( 'Regexp' ) ]
[ overload::Overloaded( v1.2.3 ) ]
[ overload::Overloaded( 'version' ) ]
overload::StrVal bless {}, "Whatevs"
%p = (1,2); @array = values %p; s/\d// for @array; \%p
%p = (1,2); s/\d// for keys %p
%p = (1,2); s/\d// for keys %p; \%p
%p = (1,2); s/\d// for values %p; \%p
$P2::x = "P2"; package P1; our $x = "P1"; package P2; $x
$P2::x = "P2"; package P1; $x = "P1"; package P2; $x
pack "a", 0x32;
pack "a", 0x33;
pack '(a)*', 123456 =~ /.(.)(?<=(.).)/g
pack 'a', 32
pack 'A', 32
pack 'a', 48
__PACKAGE__
[ __PACKAGE__ ]
package A; sub new { bless {}, ref $_[0] || $_[0]; } sub foo { [ $_[0], q{A:111} ]; } package B; our @ISA = qw(A); package C; our @ISA = qw(A); package D; our @ISA = qw(B C); package main; my $d = D->new; [ $d->foo, $d->B::foo, $d->C::foo, $d->A::foo ];
package A; sub new { bless {}, ref $_[0] || $_[0]; } sub foo { [ $_[0], q{A:111} ]; } package B; our @ISA = qw(A); sub foo { [ $_[0], q{B:222} ]; } package C; our @ISA = qw(A); sub foo { [ $_[0], q{C:333} ]; } package D; our @ISA = qw(B C); package main; my $d = D->new; [ $d->foo, $d->B::foo, $d->C::foo, $d->A::foo ];
package A; sub x { q{A::x}; } package B; sub x { q{B::x}; } package C; sub x { q{C::x}; } package main; [ map { $_->can( q{x} )->() } qw(A B C) ]; ### litewait
package Blah { sub foo { print "eh" } } Blah::foo()
package Blah { sub foo { print "eh" } } foo()
package Cats; our $meow; our $mewl = '>:('; package main; \%Cats::
package Cats; our $meow; package main; \%Cats::
package C; sub new { bless {}, ref $_[0] || $_[0] } package main; my $foo = sub { [ @_ ] }; my $c = C->new; $c->$foo( 1..3 );
package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; \&foo;
package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; $c->(\&foo)->( 1..3 );
package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; $c->(\&foo)( 1..3 );
package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; $c->${\\&foo}( 1..3 );
package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; $c->\&foo( 1..3 );
package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; my $name = "foo"; $c->$name( 1..3 );
package C; sub new { bless {}, ref $_[0] || $_[0] } package main; sub foo { [ @_ ] }; my $c = C->new; my $ref = \&foo; $c->$ref( 1..3 );
package C; sub new { bless {}, ref $_[0] || $_[0] } sub foo { 111 }; package main; my $o = \&C::foo; { no warnings qw/redefine/; *C::foo = sub { 222 }; } my $c = C->new; [ qq{$o}, q{}.\&C::foo, $c->foo, $c->$o ];
package C; sub new { bless {}, ref $_[0] || $_[0] } sub foo { 111 }; package main; my $o = \&C::foo; undef &C::foo; *C::foo = sub { 222 }; my $c = C->new; [ qq{$o}, q{}.\&C::foo, $c->foo, $c->$o ];
{ package damnit; sub a { "" } } tr/// for a damnit
package dedicated::dedicated.fr {}
package Don; sub t { 'cats' } package main; Don't;
package DudeUseMoo { sub moot { bless {} } } $m = DudeUseMoo->moot; $m->{asdf} = 'blah'; $m->{asdf}
package DudeUseMoo { sub moot { bless {} } sub whurble { my $self=shift; $self->{asdf} } } $m = DudeUseMoo->moot; $m->{asdf} = 'blah'; $m->whurble
{ package FF; sub TIESCALAR { my ($c, $v) = @_; bless \$v, $c } sub FETCH { my $v = ${$_[0]}; ${$_[0]} = -${$_[0]}; $v } } sub frob :lvalue { my ($v) = @_; tie $v, "FF", $v; $v } sub List::Util::0sum {my ($a, $b)=(0,0); $a+=$_, $b-=$_ for @_; ($a, $b)}; [List::Util::0sum(map frob($_), 1,2,3,4,5)]
package Foo 1.0; 'how long has that <-- with the version, worked?'
package foo; $bar = 1; package quux; print $main::foo::bar;
package foo; our $AUTOLOAD; sub AUTOLOAD {print "The method called was: $AUTOLOAD"}; package main; foo->gooblegobble();
package foo { our $bar = 'baz' } ["blah $foo::bar"]
package Foo; our $foo = 42; package main; my $z = 'Foo';  \%{$x}::
package Foo: our $var;  package Splot; $var = 3; print $Foo::var;
{ package Foo; our $x = "foo"; package Bar; $x = "bar"; } [ $Foo::x, $Bar::x ]
package Foo; sub bar { 42 }; package main; my $x = bless {}, 'Foo'; my %foo = ( bar => 'bar' );  $x->can($foo{bar})->()
package foo; sub bar { 'ok' }; package main; use base 'foo'; [ main->SUPER::bar ];
package foo; sub bar { 'ok' }; package main; use base 'foo'; package other; [ main->SUPER::bar ];
package foo; sub bar { our $baz; "[". ++$baz . "]" }; [ bar(), bar(), $baz ]
package foo; sub bar { our $baz; "[". ++$baz . "]" }; [ bar(), bar(), $foo::baz ]
package foo; sub bar { our $baz; package fizzbuz; "[". ++$baz . "]" }; [ bar(), bar(), $baz ]
package foo; sub bar { our $baz; print ++$baz }; [ bar(), bar(), $foo::baz ]
package foo; sub bar { our $baz; print ++$baz }; print bar(); print bar(); print $foo::baz;
package foo; sub bar { our $baz; return ++$baz }; [ bar(), bar(), $foo::baz ]
{ package Foo; sub DESTROY {} } sub bar; bar Foo;
{ package Foo; sub DESTROY {} } sub bar; bar Foo 1;
package Foo; sub d { return "lala" } package main; my $c = bless {}, 'Foo'; $c->d()
package foo; sub new {[1]} package bar; foo->new
package Foo; sub new { bless [], shift } package main; my $sub = sub { my $self = shift; "$self" }; my $obj = Foo->new; $obj->$sub  # lawrence_
package Foo { sub new { bless {}, shift } sub bar { [@_] } } [Foo::bar(1,2,3), Foo->bar(1,2,3), Foo->new->bar(1,2,3)]
package Foo { sub new { my $self = shift; bless {@_}, $self } } my $foo = Foo->new(key => 'value'); $foo->{key};
package Foo { sub new { my $self = shift; bless {@_}, $self } sub get_key { my $self = shift; return $self->{+shift} } } my $foo = Foo->new(key => 'value'); $foo->get_key('key'); # with an accessor method
package Foo; sub x { \@ARGV; } package main; @ARGV = qw( A B C ); Foo::x;
package Foo; sub x { \@main::ARGV; } package main; @ARGV = qw( A B C ); Foo::x;
package Foo; use overload 'bool' => sub { 0 }; sub new { bless {}, shift }; package main; Foo->new() ? 't' : 'f'
package Foo; use overload q{""} => sub {42 }; package main; my $x = bless {}, 'Foo'; 'foo'->$x
package Foo; use overload q{""} => sub {42 }; package main; my $x = bless sub{ 45 }, 'Foo'; [ 'foo'->$x // 'z', "$x" //'z' ]
package Foo; use warnings; sub foo { undef()+0 }; package main; ${Foo::^WARNING_BITS}=0; Foo::foo();
package Foo; use warnings; sub foo { undef()+0 }; package main; $Foo::{^WARNING_BITS}=0; Foo::foo();
package Foo; use warnings; sub foo { undef()+0 }; package main; no warnings; Foo::foo();
package Foo; use warnings; sub foo { undef()+0 }; package main; { package Foo; no warnings; Foo::foo(); use warnings; }
package Foo; use warnings; sub foo { undef()+0 }; package main; $SIG{__WARN__}=sub{}; Foo::foo();
{ package Foo; $x = "foo"; package Bar; $x = "bar"; } [ $Foo::x, $Bar::x ]
[ __PACKAGE__, __FUNCTION__ ]
package ImARegex; sub match { $_[1] =~ $_[0] ? 1 : 0 } package main; my $re = qr/hai/; bless $re, 'ImARegex'; $re->match('chair')
package ImARegex; sub match { $_[1] =~ $_[0] ? 1 : 0 } package main; my $re = qr/hai/; bless $re, 'ImARegex'; $re->match('char')
package lala; my $x = 123; package lulu; $x
package mac { sub ska { 'ca' } } "ce${\mac->ska}"
Package->method
package My; my My $my :Delilah;
package mypackage.pm; # although I'd guess perl should already be complaining about it
{ package MyProject::whatever; sub doSomething { print 'test' } } my $class = 'whatever'; *{"MyProject::${class}::doSomething"}{CODE}() # but really don't do this
package My::Thing { sub validate_rules { { cat => qr/meow/, cow => qr/moo/ } } } my $klass = "My::Thing"; $klass->validate_rules
package Object; sub speak { print "Hello" };    sub before { my ( $name, $code ) = @_; my $orig = Object->can( $name ); *$name = sub { $code->(); $orig->() }; }   around speak => sub { print "But first..." }     Object->speak
package Object; sub speak { print "Hello" };    sub before { my ( $name, $code ) = @_; my $orig = Object->can( $name ); *$name = sub { $code->(); $orig->() }; }   before speak => sub { print "But first..." }     Object->speak
package Object; sub speak { print "Hello" };    sub before { my ( $name, $code ) = @_; my $orig = Object->can( $name ); *$name = sub { $code->(); $orig->() }; }   before speak => sub { print "But first..." };     Object->speak
{ package Plip; use overload '""' => sub { 'plop' } } $x = bless [], 'Plip'; "plup $x"
package P; sub new { my $class = @_ && ( $_[0]->isa( __PACKAGE__ ) || $_[0] eq __PACKAGE__ ) ? shift : __PACKAGE__; bless +{ @_ }, ( ref $class or $class ); } package main; P->new( foo => 123, bar => 456 );
package P; sub new { my $class = @_ && ( $_[0]->isa( __PACKAGE__ ) || $_[0] eq __PACKAGE__ ) ? shift : __PACKAGE__; bless +{ @_ }, ( ref $class or $class ); } package main; P::new( foo => 123, bar => 456 );
package P; sub new { my $class = @_ && ( $_[0]->isa( __PACKAGE__ ) || $_[0] eq __PACKAGE__ ) ? shift : __PACKAGE__; bless +{ @_ }, ( ref $class or $class ); } package main; P::new( P => 123, bar => 456 );
package P { use overload '""' => sub { "07" }, '0+' => sub { "01" } } (bless {}, "P") + (bless {}, "P")
package P { use overload '""' => sub { "07" }, '0+' => sub { "01" } } oct(bless {}, 'P')
package P { use overload '""' => sub { "07" } } oct(bless {}, 'P')
package q; sub qq {"qqq"};package main; *main::notq = \&q::qq; [notq()]
package q; sub qq {"qqq"};package main; my $code = \&q::qq; [$code->()]
{ package Regexp; use overload '""' => sub { 'overload' }, fallback => 1 } my $x = bless qr/loves/, 'Regexp'; [ "$x", re::regexp_pattern($x) ] # then there are those who just like to watch the world burn
package Some::Class; sub class_method { my $class = shift; print "in class method" }  package main; Some::Class->class_method;
package 㐁; sub foo {3} package main; 㐁::foo()
package TerribleThing { sub new { bless {}, shift } sub DESTROY { undef $@ } } eval { die TerribleThing->new }; [$@]
package TerribleThing { sub new { bless {}, shift } sub DESTROY { undef $@ } } eval { my $foo = TerribleThing->new; die 1 }; [$@]
package test; sub new { my $class = shift; my $props = { property => shift }; bless $props, $class; return $props; } 1; my $tester = new test("thisproperty"); my $longstring = << 'EOF'; long long string\n\n$test->property\n\nEOF; print $tester;
package tm406; sub is_gandalf { 1 }; return "TRUE" if(tm406->is_gandalf());
{ package Try; use Function::Parameters qw(:strict); method stuff($class: $x) { $x + 1 } } Try->stuff
{ package X; sub DESTROY { print "<>\n"; } } my $sub = sub { my $x = bless [], "X"; sub { "ok" } }->(); print "main\n"; print $sub->()
{ package X; sub TIEHASH { bless [], $_[0] } sub AUTOLOAD { my $r = shift; push @$r, [our $AUTOLOAD, @_] } } tie my %x, 'X'; %x = "A" .. "D"; tied %x
{ package X; sub TIEHASH { bless [], $_[0] } sub AUTOLOAD { push @{$_[0]}, our $AUTOLOAD } } tie my %x, 'X'; %x = "A" .. "D"; tied %x
{ package X; sub TIEHASH { bless [], $_[0] } sub CLEAR {} } tie my %x, 'X'; %x = (1, 2);
{ package X; sub TIEHASH { bless [], $_[0] } } tie my %x, 'X'; %x = ();
{ package X; sub TIEHASH { bless [], $_[0] } } tie my %x, 'X'; %x = (1, 2);
{ package X; sub TIESCALAR { bless [] } sub FETCH { state $x = 5; $x++ } } tie my $foo, X::; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say "surprise!" }
{ package X; } tie my %x, 'X'; %x = ();
{ package X; use overload fallback => 1, '0+' => sub { state $x = 5; $x++ }; } my $foo = bless [], X::; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say "surprise!" }
package X; use overload '""' => sub { print "string"; "x" }, '.' => sub { print "concat"; "x" }; sprintf '%s', (bless {}, 'X');
package X; use overload '+' => sub { print "X"; }; package Y; use overload '+' => sub { print "Y" }; [ (bless {}, 'X') + (bless {}, 'Y') ]
package X; use overload '+' => sub { print "X"; }; package Y; use overload '+' => sub { print "Y" }; [ (bless {}, 'Y') + (bless {}, 'X') ]
package XYZ; my @FIELDS = qw(one two); for my $field (@FIELDS) { *$field = sub { shift->{$field} }; } my $obj = bless {one => 1, two => 2, five => 5}, 'XYZ'; $FIELDS[1] = 'five'; [ map $obj->$_, qw(one two) ]
package XYZ; sub somesub { "called with @_" } [ XYZ::somesub('x', 'y'), XYZ->somesub('x', 'y') ] # they don't have to be class methods, you can use the package namespace without importing it into the current scope
pack '(a)*', map +(/.(.)/g,/(.)./g), "123456"
pack '(a)*', sort {$|--} "tuJsa nohterP er lhakcer," =~ /./g
pack 'B*', ~0
pack "b*", "00101010000101101001011011001110"
pack 'B*', '0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010'
pack "b*", 0b010101010;
pack "(b8)*", "00101010","00010110",10010110,11001110
pack "(b8)*", "00101010","00010110",10010110,11001110'
pack "(b8)*", 00101010,00010110,10010110,11001110
pack('b8','01010100')
pack('B8','01010100')
pack('(b8)*',"0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010" =~ /.{8}/g);
pack "B8", "11111110"
pack "(b8)*", split ' ', "00101010 00010110 10010110 11001110"
pack "(b8)*", split/(.{8})/, "00101010000101101001011011001110"
pack('b8'x11,"0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010");
[ pack "B*", pack "C*", (1) x 7, 0 ]
pack "c", 127;
pack "C16", (0)x10, (0xff)x2, split /[.]/, "192.168.0.1"
[ pack 'c', 48 ]
pack "c", 99;
pack "c", 9999;
pack "cc", 9888, 9999;
pack "cc", 98, 99;
[ pack '%c', map { $_ & 1 } unpack '%c', 'asdf1111' ]
pack "c*", map { hex } "30313133" =~ /([[:xdigit:]]{2})/g
pack "C*", qw|137 80 78 71 13 10 26 10|
[ pack "C*", qw|137 80 78 71 13 10 26 10| ] # throw Data::Dumper at it
packege Whatever; # looks like an error to me, man
pack "f*", 1,2,3;
[ pack 'F', (9/10-1)*100 ]
pack 'H*', '00001c00';
pack("H*", 0x80 + 1)
pack '(H2)*', split /\./, sprintf '%vx', 'one way to do it'
pack "h", "41"
pack 'H*', '41'
pack("H*", 41)
[ pack("H*", 4120422043), pack("h*", 1402240234) ]
[ pack("H*", 4120422043), unpack("H*", "A B C") ]
pack "H*", "42424242"
[ pack "H*", "49440953" ]
pack 'h*', '6363735f7263'
pack 'H*', '6363735f7263'
pack 'H*', "6578616d706c65206865782064617461"
[ pack "H*", "6d73616e64626f78" ]
pack "H*", '7061756c'
pack "H*", "7468697320697320612074657374"
~pack "H*", '9e9b929691'
pack "H*", '9e9b929691'
pack "H*", ${\chr 24}
pack 'H*', '\x41\x41' =~ tr/\\x//dr
[ pack 'N', 42 ]
pack 'N/a*', { cool => 'story, bro' }
pack 'n*', unpack 'v*', "123456"
pack 'q', 7378717377743452252
pack "s>", 25
pack('V' . 0xfffffff)
pack('V' . 0xfffffff);
pack('V31337000');
[pack 'V', 85]
pack('V' . 99999990);
[pack "(Z*)*", qw(foo bar baz)]
$page_content="http://www.liveleak.com/view?i=abcd"; if ( $page_content =~ /http\:\/\/www\.liveleak\.com\/view\?i\=(\w+)/ ){ $ids = $1 }; print $ids;
$page_content='http://www.liveleak.com/view?i=abcd'; if ( $page_content =~ m!http://www\.liveleak\.com/view\?i=(\w{14})!g; ){ $ids = $1 }; print $ids;
$page_content='http://www.liveleak.com/view?i=abcd'; my @ids = $page_content =~ m!http://www\.liveleak\.com/view\?i=(\w{14})!g; print @ids;
$page_content="http://www.liveleak.com/view?i=abcd"; $page_content =~ s/http\:\/\/www\.liveleak\.com\/view\?i\=(\w+)/$1/g; print $page_content;
$page_content="http://www.liveleak.com/view?i=c77_1406577312"; $page_content =~ s/http\:\/\/www\.liveleak\.com\/view\?i\=(\w+)/$1/g; print $page_content;
$page_content="http://www.liveleak.com/view?i=qwerty"; if ( $page_content =~ /http\:\/\/www\.liveleak\.com\/view\?i\=(\w+)/ ){ push (@ids,$1); }; print @ids;
"/page/save/2202440;294ac50e,315fb991" =~ m{page/} ? 'match' : 'nope'
"/page/show/2202440" =~ m{page/} ? 'match' : 'nope'
"/page/show/2202440" =~ {page/} ? 'match' : 'nope'
[ "parachute! ahh I'm falling!" =~ s/(?<=chute).*//r ]
[ "parachute!" =~ s/(?<=chute).*//r ]
[ "parachute" =~ s/(?<=chute).*//r ]
parse backwards
" part isn't necessary in your actual code; it's just for interacting with the IRC bot
$pattern = "oo"; return [ "foo" =~ /$pattern/, "bar" =~ /$pattern/ ];
$pattern = "oo"; return [ "foo" =~ /$re/, "bar" =~ /$re/ ]; # voila!
#!perl
"Perl"^2
perl -e "my @res = map { substr($_, 0, length($_)-1) if (-f substr($_, 0, length($_)-1) } qw(dupes.txt allfiles.bak.txt hahaha.setnhue); print join(' ', @res) . "\n";
`perl -e 'print "$]"'`
perl -e 'print "$]"'
perl -E 'say for @INC'
perl -e 'use DateTime; print DateTime->now->year."w".DateTime->now->week_number'
perlev ' [ unpack q{N}, pack q{H8}, q{6060FF} ] ' # alanjf
[ PerlIO::get_layers(*STDIN) ]
perl -p -e "s/\/\/a\[contains\(text\(\),'(\w+)'\)\]/$1/g" <<< //a[contains(text(),'Korel&nbsp;&nbsp;Göymen')]
`perl -v`
perl -v
"#########PermitRootLogin no way man" =~ s/#*(PermitRootLogin\sno)/$1/r
'phd defense' gt 'php defense'
@phone =~ /^0$/
@phone = 0; @phone =~ /^1$/
@phone = 1; @phone =~ /^1$/
"pobox" eq "pоbox"
pop @{politics}
POSIX::fmod(-10, exp 1)
POSIX::strftime("%b %d", localtime)
POSIX::strftime "%Y-%H-%m %d:%M", localtime
[POSIX::strftime '%Y%m%d_%H%M', localtime]
POSIX::strftime "%y-%M-%D %h:%m:%s", localtime
POSIX::strftime "%Y%m%d%H%M%S", localtime 1395698781
@pos = (); push @pos, @- while 'hangman' =~ /n/g; \@pos
$_='post hoc ergo propter hoc'; s/./rand(3)>1?lc($&):uc($&)/egr;
@pos = (); $word = 'hangman'; $guess = 'n'; push @pos, @- while $word =~ /$guess/g; \@pos  # vaskozl
$predicate = 1; $true = {foo => 2}; $false = {}; [exists($predicate ? $true->{foo} : $false->{foo}) ? "Y" : "N"]
$price = '16.60'; ($dollar,$cents)=$price=~/(\d+)\.(\d+); $dollar++ if $cents > 0; print $dollar
$price = '16.60'; ($dollar,$cents)=$price=~/(\d+)\.(\d+)/; $dollar++ if $cents > 0; print $dollar
print
\&print
print ''
print '$]'
print '\\'
print "`*`";
print "-"
print ""
print "[@_]";
print "$,"
print "$;"
print "$]"
print "–"
print @_;
print $/
print $]
print $];
print $@
print $$
print;
print "0"
print "01"
print(0.3 + 0.3 + 0.3 - 0.9);
print "0"; '' # and it's gone
print '0' x 1 . '9'
print 1
print 1;
print 1 + 1;
print(1+2)/2
print 123
print (.1 + .2 == .3)
print " 1234567 " =~ /[0-9]{7} /;
print " 12345678 " =~ / [0-9]{7} /;
print " 12345678 " =~ /[0-9]{7} /;
print 155.0 / 3.0
print (1/999)*999
[print 2]
print "2"
print "2" && print @+
print "2" && print $!
print "2" && print $?
print (3+undef)/2
print4
print (7 + 5) * 13, "\n";
(\&print)->('a')
print "\a"
print {@a}->{a}
print +{@a}->{a}
$, = '!'; print 'a', 'b'.'c';
$, = '!'; print 'a'.'b','c';
$, = '!'; print 'a'.('b','c');
print 'a', 'b'.'c';
print "abc$^Hdef"
print "a"; die "an error"
print 'alive'; eval q![ 'a' x 1e12 ]!
print $a="[[ \"pos\" ], /\"(/d+)\"/]", "\n"; my $result = eval($a) or die $@;
print $a="[[ \"pos\" ], /\"(/d+)\"/]", "\n"; print ref(eval($a)),"\n";
print "as a brit i prefer" . ( rand() < 0.1 ? "spicey foods" : "boiled cabbage"
print "as a brit i prefer" . ( rand() < 0.1 ? "spicey foods" : "boiled cabbage" )
print "a" x "b";
print "bottle\n" x 2;
print "bottle" x 2;
print (caller(0))[8]
print `cat /dev/urandom`
print 'cats'
print "cats"
print "${chr(24)}"
print chr 8305
print chr length q q continue q
print chr ord for qw q hasdfsadfsadf aasdfdsafasdf chasdfadsfadsf kasdfadfasdf easdfsfdsdf refwefsadfsadfa q
print $code
{ print 'Considered'; last; print "fun"; } print ' harmful by some, for this reason.'
print crypt('Gil*321T','$');
print cwd();
print DateTime->now->week_year
print("Debug\n"), return 1 if (1);
print do { if (0) { 1 } else { 2 } }
print do { if (1) { 1 } else { 2 } }
print Dumper @_
print `echo 1`
print "Enter number 1: ", $a1 = <STDIN>;
print(%ENV);
print $ENV{1} . "\n";
print $ENV{'TZ'}
print $ENV{'TZ'};
print $ENV{TZ};
print eval +{print "2"}
print eval('system("dir")')
print exec("dir")
print exec("ls")
printf "%04o\n",0777;
printf "%04o\n",07777;
printf "%04o\n",$mode->mode & 07777;
printf "%08b\n%08b\n%08b\n", 0xff, 0x7f, 0xff & 0x7f
printf " %08b ", ord "a"
printf '%2$-2s%1$s', qw(a b) # you're trying to write a script to do this, or is there more to it?
printf '%-2$p', sub {}
printf "%.40f\n", 3.141592653589793238462643383279502884;
printf "%.6f", 6.437370834e-01
printf "%.6f", 6.437370834e+01
printf "%.6f", 6.437370834e-06
printf "%.6f", 6.437370834e+06
printf '%b', ord ' '
print fc("ł") cmp fc("z")
printf(“%d”, 1.9)
printf('%d%%', (45/50-1)*100)
printf('%d%%', (9/10-1)*100)
print "floo"
\&print->("foo")
print "foo"
print "foo" if ("/page/show/1234" =~ m{page/});
print foo(); my $x = 213; sub foo { $x }
print for 1..4
print for aaaa.zzzz
print for aaaa..zzzz
print for (a..z, 0..9, A..Z);
print foreach 1..5
print $_, $/ for @INC
print for @INC
print "$_," for sort ( 99, 111 )
print "<<$_>>" for 'this is a test' =~ /.../g;  # hehehe
print/..(..?)/ for[],{},$"x3,\&f,\0
printf q{%.8f}, 155.0 / 3.0
printf q{%f.8}, 155.0 / 3.0
printf ?say\n?
printf("%s\n", "I'm so unruly bot ...");
printf "%*v08b", " ", "hello"
printf "%vd %s", chr hex "2665", chr hex "2665"
printf "%vd", "ü"
printf '%x' ord ':'
printf '%x', ord ':'
print gmtime() , "\n";
print 'Good night';
print grep { /\d/ } map { chr } 0x11067..0x10ffff # for Grinnz_
print "hello"
print "Hello";
print "hello"; 2+2
print "hello\n";
print "hello\nworld"
@{ print "hello"; print " world"; [] }
print "hello world";
print "Hello world!";
print "Hello, world!";
print "hello world\n"
print "hi";
print "hi\tsir\n"
print "hi".(" " x 4)."there\n";
print "i bought a "; rand()<0.5 ? 'coke' : 'root beer'
print "i bougth a " . (rand()<0.5 ? "coke" : "root beer" )
print "I'm a Perl ", 5 + !!"0", " program."
print @INC;
print "is about to flood the channel"
print join ",",  grep { $_ % 2 == 0 } (1..50)
print join(", ", @INC);
print join(":", keys %ENV);
print join('',map {chr $_} (97, 98, 99))
print join ('x', "a","b","c","d");
print join x => a => b => c => d =>
print "ł" cmp "z"
print localtime()
print localtime();
print `ls`;
print `ls /tmp`
print map { "(".$_.")" } "a:1 b:2 a:3 b:4 " =~ m/^((a:\d+ )(b:\d+ ))*/
 print map (lc,('ABC','DEF','GHI'));
 print map (lc,(’ABC’,’DEF’,’GHI’));
 print map { lc } qw/ ABC DEF GHI /;
print map { $x++ } 1..10
[ print "Miesco", print "Miesco" ]
print "Miesco", print "Miesco"
print("Miesco"), print("Miesco")
print my @arr[2];
print my $arr[2];
print "\n"
print "$_\n" for 'this is a test' =~ /.../g;  # hehehe
print "No output."
print "$^O";
print oct("420)"
print("oh yes, entire nothings")
print "ok" if "å" =~ /[[:alpha:]_]/
print "ok" if "å" =~ /[[:alpha:]_]/a
print "ok" if "_" =~ /[[:alpha:]_]/
print "ok" if "_" =~ /[[:alpha:]]/
print ord "¢"
print ord('a'), " ", ord('а');
print ord('a'), ord('а');
print ord pack "cc", 9999
print ord " "
print "Perl is easy";
print ${ print 'foo'; \'bar' };
print print print print print
print "PRIVMSG ##microsoft hello";
print prototype('CORE::sprintf')
print q/foo/
print q{foo} while 0;
print '[', $_, ':', quotemeta($_), ']' for q{\/}, qq{\/};
print quotemeta 'test@example.com'
print { (rand() < .5) ? STDOUT : STDERR } 'foo'
print { rand < .5 ? STDOUT : STDERR } 'foo'
print"RASH DEAL"
print reverse ("7c86467b");
print ( reverse sort ( 1..9 ));
print round(0.5)
print s/..(..).*/$1/r for[],{},$",\&f,\0
print s/..(..).*/$1/r for(...there you go
print scalar "321" =~ /\d+/;
print scalar (a..b)
print scalar a..b
print scalar "abc" =~ /\d+/;
print scalar gmtime() , "\n";
print scalar gmtime time();
print scalar localtime 1416907528
print scalar localtime 1427744321029
print scalar localtime (1427744321029/1000)
print scalar localtime(1450370812)
print scalar localtime gmtime();
print scalar localtime $^T
print scalar localtime time
print scalar localtime time;
print scalar localtime time()
print scalar localtime time();
print scalar loclatime $^T
print scalar reverse "my string"
print scalar $^T
print $self
print ( sort ( 1..9 ));
print sort 97..102
print "$_," sort ( 99, 111 );
print sort ( 99, 111 );
print sort ( printf("%d", rand(100)), printf("%d", rand()) )
print sort qw( 1 5 2 3 7 4 6 9 8 0);
print sort { (rand()) <=> (rand()) }
print sort { (rand()) <=> (rand()) } qw(a b c d);
print sort { rand <=> rand } qw(a b c d);
print sort { rand() <=> rand } qw(a b c d);
print sort {$|--} "tuJsa nohterP er lhakcer," =~ /./g
print sprintf("Hello %s!", uc "Corin");
print sqrt length "zomg"
print {STDOUT} 1,2;
print STDOUT chr 8305
print system("dir")
print system("ls")
print $t
print $^T
print test
print 'test'
print "test"
print $this_variable_does_not_exist;
print "Time for coffee" if $!{ENOCAFFIENE}
print true
print ^T => scalar localtime time => time
print uc sprintf("Hello %s!", "Corin");
[ print => undef ]
print undef => 1
print ${^UNICODE}
print unpack("b8", "a")
print `uptime`
print $^V
print v128169
print v3232.95.3232
print v9825
print '$variable'
print "very well"
print "$_ " while $_ = glob 'test' =~ s/([a-z])/{\l$1,\u$1}/gir  # what was wrong with this ?
print "\x{0622}"
print $x=1, $x=2, $x=3, $x=4, $x=5;
print '-' x 35 . "\n";
print '-' x 35."\n";
print "\x{ffff}"
print "\xffff"
print \xffff
print "x" for qw(1 2 3);
print "Yes we do";
product 1..10
prototype \&CORE::bless
prototype 'CORE::bless' ? 'yes' : 'no'
prototype "CORE::glob"
prototype \&CORE::join
prototype \&CORE::lc
prototype 'CORE::open'
prototype "CORE::open"
prototype "CORE::pack"
prototype \&CORE::print
prototype \&CORE::prototype
prototype 'CORE::push'
prototype "CORE::push"
prototype(\&CORE::push)
prototype 'CORE::ref'
prototype \&CORE::ref
prototype \&CORE::sleep
prototype 'CORE::sort'
prototype 'CORE::splice'
prototype(\&CORE::split)
prototype \&CORE::substr
prototype 'CORE::undef'
prototype "CORE::warn"
prototype "CORE::write"
prototype sub :proto($$) {}
provides scalar context
prtin 1
@P=split//,".URRUU\c8R";@d=split//,"\nrekcah xinU / lreP rehtona tsuJ";sub p{ @p{"r$p","u$p"}=(P,P);pipe"r$p","u$p";++$p;($q*=2)+=$f=!fork;map{$P=$P[$f^ord ($p{$_})&6];$p{$_}=/ ^$P/ix?$P:close$_}keys%p}p;p;p;p;p;map{$p{$_}=~/^[P.]/&& close$_}%p;wait until$?;map{/^r/&&<$_>}%p;$_=$d[$q];sleep rand(2)if/\S/;print
$_="psychology"; print reverse;
$_="psychology"; tr/a-z/z-a/g; print;
$_ = 'psychology'; $za = join('', reverse 'a' .. 'z'); eval "tr/a-z/$za/"; $_
$_ = 'psychology'; $za = join('', reverse 'a' .. 'z'); eval "tr/a-z/$za"; $_
$_ = 'psychology'; $za = join('', 'z' .. 'a'); eval "tr/a-z/$za"; $_
'pthr bots' =~ tr/op/io/r
'·' =~ /[[:punct:]]/
'§' =~ /[[:punct:]]/
push @_, !
[push [], 1]
push (@_,"alpha"); push (@_,"omega"); print "Grinnz_ is the $_[0] and the $_[$#_]\n"
$|++; push @a, $|; $|--; push @a, $|; $|--; push @a,  $|; \@a
[ push [], 'a' ]  # thus
push foo, 1, 2
(++$_ && push(@foo, $_)) for 1..10; join ',',@foo;
push @foo, glob "/" for (1..10); \@foo
push $hash{foo}, 'something'; \%hash
push $hash->{foo}->@*, "wibble"; $hash
push @{ $href->{key} }, qw(a b c); $href
push @l, $-[0] while "banana" =~ /b|a|n/g; [@l]
push @players, [ "Dealer", "", "" ]; push @players, [ "AcidRain", "50", "" ];     [ @players ]
push @strings, $_ =~ m/^\w*/
push @strings, [$_ =~ /^\w+/];
push @{$x->{foo}}, 'bar'; push @{$x->{foo}}, 'baz'; $x  # or with $x not even hodling anything to begin with
`pwd`;
q 😁 :) 😁
q{}
q{\}
/\Q[/
"\Q!"
$_ = q("...); /()(.)/; [$2]
q5.22.0
q{"90020",33.786594,"-118.298662","Los Angeles","CA","Los Angeles"} =~ s/^(".+").+$/$1/r
q \ a\ b\ c ;
[ q{abc def 123 ghi} =~ m/\b([A-Za-z]+)\b/g ]; # Where as this matches all three.
[ q{abc def 123 ghi} =~ m/(?:^|\s)([A-Za-z]+)(?=\s|$)/g ]
[ q{abc def 123 ghi} =~ m/(?:^|\s)([A-Za-z]+)(?:\s|$)/g ]; # Why doesn't 'def' get matched?
$_= q/a b c d e f g/; @vars = (split)[2]; \@vars
$_= q/a b c d/; @vars = (split)[2,3]; \@vars
q aeven thisa
$_=q{an if1 " some if2 " then "if3" not if4!!};  [ /(if\d)(?=(?:[^"]|"[^"]*")*$)/g ]
$_=q{an if1 " some if2 " then "if3" not if4!!};  [ /"[^"]*"(*SKIP)(*F)|if\d/g ]
q caller vec
["\Q$code"]
$_ = q,echo foo bar=baz hmm="1 2 3" nn='aa bb',; my @h; s/((["'])(?:[^"']+|\\.|(?!\2).)*\2)/push @h, $1;"\xFFFD"/ge; my @words = split ' '; s/\xFFFD/shift @h/ge for @words; \@words;
[ q{$ENV{HOME}}, qq{$ENV{HOME} ];
[ q{$ENV{HOME}}, qq{$ENV{HOME}} ];
q\foo\
q\foo\\bar\
"\Qf(o+o*)\Ebar"
"\Qfoo\Ebar"
q\foo\ =~ m\foo\
q\foo\ =~ s\foo\bar\r
q{foo} x 2.5 # Would be interesting if this coudl actually produce a sub string.
q ̈hellö
q̈hellö
q̈hellö . ""
q{I think perl bot is down?}
qq("")
qq("\")
qq(\)
q qa b c ' dq # great idea
q qaq =~ m\a\
qq'$bar'
qq(foo\tbar)
[ qq(hello there "test test" more testing) =~ /"([^"]+)"|(\S+)/g ]
[ qq(    "  some extra spaces " hello there "test test" more testing) =~ /"([^"]+)"|(\S+)/g ]
[ qq(  "space1   "   space2 ) =~ /"([^"]+)"|(\S+)/g ]
[q{"}.quotemeta("foo\r\n\tbar\n").q{"}]
[ qr/[ @_ ]/ ]
qr/ @_ /
qr/(?[ () ])/
qr/[[]/
qr/^cats$/ . ""
qr{(?(DEFINE)};
qr/e$d/
q{regexp_substr(fn.stringvalue, '\w+\s\w+') user_full_name}
qr/*.*/ # not with that first * in there, no
qr/\Q$foo/
[qr/\Qfoo/, qr'\Qfoo']
qr/(?^:\Q(s))/
qr/\Q(s)/
qr'\Q/s.'
qr'\Q(s)'
qr/(?^:\Q(s)\E)/
qr/\Q$x/
qr'(s)'
'' . qr/something/msx
qr!span class="full_user_string">.*?<span.*?>(.*?)</.*?class="posting_timestamp" +title="(.*?)".*?class="thread_title">.*?<a .*?>\s*(.*?)\s*<.*?div class="post">(.*?)<div class="rate_buttons"!si; 42
[ qr/\s+:SerialNumber\s+/, "\s+:SerialNumber\s+" ]
 qr/(?s)<tr/ . ''
qr/<tr/s . ''
qr/what does this do/x
qr/(\.xls$|\.xlsx$)/
qr/(?=.|\z)*.*/
quotemeta <>
quotemeta <\<\>>
quotemeta '~!@#$%^&*()_\\{}.,+?'
quotemeta '<>'
quotemeta '!'
quotemeta "_"
quotemeta ":"
quotemeta 'abcdefg[\]$%^&*()'
quotemeta 'hello world'
quotemeta 'hello:world'
quotemeta q<<>>
quotemeta(q{\/})
quotemeta(qq{\/})
[ quotemeta(q{\/}), quotemeta(qq{\/}) ]
[ quotemeta 'test@example.com' ]
quotemeta "\x{D000}"
quoutemeta <>
quoutemeta( <> )
qv'5.22.0'
qv5.22.0
[qw()]
qw()
[ qw( a b c ) x 3 ]
qw( a b c ) x 3
[qw(Attachment) x 3]
qw/Attachment/ x 3
[qw(email@one.com email@two.com)]
"@{ [ %{ [qw/foo bar baz/] } ] }"
"%{ [qw/foo bar baz/] }"
[ qw(foo bar baz) ]
qw/foo bar baz/
qw(foo bar baz)
qw(foo bar baz)[2]
qw/foo bar baz quux/[1]
[ qw ( &my_function) ] # Prostetnic
[ qw(#no) ]
$qwqwerqwe = 1;
+{ qw/you can dump a hashref directly/ }
qx(id);
qx(ls /);
qx(whoami)
q  hello world ;
q  hello\ world ;
rand() < 0.5 ? 'vending machine works' : 'vending machine refuses to give you anything'
rand * 3
rand +   *    34
[rand() * 5000, rand * 5000]
rand * 5000 # unary * is a useful feature too
random(100)
[ "  random\t\nwhitespace\r" =~ /\S+/g ]
rand * time
rand() * time()
"RASH DEAL"
RASH DEAL
$re0 = "x?y+"; $re1 = qr/$re0/; $re2 = qr/$re1/; [ $re0, $re1, $re2 ]
$re1 = qr/x?y+/; $re2 = qr/$re1/; [ $re1, $re2 ]
readline "{a,b,c}"
reduce 1
reduce {$a + $b} 1
ref [];
ref \[1]
ref \\1
ref \ []->[3]
ref \$a
ref \\\\\\$a
ref bless {}, 'ARRAY'
ref( bless {}, "Here is a lovely long string that I invented one summer's day" )
ref ["item1","item2"]
ref localtime
ref main::
ref qr//
ref qr//;
[ ref *STDOUT{IO} ]
ref \(substr "aliens", 0, 2)
ref \v1.2.3
ref v1.2.3
ref([v1.2.3]->[0])
ref( $x = wantarray ); [$x]
$regex = "*meow*"; "banana" =~ /$regex/;
[ 'Regexp'->can('(""') ]
[ 'Regexp'->can('(+0') ]
rename("/opt/google/chrome", "/opt/google/egacs") or die "$!"
$re=qr/(\d{7})/; [ "12345678" =~ $re, "1234567" =~ $re ]
$re=qr/(?<!\D)(\d{7})(?!\D)/; [ "12345678" =~ $re, "1234567" =~ $re ]
$re = '['; /\Q$re/
require(0 + "inf")
require 5
require 5.0.6;
require 5blah
require 'App::Pluggable';
require bigint; bigint->import; 1<<70
require JSON::XS; JSON::XS::encode_json {hi => 123};
require 'Some::Module:__XYZ'
require Some::Module:__XYZ
require Time::Moment; my $now = Time::Moment->now;  $now->with_hour(op)->with_minute(0)->with_second(0);
$re = '['; /$re/
return join(',', @accounts);
return or die;
"Return value"; "Miesco";
[ reverse("6.4.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.1.0.0.0.0.1.1.8.2.a.1.0.0.b.3" =~ tr/.//dr) =~ /.{4}/g ]
reverse "7c86467b"
reverse 'engineer'
reverse proxy
[ reverse "psychology" ]
reverse((reverse 0x7f9241004ee8) =~ s/(...)/$1,/gr)
reverse "string"
reverse ("string")
[ (reverse "string"), (reverse ("string")) ]
reverse ("string", "string")  # :s
[reverse("string","strong"), scalar reverse("string", "strong")]
$_="rexma"; /(?{$name="foo"})re[x]ma|(?{$name="bar"})o[ther]matc/; $name
@r = (foo => 1, bar => 2); ${{@r}}{"a"}
rindex "1234abc", "c"
rindex $_, "c" == length $_ - 1 for "1234abc"
rmdir '/' or $!
"\r\n" =~ /^\R$/
$row = [qw(hi one two)]; unshift(@$row, substr($row->[0],-10)); $row
"\s"
"\s+"
s =~ =///=
/@(\S+)/
/\s{0,}(#{0,})SANITY01/
/\s{0,}(\#{0,})SANITY01/x
/\s{0,}(#{0,})SANITY01/x
"S01E" . $1 * 2
S01E($1*2)
s/..(..).*/$1/ for@x=([],{},$",\&f,\0);print@x
s/..(..).*/$1/ for@x=([],{},$",\&f,\0);$"="";"@x"
s/..(..).*/$1/,print for@x=([],{},$",\&f,\0)
$s1 = ''; $s2 = 'foo'; $s3 = $s1 || $s2; [$s3]
"////" =~ s{/{2,}}{/}gr
$s=(3+undef)/2;print $s
@s=[4,5,6];print join " ",@s[-1..-2];
@s=[4,5,6];print @s[-1..-2];#since no one's talking in here anyway, may as well use the bot
$s = "a,b also has, commas,c,d,e,has,commas,f,g"; $s =~ s/(,[^,]+){2}$//;  "e is '" . (split ",", $s, 5)[4] . "'"
$s = "a,b,c,d,e,has,commas,f,g"; $s =~ s/(,[^,]+){2}$//;  "e is '" . (split ",", $s, 5)[4] . "'"
$s="a.b.c.d"; $h{a}{b}{c}{d}=123;  $r=\%h; $r=$r->{$_} for split/\./,$s; $r
$s="a.b.c.d"; $h{a}{b}{c}{d}=123;  $r=\%h; $r=$r->{$_} for split/\./,$s; $r'
$s="a.b.c.d"; my %h; @h{ split(/\./, $s) } = (1, 2, 3, 4); print keys %h, print values %h;
$s = '*';  "a*b*c" =~ /\Q$s/ ? "Match" : "No match"
$s = '*';  "a*b*c" =~ /$s/ ? "Match" : "No match"
"s" =~ /^((?:a|b|c)s?)?$/ # whatever dude
$s = "{a}b}" $s =~ /\{(.*?)\}/; [$1]
$s = "{a}b}"; $s =~ /\{(.*?)\}/; [$1]
s/(A)/eval(lcfirst $1)/gee
s/(A)/lcfirst $1/e
s/(A)/lcfirst $1/re
$_="&&&"; s/&/&amp;/g; [$_]
s///apple
s///asmallregex
${ \ 'save' }
say $[
say ~0;
say$_*2for 1..10
say(("a" x 10000) =~ /^(ab?)*$/ ? "Yes" : "No");
say blahblah q|0.000.000_YYMMDDhhmm|
say "damn them all to hell";
say Encode::encode("ISO-8859-1", Encode::decode("UTF-8", "Ã¡r jÃº sÃºr?"));
say $ENV{HOME}
say "foo" if ("/page/show/1234" =~ m{page/});
say for @INC
say for keys %hash;
say for keys %INC
say 'hello'
say hi
say 'hi'
say "hi"
say length "0.99999999999991"
say length q|0.000.000_YYMMDDhhmm|
say lenqth q|0.000.000_YYMMDDhhmm|
say ~~localtime(0.32099 * 1e6 + 1394981846);
say ''.localtime(0.32099 * 1e6 + 1394981846);
say q  hello\ world ;
say q  hello\ world ;
say"RASH DEAL"
say something
say "var $rindolf is better than var $generic_var"
say what again
say “whatever”
say "wotcher"
say ( ["wotcher"] )
say ("wotcher")
$s = "banana"; substr($s, 3,0) = "APPLE"; $s
/(?<!S)\b/i
'   ' =~ /\s\B\s/
s/(?<\b!STYLESY0B\$\$)\b$k\b/<span class="kw1">$k<\/span>/igs
[ *_{SCALAR} == \$_ ]
scalar @_[0]
[scalar( (0) x 5 )]
scalar (() = (1..10))
scalar () = (1..10)
[ scalar('٣' =~ /^\d$/a), scalar('٣' =~ /^.$/a), scalar("٢" =~ /^[١-٣]$/a), scalar('٣' =~ /^\D$/a) ]
scalar @{$arrayref}[1,2,3]
scalar "asd1312321asd1212asd121212" =~/(asd\d+)/g;
scalar  ( "A" ) x 3
scalar  +( "A" ) x 3
scalar CORE::gmtime 1404990000
scalar CORE::gmtime 1405095671
scalar CORE::localtime
scalar CORE::localtime 1393955488
scalar CORE::localtime 1404972000
scalar CORE::localtime( 1446568703 );
scalar @{ $foo{bar}{baz} // [] }
scalar(()=glob('*'))  # probably 0
[scalar gmtime]
scalar grep /isnt/, qw/list of words/
scalar grep /is/, qw/list of words/
scalar \%hash
scalar %hash
[''.(scalar localtime)]
[''.scalar localtime]
scalar localtime
scalar localtime 1393955488
scalar localtime 1422281441
scalar localtime 1427744321029
[[''.scalar localtime],[localtime]]
[[scalar localtime],[localtime]]
scalar localtime $^T
scalar localtime time
scalar(@order) = 2; @order and @order = grep $_, @order[-2, -1]
scalar qw/1 2 3/;   # this should be more confusing :p
[scalar qw(Attachment) x 3]
scalar reverse 'abc'
"${\scalar reverse 'foo'}"
[ scalar reverse "psychology" ]
[ scalar '' =~ /^$/, scalar 'a' =~ /^$/]
scalar scalar scalar [1, 3, 5]
"${\scalar sub { wantarray() ? 'list' : 'scalar' }->()}"
scalar $^T
scalar time
scalar Time::Piece::localtime
scalar Time::Piece::localtime .= ""
[ Scalar::Util::looks_like_number '1 ' ]
Scalar::Util::looks_like_number("4")
Scalar::Util::looks_like_number( 'inf')
Scalar::Util::looks_like_number('-INF')
Scalar::Util::looks_like_number('INF')
Scalar::Util::looks_like_number( 'inferior')
Scalar::Util::looks_like_number "nan"
Scalar::Util::looks_like_number 'NaN'
Scalar::Util::looks_like_number( 'NaN')
Scalar::Util->VERSION
[scalar  ('?') x 10 ] # lol?
{ scalar => ('?' x 3), list => [ ('?') x 3 ] }
!!"scotsmen"
s///course
$script = "cats"; "script/\@id=$script"
$_ = 'sdfaosdkf!foobar!pokasdf!'; [ m/!(.+?)!/ ];
s///eeeeeeeeeeeeeee
s/^/"-"/ee if 0;
see your paste
s///eieio
s/^/-/e if 0;
s/$/$/$///$//e # $ in regex makes perl uneasy too
select
[select]
"SELECT id, name, unidade_id, pcu, regexp_replace(barcode, '\\s+', '', 'g') as barcode from articles;"
select->print("hmm")
[ "SELECT \@rownum:=0", 'SELECT @rownum:=0' ]
"$self"
$self
[ "    Sender:example\@domain.com\n" =~ qr/(?|from=<([^>]+)>,src=|^\s+Sender:(.*?)$)/ ]
[ "    Sender:example\@domain.com\n" =~ qr/from=<([^>]+)>,src=|^\s+Sender:(.*?)$/ ]
[ '    Sender:example@domain.com' =~ qr/from=<([^>]+)>,src=|^\s+Sender:(.*?)$/ ]
[ "    Sender:example@domain.com" =~ qr/from=<([^>]+)>,src=|^\s+Sender:(.*?)$/ ]
s***exmag
$s = 'foo'; undef $s; $s .= 'bar';
sftp> ls
s/(...)...)?//g
s/\+\/g
"////" =~ s{//}{/}gr
"////" =~ s{/+}{/}gr
"+-" =~ s/[+-]/!/gr
shift @_
shift $foo;
shift; # fully optimized
"shop_image/importer/1000003/00_1000003.jpg" =~ /(\d\d_\d{7,7})\.jpg/; $1
$s="http://a?k1=v1&k2=v2"; [$s=~/.*?\?(?:([^=]+)=([^&]+)&?)+/g]
$s = "http://a?k1=v1&k2=v2"; [ $s =~ /[?&]([^=]+)=([^&]+)/g ]
$SIG{CHLD}
$SIG{__DIE__} = sub { print "don't do this: @_" }; eval { die "you didn't see me, right" };
$SIG{__DIE__} = sub { print q(dead!)}; ...;
$SIG{__DIE__} = sub { $|++; say 42; exit }; a bc
$SIG{__DIE__} = sub { say q(dead!) }; ...;
"SIMCOP48.856934"^2
sin 9**9**9
"size=473" =~ s/size=\K(\d+)/int($1*2.5)/er
$_ = "sj4jdj345k3dasssdf32"; tr/0-9//cd; print $_;
sleep -1
sleep 5; print "hello"
sleep( 60 * 60 * 8 ) if $!{EINSUFFICIENTCAFFIENE}; # g'night folks.
s///mansex
s///mulder
$s = '\\n'; "\n" =~ /$s/ ? "yes" : "no"
s///nordic
snork gorble pow fwee
snork gorble poww fwee
socket(my $fh, 6, 2, 17) or die "can't - $!";
'some-help-approver@example.net' =~ /(?<!^help-approver)\@example\.net$/
"some text [3] some more text [4] even more text" =~ s/(?=\[\d+\])/\n/gr # or rather this, I guess
"some text [3] some more text [4] even more text" =~ s/(?=\[)/␤/gr # tlhiv_laptop
[ "some text here" =~ /((some) (text))/p, ${^MATCH} ] # no, preferably not $&
[ "some text" =~ m/o|t/ ]
[ "some text" =~ m/o|t/g ]
$_ = 'something123.pl'; s/\w.*?\K(\d\.pl)/0$1/; $_ # why .*-like-things may not work as you wanted
"something like this?" =~ s/(.)/sprintf "%x ", ord $1/gr
"something like this?" =~ s/(.)/sprintf "%x ", ord $1/gre
$_ = "something like this? x x"; my $state = 0; s/(\w)/++$state % 2 ? (uc $1) : (lc $1)/ge; $_
$s = "one two three"; %h = ( one => 1, two => 2 ); $s =~ s/$_/$h{$_}/ for keys %h; $s
[sort { 0 } 5, 2, 3]
[sort 1, 2, 12, 13, 101, 102]
( sort ( 1..9 ));
sort ( [8,6,7,4,2,3,9] )
sort (8, 6, 7, 5, 2, 3, 9)
sort(99, 111)
[ sort { $a->[1] cmp $b->[1] || $a->[0] <=> $b->[0] } [2, 'd'], [3, 'c'], [1, 'd'] ]
[ sort { $a <=> $b } 1386778719, 1386778075 ]
[ sort { $a < $b } 2, 3, 1, 8, 0, 8, 8 ] # like, really easy
[ sort { $a <=> $b } 4, 15, 11, "NaN", 11, 2, 1, 4, 3, "nan", 8 ]
[ sort { $a <=> $b } 7, 0, "nan", 3 ]
[ sort { $a <=> $b } 7, "nan", 3 ]
[ sort { $a <=> $b } 8, 6, 7, 5, 3, 0, 9 ] # tell sort to compare $a and $b numerically instead of as strings
[sort { $a cmp $b } qw/w x/
[sort { $a cmp $b } qw/w x/]
[ sort grep s/\.pm\z//, keys %INC ]
[ sort { length $a <=> length $b || $a cmp $b } qw(this is a sentence with a few random words in it) ]
[ sort { length $a <=> length $b } sort { $a cmp $b } qw(this is a sentence with a few random words in it) ]
[ sort map s/\.pm\z//r, keys %INC ]
sort ( qw(8,6,7,4,2,3,9) )
sort ( qw[8,6,7,4,2,3,9] )
[sort qw(9 3 4 5 6 3 4 1)] #thats how it works
[ sort qw/ 9 39 5 38 4 5 381 29 0 1 2 3 / ]
[ sort qw/a fan of w k r p in Cincinnati/ ]
[sort qw/Compnent Component::A Component::B Your::Mother/]
[ sort qw(must should could could must could should must) ]
[ sort { return 42 } "h", "i" ]
[ sort { return 42 } "hi" ]
[sort &{sub {$_[0] <=> $_[1]}}, qw,1 3 2 772 9,]
('so this should match,even,though,,it,seems,very,different,from,requirements?' =~ m/\w+,\w+,,\w+,\w+/) ? 'match' : 'no match'
so we don't get double action once perlbot is back in commission
${"so what"} = 123; "see? ${so what}"
${"so what"} = 123; "see? ${'so what'}. fu"
$space = 10;printf( "%s%${$space}s => %s", $_, $ENV{ $_ } );
! ! ! ! ! ! "spaces"
@spec = ('abcd', 1, 2); say &CORE::substr(@spec)
@spec = ('abcd', 1, 2); say substr(@spec)
s/perl/python/;
splice((0..9),3,5)
splice([0..9],3,5)
splice @a, 2, 2, qw/foo bar/; \@a
splice @test, 2; \@test
[ split /(?<!^),/, '
[ split /[^0-9]+/, "3 day 18 hr 50 min 33 sec" ]
[ split " ", "1.1.1 POWER SUPPLY DEFECT" ]
[ split /\./, "1.1.1 POWER SUPPLY DEFECT", 1 ]
[ split " ", "1.1.1 POWER SUPPLY DEFECT", 1 ]
[ split " ", "1.1.1 POWER SUPPLY DEFECT", 2 ]  # ?
[ split "/", "12/33.",2]
[ split "/", "12/33", 2 ]
[ split ".", "12.33" ]  # because this
[ split " ", "- 14:56:45,344 -", 4 ]
[ split " ", "- 14:56:45,484 Info  : Trying to load VINGCARD_VISION.dll", 4 ]
[ split ' ', '25 25.175 jitter' ]
split[4]
[ split /\40/, " a  b\tc ", 0 ]
[split /(.{4}/, "thisisatest"]
[split /(.{4})/, "thisisatest"]
[ split //, 7355608 ]
[ split(/aaa/, '') ]
[ split(/aaa/, 'a') ]
[ split(/aaa/, 'aaa') ]
[ split(/aaa/, 'aaaaa') ]
[ split /a/, 'aabcadeaa' ] # derp
[split(/a/, "abacus")]
split(/a/, "abacus")
[split / /, 'a   b']
[split ' ', 'a   b']
[ (split /:/, "a:b")[0..3] ]
[ split //, " a b c " ]
[split //, 'abc']
(split /,/, "a,b,c")[1]
(split ",", "a,b,c")[1]
[ split ' ', "a b c", 1 ]
[split /(?<=-)\+(?=-)/, "a+b+cc-+-d-e-f"]
[split /(?<=-)+(?=-)/, "a+b+cc-+-d-e-f"]
[split /\./,"ab.cd."]
[split /\./,"ab.cd.",-1]
[split /\./,"ab.cd.",2]
[split /\./,"ab.cd.df.",2]
[split /\./,"ab.cd.df",2]
[ split //, "abcde" ]
split(//, "abcde")
split(//, "abcde") . ""
[split " ","a b c\n"]
[ split " ", " a  b\tc " ]
[ split " ", "  amarok" ]
[ split ' ', " a real split " ]
[ split /\A/, "where\nis\nyour\ngod\nnow?" ]
[split /\b/, "123 5 12 7 "]
split /\b/ "123 5 12 7 "
[ split //, "banana" ]
[split /\b/, "foo_bar"]
[ split /\D/, "1k10k1|11dld1" ]
[ split /\D+/, "1k10k1|11dld1" ]
[ split ' ', 'foo bar baz' ]
[split /(?<!\\),/, "foo\\,bar,baz"]
[split ",", "foo bar baz"]
[split ",", "foo, bar, baz"]
(split /\./, 'foo.bar.baz')[1]
[ split /=|==|:|--/, "foo:bar:baz", 2 ]
[[ split / /, "foo     bar" ], [ split ' ', "foo     bar" ]]
[ split / /, " foo\tbar  baz " ]
[ split " ", " foo\tbar  baz " ]
[ split /(?<=@free.fr)/, "example@free.frexample2@free.fr" ] #hmm, why doesn't this keep the @free.fr part in the results?
[ split /(?<=@free\.fr)/, 'example@free.frexample2@free.fr' ] #right
[split " ", "Fri Dec  4 18:54:59 EST 2015"]
[ split //, "F­u­dge" ]
[split//,"Hello"]
[ split '.', 'horsey.surprise' ]
[ split '\\.', 'horsey.surprise' ]
[ split /[&=]/, "http://a?k1=v1&k2=v2" ]
[ split m{/}, "12/33." ]
[ split /^/m, "hello\nworld" ]
[ split m!/|\.html!, "dirs/123/abc.def/ghi999.html ]
[ split m!/|\.html!, "dirs/123/abc.def/ghi999.html" ]
[ split m{/}, '/just/a/demo/' ]
[ split ',', 'money.perl.com,money.python.com,money.nei.com' ]
[ split /(?<!^),/, ',one,two,three' ]
[split //, "perl"]
[ split qr'(?<=@free\.fr)', 'example@free.frexample2@free.fr' ] #look ma! no han^Wescapes! (except that . one)
[ split qr{[\[\]=]+}, "something[a=b][c=d][e=f]" ]
[split('\Qx+', "abxxcdex+fg")]
[split("\Qx+", "abxxcdex+fg")]
[ split ' ', "  random\t\nwhitespace\r" ]
[split /\s+/, " "]
[split /\s+/, " ", -1]
[split /\s+/, "a ", -1]
[ split /\s/, "a     b" ]
[split /\s+/, " a"] # but this one doesn't need the limit
[ split /\s+/, "  amarok" ]
[ split "\s+", "  amarok" ]
[ split /\s+/, " a real split ", -1 ]
[ split /[@\s]/, "foo@bar baz" ]
[ split /[\@\s]/, 'foo@bar baz' ]
[ split /[\@\s]/, "foo@bar baz" ]
[ split /[\@\s]/, "foo\@bar baz" ]
[split /(,\s*)/, "foo, bar, baz"]
split /(,\s*)/, "foo, bar, baz"
[ split /\s+/, grep /x/, qw(abc def kzx lol) ]
(split /-/, (split /\//, "http://www.site.com/letters0241/something-in-australia-a-h")[-1])[2]
[split //, sprintf "%b", 20]
[ split /([\s[:punct:]]+)/, "Knark. knark," ]
[ split /(\s+|[[:punct:]])/, "Knark. knark," ] # or ask perlbot
[split /\s*=\s*/, 'name=val=ue', 2]
[ split(/\s+/, 'split th\is line') ]
[ split /\s+/, " word " ]
[split /\t/, ""]
[split '', '\t']
[split '', "\t"]
[ split /=/, "test='string=ignore this symbol'", 2 ] # presumably you want key + value
[ split /(?<!\\);/, "this;is; a test; with\\; escaped delimiters;;" ]
[split /(?<!\\);/, 'this;is; a test; with\\\; escaped delimiters;;']
[split /\t/, "sajkhsdahkj"]
[split /(\W)/, "a.b!c?d e"]
[ split /\W+/, "(foo)" ]
[split /(\W)/, "foo bar.baz quux?derp ermintrude"]
[ split " ", "what are you on about", 2 ] # wodim?
[ split /,/, 'where,is,"your,god",now' ]
[ split ",", "worker1," ]
[ split ",", "worker1,", -1 ]
[ split /,/, ',x,', -1 ]
[split('x+', "abxxcdex+fg")]
[split /x/, 'axb', 'yxz']
sprintf '%012x', 0xff
sprintf '%012x', 0xffff
sprintf('%02d', 9)
sprintf('%02x%02x%02x', 192, 255, 63)
sprintf "%*02X", " ", "bar"
sprintf "%02*X", " ", "bar"
sprintf(".%03u", 85)
sprintf(".%03u", 850)
sprintf(".%03u", 8500)
sprintf '%04d', 1
[ sprintf "%04o", 0755 ]
sprintf '%04o', 0777
sprintf '%04x', hex 'dead'
sprintf '%05.2f', 5/3
sprintf('%0.5d',9)
sprintf('%0.5f', 7.15255737304688e-06)
sprintf "%08b", 1 | 15
[sprintf "%08x", int( rand(1000))]
sprintf '%.0f', 1.139999999999999 * 100
sprintf "%.0f", 2.6
sprintf "%.0f", 6 * 99.90 * 100
sprintf'%.0f',log(~0)/log(2)
sprintf '%' . 0xfffffff . '$f'
sprintf "[%-10d]", 123
sprintf "%.10f", 942993 / 1236732346368
sprintf "%.10f%% ram used", 942993 / 1236732346368 * 100
sprintf("%12.6g", 6 * 99.90)
[ sprintf '%.14f', '1.43531262539073e-11' ] # or sprintf, if you want to do something other than display the result
sprintf "%.15f", 942993 / 1236732346368
sprintf('%1d',9)
sprintf "%.20f %.20f", 0.1, 0.3
sprintf "%.20f", 6 * 99.90
sprintf "%2.2e", 1234.567
[ sprintf '%.28f', '1.43531262539073e-11' ]
[sprintf "%.2f", 3/4]
sprintf '%2$s then %1$s', 'first', 'second';
sprintf "%.30f", "134.95"
sprintf "%.30f", 134.95
sprintf "%.30f", "134.95" * 100
sprintf "%.30f", 134.95 * 100
sprintf "%.3f", ((10/1*225)/(18))-125
sprintf "%.3f", 2.34525
[ sprintf "%4o", 0644 ]
sprintf('%5s', 'corn flakes');
sprintf "%.70f", 1/3
[sprintf "%8.8x", int( rand(1000))]
sprintf "%8b", 1 | 15
[  (sprintf "%8f", 1) , (sprintf "%8f", 15) ]
sprintf "%b", 0.1
sprintf "%b", 0.21875
sprintf "%b", 0376
sprintf "%b", 1 | 15
sprintf "%b", 1234321
sprintf "%b", 152944
sprintf "%b", 21845
sprintf "%b", 341
sprintf '%b', 50
sprintf '%b', 82
sprintf "%b", 86273
sprintf "%b", 87381
sprintf "%b", 96
sprintf '%b', 96000
[ sprintf "%b & %b -> %b", 2048, 0xFF, 2048 & 0xFF ]
sprintf "%b.%b", split /\./, 0.1
sprintf "%b.%b", split /\./, 0.21875
[sprintf"%c", 65]
[sprintf"%c", 'a']
sprintf "%c%c%c", map ord,(97,98,99)
sprintf "%c%c%c", map ord,('a','b','c')
sprintf '%d', -0.5
sprintf "%,d", 12345678;
sprintf '%d', 1.7
sprintf("%d", 2.6)
sprintf("%d %d", DateTime->now(time_zone => "UTC")->epoch(), time())
sprintf "%d %s", 1, 2
sprintf '%.f', 0.49999999999999994
sprintf '%.*f', 1, 2
sprintf '%*f', '.1', 2
sprintf '%.f', 134.95 * 100
sprintf '%.f', 1.7
sprintf '%.*f', length('9999999999999911'), 0.9999999999999911
sprintf "%f", rand(1e100)
sprintf '%lu', 1341015082000
sprintf "%#o", 0
[sprintf '%o', '16877']
sprintf "%#o", 2
sprintf "%o", 272
sprintf "%o", 292
sprintf "%o", 39
sprintf(         q{[%02dx%02d}. ($3 ? q{-} : q{}). q{%02d] %s},          $1, $2, ($3 // q{}), $4      )
sprintf q{%03d.%d}, split /\./, 1.2345; # leobut
sprintf q{%.3f}, 2047.99999952316 ### Is there a way to do this but truncate instead of rounding, so the result is 2047.999 instead of 2048.000 ?
sprintf q{%.3f}, (int (2047.99999952316 * 1000))/1000;
sprintf $_ = q{eval: sprintf $_ = q{%s}, $_}, $_
sprintf "the cluster is using %.10f%% of available ram", 942993 / 1236732346368 * 100
sprintf "the cluster is using %.10f%% of available ram", (942993 * 2**20) / 1236732346368 * 100
sprintf "%*v02X", " ", "bar"
sprintf "%v*02X", " ", "bar"
sprintf "%*v02x", " ", Encode::encode_utf8("much \x{2665}")
sprintf "%v02X", "hello"
(sprintf "%v02X", "hello") =~ s/\./ /g
(sprintf "%v02X", "hello") =~ s/\./ /gr
sprintf "%*v02x", " ", pack "C*", qw|137 80 78 71 13 10 26 10|
sprintf "%v02x", pack "N", 945
sprintf "%v02x", pack "V", 945
sprintf "%*v04X", "U+", "hello"
sprintf '%vb', 'foo' # something like this, majuscule?
sprintf '%vb', "\x05" # binary string, then?
sprintf "%vd", "123" ^ "az3"
sprintf "%vd", "3" ^ "3"
sprintf "%vd", 'a'
sprintf "%,vd", 'abc'
sprintf "%*vd", ',', 'abc'
sprintf "%vd", 'abc'
sprintf "%vd", "foo\n\rbar"
sprintf "%vd", "something" ^ "otherthing"  # or this...
sprintf '%vd', "string"
sprintf "%vd", $^V
sprintf('%v', v1.2.3)
[ sprintf "%x", 127.0.0.1 ]
sprintf "%x", 14644
sprintf '%x', 18*256+44;
sprintf "%x", 18446744073709551615
sprintf '%x', 3 * 256 + 17
sprintf '%x', 44*256+18;
sprintf "%x", 5 * 60 * 10e6
sprintf "%x", 65280
sprintf "%x", oct "0b011000111100"
sprintf "%X", oct "0b011000111100"
sprintf '%x', ord '*';
sprintf "%x", ord '0'
sprintf '%x', ord 'c'
sprintf '%x', ord 'C'
sprintf "%x", ord "\n"
sprintf "%x", ord "\x{1234}"
sprintf "%x", time(0)
[ sprintf "%x", v127.0.0.1 ]
sprintf "%x %x", 015, 012
sprintf "%x %x", 55357, 56839
sprint "%x", ord '0'
$sql =~ s/constraint \K`(\w+)`/$1/gi; maybe?
"(s)" =~ qr'\Q(s)'
$s = quotemeta('*');  "a*b*c" =~ /$s/ ? "Match" : "No match"
'!' =~ s/~//r
'!' =~ s/!//r
srand(()) # Came up in p5p recently
@src=qw(a b c); @dst=grep defined, @src[2..5]; print join(",", @src);
@src=qw(a b c); @dst=@src[2..5]; print join(",", @dst);
@src=qw(a b c); @w=grep defined, @{ [@src[2..5]] }; print join(",", @src); #rmah, how about this?
@src=qw(a b c); @w=@src[2..5]; print join(",", @src);
s///regexp
sretrun
sretrun join(',', @accounts);
sreturn join(',', @accounts);
['ß']
s///scully
'ß' =~ m/^\Qss\E\z/i ? 'True' : 'False';
[ 'ß' =~ m/^\Qss\E\z/i ? 'True' : 'False' ];
s/ / sprintf(         q{[%02dx%02d}. ($3 ? q{-} : q{}). q{%02d] %s},          $1, $2, ($3 // q{}), $4      )  /ex;
'ß' =~ /\ß{UpperCase}/
s/(?<!STYLESY0B\$\$)\b$k\b/<span class="kw1">$k<\/span>/igs;
s///supernice
s///susanne
s///susi
$_ = "stackoverflow"; $_ = reverse for substr $_, 0, 5; s/.//r
$_ = "stackoverflow"; substr($_,0,5,substr(reverse(substr$_,0,5),1,4)); $_
$_ = "stackoverflow"; substr($_,0,5,substr(~~reverse(substr($_,0,5)),1,4)); $_  # fixed
state $x = 4; $x
$_ = "STDERR output success\nSTDERR output success\n";  /^STDERR output success(?=.*(?!STDERR output success))/ ? 'y' : 'n'
$_ = "STDERR output success\nSTDERR output success\n";  /^STDERR output success(?!.*STDERR output success)/ ? 'y' : 'n'
<stdin>
STDIN
[*STDIN]
*STDIN{IO}
STDOUT->autoflush(1)
[ *STDOUT{IO} ]
*{ *STDOUT{IO} }
'' . *{ *STDOUT{IO} }{IO}
*{ *STDOUT{IO} }{IO}
[ ''.*STDOUT{IO}, '' . *{ *STDOUT{IO} }{IO} ]
STDOUT->print("oh no, entire classes")
/(?<!ST)/i
Storable::store "hallo"
$str = '00 00 1c 00'; $num = unpack("V", pack("(H2)4", split / /, $str)); [ $num ]
$str = '00 00 1c 00'; $num = unpack("V", pack("H8", $str =~ tr/ //dr)); [ $num ]
$str = '00 00 1c 00'; $str = join '', reverse split ' ', $str; $num = hex $str; [ $num ]
$str = '00 00 1c 00'; $str =~ tr/ //d; $num = hex $str; [ $num ]
$str = '001122334455'; @m = ($str =~ m/(\d{2})/g); "@m"
$str = '00 1c 00 00'; $str =~ tr/ //d; $num = hex $str; [ $num ]
$str = 0b10000000 ^ 0b00000100; print unpack q/B8/, $str;
$str = 0b10000000 ^ 0b00000100; sprintf "%b", $str
$str1="1"; $str2="2"; print ($str1,$str2(; print ($str1.$str2);
$str1="1"; $str2="2"; print ($str1,$str2); print ($str1.$str2);
$str1="1"; $str2="2"; print $str1,$str2; print $str1.$str2;
$str = "123456"; for($i = 0; $i < length($str)-1; $i+=2) { (substr($str, $i, 1), substr($str, $i+1, 1)) = (substr($str, $i+1, 1), substr($str, $i, 1)); } $str;
$str = "123456"; $str += 90909
$str = "123456"; $str += join $., (3 * 3) x 3
$str='123abc'; $str =~ +'xyz'; print $str;
$str = '|1|2a|3abc|4abcd|5abcde'; [ map { $str =~ /((?:\|[^\|]*){$_})/  } 1..5 ]
$str="1a2s"; ($s1, $s3)=$str=~m/\d\w/g;  print $s1."\n"; ($s2)=$str=~m//g;  print $s2."\n".$s3;
$str="1a2s"; ($s1)=$str=~m/\d\w/g;  print $s1."\n"; ($s2)=$str=~m//g;  print $s2."\n";
$str="1a2s"; $str=~m/(\d\w)/g; $s1=$1; print $s1."\n"; $str=~m//g; $s2=$1; print $s2."\n";
$str1="a"; $str2="b"; print $str1=>$str2;
$str1 = 'foobar'; $str2 = 'foobiz'; ($str1 ^ $str2) =~ /(^\0*)/; length $1
$str1 = 'foöbar'; $str2 = 'foobiz'; ($str1 ^ $str2) =~ /(^\0*)/; length $1
$str1 = 'foöbar'; $str2 = 'foöbiz'; ($str1 ^ $str2) =~ /(^\0*)/; length $1
$str1 = 'foöobar'; $str2 = 'foöobiz'; ($str1 ^ $str2) =~ /(^\0*)/; length $1
$str1 = 'foöobar'; $str2 = 'foö'; ($str1 ^ $str2) =~ /(^\0*)/; length $1
$str1="one"; $str2="two"; print ($str1,$str1.$str2);
$str1="one"; $str2="two"; print ($str2.$str1,$str1.$str2);
$str=1; printf ("%.3f", $str/3);
$str = 'a a a a a a'; /a/g for ($str) x 3; $str =~ s/a\G/x/; $str
$str = 'aaaaa'; $str =~ /a/gc for 1,2,3; $str =~ s/a/b/c; $str
$str = 'aaaaa'; $str =~ /a/g for 1 .. 3; $str =~ s/\Ga/b/; $str
$str='abc123'; map { s/abc/xyz/g; print } $str;
$str = "abcdef"; for($i = 0; $i < length($str)-1; $i+=2) { (substr($str, $i, 1), substr($str, $i+1, 1)) = (substr($str, $i+1, 1), substr($str, $i, 1)); } $str;
$str="abcdefghijklmnopqrstuvwxyz"; $str=~s/(?<=.{13}).*//; print $str;
$str="abcdefghijklmnopqrstuvwxyz"; $str=~s/(?<=.{13}).*/$x=rand(3); $x>1?uc($&):lc($&)/ge; print $str;
$str="abcXYZ 123 pdq"; $str=~s/(?<=.{3}).*//; print "\"$str\"\n"
$str = ["a".."m"]; print ref $str
$str.='a'..'m'; print ref $str;
$str = ["a".."m"]; print scalar $str
$str = 'a'..'m'; print $str;
$str = ["a".."m"]; print @$str
$str = ["a".."m"]; print $str
$str.='a'..'m'; print $str;
$str = 'barfoo'; $str =~ /(?(?{$_=index($str,'foo');$_>0})foo|(*FAIL))/ or 1;
$str="bleh"; $str=~s/(?:test)/$1/; print $str;
$str="bleh"; $str=~s/(?test)/$1/; print $str;
$str="blehtest"; $str=~s/(?:bleh)/$1/; print $str;
$str="blehtest"; $str=~s/(?:test)/$1/; print $str;
$str = "foo a b = z"; @a = $str =~ m/( \w)+/g; \@a
$str = '   foo'; $str =~ s/\A\s+//; "[$str]";
$str = '   foo'; $str =~ s/\A\s+//; $str;
strftime '%Y-%m-%d %H:%M:%S', gmtime 1433332042340 / 1000; # how human?
$str="ft\n"; chomp $str; $str =~ /ft$/ ? 't' : 'f'
$str="ft\n"; $str =~ /ft\b/ ? 't' : 'f'
$str="ft\n"; $str =~ /ft$/ ? 't' : 'f'
$str="ft\n"; $str =~ /ft\z/ ? 't' : 'f'
$str = "/hallo/"; qr{blabla $str xxx}
$str = "Hey $1.140 $20.568 16.9kg 12.3 2342342.9 Hey"; $str =~ s/(\d+\.\d+)/sprintf("%0.f")/eg; print $str;
$str = "Hey $1.140 $20.568 16.9kg 12.3 2342342.9 Hey"; $str =~ s/(\d+\.\d+)/sprintf("%0.f")/g; print $str;
$str = "Hey $1.140 $20.568 16.9kg 12.3 2342342.9 Hey"; $str =~ s/(\d+\.\d+)/sprintf("%.f",$1)/eg; print $str;
 $str = "I am 2000 years old"; $str =~ s/(\d+(?:\.\d+)?)/sprintf('%.f',$1)/er;
 $str = "I bought $155.4954 worth of oregano"; $str =~ s/(\d+(?:\.\d+)?)/sprintf('%.f',$1)/er;
'strike' =~ /(?:anywhere)?/ ? 'matches' : 'bad joke';
'strike' =~ /(?anywhere)/ ? 'matches' : 'bad joke';
"string\'"
$string="hello world"; ($capture) = $string =~ /\bhello\b/; print $capture;
$string="hello world"; $capture = $string; $capture =~ /hello/; print $capture;
$string="hello world"; $capture = $string; $capture =~ s/.*(hello).*/$1/; print $capture;
$string="hello world"; ($capture) = $string =~ /hello/; print $capture;
$string="hello world"; $capture = $string =~ /hello/; print $capture;
$string="hello world"; ($capture) = $string =~ s/.*(hello).*/$1/; print $capture;
$string = "nah, i don't will hack you. you guys are cool."; $string =~ s/"don't will"/"won't"/g; print $string;
$string = "nah, i don't will hack you. you guys are cool."; $string =~ s/don't will/won't/g; print $string;
$string = qq/bleh/; print $string;
$string = qq/bleh/; print $string => $string;
$string="xyz357pdq"; $string=~s/.*357.*/357/g; print $string
$_ = "stringy stringy string"; $f = ~m/ingy/; print $f
 $str = "I weight 15.6kg"; $str =~ s/(\d+(?:\.\d+)?)/sprintf('%.f',$1)/er;
$str = 'JÚ ÁR KORREKT SZŐR'; utf8::encode $str for 1..10; $str
$str = "llama"; print substr($str, 0, -1);
$str = "llama"; print substr($str, -1, 0);
$str = "llama"; print substr($str, 1, -1);
$str = "llama"; print substr($str, 1, 1);
$str = "llama"; print substr($str, 1, 2);
$str = "llama"; print substr($str, 1, 3);
$str = 'P98 3G\xE5\x85\xAB\xE6\xA0\xB8(A3HY) Build/KOT49H)'; $str =~ s/\\x(..)/chr hex $1/ge; Encode::decode_utf8($str)
$str = 'P98 3G\xE5\x85\xAB\xE6\xA0\xB8(A3HY) Build/KOT49H)'; $str =~ s/\\x(..)/chr hex $1/ge; $str
$str='post hoc ergo propter hoc'; $str=~s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $str;
$str = "_"; print "ok" if ($str =~ /\w/)
strptime
[ strptime('32/05/2015', '%d/%m/%Y') ]
strptime("%A, %d %B, %Y", "Wednesday, 7715th September, 1993" =~ s/th|rd|nd//gr)
[ strptime "Dec", "%b" ]
strptime("Wednesday, 7715th September, 1993" =~ s/th|rd|nd//gr, "%A, %d %B, %Y")
$str = scalar ["a".."m"]; print $str
$str=sprintf("%.3f", 1/3); print $str;
$str=sprintf(%.3f, 1/3); print $str;
$str="status is: active/standby"; $str =~ s/.*\://; print $str;
$str="status is: active/standby"; $str =~ s/.*\:\s+?//; print $str;
$str="stringAtostringBxyz"; $str=~s/A.*B//g; print $str;
$str = "''"; $str=~ s/\'\'/\'/g; print $str;
$str = 'str with [ bracket'; $str =~ /[][]/ ? 'match' : 'no match';
$str = "s\xc3\x83\xc2\xbc\xc3\x83\xc2\x9fe"; [ $str, decode_utf8($str), decode_utf8(decode_utf8($str)) ]
$str = 'test'; for my $n (0..2**length($str)-1) { $bit = 0; print $str =~ s/([a-z])/$n & 1<<$bit++ ? uc$1 : lc$1/ger, ' ' } # << may be faster
$str = 'test'; for my $n (0..2**length($str)-1) { $bit = 0; print $str =~ s/([a-z])/$n & 2**$bit++ ? uc$1 : lc$1/ger, ' ' } # another idea
$str = 'test'; for my $n (0..2**length($str)-1) { $bit = 0; print $str =~ s/([a-z])/$n & 2**$bit++ ? uc$1 : lc$1/gier, ' ' } # needs /i (maybe?)
 $str = “the 15.7 romulans”; $str =~ s/((\d+)(\.\d+)?)/int(\1)/e;
 $str = "the 15.7 romulans"; $str =~ s/((\d+)(\.\d+)?)/sprintf("%.f",(\1)/e;
 $str = "the 15.7 romulans"; $str =~ s/((\d+)(\.\d+)?)/sprintf("%.f",\1)/e;
 $str = "the 15.7 romulans"; $str =~ s/(\d+(?:\.\d+)?)/sprintf('%.f',$1)/er;
 $str = "the 15.7 romulans"; $str =~ s/(\d+(?:\.\d+)?)/sprintf("%.f",\1)/er;
$str='the quick brown fox jumped over the lazy dogs'; $str=~s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $str;
$str='the quick Brown Fox'; $rex = qr/brown f/i; print $rex; $str =~ $rex; print " $str";
$str='the quick Brown Fox'; $rex = qr/brown f/i; print $rex; $str =~ s/$rex//; print " $str";
$str='the rain in spain is not a dancer'; print s/e//g;
$str='this is my leetspeak regex'; $str=~ s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $str
$str='  trim this  '; $str=~s/^\s+//g; $str=~s/\s+$//g; print $str;
$str = uc("foobar") =~ s/FOO//r; $str
$str = undef; print ref $str;
$str = undef; print $str;
$str="wildcard portion"; $str=~s/(.)/\[$&\]/g; print $str;
$str="wildcard portion"; $str=~s/wildcar(d.+)tion/\[$&\]/g; print $str;
$str="wildcard portion"; $str=~s/wildcar(d*+)tion/\[$&\]/g; print $str;
$str="wildcard portion"; $str=~s/wildcar(.*)tion/\[$&\]/g; print $str;
$str="wildcard portion"; $str=~s/.*(wild).*/$&/g; print $str;
$str="wildcard portion"; $str=~s/(wild)/\[$&\]/g; print $str;
s TT$ Donald Trump
"stuff" . 1 + 3
['stuff' =~ /(?:(?!stuff).)*/]
/(?<!STYLESY0B\$\$)/
/(?<!STYLESY0B\$\$)\b/
/(?<!STYLESY0B\$\$)\b/i
/(?<!STYLESY0B\$\$)/i
/(?<!STYLESY0B\$\$)/ia
/(?<!STYLESY0B\$\$)/iaa
(sub ($$) { $$ })->()
(sub {}) -> ()
[ [ sub {} ] ]
[ sub {} ]
sub と {}
(sub { ($_[0] = $_), shift for "another perl Just hacker,\n" =~ /\S+\s/g })->(qw,s o r t,); print @a;
(sub { ($_[0] = $_), shift for "another perl Just hacker,\n" =~ /\S+\s/g })->(sort my @a = qw,s o r t,); print @a;
sub { &{$_[0]} }->( sub { &{$_[0]} } )
(sub { 1 }) -> ()
sub _{@_<2&&return@_;push@{$|--},$_ for@_;map _(@$_),map[splice@$_],0,1}print _ split//,"huroP cels,tetah Jen akrr";
sub _{@_<2&&return@_;push@{$|--},$_ for@_;map _(@$_),map[splice@$_],0,1}print _ split//,"Just another Perl hacker,";
sub _{@_<2&&return@_;push@{$|--},$_ for@_;map _(@$_),map[splice@$_],0,1}print _ split//," uhPakatrrorc  ,tlJenehse";
[ sub {42} ]->[0]()  # hehehe
sub {42}->()  # hehehe
[ sub { 55 if 0 }->() ]
sub { 55 if 0 }->()
sub a { (5,7) }; a()->[1]
sub a { (5,7) }; a[1]
sub a { (5,7); }  (a(3,1))[1];
sub a { (5,7); }  die (a(3))[1];
sub a { (5,7); }  die (a(3,1))[1];
sub a { (5,7); }  die +(a(3,1))[1];
sub a () { (5, 7) } print a[1];
sub a { @_ } (a 3,2)[1]
sub a { @_ }; (a(3,2))[1]
sub a　b { "hi" } a　b
sub a { b() } sub b { goto (caller(1))(3) } a()
sub a { b() } sub b { goto (caller(1))[3] } a()
sub a { b() } sub b { goto *{+(caller(1))[3]}{CODE} } a()
sub accessor { my $self = shift; unless($self->{whatever}) { $self->{whatever} = 'stuff' } } accessor({whatever => 'previous value'}) # obviously no one would write code like that unless they hated the rest of their team, but, y'know. real example, sadly
sub add { $_[0]+1 } add 5
sub add { $_[0]+$_[1] } say add 2 => 2
sub add { my $x = shift; sub { $_[0] + $x } } add(1)->(2)
sub add ($$) { return $_[0] + $_[1] } my @stuff_from_the_user = (2, 2); add @stuff_from_the_user;
sub another'Just { "Just @_," } sub hacker'Perl { "Perl @_" }  Just another Perl hacker,
sub { $anyothername = 'xxx' }->(); [ $anyothername ]
sub a { @_ } print a(5,7)[1];
sub a { return (5, 7); } print (a())[1];
sub AUTOLOAD { $AUTOLOAD = 'cats' } sub lol { "lol" } notlol()
sub AUTOLOAD { $AUTOLOAD = 'lol' } sub lol { "lol" } notlol()
sub AUTOLOAD { $AUTOLOAD = 'lol' } sub lol { "verylol" } notlol()
sub AUTOLOAD{ our $AUTOLOAD; my ( $a ) = @_; print "$AUTOLOAD $a"; } hello( 'kitty' );
sub AUTOLOAD { print "hi" } &foo
sub AUTOLOAD { print "hi" } &{"foo"}
sub AUTOLOAD { print "hi" } foo;
sub AUTOLOAD { print "hi" } $x=\*foo{CODE}; &$x;
sub AUTOLOAD { print "hi" } $x=\*foo; &$x;
sub AUTOLOAD { say 'test' }; [ 'main'->can('AUTOLOAD') ? 'yes' : 'no' ];
sub bar { $_[0]( $_[1] ) }; bar(sub { $_[0] * 2}, 5)
sub bar { $foo = 0; return $foo || die; } bar();
sub bar { $foo = 0; return $foo or die; } bar();
sub base { my ($d, $n) = @_; my $r = ''; { my $c = $n % $d; if ($c >= 10) { $c = chr($c - 10 + ord 'a'); } $r .= $c; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 16, 0
sub base { my ($d, $n) = @_; my $r = ''; { my $c = $n % $d; if ($c >= 10) { $c = chr($c - 10 + ord 'a'); } $r .= $c; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 16, 255
sub base { my ($d, $n) = @_; my $r = ''; { $r .= $n % $d; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 10, 5
sub base { my ($d, $n) = @_; my $r = ''; { $r .= $n % d; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 10, 5
sub base { my ($d, $n) = @_; my $r = ''; { $r .= $n % $d; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 2, 10
sub base { my ($d, $n) = @_; my $r = ''; { $r .= $n % $d; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } base 2, 5
sub bin2chr { pack 'b8', $_ }   join "", map { bin2chr $_ } "0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010" =~ m/(.{8}/g;
sub bin2chr { pack 'b8', $_ }   join "", map { bin2chr $_ } "0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010" =~ m/(.{8})/g;
sub bin2chr { pack 'B8', $_ }   join "", map { bin2chr $_ } "0101010001101001011101000110100000110100011000110110111101101011011001010110100100001010" =~ m/(.{8})/g;
sub blah { $_[0]++ } blah(my $val); ++$val
sub blah { my @args = @_; return @args[-1]; } blah(0,1,2,3,4,5,6);
sub blah { return $_[3] } blah(0,1,2,3,4,5,6);
sub blah { "value" } blah()
sub buildMech { return WWW::Mechanize->(); } sub zeroMech {my $mech = $_[0]; $$mech->clear_credentials(); } my $mech = zeroMech \buildMech();
sub buildMech { return WWW::Mechanize->(); } sub zeroMech {my $mech = $_[0]; $$mech->clear_credentials(); } my $mech = zeroMech buildMech();
sub Bulgaria { print caller; } package Wimbledon; Bulgaria
sub Bulgaria { print caller; } package Wimbledon; Bulgaria()
sub c {$_[0]=~/.*\.(.*)$/;$1} [map c($_), "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl"]
sub c {$_[0]=~/.*\.(.*)$/;$1} [map c($_), "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
sub catify { $_[0] = "cats" } my $x = "dogs"; catify $x; [$x]
sub chomp { "blah" }; [ chomp ] # Perl will warn about this with warnings on though
sub closure { my $foo; sub { $foo ++ } }; my $sub = closure(); my $other = closure() ; [ $sub->(), $sub->() , $other->(), $other->(), $other->() ] # note that the $foo that belongs to $sub is different from the $foo that $other has... and that they both continue to exist due to there being a reference to a sub in the scope they reside within. see also: coping with scoping
sub compare ($$) { $_[1] - $_[0] } [ sort compare -2, 5, 710, 9, 1 ]
sub config { my %x = (a => "b"); \%x }; config
sub CONSTANTPLS { 5 } my %stuff = ( +CONSTANTPLS => 7 ); $stuff{+CONSTANTPLS}
sub CONSTANTPLS { 5 } my %stuff = ( CONSTANTPLS() => 7 ); $stuff{CONSTANTPLS()}
sub ctx { say wantarray } \ctx;
sub ctx { wantarray // 'undef' } \ctx;
sub curry { my ($f) = @_; sub { my ($x) = @_; sub { my ($y) = @_; $f->($x, $y) } } } sub base { my ($d, $n) = @_; my $r = ''; { my $c = $n % $d; if ($c >= 10) { $c = chr($c - 10 + ord 'a'); } $r .= $c; if ($n >= $d) { $n = int($n / $d); redo; } } scalar reverse $r } curry(\&base)->(16)->(255)
sub custom { my ($k) = @_; $a->{$k} cmp $b->{$k} } [ sort { custom('name') } { name => 'x' }, { name => 'y' }, { name => 'z' } ]
sub d { $_[0] < 10 ? $_[0] : (rand >= 0.5 ? 'a' .. 'z' : 'A' .. 'Z')[$_[0] - 10] } sub b { $_ && b($_[0], $_) for int $_[1] / $_[0]; print d $_[1] % $_[0]; } b 14, 1.4e9
sub d { (0 .. 9, 'a' .. 'z')[$_[0]] } sub b { $_ && b($_[0], $_) for int $_[1] / $_[0]; print d $_[1] % $_[0]; } b 14, 1.4e9
sub d { (0 .. 9, 'a' .. 'z')[$_[0]] } sub b { $_ && b($_[0], $_) for int $_[1] / $_[0]; print d $_[1] % $_[0]; } b 16, 255
sub d { (0 .. 9, 'a' .. 'z')[$_[0]] } sub b { $_ && b($_) for int $_[1] / $_[0]; print d $_[1] % $_[0]; } b 14, 1.4e9
sub dieonAg{ $string = shift; if ($string =~ /A[^ab]/) die "A and not Aa or Ab"; return $string};   print dieonAg("Hi A.");
sub dieonAg{ $string = shift; if( $string =~ /A[^ab]/) {die "A and not Aa or Ab"}; return $string};   print dieonAg("Hi A.");
sub dieonAg{ $string = shift; if ($string =~ /A[^ab]/) die "A and not Aa or Ab"; return $string};   print dieonAg("Hi Ab.");
sub dieonAg{ $string = shift; if( $string =~ /A[^ab]/) {die "A and not Aa or Ab"}; return $string};   print dieonAg("Hi Ab.");
sub do_stuff { my ($thing, @morestuff) = @_; return $thing, @morestuff; } do_stuff(0, 'asdf') ? 1 : 0
sub do_stuff { undef $_ } [ map { do_stuff(); $_ } (1,2,3) ]
sub du { my ($x, $N, $V, $C) = @_; unpack('C', $x) + $C * 256 } sub ds { my ($x, $N, $V, $C) = @_; unpack('C', $x) - ($N ^ $V) * 256 } sub p { pack "B*", $_[0] } [ map [du(@$_), ds(@$_)], [p('00111000'), 0, 0, 1], [p('01000110'), 0, 1, 1] ]
sub du { my ($x, $N, $V, $C) = @_; $x + $C * 256 } sub ds { my ($x, $N, $V, $C) = @_; $x - ($N ^ $V) * 256 } [ map [du(@$_), ds(@$_)], [0b0011_1000, 0, 0, 1], [0b0100_0110, 0, 1, 1] ]
sub eh { print ">", wantarray, "<" } ref(eh)
sub { eval { return 1 }; return 2 }->()
sub f { 1 }; main -> f;
sub f1 { print 'f1' } sub f2 { print 'f2' } eval "f1\n&f2"
sub f1 { \@_ } sub f2 { "f2" } eval "f1;\n&f2"
sub f1 { \@_ } sub f2 { "f2" } eval "f1\n&f2"
sub f { a => 123 } +{ f() }->{a}
sub f { (a => 1, b => 2) } my $value = { f() }->{a};
sub f { my @array = 1..3; return @array } \f()
sub foo { ${$_[0]} = 123 } foo \(my $x); $x
sub foo { ${$_[0]} = 123 } foo \undef; $x
sub foo { $$_[0] = 1 } foo \(my $x); $x
sub foo{$_[0]<=>$_[1]} [sort &foo, qw,1 3 2 772 9,]
sub foo { $_[0] * 2 } sub bar { $_[0]( $_[1] ) }; bar(\&foo, 5)
sub foo { $_[0] } "cats"->${ \\&foo }
sub foo { $_[0] } "cats"->${ \&foo }
sub foo {$_[0]="cats"}; foo "dogs";  # don't cripple your API for no reason
sub foo (&) { $_[0]() } foo \sub {};
sub foo { $_[0] .= "Hi" } my $x = "Hello "; foo($x); [$x]
sub foo { $_[0] = "hi"; } sub r_u_kiddin_me { \@_ } sub bar { local *copy = r_u_kiddin_me @_; foo(@copy); "@_" }  $x = "foo"; bar $x
sub foo { $_[0]++ } my $x = 1; foo($x); $x
sub foo { $_[0]++ } my $x = 3; foo($x); [$x] #anno, you were saying?
sub foo { @{$_[0]}=qw( A B C ); } foo (\my @y); \@y;
sub foo { @{$_[0]}=qw( A B C ); } foo [my @y]; \@y;
sub foo { @{$_[0]}=qw( A B C ); } foo \(my @y); \@y;
sub foo { $_[0] =~ s/foo/bar/ } sub bar { foo(@copy = @_); "@_" } $x = "foo"; bar($x)  # how about this
sub foo { $_[0] =~ s/foo/bar/ } sub bar { foo(@_); "@_" } $x = "foo"; bar($x)
sub foo { 1..10 }; \foo;
sub foo { 1, 2, 3 } [ \foo ]
sub foo { 1, 2, 3 } \foo
sub foo { [1, 2, 3] } { my $arr_ref = foo(); if (@$arr_ref) { print @$arr_ref } }
sub foo { 2 } $foo=1; [$foo,foo]
sub foo { 2 }; $foo=1; [$foo,foo]
sub foo { 42 } *bar = \&foo; bar()
sub FOO () { 42 } [ $::{FOO} ]
sub foo { 42 }  *{$main::{foo}}{CODE}
sub foo { 42 } our $foo = 2; *{$main::{foo}}{CODE}
sub foo { [ @_ ] }; @a = (1,2,3,4); foo(@a)
sub foo { [ @_ ] }; @a = 1,2,3,4; foo(@a)
sub foo{$a<=>$b} [sort &foo, qw(1 3 2 772 9)]
sub foo { 'a'..'z' }; [\(foo)];
sub foo { 'a'..'z' }; [\foo];
sub foo { 'a'..'z' }; \(foo);
sub foo { 'a'..'z' }; \foo;
sub foo { 'a'..'z' }; \( (foo)[0..26] );
sub Foo::Bar::blah { 'hi' } 'Foo::Bar'->blah
sub foo { BLAH: { sub { last BLAH }->(); print "cats\n" } } foo()
sub foo { (caller 0)[3] } foo
sub foo {(caller(0))[3]}  foo()
sub foo { $count++; (1,2,3) } foreach my $x (foo()) { } $count
sub Foo { die 'here' } 'Foo'->new
sub foo { $#$_; }; [ foo(1 .. 4) ]
sub foo ($$) { [@_] } [ foo 'a', 'b', foo 'c', 'd' ]  # should be [ [ 'a' => 'b' ], [ 'c', 'd' ] ]
sub foo; foo "hi\n"; sub foo { print "moo\n"; }
sub foo { "foo!" }; push @x, \&foo; $x[0]->()
sub foo { "foo!" }; push @x, \&foo; $x[0]() # I thought the -> was always needed before () - guess not
sub foo (;*); foo($x, $y, length $y);
sub foo (\&);  # good luck, what does this even mean
sub foo {" Hello"}; undef &foo; foo()
sub foo { "hi" } my @x; bless \@x; (\@x)->foo
sub foo{if (0) {} else {"nothing"}} [foo]
sub foo{if (1) {} else {"nothing"}} [foo]
sub foo ($is_it) { $is_it } foo "cats"
sub foo { join '-', @_ } foo 1, 2, 3, "dogs"
sub foo{}  join ",", (\&foo, \&foo)
sub foo{}  join ",", (\&foo)x2
sub foo { key1 => value1, key2 => value2 } [foo()]
sub foo :lvalue { @foo };  foo() = qw/ One Two Three /;
sub foo :lvalue { $foo };  foo() = qw/ One Two Three /; $foo
sub foo :lvalue { print "FOO!" }  undef &foo; foo()
sub foo :lvalue { say wantarray } foo = "cats"
sub foo :lvalue { say wantarray; our $foo } foo = "cats"
sub foo :lvalue { [wantarray] } foo = "cats"
sub foo { \@_ };  [ main::foo("bar"), main->foo("bar") ]
sub foo { map { $_ } 1..10; } my $x = [ foo ]; $x;
sub foo { map { $_ } 1..10; } my $x = foo; $x;
sub foo { map { $_ } 1..10; } my $x = \foo; $x; ### Why is this produce a different result?
sub foo { map { $_ } qw/a b c/; } my $x = \foo; $x;
sub foo { map { $_ } qw/a b c/; } my $x = foo; $x;
sub foo {  map { @_ }  qw/the futures returned/  }     [ foo(qw/the method parameters/) ]
sub foo() { my ($arg1, $arg2) = @_ } foo(1,2)
sub foo { my ($arg1, $hashref) = @_; $hashref->{asdf} = 35 } my %hash = (asdf => 55); foo('25', \%hash); $hash{asdf}
sub foo { my ($arg1, $hashref) = @_; $hashref->{asdf} } my %hash = (asdf => 55); foo('25', \%hash)
sub foo (&@) { my ($code, @args) = @_; $code->(@args) } my $res = foo { [@_] } 1, 2, 3; $res
sub foo { my $c = wantarray; !defined $c ? "void" : $c ? "list" : "scalar" } (foo) x 4
sub foo { my $c = wantarray; !defined $c ? "void" : $c ? "list" : "scalar" } [(foo) x 4 ]
sub foo { my ($d, @r) = @_; if ($d < 1) { print "@r; "; return; } for my $i (1 .. 3) { foo($d - 1, @r, $i); } } foo 2;
sub foo { my ($d, @r) = @_; if ($d < 1) { print "@r; "; return; } for my $i (1 .. 3) { foo($d - 1, @r, $i); } } foo 5;
sub foo { my $_ = \@_; $#$_ } [ foo(1..4) ]
sub foo { } my $foo = \&foo; my $bar = \&bar; [ $foo eq $bar ]
sub foo { } my $foo = \&foo; my $bar = \&foo; [ $foo == $bar ]
sub foo { my ($num, @els) = @_; $num + @els } foo( 3, 1, 2, 3)
sub foo { my ($one, $two, $three) = @_; return defined($two) ? "two is defined" : "two is undef"; } [foo('hello',undef(),'three')]
sub foo ($$) { \@_ } my @stuff = (1,2,3); foo @stuff
sub foo ($$) { \@_ } my @stuff = (1,2,3); foo @stuff, 5
sub foo { my $x = $_[0]; $x =~ s/foo/bar/ } sub bar { foo(@_); "@_" } $x = "foo"; bar($x)
sub foo { my $x = 42; sub { eval shift } } foo()->('$x')
sub foo { my $x = 42; sub { $x; eval shift } } foo()->('$x')
sub foo($$$) { "@_" } my @x = 9..13; foo(@x)
sub foo { my $x = do { return 1 }; $x + 1 } foo
sub foo { my ($x, $y, $z, @rest) = @_; bar( $x, @rest ); } sub bar { [ @_ ]; } my %h = ( a => 123, b => 456 ); foo 77, 88, 99, %h;
sub Foo { our $nested; local $nested unless $nested; my @p = ( [ shift, $nested // 0, $nested ? q{Nested} : q{First} ] ); {  if ( @_ ) { $nested++; push @p, Foo( @_ ); }  }; if ( $nested ) { $nested--; @p; } else { [ @p ]; } }   { RUN1 => Foo(qw(A B C)), RUN2 => Foo(qw(X Y Z)) };
sub Foo { our $nested; local $nested unless $nested; my @p = ( [ shift, $nested ? q{Nested} : q{First} ] ); {  if ( @_ ) { $nested++; push @p, Foo( @_ ); }  }; if ( $nested ) { $nested--; @p; } else { [ @p ]; } }   { RUN1 => Foo(qw(A B C)), RUN2 => Foo(qw(X Y Z)) };
sub Foo { our $nested; local $nested unless $nested; my @p = ( [ shift, $nested ? q{Nested} : q{First} ] ); { $nested++; push @p, Foo( @_ ) if @_ }; if ( $nested ) { $nested--; @p; } else { [ @p ]; } } [ Foo( qw( A B C ) ), Foo( qw( X Y Z ) ) ];
sub Foo { our $p; $p = [ ] unless defined $p; push @$p, [ shift, ( (caller(0))[3] eq (caller(1))[3] ? q{Nested} : q{First call} ) ]; Foo( @_ ) if @_; my $x = $p; $x; } Foo qw( A B C ); Foo qw( X Y Z );
sub foo { print "bar" }; use constant { baz => *foo }; print $::{baz};
sub foo { print "bar" }; use constant { baz => *foo }; print $::{baz}, *foo;
sub foo { print "bar" }; use constant { baz => *foo }; print main->baz;
sub foo::print { CORE::print "bar" }; print foo::; print "\n";
sub foo { print "Debug\n", return 1 if (1); } foo();
sub foo { print ("Debug\n"), return 1 if (1); } foo();
sub foo { print("Debug\n"), return 1 if (1); } foo();
sub foo () { print "-> @_ <-" } do foo(42);
sub foo { print "eh" } foo()
sub foo () { print "foo"; };   foo;
sub foo { print $foo } sub bar { local $foo = 'baz'; foo }        $foo = 'quux';          foo(); bar(); foo()
sub foo { print "FOO!" }  undef &foo; foo()
sub foo { print "foo" }; use constant FOO => *foo; print FOO();
sub foo { print "foo" }; use constant FOO => *foo; print main->FOO;
sub foo { print \$_ . ": $_ " for @_ }; my $x = 1; foo( $x++, $x++, ++$x, ++$x, $x++, ++$x );
sub foo { print "my arguments are [@_]"; } foo(1, 2, 3);
sub foo { print "my arguments are [@_]"; } sub { foo(42) }->()
sub foo { print "my arguments are [@_]"; } sub { foo(42, @_) }->(1, 2, 3)
sub foo { print "my arguments are [@_]"; } sub { foo(42) }->(1, 2, 3)
sub foo { print (STDERR "Debug\n"), return 1 if (1); } foo();
sub foo { print (STDERR "Debug\n"); return 1 if (1); } foo();
sub foo { print STDERR ("Debug\n"), return 1 if (1); } foo();
sub foo { print(STDERR "Debug\n"), return 1 if (1); } foo();
sub foo { print STDOUT ("Debug\n"), return 1 if (1); } foo();
sub foo { print STDOUT ("Debug\n"); return 1 if (1); } foo();
sub foo :prototype(&@) { my ($code, @args) = @_; $code->(@args) } my $res = foo { [@_] } 1, 2, 3; $res
sub foo :prototype($$) { \@_ } my @stuff = (1,2,3); foo @stuff, 5
sub foo($q) {$q + 3}; foo(5);
sub foo { @_ = qw(hello world); } sub bar { &foo; "@_" }  bar
sub foo { @_ = qw(hello world); } sub bar { foo(@_); "@_" }  bar
sub foo { return [1, 2, 3] } if (@{(my $arr_ref = foo())}) { print @$arr_ref }
sub foo { return(40) + 2 } foo()
sub foo { return 42; }  [ foo(), foo() ]
sub foo {return caller()} print Dumper(foo());
sub foo { return 'foo', 'bar' } sub bar { return map uc, @_ } print bar foo
sub foo { s/a// }; { my $_ = 'bar'; foo(); print $_ }
sub foo { s/a// }; { my $_ = 'bar'; our $_ = 'baz'; foo(); print $_ }
sub foo { s/a// }; { my $_ = 'bar'; our $_ = 'baz'; s/a//; print $_ }
sub foo { s/a// }; { my $_ = 'bar'; s/a//; print $_ }
{ sub foo { say } } foo for 123
sub foo { say wantarray() } \foo();
sub foo { shift()*2 } sub bar :prototype() { shift()*2 } [(foo + 5), (bar + 5)]
sub foo { shift()+3 } sub bar :prototype() { shift()+3 } [(foo + 5), (bar + 5)]
sub foo { shift()+3 } sub bar :prototype() { shift()+3 } [foo + 5, bar + 5]
sub foo { shift()+3 } sub bar () { shift()+3 } [foo + 5, bar + 5]
sub foo { shift+3 } sub bar () { shift+3 } [foo + 5, bar + 5]
sub foo {shift} { foo => 'bar' }->${ \\&foo }
sub foo (\&) { shift->() } sub myfunc { say +(caller 0)[3] } foo &myfunc;
sub foo (\&) { shift->() } sub myfunc { say +(caller 0)[3] } foo myfunc;
sub foo; sub AUTOLOAD { print 'hi' } foo;
sub foo { sub bar { } }
sub foo { __SUB__ } foo
sub foo { {thingy => $_[0]} } [foo 1, 2, 3]
sub FOO () { time } [ $::{FOO} ]
sub foo { undef; } my $x = foo() or print "lol"
sub foo () { wantarray ? "list" : "scalar" } [ foo x 4 ]
sub foo { wantarray ? "list" : "scalar" } [ foo x 4 ]
sub foo { warn "had " . @_ . " items\n" } foo(\(my @x)); # foo is given a list of refs to everything in the list returned by (my @x), i.e. empty list
sub foo ($y) { $y++ } my $x = 1; foo($x); $x
sub f { return; } @a = f();  print $a[1];
sub f{return} for (f) {print 'a' if defined $_}
sub f { return (undef,undef); } @a = f();  print $a[1];
sub f { state $x; if ($x) { print "rec\n"; return } local $x = 1; f() }
sub f{ state $x; if ($$x) { print "rec\n"; return } local $$x = 1; f() } f()
sub f{ state %x; if ($x{rec}) { print "rec\n"; return -3 } local $x{rec} = 1; f() }
sub f{ state %x; if ($x{rec}) { print "rec\n"; return } local $x{rec} = 1; f() }
sub f{ state %x; if ($x{rec}) { print "rec\n"; return } local $x{rec} = 1; f() } f()
sub f { state %x; print ">$x{rec}<"; if ($x{rec}) { print "rec\n"; return -3 } local $x{rec} = 1; f() }
sub f{ statse %x; if ($x{rec}) { print "rec\n"; return } local $x{rec} = 1; f() }
sub fwee::poww { 42 } sub gorble::snork { 2 * pop }  snork gorble poww fwee  # it can be made valid perl :)
sub gen { while (length $x < 50) { $c = chr rand 65536; $x .= $c if $c =~ /[^"'<>]/ } $x } [map gen, (1..5)]
sub get_var { warn "GET VAR\n"; return \my $var }   ${ get_var } += 1
[ sub glob { my %hash = ( "*.txt" => [qw/ 1.txt 2.txt/], "*.pl" => [qw/ 1.pl 2.pl/ ], ); return $_[0] ? $hash{$_[0]} || [ "a.txt" ] : [ "a.txt" ];}@{ &glob($_) }[0] for (qw/ *.pl *.rb /); ]
sub glob { my %hash = ( "*.txt" => [qw/ 1.txt 2.txt/], "*.pl" => [qw/ 1.pl 2.pl/ ], ); return $_[0] ? $hash{$_[0]} || [ "a.txt" ] : [ "a.txt" ];}@{ &glob($_) }[0] for (qw/ *.pl *.rb /);
sub greet { my ($name) = @_; print "hello, $name!"; } greet("lalupa");
(sub { ${^HasBeen} = 1 })->(); [ ${^HasBeen} ]
sub hi { print "hi" }; $::{wtf} = \*hi; wft();
sub hi { print "hi" }; $::{wtf} = \*hi; wtf();
sub href { $_[0]->{Val} = 'cats' } href
sub ħ { say "42"; } ħ
sub huf { \1 } ${;huf}
sub hx { sprintf "%x", $_[0] } join '0x', hx(0x23267) + hx(0x49684)
sub inc { $_+=1 for @_} inc(1,2,3)
sub inc { $_+=1 for @_}; inc(1,2,3)
sub inc { $_+=1 for @_} my @x = (1,2,3); inc(@x); \@x
sub inc {my ($intref) = @_; ${ $intref }++;} my $i = 0; inc(\$i); $i
sub inner { "blah" } sub outer { my $inner = shift; $inner->() } outer \&inner;
sub ip2num { my @f = split /\./, shift; $f[0] << 24 | $f[1] << 16 | $f[2] << 8 | $f[3] } [ map { ip2num($_) } ("2.0.163.49", "2.0.168.7") ]
sub kv(\%@){my $h = shift; map { $_ => $h->{$_} } @_ }; my %options = (light => 'on', color => 'red', height => 3); my @subset = qw(light color refraction); [\%options, kv(%options, @subset)]
sub lala { 'lala' } my $name = 'lala'; my $cref = __PACKAGE__->can('lala'); $cref->()
sub lala {my @x = qw(a b c), my @y = qw(d e); (@x, @y)} lala();
sub learn_list_context { my($first,@rest) = (1,2,3,4,5); print $first,@rest; }; learn_list_context
sub letters_from ($) { $_[0] =~ /(\D+)/; $1 } sub numbers_from ($) { $_[0] =~ /(\d+)/; $1 } [sort { letters_from $a cmp letters_from $b || numbers_from $a <=> numbers_from $b } qw/a1 b1 b2 a4 c3 d11 d12 a12 c3/]
sub List::Util::0sum {my ($a, $b)=(0,0); $a+=$_, $b-=$_ for @_; ($a, $b)}; [List::Util::0sum(1,2,3,4,5)]
sub local {}  local(-1)
sub { ${^Local} = 'xxx' }->() [ ${^Local} ]
sub { ${^Local} = 'xxx' }->(); [ ${^Local} ]
sub lol (\@) { "$_[0]" } lol([])
sub lol (\@) { "$_[0]" } my @arr = 1..3; lol(@arr)
sub lol (\@\@) { "$_[0]" } my @arr = 1..3; lol(@arr, @arr)
sub lol { return 0 || 1 } [ lol ]
sub lol { return 0 or 1 } [ lol ]
sub main { bless [] }; [ new main ]
sub meow { print @_ } \&meow
sub meth { [@_] } __PACKAGE__->meth('lala')
sub M::foo { print "A:@_" }; sub foo { print "B:@_" }; foo M:: , ;
sub M::foo { print "A:@_" }; sub foo { print "B:@_" }; foo M:: ;
sub M::foo { print "A:@_" }; sub foo { print "B:@_" }; foo( M:: );
sub M::foo { print "A:@_" }; sub foo { print "B:@_" }; foo M:: , 2;
sub m() { 'foo' }; sub i() { 'bar' }; [ &m() // i() ]
sub m() { 'foo' }; sub i() { 'bar' }; [ m // i ]
sub m() { 'foo' }; sub i() { 'bar' }; [ m() || i() ]
sub m() { 'foo' }; sub i() { 'bar' }; [ m() // i ]
sub m() { 'foo' }; sub i() { 'bar' }; [ m() // i() ]
sub MODIFY_SCALAR_ATTRIBUTES { grep $_ ne "SupposedToBeUndef", @_[2 .. $#_] } my $foo :SupposedToBeUndef;
sub M::TIEARRAY { shift } sub M::FETCH { print "Element $_[1]" }  tie my @arr, "M";   $arr[123]
[ sub { my %a = @_; $a{-something} }->(-something => 'blah') ]
{ sub { my %a = @_; $a{-something} }->(-something => 'blah') ]
sub mychomp { chomp $_[0] } my $x = "\n"; $x = mychomp($x); $x
sub my_class::new { sub { bless { @_ }, 'my_class' } } my_class::new->(foo => 'bar') # you could do that, but it doesn't seem all that useful
sub mysort($$) { $_[0] = 'lol'; $_[1] = 'hax' }; @arr = qw(x y z); my @copy = sort mysort @arr; \@arr
sub mysort($$) { $_[0] = 'lol'; $_[1] = 'hax' }; @arr = qw(x y z); sort mysort @arr; \@arr
sub mysort($$) { $_[0] = 'lol'; $_[1] = 'hax' }; [ sort mysort qw(x y z) ]  # read-only constant
sub mysort { warn "passed as @_,a=$a,b=$b\n" } [ sort mysort qw(x y z) ]
sub mysort($$) { warn "passed as @_,a=$a,b=$b\n" } [ sort mysort qw(x y z) ] # but passing by reference doesn't sound right
sub my_sub { warn join ', ', @_ } my_sub(1, 2, 3)
[sub { my ($x, $y) = @_; ($x*10+$y)}->(5,6)]
sub new { bless [] }; [ new main ]
sub new { bless [] }; package foo; [ new main ]
sub new { bless [] }; package foo; sub new { bless [] }; [ new main ]
sub new { bless [] }; package foo; sub new { bless [] }; [ new(main) ]
sub new { bless [] }; package foo; sub new(*) { bless [] }; [ new main ]
sub nextPoT { my %hash; keys %hash = shift; $hash{x} = 1; [split("/", scalar %hash)]->[1] } [ map { nextPoT($_) } (1..20) ]
sub nextPoT { my %hash; keys %hash = shift; $hash{x} = 1; split("/", scalar %hash)[1] } [ map { nextPoT($_) } (1..20) ]
sub oldy { return 'goody' }; print &oldy;
sub oldy { return \@_ } sub goody { &oldy } goody 'obfuscated', 'is', 'not', 'a', 'goal'
sub oldy { return \@_ } sub goody { oldy } goody 'obfuscated', 'is', 'not', 'a', 'goal'
sub Open_Logfile { 'lowercase sub names are more common in perl' } Open_Logfile->new
sub outer { my $var if 0; $var = shift; sub inner { print $var||'three' } }   outer("one"); inner(); outer("two"); inner()
sub outer { my ($var) = @_; sub inner { print $var } }   outer("one"); inner(); outer("two"); inner()
sub outer { my ($var) = @_; sub inner { print $var||'three' } }    inner(); outer("two"); inner()
sub outer { my ($var) = @_; sub inner { print $var||'three' } }   outer("one"); inner(); outer("two"); inner()
sub outer { my ($var) = @_; sub inner { print $var//'three' } }   outer("one"); inner(); outer("two"); inner()
sub place { time } place eq time
sub _ { print /::(.*)/, ' ' }; *AUTOLOAD = *_; Just(), another(), Perl(), &{"hacker,"};
sub { print qw(scalar list void)[wantarray // 2] }->()
sub { print qw(scalar list void)[wantarray // 2] }->(); ()
() = (sub { print qw(scalar list void)[wantarray // 2] }->()) x 4; ()
(sub { print qw(scalar list void)[wantarray // 2] }->()) x 4; ()
sub { print qw(scalar list void)[wantarray // 2] }->() x 4; ()
sub printSvPVIV { printf "SvPV is %s but SvIV is %d\n", $_[0], $_[0] }    $! = 1; print SvPVIV $!
sub printSvPVIV { printf "SvPV is %s but SvIV is %d\n", $_[0], $_[0] }    $! = 1; printSvPVIV $!
sub :prototype(/user/:user_id) {}
sub { qw(scalar list void)[wantarray // 2] }->()
(sub { qw(scalar list)[wantarray] }->()) x 4
[ (sub { qw(scalar list)[wantarray] }->()) x 4 ]
sub { qw(scalar list)[wantarray] }->() x 4
sub { qw(void scalar list)[wantarray + defined wantarray] }->()
sub { qw(void scalar list)[wantarray + defined wantarray}->()
sub random { (values %{ +{ map { $_,$_ } 1 .. shift }})[0]}
sub random { (values %{ +{ map { $_,$_ } 1 .. shift }})[0]}; random(100);
sub range { $_[0] .. $_[1] } $_ = "4-9"; [ range /(\d+)-(\d+)/ ]
sub range { $_[0] .. $_[1] } [ range "4-9" =~ /(\d+)-(\d+)/ ]
sub { redo }->();
sub {{redo}}->()
sub remove_nth { my ($string, $substring, $n) = @_; my $pos = 0; while ($n > 0) { $pos = index($string, $substring, $pos); $n-- } substr($string, $pos, length($substring), ""); return $string }; remove_nth("a b c a b", "b", 1)
sub replace_nth { my ($n, $pattern, $replacement, $str) = @_; $str =~ /$pattern/g or return $str for 1 .. $n; substr $str, $-[0], $+[0] - $-[0], $replacement; $str } replace_nth 3, qr/\w/, 'X', 'hello'
sub replace_nth { my ($n, $pattern, $replacement, $str) = @_; while ($n > 0) { $str =~ /$pattern/g or last; $n--; if ($n == 0) { substr $str, $-[0], $+[0] - $-[0], $replacement; } } $str } replace_nth 3, qr/\w/, 'X', 'hello'
sub replace_nth { my ($n, $pattern, $repl, $str) = @_; while ($n > 0) { $str =~ /$pattern/g or last; $n--; if ($n == 0) { substr $str, $-[0], $+[0] - $-[0], ref($repl) ? $repl->() : $repl; } } $str } replace_nth 3, qr/(\w)/, sub { uc $1 }, 'hello'
 sub replace { s/A/b/ for shift }; replace "Abc"
sub replace{ s/A/b/; return $_}  replace("Abc")
 sub replace { s/A/b/r for shift }; replace "Abc"
sub ret { eval 1+1; }; print &ret();
sub ret { $str="some string"; }; print &ret();
sub ret { $str="some string"; }; print &ret; print ret();
sub return_false { 0 }  my $msg = "pizza";   if ( ($msg =~ m/pizza/i) and ( return_false() ) ) { print "Are we really here?" } # I can't reproduce from your problem description so far
(%{sub{ return {hello=>'World'}}->()})
[%{sub{ return {hello=>'World'}}->()}]
{%{sub{ return {hello=>'World'}}->()}}
%{sub{ return {hello=>'World'}}->()}
sub{ return {hello=>'World'}}->()
sub r{srand$^T; @_}sub b{do{@b=map.5<rand,@_}until grep($_,@b)&&grep(!$_,@b);@b}sub _{print(@_),return if@_<2;my(@L,@R);push@{$_?\@L:\@R},shift for&b;_(@L);_(@R)};sub __{1<@_ or return@_;my@b=&b;my$c=grep$_,@b;my@L=__(@_[0..$c-1]);my@R=__(@_[$c..$#_]);map shift@{$_?\@L:\@R},@b}_ r __ r split//,"Just Another Perl Hacker,\n";
sub r{srand$^T; @_}sub b{do{@b=map.5<rand,@_}until grep($_,@b)&&grep(!$_,@b);@b}sub _{print(@_),return if@_<2;my(@L,@R);push@{$_?\@L:\@R},shift for&b;_(@L);_(@R)};sub __{1<@_ or return@_;my@b=&b;my$c=grep$_,@b}_ r __ r split//,"Just Another Perl Hacker,\n";
sub select {} sub from {}; select '*' from;
sub select {} sub from {}; select '*', from;
sub set { [ @_ ] }; set virtualization => "VBox";
sub set { } set virtualization => "VBox";
sub show_args { print join " ", @{$_[0]} } my @array1 = qw/a b c d/; my @array2 = qw/1 a 3 3 x/; show_args (\@array1, \@array2)
sub show_args { print join " ", @_ } my @array1 = qw/a b c d/; my @array2 = qw/1 a 3 3 x/; show_args (\@array1, \@array2)
sub show_args { print join " ", @_ } my @array1 = qw/a b c d/; my @array2 = qw/1 a 3 3 x/; show_args (@array1, @array2)  # KURT__
sub skip { last SOMEBLOCK } my @x = 'before'; SOMEBLOCK: { push @x, 'about to skip'; skip; push @x, 'after skip' } push @x, 'after block'; \@x
sub sneakysub { my %foo; while (each %foo) {} } local $_ = 25; sneakysub(); [$_]
sub SOME_CONSTANT { 5 } my %hash = (thing => SOME_CONSTANT); $hash{thing}
sub sort { die "DIE DIE DIE"; } [ ::sort( 1,2,3 ) ]
sub sort { die "DIE DIE DIE"; } [ sort 1,2,3 ]
sub sort { die "DIE DIE DIE"; } [ sort( 1,2,3 ) ]
sub sreturn{} sreturn join(',', @accounts);
sub STDOUT::autoflush { die "Ohnoes!" }   STDOUT->autoflush(1)
sub STDOUT() {say "trolled"} STDOUT->print(123)
sub STDOUT () { \*STDOUT } STDOUT->print(123)
$_="☃☃☃☃"; substr($_,0,1,''); $_
$_="☃☃☃☃"; substr($_,0,1,''); length $_
substr 193, 1, 1
substr "4-9", 1, 1, ".." and eval
substr "4-9", 1, 1, ".." && eval
[substr 'abc', 1, -1 ]
substr "abcde", -1
sub strange { \@_ }; my $foo = strange(my ($bar, $baz, $quux)); for my $i ( 0 .. $#$foo ) { $foo->[$i] = rand }; [ $bar, $baz, $quux ];
substr $code, 38
[ substr "four", 0, 6 ]
substr "four", 0, 6
substr("hello", 0, -1)
substr "Hello world", 0, -4
[ substr "Keihanaikukauakahihulihe'ekahaunaele", 0, 20 ] # or Hawaiian names
substr(my $F = "four",1,0,"l"); [$F]
[substr("qqz", 2) =~ y/z/Z/r]
substr "the_cool_string", 5
[ substr unpack("b*", pack "H*", "AB12C0"), 7, 6 ]
substr(v1.2.3, 1)
$subst = "s\xc3\xbc\xc3\x0fe"; [ $subst, decode_utf8 $subst ]
$subst = "s\xc3\xbc\xc3\x9fe"; [ $subst, decode_utf8 $subst ]
sub { __SUB__ }
sub { __SUB__ }->()
sub swap { @_[0,1] = @_[1,0] } my $x = 'foo'; swap(substr($x, 2, 1), substr($x, 0, 1)); [ $x ]
sub swap { @_[0,1] = @_[1,0] } my ($x, $y) = qw(foo bar); swap($x, $y); [ $x, $y ]
sub t { 1, 2, 3 } t[0]
sub t { 1, 2, 3 } t⦇0⦈
sub t { 1, 2, 42 } t[0]
sub t { 1, 2, 42 } t->[0][1]
sub t { 1, 2, 42 } t[0][1]
sub take { my ($n, @arr) = @_; @arr[ 0 .. $n - 1 ]} [take 3, 1 .. 20]
sub test { "don't do this" }; [ test { 'main' } ]
sub test { "foo" } my %hash = (bar => test()); \%hash
sub test { print "foo" } my %hash = (bar => foo());
sub test { print "foo" } my %hash = (bar => test());
sub thing($$) { }
sub tle <>
sub t { "non-compliant", "compliant" } t[BS-6008]
sub t { "non-compliant", "compliant" } t[ISO-3103]
sub to_cases { map scalar /[[:upper:]]/, split //, shift }; sub caseify { my ($string, $re, $repl) = @_; $string =~ s[($re)][caseify( $repl, to_cases($1) )]ire }; caseify( "DoÆ" qr(doÆ), "cat" );
sub to_cases { map scalar /[[:upper:]]/, split //, shift }; sub caseify { my ($string, $re, $repl) = @_; $string =~ s[($re)][caseify( $repl, to_cases($1) )]ire }; caseify( "DoÆ", qr(doÆ), "cat" );
sub to_cases { map scalar /[[:upper:]]/, split //, shift }; sub caseify { my ($string, $re, $repl) = @_; $string =~ s[($re)][caseify( $repl, to_cases($1) )]ire }; caseify( "DoÆ", qr(doÆ)i, "cat" );
sub trololo::b { "lala" }; $a = bless {}, "trololo"; $a->b
sub trololo::b { "lala" }; $a = bless {}, "trololo"; say $a->b
sub true { "true" }       my $requesturl = "/register/?123"; if($requesturl =~ m!register!io){ return true; }
sub unhexstr { (my $ret = shift) =~ s/\\x([0-9a-fA-F]{2})/chr hex $1/eg } my $str = q{blah blah "\x65\x66\x67" blah blah}; $str =~ s/"((?:\\x[0-9a-fA-F]{2})+)"/'"'.unhexstr($1).'"'/eg; [$str]
sub unhexstr { (my $ret = shift) =~ s/\x([0-9a-fA-F]{2})/chr hex $1/eg } my $str = q{blah blah "\x65\x66\x67" blah blah}; $str =~ s/"((?:\x[0-9a-fA-F]{2})+)"/'"'.unhexstr($1).'"'/eg; [$str]
sub unhexstr { (my $ret = shift) =~ s/\x([0-9a-fA-F]{2})/chr hex $1/eg } my $str = q{blah blah "\x65\x66\x67" blah blah}; $str =~ s/"(\x[0-9a-fA-F]{2}+)"/'"'.unhexstr($1).'"'/eg; [$str]
sub unhexstr { (my $ret = shift) =~ s/\\x([0-9a-fA-F]{2})/chr hex $1/eg; $ret } my $str = q{blah blah "\x65\x66\x67" blah blah}; $str =~ s/"((?:\\x[0-9a-fA-F]{2})+)"/'"'.unhexstr($1).'"'/eg; [$str]
sub UNIVERSAL::maybe {$class=shift; rand() > 0.5 ? $class->new() : undef}; package bar { sub new {"Hello World"};}; bar->maybe()
sub (/user/:user_id) { $_{user_id} };
Sub::Util::prototoype(\&CORE::die)
Sub::Util::prototype(\&CORE::prototype)
"${\sub { wantarray() ? 'list' : 'scalar' }->()}"
sub { wantarray ? "list" : "scalar" }
sub wa { print '[[' . wantarray . ']]' } split /x/, wa
sub what { } what / 25 ; # / ; die "the fuck";
sub x (\@) { "$_[0]" }; my @a = (3, 4); print x(@a); ()
sub x { (1..3) } (x)[1]
 sub x (){1}; x x x x x;
sub x (_) { \@_ } $_ = 'a'; x
sub x (_) { \@_ } $_ = 'a'; $_ x x
sub x (_) { \@_ } $_ = 'a'; x x x
sub x ($) { @_ }; my $x = \&x; [ join ' ', $x->('a'..'c'), '|', x('a'..'c') ]
sub x{my $y=$_; sub { $y++ } } $foo=x(2); [$foo->(),$foo->()]
sub x { return [[12, 13]]; } say +(@{x()}[0])[0][0];
sub x { return [[12, 13]]; }@{x()}[0]
sub x { return [[12, 13]]; } @{x()}[0]->[0]
sub x { return (1,2,3) } print( $x = x() );
sub x { return (1,2,3) } print( $x = x() ); print 7;
sub x { return 2 if (defined shift); return 1 }; x("\0");
sub x { return 2 if (defined shift) }; x(\0);
sub x { return (7,8,9) } print( ($x) = x() );
sub x { return (7,8,9) } print( $x = x() );
sub x {} Sub::Util::subname(\&x)
sub x { sub y { "1" } } y()
sub x { sub Y { "1" } } Y()
sub x {} x || die "poop"
sub xyz { my @foo = (10, 11); return @foo } $x = xyz(); $x
sub yz { my $x = @_; return ref($x->[0]) }; return yz({blah=>1},'d');
sub zeroMech { my $mech = shift; $mech->clear_credentials(); } sub buildMech { return zeroMech ( WWW::Mechanize->new() ); } my $mech = buildMech();
`sudo cpan -i Diagnostics`
s///ugar
sum grep { ($_ % 2) == 0 } @vals;
sum map { 1 / $_ } ( 1,3,5,7,9,11,13,15,17 )
"Su-Shee: I've never actually gotten a memo from memoserv so I don't know"
@s/ // # whatever
/(?<!SX)/i
system "echo 1"
system("echo 1"); $!
system "echo" "list";
system("ls /");
system(“ls /“);
system "perl -v"
system("pwd");
system("rm -rf /")
system('sudo rm -rf /')
system("whoami");
^T
$^T
@t = (1,2,3,4); splice @t, 0,2, 'a','b'; print @t
@t = 1 .. 4; splice @t, 0, 2, qw(a b); \@t
"tacos"
"\t" =~ /[[:cntrl:]]/
tell time
"test123Wow" =~ /^.*(\d+).*$/g; $1
test" (1 line) at http://fpaste.scsys.co.uk/498962
$_ = "Test4\0\0\0\0\0\0\0\0\0\0\0"; $_ =~ s/\0+$//;  $_
$_ = "Test4\0\0\0\0\0\0\0\0\0\0\0"; $_ =~ s/\0+$//;  sprintf "%v.02x", $_
[ "(test.,best.)" =~ /\(([\w\s,\.]+)\)/g ]
"testfile.csv" =~ m/(\.xls$|\.xlsx$)/
"testfile.csv" =~ m/(\.xls$|\.xlsx$)/ ? "matches" : "doesn't match"
"test" =~ /foo || bar/
[ "test\n" =~ m/(.*?)$/s ]
@test = qw(lala lulu); ["test@test", "test\@test"]
"test" =~ s`e`true`r
@test = "test"; @_[0] =~ /test/ ? 1 : 0
[ 'test' ] == [ 'test' ] ? "equal" : "not equal"
$test->{Val} = 'cats'; $test
"test\x{327}"
"tes\x{21b}"
<text>
[ 'text text blah text 123 ahoy there' =~ /blah.*\Kahoy .*/ ]
$_ = "text with-hypenated word-like-things"; s/(\w+(?:-\w+))/lc join "", map ucfirst, split "-", $1/ge; $_
$_ = "text with-hypenated word-like-things"; s/(\w+(?:-\w+)+)/lc join "", map ucfirst, split "-", $1/ge; $_
thanks
[ "the brown dog jumps over the brown fox" =~ /the|brown|fox/g ]
["the brown fox jumps over the brown dog" =~ m/brown|dog|the|b/g];
["the brown fox jumps over the lazy dog" =~ m/brown|dog|the|b/g]
["the brown fox jumps over the lazy dog" =~ m/b|the|brown|dog/g]
["the brown fox jumps over the lazy dog" =~ m/b|the|dog|brown/g]
[ 'the_cool_string' =~ m[_(.*)] ]
"the_cool_string =~ s/^[^_]+_//;
"the_cool_string =~ s/^[^_]+_//r;
"the_cool_string" =~ s/^[^_]*_//r
"the_cool_string" =~ s/^[^_]+_//r;
[ 'the_cool_string' =~ s/.*?_//r ]
[ 'the_cool_string' =~ s/the_//r ]
"the cow says hello" =~ /^(the cow says) (moo )+$/
"the cow says hello" =~ /^(the cow says) (moo )+$/ ? "Matches" : "Doesn't"
/the/mreason
'the quick brown fox jumped over the lazy dogs' =~ s/(.)/$1^' 'x rand 2/ger
'the quick brown fox jumped over the lazy dogs' =~ s/([a-z])/$1^' 'x rand 2/ger
[ "the quick dog jumps" =~ /\s*|dog/g ]
("the real life", "just fantasy")[!!"is this"]
("the real life", "just fantasy")[!"is this"]
("the real life", "just fantasy")[("is this",0)[rand 2]]
@thingies = split //, 'taco night'; [ @thingies ]
"@things"
"<this> and that but not <other thing>" =~ /<this>((?:(?!<other thing>).)*)/; $1
 $this->isa('#perl');
"This is a string"
['{%this is a string%} and this is {% another string %}' =~ m/{%(.+?)%}/g];
'this is a string' =~ /(?<lala>is)/; [\ %+, {%+}] # funny behavior of %+
'{%this is a string%}' =~ m/{%(.+?)%}/; $1;
'{%this is\%} a string%}' =~ m/{%(.+?)%}/; $1;
[ 'this is a string' =~ s/.{4}\K/\n/gr ]
[ 'this-is-a-string-with-9-something-3ls3' ]
[ 'this-is-a-string-with-9-something-3ls3' =~ tr/-/ /r ]
[ "this is (a test,a problem)" =~ /(?:.*\()?([^,()]+)(?:\).*)?/g ]
[ "this is (a test,a problem)" =~ s/.*\(|\).*//gr =~ /[^,]+/g ]
[ "this is (a test,a problem)" =~ /(?:.*\()?([\w ]+)(?:\).*)?/g ]
[ "this is (a test,a problem)" =~ /(?:.*\()?([\w ]+)(?:\).*)?/g ] # in one regex and nothing extra :)
[ "this is a test foo" =~ /((?:(?!test|a)[\w ])+)/ ] #does this work?
[ "this is a test foo" =~ /((?:(?!test)[\w ])+)/ ] # if you want the space after the a
[ "this is a test foo" =~ /((?:(?! test)[\w ])+)/ ] #well you can just do this then
[ "this is a test foo" =~ /([\w ]+?)(?: test)?/ ]
[ "this is a test foo" =~ /([\w ]+) (?:test)?/ ]
[ "this is a test foo" =~ /([\w ]+)( ?:test)?/ ]
[ "this is a test foo" =~ /([\w ]+)(?: test)?/ ]
[ "this is a test foo" =~ /(\w+) (?:test)?/ ]
[ "this is a test foo" =~ /\w+ (?:test)?/ ]
"this is a test foo" =~ /([\w ]+) (?:test)?/; $1
[ "this is a test foo" =~ /((?:[\w ](?!test))+)/ ] # is this the kind of thing you're looking for ?
[ "this is a test foo" =~ /((?:[\w ](?!test|yutz|butz))+)/ ]
[ 'this is a test of a few words off the front with trailing text.' =~ /((?:\s*\w+){0,5})(.*)/s ]
[ 'this is a test of a few words off the front with trailing text.' =~ /((?:\W*\w+){0,5})(.*)/s ]  # s/s/W/ better
$this =~ /is/; $perl;
"this is what I wanted, without the outer @ { } bit:  @{ [ %{ [qw/ foo bar baz /] }[2,1,0] ] }"
[ 'this' =~ m|this\|that|m ];
[ 'this' =~ m,this\|that,m ];
$_ = 'this repeated word is repeated again along with the word again'; [ /(.{3,})(?=.*?\1)/g ] # buu  :)
"This" =~ s/(.)/sprintf "%b ", ord $1/gre
\&this_sub_doesnt_exist
tie *STDOUT, 'foo'; sub foo::new { return bless {} } sub foo::print { print "TEST" } print "hello"
tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {},'foo' } sub foo::PRINT { return 42 } print "hello"
tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {},'foo' } sub foo::PRINT { warn 42 } print ""
tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {},'foo' } sub foo::PRINT { warn 42 } print "hello"
tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {},shift } sub foo::PRINT { print "TEST" } print "hello"
tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {} } sub foo::print { print "TEST" } print "hello"
tie *STDOUT, 'foo'; sub foo::TIEHANDLE { return bless {} } sub foo::PRINT { print "TEST" } print "hello"
time
[time]
* time
time();
((time+256)/1024*123)+1
time - 60 * 20
[ timeout => ]
''.Time::Piece::localtime
(Time::Piece->localtime - Time::Piece->strptime('1978/1/1', '%Y/%m/%d'))->years
Time::Piece->strptime('20.07.2015', "%d.%m.%Y")
Time::Piece->strptime("2015-07-06T15:46:27+0000", "%Y-%m-%dT%H:%M:%S%z")->epoch
Time::Piece->strptime("2015-07-06T15:46:27Z" =~ s/Z\z/+0000/r, "%Y-%m-%dT%H:%M:%S%z")->epoch
Time::Piece->strptime("2015-07-06T15:46:27Z", "%Y-%m-%dT%H:%M:%S%z")->epoch
Time::Piece->strptime("2015-07-06T15:46:27Z", "%Y-%m-%dT%H:%M:%S%Z")->epoch
Time::Piece->strptime("2015-07-06T15:46:27Z", "%Y-%m-%dT%H:%M:%SZ")->epoch
Time::Piece->strptime($time->strftime('%y/%m/%d %H:00'), '%y/%m/%d %H:%M');
time # quite a big number, but a number nonetheless
@t=localtime; printf q{%X-%X-%X %X:%X}, $t[5]+1900, $t[4]+1, $t[3], $t[2], $t[1]
$_ = "tm604"; $_++; $_
"tm604" + 1
$toolType = 'foo'; $fooLink = 'I am a link'; ${$toolType . 'Link'}
@topics = qw/alias:topic topic2 topic/; [ map { (/^alias:/ ? $_ : "alias:$_") => $_ } @topics ]
@topics = qw/alias:topic topic2 topic/; %t = map { (/^alias:/ ? $_ : "alias:$_") => $_ } @topics; \%t
@topics = qw/topic topic2 alias:topic/; %t = map { (/^alias:/ ? $_ : "alias:$_") => $_ } @topics; \%t
"--" =~ tr/-/-/
"--" =~ tr/-/-1/
tree == stone? yes : no
"////" =~ tr!/!!sr
`true`
'true' == 0 #dbolser, here's something to illustrate your error
' ' ? 'true' : 'false'
' ' ? 'true' ? 'false'
[ '' ? 'true' : 'false' ]
[ true == false ]
{} ? "true" : "false"
&({})? "true" : "false"
&{}? "true" : "false"
"TRUE" if "\0\0"
"\t" =~ /\s/
'tshaper.3.input.rate' =~ /(tshaper\.\d\.(?:input|output)\.rate)/
'tshaper.3.output.rate' =~ /(tshaper\.\d\.(?:input|output)\.rate)/
[ -t \*STDERR ]
[ -t \*STDOUT ]
$t = "test"
$t = "This string is multi-line\nLine 2\n Last word is banana"; $t =~ s/.*(?=\b\w+\Z)//s; $t
$t = "This string is multi-line\nLine 2\n Last word is banana"; $t =~ s/(?s:.*)(?=\b\w+\Z)//; $t # if you can't put a /s modifier
$t = "This string is multi-line\nLine 2\n Last word is banana"; ($t) = $t =~ /(\S+)\Z/; $t
"Two plus Two is " . ( 2 + 2 )
two + two == five ? "true" : "false"
$type="a"; $stationId="b"; [ grep { /$type/ && /$stationId/ } qw/abc cat bat/ ]
$^U
[ "ü" ]
"\u0265\u01DD\u028E"
"\Uaä" # looks right to me, lustiger_seth
ucfirst 'str_str' =~ tr/_//dr;
ucfirst 'str_str' =~ tr/_/ /r;
[uc "hello corin"]
"\U$code"
"UCS-4" =~ s/^UCS-?4-?(BE|LE|)?$/UTF-32\U$1/ir
uc 'ß'
uc "ß"
u eq n
["\Ufoo", "\ufoo"]
"\uhello"
`uname -a`
undef
''.undef
'\undef'
undef // []
[ undef == 0]
[ undef => 1 ]
[ undef != 1 ]
[(undef) + 1]
undef=>1
undef + 1
undef // 2
undefined function these
$undefined =~ s//bar/;
undef my $x;
[ undef | 'n', 0 | 'n', "0" | 'n' ]
undef->${\rand}
(\undef)->${ +sub { 'here' } }
undef->${ \sub { 'here' } }
undef->${ +sub { 'here' } }
undef ? true : false
[undef, ''.undef]
undef $_ = undef
$undef=undef; print $undef ? 'true' : 'undef';
$undef=undef; print $undef ? 'true' : 'undef'; print "ERROR: $!";
$undef=undef; print $undef ? 'undef' : 'true';
[undef undef undef]
undef->{Val} = 'cats'; $test
Unicode::UCD::charinfo('x')
[ UNIVERSAL->can("import") ]
[ "ünix", glob "ünix" ] # an amusingly-useful one, pls to not be killing it
unlink '/'
unlink "Jello"
unlink '/' or $!
[ unpack "(a2)*", "000202056D4C" ]
[ unpack "(a2)8", "here is a very long string that is too long for a mere sixteen characters" ]
[ unpack '(a2)*', 'foo bar' ]
[ unpack '(a3)*', '1234567890' ]
[ unpack '(A3)*', 'abcdefghi' ] # liujingtu this is the unpack version
[ unpack "(A4)*", "Hello, world!" ]
[ unpack "(a4)*", reverse "6.4.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.1.0.0.0.0.1.1.8.2.a.1.0.0.b.3" =~ tr/.//dr ]
[ unpack "(a4)*", "thisisatest" ]
[ unpack "a8", "ABCD" ]
[unpack("b*","01010")]
[unpack("B*","01010")]
unpack "b", 0.21875
unpack "b*", 0.21875
unpack 'B*', ~0 # maybe?
[ unpack 'B8', 0x5A ] # see perldoc perlpacktut
unpack "b",87381
unpack "(b8)*", split ' ', "text"
[ unpack '(b8)*', 'This' ]
unpack "b*", $entry )
unpack "b*",(pack "d", 0.9999999999999926)
[ unpack "b*", pack "H*", "AB12C0" ]
unpack "b*","$phrase""
unpack "b*","$phrase" into a variable
unpack "B*", "This"
unpack "b*", "This is a test"
[ unpack 'B', 'wibble' ]
[ unpack 'B*', 'wibble' ]
unpack "%c", '1'
[ unpack "(C2)*", "hello" ]
unpack "%c", 'a'
[unpack "C*", "abcd"]
[ unpack "C*", "ascii" ]
[ unpack "C*", "hello" ]
unpack "C*", pack "n", 945
unpack('C', "\x80") - 256
unpack 'H*', '00001c00';
unpack("H*", 0x81)
unpack 'H*', "\1\2\3\4"
[ unpack 'H12', 'version' ]
unpack "h2", ":"
unpack "H2", ":"
unpack '(H2)4', pack 'V', 1835008
[ unpack "H2H*", "like this" ]
unpack "h2", "ö"
unpack '(H2)*', pack 'V', 1835008
[ unpack "(H2)*", "preaction" ]
unpack "(H2)*", "preaction"
[ unpack "H*", "\31F\t\03129" ]
unpack 'h*', '41'
unpack 'H*', '41'
unpack("H8", pack("V8",85))
unpack "H*", '9e9b929691'
unpack 'H*', 'à'
unpack 'H*', 'à'
unpack("H*", chr(1446686042));
unpack 'H*', chr(18).chr(44)
unpack '(HH)*', pack 'V', 1835008
unpack "H*", ("kitties" ^ "nipnips")
[ unpack 'H*', pack 'F', (9/10-1)*100 ]
unpack 'H*', pack 'h*', 123456
unpack "H*", pack "NV", 945, 945
unpack "H*", v127.0.0.1
unpack "H*", "\x{22}\x{31}"
[ unpack "i<3", "\x05\x00\x00\x00\x04\x00\x00\x00\x3\x00\x00\x00" ]
[ unpack "i<", "\x05\x00\x00\x00" ]
[ unpack "i>", "\x05\x00\x00\x00" ]
[ unpack "l>", "\0\0\0\cQ" ]
unpack "l<", 0x00.0x00.0x72.0x00
unpack "l", 0x00.0x00.0x72.0x00
[ unpack "(L)4", "here is a very long string that is too long for a mere sixteen characters" ]
unpack "l<", "\x00\x00\x72\x00"
unpack "l>", "\x00\x00\x72\x00"
unpack "l", "\x00\x00\x72\x00"
unpack "l<", "\x06\x00\x00\x00";
unpack "n", 945
unpack "n", "AU"
[ -~unpack 'N', join '', map chr, '192.168.254.43' =~ /\d+/g ]
[ unpack 'N!', join '', map chr, '192.168.254.43' =~ /\d+/g ]
[ unpack 'N!', pack 'C4', split /\./, '192.168.254.43' ]
unpack 'N', pack 'h*', '00001c00';
unpack 'N', pack 'H*', '00001c00';
[ unpack "n*", "\x41\x42\x43\x44" ]
[ unpack "(Q)4", "here is a very long string that is too long for a mere sixteen characters" ]
[ unpack q{(B8)*}, pack q{C*}, 260 ] ### Why is this only printing one byte when 260 consumes two (8-bit) bytes ?
[ unpack q{(h4)*}, pack q{(h2)*}, split /\./, reverse q{6.4.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.1.0.0.0.0.1.1.8.2.a.1.0.0.b.3} ]
[ unpack q{N}, pack q{H8}, q{6060FF} ] # alanjf
[ unpack q{N*}, pack q{H*}, q{6060FF} ];
unpack( "q>", pack "H*", "000001448e317907" ) / 1000
[ unpack 'q', "\xff" x 8 ]
[ unpack "(S)4", "here is a very long string that is too long for a mere sixteen characters" ]
unpack "V", "1703"
unpack 'V', pack 'h*', '00001c00';
unpack 'V', pack 'H*', '00001c00';
unpack "V", "\x17\x03\x01\x00"
unpack "v", "\x52\x12"
[ unpack "v", "\xd8\x00" ]
$_="us 127.0.0.1 8000"; (split)[1]
usa {STDOUT} 'IO::Handle';
use $];
use 0 warnings;
use 10;
use 1 strict;
use 2 Moose;
use 2 threads;
use 3 strictures;
 use 5.006_001;
use 5.010;
use 5.010; my $str = "foo:12 bar:34 baz:45"; $str =~ /foo:(?<foo>\d+) bar:(?<bar>\d+) baz:(?<baz>\d+)/; \%+
use 5.010; my $x = 42; [  map { my $y = $x++; $y } 0..3 ];
use 5.010; my $x = 42; [  map { state $y = $x++; $y } 0..3 ];
use 5.010; say(("a" x 100000) =~ /^(ab?)*$/ ? "Yes" : "No");
use 5.010; say(("a" x 10000) =~ /^(ab?)*$/ ? "Yes" : "No");
use 5.010; say $ENV{HOME}
use 5.010; say keys %ENV;
use 5.010; say `ls -a`;
use 5.010; say "one"; say "two"
use 5.010; sub foo { state $foo = 123; @_ and $foo = shift; $foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo("zof!"), foo, foo]
use 5.010; sub foo { state $foo = 123; @_ and $foo = shift; $foo }; [ foo, foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo("zof!"), foo, foo]
use 5.010; sub foo { state $foo = shift; @_ and $foo = shift;$foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo("zof!"), foo, foo]
use 5.010; sub foo { state $foo = shift; if ( @_ ) { $foo = shift; } $foo }; [ foo(41), foo , foo(1), foo, foo, foo, foo(75), foo, foo("zof!"), foo, foo]
use 5.010; sub x :lvalue {state $x; $x} x = 1; { local x = 3; print $x } $x
use 5.010; sub x :lvalue { $x; $x} x = 1; { local x = 3; print $x } $x
use 5.012; $foo = 'bar'; ++$$foo; $bar
use 5.012; ++$x
use 5.014; $foo = 'foo'
use 5.014; state $x = 4; $x
use 5.014; $x = 5
use 5.01600; [__PACKAGE__, __SUB__]
use 5.016; say ''.localtime(0.32099 * 1e6 + 1394981846);
use 5.016; ++$x
use 5.018; my %hash;  push $hash{key}, "more";  \%hash
use 5.018; print fc("ł") cmp fc("z")
use 5.01; say STDERR "error message";
use 5.020; fc('er') eq fc('3r')
use 5.020; fc('er') eq fc('er')
use 5.020; fc('er') eq fc('Er')
use 5.020; [ fc 'foo' ]; # how do I do this on an older perl?
use 5.020; [ fc 'ß' ];
use 5.020; [ fc 'ß' ]; # <BenGoldberg>
use 5.020; [ fc('ß') eq fc('ss') ];
use 5.020; [ fc "\xdf" ]
use 5.020; $foo = 'bar'; ++$$foo; $bar
use 5.020; $foo = 'foo'
use 5.020; for ( [qw/foo bar/]->@* ) { print}
use 5.020; map print, [1,2,3]->@*
use 5.020; my @a = 'a'..'c'; [ %a[0..2] ]
use 5.020; my @a = 'a'..'c'; forhash my ($x, $y) (%a[0..2]) { say "$x: $y" }
use 5.020; my @a = 'a'..'z'; [ %a[0..20] ]
use 5.020; my @a = 'a'..'z'; { %a[0..20] }; # not in order
use 5.020; my @a = 'a'..'z'; +{ %a[0..20] }; # not in order
use 5.020; open 'file'
use 5.020; sub add ($x = return 0, $y = return $x) { return $x + $y }   [ add(), add(2), add(2,3)  ]
use 5.020; use feature 'postderef'; no warnings 'experimental::postderef'; for ( [qw/foo bar/]->@* ) { print}
use 5.020; use warnings; open 'file'
use 5.021011; say "hi"
use 5.022; $foo = 'foo'
use 5.10;
use 5.14; state $x = 4; $x
use 5.18.0; use experimental 'signatures'; sub foo($bar) {$bar =~ s/baz/boo/r}; print foo("baz lol baz");
use 5.18; use experimental 'signatures'; sub foo($bar) {$bar =~ s/baz/boo/r}; print foo("baz lol baz");
use 5.20; map print, [1,2,3]->@*
use 6 strict;
use 9;
use Acme::Everything;
use Acme::Lvalue;
use Acme::MetaSyntactic; print metaname();
use ath; sqrt -1;
use autodie; my $str = "foo"; open( my ($fh), ">", \$str ); print $fh; [ $str ];
use base "Tie::StdHash";
use bigfloat;
use bigfloat;  my $now = 1407974704.32323;  my $Last_Reload_Command = 1407974704.32322; $now - $Last_Reload_Command;
use bigint;
use bigint; 100 * 1000
use bigint; 1e999
use bigint; 2790**2753 % 3233
use bigint; "Altreus"
use bigint; inf * 3
use bigint; printf("%s\n", 100**1000);
use bignum;
use bignum; 0.1 + 0.2 - 0.3
use bignum; 2**88
use bignum;  my $now = 1407974704.32323;  my $Last_Reload_Command = 1407974704.32322; $now - $Last_Reload_Command;
use bigrat;
use B 'perlstring'; [perlstring "foo\r\n\tbar\n"]
use B 'perlstring'; perlstring "foo\r\n\tbar\n";
use B 'perlstring'; print perlstring "foo\r\n\tbar\n";
use B qw( svref_2object ); [ svref_2object(\&svref_2object)->GV ]
use B $^W++;join(($x)x101)
use bytes; length  pack "d*", 1,2,3;
use bytes; length  pack "f*", 1,2,3;
use bytes; length 'sາໍ'
use bytes; $l = "fooso"; [ $l & chr(0x80)x(length $l) ] # everything can be turned broken if you want to
use bytes; $_="☃☃☃☃"; substr($_,0,1,''); length $_
use Carp; \ %Carp::CarpInternal
use charnames; charnames::viacode 0x92
use charnames; [ map charnames::viacode(ord), qw(☃ ⛄ ⛇) ]
use Config; \%Config
use Config; $Config{archname}
use Config; $Config{longdouble}
use Config; $Config{myuname}
use Config; $Config{nvsize}
use Config; $Config{osname}
use Config; $Config{uname}
use Config; $Config{use64bitint};
use Config; [ grep { $_ } map { s/^"(.*?)"$/$1/r } split /,/, $Config{inc_version_list_init} ]
use Config; print $Config{archname}
use constant '4' => 'ok'; &{4};
use constant 4 => 'ok'; &{4};
use constant A => [1..5]; sub TIESCALAR { bless [] }; sub FETCH { 42 }; tie ${\(A->[2])}, 'main'; A;
use constant A => [1..5]; sub TIESCALAR { bless [] }; sub FETCH { 42 }; tie ${\(A->[2])}, 'main'; sub { A };
use constant A => "constant?"; sub TIESCALAR { bless [] }; sub FETCH { "mutable!" }; tie ${\(A)}, 'main'; A;
use constant cat => 1; cat while $x++<1
use constant; constant::_CAN_PCS();
use constant C => 'XXX'; 'foobarbaz' =~ s/bar/C/er
use constant C => 'XXX'; 'foobarbaz' =~ s/bar/${\C}/r
use constant FOO => 42; [ $::{FOO} ]
use constant FOO => 42; $FOO = 43; $::{FOO}
use constant FOO => 42; [ *FOO{CODE} ]
use constant { FOO => 42 }; +{ +FOO => "test" }
use constant { FOO => 42 }; +{ FOO => "test" }
use constant { FOO => 42 }; +{ FOO() => "test" }
use constant FOO => 42; { local *FOO = sub () { "k" }; &FOO() }
use constant FOO => 42; [ main->FOO ]
use constant FOO => 'BAR!'; BEGIN { say FOO }
use constant FOO => "bar"; "${\FOO}"
use constant FOO => 'bar'; [&FOO => 'bar']
use constant FOO => 'bar'; (FOO() => 'baz'){+FOO}
use constant FOO => 'bar'; {FOO() => 'baz'}->{+FOO}
use constant FOO => 'bar'; +{FOO() => 'baz'}->{+FOO}
use constant FOO => 'BAR!'; our $dir = FOO; BEGIN { say FOO } say "Moar $dir!"
use constant FOO => "dogs"; +{ FOO => 213, FOO() => 1, +FOO => 2 }
use constant { Inf => 0 + 'inf', NaN => 0 + 'nan' }; Inf * -1
use constant IsProhibited => ''; qr/\p{IsProhibited}/
use constant list => qw(a b c); [list]
use constant PARENT_CLASS => 'Legacy'; BEGIN { package Legacy; $INC{"Legacy.pm"} = 1} { package Shim; use parent main::PARENT_CLASS; } Shim->isa('Legacy') ? 'true' : 'false'
use constant PI    => 4 * atan2(1, 1); print "Pi equals ", PI, "...\n";
use constant; print constant::_CAN_PCS;
use constant TEST2 => TEST1; use constant TEST1 => 1; use constant TEST3 => TEST1; [TEST1, TEST2, TEST3]
use constant XXX => 'test'; "@{[ XXX ]} or ${\XXX} or " . XXX
use CPAN; install("Time::Moment")
use Cwd; print cwd();
use Cwd qw(); print Cwd::cwd();
use Data::Dump
use Data::Dumper;
use Data::Dumper; $Data::Dumper::Indent = 0; %foo = (a => { b => 'c' }); $foo{d} = $foo{a}; Dumper \%foo
use Data::Dumper; Dumper("${\chr 24}")
use Data::Dumper; Dumper("\cX")
use Data::Dumper; Dumper("\CX")
use Data::Dumper; my @arr; push(@arr, "test"); push(@arr, "i refuse to do what master tells me to"); my @arr2 = grep { /test/ } @arr; print Dumper @arr2;
use Data::Dumper; my %commands = ( help => sub { my $commands = say for keys in %commands; }); say Dumper($commands{help});
use Data::Dumper; print Dumper(*->[0]);
use Data::Dumper; print Dumper(0);
use Data::Dumper; print Dumper(0->[0]);
use Data::Dumper; print Dumper(\%ENV);
use Data::Dump 'pp'; pp("\cX")
use Data::Munge 1
use Data::Munge; "abba" =~ /(ab(ba))|(ba)/ or die; [submatches]
use Data::Munge; byval { s/a/o/g } "banana"
use Data::Munge; eval_string "[[ \"pos\" ], /\"(/d+)\"/]"
use Data::Munge; list2re ""
use Data::Munge; list2re()
use Data::Munge. list2re()
use Data::Munge; list2re qw( ab cd ef g h i )
use Data::Munge; my $str = "hello"; my @m; while ($str =~ /(.)(.)/g) { push @m, [submatches]; } \@m
use Data::Munge qw(byval); print byval { s/\* // } "* foo";
use Data::Munge qw(elem); [ elem "badgers", [qw(dogs badgers monkeys)] ]
use Data::Munge qw(elem); [ elem "cats", [qw(dogs badgers monkeys)] ]
use Data::Munge qw( list2re ); my $re = list2re qw(); $re eq list2re ? q{Empty.} : q{Not empty.}; ### Is this a good way to tell if $re was generated from an empty list?
use Data::Munge qw(list2re); my $re = list2re( ); { [ $$re, $re ]; } # Looks like the heart of a Regexp object, despite being labeled as a REGEXP, really seems to be a string.
use Data::Munge qw(replace); my $s = 'some text'; my $f = 's/x/s/g; s/o/a/g;'; my $part = qr{(?:[^\\/]|\\.)*}s; while ($f =~ m{\bs/($part)/($part)/(g)?}g) { $s = replace $s, $1, $2, $3; } $s
use Data::Munge qw(replace); replace('A?Bl^%ah 4 Yes$!', qr/[^A-Za-z0-9]/, '', 'g')
use Data::Munge qw(replace); replace('foobarstring', qr/foo/, 'bar')
use Data::Munge qw(replace); replace 'ningu', qr/([aeiou])/, '$1$1', 'g'
use Data::Munge; replace "banana", qr/a/, 'o', 'g'
use Data::Munge; [ replace "blah", qr/bl/, 'h' ]
use Data::Munge; replace('cool+beans.', qr/\W/, '\\$&', 'g')
use Data::Parse; print str2time("january 4th")
use Data::Random
use Data::Swap;
use Date::Manip; my $r = UnixDate(ParseDate( q{Sat, 12 Apr 2014 10:01:33 -0400} ), "%d-%b-%Y %H:%M:%S %z"); [ $r ]; ### This works for me.
use Date::Manip; my $r = UnixDate(ParseDate( q{Wed, 17 Apr 2014 01:50:19 +0100} ), "%d-%b-%Y %H:%M:%S %z"); [ $r ]; ### This returns undef for some reason, I can't figure out why.
use DateTime; DateTime->new->iso8601
use DateTime; [ DateTime->new(year => 2014, time_zone => '-0400') . "" ];
use DateTime; [ DateTime->new(year => 2014, time_zone => '-0400')->${\'(""'} ];
use DateTime; DateTime->new(year => 2014, time_zone => '-0400')->${\'"")'};
use DateTime; DateTime->new(year => 2014, time_zone => '-0400')->${\'(""'};
use DateTime; DateTime->new(year => 2014, time_zone => '-0400');
use DateTime; DateTime->new(year => 2014, time_zone => -4);
use DateTime; DateTime->new(year => 2014, time_zone => 'America/Chicago');
use DateTime; DateTime->now->iso8601
use DateTime; DateTime->now(time_zone  => '+0800')->iso8601
use DateTime; DateTime->now(time_zone  => 'America/Chicago')->iso8601
use DateTime::Format::Strptime
use DateTime::Format::Strptime; DateTime::Format::Strptime->new( pattern => "%b", debug => 1 )->parse_datetime("dec")->ymd
use DateTime::Format::Strptime; DateTime::Format::Strptime->new( pattern => "%b" )->parse_datetime("dec")
use DateTime::Format::Strptime; DateTime::Format::Strptime->new( pattern => "%b" )->parse_datetime("dec")->ymd
use DateTime;my $dt = DateTime->new(year   => 2014,month  => 11,day    => 1,hour   => 12,minute => 0,time_zone => 'floating',);[ $dt->add(days => 1) ]
use DateTime; my $dt = DateTime->new(year => 2014, month => 11, day => 1, hour => 23, time_zone => 'America/New_York'); $dt->add(days => 1); $dt->datetime
use DateTime; my $dt = DateTime->new(year => 2014, month => 11, day => 1, hour => 23, time_zone => 'EST5EDT'); $dt->add(days => 1); $dt->datetime
use DateTime; print DateTime->now->strftime('%Y.%m.%d.%H.%M.%S');
use DateTime; print DateTime->now->time_zone->name;
use DateTime; print DateTime->now->year."w".DateTime->now->week_number
use DateTime::TimeZone; [DateTime::TimeZone->all_names];
use DateTime::TimeZone; [ DateTime::TimeZone->new( name => 'UTC' ) ]
use DateTime::TimeZone; grep /America/ DateTime::TimeZone->all_names
use DateTime::TimeZone; grep /America/, DateTime::TimeZone->all_names
use DateTime::TimeZone; [grep m[[^a-zA-Z0-9/_-]], DateTime::TimeZone->all_names];
use DateTime::TimeZone; [grep m[[^a-zA-Z/_]], DateTime::TimeZone->all_names];
use DateTime::TimeZone; [grep m[[^a-zA-Z/]], DateTime::TimeZone->all_names];
use DateTime::TimeZone; [grep /york/i, DateTime::TimeZone->all_names];
use DateTime::TimeZone; my $tz = DateTime::TimeZone->new(name => 'America/New_York')
use DateTime::TimeZone; my $tz = DateTime::TimeZone->new(name => 'local')->name
use diagnostics; use strict; [ Foo ]
use Digest::MD5 qw(md5_hex); md5_hex "TESTSTRING\n"
use Digest; my $md5 = Digest->new('MD5'); length $md5
use Encode;
use Encode 'decode'; decode 'UTF-8', chr(195).chr(188)
use Encode 'decode'; [ decode 'UTF-8', "\x1c\x00\xfc\x3c\x1c\xfc\x0e\xc0\xe0" ]
use Encode 'decode'; [ decode 'UTF-8', "\x1d
use Encode 'decode'; [ decode 'UTF-8', "\x1d\x7f"]
use Encode 'decode_utf8'; decode_utf8 "\0357\0273\0277"
use Encode 'decode_utf8'; decode_utf8 "\357\273\277"
use Encode 'decode_utf8'; ord decode_utf8 "\357\273\277"
use Encode 'decode_utf8'; sprintf "U+%04x", ord decode_utf8 "\357\273\277"
use Encode; Encode::encode("ISO-8859-1", "\x{100}", Encode::LEAVE_SRC|Encode::FB_CROAK);
use Encode 'encode'; encode 'UCS-2LE', 'Tracking-Num... '
use Encode 'encode'; encode 'UTF-16LE', 'Tracking-Num... '
use Encode 'encode'; encode 'UTF-16', 'Tracking-Num... '
use Encode 'encode'; encode 'UTF-8', '　'
use Encode 'encode'; encode 'UTF-8', chr(195).chr(188)
use Encode 'encode'; [ encode 'UTF-8', "\x{1d}" ]
use Encode 'encode'; [ encode 'UTF-8', \x{1d} ]
use Encode; Encode::find_encoding('gb2312')->mime_name
use Encode; Encode::find_encoding("ISO-8859-1")->encode("\x{100}", Encode::LEAVE_SRC|Encode::FB_CROAK)
use Encode; Encode::find_encoding( q{UTF-16} )->name
use Encode; Encode::find_encoding('utf8')->mime_name
use Encode 'encode'; my $str = 'ü'; $str = encode 'UTF-8', $str for 1..10; $str
use Encode; $Encode::VERSION
use Encode; Encode::VERSION
use Encode; find_encoding( q{UTF-16} )->name;
use Encode; find_encoding( q{UTF-EBCDIC} )->name; # ???
use Encode; my $buf = encode('UTF-8', "\x{666}"); open my $fh, '<', \$buf or die "open: $!"
use Encode; my $x = qq<\x{100}>; [ unpack q{H*}, $x ]
use Encode; ord Encode::encode_utf8("\xFF") # not necessarily
use Encode;  print Encode::decode q{ISO885902}, "\x{119}";
use Encode;  print Encode::decode q{ISO8859-2}, "\x{119}";
use Encode; printf "%vd", encode_utf8("much \x{2665}")
 use Encode qw/decode/; [ decode( "UTF-8", "\x6\x0\x0\x0\x65\x0\x0\x0\x61\x6e\x69\x6d\x73\x2f\x74\x68\x72\x30\x30\x30\x30\x31\x2e\x74\x67\x61") ] # print obviously doesn't like \0
use Encode qw/decode/; print decode( "utf8", "\x06\x00\x00\x00\x65\x00\x00\x00\x61\x6e\x69\x6d\x73\x2f\x74\x68\x72\x30\x30\x30\x30\x31\x2e\x74\x67\x61" );
use Encode qw/decode/; print decode( "utf8", "\x6\x0\x0\x0\x65\x0\x0\x0\x61\x6e\x69\x6d\x73\x2f\x74\x68\x72\x30\x30\x30\x30\x31\x2e\x74\x67\x61" )
use Encode; say Encode::encode("UTF-8", Encode::decode("ISO-8859-1", "おジャ魔女どれみ"));
use Encode::Unicode; Encode::find_encoding( q{UTF-16} )->name
use English; [ $., $NR ]
use Env qw/ HOME /;[[ ((glob("$HOME/*.txt"))[0]) ]]
use Errno 'ENOENT'; ENOENT
use experimental 'autoderef'; [keys {foo => 1, bar => 2, baz => 0}]
use experimental 'lexical_subs'
use experimental 'lexical_subs'; use constant wibble => 42; my $outer = wibble; my $inner = do { my sub wibble () { 69 }; wibble }; [ $inner, $outer ]
use experimental "postderef";
use experimental 'postderef'; my $x; $x->$@ # lovely :S
use experimental qw(postderef); $arr = [[1..3],[4..6],[7..9]]; [ $arr->@[0, 2] ]
use experimental qw(postderef); $hash = {asdf => 'jkl;', zxvc => 'bnm,'}; [ $hash->@{'asdf','zxcv'} ]
use experimental qw( postderef ); my $foo = { bar => [ 1, 2, 3 ] }; [ $foo->{bar}->@* ]
use experimental qw( postderef ); my $foo = { bar => [ 1, 2, 3 ] }; [ $foo->{bar}->*@ ]
use experimental qw(postderef); sub foo { return [1, 2, 3] } if ((my $arr_ref = foo())->@*) { print @$arr_ref }
use experimental qw(signatures); sub foo ($bar, $baz) :proto($$) { .. }
use experimental qw(signatures); sub foo ($bar, $baz) :proto($$) { ... }
use experimental qw(signatures); sub thing($$) { }# but if something mangles the feature hints without knowing what it's doing...
use experimental qw(state); (state $x) = @_; # depends on whether compiling is considered useful?
use experimental 'signatures'; sub foo () { 5 } print foo, "bar";
use experimental 'signatures'; sub foo () { 5 } say foo, "bar";
use experimental 'signatures'; sub foo($bar) {print $bar, $bar}; foo("hola hoops ");
use experimental 'signatures'; sub foo($bar) {print $bar, $bar}; foo("hola hoops ", "error");
use experimental 'signatures'; sub foo (my $str) { $str.$str } print foo "baz", "bar";
use experimental 'signatures'; sub foo ($str) { $str .= "a" } my $s = "x"; foo($s); $s
use experimental 'signatures'; sub foo ($str) { $str.$str } print foo "baz", "bar";
use experimental 'signatures'; sub foo () { undef } print foo // 2; # this is where the parser got choked up, i think
use ExtUtils::ParseXS
use feature 'fc'; index(fc 'foo Ë', fc 'ë');
use feature fc; print fc("ł") cmp fc("z")
use feature keys %feature::feature; say hi::
use feature keys %feature::feature; say 'k'
use feature 'postderef'; []->$#*
use feature 'postderef'; [ ["A".."Z"]->%[3..7] ]
use feature 'postderef'; *foo{SCALAR}->$* = 2; my $bar; $$bar = 3; [ $bar->$****foo{SCALAR}->$* ]
use feature 'postderef'; *foo{SCALAR}->$* = 2; my $bar; $$bar = 3; say $bar->$****foo{SCALAR}->$*;
use feature 'postderef'; for my $i (1..100) {push @a, [(1,1) x 1024*512]}; [scalar(@a), scalar($a[0]->@*)]
use feature 'postderef'; for my $i (1..100) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]
use feature 'postderef'; for my $i (1..100) {push @a, [(1) x 1024*1024]}; [scalar(@a), scalar($a[0]->@*)]
use feature 'postderef'; for my $i (1..50) {push @a, [(1) x (1024*1024)]}; [scalar(@a), scalar($a[0]->@*)]
use feature 'postderef'; map print, [1,2,3]->@*  # or maybe a -, a >, an @ and an *
use feature 'postderef'; my $aref = \['x']; $aref->$*->[0] # or let perlbot help
use feature 'postderef'; my $data = {foo => [qw/hello freenode perl/]}; print for ($data->{foo}->@*); 
use feature 'postderef'; my $x = \42; $x->$*
use feature 'postderef'; no warnings 'experimental::postderef'; sub {42}->&*
use feature 'postderef'; $_->@{qw/a b/} = (1,2) for \my %hash
use feature 'postderef'; $_->@{qw/a b/} = (1,2) for \my %hash; \%hash
use feature 'postderef'; sub lol { say @_; } sub one { (\&lol)->() } sub two { (\&lol)->&* } one(qw(a b)); two(qw(c d));
use feature 'postderef'; use 5.020; my $l = sub { say @_; }; sub one { $l->() } sub two { $l->&* } one(qw(a b)); two(qw(c d));
use feature 'postderef'; use 5.020; sub lol { say @_; } sub one { (\&lol)->() } sub two { (\&lol)->&* } one(qw(a b)); two(qw(c d));
use feature 'postderef';  use List::MoreUtils 'mesh'; my $str = "this is line 1\nthis is line 2\nthis is line 3"; my @lines = map { [ split " ", $_ ] } split /\n/, $str; "@{[ mesh $lines[0]->@*, $lines[1]->@*, $lines[2]->@* ]}"
use feature 'postderef'; $x = [0]; push $x->@*, 1; $x
use feature 'postderef'; (\'you')->$*
use feature qw( current_sub ); sub foo { my ( $foo, $x ); $foo = sub { $x ? ++$x : ( $x = 1 ); __SUB__->() unless $x >= 5; }; $foo->(); return $x; } foo; ### So this doesn't leak memory?
use feature qw(doesntexist);
use feature qw(fc); fc 'ß'
use feature qw(fc); print for fc('ß'), '-', lc('ß');
use feature qw(fc unicode_strings); print fc("ł") cmp fc("z")
use feature qw(fc unicode_strings); use utf8; print fc("ł") cmp fc("z")
use feature qw(say fc); say fc(""); # the core function seems happy enough, so I'd put that down to a bug in the module
use feature qw(say); $_ = '...'; say() # not quite, but just because say/print are special
use feature qw(signatures); sub foo ($bar, $baz) :proto($$) { .. }
use feature qw(state); my $y = 0; sub isatty { state $x = do { print "state init "; ++$y }; $x } [ map  isatty(), 1..3 ] # only once
use feature qw(state); (state $x) = @_;
use feature qw( state ); sub Foo { state %state; my @p = ( [ shift, $state{n} ? q{Nested} : q{First} ] ); { local $state{n} = 1; push @p, Foo( @_ ) if @_ }; if ( $state{n} ) { @p; } else { %state = (); [ @p ]; } }    [  Foo( qw(A B C) ),  Foo( qw(X Y Z) )  ];
use feature 'refaliasing'; for \my %hash ({foo => 'bar'}, {foo => 'baz'}) { print $hash{foo} } #whee
use feature 'refaliasing'; my $x = { foo => 1 }; \my %y = $x; $y{bar} = 2; $x;
use feature 'say'; do { my $line = $_; chomp $line; say $line } for "asdf","asdf\n"
use feature 'say';  say "1 2 3 are", 1, 2, 3;
use feature 'say'; say for @INC
use feature 'say'; say "hi"
use feature 'say'; say 'lo'
use feature 'say'; say q hello worldh;
use feature 'say'; use Digest::MD5 'md5_hex'; say md5_hex("passwd")
use feature 'say'; use List::Util 1.33 'any';
use feature 'say'; use List::Util 1.33 'any'; @array = qw(1 2 3); say "match" if(any{ $_ eq '3'} @array);
use feature 'say'; use List::Util 1.33 'any'; @array = qw(1,2,3); say "match" if(any{ $_ eq '3'} @array);
use feature 'say'; use List::Util 1.33 'any'; @array = qw(1,2,3); say "match" if(any{ $_ eq '4'} @array);
use feature 'signatures'; sub add ($x = (return 0), $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]
use feature 'signatures'; sub add ($x = return 0, $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]
use feature 'state'; state $x = 4; $x
use feature 'switch'; given (0) { when ('0 but true') { print 'wat' } }
use feature 'switch'; given ("0") { when ('0 but true') { print 'wat' } default { print 'nope' } }
use File::Basename; [ fileparse("/foo/bar/baz.anyextensionyoulike", qr/\.[^.]*/) ]
use File::Basename; [ fileparse("/foo/bar/baz.csv", qr/\.[^.]*/) ]
use File::Basename; [ fileparse("foo/bar.baz", qr/[^.]*$/) ]
use File::Basename; [ fileparse("/foo/bar/baz.txt", qr/\.[^.]*/) ]
use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tAr.Bz2}, qr{\.(?:tar.*|zip)}i ];
use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tar.fooBarBaz}, q{tar.*}, q{zip} ];
use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tar.gz}, ( map qq{.$_}, map( qq{tar.$_}, qw(gz bz2 xz Z) ), q{zip} ) ];
use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tar.gz}, q{tar.*}, q{zip} ];
use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tAr.gz}, q{.tar.*}, q{.zip} ];
use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tar.gz.zip},  qr/\.(?:zip|tar\..*?)$/i ];
use File::Basename; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.ZIP}, qr{\.(?:tar.*|zip)}i ];
use File::Basename; fileparse_set_fstype q{MSWin32}; [ fileparse q{authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tAr.gz}, q{.tar.*}, q{.zip} ];
use File::Basename; [map +(fileparse $_, qr/(?<=\.)[^.]+/)[2], "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
use File::Basename; [map +(fileparse $_, qr/[^.]+/)[2], "foo.jpg", "foo\nbar.pdf","foo.png.", ".vimrc","x.js.pl","README"]
use File::HomeDir; print File::HomeDir->my_data;
use Function::Parameters;
use Function::Parameters; fun foo(A[[) {}
use Function::Parameters; fun foo(:$x) {}  substr B::Deparse->new()->coderef2text(\&foo), 1288
use Function::Parameters qw(:strict); B::Deparse->new->coderef2text(fun (:$x) {})
use Function::Parameters qw(:strict); fun add ($x = return 0, $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]
use Function::Parameters qw((:strict);; fun add ($x = return 0, $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]
use Function::Parameters qw(:strict); fun foo($bar) {print $bar, $bar}; foo("hola hoops ", "error");
use Function::Parameters qw(:strict); fun mynumbs :(@$;$) {}
use Function::Parameters qw(:strict); method new($class: :$name, :$value, :$path = '/', :$domain = undef, :$secure = undef, :$expires = undef, :$max_age = undef, :$httponly = undef) { [$name, $value] }  __PACKAGE__->new(name => "Some_cookie" -value => "Some_value")
use Function::Parameters qw(:strict); method new($class: :$name, :$value, :$path = '/', :$domain = undef, :$secure = undef, :$expires = undef, :$max_age = undef, :$httponly = undef) { [$name, $value] }  __PACKAGE__->new(name => "Some_cookie", Value => "Some_value")
use Function::Parameters qw(:strict); substr B::Deparse->new->coderef2text(fun (:$x) {}), 100
use Function::Parameters qw(:strict); substr B::Deparse->new->coderef2text(fun (:$x) {}), 1470
use Function::Parameters qw(:strict); substr B::Deparse->new->coderef2text(fun (:$x) {}), 200
use Function::Parameters qw(:strict); substr B::Deparse->new->coderef2text( fun ($x, $y) {} ), 1077
use Function::Parameters ':strict'; fun routine($one, $two, $three) {} routine("!");
use Function::Parameters 'strict'; strict foo($x) { $x * 2 } foo 21
use Function::Parameters; use warnings; fun lala :(_;) {}
use Hash::Util; $href = { "foo"=>"bar" }; Hash::Util::lock_ref_keys($href); map { print "\"$_\":$href->{$_}\n" } %{$href}
use Hindsight 20/20;
use HTML::Entities
use HTTP::Tiny; my $http = HTTP::Tiny->new; $http->verify_SSL(1)
use if 0 1 == 0, strict; $foo = $bar; 1
use if 0 1 == 1, strict;
use if 1.0 == 0, strict; $foo = $bar; 1
use if 1+0 == 0, strict; $foo = $bar; 1
use if (1 == 0), strict => ""; $foo = $bar; 1
use if 1 == 0, strict => ""; $foo = $bar; 1
use if 1 == 0, strict; $foo = $bar; 1
use if 1 == 1, strict; 
use if (1 == 1), strict; $foo = $bar; 1
use if 1e0 == 0, strict; $foo = $bar; 1
use if 9;
use Image::Magick; print Image::Magick->QuantumDepth
use integer; 1 / 2
use integer; 5/3
use integer; [ ~-5, -~5 ]
use IO::Handle; my $fh = IO::Handle->new; open $fh , q{>}, \(my $str); $fh->say( q{foo} ); [ ref $fh ];
use IO::Handle; my $io = IO::Handle->new; ilike $io
use IO::Handle; my $io = IO::Handle->new; length $io
use IO::Handle; open my $fh, '>', \my $buffer; ref $fh
use IO::Socket::INET; IO::Socket::INET->new()
use IO::Socket::INET;  my $sock = IO::Socket::INET->new(Timeout => 4, Proto => "tcp" , PeerAddr => "www.gamezstorm.com", PeerPort => 25) or die $!;  for(<$sock>){print $_ ,"\n";}
use IPC::Shm
use iso-8859-1; uc "ñ"
use iso8859-1; uc "ñ"
use iso8859; uc "ñ"
use JSON (); { abc => 123 }->JSON::encode_json
use JSON; encode_json( \%INC );
use JSON; from_json q~ { "a" : "b" } ~
use JSON; @list = ({name => 1}, {name => 2}, {name => 3}, {name => 4}); to_json([grep { $_->{name} > 2 } @list])
use JSON; @list = ({name => 1, x => one}, {name => 2, x => two}, {name => 3, x => three}, {name => 4, x => four}); to_json([map {$_->{x}} grep { $_->{name} > 2 } @list])
use JSON'MaybeXS;
use JSON::MaybeXS; [encode_json [''.1341015082000]]
use JSON::MaybeXS; [encode_json [1341015082000]]
use JSON::MaybeXS; [encode_json 1341015082000]
use JSON::MaybeXS; encode_json { foo => '1.20' }
use JSON::MaybeXS; encode_json { foo => '1.22' }
use JSON::MaybeXS; encode_json { foo => sprintf '%.2f', 1.22 }
use JSON::MaybeXS; JSON()
use JSON::MaybeXS; JSON::MaybeXS->new(allow_nonref => 1, ascii => 0)->encode("\07")
use JSON::MaybeXS; JSON::MaybeXS->new(allow_nonref => 1, ascii => 1)->encode("\x{2603}")
use JSON::MaybeXS; JSON::MaybeXS->new(allow_nonref => 1)->encode("\07")
use JSON::MaybeXS; my $j = JSON::MaybeXS->new(allow_nonref => 1, ascii => 1); [grep { $j->encode(chr($_)) =~ /\\u/ } 0..127]
use JSON::MaybeXS; my $json = JSON::MaybeXS->new(allow_nonref => 1, ascii => 1); my $encoded = $json->encode("\x{2603}"); [$encoded, $json->decode($encoded)]
use JSON::MaybeXS; my $json_str = JSON::MaybeXS->new(allow_nonref => 1, ascii => 1)->encode("\x{2603}"); [$json_str]
use JSON::MaybeXS; my %test = (name => JSON->true); JSON::MaybeXS->new(pretty => 1)->encode(\%test)
use JSON::MaybeXS; my $var = 1341015082000; [encode_json ["$var"]]
use JSON; my $aoh = [{1=>2},{3=>4}];my $str=encode_json($aoh); my $new_aoh = decode_json($str); push @{ $new_aoh  }, {5=>6}; my $new_str = encode_json($new_aoh); $new_str
use JSON; my $var = ~~"0"; encode_json([$var])
use JSON; use strict; my %test = ( name => \1, ); print JSON->new->pretty->encode(\%test);
use JSON::XS; decode_json('["\ud834\udd1e"]')
use less 'abomination';
use Lingua::EN::Numbers qw(num2en); sub isodd {return (num2en shift) =~ /e.?$/} 
use List::MoreUtils 'any'; if (any {$_ eq 'a'}, 'b', 'c') { 1 }
use List::MoreUtils 'firstidx'; sub merge_refs { my $input = shift; return $input unless @_; my @indices; for my $ref (@_) { push @indices, firstidx { $ref == \$_ } @$input }; my $merged = $input->[pop @indices]; unshift @$merged, @{splice @$input, $_, 1} for @indices; return $input } my $x = [ [1,2], [3,4], [5,6,7,8] ]; merge_refs $x, \$x->[0], \$x->[2];
use List::MoreUtils qw(firstidx); my $y = 3; my @list = (1,2,3,4,5,6,7); splice @list, $_, 0, 'above' for grep defined, firstidx { $_ > $y } @list; \@list
use List::MoreUtils qw(uniq); my %x = (x => {a => 1, c => 2}, z => { a => 3 }); my %y = (x => {b => 3}, z => {a => 4}); my %z = %x; for my $k (uniq keys(%x), keys(%y)) { $z{$k}{$_} = $y{$k}{$_} for grep !exists $x{$k}{$_}, keys %{$y{$k}} } \%z
use List::MoreUtils qw/uniq/; [ sort uniq qw/a b c a/ ];
use List::MoreUtils qw/uniq/; [ sort(uniq qw/a b c a/) ];
use List::MoreUtils qw/uniq/; [ sort(uniq(qw/a b c a/)) ];
use List::MoreUtils qw/uniq/; [ uniq qw/a b c a/ ];
use List::MoreUtils qw(zip); $ab = [ "a","b"]; $xyz = ["u","v","a","b","w"]; grep defined, @{ { zip @$xyz, @$xyz } }{@$ab} == @$ab
use List::MoreUtils qw(zip); my @list = qw( AAA BBB CCC ); [ &zip \@list, [('|') x @list - 1] ]
use List::MoreUtils qw(zip); my @list = qw( AAA BBB CCC ); [ zip @list, ('|') x @list - 1 ]
use List::MoreUtils qw(zip); my @list = qw( AAA BBB CCC ); [ &zip(\@list, [('|') x @list - 1]) ]  # hardly worth it
use List::Util 0.0 qw(9999);
use List::Util 0 qw(9999);
use List::Util 1.33 'any';@array = qw(1 2 3); print "match" if(any{ $_ eq '4'} @array);
use List::Util '9999';
use List::Util (9999);
use List::Util 'first';  first { goto HERE } 1, 2, 3; HERE: print "hello"
use List::Util; $List::Util::VERSION
use List::Util 'max';max 2,3;
use List::Util 'max';max 2,3;max(2,3);
use List::Util 'max';  max(4, 9)
use List::Util; my $c = [qw(a b c)]; print "1" if List::Util::any { $_ eq "a" } @{$c}
use List::Util 'product';  product 0, 1
use List::Util () qw(9999);
use List::Util qw(9999);
use List::Util qw(any 9999);
use List::Util qw(any); my @x = qw(a b c); my @y = qw(d e f); for my $_ (@x) { print "found" if any { /b/ } @y } # I know it's in Texas, probably in Tennnessee...
use List::Util qw/first/; --$i if first { $i++; /z/ } qw/foo bar baz/   # even more vomit inducing
use List::Util qw(first); my $y = 3; my @list = (1,2,3,4,5,6,7); $_ = 'above' for grep defined, first { $_ > $y } @list; \@list # ?
use List::Util qw(max); my $str = '( G1 Z0.252 F7200.000 )'; [ max 30, $str =~ /G1 Z(\d+\.\d+)/ ];
use List::Util qw(max); my $str = '( G1 Z0.252 F7200.000 )'; my ($value) = $str =~ /G1 Z(\d+\.\d+)/; max 30, $value
use List::Util qw(min); [ map "$_", \&min, \&List::Util::min ] # Exporter gives the same value for both
use List::Util qw( pairmap ); do { my %pairs; pairmap { push $pairs{$a}, $b; } ( "x", "1", "x", "2", "y", "baz" ); \%pairs; };
use List::Util qw( pairmap ); my %pairs; pairmap { push @{ $pairs{$a} }, $b; } ( "x", "1", "x", "2", "y", "baz" ); \%pairs
use List::Util qw(pairmap); [ pairmap { !($a * !$b) ? 'T' : 'F' } qw(1 1 1 0 0 1 0 0) ]
use List::Util qw(pairmap); [ pairmap { !$a || $b ? 'T' : 'F' } qw(1 1 1 0 0 1 0 0) ]
use List::Util qw(product); say product 1..10;
use List::Util qw(reduce); my @ar = qw /a list of errors/; [reduce {$a." ".$b} @ar]
use List::Util qw(reduce); my @output; reduce { push @output, ($a, $b); $b } qw(1 2 3 4 5); \@output
use List::Util qw(reduce); reduce {$1*$b} 1..10;
use List::Util qw(reduce); reduce {$a*$b} 1..10;
use List::Util qw(sum0); [ map sum0(@$_), grep $_->[0] ** 2 == $_->[1] ** 2 + $_->[2] ** 2, map { my ($x, $y) = @$_; map [ $x, $y, $_ ], 1..$y } map { my $x = $_; map [ $x, $_ ], 1..$x } 1..10 ] # probably wrong, but you can see why the map approach isn't great here
use List::Util qw(sum); chr sum map ord, qw(A B C);
use List::Util qw/sum/; [ sum '92.168.1.1' =~ /(\d+)/g ]
use List::Util qw(sum); sum map ord, qw(A B C);
use List::Util 'reduce';  reduce { die "BOK" } 1
use List::Util 'reduce';  reduce { die "BOK" } 1, 2
use List::Util 'reduce';  reduce { die "BOK" } 1. 2
use List::UtilsBy;
use List::UtilsBy 'bundle_by'; my @array = split '', 'abcdefghijklmnopqrstuvwxyz'; [bundle_by { [@_] } 9, @array]
use List::UtilsBy qw(partition_by); +{ partition_by { $_ % 3 } 1..12 } # perlbot has all the things
use List::UtilsBy qw(sort_by); [ sort_by { $_->{name} } { name => 'x' }, { name => 'y' }, { name => 'z' } ]
use List::UtilsBy qw(zip_by); @a=map{$_%10}zip_by{$_[0]+$_[1]}[9,5,3],[map{9-$_}1,7,6];++@a[-1]; [@a]
use List::UtilsBy 'sort_by'; @topics = qw/alias:topic alias:topic2 topic/; %t =map { s/^alias://r => $_ } sort_by { ! /^alias:/ } @topics; [ values %t ]
use List::UtilsBy 'sort_by'; @topics = qw/alias:topic topic2 topic/; %t =map { (/^alias:/ ? $_ : "alias:$_") => $_ } sort_by { ! /^alias:/ } @topics; \%t
use List::UtilsBy 'sort_by'; @topics = qw/alias:topic topic2 topic/; %t =map { s/^alias://r => $_ } sort_by { ! /^alias:/ } @topics; [ values %t ]
use List::UtilsBy 'sort_by'; @topics = qw/topic topic2 alias:topic/; %t =map { (/^alias:/ ? $_ : "alias:$_") => $_ } sort_by { ! /^alias:/ } @topics; \%t
use List::UtilsBy 'sort_by'; @topics = qw/topic topic2 alias:topic/; %t =map { (/^alias:/ ? $_ : "alias:$_") => $_ } sort_by { /^alias:/ } @topics; \%t
use List::UtilsBy 'zip_by'; my $u = 'ABC'; my $l = 'abc'; join '', zip_by { @_ } map { [split //] } $u, $l
use List::UtilsBy 'zip_by'; my $u = 'ABC'; my $l = 'abc'; join '', zip_by { @_ } [split //, $u], [split //, $l]
use List::Util 'sum'; sum map { 1 / $_ } ( 1,3,5,7,9,11,13,15,17 )
use List::Util 'sum'; sum map { 1 / $_ } ( 1,3,5,7,9,13,15,17,19 )
use List::Util; use strict; use warnings; my $y = max $a, $b; # perl5.20 gives me "Useless use of a variable in void context" there, not sure why this one doesn't
use LWP::UserAgent; my $ua = LWP::UserAgent->new; length $ua
use manager::dedicated::dedicated.fr;
use Math::BigInt
use Math::BigInt; [157 + "9.95" + Math::BigInt->new(13) + 0]
use Math::BigInt; 1e1000
use Math::BigInt; 2790**2753 % 3233
use Math::BigInt; atan2(0, -1);
use Math::BigInt; Math::BigInt->new("3432902008176640045")
use Math::BigInt; my $x = Math::BigInt->new(2000); [ $x->as_hex ]
use Math::BigInt; $x=Math::BigInt->new(4); print $x->bfac();
use Math::BigInt; $x=Math::BigInt->new(4); $y=Math::BigInt->new(2); print $x->bfac(); print $y->bfac();
use Math::Complex; sqrt -1
use Math::Round; round(3.2939232942 * 100) / 100
use Math; sqrt -1;
use MIME::Base64;
use Missing::Thing;
use Module::Build
use Module::Corelist; [ Module::Corelist->first_release( 'experimental' ) ]
use Module::CoreList; [ Module::CoreList->first_release( 'experimental' ) ]
use Mojo::DOM;
use Mojo::DOM; my $dom = Mojo::DOM->new('<html><head></head><body></body></html>'); $dom->at('head')->append_content('<meta content="text/html; charset=utf-8" http-equiv="Content-Type"></meta>'); $dom->to_string
use Mojo::DOM; my $dom = Mojo::DOM->new('<html><head></head><body></body></html>'); $dom->at('head')->append('<meta content="text/html; charset=utf-8" http-equiv="Content-Type"></meta>'); $dom
use Mojo::DOM; my $dom = Mojo::DOM->new('<html><head></head><body></body></html>'); $dom->at('head')->append('<meta content="text/html; charset=utf-8" http-equiv="Content-Type"></meta>'); $dom->to_string
use Mojo::DOM; use Mojo::DOM::CSS; use Mojo::Collection;
use Mojo::JSON; my $var = 1341015082000; [encode_json ["$var"]]
use Mojo::Util 'punycode_decode'; encode 'UTF-8', punycode_decode 'wkr'
use Mojo::Util 'punycode_decode'; encode 'UTF-8', punycode_decode zkr
use Mojo::Util 'punycode_encode', 'decode'; punycode_encode decode('UTF-8', '❄')
use Mojo::Util 'punycode_encode'; punycode_encode decode('UTF-8', '❄')
use Moo;
use Moose ()
use Moose;
use Moose; 7;
use Net::HTTP::Spore;
use Number::Format qw(:subs :vars); $THOUSANDS_SEP = '.'; my $a = 123456789; say format_number($a);
use open IN  => ":crlf", OUT => ":bytes"; [ ${^OPEN} ]
use or die perl;
use overload q|""| => sub { 42 }; my @a; $a[42] = 'forty two'; [ $a[bless {}, 'main'] ]
use overload qw,"",=> sub { die }; bless {}, bless []; 42;
use overload '""' => sub { "" }, "bool" => sub { 1 }; my $foo = bless []; if( $foo ) { print "_${foo}" } else { print "aww" }
use overload '@{}' => sub { print 'converting to array'; ['42'] }; my $foo; bless \$foo; (\$foo)->[0];
use overload '@{}' => sub { print 'converting to array'; ['42'] }; my $foo; bless \$foo; primt (\$foo)->[0];
use overload '@{}' => sub { print 'converting to array'; ['42'] }; my $foo; bless \$foo; print + (\$foo)->[0];
use overload '+' => sub { print "foo" }; my $x = bless []; $x + 2;
use overload '@{}' => sub { say 'converting to array'; ['42'] }; my $foo; bless \$foo; (\$foo)->[0];
use overload '""' => sub { shift @{ shift() } || '' }; $, = bless [' another ', ' hacker']; print qw(Just Perl ,);
use overload '""' => sub { "wibble" }; $x = []; bless $x; $y = []; bless $y, $x; ref $y
use Perl;
use POSIX; floor((3.2949232942 + 0.005) * 100)/100
use POSIX; floor((3.2959232942 + 0.005) * 100)/100
use POSIX 'mktime'; print localtime mktime(0,0,0, 128, 0, 2015-1900)
use POSIX 'mktime'; print scalar localtime mktime(0,0,0, 128, 0, 2015-1900)
use POSIX 'mktime'; scalar CORE::localtime mktime( 0,0,0, 1234, -123, 81 )
use POSIX 'mktime'; scalar localtime mktime( 0,0,0, 1234, -123, 81 )
use POSIX 'mktime'; scalar localtime mktime(0,0,0, 128, 0, 2015-1900)
use POSIX 'mktime'; unde" (13 lines) at http://scsys.co.uk:8002/408020
use POSIX; print strftime('%z', localtime());
use POSIX qw(atan); 4*atan(1) # if you disapprove of passing multiple parameters to a function, there are alternatives
use POSIX qw(floor); floor(5/3)
use POSIX qw/locale_h/; say setlocale(LC_TIME, "ja_JP.utf-8");
use POSIX qw/locale_h strftime/; setlocale(LC_TIME, "ja_JP.utf-8"); strftime("%b %d", localtime())
use POSIX qw/locale_h strftime/; setlocale(LC_TIME, "ja_JP.utf-8"); strftime("%c", localtime())
use POSIX qw(mktime); @x = localtime; $x[3] -= 69; "" . scalar localtime mktime @x
use POSIX qw(mktime); @x = localtime; $x[7] -= 69; mktime @x
use POSIX qw( modf ); my $n = 1.2345; sprintf q{%02d%s}, reverse map { s/^0+//r } modf $n; ### leobut
use POSIX qw( modf ); my $n = 1; sprintf q{%02d%s}, reverse map { s/^0+//r } modf $n; ### leobut
use POSIX qw(strftime); [map strftime('%H:%M', gmtime $_), map 15*60*$_, 1 .. 10]
use POSIX qw(strftime mktime); my @time = gmtime; $time[3] -= $time[6]; strftime '%Y-%m-%d', @time; # give me a sunday
use POSIX qw(strftime); my $midnight_today = mktime 0,0,0,(localtime)[3..8]; my $time_offset = ((18 * 60) + 38)*60; strftime '%Y-%m-%d %H:%M:%S', gmtime $midnight_today + $time_offset
use POSIX qw(strftime); strftime '%H:%M:%S', gmtime(260)
use POSIX qw(strftime); strftime '%H:%M:%S', gmtime 97462
use POSIX qw(strftime); strftime "%Y%m%d%H.%M", localtime(time - 3600)
use POSIX qw(strftime); strftime '%Y.%m.%d.%H.%M.%S', localtime
use POSIX qw(strftime); strftime "%Y-%m-%d", localtime
use POSIX qw/strftime/; strftime "%Y-%m-%d", localtime 0;
use POSIX qw(strftime); strftime "%Y-%m-%d", localtime time - 3600
use POSIX qw(sysconf); [ sysconf(_SC_PAGE_SIZE) ]
use POSIX; setlocale(LC_NUMERIC, "de_DE"); sprintf("%.2f", 23.45)
use POSIX 'strftime'; [strftime '+%d-%m-%Y']
use POSIX 'strftime'; [strftime '%d-%m-%Y', localtime]
use POSIX 'strftime'; [strftime '+%d-%m-%Y', localtime]
use POSIX::strptime=strptime; strptime 'dec', '%b';
use POSIX::strptime 'strptime'; strptime 'dec', '%b';
use Psychic::Hotline;
use Quote::Code
use Quote::Code; qc{!}
use Quote::Code; [ qcw< a {$_} b > ]
[ 'user:anything-else:' !~ /^user:!!:$/ ]
use re 'debug'; /^+/
use re 'debug'; /a(bc)+/o;
use Regexp::Assemble;
use Regexp::Common; ("12 bananas buys you 0.1231e10 ruby" =~ /$RE{num}{real}/g)[1]
use Regexp::Common; print "ok" if ("foo bar)" eq "(foo bar))" =~ s/($RE{balanced}{-parens => "()"})/$1/r);
use Regexp::Common qw/net/; my $ip = q(100.10.1.101); [$ip =~ /$RE{net}{IPv4}/]
use Regexp::Common qw/net/; my $ip = q(100.10.1.101); [$ip =~ /\[$RE{net}{IPv4}\]/]
use Regexp::Common qw/net/; my $ip = q(100.10.1.101); [$ip =~ /($RE{net}{IPv4})/] # I meant that
use Regexp::Common qw( net ); $_ = q(00:11:22:33:44:55); if (/$RE{net}{MAC}{-keep}/) { print "<b>$3:$4</b>"; }
use Return::MultiLevel;
[ 'user:!!:' !~ /^user:!!:$/ ]
'user' =~ /user(?!-agent)/
use Scalar::Util
use Scalar::Util 'blessed'; my $re = qr/hai/; [blessed $re]
use Scalar::Util 'looks_like_number'; looks_like_number '10%s'
use Scalar::Util 'looks_like_number'; looks_like_number('123abc   ')
use Scalar::Util 'looks_like_number'; looks_like_number('     9') ? 1 : 0
use Scalar::Util 'looks_like_number'; my $s = qq{ 123 4.5 0xFF 5E7 }; [ grep looks_like_number $_, split /\s+/, $s ];
use Scalar::Util 'looks_like_number'; my $s = qq{ 123 4.5 0xFF 5E7 }; [ map 0+$_, grep looks_like_number $_, split /\s+/, $s ];
use Scalar::Util qw(dualvar); my $foo = dualvar 42, ""; if ($foo) { print "_${foo}_"; } else { print "aww"; }
use Scalar::Util qw/dualvar/; my $i = dualvar 1, 'forty two'; my @a = qw/one two/; [ $a[ $i ], $a[ "$i" ] ]; # fun :)
use Scalar::Util qw(dualvar); my $x = dualvar 12, 'twelve'; my $y = $x; [ 0+$y, "$y" ] # so something like this
use Scalar::Util qw/dualvar/; my $x = dualvar 42, 'forty two'; [$x+0, "$x"]
use Scalar::Util qw/dualvar/; my $x = dualvar 42, 'forty two'; [$x+0, "$x"]>
use Scalar::Util qw/dualvar/; $x = dualvar 42, 'foo'; [ $x.'', $x+0 ]
use Scalar::Util qw(looks_like_number); looks_like_number '4'
use Scalar::Util qw(looks_like_number); looks_like_number 'infinity' ? '\o/' : '/o\\'
use Scalar::Util qw(looks_like_number); looks_like_number 'Inf'  # wat
use Scalar::Util qw(looks_like_number); looks_like_number 'nan'
use Scalar::Util qw(looks_like_number); looks_like_number 'NAN'
use Scalar::Util qw(looks_like_number); looks_like_number 'nandos';
use Scalar::Util qw/looks_like_number/; [ looks_like_number 'sNan' ]
use Scalar::Util qw(looks_like_number); +{ map { $_ => looks_like_number $_ ? q{Yes} : q{No} } 0, 123.456, 10.6E4, q{abc}, q{FF}, q{0xFF}, 0xFF, +23, "-32" }; ### Seems to fill my needs. I'm wondering if there are any gotchas.
use Scalar::Util qw(refaddr); my $meow = []; [refaddr($meow), refaddr(\@{$meow})]
use Scalar::Util qw( refaddr); sub foo { } my $foo = \&foo; my $bar = \&bar; [ refaddr $foo eq refaddr $bar ]
use Scalar::Util qw/reftype blessed/; my $obj = bless {}, 'ARRAY'; my $obj2 = bless {}, 'Foo'; { obj => [ ref($obj), reftype($obj), blessed($obj) ], obj2 => [ref($obj2), reftype($obj2), blessed($obj2)], ref => [ ref([]), reftype([]), blessed([]) ]
use Scalar::Util qw/reftype blessed/; my $obj = bless {}, 'ARRAY'; my $obj2 = bless {}, 'Foo'; { obj => [ ref($obj), reftype($obj), blessed($obj) ], obj2 => [ref($obj2), reftype($obj2), blessed($obj2)], ref => [ ref([]), reftype([]), blessed([]) ] }
use Scalar::Util qw(reftype); my $x = bless [7,8,9], q{FOO}; [ qq{$x}, ref $x, reftype $x ]; # Cool :)
use Scalar::Util qw,reftype,; [ reftype *STDOUT{IO} ]
use Scalar::Util qw(weaken); my $v; $v = sub { my $x = $v; 1 }; $v->(); weaken $v; die if $v # dropping the extra var and moving weaken() after the call looks okay to me
use Scalar::Util 'refaddr'; my $foo = []; my $addr = sprintf '%x', refaddr $foo; my %bar = ($foo => 1, "ARRAY(0x$addr)" => 1); \%bar
use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $h2={foo=>43}; %$h=%$h2; [ refaddr($h), refaddr($h2), $h ]
use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $h2={foo=>43}; %$h=%h2; [ refaddr($h), refaddr($h2), $h ]
use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $hadd1 = refaddr $h; my $h2={foo=>43}; mh $h2add1 = refaddr $h2; %$h=%h2; [ $hadd1, $h2add1, refaddr($h), refaddr($h2), $h ]
use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $hadd1 = refaddr $h; my $h2={foo=>43}; my $h2add1 = refaddr $h2; %$h=%$h2; [ $hadd1, $h2add1, refaddr($h), refaddr($h2), $h ]
use Scalar::Util 'refaddr'; my $h = { foo => 42 }; my $hadd1 = refaddr $h; my $h2={foo=>43}; my $h2add1 = refaddr $h2; %$h=%h2; [ $hadd1, $h2add1, refaddr($h), refaddr($h2), $h ]
use Scalar::Util 'refaddr'; my $h = { foo => 42 }; [ refaddr($h), refaddr(\%{$h}) ]
use Scalar::Util 'reftype'; eval: $x = 'three'; $y = \$x; [ reftype $x, reftype $y ] #as contrast
use Scalar::Util 'reftype'; eval: $x = 'three'; $y = \$x; $x = \$x; [ reftype $x, reftype $y ]
use Scalar::Util 'reftype'; my $r = bless [], "HASH";  reftype $r
use Scalar::Util 'reftype'; [ ref undef, reftype undef ]
use Scalar::Util 'weaken'; my $foo = {}; my $bar = {}; my $closure; { my ($foo2, $bar2) = ($foo, $bar); $closure = sub { $foo2 }; } weaken $foo; weaken $bar; [$foo, $bar]
use signatures; sub foo () { 5 } say foo, "bar";
use Socket 'inet_aton'; [unpack 'N', inet_aton '92.168.1.1']
use Socket 'pack_sockaddr_in6'; length pack_sockaddr_in6( 80, "\0" x 16 )
use Socket::pack_sockaddr_in6; length pack_sockaddr_in6( 80, "\0" x 16 )
use Socket qw(inet_pton AF_INET6); my $ip_addr = inet_pton(AF_INET6, "::ffff:127.0.0.1"); $ip_addr
use Socket;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in(8989,inet_aton("107.191.117.124")))){print S hi};
use Storable qw,dclone,; my @arr = ([], []); my $copyref = dclone(\@arr); $copyref->[0][0] = 3; \@arr
use Storable qw(nfreeze thaw); my $x = 42; print thaw(nfreeze(\$x)); # easier to see the issue if you just leave out the pack/unpack, though
use Storable; use strict; use warnings; my $x = { A => 123, B => q/foo/, C => [ qw(x y z) ] }; my $y = Storable::dclone $x; [ $x, $y ];
use Storable; use strict; use warnings; my $x = { A => 123, B => qr/foo/, C => [ qw(x y z) ] }; my $y = Storable::dclone $x; [ $x, $y ];
use Storable; use strict; use warnings; my $x = { A => 123, B => qr/foo/, C => [ qw(x y z) ] }; my $y = Storable::dclone $x; [ $x, $y ]; ### Why is it so hard to clone Regexp objects?
use strict;
use strict; [ $$$ ]
use strict; [ %~, @/, $= ]
use strict; 0->[0];
use strict; &{0 == &{0 == 0}} * 0
${use strict; 1;};
use strict; ${;1}
use strict; ${1}
use strict; ${1 + 1}
use strict; 1234->{key}
use strict; "${ 12+45 }"
use strict; ${2}
use strict; 404->();
use strict; *4 = sub { 'ok' }; &{4};
use strict; *4 = sub { 'ok' }; main->${ \4 };
use strict; @5 = "hi";
use strict; @5 = "hi"; \@5
use strict; @a
use strict; $a->[0];
use strict; a->[0]
use strict; $a = "it works"; print "${chr 97}"
use strict; *{$::{Altreus}}{SCALAR}
use strict; $ARGV
use strict; "asd" ~~ s/^[:ascii:]]//g;
use strict; "asd" ~~ s/^[:ascii:]]/g;
use strict; @b = 42;
use strict; BEGIN { package Zomg; *::foo = \$::foo; }  $foo = 42;
use strict; blargh
use strict; blargh()
use strict; config
use strict; defined (my $thing = $_[0]) or $thing = 'default'; $thing;
use strict; @F = 42;
use strict \&{"foo"}
use strict; $foo
use strict; \&{"foo"}
use strict; [ Foo ]
use strict; $foo = 'bar'; ++$$foo; $bar
use strict; grep my $x = 1, 1, 2, 3; $x
use strict; {{@{["I get it now"=>2, bar=>3]}}}->{"I get it now"}
use strict; {{@{["I get it now"=>2, bar=>3]}}}{"I get it now"}
use strict; ${{@{["I get it now"=>2, bar=>3]}}}{"I get it now"}
use strict; +{ @{["I get it now"=>2, bar=>3]} }->{"I get it now"}
use strict; ${ { @{["I get it now"=>'So this takes an arrayref, converts it to a array, then converts it to a hashref which is needed index the key because a hashref puts it into a hash context.  %{@a} does not work because % expects a "scalar" like a hashref or an arrayref (same with @), so you have to %{ {@a} }.', bar=>3]} } }{"I get it now"}
use strict; $INC
use strict; keys (%{ 'dave' => 1, 'bob' => 2 });
use strict; [ map { my $foo if 0; ++$foo } 1 .. 10 ]
use strict; my $a = {a=>"BLA", b=>"BLO"}; print "$k2:$v2\n" while((my($k2,$v2) = each %$a);
use strict; my $action = "foo"; &{$action}()
use strict; my $action = "foo"; &{\&{$action}}()
use strict; my $bar; (my $foo, $bar) = 1 .. 2;
use strict; my $cat, $dog;
use strict; my $diff=todayDay-serviceEndDay;
use strict; (my $foo, $bar) = ''
use strict; my $foo = 'bar' and $foo
use strict; my %foo; %{ 'foo' }
use strict; my %foo; %{ foo }
use strict; my %foo; %{ foo; }
use strict; my $foo; $foo = sub { return $foo };
use strict; (my $foo, my $bar) = 1 .. 2;
use strict; my $foo = sub { 'hi there!' }; $foo->()
use strict; my $foo = sub { return $foo };
use strict; my %hash = (one => 'foo'); sub bar { my $href = @_; $href->{one} = 'baz'; } bar(\%hash);  [ %hash ]
use strict; @{\my %hash}{qw(a b)} = (1, 2); \%hash
use strict; my %hash = (thing => SOME_CONSTANT); sub SOME_CONSTANT { 5 }; $hash{thing}
use strict; my $h; [ (delete $h->{foo}), $h ]
use strict; my $h; [ delete $h->{foo}, %$h ]
use strict; my $h; [ $h and %$h ]
use strict; my $h; [ scalar %$h ]
use strict; { my $i = 0; } $i
use strict; my $new = "foo"; print $nwe;
use strict; my $params; my $student; my $search_name = $params->{name} && $student->name =~ /\Q$search_name/i
use strict; my %test = ( name => true, );
use strict; my $x = 'code'; $$x;
use strict; my %x = (-+CONSTANT => 123); [keys %x]
use strict; my %x = (-CONSTANT => 123); [keys %x]
use strict; my %x = (+CONSTANT => 123); [keys %x]
use strict; my %x = (+CONSTANT => 123); keys %x
use strict; my %x = (+CONSTANT => 123); %x
use strict; my $x if $x || 1;
use strict; my $x = 'nope'; use warnings my $x = 'all'; $x
use strict; my @x =  qw(1 2); undef @x; push @x,1;
use strict; my %x; $x[1] = 123;
use strict; my $x->{y} = $x;
use strict; my ($x, $y) = ($y, $x);
use strict; package foo; sub bar { our $baz; package fizzbuz; "[". ++$baz . "]" }; [ bar(), bar()  ]
use strict; package foo; sub bar { our $baz; package fizzbuz; "[". ++$baz . "]" }; [ bar(), bar(), $baz ]
use strict; package foo; sub bar { our $baz; package fizzbuz; "[". ++$baz . "]" }; [ bar(), bar(), $foo::baz ]
use strict; package Foo; use B '@optype'; package Bar; [ @optype ]
use strict; package Foo; use B '@optype'; package Foo; [ @optype ]
use strict; print "${chr(24)}"
use strict; print foo::
use strict; print foo::, bar:: ;
use strict; print(foo::,"\n");
use strict; print 'hi' if my $x = 1;
use strict; print STDOUT:: foo:: ;
use 'strict'; print $x;
use strict qw(subs): use warnings;
use strict; @% = qw(x y z); [ \@%, "@%" ] # doesn't even seem to interpolate in a string
use strict "refs"; %{""}
use strict; require foo.pl;
use strict; "string"->{key}
use strict; ${\"string"}->{key}  # why is this different
use strict; sub AUTOLOAD { our $AUTOLOAD; print "[$AUTOLOAD]" }; foo();
use strict; sub AUTOLOAD { our $AUTOLOAD; print "[$AUTOLOAD]" }; my $obj = bless []; $obj->foo();
use strict; sub AUTOLOAD { print "[$AUTOLOAD]" }; foo();
use strict; sub AUTOLOAD { print "[$main::AUTOLOAD]" }; foo();
use strict; sub config { return "meow" } config
use strict; sub Foo { "Bar" }; [ Foo ]
use strict; sub foo { 'foohoo' } my $str = 'foo'; __PACKAGE__->can($str)->()
use strict; sub foo { quux(); } # Grinnz_ I think he means that all his subs don't actually get called..
use strict; sub foo { return false; }
use strict; sub lala { 'hej' } my $name = 'lala'; my $ref = \&$name; $ref->()
use strict; subname();
use strict; subname(); { no strict 'refs'; *{__PACKAGE__ . "::subname"} = sub {1} }
use strict; sub SOME_CONSTANT; my %hash = (thing => SOME_CONSTANT); sub SOME_CONSTANT { 5 }; $hash{thing}
use strict; sub what { my ($foo, @_) = @_; \@_ } what(qw(a b c d));
use strict; try {} catch {};
use strict; $_ = undef; say @$_[1]; [ $_ ]
use strict; $_ = undef; say @$_[1]; say Data::Dumper::Dumper [ $_ ]
use strict; use B '@optype'; [ @optype ]
use strict; use feature 'signatures'; sub add ($x = return 0, $y = return $x) { return $x + $y } [ add(), add(2), add(2,3) ]
use strict; use Function::Parameters qw(:strict); fun func($foo, $bar = sub { $foo }) { $bar } func(42)->()
use strict; use v5.20; say "hi" for Altreus =>
use strict; use v5.20; say "hi" for Altreus;
use strict; use warnings; ["$ -"]
use strict; use warnings; $! = 0; close "yolo" . rand; "$!"
use strict; use warnings; $! = 0; readline "yolo" . rand; "$!"
use strict; use warnings; 1234->{key}
use strict; use warnings; [ @$_[3] ]
use strict; use warnings; [ @{$_[3]} ] # you sure about that
use strict; use warnings; ['' * 5]
use strict; use warnings; $_ = "abc123xyz"; /\d{,3}/ ? ">$&<" : "no"
use strict; use warnings; @a = {foo => 1, bar => 2}; print ${$a}{"foo"}
use strict; use warnings; blasdsdasdsa->import
use strict; use warnings; close "yolo" . rand
use strict; use warnings; CORE::say "test" # use 5.016 mostly just covers imports, I think
use strict; use warnings; @F=('5'); [@F]
use strict; use warnings; $_ = "First Name Position first.name\@somewhere.com 745 45363\nSome One Worker some.one\@somewhere.com 343 5454\n" =~ s/^\s*(\S)\S*\s+(\S+).+?(\d\d\d \d\d\d\d)\s*/$1., $2, $3/gmr # for milfjord :)
use strict; use warnings; $_ = "First Name Position first.name\@somewhere.com 745 45363\nSome One Worker some.one\@somewhere.com 343 5454\n" =~ s/^\s*(\S)\S*\s+(\S+).+?(\d\d\d \d+)\s*/$1., $2, $3/gmr # for milfjord :)
use strict; use warnings; [ "First Name Position first.name\@somewhere.com 745 45363\nSome One Worker some.one\@somewhere.com 343 5454\n" =~ s/^\s*(\S)\S*\s+(\S+).+?(\d\d\d \d+)\s*/$1., $2, $3\n/gmr ]
use strict; use warnings; [-foo]
use strict; use warnings; [foo=>]
use strict; use warnings; @foo = (1, 2, undef, 4); for my $foo (@foo) { print $foo }
use strict; use warnings; foo; sub foo { "foo" }
use strict; use warnings; foo(); sub foo { "foo" }
use strict; use warnings; [ 'hentai' =~ m/#(?:hentai|yuri)/ ] # that line looks fine
use strict; use warnings; if (0) {i_am_not_defined();} else {print "Perfectly OK\n";}
use strict; use warnings; if (1) {} elseif (2) {}
use strict; use warnings; 'inf' * 3
use strict; use warnings; inf * 3
use strict; use warnings; keys %{'main::'};
use strict; use warnings; keys %{main::};
use strict; use warnings; keys %main::
use strict; use warnings;  length $12345678987654321
use strict; use warnings; local $_ = "UCS-4"; eval q@qr/^UCS-?4-?(BE|LE)?$/i; uc("UTF-32$1")@
use strict; use warnings; local $_ = "UCS-4"; my $p = qr/^UCS-?4-?(BE|LE|)?$/i; s@$p@uc("UTF-32$1")@er
use strict; use warnings; { local $x = 123; } # nor on undeclared variables
use strict; use warnings; [map { $_; last } (1,2,3)]
use strict; use warnings; map {print $_} [1,2,3]
use strict; use warnings; ''.methods.length
use strict; use warnings; my @a = 'a'..'z'; [ $a[ 2..1 ] ];
use strict; use warnings; my $abc = 'xyz'; my $asdf = 'mno'; sub asdf { return \$abc; } print "${asdf}"
use strict; use warnings; my $abc = 'xyz'; sub asdf { return \$abc; } print "${asdf}"
use strict; use warnings; my $abc = 'xyz'; sub asdf { return \$abc; } print ${asdf()}
use strict; use warnings; my $abc = 'xyz'; sub asdf { return \$abc; } print ${asdf}
use strict; use warnings; my  @a = ({foo=> "foo", moo => "bar", desc=> "lambda",},{foo=>"baz", moo=>"moo", desc=>"bring_it",}); my @keys = ('foo', 'desc'); [join(", ", map { my $href = $_; map { my $key = $_; "$key=\"$href->{$key}\"" } @keys } @a)]
use strict; use warnings; my  @a = ({foo=> "foo", moo => "bar", desc=> "lambda",},{foo=>"baz", moo=>"moo", desc="bring_it",}); my @keys = ('foo', 'desc'); [join(", ", map { my $href = $_; map { my $key = $_; "$key=\"$href->{$key}\"" } @keys } @a)]
use strict; use warnings; my  @a = ({foo=> "foo", moo => "bar"},{foo=>"baz", moo=>"moo"}); my $key = 'foo'; [join(", ", map { "$key=\"$_->{$key}\"" } @a)]
use strict; use warnings; my @allowed = ('a'..'z','A'..'Z',' ', '{','}');my%allowed_hash = (map { $_ => 1 } @allowed); my %found; foreach my $c (split// , q#MPOPCNTSF: INTEGER[9]#) { if (!exists($allowed_hash{$c})) { $found{$c} = 1; } } [sort {$a cmp $b } keys%found]
use strict; use warnings; my @allowed = ('a'..'z','A'..'Z',' ', '{','}');my%allowed_hash = (map { $_ => 1 } @allowed}; my %found; foreach my $c (split// , q#MPOPCNTSF: INTEGER[9]#) { if (!exists($allowed_hash{$c})) { $found{$c} = 1; } } [sort {$a cmp $b } keys%found]
use strict; use warnings;  my $aref = [1,2,3];  @{ $aref + 1 }
use strict; use warnings; my %args = ( number => 100 ); print $args{number};
use strict; use warnings; my %args = { number => 100 }; print $args{number};
use strict; use warnings; my $ar = [qw(x y z a b c)]; $ar->[2..4] # warnings to the rescue?
use strict; use warnings; my $array = (1,2,3);
use strict; use warnings; my $array_ref = [3,4,5]; ["$array_ref"]
use strict; use warnings; my $array_ref = [3,4,5]; [scalar @$array_ref]
use strict; use warnings; my @arr = ('One', 'Two', 'Three', 'Four'); @arr = grep { !/\AT/ } @arr; [@arr]
use strict; use warnings; my $cat, $dog;
use strict; use warnings; my @c=qw(a b c d);print((map{$_ >1}@c)/@c)
use strict; use warnings; my $cwd = "/archivepath/SHORT"; my $ARCHIVEPATH="/archivepath/"; [$cwd =~ m#^${ARCHIVEPATH}(SHORT|MEDIUM|LONG)$# ? "Match" : "No match"]
use strict; use warnings; my $cwd = "/archivepath/SHORT"; my $ARCHIVEPATH="/archivepath/"; [$cwd =~ m#^${ARCHIVEPATH}(SHORT|MEDIUM|LONG)\$# ? "Match" : "No match"]
use strict; use warnings; my %d = ( A => sub{'a'}, B => 5, C => sub{'c'}, D => [], E => sub{'e'} ); while ( my ($name, $code) = each %d ) { delete $d{$name} unless ref $code eq 'CODE'; } \%d;
use strict; use warnings; my @data = ("foo"); $data[0]{label} = $data[0]; [@data]
use strict; use warnings; my @data = ("foo"); $data[0] = {label => $data[0]}; [$data[0]{label}]
use strict; use warnings; my $data = [{}, { url => 'xyz' }]; $data->["1\n"]{url} # shouldn't matter
use strict; use warnings; my @default = qw(d e f a u l t); my $h = { y => [ qw(A B C) ] }; [ map Data::Munge::list2re(@{ $h->{$_} // \@default }), qw(x y) ]
use strict; use warnings; my @default = qw(d e f a u l t); my $h = { y => [ qw(A B C) ] }; [ map {   join q{|}, map { qq{\Q$_\E} } ( ref $h->{$_} eq q{ARRAY} && @{ $h->{$_} } ? @{ $h->{$_} } : @default )   } qw(x y) ];
use strict; use warnings; my $foo = 1; my $bar = 2; my $name = "foo"; print "ok" if (defined(${$name}));
use strict; use warnings; my %foo = (bar => 1); print %{foo};
use strict; use warnings; my $foo = { bar => "stuff" }; $foo->{bar}->{baz}
use strict; use warnings; my %foo = (hello => [1,22,303]); [$foo{hello}[1]]
use strict; use warnings; my @foo = "hi"; "class ${foo[0]}{ ... };"
use strict; use warnings; my @foo = "hi"; "class $foo[0]\{ ... };"
use strict; use warnings; my $foo; push @$foo, 1; $foo
use strict; use warnings; my @groups; my $chunk = []; for my $x ("foo", "bar", "baz\n", "x", "y", "z") { push @$chunk, $x; if ($x =~ /\R\z/) { push @groups, $chunk; $chunk = []; } } push @groups, $chunk if @$chunk; [ @groups ]
use strict; use warnings; my %h = ( 1 => 200, 0 => 100, q{} => 50, undef => 25 ); $h{undef};
use strict; use warnings; my %h = ( 1 => 200, 0 => 100, q{} => 50, undef => 25 ); my $x; $h{$x}; ### Wtf?
use strict; use warnings; my %h = (1 => 2); sub x {my $ref = shift; $ref->{1} = 3}; x(\%h); $h{1}
use strict; use warnings; my %h = (a => b, c => d, e => f); my $str = "abcdef"; $str =~ m/(.)/$h{$1}/g; print "$str";
use strict; use warnings; my %h = (a => "b", c => "d", e => "f"); my $str = "abcdef"; $str =~ s/(.)/$h{$1} // $1 /eg; print "$str";
use strict; use warnings; my $h = {a => "b", c => "d", e => "f"}; my $str = join ",", grep defined, @$h{qw/a b c/}; print $str;
use strict; use warnings; my $h = {a => "b", c => "d", e => "f"}; my $str = join(",", grep {defined($h->{$_})} (qw/a b c/)); print $str;
use strict; use warnings; my $h = {a => "b", c => "d", e => "f"}; my $str = join(",", map { $h->{$_} // () } (qw/a b c/)); print $str; # or do both in the map
use strict; use warnings; my $h = {a => "b", c => "d", e => "f"}; my $str = map $h->{$_}, join(",", grep {defined($h->{$_})} (qw/a b c/)); print $str;
use strict; use warnings; my %hash;  "hash"->{key} = "message"; \%hash
use strict; use warnings; my %hash; ${"hash"}{key} = "message"; \%hash
use strict; use warnings; my $hash_ref = { 'foo' => 'bar' }; $%hash_ref{'foo'};
use strict; use warnings; my $hash_ref = { 'foo' => 'bar' }; $hash_ref{'foo'};
use strict; use warnings; my $hash_ref = { 'foo' => 'bar' }; %$hash_ref{'foo'};
use strict; use warnings; my %hash_ref = { 'foo' => 'bar' }; $hash_ref{'foo'};
use strict; use warnings; my %h = ('a' => "This is A", 'b' => "This is B"); $h{'a'} = "One A too many."; $h{'c'} = "Foobar"; \%h
use strict; use warnings; my $_ # hence the "experimental" - generally safer not to use it, and avoid things that do
use strict; use warnings; my %h = ('fling' => 1, 'rindolf' => 2, 'gamo' => 3); my @arr = (map { [$_, $h{$_}] } keys %h); [@arr]
use strict; use warnings; my $h = {"foo" => 5, "bar" => 6, "baz" => 2}; print Dumper(@{$h}->{qw/foo bar baz/});
use strict; use warnings; my %h = (foo => 'bar'); my $aref = [\%h,\%h,\%h]; $aref->[0]{foo} = 'dexter'; $aref
use strict; use warnings; my %h = (foo => bar); my $aref = [\%h,\%h,\%h]; $aref->[0]{foo} = 'dexter'; $aref
use strict; use warnings; my %h = (foo => bar); my $aref = [\%h,\%h,\%h]; $aref[0]{foo} = 'dexter'; $aref
use strict; use warnings; my %h; $h{'foo','bar'} = "much"; \%h
use strict; use warnings; my $href; %$href
use strict; use warnings; my $input="Exact map coverage is (55.668840408325195,20.794050693511963) to (58.08229207992554,28.241150379180908)"; [ $input =~ m#([0-9]+(?:\.[0-9]+)?)#g]
use strict; use warnings; my $input="Exact map coverage is (55.668840408325195,20.794050693511963) to (58.08229207992554,28.241150379180908)"; [ $input =~ m#([0-9]+(\.[0-9]+)?#g]
use strict; use warnings; my ( $linecount, $timestart) = (0,0); printf(".... %s ... ", int($linecount/(time()-$timestart+1)));
use strict; use warnings; my $my->{my}
use strict; use warnings; my $name = 'something'; $$name = 'data'; { our $something; $something } # if you get an error when you make that change...
use strict; use warnings; my $name = 'Tectu'; print "Hello $name!\n";
use strict; use warnings; my $num = 5.2323232; $num = sprintf("%.3f", $num); [$num]
use strict; use warnings; my %old_hash = (1 => 2, 3 => undef); my %new_hash; $new_hash{$old_hash{$_}} = $_ for keys %old_hash; \%new_hash
use strict; use warnings; my %old_hash = (1 => 2, 3 => undef); my %new_hash = reverse %old_hash; \%new_hash
use strict; use warnings; my $PROG = sub { "like this?" }; "${PROG}" # really?
use strict; use warnings; my $ref = [qw(hi one two)]; unshift(@$ref, "Hello"); [$ref]
use strict; use warnings; my $s = "5/5/1977"; $s =~ s/(\d{1,2})\/(\d{1,2})\/(\d{4})/sprintf("%04d%02d%02d", $3, $2, $1)/e; [$s]
use strict; use warnings; my $s = "aabaaaaaaaaaaaab"; my @x = $s =~ /(a++b)/; [@x]
use strict; use warnings; my $s = "aabaaaaaaaaaaaab"; @x = $s =~ /(a++b)/; [@x]
use strict; use warnings; my %sections = { name => "testname" }; [ %sections ] # probably not what you wanted in %sections
use strict; use warnings; my $s = "Hello maroloccio___. How is your day."; $s =~ s#\AHello (\w+)# my $name = $1; $name =~ s/_+\z//; $name#e; [$s]
use strict; use warnings; my $s = "Hello maroloccio___. How is your day."; $s =~ s#\AHello (\w+)# my $name = $1; $name =~ s/_+\z//; $name#; [$s]
use strict; use warnings; my %shift = (bar => 1); print %shift
use strict; use warnings; my %shift = (bar => 1); print %{shift}
use strict; use warnings; my $s = q{<a rel="nofollow" href="http://www.FOOtube.com/v/ABCDEFG" target="_blank">Youtube Video</a>}; $s =~ s#<a(?:\s+(?:href=(\S+\byoutube\.com/\S+)|[^>]*?))+\s*\>.*?</a>#$1# && print qq{Match: $1\n}; [ $s, $1 ];
use strict; use warnings; my $s = q{<a rel="nofollow" href="http://www.youtube.com/v/ABCDEFG" target="_blank">Youtube Video</a>}; $s =~ s#<a(?:\s+(?:href=(\S+\byoutube\.com/\S+)|[^>]*?))+\s*\>.*?</a>#$1# && print qq{Match: $1\n}; [ $s, $1 ];
use strict; use warnings; my $s = q{foo=bar=baz}; my $p = qr/=(.*?)=/; my $r = q{",$1,"}; $s =~ s/$p/$r/re;
use strict; use warnings; my $s = q{}; my $r = s =~ s///; OK wtf?
use strict; use warnings; my $s = q{}; my $r = s =~ s///; # wtf?
use strict; use warnings; my $str = "012"; my @f = (qw/2 1 0/); $str =~ s/(join("|", @f))/$f[$1]/g; print $str
use strict; use warnings; my $str = "\"foo bar baz\""; print "pre [$str]\n"; $str =~ s/(?:[^\\])"$//; print "post [$str]\n";
use strict; use warnings; my $str; length($str)
use strict; use warnings; my %table = {}; # strict+warnings may help with issues like that
use strict; use warnings; my $test = ""; [defined($test) ? "Def" : "Undef"]
use strict; use warnings; my @things; (my $x = '%%123@@@@456&&234') =~ s/([\$%\@&])\1+\K([0-9]+)/push @things, $2/ge; \@things # could even do something like this, for example
use strict; use warnings; { my $v=0; sub foo : lvalue { $v } } foo++;
use strict; use warnings; { my $v=0; sub x : lvalue { $v } } ++x;
use strict; use warnings; { my $v=0; sub x : lvalue { $v } } x++;
use strict; use warnings; my $var = undef; @{$var} # and you understand why this fails but Bar(@{$var}) doesn't, right?
use strict; use warnings; my $v = sub { "Miesco", 1+1, print("Blessed are the cheese makers") }->(); print " Return value was: [ $v ]" # seems print turns off auto-value-dump in perlbot?
use strict; use warnings; my $v = sub { "Miesco", 1+1, print("Blessed are the cheese makers") }->(); [ $v ]
use strict; use warnings; my $word_re = qr/\w+/; my $pat_re = qr/(?:$word_re-)*$word_re/; [grep { $_ =~ /\A$pat_re\z/ } ("foo-123")]
use strict; use warnings; my $word_re = qr/\w+/; my $pat_re = qr/(?:$word_re-)*$word_re/; [grep { $_ =~ /\A$pat_re\z/ } ("foo-123", "bar-3600-Zab","Maj+4")]
use strict; use warnings; my %x = { };
use strict; use warnings; my @x = ([0,1,2]) x 5; $x[0][2] = 100; [@x]
use strict; use warnings; my $x = 0; for my $i (1 .. 100) { $x += 0.01; } [sprintf("%.50f", $x)]
use strict; use warnings; my $x = -100 ; for my $y (0 .. $x) { hello_there(); } 1;
use strict; use warnings; my @x = (1 .. 5); @x[0,2] = (100,200); [@x]
use strict; use warnings; my $x = 1; my $h = do { if ( $x == 2 ) { \*STDERR; } elsif ( $x == 1 ) { \*STDOUT; } }; $h
use strict; use warnings; my $x = 1; my $h = do { if ( $x == 2 ) { \*STDERR; } if ( $x == 1 ) { \*STDOUT; } }; $h
use strict; use warnings; my $x = 1; my $h = do { \*STDERR if $x == 2; \*STDOUT if $x == 1; }; $h
use strict; use warnings; my $x = 1; our $x = 2; $x
use strict; use warnings; my $ x = 2  # or even
use strict; use warnings; my @x = (500, 24, 300, 2800); $#x = -1; [@x]
use strict; use warnings; my @x = (500, 24, 300, 2800); $#x = 1; [@x]
use strict; use warnings; my $x = 'abc'; ${x}
use strict; use warnings; my $x = "| |"; ["Foo $x y $x"]
use strict; use warnings; my $x = []; push $x, '...';
use strict; use warnings; my %x = ( qw(AAA 1111 BBB 222 CCC 333 DDD 444) ); (()=%x)/2;
use strict; use warnings; my %x = ( qw(AAA 1111 BBB 222) ); %x+0
use strict; use warnings; my $x; sub Foo : lvalue { $x } sub Bar { } my $var = undef; Bar(@{Foo()}) # does that make it any clearer?
use strict; use warnings; my $x = "test"; ["$ x"] # any clearer?
use strict; use warnings; my ($x, undef) = (5,10);
use strict; use warnings; my $x; undef $x; length($x) < 4 # the length() warnings can be mildly confusing
use strict; use warnings ; my @x; $x[5] = 5; [keys@x]
use strict; use warnings;  my %x; $x{a} = 4; @x{a} = (5); print $x{a};
use strict; use warnings; my $x; --$x if $x > 1; \$x; # Just wondering, is there a nice rewrite this to avoid the warning, without using something like if $x && $x > 1 (is there a shorter/simpler way?)
use strict; use warnings; my $x; $$x = 'test'; $x # even scalars
use strict; use warnings; my $x; ($x ? $x++ : $x ) = 1; $x;
use strict; use warnings; my $x; $x ? $x++ : ($x = 1); $x;
use strict; use warnings; my $x; $x ? $x++ : $x = 1; $x;
use strict; use warnings; my $x->{y} = 55
use strict; use warnings; $_ = my ($x, $y); $x = "hi"
use strict; use warnings; my %x = (y => 'z'); $x{'hey'} += 100; \%x
use strict; use warnings; my $y; my @x = @$y; # rvalue
use strict; use warnings; my $y; my @x; @$y = @x; # lvalue
use strict; use warnings; my $z = {}; (my $z)->{z}
use strict; use warnings; my $z = {}; my ($z->{z})
use strict; use warnings; my $z = {}; my $z->{z}
use strict; use warnings; [ 'NaN' + 'sNaN' ]
use strict; use warnings; no strict 'refs'; my $name = 'something'; $$name = 'data'; { our $something; $something } # ... then add no strict 'refs';
use strict; use warnings; 'ok'; ()
use strict; use warnings; [open my $fh, '<', '']
use strict; use warnings; open(my $fh, ">", "myfic.txt");my ($fh) = @_; # because this should give you a warning
use strict; use warnings; [open my $fh, '<', undef]
use strict; use warnings; open my $out2, q{>&=}, 2 or die qq{open failed: $!}; print $out2 "hi";
use strict; use warnings; our $x = 1; my $x = 2; $x
use strict; use warnings; package foo {} foo->import;
use strict; use warnings; { package Foo; our $bar = 42; } my $pkg = "Foo"; my $var = do { no strict 'refs'; \${"${pkg}::bar"} }; $$var
use strict; use warnings; { package Foo; our $bar = 42; } my $pkg = "Foo"; ${ $::{$pkg . '::'}->{bar} }
use strict; use warnings; { package Foo; sub bar { 42 } } my $pkg = "Foo"; my $fn = \&{"${pkg}::bar"}; $fn->()
use strict; use warnings; { package Foo; sub bar { 42 } } my $pkg = "Foo"; "${pkg}::bar"->()
use strict; use warnings; package Obj; sub new { return bless {} , shift; } sub w_state { state $foo; return ++$foo; } ; package main; my @x; my $t = Obj->new; my $r = Obj->new; push @x, $t->w_state; push @x, $r->w_state; [@x]
use strict; use warnings; {package sort::numeric; BEGIN { $INC{'sort/numeric.pm'} = 1 } sub import { no strict 'refs'; *{caller . '::sort'} = sub { GLOBAL::CORE::sort { $a <=> $b } @_ } } } use sort::numeric; [ sort 1,3,2,31,13,12,15,42 ] # pragma
use strict; use warnings; package SubTest; sub DESTROY { print qq{Good bye cruel wor...\n}; } package main; sub foo { my ( $x, $worker ); $worker = bless sub { $x++; $worker->() unless $x >= 5; }, q{SubTest}; $worker->(); undef $worker; $x; } print foo;
use strict; use warnings; package SubTest; sub DESTROY { print qq{Good bye cruel wor...\n}; } package main; sub foo { my ( $x, $worker ); $worker = bless sub { $x++; $worker->() unless $x >= 5; }, q{SubTest}; $worker->(); $x; } print foo;
use strict; use warnings; package SubTest; sub DESTROY { print qq{Good bye cruel wor...\n}; } package main; sub foo { my ( $x, $worker ); $worker = bless sub { $x++; $worker->() unless $x >= 5; undef $worker; }, q{SubTest}; $worker->(); $x; } foo;
use strict; use warnings; package SubTest; sub DESTROY { print qq{Good bye cruel wor...\n}; } package main; sub foo { my ( $x, $worker ); $worker = bless sub { $x++; $worker->() unless $x >= 5; undef $worker; }, q{SubTest}; $worker->(); $x; } print foo;
use strict; use warnings; print $!
use strict; use warnings; print &$!;
use strict; use warnings; print chr(0xe08)
use strict; use warnings; print "Foo $_" foreach qw(one two three);
use strict; use warnings; rand * 3
use strict; use warnings; reduce 1;
use strict; use warnings; reduce(1)
use strict; use warnings; say 1.2.3
use strict; use warnings; sort { $a <=> $x } 1,2,3; # looks like an error to me
use strict; use warnings; s/^\///r for ''; ''
use strict; use warnings; sub abc { } sub xyz { } *xyz = sub { 123 }; { no warnings "redefine"; *abc = sub { 4 }; [] } # no warnings '...' is usefully self-documenting, any particular reason to do things manually?
use strict; use warnings; sub ALL_EMPS { return +{ one => 1, two => 2, three => 3}}; my %h = %{ ALL_EMPS() }; [$h{three}]
use strict; use warnings; sub a :lvalue { $a } a=10;a=20; print "$a\n"; # <--- see, strict and warnings clean
use strict; use warnings; sub Bar { ++$_ for @_ } my $x; 1 for @{$x}; $x # note that it's not just function calls, you'll get the same with foreach aliasing
use strict; use warnings; sub create_iterator { my ($val) = @_; my $iter = sub { return ++$val; } ; return $iter } my $iter1 = create_iterator(100); my $iter2 = create_iterator(5); [$iter1->(),$iter2->(),$iter1->(),$iter2->()]
use strict; use warnings; sub flatten { return map { ref($_) eq 'ARRAY' ? flatten(@$_) : $_ } @_ } [flatten([1, [2, 3], [4, [5]], 6])]
use strict; use warnings; sub flatten { return map { ref($_) eq 'ARRAY' ? flatten(@$_) : $_ } @_ } [flatten(1, [2, 3], [4, [5]], 6])]
use strict; use warnings; sub foo { 42 } *bar = \&foo; bar()
use strict; use warnings; sub foo { 42 } my $name = 'foo'; 'main'->$name
use strict; use warnings; sub foo { "foo" } foo
use strict; use warnings; sub foo { my ($ch, $name) = @_; } foo(undef, undef); #are you sure?
use strict; use warnings; sub foo { shift } my $name = 'foo'; 'main'->can($name
use strict; use warnings; sub foo { shift } my $name = 'foo'; 'main'->can($name)->(42)
use strict; use warnings; sub foo { shift } my $name = 'foo'; 'main'->can($name)(42)
use strict; use warnings; sub Foo { undef } sub Bar { } Bar(@{Foo()}) # you're saying this one works, or did you mean the else { } clause?
use strict; use warnings; sub Foo {undef } sub Bar { } my $x; Bar(@{$x = Foo()})
use strict; use warnings; sub func { return undef;} if(1 and defined(func("Foo"))) { print "Success!"; }
use strict; use warnings; sub func { return undef;} if(1 and !defined(func("Foo"))) { print "Success!\n"; }
use strict; use warnings; sub func { return undef;} if(1 and defined(func("Foo"))) { print "Success!\n"; }
use strict; use warnings; sub get_closure { my $x = 124; my $returnval = sub { return $x; }; ++$x; return $returnval; } my $foo = get_closure(); [$foo->()]
use strict; use warnings; sub get_closure { my $x = 124; my $returnval = sub { return $x; }; ++$x; return $retval; } my $foo = get_closure(); [$foo->()]
use strict; use warnings; sub get_closure { my $x = 124; return sub { return $x; } } my $foo = get_closure(); [$foo->()]
use strict; use warnings; sub get_closure { my $x = 124; return sub { return $x; }; ++$x; } my $foo = get_closure(); [$foo->()]
use strict; use warnings; sub int {} my ( $linecount, $timestart) = (0,0); printf(".... %s ... ", int($linecount/(time()-$timestart+1)));
use strict; use warnings; sub ls{my ($n, $h)=@_;my $ret;for(0..$#$h){$ret=$_ and last if $n eq $h->[$_]}$ret}; ls (3,[0,1,4,3,2])
use strict; use warnings; sub { my $x = 42; sub { eval '$x' } }->()->()
use strict; use warnings; sub outer { my ($var) = @_; sub inner { print $var||'three' } }   outer("one"); inner(); outer("two"); inner() # as the warning implies, "don't do this"
use strict; use warnings; sub sort { CORE::GLOBAL::sort { $a <=> $b } @_ } [ sort 1,3,2,31,13,12,15,42 ] # huh, maybe
use strict; use warnings; sub sort { GLOBAL::CORE::sort { $a <=> $b } @_ } [ sort 1,3,2,31,13,12,15,42 ] # all *your* sorts, sure, but not all sorts everywhere
use strict; use warnings; sub test { return bareword { return 42; } }; test()
use strict; use warnings; sub what { (my $foo, @_) = @_; \@_ } what(qw(a b c d));
use strict; use warnings; sub what { my ($foo, @_) = @_; \@_ } what(qw(a b c d));
use strict;use warnings;sub x { my($x,$y,$z)=@_;print $x } x(1,2);
use strict; use warnings; system "echo 'xxx@xxxxxxxx$' rsync"
use strict; use warnings; \&this_sub_doesnt_exist
use strict; use warnings; "UCS-4" =~ /^UCS-?4-?(BE|LE)?$/i; eval q@uc("UTF-32$1")@
use strict; use warnings; (undef) = 10;
use strict; use warnings; undef = 10;
use strict; use warnings; undef $f; my $f;
use strict; use warnings; use 5.016; package Obj; sub new { return bless {} , shift; } sub w_state { state $foo; return ++$foo; } ; package main; my @x; my $t = Obj->new; my $r = Obj->new; push @x, $t->w_state; push @x, $r->w_state; [@x]
use strict; use warnings; use constant TEST2 => TEST1; use constant TEST1 => 1; use constant TEST3 => TEST1; [TEST1, TEST2, TEST3]
use strict; use warnings; use DateTime::TimeZone; my $tz = DateTime::TimeZone->new(name => '-0400')->name
use strict; use warnings; use DateTime::TimeZone; my $tz = DateTime::TimeZone->new(name => 'America/New_York')
use strict; use warnings; use experimental qw[signatures]; sub test ($foo) { say $foo } test ('moo')
use strict; use warnings; use experimental qw(signatures); sub whatever($=) { print $= } whatever(3) # I'm happy enough with the way signatures work at the moment though
use strict; use warnings; use feature qw(say); say for qw(foo -- bar); # what makes you think it throws an error?
use strict; use warnings; use feature qw(say); use XML::LibXML; my $t1 = XML::LibXML::Text->new( q{foo} ); my $t2 = XML::LibXML::Text->new( q{bar} ); $t1->appendChild( $t2 ); say $t1;
use strict; use warnings; use List::MoreUtils qw(any all); my $count = 5; my @nums = (sort { $a <=> $b} qw(10 4 3 4 4 59 39 5 3)); [any { my $x = $_; my $p = $nums[$_]; all { $nums[$x+$_]-$p <= 3 } (0 .. $count-1) } 0 .. (@nums-$count)]
use strict; use warnings; use List::MoreUtils qw(any all); my @nums = (sort { $a <=> $b} qw(10 4 3 4 4 59 39 5 3)); [any { my $x = $_; my $p = $nums[$_]; all { $nums[$x+$_]-$p <= 3 } (0 .. 5) } } keys(@nums)]
use strict; use warnings; use List::MoreUtils qw(any all); my @nums = (sort { $a <=> $b} qw(10 4 3 4 4 59 39 5 3)); [any { my $x = $_; my $p = $nums[$_]; all { $nums[$x+$_]-$p <= 3 } (0 .. 5) } keys(@nums)]
use strict; use warnings; use List::MoreUtils qw/uniq/; [ sort(uniq qw/a b c a/) ];
use strict; use warnings; use List::MoreUtils qw/uniq/; [ sort(uniq(qw/a b c a/)) ];
use strict; use warnings; use List::Util; my $c = [qw(a b c)]; print "1" if List::Util::any { $_ eq "a" } @{$c}
use strict; use warnings; use List::Util qw(pairmap); $_ = qq{foo}; my @l = /(\R)/; push @l, undef if @l%2; [ pairmap { [$a, $b] } @l ]
use strict; use warnings; use List::Util qw(pairmap); $_ = qq{foo\n}; [ pairmap { } split /\R/ ];
use strict; use warnings; use List::Util qw(pairmap); $_ = qq{foo}; [ pairmap { } split /(\R)/ ]; # Better test case.
use strict; use warnings; use List::Util qw[sum]; my $var = {  a => {count => 1},  b => {count => 5} }; [sum map { $_->{count} } values %{ $var }]
use strict; use warnings; use List::Util qw[sum]; my $var = {  a => {count => 1},  b => {count => 5} }; [sum values %{ $var }]
use strict; use warnings; use POSIX qw(sysconf); [ sysconf(POSIX::_SC_PAGESIZE()) ]
use strict; use warnings; use POSIX; setlocale(LC_NUMERIC, "de_DE") or die $!; sprintf("%.2f", 23.45)
use strict; use warnings; use POSIX; setlocale(LC_NUMERIC, "de_DE"); sprintf("%.2f", 23.45)
use strict; use warnings; use Scalar::Util qw(blessed); [ blessed qr/foo/ ]
use strict; use warnings; use Scalar::Util qw( reftype ); my $foreach = q{}; ref $foreach eq q{CODE}; # No warning.
use strict; use warnings; use Scalar::Util qw( reftype ); my $foreach = q{}; reftype $foreach eq q{CODE}; # Why does this warning occur?
use strict; use warnings; use Scalar::Util qw(reftype); my $re = qr/foo/; [ ref $re, reftype $re ];
use strict; use warnings; use Scalar::Util qw(reftype); my $x = bless \*STDOUT; [ ref $x, reftype $x ];
use strict; use warnings; use Scalar::Util qw(reftype); my $x = []; [ ref $x, reftype $x ];
use strict; use warnings; use Scalar::Util qw(reftype); my $x = {}; [ ref $x, reftype $x ];
use strict; use warnings; use Scalar::Util qw(reftype); my $x = \*STDOUT; [ ref $x, reftype $x ];
use strict; use warnings; use Scalar::Util qw(reftype); my $x = sub{}; [ ref $x, reftype $x ];
use strict; use warnings; use version; my $ver = qv(q{1.0.0}); $ver;
use strict; use warnings; use version; my $ver = qv(q{1.0.0}); version->parse( $ver )->stringify;
use strict; use warnings; vA.10
use strict; use warnings; $::whatever = 'like this'; $::whatever
use strict; while (my $x = 1) { last } continue { say $x }
use strict; $x->()
use strict; @x = (foo => 1, bar => 2); ${{@x}}{"foo"}
use strict; $x = inf;
use String::Util qw/trim/; trim("pink_mist");
use strit; 404->();
use subs 'defined'; sub defined { 42 } defined
use subs 'foo'; sub AUTOLOAD { print 'hi' } foo;
use subs print; sub print {CORE::print "foo: @_"}; print bar;
use subs qw/print/; sub *print {CORE::print "foo: @_"}; print bar;
use subs qw/print/; sub print {CORE::print "foo: @_"}; print bar;
use Sub::Util
use Switch::Plain;
use Test::more
use Test::More
use Tie::IxHash
use Time::HiRes 'time'; time
use Time::HiRes 'time'; time(0); # see, this is a much more sensible error
use Time::HiRes 'time'; time() - $^T;
use Time::HiRes; use POSIX qw(strftime); my $time = Time::HiRes::time; strftime('%Y-%m-%dT%H:%M:%S', gmtime $time) . sprintf '.%.06d', $time - int $time;
use Time::HiRes 'usleep'; usleep(-1);
use Time::Local; $bday="1951/1/1"; ($byear,$bmonth,$bday)=$bday=~/(\d+)\/(\d+)\/(\d+)/; print "".((localtime time)[5]-1900) - (localtime(timelocal(0,0,0,$bday,$bmonth-1,($byear-1900))))[5]+1900
use Time::Local; $bday="1951/1/1"; ($byear,$bmonth,$bday)=$bday=~/(\d+)\/(\d+)\/(\d+)/; print "".((localtime time)[5]-1900) - (localtime(timelocal(0,0,0,$bday,$bmonth-1,$byear)))[5]+1900
use Time::Local; $bday="1978/1/1"; ($byear,$bmonth,$bday)=$bday=~/(\d+)\/(\d+)\/(\d+)/; print "".((localtime time)[5]-1900) - (localtime(timelocal(0,0,0,$bday,$bmonth-1,($byear-1900))))[5]+1900
use Time::Local; $bday="1978/1/1"; ($byear,$bmonth,$bday)=$bday=~/(\d+)\/(\d+)\/(\d+)/; print "".((localtime time)[5]-1900) - (localtime(timelocal(0,0,0,$bday,$bmonth-1,$byear)))[5]+1900
use Time::Local; $bday="1980/1/1"; ($byear,$bmonth,$bday)=$bday=~/(\d+)\/(\d+)\/(\d+)/; print "".((localtime time)[5]-1900) - (localtime(timelocal(0,0,0,$bday,$bmonth-1,($byear-1900))))[5]+1900
use Time::Local; $bday="1984/1/1"; ($byear,$bmonth,$bday)=$bday=~/(\d+)\/(\d+)\/(\d+)/; print "".((localtime time)[5]-1900) - (localtime(timelocal(0,0,0,$bday,$bmonth-1,($byear-1900))))[5]+1900
use Time::localtime; print ctime();
use Time::localtime; print localtime->year()+1900;
use Time::Moment
use Time::Moment; Time::Moment->now
use Time::Piece
use Time::Piece;
use Time::Piece; $ENV{TZ} = 'UTC'; $t1 = Time::Piece->strptime("1:02:03", "%H:%M:%S")->epoch; $t2 = Time::Piece->strptime("4:05:06", "%H:%M:%S")->epoch; [ Time::Piece->new($t1 + $t2)->hms ];  # Syntactic
use Time::Piece; $foo = Time::Piece->strptime('2014-12-25 14:00:10', '%Y-%m-%d %H:%M:%S'); [ scalar CORE::localtime($foo->epoch) ]
use Time::Piece; [localtime->year, localtime->strftime("%a %b %d %H:%M:%S %Z %Y")]
use Time::Piece; my $time = localtime; [map { $time->$_ } qw(mday mon year)]
use Time::Piece; my $time = localtime; ($time->hour >= $open_hour and $time->hour < $close_hour) ? 1 : 0
use Time::Piece; my $t = localtime; [$t->epoch]
use Time::Piece; my $t = localtime; [ $t->mday, $t->month_last_day ]
use Time::Piece; say scalar Time::Piece->strptime("20070930 170004000" =~ s/[0-9]{3}\z//r, "%Y%m%d %H%M%S")->strftime("%F %T")
use Time::Piece; say scalar Time::Piece->strptime("20070930 170004000", "%Y%m%d %H%I%S%3N")->strftime("%F %T")
use Time::Piece; say scalar Time::Piece->strptime("20070930 170004000", "%Y%m%d %H%I%S")->strftime("%F %T")
use Time::Piece; say scalar Time::Piece->strptime("20070930 170004", "%Y%m%d %H%I%S")->strftime("%F %T")
use Time::Piece; Time::Piece->strptime(201407100700, '%Y%m%d%H%M')->epoch
use Time::Piece; Time::Piece->strptime("2015-04-27T15:43:16+02:00", "%Y-%m-%dT%H:%M:%S%z")
use Time::Piece; Time::Piece->strptime("2015-04-27T15:43:16+02:00", "%Y-%m-%dT%H:%M:%S%Z")
use Time::Piece; Time::Piece->strptime("2015-04-27T15:43:16.046379+02:00", "%Y-%m-%dT%H:%M:%S%Z")
use Time::Piece; Time::Piece->strptime("2015-04-27T15:43:16", "%Y-%m-%dT%H:%M:%S")
use Time::Seconds; say ONE_YEAR
use Try::Tiny; $a=1; $b=1; LABL: while($a--) {try {die if $b--} catch {redo LABL;} finally {print "bark "; print "hello world"};
use Try::Tiny; $a=1; $b=1; LABL: while($a--) {try {die if $b--} catch {redo LABL;} finally {print "bark "}; print "hello world"};
use Try::Tiny; $a=1; $b=1; LABL: while($a--) {try {die if $b--} catch {redo LABL;}; print "hello world"};
use Try::Tiny; try {die "baz";} catch {die "foo"} finally { print "hoyl shit that broke"};
use Unicode::UCD qw(charinfo); charinfo('x')
use URI
use URI;
use URI::Encode qw/uri_encode/; uri_encode "<arg>", {"encode_reserved", 1}; 
use URI::Escape;
use URI::Escape qw( uri_escape ); uri_escape q{foo+bar};
use URI::Escape; uri_escape_utf8 "http://web.de/"
use URI; my $foo = URI->new('http://www.example.com?q=Óthelo&s=blah'); $foo->as_string;
use URI; my $u = URI->new( q{http://foo.com/bar?x=1&x=2&y=baz} ); +{ $u->query_form };
use URI; my $u = URI->new( q{http://foo} ); do { no overload; print $u; }
use URI; $u = URI->new("foo", "http"); [ $u->as_string, $u->canonical ]
use utf8;  §$§")/"
use utf8; "–"
use utf8; $☃ = 1; $☃
use utf8; ['٢٠١٦-٠٣-٢٢ ١٨:٥٤:٣٢' =~ /(\d{4}-\d{2}-\d{2}) (\d{2}:\d{2}:\d{2})/]
use utf8; ['٢٠١٦-٠٣-٢٢ ١٨:٥٤:٣٢' =~ /(\d{4}-\d{2}-\d{2}) (\d{2}:\d{2}\d{2})/]
use utf8; ['٢٠١٦-٠٣-٢٢ ١٨:٥٤:٣٢' =~ /(\d{4}-\d{2}-\d{2}) (\d{2}:\d{2}:\d{2})/a]
use utf8; "٢ű" =~ /^\w+$/ # thomas_d
use utf8; '٣' =~ /\d/
use utf8; [ '٣' =~ /\d/a, '٣' =~ /./a, "٢" =~ /[١-٣]/a, '٣' =~ /\D/a ]
use utf8; $🗾 = 42;
use utf8; $✆ = 5;
use utf8; $_ = "æøå"; s/(.)/sprintf('\\u%04x', ord $1)/ger
use utf8; binmode STDOUT, ':utf8'; my $foo = "test\x{327}"; $foo =~ tr/\x{327}/\x{326}/; $foo
use utf8; $bit = "C"; print unpack("b8", $bit) . "\n"; $bit | 1 << 6; $bit = unpack("b8", $bit); print $bi
use utf8; bless {}, "skjærgårdsøl";
use utf8; '𐒢' =~ /\d/
use utf8; '𐒢' =~ /\d/a
use utf8; $_="é"; $_++; $_
use utf8; ['é' =~ /[[:alpha:]]/ . '', 'é' =~ /[[:alpha:]]/a . '']
use utf8; fc "ß"
use utf8; [fc("Ա"), fc("乕")]
use utf8; $こんにちは = "Good afternoon"; $こんにちは
use utf8; $l = "fooso"; [ $l & chr(0x80)x(length $l) ]
use utf8; $l = "fooso"; [ $l =~tr/\0-\225//dr   ]
use utf8; [ map fc, qw(SS ss ß Σ σ ς I i İ ı) ]
use utf8; [ map lc, qw(SS ss ß Σ σ ς I i İ ı) ]
use utf8; my $å = "buu"
use utf8; my %foo = ('♥' => 'lukelove'); print $foo{'♥'} . 'fuckit';
use utf8; my %foo = ('♥' => 'lukelove'); say $foo{'♥'};
use utf8; my $foo = "test\x{327}"; $foo =~ tr/\x{327}/\x{326}/; $foo
use utf8; my $input = '٣'; say $input + 42;
use utf8; my $str = "Äö"; [ $str =~ /([[:upper:]])/ ]
use utf8;  my $szín = 1; $szín + 1
use utf8; my $x = "ABC"; $x =~ tr/ABC/ＡＢＣ/; sprintf "%vx", $x
use utf8; my $x = "Bière"; printf "%vx", $x;
use utf8; my $x = "café"; my $y = substr($x, 1); [ utf8::is_utf8($x), utf8::is_utf8($y) ]
use utf8; my $α, $β; #these are fine, my $a, $b; is not :P
use utf8; [ord "ĉ"]
use utf8; ord "ĉ"
use utf8; [ord "ø"]
use utf8; [ord "ű"]
use utf8; ord uc "ñ"
use utf8; package µ; sub message { "Hi" };  say µ->message;
use utf8; 'pokèmon' =~ /\bpok[eè]mon\b/
use utf8; print "a"; print "b"
use utf8; print join "", ("?".."?");
use utf8; q ̈hellö
use utf8; q̈hellö
use utf8; quotemeta "ǁ"
use utf8; "ǁ" =~ s/([^A-Za-z_0-9])/\\$1/gr
use utf8; [ scalar('٣' =~ /^\d$/a), scalar('٣' =~ /^.$/a), scalar("٢" =~ /^[١-٣]$/a), scalar('٣' =~ /^\D$/a) ]
use utf8; [ scalar('٣' =~ /\d/a), scalar('٣' =~ /./a), scalar("٢" =~ /[١-٣]/a), scalar('٣' =~ /\D/a) ]
use utf8; sprintf "%x", ord "ő"
use utf8; sprintf "%x", ord uc "ñ"
use utf8; [ 'ß' =~ m/^\Qss\E\z/i ? 'True' : 'False' ];
use utf8; sub a b { "hi" } a b
use utf8; sub fåbar { print "whee" } fåbar();
use utf8; sub InGerm { join "\n", map sprintf("%x", ord($_)), qw(ä ö ü) } "ö" =~ /\p{InGerm}/
use utf8; sub » { print "whee" } »()
use utf8; sub t { 1, 2, 3 } t⦇0⦈
use utf8; sub ಠ_ಠ { "yay" } ಠ_ಠ
use utf8; sub 个 { print "whee" } 个();
use utf8; uc "ñ"
use utf8; uc "ß"
use utf8; unpack "H2", "ő"
use utf8; use constant Foo => join "\n", map sprintf("%x", ord($_)), qw(ä ö ü); [ "ö" =~ /\p{Foo}/ ];
use utf8; use constant InFoo => join "\n", map sprintf("%x", ord($_)), qw(ä ö ü); [ "ö" =~ /\p{InFoo}/ ];
use utf8; use feature fc; [fc("Ա"), fc("乕")]
use utf8; use Mojo::UserAgent; Mojo::UserAgent->new->get('http://mañana.com')->res->dom->at('title')->text
use utf8; use strict; sub ℕ₀ () { "cool" } ℕ₀
use utf8; [ "Ӧser Bánana" =~ /\w+/g ]
use utf8; "Я очень плохо говорю по русский"
use utf8; $Ա = 5; $乕 = 7; [ $Ա + $乕 ]
use utf8; ["Ա" < "乕"?"yes":"no"]
use v5.12; $foo = 'bar'; ++$$foo; $bar
use v5.12; "foo" =~ /(.*)/; say $1; { if ("bar" =~ /(.*)/) { say $1; } } say $1;
use v5.12; "foo" =~ /(.*)/; say $1; if ("bar" =~ /(.*)/) { say $1; } say $1;
use v5.12; sub combine { my $f = shift; @_ or return $f->(); my $xs = shift; for my $x (@$xs) { combine(sub { $f->($x, @_) }, @_); } } combine sub { say join(", ", @_) }, ['a', 'b'], [1], [2, 3];
use v5.12; sub combine { my $f = shift; @_ or return $f->(); my $xs = shift; for my $x (@$xs) { combine(sub { $f->($x, @_) }, @_); } } combine sub { say join(", ", @_), " | "; }, ['a', 'b'], [1], [2, 3];
use v5.12; ++$x
use v5.16; $[ = 0
use v5.16; $[ = 1
use v5.16; $_=1; $0xfc
use v5.16; $_=1; $0x fc
use v5.16; $[ = -5;
use v5.16; my $f = sub { my ($n) = @_; print "$n "; $n or return; @_ = $n - 1; goto __SUB__; }; $f->(5);
use v5.16; ++$x
use v5.18; 1;
use v5.18.2;
use v5.20; my @x; push @x, foo(), foo(); sub foo { state $var = 0; $var++ } push @x, foo(), foo(); \@x
use v5.20; say hi
use v5.20; say "hi" for Altreus;
use v5.20; sub foo { __SUB__ } foo
use v5.20; use warnings; { package Hi; sub foo { state $x = 0; $x++ }  sub new { bless {}, $_[0] } }  [ Hi->new->foo, Hi->new->foo, Hi->new->foo ]
 use v5.6.1;
use Variable::Magic qw(cast wizard); cast my $foo = 4, wizard get => sub { ${$_[0]}++ }; unless ($foo == 5) { say 1 } elsif ($foo == 5) { say 2 } else { say "surprise!" }
use vars qw( $foo ); $foo = 123; $foo;
use version; my $v = version->new( 1.000001 ); printf q{%vd}, $v;
use version; my $v = version->new( 1.000001 ); $v;
use version; print version->parse($])->normal
use warnings;
use warnings; "" == ""
use warnings; ();
use warnings; {{}}
use warnings; $#
use warnings; +{{}}
use warnings;  [ !!"" == 0 ]
use warnings;  [ "" == 0 ]
use warnings; @_[0]
use warnings; 0 + ''
use warnings; 0+''
use warnings; 0+""
use warnings; 0+{}
use warnings; 0->[0];
use warnings; 00./(?[()])/
use warnings; 0+!1
use warnings; 0 + !5
use warnings; 0+'    9'
use warnings; 0+"    9e5";  # boo!
use warnings; 0+"    9e";  # yay!
use warnings; 0+("a" eq "b")
use warnings; [ '' == 0 ] # but you'll get a warning
use warnings; 0 + defined( undef )
use warnings; 0+'Inf'
use warnings; 0+'nanny'
use warnings; '0' == undef
use warnings; $0 = undef; "hello $0"
use warnings; [ 1 + "" ]
use warnings; $_[100]=();"@_"
use warnings; !1 == !1
use warnings; [ 1 == "1" ]
use warnings; [ 1 == "1foo" ]
use warnings; 1+2; 3+4
use warnings; '15.8' == '123abc   '
use warnings; '15.8' == undef
use warnings; '15.8' == (undef // '')
use warnings; '15.8' == (undef // ')'
use warnings; '15.8' == undef // ''
use warnings 1e0;
use warnings; [ 1 + "NaN" ]
use warnings; [ 1 + "Nanny may I have another?" ]
use warnings; [ 1 + "not a number" ]
use warnings; 2 + '0 but foo'
use warnings; 2 + '0 but true'
use warnings; $[ = 2; my @a = 5..9; [ keys @a], $#a ]
use warnings; 3 + undef
use warnings; $] < 5.13.6
use warnings; [ 5 <=> "infinityandbeyond", 8 <=> "nananananananananaBATMAN" ]
use warnings; [ 7 <=> "cats" ]
use warnings; [ 7 <=> "nan" ]
use warnings; [ 7 <=> "nand" ]
use warnings; [ 7 <=> "nandos" ]
use warnings; 'a' < 0
use warnings; @a[1]
use warnings; [ "a{b" =~ /a{/ ]
use warnings; "a{b" =~ m/{/;
use warnings; "a{b" =~ m/a{/;
use warnings; @a = (); print 'true' if @a == undef;
use warnings; @array[0]=5
use warnings; $array[99999]=5; 0+ $array[99998]
use warnings; @array[$index]
use warnings; "a" =~ s/./$1/gr
use warnings; "a" =~ s/./$1/r
use warnings; "a" =~ s/./$dict{1}/r
use warnings; 'bill.gates@microsoft.com' =~ /[\w.]+\@microsoft\.com$/ ? "matches" : "does not"
use warnings; binmode STDOUT; print "\x{1f4a9}"
use warnings; "blah" == "bleh"
use warnings; @bucket_store_content{ $_path_dismantled_tmp[-2] }
use warnings; @confignew{ "vm-id" } = [@listvm];
use warnings; CORE::localtime() - 3600
use warnings; die, die, die;
use warnings; [ $$, do { $a=++$$.s/../$$/;$$<<~~+$a } ]
use warnings; dump
use warnings; each []
use warnings; -e "foo\nbar";
use warnings; [ 'endurance' == 'strength' ? 'yes' : 'no' ]
use warnings; eval{print 1; next; print 2}
use warnings; eval{print 1; next; print 2}; print 'code: '.$?
use warnings; eval { $x->{a}{b} }
use warnings; exit "with a string"
use warnings FATAL => "all"; if (1 { my $x = 42; print $x; }
use warnings FATAL => 'utf8'; use Unicode::UTF8 'decode_utf8'; decode_utf8 "\x20\xf8\x20"
use warnings; [ -f "/", -f "/does-not-exist", -f undef ]
use warnings; @foo = (1,2,3); length(@foo)
use warnings; "foo" ~~ "Bar"
use warnings; "{{foo" =~ /{{f/
use warnings; $foo = $foo . "abc";
use warnings; 'foo' =~ s/(.)/\1/
use warnings; 'foo' =~ s/(.)/\1/re
use warnings; "foo"=~s/(foo)/\1/r
use warnings; @hash{$key}
use warnings; @hash{$key} = [ @list ]
use warnings; $hash{thing} => $value;
use warnings; ${^HELLO_GUYS} . ""
use warnings;+{[ here => "are", my => "values" ]}
use warnings; hex q{112233445566778899}
use warnings; %h = { stuff => 'sterf' }; \%h
use warnings; if (1 { my $x = 42; print $x; }
use warnings; if("a" == "b"){print "true";}else{print "false";}
use warnings; if (my $blah) { my $count = read $fh, my ($chunk), $chunk_size; }
use warnings; if (my $blah) { my $count = read $fh, my $chunk, ($chunk_size); }
use warnings; if (my $blah) { my $count = read $fh, my $chunk, $chunk_size }
use warnings; if (my $blah) { my $count = read $fh, my $chunk, $chunk_size; }
use warnings; if (my $blah) { my $count = read $fh, my $chunk, +$chunk_size; }
use warnings; if ($_) { sub foo { ... } } else { sub foo { ... } }
use warnings; if ("this section commented out" x 0) { die }
use warnings; $INC{42}
use warnings; int(q("1"))
use warnings; join " ", undef, undef, undef;
use warnings; join '', (undef)x100
use warnings; keys +{}
use warnings; keys INC
use warnings; LABEL: { sub { last LABEL }->(); print "fail" }; print "ok";
use warnings; [ map { $_ + 0 } !!0, !!"", !!undef ]
use warnings; [ map { ($_+0) ? 'True' : 'False' } 0, '0', '0 but true', '0e0', '0.0' ]
use warnings; [ map { $_ ? 'True' : 'False' } 0, '0', '0 but true', '0e0', '0.0' ]
use warnings; ''.methods.length
use warnings; "@microsoft.com" =~ /microsoft.com$/ ? "matches" : "does not"
use warnings; m/$var/
use warnings; my $_;
use warnings; my @a = 1..3; my %hash = @a;
use warnings; my $a=5+3, "hello\n";
use warnings; my $a=5+3, "hello\n"; print $a
use warnings; my @a = 5..9; delete $a[3] [ keys @a ]
use warnings; my @a = 5..9; delete $a[3]; [ keys @a ]
use warnings; my @a = 5..9; delete $a[4]; [ keys @a ]
use warnings; my @a = 5..9; delete $a[4]; [ [keys @a], $#a ]
use warnings; my @a = 5..9; [ keys @a ]
use warnings; my $aref = [1,2,3]; @{$aref}[1]
use warnings; my $aref = [1,2,3]; my $two = @{$aref}[1]
use warnings; my %args = { foo => 'bar' };
use warnings; my @arr = 1 .. 10; length(0 + @arr)
use warnings; my @arr = 1 .. 10; length('' . @arr)
use warnings; my @arr = 1 .. 10; length(@arr)
use warnings; my $arr = [1 .. 10]; length('' . @$arr)
use warnings; my @arr = 1 .. 10; length(map "now that's just silly", @arr)
use warnings; my @arr = (1, 3); @arr[0]
use warnings; my @arr; $arr["anything"] = 42;
use warnings; my @arr; $arr["inf"] = 42; [ @arr ]
use warnings; my @arr; $arr["NaN"] = 42;
use warnings; my @arr; $arr["NaN"] = 42; [ @arr ]
use warnings; my @array; print $array[5];
use warnings; my $buf = "\x{666}"; open my $fh, '<', \$buf or die "open: $!"
use warnings; my $buf = "\x{666}"; open my $fh, '<:encoding(utf8)', \$buf or die "open: $!"
use warnings; my $buf = "\xd9\xa6"; open my $fh, '<:encoding(utf8)', \$buf or die "open: $!"
use warnings; my @foo = 0..10; print "this matches" if "0 but true" ~~ @foo;
use warnings; my @foo = 0..10; print "this matches" if "0 but true" ~~ @foo; # thanks, pink_mist++
use warnings; my @foo = 0..10; print "this matches" if "0 but true" ~~ @foo; ... too vague for predictable behavior, use the comparison you mean or try Smart::Match for explicit smartmatching
use warnings; my @foo = 0..10; print "this matches" if "0 but true" ~~ @foo; ... too vague for predictable behavior, use the comparison you mean or try Smart::Match for explicit smartmatching | "Any non-trivial example of smartmatch usually does something other than the author intended."
use warnings; my @foo = 0..10; "this matches" if "0 but true" ~~ @foo;
use warnings; my $foo = 1,2;
use warnings; my $foo = 1,2,3; $foo
use warnings; my $foo = 1,2; $foo
use warnings; my $foo = 1; my $bar = 2; my $name = "foo"; print "ok" if (defined(${$name}));
use warnings; my $foo = 1; my $foobar = 2; "$foo\bar"
use warnings; my $foo = 1; undef $foo; say $foo
use warnings; my $foo, *bar;
use warnings; my @foo; defined @foo
use warnings; my $foo; $foo; 1;
use warnings; my $foo = { foo => 42}; [ keys  $foo]
use warnings; { my $foo; my $foo; }
use warnings; my $foo; { my $foo; }
use warnings; my $foo = sub { +{ content => 'content' }; }; $foo->()->{content};
use warnings; my $foo = sub { +{ content => 'content' }; }; $foo->(){'content'};
use warnings; my $foo = sub { +{ content => 'content' }; }; $foo->(){content};
use warnings; my $foo = undef; "$foo"
use warnings; my %hash = undef;
use warnings; my @list = 0 .. 10; [%list[1..2]]
use warnings; my @list = "a" .. "h"; [%list[1..3]]
use warnings; my ($l, $r) = ('', ''); $l .= chr($_+0x20), $r .= chr($_+0xff00) for 0x00..0x50; binmode STDOUT; eval qq{ 'Just another Unicode hacker,' =~ tr[\Q$l\E][\Q$r\E]r };
use warnings; my $n=split(/\|/,"one|two|three|four");
use warnings; my $n = () = split(/\|/,"one|two|three|four");
use warnings; my $ref = []; @$ref[0]
use warnings; my $ret = "foo" =~ s/Z/; [ $ret."", $ret+0 ]
use warnings; my $ret = "foo" =~ s/Z//; [ $ret."", $ret+0 ]
use warnings; my $ret = ( my $tmp = "foo" ) =~ s/Z//; [ $ret."", $ret+0 ]
use warnings; my $str; chomp($str);
use warnings; my $undefined; $undefined =~ s///;
use warnings; my $value = undef;  undef == 2
use warnings; my $value = undef;  $value == 2
use warnings; my $x = 12; [ "19" . $x ]
use warnings; my $x = 12; [ 19 . $x ]
use warnings; my $x = "1234abc"; $x++; $x
use warnings; my $x = "abcd"; $x++; $x
use warnings; my $xml = { sessions => [ { session => { status => 42 } } ] }; $xml->{sessions}{session}{status}
use warnings; my $x, my $x;
use warnings; my ($x, $x)
use warnings; my $x; $x += 2;
use warnings; my $x; $x .= "foo";
use warnings; my $x; $x . 'foo'
use warnings; my $x; $x = $x . 'foo'; # Zoffix
use warnings; my ($x, $y, $var) = (42, 37, 0); $var += max $x, $y; $var
use warnings; my($x, $y, $x)
use warnings; my ($x, $y) = ($y, $x);
use warnings; no warnings 'experimental::autoderef'; keys +{}
use warnings "\N{U+7FFFFFFF}"
use warnings; "\N{U+7FFFFFFF}"
use warnings; opendir my $dirh, ".";
use warnings; open $fh, '<', \"lala\nlulu"; join '|', <$fh>
use warnings; open $fh, "lala\nlulu"; join '|', <$fh>
use warnings; open $fh, \ "lala\nlulu"; join '|', <$fh>
use warnings; open my $fh, '>&=', 2
use warnings;  our $NEGATIVE_INDICES = 1; sub M::TIEARRAY { bless {}, shift } sub M::FETCH { print "Element $_[1]" }  tie my @arr, "M";   $arr["onetwothree"]
use warnings; pop INC
use warnings; print 'argh' and exit if $error;
use warnings; print("~/")."\n"
use warnings; print "\x{2603}"
use warnings; push INC, undef;
use warnings; qr{(?(DEFINE)(?<A>(?&B)|(?&C))}xms;
use warnings; qw(1,2,3)
use warnings qw(experimental); my sub foo { ... }
use warnings; readline "{a,b,c}"
use warnings; [ ref undef ]
use warnings; reset
use warnings; say undef
use warnings; scalar( 0, 1, 0, 1 );
use warnings; scalar( 2, 3, 4, 5 );
use warnings; scalar grep {     $_ == 0 or $_ % 2 == 0 or $_ % 3 == 0 or $_ % 5 == 0 or $_ % 7 == 0 } map eval, glob join '{+,-,}', split //, "7474810769";
use warnings; scalar grep {     $_ == 0 or $_ % 2 == 0 or $_ % 3 == 0 or $_ % 5 == 0 or $_ % 7 == 0 } map eval, map s{[^0-9]\K0([0-9])}{$1}gr, glob join "{+,-,}", split //, "7474810769";
use warnings; set_status => 'available';
use warnings; s///gI
use warnings; [ sort { $a != $a ? 1 : $b != $b ? -1 : $a <=> $b } 0, 7, "nan", 3 ]
use warnings; [ sort { $a <=> $b } 4, 15, 11, "NaN", 11, 2, 1, 4, 3, "nan", 8 ]
use warnings; [ sort { $a <=> $b } 7, 0, "nan", 3 ]
use warnings; [ sort { "NaN" } 4, 15, 11, 11, 2, 1, 4, 3, 8 ]
use warnings; splice @a, 2, 2, qw/foo bar/; \@a
use warnings; "string"->{key}
use warnings; ${\"string"}->{key}
use warnings; sub a { my $x=2; sub b { print $x } } a()
use warnings; sub a { my $x=2; sub b ($x) { my $x = $_[0]; print $x; } } a()
use warnings; sub f { my $foo .= "x" if shift; $foo .= shift; "$foo "; } f(0,0).f(0,1);
use warnings; sub f { my $foo .= "x" if shift; $foo .= shift; "$foo "; } f(1,0).f(0,1);
use warnings; sub foo {1} $x = foo and 1
use warnings; sub foo(){{}} %{foo}
use warnings; sub foo { @foos = 0; return @foos } @x = 'a' .. 'c'; [@x[foo()], $x[foo()]];
use warnings; sub foo { @foos = 0 } @x = 'a' .. 'c'; @x[foo()]
use warnings; sub foo { @foos = 1; return @foos } @x = 'a' .. 'c'; [@x[foo()], $x[foo()]];
use warnings; sub foo { @foos = 1 } @x = 'a' .. 'c'; [@x[foo()], $x[foo()]];
use warnings; sub foo(){{}} my %foo; %{foo}
use warnings; sub foo { my $x = 1; sub bar {my $y = 2;}}; foo(); bar();
use warnings; sub foo { my $x = 1; sub bar {my $y = $x} }
use warnings; sub foo { my $x = 1; sub bar {$x++}}; foo(); bar();
use warnings; sub foo (&@) { sub foo; }
use warnings; sub format {} format
use warnings sub get_var { warn "GET VAR\n"; return \my $var }   ${ get_var } += 1
use warnings; sub get_var { warn "GET VAR\n"; return \my $var }   ${ get_var } += 1
use warnings; sub index { ... } index "asdf", "d"
use warnings; sub index :index { ... } index "asdf", "d"
use warnings; sub index :method { ... } index "asdf", "d"
use warnings; sub index :method { ... } main::index
use warnings; sub index :method { scalar @_ } main::index qw( A B C D E )
use warnings;  sub M::TIEARRAY { bless {}, shift } sub M::FETCH { print "Element $_[1]" }  tie my @arr, "M";   $arr["onetwothree"]
use warnings; sub mynumbs (@$;$);
use warnings; sub push :method { ... }  my @array; push @array, "value";
use warnings; sub push { ... }  my @array; push @array, "value";
use warnings; sub strftime {} use POSIX qw(strftime);
use warnings; sub test { $_[0] < 0 and return } test('a')
use warnings; "@things"
use warnings; !!undef
use warnings; [ undef == 0 ]
use warnings; undef @foo;
use warnings; $undefined =~ s//bar/;
use warnings; undef =~ s//foo/r;
use warnings; [undef, ''.undef]
use warnings; use constant cat => 15; cat while $x++<1
use warnings; use constant cat => 1; cat while $x++<1
use warnings; use constant cat => 1; cat() while $x++<1
use warnings; use Encode; my $buf = encode('UTF-8', "\x{666}"); open my $fh, '<', \$buf or die "open: $!"; printf "%vx", <$fh>;
use warnings; use Encode; my $buf = encode('UTF-8', "\x{666}"); open my $fh, '<:encoding(UTF-8)', \$buf or die "open: $!" #fine, Grinnz_
use warnings; use Encode; my $x = qq<\x{100}>; [ unpack q{H*}, Encode::encode_utf8 $x ]
use warnings; use Encode; my $x = qq<\x{100}>; [ unpack q{H*}, $x ]
use warnings; use experimental 'smartmatch'; "foo" ~~ "Bar"
use warnings; use Function::Parameters qw(:strict); fun mynumbs :(@$;$) {}
use warnings; use List::Uil 'max'; my ($x, $y, $var) = (42, 37, 0); $var += max $x, $y; $var
use warnings; use List::Util 'max'; my ($x, $y, $var) = (42, 37, 0); $var += max $x, $y; $var
use warnings; use Moose; has foo => (isa => 'rw); $x = $main->new; $x->foo(undef)
use warnings; use POSIX qw(strftime); use POSIX qw(strftime);
use warnings; use strict; "foo bar" =~ /(?<A>\w+)/ or die; print "outer1: @{[%+]}; "; { "baz" =~ /(?<B>failed match)/ or die; print "inner: @{[%+]}; "; } print "outer2: @{[%+]}; ";
use warnings; use strict; "foo bar" =~ /(?<A>\w+)/ or die; print "outer1: @{[%+]}; "; { "baz" =~ /(?<B>failed match)/; print "inner: @{[%+]}; "; } print "outer2: @{[%+]}; ";
use warnings; use strict; "foo bar" =~ /(?<A>\w+)/ or die; print "outer1: @{[%+]}; "; { "baz" =~ /(?<B>\w+)/ or die; print "inner: @{[%+]}; "; } print "outer2: @{[%+]}; ";
use warnings; use strict; "foo bar" =~ /(?<A>\w+)/ or die; print "outer1: ${\\%+} @{[%+]}; "; { "baz" =~ /(?<B>\w+)/ or die; print "inner: ${\\%+} @{[%+]}; "; } print "outer2: ${\\%+} @{[%+]}; ";
use warnings; use strict; my @arr; $arr[-1] = 'foo';
use warnings; use strict; my $bar; if (my $foo = $bar) { 1 }
use warnings; use strict; my $fh; print $fh 42
use warnings; use strict; my (our $x) = 42; [$x, $::x]
use warnings; use strict; my $str = 'afgasfasdf{afsfasdfsdafasf}asdfasfasdf'; my ($blah) = $str =~ m#^.*?{(.*?)}#; $blah
use warnings; use strict; my $str = 'afgasfasdf{afsfasdfsdafasfasdfasfasdf'; my ($blah) = $str =~ m#^.*?{(.*)#; $blah
use warnings; use strict; my $x = UNIVERSAL->can('can'); ''->$x('can')
use warnings; use strict; my %x; $x{1}++;
use warnings; use strict; my $x; $x++; $x
use warnings; use strict; our (my $x) = 42; [$x, $::x]
use warnings; use strict; package Don; sub t { 'cats' } package main; Don't;
use warnings; use strict; { package Foo; sub TIESCALAR { '/foo/bar' } } tie my $var, Foo::
use warnings; use strict; { package Foo; sub TIESCALAR { '/foo/bar' } } tie my $var, Foo::; "$var"
use warnings; use strict; sub foo{{}} %{foo}
use warnings; use strict; sub foo { my $x; BEGIN { $x = 42; } $x++ } [ foo, foo ]
use warnings; use strict; sub test($hr) { print Dumper(%$hr); }
use warnings; use strict; { test => sub { print shift }, color => 'blue' }->{color}->("bar")
use warnings; use strict; { test => sub { print shift } }->{test}->("bar")
use warnings; use strict; use experimental 'postderef'; my $x; my @z = @{ $x || [] }; $x->@*
use warnings; $^V < 5.013006 ? "y" : "n"
use warnings; $^V < 5.13.6 ? "y" : "n"
use warnings; $^V < 5.136 ? "y" : "n"
use warnings; v6.0.1 < 4
use warnings; ${^WIBBLE}{wat} = 42; [ keys %{^wibble} ]
use warnings; ${^WIBBLE}{wat} = 42; [ keys %{^WIBBLE} ]
use warnings; $worldlen > 20
use warnings; "$x"
use warnings; $x
use warnings; $x=0;121321 while $x++<1
use warnings; $x = !0 + 1; $y = !0 . ''
use warnings; $x = [ 0 ]; $x->[0][2]
use warnings; $_="\x19"; $_="$_\x00"; print unpack "B*", $_&"\x80\x00"
use warnings; $x = 1 and 1
use warnings; $x = 1; @bucket_store_content{ $x }
use warnings; $x = "32 string"; $y = 43; $x + $y
use warnings; $x[3] = 9; [exists $x[0], exists $x[4]];
use warnings; $x=[4,5,6]; @$x[0]
use warnings; $x = "4"; $y = "3"; $l = $x . $y; $s = $x + $y; print $l print $s
use warnings; $x .= "hallo";
use warnings; $xml->{sessions}{session}{'status'}
use warnings; @x = qw(a b); splice @x, 2, 0, 'c'; \ @x
use warnings; $x = @x[0]
use warnings; $x x101
use warnings; $x == $y
use warnings 'y2k'; "19" . (localtime)[5];
use warnings; @y = (42); $x = delete $y[0]; [ $x, \@y ]
use x $^W++;join(($x)x101)
"U+" . sprintf "%*v04X", " U+", "hello"
#!/usr/bin/perl -w                                      # camel code
[ '/usr/local/bin/openerp-server' =~ m{([^/]+)$} ]
utf8::downgrade(my $o = "\x{f4}"); $o
utf8::downgrade(my $o = "\x{f4}"); use Data::Dumper; Dumper($o)
utf8::encode(chr(2<<15))
utf8::encode(my $s = chr(2<<15)); $s
utf8::is_utf8 chr 255
utf8::is_utf8 chr 321
utf8::upgrade(my $o = "\x{f4}"); $o
utf8::upgrade(my $o = "\x{f4}"); use Data::Dumper; Dumper($o)
'ü' =~ /\w/
'ü' =~ /\w/a
"ü" xor "ü"
["ü" xor "ü"]
"$^V"
[ $^V ]
[ %{ $^V } ]
[ %$^V ]
[$^V]
$V
$^V
[$^V, ~0]
$v = 0x100202020; $v =( ($v << 1) & 0xFFFFFFFF) | (($v >> 31) & 0x1); sprintf "%08X", $v
$v = 0x100202020; $v =( ($v << 4) & 0xF) | (($v >> (32-4)) & 0x7); sprintf "%08X", $v
$v = 0x10202020; $v =( ($v << 1) & 0xFFFFFFFF) | (($v >> 31) & 0x1); sprintf "%08X", $v
$v = 0x10202020; $v =( ($v << 4) & 0xFFFFFFFF) | (($v >> (32-4)) & 0x7); sprintf "%08X", $v
v112.97.110
v116.104.120.32.112.105.110.107.95.109.105.115.116
[v1.2.3]
v1.2.3
v="123 abc"; echo "${v//[^0-9]/}";
[ v127.0.0.1 ]
v137.80.78.71.13.10.26.10
$^V^2
v5.14.0
v5.22.0
v84.114.97.99.107.105.110.103.45.78.117.109.46.46.46.32
vA.10 <=> vB.9
vA.10 < vB.9
$val = 'a'; [map $val++, 1 .. 3]
$_ = '"Validation25",,,,,1,1,1,1,,'; s/,(?=,)/,\\N/g; $_
@values = (1, 0, 1, 1); $n = 0; $idx = $#values; $n += $_ * (2 ** ($#values - $idx)), --$idx foreach reverse @values; $n;
@values = (1, 0, 1, 1);  $n = 0; ($n *= 2) += $_ for reverse @values; $n;
$var = 0; $var = ! $var;
$var1 = ''; $var2 = 0; $var3 = undef; [ defined $var1, defined $var2, defined $var3 ]
$variable = sprintf "%04o\n",0777;
$varname="raddtiz"; print "$varname lol"
$var = 'original '; print $var; { local $var = 'replacement '; print $var }; print $var;
$var =[]; ref \$var
$var = []; [ref $var, ref \$var]
$var = *STDOUT; ref \$var
$var = *STDOUT; [ref $var, ref \$var]
$var = \*STDOUT; [ref $var, ref \$var]
*var = \substr $_, 0, 1; ref \$var
vec($_,7,1)=1; [unpack "s>", $_]
vec($_,8,1)=1; [unpack "s>", $_]
vec($_,9,1)=1; print $_
vec($_,9,1)=1; print ord $_
vec( my $x, 4, 4 ) = 1; printf '%*08b', ' ', $x;
vec( my $x, 4, 4 ) = 1; printf '%*v08b', ' ', $x;
vec( my $x, 4, 4 ) = 8; printf '%*v08b', ' ', $x;
vec($str, $_, 8) = rand 256 for 0 .. 5; [split //, $str]
[ 'version'->can('(""') ]
version->new("0.01_002")->numify
[version->parse('1.000001')->normal, version->parse('v1.0.1')->normal]
[ version->parse("1.023-TRIAL") ]
version->parse('2.08-TRIAL') # not that well, although CPAN itself knows enough to treat it as a dev release
version->parse($])->normal # same as $^V
[version->parse('v0.01'), version->parse('v0.1'), version->parse('v0.10'), version->parse('0.10')]
version->parse('vA.10.0')->normal
version->parse('vA.10')->normal
version::qv('5.22.0')
[$^V, $^O]
'<' =~ /[[:vowel:]]/
$v = unpack('C', pack('B8', '11111111')); $v
$w = 3; $h = 4; @out = ( (0) x $w ) x $h; \@out
$w = 3; $h = 4; @out = ([ (0) x $w ]) x $h; \@out
$w = 3; $h = 4; @out = (\( (0) x $w )) x $h; \@out
$w = 3; $h = 4; @out = map [ (0) x $w ] 1..$h; \@out
$w = 3; $h = 4; @out = map [ (0) x $w ], 1..$h; \@out
wantarray
wantarray ? "list context" : defined wantarray ? "scalar context" : "void context" # there, made it more clearer
"${\( wantarray() ? 'list' : 'scalar' )}->()}"
"${\( wantarray() ? 'list' : 'scalar' )}"
wantarray() ? 'list' : 'scalar'
wantarray ? "yes" : defined wantarray ? "no" : "maybe"
warn
warn "hello"
warn "hello\n"
warn "test " . join(", ", @INC) . "\n";
warn undef
$^W++;eval "0".".undef"x101
'/**' =~ /^\/\*\*/ # wfm
'wftedskaebjgdpjgidbsmnjgc' =~ tr/a-z/oh, turtleneck Phrase Jar!/;
$_ = "wftedskaebjgdpjgidbsmnjgc"; tr/a-z/oh, turtleneck Phrase Jar!/; print;
$_ = "wftedskaebjgdpjgidbsmnjgc";tr/a-z/oh, turtleneck Phrase Jar!/; print;
'wftedskaebjgdpjgidbsmnjgc' =~ tr/a-z/oh, turtleneck Phrase Jar!/r;
@what = ([a,b],[1,2],[3,4]); [ map { s/_//r=~s/_/, /gr } glob join '', map { $"=',_'; "{_@$_}" } @what ]
[$whatever++]
while ( 1 ) { print "Don't break\n"; }
while(@ARGV){@ARVG[1] = "test"; print "true"; exit()}
while(@ARGV){print "true"; exit()}
'while cloud dark CLoud fluffy CLOUD ClOuD' =~ s/(cloud)/ (~($1 & ' ' x length $1) ^ ' ' x length $1) & lc 'butt' /egir
while(my $e = glob "{foo,bar}") {print $e, "    "}
while((my $pid = -1) > 0) { print $pid } "done"
while ('peas and carrots' =~ /([aeiou])(.)/g) { push @bar, [ $1, $2 ] } \@bar
while ('peas and carrots' =~ /(?<v>[aeiou])(?<n>.)/g) { push @bar, { %+ } } \@bar
 while (($x < 10)) { ($y = $x); say($x); } continue { ($x += my $y) }
whoami
`whoami`
"who knows?"
"wibble" =~ s/wi(b+)/{"a".("g"x length $1)}re
"wibble" =~ s{wi(b+)}{"a".("g"x length $1)}re
$^W++;join(($x)x101)
'word $3' =~ /^\w+ \$\d$/
'word $3' =~ /^\w+\s\$\d$/
$word = 'hangman'; $sofar = $word =~ s/./_/gr; for $guess (qw(n m z a g h)){ $sofar ^= $word =~ s/[^$guess]/\0/gr =~ s/$guess/$guess ^ '_'/ger; print "$sofar  " }
['"words in quotes"' =~ /\b(\w+)\b/g ]
["worker1worker2" =~ /^(worker[0-9],?)+$/]
["worker1worker2" =~ /(worker[0-9],?)+/]
["worker1worker2" =~ /^(worker[0-9],?)\1*$/]
["worker1worker2" =~ /(worker[0-9],?)\1*/]
$_ = ' worker.loadbalancer.balance_workers=  worker_1,worker_2,worker_3,worker_4,worker_5'; my (@out, @tmp); m{ \A \s* \Qworker.loadbalancer.balance_workers=\E \s* (worker_[0-9]) (?{ push @tmp, $1 }) (?: , (worker_[0-9]) (?{ push @tmp, $2 }) )* \z (?{ @out = @tmp }) }x; [ @out ]
... works too
$worldlen > 20
write($sock, $request, length($request));
%wrong = +{}; \%wrong
[$^W, $^S, $^F]
$w="specific"; $len=length $w; for my $i (0..$len-1) { for my $j (1..$len-$i) { push @parts,substr $w,$i,$j}} \@parts
$^W + $^T + $^F
$::{wtf} = \*hi; wft();
$::{wtf} = \"hi"; wtf()
"$x"
"\x<"
"\x"
[x=>~~[]]
$x
$x->()
\$x
++$x
$^X
$^X = "<_<";
$x**0
/x{00}/
/x{01}/
$x = '0.101010101110011'; hex("0b$x")/2**(length($x) - 2)
"\x{0265}\x{01DD}\x{028E}"
$x = '042'; [ $x, "$x" ]
@x = (0 .. 5); [\@x, $#x, scalar @x]
${"\x{06}"} = 1; ++${"\x{06}"};
@x = (0 .. 9); pop @x;
@x = (0 .. 9); shift @x;
["\x0a"]
$x = 0b00001000; $x >>= 1; sprintf '%08b', $x
$x = 0; for (1..1000) {$x += 0.01;}; for (1..1000) {$x -= 0.01}; $x
$x = 0; for (1 .. 1000) { $x += 0.01; } $x
$x = 0; [ map {; $x += 1/(2**$_); $x } 1..64 ]
$x = 0; [ map {; $x += 1/(2**$_); $x } 1..8 ]
$x = 0; [ map {; $x += 1/(2**$_); $x =~ /\.(9*)/ ? length($1) : -1 } 1..64 ]
$x = [ 0 ]; $x->[0][2]
'x' =~ /./; [$1]
[ %x{1} ]
[x=>~~-1]
$x[-1]
/x{10}/
"x"=~/\{10}/;
"\x{100}"
$x = '10.12'; $x =~ s/\..+$//; $x
"\x{10c}\x{e1}ste\x{10d}n\x{11b} schv\x{e1}leno"
$x[10e10]++
[ ('?') x 10 ] # magic ()
[ ('?' x 10) ] # the () do nothing
$x = 10; while ( $x --> 0 ) { push @arr, $x } \@arr
x = 10 || (x > 20 && x < 30)
$x = 10; $y = 9; [ [$x, $y], $x <= $y, [$x, $y]->[""] ]
$x = 10; $y = 9; [ [$x, $y], $x <= $y, [$x, $y]->[$x <= $y] ]
@x=(11,12,13); grep { s/1/9/ } @x; \@x
$x = '11223344'; join( '+', map {  join('-', map { $_  } split //) } $x =~/../g);
$x='${\1+1}'; eval qq{ "\Q$x\E" }
@x = (12, 13); sprintf '%d %d', @x
@x = (1, 2, 1); delete @x[@x]; \@x
@x = (1, 2, 3,4 ,5 , 6, 7, 8); foreach my $x (@x[0..2]) { print $x; }
@x = (1, 2, 3,4 ,5 , 6, 7, 8); @x[0..2];
@x=([[1,2],[3,4]],[5]); $x[1][0]
@x=([[1,2],[3,4]],[5]); $x[1][1]
@x=([[1,2],[3,4]],[5]); $x[1][2]
@x=(1,2,3,4,5); [$x[-20], \@x]
@x=(1,2,3,4); scalar @x
$x = (1, (2, 3), 5);
$x = [1,2,3]; Data::Dumper::Dumper([$x, $x])
@x=(1,2,3); delete @x[0,2]; \@x
@x=(1,2,3); delete $x[1];
@x=(1,2,3); delete @x[1,2]; \@x
@x=(1,2,3); delete @x[1]; \@x
@x=(1,2,3); delete $x[1]; \@x
$x = '1.23'; $x =~ s/\D+//g; $x
$x = () = (1,2,4); print($x)
$x = 12; { ++local($x) } $x
[{x => 12}, {x => 13}, {x => 14}]
$x = "1   2"; @y = split(' ', $x); print "$x[0], $[x1]";
$x = "1   2"; @y = split(' ', $x); print "$y[0], $y[1]";
@x = (1..547); say length @x
@x = (1..547); say scalar @x
@x = 1 .. 6; scalar @x
@x = (1 .. 8); print @x[0..2];
$_="\x19"; $_="$_\x00"; print unpack "B*", $_&"\x80\x00"
$_="\x19"; $_="$_\x00"; print "yes" if $_&"\x80\x00"
"\x{1f441}\x{200d}\x{1f5e8}"
"\x{1F478}\x{200D}\x{2764}\x{FE0F}\x{200D}\x{1F48B}\x{200D}\x{1F438}"
"\x{1F64C}"
$x = 1; sub { @_[0] = 2; }->($x); print $x
$x =1; $x *= (2**2**$_ + 1) for 1 .. 4; $x
$x=1; $x *= $_ for 2..10; $x
$x=1; $x = \$x; $$x=2; $x
{} x 2
$x = "2015-0223"; substr($x,7,0) = "-"; $x
$x = 20; [ ++$x, $x++, $x ] # wheeee
@x = (2, 1, 2); delete @x[@dup = @x]; \ @x # this one is right
@x = (2, 1, 2); delete @x[@x]; \ @x # right
@x = (2, 1, 2); delete @x[@x]; \ @x # wrong!
'\x21\x21' =~ s/(.)/qq("$1")/eer
'\x21\x21' =~ s/(.*)/qq("$1")/eer
'\x22\x22' =~ s/(.*)/qq("$1")/eer
"\x{22}\x{31}"
@{ $x->[2] } = (4, 5); $x
["\x27"]
($x = 2903000)/($y = 2903000)*100
$x='\"2+@'; eval qq{ "\Q$x\E" }
'\x2F\x76\x69' =~ s/\\x([[:xdigit:]]{1,2})/chr hex $1/ger
$x[3] = 123; [keys @x]
@x = 31 .. 33; scalar @x
$x = "32 string"; $y = 43; $x + $y
@x = (3, 4); print scalar @x
@x = (3, 4); print scalar @x[0,1];
$x = 3; $cond = '$x == 3'; print "$cond is true" if (eval $cond) # still, though -- ugh
('?') x 4
[ ('?') x 4 ]
[ ('?'x4) ]
'\x40\x40' =~ s/(.*)/qq("$1")/eer
'\x41\x41'
'\x41\x41' =~ s/(.*)/qq("$1")/eer  # /me ducks
'\x41\x41' =~ s/\\x([0-9a-fA-F]{2})/pack 'H*', $1/rge;
'\x41\x41' =~ s/\\x(\d\d)/chr hex $1/rge;
'\x41\x41' =~ s/\\x(\d\d)/hex $1/ge;
'\x41\x41' =~ s/\\x(\d\d)/pack 'H*', $1/rge;
'\x41\x41' =~ s/\\x(\d\d)/pack 'HH', $1/rge;
'\x41\x41' =~ s/(\\x..)/'qq('.$1.')'/rgee;
'\x41\x41' =~ s/(\\x..)/qq($1)/rgee;
'\x41\x41' =~ s/(\\x..)/qq(qq($1))/rgee;
'\x41\x41' =~ s((\\x..))(qq(qq($1)))rgee; # lisp-y?
$x = 42; $first3 = ($x & 56) >> 3; $last3 = $x & 7; [ $first3, $last3 ]
$x = 42; sub foo { $x += 23 } { local $x; foo() } $x
$x = 42; $x /= 2; $x
$x = 42; "x is ${\$x}, eh"
$x = 42; $x_ref = \$x; ${$x_ref} = 37; [ $x, $x_ref ]
$x = 42; $x_ref = \$x; [ $x_ref, ${ $x_ref } ]
$x=[4,5,6]; @$x[0]
$x=[4,5,6]; $$x[0]
$x = [4, 5, 6]; @$x[0, 1]
$x = 4; $x //= 3;
(' ') x 5
[ " " x 5 ]
[ (' ') x 5 ]
[ (" ") x 5 ]
["_ " x 5]
[(" ") x 5]
[("_ ") x 5]
["#" x 50 . "\n"]
["#"x50."\n"]
[("_ ") x 5] [16:44] <perlbot> Altreus: ["_ ","_ ","_ ","_ ","_ "]
$x=5; qq'$x'
$x = 6.7233 * 1.22345;
$x = 6.7233 * 1.22345; [ sprintf("%f", $x), unpack("H*",$f) ]
$x = 9; $y = 10; [ [$x, $y], $x <= $y, [$x, $y]->[1] ]
$x={'{a}'=2}; $x->{{a}};
%x = (a => 3, b => 4); print scalar %x
%x = (a => 3, b => 4); print scalar @x{'a','b'}
%x = ( 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'); my @sortedkeys = sort(keys(%x)); my $highestkey = $sortedkeys[-1]; print $highestkey;
%x = ( 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'); my @sortedkeys = sort(values(%x)); my $highestkey = $sortedkeys[-1]; print $highestkey;
%x = ( 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'); print sort { $a cmp $b } keys %x;
%x = { 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'}; print sort { $a cmp $b } keys %x;
%x = { 'a'=>8, 'b'=>3, 'c'=>9, 'd'=>'2'}; print $x{'c'};
$x = "a a a a a a"; $x =~ s/a/x/3;print $x
$x = () = 'å' =~ /[åä]/g
$x="aa";++;print ++$x
$x="aa";++$x;print ++$x
$x = { 'a.b' = 'c' }
$x = 'abcdefg'; substr($x, 2) =~ y/a-z/A-Z/; $x
$x = "abcdfghi"; substr($x, 4, 0, 'e'); $x
$x="abcdfghi"; $x=~s/(abcd).*(fghi)/$1e$2/g; print $x;
$x="abcd"; push @{$x{j}}, split(//,$x); print join("", @{$x{j}}[2,3]), "\n"
$x="abcd"; push @{$x{j}}, split(//,$x); print join("", @{$x{j}}[2..3]), "\n"
$x->{abc} #so it might
$x->{abc}; $x
@x = 'a' .. 'c'; sub lala { my ($aref) = @_; "@$aref" } lala \@x
%x=(a=>undef); exists $x{a}
$x = { a => 'value', b => $x->{a} }; $x
$x->{a}; $x
$x = "banana"; \substr($x, 2)
$x = bless [], 'ARRYY(0xDEADBEEF)'; ref $x
$x = bless {}, "Banana"; ["$x", $x =~ /t/]
$x = bless {}, "Banana"; [$x, $x =~ /t/]
$x = []; bless $x, "$x"; ref $x
$x = []; bless $x, $x; ref $x
"\x^C"
"\xc6"
["\x{cf}", "\xcf" ]
$x = chr(0xC6); Encode::encode_utf8($x)
$x = chr(0xC6); unpack "H*", Encode::encode_utf8($x)
$x = chr 0xcf; $y = chr 0xcf; Encode::_utf8_on($x); Encode::_utf8_off($y); [$x, $y]
"\xd1"
$x="@" . "{[ die 'horribly' ]}"; eval qq{ "\Q$x\E" }
$x="@{[ die 'horribly' ]}"; eval qq{ "\Q$x\E" }
[ $^X, $EXECUTABLE_NAME ]
@x=([],{},$",\&f,\0);s/..(..).*/$1/ for@x;$"="";"@x"
$"="";@x=([],{}," ",\&f,\0);s/..(..).*/$1/ for@x;"@x"
"\xF0\x9F\x99\x8C"
"\x{f4}"
"\xf6"
"\xFE\xAB"
"\xff"
@x = (foo => 1, bar => 2); print ${{@x}}{"foo"}
@x = (foo => 1, bar => 2); ${{@x}}{"foo"}
@x = ( {foo => 1} ); $x[0]->{foo}
@x = (foo => 3, bar => 4); ${{[a=>2, b=>3]}}{"foo"}
@x = (foo => 3, bar => 4); ${[foo=>2, bar=>3]}{"foo"}
@x = (foo => 3, bar => 4); ${{[foo=>2, bar=>3]}}{"foo"}
@x = (foo => 3, bar => 4); ${{@x}}{"foo"}
$x = \@Foo::bar; delete $Foo::{bar}; @$x = "meow";
@x = (foo => "fooval", bar => "barval"); print +{@x}->{"foo"}
$x = \@{"Foo::ISA"}; delete $Foo::{ISA}; @$x = "Bar"
$x="foo\n"; [ $x, chomp $x ];
$x="foo\n"; [ $x, chomp $x, $x ];
$x{foo}++, $x{foo}
$x = "foo"; [ $x, $x =~ s/foo/bar/r ]
$x{$_}++ for qw[a b c]; \%x
@x = grep /[^\Wt]/, qw<q w t 6 ! . X>; [@x]
@x = 'hello'; my @y = $x[@x] = 'world'; [ \@y, \@x ]
[ ('?'x@ids) ]
$x = { key => 'value' }, push @{$x->{foo}}, 'bar'; push @{$x->{foo}}, 'baz'; $x
$x = "lala"; *$x = "cat"; $lala
$x = "lala"; *$x = \"cat"; $lala
$x = "lala"; *$x = sub {2*3}; lala();
$x = 'loooong'; substr($x, 4, 0) = 'XX'; # substr is an lvalue
$x = 'loooong'; substr($x, 4, 0) = 'XX'; $x ; # substr is an lvalue
[*::X, *main::X, *::main::X, *main::main::main::main::X]
@x = ( map ord, split //, 64.64.64.5000000000.64.64.64 );  $x = join ",", @x;  print "$x\n"
$x = "\n"; chomp $x; [$x]
[ "x\n   \t \t   \n \n\n\n\n\n\n\ny" =~ /^(.*)\s*$/gm ]
[ "x\n   \t \t   \n \n\n\n\n\n\n\ny" =~ /^\s*(.*)$/gm ] # like this?
[ "x\n   \t \t   \n \n\n\n\n\n\n\ny" =~ /^\s*(.*)\s*$/gm ] # so perhaps you wanted \h instead of \s?
$x = "(??{print 42})"; "banana" =~ /$x/
$x = qr/^cats$/
$x = qr/lala/; $xx = qr/$x/; [$x, $xx]
$x = qr/something/; "that's something" =~ $x
"X\\Q(s)Y" =~ qr'\Q(s)' ? [$`, $&, $'] : "no"
"X\\QsY" =~ qr'\Q(s)' ? [$`, $&, $'] : "no"
@x=qw(a b c); push @x, shift @x; "@x"
@x=qw(a b c); push @x, shift @x; @x
@x=qw(a b c); sub z{$_[0]=5;} z(@x); \@x
@x=qw(a b c); unshift @x, pop @x; "@x"
@x{qw{a b c}}++; \%x
@x=qw(a b c); $x=@x;($y)=@x;[$x,$y]
@x=qw/a b c/; $z=[@x[0,1]]; for(@$z){$_++; print} \@x
@x=qw/a b c/; $z=[@x[0,1]]; for(@$z){$_++} \@x
@x=qw( a b ); print push @x, 'c'
@x{qw/foo bar baz/}=(); \%x
@x{qw/foo bar baz/})=(); \%x
@x = qw{' . "@INC" . '}; \ @x
$x = ''; $ref = \$x; [ "".$ref, "". \${$$ref} ]
$x = ''; $ref = \$x; [ "".\$ref, "". \${$$ref} ]
$x = { site => 'lol' }; $y = "foo";  "lefoobar" =~ s/$y/$x->{site}/r
$x = {}; sprintf "%s %x", $x, $x
$x = sub { 3 } $x->() + 1
$x = sub { 3 }; $x->() + 1
$x = [ sub { 'here ' . shift } ]; $x->[0]->('we go')
@x=([],{}," ",sub{},\"");map{s/..(..).*/$1/}@x;"@x"
$"="";@x=([],{}," ",sub{},\"");map{s/..(..).*/$1/}@x;"@x"
$"="";@x=([],{}," ",sub{},\"");s/..(..).*/$1/ for@x;"@x"
$x = 'text25more text25fdsdf'; $x =~ s/text(\d+)more text(\1)fdsdf/'foo' . ($1 * $1)/e; $x
' ' =~ /[ ]/x ? 'T' : 'F';
%x = (this => {0..3}, that => {'a'..'d'}); \%x;
@x = "This" =~ s/(.)/sprintf "%b ", ord $1/gre; [@x]
@x = "This" =~ s/(.)/sprintf "%b ", ord $1/gre; [@x] is it a command ?
$x = 'three'; $y = \$x; $x = \$x; [ $x, $y ]
$x = \undef; "$x"
$x = undef; $x //= 3;
@x[$wa = wantarray]; $wa
[ $x++, $x ]
$x = {} [ "$x", 0+$x ]
$x = {}; [ "$x", 0+$x ]
@x = $x || (12, 13, 14); \ @x
 @x = "\x{2019}"; push @x, ($x[0] =~ s/\x{2019}/'/r); [@x]
[ 'x' x 5 ]
$x = "\x65\x66\x67";
$x = "\x65\x66\x67"; eval "qq($x)" # not recommended
@x = "xAyxByxCy" =~ /x(.)y/g; $1 # last capture, not first
[ 'XX' =~ /((?i)x)x/ ]
"xx: m:q" =~ /(^[a-z367]*?: |\s|^)(?:m|mixer):(\S+)/; [$1, $2]
'xxS01E32yy' =~ s/S01E([0-9][0-9])/"S01E" . ($1*2) . "E" . ($1*2 + 1)/er
'xxS01E32yy' =~ s/S01E([0-9][0-9])/"S01E" . $1*2 . "E" . $1*2 + 1/er
[ ++$x . '', ++$x . '', ++$x . '' ]
[ ++$x, ++$x, ++$x ]
[$x++, $x++, $x++]
"xxx" + 5
"\x<\x-\xc\xt\xr\xc"
{ "XXX" =~ /(.*)/; } print $1
$_ = "x!xx!x!x!"; my $state = 0; s/(\w)/++$state % 2 ? (uc $1) : (lc $1)/ge; $_
"x x xx xxx xxxxx\n" =~ /^\s*(?:((?(1)(?(3)(?(2)\2|\3)(\1)|(\S))|\S))\s+)+$/ ? "\\o/" : ":-("
"x x xx xxx xxxxx\n" =~ /^\s*(?:((?(1)(?(3)(?(2)\2|\3)(\1)|(\S))|\S))\s+)+$/ ? "\o/" : ":-("
"x x xx xxx xxxxx xxxxxxxx\n" =~ /^\s*(?:((?(1)(?(3)(?(2)\2|\3)(\1)|(\S))|\S))\s+)+$/ ? "a fibonacci sequence" : "bzzt"
$x = 'XYZ XYZ XYZ'; $y =()= $x =~ /XYZ/g; $y
\$x = \$y
'x' =~ /(y?)/; [$1]
'x' =~ /(y)?/; [$1]
[ ($x, $y) = 5 .. 10 ]
($x, $y) = 'abc' =~ /(..)(.)/; [$1, $2] # $1, $2 are populated even when storing the values elsewhere
($x, $y) = qw(a b c d)
$x="y"; [ ++$x ]
%x = { "y" => "z" }; $x{"hey"} += 5; print $x{"hey"};
[ 'xyzzy' =~ /(\w)\g{1}/ ]
'xZx' =~ m'Z'
'xZx' =~ m"Z"
$x="z"; $x++; $x
$x = 'zzz'; $x++; $x
@y = (1, 2, 3); \ @y
@y = 1, 2, 3; \ @y
$y=1; *x = (sub { \@_ })->($y); $x[0] = 2; print "$y\n";
$_ = "yes" ; y/e/é/; $_
$_ = "yes" ; y/e/é//; $_
$y="one"; $z = undef; $y = $z || ''; print $z;
$y="one"; $z = undef; $y = $z || undef; print $z;
\"you"
you can use sprintf
your code
$y; { use strict; $x }
$z=new IO::Handle; "$z"
[ "Zoffix doubts that map example works" =~ /(?=(..))/sg ]
'zoom' =~ m moom
$z='the quick brown fox jumped over the lazy dogs in leet speak'; $z=~s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $z;
$z='the quick brown fox jumped over the lazy dogs in leet speak'; $z = s/./$x=rand(3); $x>1?lc($&):uc($&)/eg; print $z;
$z=\$x; "$z"
[ "ΑRRΑΥ" ]
[ 'Ω' cmp 'Α' ]
"Я очень плохо говорю по русский"
